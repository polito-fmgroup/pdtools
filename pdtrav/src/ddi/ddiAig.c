/**CFile***********************************************************************

  FileName    [ddiAig.c]

  PackageName [ddi]

  Synopsis    [Functions working on AIGs]

  Description [Functions working on AIGs]

  SeeAlso   []

  Author    [Gianpiero Cabodi]

  Copyright [This file was created at the Politecnico di Torino,
    Torino, Italy.
    The  Politecnico di Torino makes no warranty about the suitability of
    this software for any purpose.
    It is presented on an AS IS basis.
  ]

  Revision  []

******************************************************************************/

#include "ddiInt.h"
#include "baigInt.h"
#include "tr.h"
#include "fsm.h"

// #include "SAT_C.h"
#include "Solver.h"
#include "Proof.h"
#include "File.h"

#include <time.h>


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/* Debugging Flags for the Above Method */
#define INTERP_DEBUG_MINISAT      0
#define CHECK_AIGCNF_LEVEL        0

#define ITP_FRONTIER_COMPOSE 1

int printCompose=0;
static int ncall=0;
static int recDepth = 0;

    static int cntDbg=0, observed = -1;

static int implCalls=0;
static int implCallsMax=1000000;


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

typedef struct {
  int foCnt;
  int *foIds;
  char *isPathNext;
  int fiIds[2];
  int isFiPrev[2];
  int visited;
  int flowVisited;
  int pathPrev;
  int pathNext;
  int bfVisited;
  int inLevel;
  int inLevelMin;
  int outLevelMax;
  int outLevel;
  int refInput;
  int cutIndex;
  char isTarget;
  char isInput;
  char lockedInput;
  char isSmoothInput;
  char isSmooth;
  char isMinCut;
  char isShortEdgeCut;
  char isShortEdge[2];
  char noFlowRegion;
  char noCutRegion;
} mincut_info;


typedef struct {
  long decisions,
       conflicts,
       propagations,
       learnts_literals;
  int nCached, nChecks, nRed, nAbort;
} redrem_stats;

typedef struct {
  int i;
  int val;
} listWithI_t;

typedef struct {
  listWithI_t listFirst[2];
  int foCnt, foImplCnt, fiImplCnt, fiTransImplCnt, foAux, foAux2;
  int *fo;
  int *foImpl;
  int *fiImpl;
  int *ldrCut;
  listWithI_t *link;
  int redGate;
  int clstLdr, clstLdr2;
  int lastIn;
  int redJoin;
  int ldrFiNum;
  struct {int r, l;} fi;
  bAigEdge_t baig;
} nnfGate_t;

typedef struct {
  int randRefinePeriod;
  bAig_array_t *aNodes;
  char *isCore;
  char *gateType;
  Ddi_Vararray_t *rV;
  Ddi_Vararray_t *aV0;
  Ddi_Vararray_t *aV1;
  Ddi_Bdd_t *nnfConstr;
} nnfCoreMgr_t;

typedef struct {
    bAigEdge_t aig;
  //    Ddi_Bdd_t *cube;
    Ddi_Bdd_t *orClause;
  //    int aigSize;
    char chainLevel;
    int isOdc;
    char optimized;
    char isAndCube;
    char isOrCube;
    char isLiteral;
    char isConst;
    char isTreeRoot;
    char AClause;
} interpolantNode_t;

static int
Minisat22FreezeVars (
  void    *Svoid,
  Ddi_Mgr_t *ddm,
  Ddi_Vararray_t *vA
);
static int
Minisat22FreezeAig (
  void    *Svoid,
  Ddi_Bdd_t *f
);
static int
Minisat22ReleaseEliminatedVars (
  void    *Svoid,
  Ddi_Mgr_t *ddm,
  bAig_array_t *cnfMappedVars
);
static void
Minisat22FreezeCnfVar (
  void    *Svoid,
  int cnfV
);
static void
Minisat22Eliminate (
  void    *Svoid
);
static Ddi_Bddarray_t *
aigArrayMakeFromMinisatLits(
  Ddi_Mgr_t *ddm,
  vec<Lit>& lits
);
static void
RestoreClausesAsAigs(
  Ddi_Mgr_t *ddm,
  vec<vec<Lit> > &clauses,
  Ddi_Bdd_t *partAig
);
static Ddi_Bddarray_t *
RestoreSavedAigNodes(
  Ddi_Mgr_t *ddm
);
static void
RestoreVarsAsAigs(
  Ddi_Mgr_t *ddm,
  Ddi_Bdd_t *auxAig,
  vec<Var>   &vars
);
static void
SaveClausesAsAigs(
  Ddi_Mgr_t *ddm,
  vec<vec<Lit> > &clauses,
  float ratio  
);
static void
SaveVarsAsAigs(
  Ddi_Mgr_t *ddm,
  vec<Var> &vars,
  Ddi_Vararray_t *vA
);
static void
AnalyzeCoreVars(
  vec<Var> &vars,
  Ddi_Bdd_t *f
);


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

typedef Ddi_MinisatAigCnfInfo_t aigCnfInfo_t;
typedef Ddi_MinisatAigCnfMgr_t aigCnfMgr_t;

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

//Ddi_Bdd_t *globalClass=NULL;
//Ddi_Bdd_t *globalNode=NULL;

//static int enCached=1;
//static int doingMinCut = 0;
//static int varSortByFlow = 1;

static int nItpCalls=0;

// static int cntCalls=0;

/* MUTUAL EXCLUSION access vars */

static int benchCount=0;

//  static int totncuts=0;

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

#define dMgrO(ddiMgr) ((ddiMgr)->settings.stdout)

#define bAigSwap(aig0,aig1) {\
  bAigEdge_t swap_tmp_aig = aig0;\
  aig0 = aig1;\
  aig1 = swap_tmp_aig;\
}

#define LglAddClause(L,lits) {\
  int _i, lglLit; \
  for (_i=0; _i<lits.size(); _i++) {		\
    lglLit = var((lits)[_i]) + 1; \
    if (sign((lits)[_i])) lglLit = -lglLit;	\
    lgladd (L, lglLit); \
  }\
  lgladd (L, 0);				\
}

#define MinisatSolverAddClause(S,lits) {\
  int _i;\
  for (_i=0; _i<lits.size(); _i++) {\
    while (var((lits)[_i])>=(S).nVars())(S).newVar();    \
  }\
  (S).addClause(lits);\
}

#define Minisat22SolverAddClause(S22,lits,lits22) {   \
  int _i, _var22; \
  lits22.clear();\
  for (_i=0; _i<lits.size(); _i++) { \
    _var22 = var((lits)[_i]); \
    while (_var22>=(S22)->nVars())(S22)->newVar();\
    lits22.push ((Minisat::mkLit(_var22,sign((lits)[_i]))));       \
    /* printf("%s%d ", sign((lits)[_i])?"-":"", _var22); */	   \
  }\
  /* printf("0\n"); */				\
  (S22)->addClause(lits22);\
}

#define Minisat22PrintClause(lits22) {   \
  int _i, _var22; \
  for (_i=0; _i<lits22.size(); _i++) { \
    _var22 = Minisat::var((lits22)[_i]);		\
    printf("%s%d ", Minisat::sign((lits22)[_i])?"-":"", _var22); \
  }\
  printf("0\n");	\
}

#define Minisat22Lit(l) \
  ((l)<0 ? ~Minisat::mkLit(abs(l)-1) : Minisat::mkLit((l)-1))

#define MinisatTo22(lits22,lits) {                  \
  int _i, _var22; \
  lits22.clear();\
  for (_i=0; _i<lits.size(); _i++) {		\
    _var22 = var((lits)[_i]); \
    lits22.push ((Minisat::mkLit(_var22,sign((lits)[_i]))));       \
  }\
}
#define MinisatFrom22(lits22,lits) {                  \
  int _i, _var; \
  lits.clear();\
  for (_i=0; _i<lits22.size(); _i++) { \
    _var = Minisat::var((lits22)[_i]);\
    lits.push (Minisat::sign((lits22)[_i])?~Lit(_var):Lit(_var));	 \
  }\
}

#define FileStoreClause(fp,lits) {\
  int _i;\
  for (_i=0; _i<lits.size(); _i++) {\
    fprintf(fp," %s%d", sign(lits[_i])?"-":"", var(lits[_i])+1); \
  }\
  fprintf(fp," 0\n");\
}
#define FileStoreClause1(fp,c) {\
  fprintf(fp,"%d 0\n", c);\
}

#define FileStoreClause2(fp,c0,c1) {\
  fprintf(fp,"%d %d 0\n", c0, c1);\
}

#define FileStoreClause3(fp,c0,c1,c2) {		\
    fprintf(fp,"%d %d %d 0\n", c0, c1, c2);		\
}


#define rightChildAuxInt(bmgr,baig) \
  bAig_AuxInt((bmgr),bAig_NodeReadIndexOfRightChild((bmgr),(baig)))
#define leftChildAuxInt(bmgr,baig) \
  bAig_AuxInt((bmgr),bAig_NodeReadIndexOfLeftChild((bmgr),(baig)))


#define minCutNodeSetNext(nodeInfoArray,node,next) \
{\
  int j;\
  nodeInfoArray[node].pathNext = next;\
  for (j=0; j<nodeInfoArray[node].foCnt; j++) {\
    if (nodeInfoArray[node].foIds[j] == next) {\
      nodeInfoArray[node].isPathNext[j] = 1;\
    }\
  }\
}


/*---------------------------------------------------------------------------*/
/* Zchaff section   - MC 25/10/2004 added */
/*---------------------------------------------------------------------------*/
// StQ 2010.07.07
//#define CLAUSE_SIZE  100
//#define LINE_SIZE    1000


/**AutomaticStart*************************************************************/

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static Ddi_Bdd_t *AigAbstrVarsForInterpolantByRefinementIntern (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Vararray_t *aVars, Ddi_Vararray_t *bVars, Ddi_Vararray_t *auxVars, char *wfileName, unsigned char *enAbstr,   unsigned char *enAbstrIn, unsigned char *doAbstrOut, int *nAbstrP, int *nInitAbstrP, int *undefP, int phase, int up_down);
static Ddi_Bdd_t *AigFromNnfFullAcc(Ddi_Bdd_t *f, nnfCoreMgr_t *nnfMgr);
static Ddi_Bdd_t * AigRedRemovalIncrementalAcc(Ddi_Bdd_t *fAig, Ddi_Bdd_t *care, int maxCutNum, int maxObserve, bAig_array_t *cachedNodes, float timeLimit, int doApproxOnAbort, int enableObservabilityDC, int redVal);
static Ddi_Bddarray_t * AigArrayRedRemovalIncrementalAcc(Ddi_Bddarray_t *fAigarray, Ddi_Bdd_t *care, int maxCutNum, int maxObserve, bAig_array_t *cachedNodes, float timeLimit, int redVal);
static void MinisatAssume(Ddi_Bdd_t *f,vec<Lit>& assumps);
static void AigRedRemovalIncrementalIntern1(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, bAigEdge_t fBaig, bAigEdge_t careBaig, int maxCutNum, int maxObserve, int *enChk, int *nRef, bAig_array_t *cachedNodes, redrem_stats *rrStatsP, float timeLimit, int doApproxOnAbort);
static void AigRedRemovalIncrementalIntern(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, bAigEdge_t fBaig, bAigEdge_t careBaig, int maxCutNum, int maxObserve, int *enChk, int *nRef, bAig_array_t *cachedNodes, redrem_stats *rrStatsP, float timeLimit, int doApproxOnAbort, int enableObservabilityDC);
static void AigRedRemovalIncrByRefinementIntern(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, bAig_array_t *fBaigs, bAigEdge_t careBaig, int maxCutNum, int *enChk, int *nRef, bAig_array_t *cachedNodes, redrem_stats *rrStatsP, int *nodeClass, float timeLimitSingle, float timeLimitTotal, int redVal, int runMode, int *singleDone);
static void AigArrayRedRemovalIncrementalIntern(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, bAig_array_t *fBaigs, bAigEdge_t careBaig, int maxCutNum, int maxObserve, int *enChk, int *nRef, bAig_array_t *cachedNodes, redrem_stats *rrStatsP, float timeLimit);
static int AigOptOrIncrementalAcc(Ddi_Mgr_t *ddm, bAig_array_t *refNodes, bAig_array_t *nodes0, bAig_array_t *nodes1, bAigEdge_t careBaig, int maxCutNum, int maxObserve, bAig_array_t *cachedNodes, float totTimeLimit);
static int AigOptOrIncrementalIntern(Ddi_Mgr_t *ddm, bAig_array_t *refNodes, bAig_array_t *nodes0, bAig_array_t *nodes1, bAigEdge_t careBaig, int maxCutNum, int maxObserve, int *enChk, int *nRef, bAig_array_t *cachedNodes, redrem_stats *rrStatsP, float totTimeLimit);
static int AigOptByBddWithThresh(Ddi_Bdd_t *f, Ddi_Bdd_t *constr, int th, float timeLimit, int sizeLimit);
static void AigArrayRedRemovalIncrByControlClasses(Ddi_Bddarray_t *fAigarray, Ddi_Bdd_t *careAig, int onlyOuts, float timeLimit);
static void AigArrayRedRemovalIncrByEqClasses(Ddi_Bddarray_t *fAigarray, Ddi_Bdd_t *careAig, Ddi_Bdd_t *miters, int maxLevel, int filterVars, int assumeF, float timeLimit);
static void AigRedRemovalIncrByControlClasses(Ddi_Bdd_t *fAig, Ddi_Bdd_t *careAig, float timeLimit);
static void AigRedRemovalIncrByEqClasses(Ddi_Bdd_t *fAig, Ddi_Bdd_t *careAig, Ddi_Bdd_t *miters, int maxLevel, int filterVars, float timeLimit);
static Ddi_Bddarray_t * AigComputeInitialRedClasses(Ddi_Mgr_t *ddm, Ddi_Bddarray_t *fAigarray, bAig_array_t *visitedNodes, Ddi_Bdd_t *careAig, unsigned long time_limit);
static int aigOptTopIntern(bAig_Manager_t *manager, bAig_array_t *aigNodes, bAigEdge_t nodeIndex, int topOr, int keepXor, int maxDepth);
static int aigOptTopInternTopAnd(bAig_Manager_t *manager, bAig_array_t *aigNodes, bAigEdge_t nodeIndex);
static bAigEdge_t aigPartitionTopIteIntern(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex, Ddi_Bdd_t *sel, Ddi_Bdd_t *thenAig, int sizeTh);
static int aigOptTopInternTopOr(bAig_Manager_t *manager, bAig_array_t *aigNodes, bAigEdge_t nodeIndex);
static void aigTopOrClearVisitedIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static Ddi_Bdd_t * aig2BddIntern0(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex);
static Ddi_Bdd_t * aig2BddIntern(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex);
static Ddi_Bdd_t * aig2BddInternWithAbort(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex, int th);
static Ddi_Bdd_t * aig2BddInternWithCuts0(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex, int th, Ddi_Vararray_t *auxV, Ddi_Bddarray_t *auxF, Ddi_Bddarray_t *auxLits, int enPartial, float timeLimit);
static Ddi_Bdd_t * aig2BddInternWithCuts(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex, int th, Ddi_Vararray_t *auxV, Ddi_Bddarray_t *auxF, Ddi_Bddarray_t *auxLits, Ddi_Bdd_t *constrainCare, int enPartial, float timeLimit, int sizeLimit, int auxVarIdStart);
static Ddi_Bddarray_t * aigarray2BddInternWithCuts(Ddi_Mgr_t *ddm, bAig_array_t *nodeRoots, int th, Ddi_Vararray_t *auxV, Ddi_Bddarray_t *auxF, Ddi_Bddarray_t *auxLits, Ddi_Bdd_t *constrainCare, int enPartial, float timeLimit, int sizeLimit, int auxVarIdStart);
static Ddi_Bdd_t * aig2BddGenCutsIntern(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex, int th, Ddi_Vararray_t *auxV, Ddi_Bddarray_t *auxF);
static Ddi_Bdd_t * aig2BddDiffInternWithCuts(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex, int th, Ddi_Vararray_t *auxV, Ddi_Bddarray_t *auxF);
static void aig2CnfIntern(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex, FILE *fp, int *clauseNPtr, int *varMaxPtr);
static int aig2CnfIdRead(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static void aig2CnfIdWrite(bAig_Manager_t *manager, bAigEdge_t nodeIndex, int id);
static bAigEdge_t composeIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex, int enaMultiple);
static void coiIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static Ddi_Bdd_t * FindMinCut(Ddi_Bdd_t *f, Ddi_Bdd_t *care, Ddi_Var_t *initVar, Ddi_Varset_t *smoothVars, int observeLevels, int maxPiNum, int startFromPiFanout, int doFullFlow, float cutRatio);
static Ddi_Bddarray_t * FindMinCutArray(Ddi_Bddarray_t *fA, Ddi_Bdd_t *care, Ddi_Vararray_t *initVars, Ddi_Bddarray_t *substF, Ddi_Vararray_t *substV, int observeLevels, int maxPiNum, int startFromPiFanout, int doFullFlow, int disablePiFlow,   int fwdCut, int cutShortEdges, float cutRatio);
static Ddi_Bddarray_t *FindMinCutArrayBF(Ddi_Bddarray_t *fA, Ddi_Bdd_t *care, Ddi_Vararray_t *initVars, Ddi_Vararray_t *lockedVars, Ddi_Bddarray_t *substF, Ddi_Vararray_t *substV);
static int findFwdAugmPath(int startId, int visitId, bAig_array_t *visitedNodes, mincut_info *nodeInfoArray, int enBack);
static int findFwdBwdAugmPathBF(bAig_array_t *visitedNodes, mincut_info *nodeInfoArray, int *bfvAuxArray, int startFromAll, int setMinCut, int doPrint);
static Ddi_Bdd_t * evalMinCut(Ddi_Bdd_t *f, Ddi_Bdd_t *care, bAig_array_t *visitedNodes, mincut_info *nodeInfoArray, int doFullFlow, int *roots, int nRoots);
static Ddi_Bddarray_t *evalMinCutArray(Ddi_Bddarray_t *fA, Ddi_Bddarray_t *auxFA, Ddi_Vararray_t *auxVA, bAig_array_t *visitedNodes, mincut_info *nodeInfoArray, int doFullFlow, int *roots, int nRoots, int cutShortEdges);
static void existIntern(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex, bAigEdge_t *res0p, bAigEdge_t *res1p, int depth);
static void composeClearVisitedIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex, int enaMultiple);
static void existClearVisitedIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static void aig2BddClearVisitedIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static void aig2CnfClearVisitedIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static int aig2CnfIdLoad(Ddi_Mgr_t *ddm, bAig_array_t *cnfMapping, int setActive);
static int aig2CnfIdInit(Ddi_Mgr_t *ddm);
static int aig2CnfIdInitDecr(Ddi_Mgr_t *ddm, int size);
static int aig2CnfIdClose(Ddi_Mgr_t *ddm);
static int aig2CnfIdClear(Ddi_Mgr_t *ddm, bAigEdge_t nodeIndex);
static bAigEdge_t cnfId2AigClear(Ddi_Mgr_t *ddm, bAig_array_t *cnfMappedVars, int cnfId);
static int sat2AigActivity(Ddi_Mgr_t *ddm, Solver *S);
static int aig2SatActivity(Ddi_Mgr_t *ddm, Solver *S);
static int vararray2AigActivity(Ddi_Vararray_t *vA, float scale);
static int satActivity(Ddi_Mgr_t *ddm, Solver *S);
static void satDiffSolve(char *filename);
static int * satSolve0(char *filename, int *satP, int timeLimit);
static int * satSolve(char *filename, int *satP, int timeLimit);
static int * satSolveBerkmin(char *filename, int *satP, int timeLimit);
static int * satSolveCircuit(char *filename, int *satP, int timeLimit);
static void satDiffSolve0(char *filename);
static void AigSatDiffTot(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, bAigEdge_t careBaig, int mergeDirection, int mergeCompl, int cacheEnable);
static int AigSatRedCheck(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, bAigEdge_t careBaig, int constVal);
static int AigSatRedEqCheck(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, bAigEdge_t careBaig, int **compareLitArray, int eqPhase);
static int AigSatRedEqCheckMinisat(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, bAigEdge_t careBaig, int **compareLitArray, int eqPhase);
static void AigSatOptMerge(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, bAigEdge_t careBaig, int doRedRem, int mergeDirection, Ddi_AigSignatureArray_t *cof0Sig, Ddi_AigSignatureArray_t *cof1Sig, Ddi_AigSignature_t *careSig);
static int existOptMergeIntern(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, int refI, int mergeDirection, int constRedundancy, int useCofactorCare, bAigEdge_t careBaig, Ddi_AigSignatureArray_t *varSigs);
static void existDiffEvalIntern(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, bAigEdge_t careBaig, int cacheEnable);
static void ternaryEvalIntern(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, bAigEdge_t careBaig, int startTernary);
static Ddi_Bdd_t * checkRedIntern(Ddi_Bdd_t *fAig, Ddi_Bdd_t *careAig, bAigEdge_t redNode, int redVal);
static Ddi_Bdd_t * checkRedPartialIntern(Ddi_Bdd_t *fAig, Ddi_Bdd_t *careAig, bAig_array_t *visitedNodes, int redId, int redVal, double time_limit);
static int existDiffCnfStoreIntern(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, bAigEdge_t careBaig, int *compareLit, FILE *fp, int *clauseNPtr, int *varMaxPtr, int mergeCompl, int cacheEnable);
static int redCnfStoreIntern(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, bAigEdge_t careBaig, int *compareLit, FILE *fp, int *clauseNPtr, int *varMaxPtr, int constVal);
static int redEqCnfStoreIntern(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, bAigEdge_t careBaig, int **compareLitArray, FILE *fp, int *clauseNPtr, int *varMaxPtr, int constVal);
static void existDiffMergeIntern(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, bAigEdge_t careBaig, int *compareLit, int mergeDirection, int mergeCompl, int cacheEnable);
static void existDiffClearCnfIntern(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes);
static int AigVararraySortByFanout(Ddi_Vararray_t *vA, Ddi_Bdd_t *fAig);
static int AigVararraySortByFlow(Ddi_Vararray_t *vA, Ddi_Bdd_t *fAig);
static int bAigArraySortByLevel(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, bAigEdge_t start, int countMaxLevel);
static int bAigArraySetOutLevels(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, Ddi_Bddarray_t *roots);
static int bAigArraySortByLevelWithFlowStart(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, Ddi_Vararray_t *startVars);
static int bAigArraySiftVarIntern(Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, bAigEdge_t start);
static Ddi_Bdd_t * siftVarAcc(Ddi_Bdd_t *fAig, Ddi_Var_t *v, Ddi_Bdd_t *care);
static void logBaig(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static void logBaigNotShared(bAig_Manager_t *manager, bAigEdge_t nodeIndex, bAig_array_t *sharedRoots);
static void logAig(Ddi_Bdd_t *f);
static int myNodeCountIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static int myNodeCountInternWithPrint(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static int nodeNetStoreIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex, FILE *fp, Pdtutil_AigDump_e format);
static int nodeNetStoreInternNoPI(bAig_Manager_t *manager, bAigEdge_t nodeIndex, FILE *fp, Pdtutil_AigDump_e format);
static int nodeNetStoreClearIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex, FILE *fp, Pdtutil_AigDump_e format);
static void myNodeClearVisitedIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static void existMergeClearVisitedIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex);
static void bfsOrderAigVisitIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex, bAig_array_t *visitedNodes);
static void postOrderAigVisitIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex, bAig_array_t *visitedNodes, int maxDepth);
static void postOrderAigVisitInternReversed(bAig_Manager_t *manager, bAigEdge_t nodeIndex, bAig_array_t *visitedNodes, int maxDepth);
static void postOrderAigByAuxIntVisitIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex, bAig_array_t *visitedNodes, int *inOrderTimeP, int maxDepth);
static void
postOrderAigByMaxAuxRefWithDecrVisitIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  bAig_array_t *visitedNodes,
  int *inOrderTimeP
);
static void bfsAigVisitIntern(bAig_Manager_t *manager, bAigEdge_t nodeIndex, bAig_array_t *visitedNodes, int maxDepth);
static void postOrderBddAigByAuxIntVisitIntern(Ddi_Bdd_t *fAig, bAig_array_t *visitedNodes, int *inOrderTimeP, int maxDepth);
static void
postOrderBddAigByMaxRefVisitIntern(
  Ddi_Bdd_t *fAig,
  bAig_array_t *visitedNodes,
  int *inOrderTimeP
);
static void postOrderBddAigVisitIntern(Ddi_Bdd_t *fAig, bAig_array_t *visitedNodes, int useCnfActive, int maxDepth);
static void postOrderBddAigVisitInternReversed(Ddi_Bdd_t *fAig, bAig_array_t *visitedNodes, int useCnfActive, int maxDepth);
static void bfsOrderBddAigVisitIntern(Ddi_Bdd_t *fAig, bAig_array_t *visitedNodes);
static void aigArrayClearVisitedIntern(bAig_Manager_t *bmgr, bAig_array_t *visitedNodes);
static void aigArrayClearAuxAigIntern(bAig_Manager_t *bmgr, bAig_array_t *visitedNodes);
static void aigArrayClearAuxIntIntern(bAig_Manager_t *bmgr, bAig_array_t *visitedNodes);
static void aigArrayLevelizeIntern(bAig_Manager_t *bmgr, bAig_array_t *visitedNodes);
static void aigArrayLevelizeMaxFromOutIntern(bAig_Manager_t *bmgr, bAig_array_t *visitedNodes);
static void postOrderAigClearVisitedIntern(bAig_Manager_t *bmgr, bAig_array_t *visitedNodes);
static void bfsOrderAigClearVisitedIntern(bAig_Manager_t *bmgr, bAig_array_t *visitedNodes);
static int bAigMergeCacheRead(bAig_Manager_t *manager, bAigEdge_t node0, bAigEdge_t node1, bAigEdge_t *res);
static int bAigMergeCacheWrite(bAig_Manager_t *manager, bAigEdge_t node0, bAigEdge_t node1, bAigEdge_t entry, int merged);
static int bAigNodeComputeAuxVal(bAig_Manager_t *bmgr, bAigEdge_t baig, int cof);
static int MinisatClausesIncr(Ddi_IncrSatMgr_t *incrSat, Ddi_Bdd_t *f, Ddi_Bdd_t *g, int *na, int genRelation);
static int Minisat22Clauses(void *S22, Ddi_Bdd_t *f, Ddi_Bdd_t *g, int *na, int genRelation);
static int bAigSetAuxCharForInterpolant(Ddi_Bdd_t *f,Ddi_Bdd_t *g);
static int MinisatClausesWithSuppFlow(Ddi_IncrSatMgr_t *incrSat, Solver& S, void *S22,  Ddi_Bdd_t *f, Ddi_Bdd_t *g, Ddi_Varset_t *flowVars, int *na, int *aigShared, aigCnfMgr_t **aigCnfMgrP, int genRelation, int genRelationG, int genActLits, int nItpCuts);
static int MinisatClausesWithAbstraction(Ddi_Bdd_t *f, Ddi_Bdd_t *g);
static bAig_array_t **MinisatItpSeqClauses(Solver& S, Ddi_Bdd_t *f, int *nA);
static int MinisatClauses2Solvers(Solver& S, Solver& S2, Ddi_Bdd_t *f, Ddi_Bdd_t *g, int *na, int genRelation);
static void bAigArrayMinisatClausesWithNum(Ddi_Mgr_t *ddm, Solver&    S, bAig_array_t *visitedNodes, int i0, int N);
static void bAigArrayMinisatClauses(Ddi_Mgr_t *ddm, Solver&    S, bAig_array_t *visitedNodes, int i0);
static void MinisatInterpolant(Solver& S, Ddi_Mgr_t *ddm, int nAClauses, int reverseItp, Ddi_Bdd_t **interpolantP, Ddi_Bdd_t **interpolantOptP, Ddi_Bdd_t *care,  Ddi_Bddarray_t *partitionLits, vec<vec<Lit> > *partitionClausesP, int nSuppVars, int itpOdc);
static Ddi_Bdd_t *getProof22(void *Svoid, struct Checker *travP, Ddi_Bdd_t *a, Ddi_Bdd_t *b, int nAClauses, Ddi_Varset_t *globalvars,int computeAuxItp);
static Ddi_Bdd_t *Minisat22InterpolantUndefTopLits (void *Svoid, Ddi_Mgr_t *ddm, int maxn);
static bool
Minisat22InterpolantUndef (void    *Svoid, Ddi_Mgr_t *ddm, Ddi_Bdd_t *a, Ddi_Varset_t *globalvars, int reverseItp, Ddi_Bdd_t **interpolantP, Ddi_Bdd_t *care, int nSuppVars, int itpOdc, int genProof, int nACl, int useB);
static bool Minisat22Interpolant(void *S22, Ddi_Mgr_t *ddm, Ddi_Bdd_t *a, Ddi_Bdd_t *b, int nAClauses, Ddi_Varset_t *globalvars, int reverseItp, Ddi_Bdd_t **interpolantP, Ddi_Bdd_t **interpolantOptP, Ddi_Bdd_t *care, int nSuppVars, int itpOdc, int genProof);
static Ddi_Bdd_t *aigSat22NnfSubset (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, int *psat, float timeLimit);
static int MinisatCore (Solver& S, Ddi_Mgr_t *ddm, int nAClauses, vec<Var>& coreVars, vec<vec<Lit> >& coreClauses, int doFinalClean);
static int MinisatCoreWithResolution (Solver& S, Ddi_Mgr_t *ddm, Ddi_Bdd_t *a, int nAClauses, vec<Lit> *assumps, int nAssumpsA, vec<Var>& coreVars, vec<vec<Lit> >& coreClauses, int doResolutionB, int doFinalClean);
static int Minisat22Core (void *S22void, Ddi_Mgr_t *ddm, vec<Var>& coreVars, vec<vec<Lit> >& coreClauses);

static int nnfAndFindOdc(void *S22void,Ddi_Mgr_t *ddm,bAigEdge_t *cutBaigs,int nPin, long *unsatTimeP);
static int nnfAndFindOdcIncr(void *S22void,Ddi_Mgr_t *ddm,bAigEdge_t *cutBaigs,int nPin, long *unsatTimeP);

static Ddi_Bdd_t *MinisatCoreAig (Ddi_Bdd_t *f, Ddi_Bdd_t *share, vec<Var>& coreVars, vec<Var> *sharedVars, bAig_array_t *cnfMappedVars, int *nCutP, aigCnfMgr_t *aigCnfMgr, nnfCoreMgr_t *nnfCoreMgr, int monotoneExist);
static int aigArraySearch(bAig_array_t *visitedNodes, bAigEdge_t baig);
static Ddi_Var_t * newQbfVar(Ddi_Mgr_t *ddm, int idx);
static void dom_stats(bAig_Manager_t *bmgr, bAig_array_t *visitedNodes, int *doms, int *occur, int ffrSize);
static int intersect(int b1, int b2, int *doms);
static Ddi_Bdd_t *AigAbstrVarsForInterpolantPreWindow (Ddi_Bdd_t *a, unsigned char *saveEnAbstrIn, unsigned char *enAbstrIn, unsigned char *doAbstrOut, int nVars, int startId, int wSize, Ddi_Vararray_t *aVars, Ddi_Vararray_t *bVars);
static Ddi_Bdd_t *AigAbstrVarsForInterpolantPostWindow (Ddi_Bdd_t *a, unsigned char *saveEnAbstrIn, unsigned char *enAbstrIn, int nVars, Ddi_Vararray_t *aVars,  Ddi_Vararray_t *bVars);
static int VarOrdCompare(const void *v0, const void *v1);
static int AuxIntAigCompare(const void *b0, const void *b1);

static int foOptPropImpl(  int id, int *workA, int *zeroRed, int *visited, int *nVisitedP, int **cutFi, int *cutFiNum, int *cutPins, int cutNum, int *nRedSameP, int *nRedRedP, int *nRedOrP, int *nRedFoundP, int isAndPin);
static int *aigNetlistBddMerge(Ddi_Mgr_t *ddm, bAig_array_t *visitedNodes, Ddi_Bdd_t *careBdd, int *enCutVar, int *nRef, int th);
static aigCnfInfo_t *genAigCnfInfo(bAig_Manager_t *bmgr, bAig_array_t *visitedNodes, Ddi_Bddarray_t *roots, Ddi_Vararray_t *flowV, Ddi_AigAbcInfo_t *aigAbcInfo, int useCnfActive, int makeRel);
static aigCnfMgr_t *aigCnfMgrAlloc(Ddi_Mgr_t *ddm, int nNodes);
static void aigCnfMgrFree(aigCnfMgr_t *aigCnfMgr);
static nnfCoreMgr_t *nnfCoreMgrNew(Ddi_Bdd_t *fNnf, Ddi_Vararray_t *rV,Ddi_Vararray_t *aV0,Ddi_Vararray_t *aV1, Ddi_Bdd_t *nnfConstr, int storeGateType, int leftFirst);
static void nnfCoreMgrFree(nnfCoreMgr_t *nnfCoreMgr);
static int
aigCnfMgrGenActLits(
  aigCnfMgr_t *aigCnfMgr
);
static int genAigCnfGenClauses(aigCnfMgr_t *aigCnfMgr);
static int genAigCnfFlowRefine(aigCnfMgr_t *aigCnfMgr, Solver *S, Solver *S1);
static void genAigCnfFlowFrontier(aigCnfMgr_t *aigCnfMgr, Solver *S, int mode);
static void genAigCnfSolverClauses(aigCnfMgr_t *aigCnfMgr, Solver *pS, void *S22, LGL *lgl, int j);

static void *Minisat22NewSolverVoidP(void);
static void Minisat22FreeSolverVoidP(void *pS22void);
static void Minisat22AndOrClauses(void *pS22void,bAig_Manager_t *bmgr,int isAnd,bAigEdge_t fbaig,bAigEdge_t *cutBaigs,int n,int nicePhase);
static int Minisat22Solve(void *pS22void);
static int Minisat22nClauses(void *pS22void);
static int Minisat22nVars(void *pS22void);
static void Minisat22NewVars(void *pS22void, int maxv);
static void Minisat22Clause(void *pS22void, vec<Lit>& lits);
static void Minisat22Clause1(void *pS22void, int l);
static void Minisat22Clause2(void *pS22void, int l0, int l1);
static void Minisat22Clause3(void *pS22void, int l0, int l1, int l2);
static int genAigCnfSolverFrontierVars(aigCnfMgr_t *aigCnfMgr, int j, bAig_array_t *refinementFrontier);
static int genAigCnfPropImplications(aigCnfMgr_t *aigCnfMgr);
static int baigIsXorOrXnor(bAig_Manager_t *bmgr, bAigEdge_t baig);
static int baigSplitXorOrXnor(bAig_Manager_t *bmgr, bAigEdge_t baig, bAigEdge_t *baig0P, bAigEdge_t *baig1P, int doXor);
static int findIteOrXor(bAig_Manager_t *bmgr, bAig_array_t *visitedNodes, aigCnfInfo_t *aigCnfInfo, bAigEdge_t baig, bAigEdge_t right, bAigEdge_t left, int i, int ir, int il);
static int eqGateFindLdr (int *eqArray, int n, int i);
static int checkEqGate (Ddi_Mgr_t *ddiMgr, Ddi_Varset_t *psv, bAigEdge_t baig, bAigEdge_t right, bAigEdge_t left, bAig_array_t *visitedNodes, int *eqArray,   bAigEdge_t *baigEq0P, bAigEdge_t *baigEq1P, int chkDiff);
static int aig2CnfClauses(Ddi_Bdd_t *f, FILE *fp, int *clauseNp, int *varMaxp);
static void genAigCnfFileClauses(aigCnfMgr_t *aigCnfMgr, FILE *fp, int j, int *clauseNp);
static int resolve(vec<Lit>& main, vec<Lit>& other, Var x);
static void monotoneSplitIntern (Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, int assumeRed);
static void newAigEvalIntern (Ddi_Mgr_t *ddm, bAig_array_t *aigNodes);
static void newAigEvalInternNnf (Ddi_Mgr_t *ddm, bAig_array_t *aigNodes, nnfCoreMgr_t *nnfCoreMgr);
static Ddi_Bdd_t *aigSplitMonotoneGen (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *care, int useCompl);
static Ddi_Bdd_t *aigOptByMonotoneCoreAcc (Ddi_Bdd_t *itp, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, vec<vec<Lit> > *coreBClauses, Ddi_Bdd_t *cnfSharedAigs, vec<vec<Lit> > *partitionClauses, bAig_array_t *cnfMappedVars, int complement, int monotoneForall, int byRefinementOrPart, float timeLimit);
static Ddi_Bdd_t *aigNnfOptBySatSimplifyAcc (Ddi_Bdd_t *itp, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, vec<vec<Lit> > *coreBClauses, bAig_array_t *cnfMappedVars, int complement, int monotoneForall);
static int
hintSatPreprocess(
  Ddi_Mgr_t *ddm,
  Solver *S,
  Solver *S2,
  int *cnf2solver,
  Ddi_Bdd_t *partHint
);
static Ddi_Bdd_t *aigSatAndWithAigCore (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, vec<vec<Lit> > *coreBClauses, Ddi_Bdd_t *cnfSharedAigs, vec<vec<Lit> > *partitionClauses, bAig_array_t *cnfMappedVars, int useMonotone, int *psat, float timeLimit);
static Ddi_Bdd_t *aigSatAndWithAigCoreNnf (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, nnfCoreMgr_t *nnfCoreMgr, vec<vec<Lit> > *coreBClauses, Ddi_Bdd_t *cnfSharedAigs, vec<vec<Lit> > *partitionClauses, bAig_array_t *cnfMappedVars, int useMonotone, int *psat, float timeLimit);
static Ddi_Bdd_t *aigSatAndWithAigCoreNnfPart (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, nnfCoreMgr_t *nnfCoreMgr, vec<vec<Lit> > *coreBClauses, bAig_array_t *cnfMappedVars, int useMonotone, int *psat, float timeLimit);
static Ddi_Bdd_t *aigSatAndWithAigCoreNnfByRefinement (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, nnfCoreMgr_t *nnfCoreMgr, vec<vec<Lit> > *coreBClauses, bAig_array_t *cnfMappedVars, int useMonotone, int *psat, float timeLimit);
static Ddi_Bdd_t *aigSatAndWithAigCoreNnfIntern (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare,   Ddi_Bdd_t *shareAig, nnfCoreMgr_t *nnfCoreMgr, vec<vec<Lit> > *coreBClauses, vec<vec<Lit> > *partitionClauses, bAig_array_t *cnfMappedVars, bAig_array_t *coreGates, int useMonotone, int *psat, float timeLimit);
static Ddi_Bdd_t *aigSat22AndWithAigCoreByProof (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, nnfCoreMgr_t *nnfCoreMgr, vec<vec<Lit> > *coreBClauses, bAig_array_t *cnfMappedVars, int useMonotone, int *psat, float timeLimit);
static Ddi_Bdd_t *aigSat22AndWithAigCore (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, nnfCoreMgr_t *nnfCoreMgr, vec<vec<Lit> > *coreBClauses, bAig_array_t *cnfMappedVars, int useMonotone, int *psat, float timeLimit);
static Ddi_Bdd_t *aigSat22RedBySimplify (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, nnfCoreMgr_t *nnfCoreMgr, vec<vec<Lit> > *coreBClauses, bAig_array_t *cnfMappedVars, int useMonotone);
static Ddi_Bdd_t *aigSatAndWithAigCoreByRefinement (Ddi_Bdd_t *a, Ddi_Bdd_t *b, Ddi_Bdd_t *optCare, vec<vec<Lit> > *coreBClauses, bAig_array_t *cnfMappedVars, int useMonotone, int *psat, float timeLimit);
static void cnfSetActive(Ddi_Mgr_t *ddm, int i, int val);
static unsigned char cnfReadActive(Ddi_Mgr_t *ddm, int i);
static int aigSatGetActLiterals(Ddi_Bdd_t *f, vec<Lit>& lits);
static Ddi_Bdd_t *aigStructRedRemRecur (Ddi_Bdd_t *f, Ddi_Bdd_t *share, int tryRecur);
static Ddi_Bdd_t *aigNnfClustSimplify (Ddi_Bdd_t *a);
static Ddi_Bdd_t *aigNnfClustNormalize (Ddi_Bdd_t *a, int leftFirst);
static Ddi_Bdd_t *aigNnfClustNormalize2 (Ddi_Bdd_t *a);
static Ddi_Bdd_t *aigNnfClustNormalize3 (Ddi_Bdd_t *a);
static Ddi_Bdd_t *aigNnfClustOdcSat (Ddi_Bdd_t *a,Ddi_Bdd_t *care);
static Ddi_Bdd_t *aigNnfTransImplSimplify (Ddi_Bdd_t *a);
static Ddi_Bdd_t *aigNnfClustRefactor(Ddi_Bdd_t *a);
static Ddi_Bdd_t *aigNnfClustIteDecomp (Ddi_Bdd_t *a,  Ddi_Vararray_t *rV, Ddi_Vararray_t *aV);

static int resortCut (nnfGate_t *nnfGates, int ldr, int i, int j);
static int Minisat22ConstrainSolverWithAbstrCex(
  void *pS22void,
  void *pS22itpVoid,
  Ddi_Mgr_t *ddm,
  Ddi_Bdd_t *bAbstr,
  vec<Lit>& assumps,
  int nAClauses
);
static Ddi_Bdd_t *
sat22ConstrainIntern(
  Ddi_Bdd_t *F,
  Ddi_Bdd_t *C,
  Ddi_Bdd_t *A,
  int maxIter,
  int *res,
  int doTernary,
  float subsetRatio
);

/**AutomaticEnd***************************************************************/

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigOptByAbc (
  Ddi_Bdd_t *f
)
{
  ddiAbcOptAcc(f, -1);
}

/**Function********************************************************************
  Synopsis    [Free aig ddi struct and related baig]
  Description [Free aig ddi struct and related baig]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiAigFree (
  Ddi_Aig_t *a
)
{
  if (!bAig_NodeIsConstant(a->aigNode)) {
    bAig_RecursiveDeref(a->mgr, a->aigNode);
  }
  Pdtutil_Free(a);
}

/**Function********************************************************************
  Synopsis    [Duplicate meta struct]
  Description [Duplicate meta struct]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Aig_t *
DdiAigDup (
  Ddi_Aig_t *a
)
{
  return(DdiAigMakeFromBaig(a->mgr,a->aigNode));
}


/**Function********************************************************************
  Synopsis    [Copy Aig between managers]
  Description [Copy Aig between managers]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Aig_t *
DdiAigCopy (
  Ddi_Mgr_t *ddm0,
  Ddi_Mgr_t *ddm,
  Ddi_Aig_t *a
)
{
  bAigEdge_t baig0, baig;
  bAig_Manager_t *bmgr0 = ddm0->aig.mgr;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_ArrayData_t *newa, *auxa;
  Ddi_Bdd_t *aDupBdd;
  Ddi_Aig_t *a1;

  if (ddm0 == ddm) {
    /* same menager, call dup */
    return (DdiAigDup(a));
  }

  baig0 = a->aigNode;
  aDupBdd = Ddi_BddMakeFromBaig(ddm0, baig0);
  auxa = DdiArrayAlloc (1);
  DdiArrayWrite(auxa,0,(Ddi_Generic_t *)aDupBdd,Ddi_Mov_c);

  newa = DdiAigArrayCopy (ddm0, ddm, auxa);

  a1 = DdiAigDup(DdiArrayRead(newa,0)->Bdd.data.aig);

  DdiArrayFree(auxa);
  DdiArrayFree(newa);

  return(a1);
}

/**Function********************************************************************
  Synopsis    [Copy Aig between managers]
  Description [Copy Aig between managers]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_ArrayData_t *
DdiAigArrayCopy (
  Ddi_Mgr_t *ddm0,
  Ddi_Mgr_t *ddm,
  Ddi_ArrayData_t *a
)
{
  Ddi_ArrayData_t *newa;
  bAigEdge_t baig0, baig;

  bAig_array_t *visitedNodes;

  bAig_Manager_t *bmgr0 = ddm0->aig.mgr;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i, nRoots = DdiArrayNum(a);

  if (ddm0 == ddm) {
    /* same menager, call dup */
    return (DdiArrayDup(a));
  }

  visitedNodes = bAigArrayAlloc();

  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f_i = (Ddi_Bdd_t *)DdiArrayRead(a,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f_i);
    if (!bAig_NodeIsConstant(fBaig)) {
      postOrderAigVisitIntern(bmgr0,fBaig,visitedNodes,-1);
    }
  }
  aigArrayClearVisitedIntern(bmgr0,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr0,visitedNodes);

  newa = DdiArrayAlloc (nRoots);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1, baig = visitedNodes->nodes[i];

    Pdtutil_Assert(!bAig_NodeIsConstant(baig),"Constant baing in array");

    if (bAig_isVarNode(bmgr0,baig)) {
      /* take correspondent var */
      char *name = bAig_NodeReadName(bmgr0,baig);
      baig1 = bAig_VarNodeFromName(bmgr,name);
      if (baig1 == bAig_NULL) {
	int isAig = Ddi_VarIsAig(Ddi_VarFromName(ddm0,name));
	Ddi_Var_t *v;
	if (isAig) {
	  v = Ddi_VarNewBaig(ddm,name);
	}
	else {
	  v = Ddi_VarNew(ddm);
	  Ddi_VarAttachName (v, name);
	}
	baig1 = bAig_VarNodeFromName(bmgr,name);
      }
    }
    else {
      bAigEdge_t right, left, r, l;
      right = bAig_NodeReadIndexOfRightChild(bmgr0,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr0,baig);
      r = bAig_NodeIsInverted(right) ?
        bAig_Not(bAig_AuxAig1(bmgr0,right)) : bAig_AuxAig1(bmgr0,right);
      l = bAig_NodeIsInverted(left) ?
        bAig_Not(bAig_AuxAig1(bmgr0,left)) : bAig_AuxAig1(bmgr0,left);
      /* this is the operation in the new manager */
      baig1 = bAig_And(bmgr,r,l);
    }
    Pdtutil_Assert(baig1 != bAig_NULL,"NULL baig");
    bAig_Ref(bmgr, baig1);
    Pdtutil_Assert(bAig_AuxAig1(bmgr0,baig) == bAig_NULL, "wrong auxaig1");
    bAig_AuxAig1(bmgr0,baig) = baig1;
  }

  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f_i = (Ddi_Bdd_t *)DdiArrayRead(a,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f_i);
    bAigEdge_t fBaig1;
    Ddi_Bdd_t *f1_i;
    if (bAig_NodeIsConstant(fBaig)) {
      /* constants are equal on both managers */
      fBaig1 = fBaig;
    }
    else {
      fBaig1 = bAig_NodeIsInverted(fBaig) ?
                            bAig_Not(bAig_AuxAig1(bmgr0,fBaig)) :
                                     bAig_AuxAig1(bmgr0,fBaig);
    }
    f1_i = Ddi_BddMakeFromBaig(ddm,fBaig1);
    DdiArrayWrite(newa,i,(Ddi_Generic_t *)f1_i,Ddi_Mov_c);
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr0,baig));
    bAig_AuxAig1(bmgr0,baig) = bAig_NULL;
  }


  bAigArrayFree(visitedNodes);

  return(newa);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to the corresponding bAig Node]
  Description [Convert a DDI AIG  to the corresponding bAig Node.
    This is done by reading the proper field (pointing to a bAig node) in the
    DDI node. No ref is done on the returned node.]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
bAigEdge_t
DdiAigToBaig(
  Ddi_Aig_t *a
)
{
  return (a->aigNode);
}

/**Function********************************************************************
  Synopsis    [Make new DDI AIG]
  Description [Make new DDI AIG]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Aig_t *
DdiAigMakeFromBaig (
  bAig_Manager_t *mgr,
  bAigEdge_t bAigNode
)
{
  Ddi_Aig_t *a;

  Pdtutil_Assert((mgr!=NULL),
    "NULL manager or bAig when generating DDI node");
  Pdtutil_Assert(bAigNode != bAig_NULL,"NULL baig generating ddi node");

  a = Pdtutil_Alloc(Ddi_Aig_t,1);
  a->mgr = mgr;
  a->aigNode = bAigNode;
  bAig_Ref(mgr, bAigNode);

  return(a);
}

/**Function********************************************************************
   Synopsis    []
   Description []
   SideEffects []
   SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigDisjDecomp (
                   Ddi_Bdd_t *f,
                   int minp,
                   int maxp
                   )
{
  Ddi_Bdd_t *notF = Ddi_BddNot(f);
  Ddi_Bdd_t *res = Ddi_AigConjDecomp (notF,minp,maxp);
  Ddi_Free(notF);
  Ddi_BddNotAcc(res);
  return res;
}

/**Function********************************************************************
   Synopsis    []
   Description []
   SideEffects []
   SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigConjDecomp (
                   Ddi_Bdd_t *f,
                   int minp,
                   int maxp
                   )
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *pConj = Ddi_AigPartitionTop(f, 0);
  Ddi_Bdd_t *pPart;
  int tryDec = 1, tryCompact = 1, increasingSize = 1;
  int prevPartNum = 0;
  while (tryDec && (Ddi_BddPartNum(pConj) < minp) &&
         (Ddi_BddPartNum(pConj) > prevPartNum)) {

    int ii, np0 = Ddi_BddPartNum(pConj);
    prevPartNum = np0;

    Ddi_BddPartSortBySizeAcc(pConj, increasingSize); 

    for (ii = 0; ii < 1 /*Ddi_BddPartNum(pConj)*/; ii++) {
      Ddi_Bdd_t *p_ii = Ddi_BddPartRead(pConj, ii);

      //      tryDec = 0;
      //      Ddi_AigStructRedRemAcc(p_ii, NULL);
      Ddi_Bdd_t *p_ii_Part = Ddi_AigPartitionTop(p_ii, 1);
      int np_ii = Ddi_BddPartNum(p_ii_Part);
      int j, j_max = -1, max = 1;
      Ddi_Bdd_t *pMaxPart = NULL, *pMax = NULL;
      int supset = 0;
      
      
      Ddi_BddPartSortBySizeAcc(p_ii_Part, 0); // decreasing size
      pPart = Ddi_BddDup(p_ii_Part);
      Ddi_Free(p_ii_Part);
      
      for (j = 0; j < np_ii; j++) {
	Ddi_Bdd_t *p_j = Ddi_BddPartRead(pPart, j);
	Ddi_Bdd_t *p_j_Part = Ddi_AigPartitionTop(p_j, 0);
	
	int size = Ddi_BddSize(p_j);
	int np = Ddi_BddPartNum(p_j_Part);
	
	Ddi_Free(p_j_Part);
	if ( /*j==0 || */ np > max) {
	  j_max = j;
	  max = np;
	}
      }
      
      if (j_max < 0) {
	Ddi_Free(pPart);
        //	continue;
        break;
      }

      tryDec = 1;

      pMax = Ddi_BddPartExtract(pPart, j_max);
      //      Ddi_AigStructRedRemAcc(pMax, NULL);
      pMaxPart = Ddi_AigPartitionTop(pMax, 0);
      Ddi_Free(pMax);
      Ddi_BddSetAig(pPart);
      if (tryCompact) {
	int j;
	int size = Ddi_BddSize(pMaxPart);
	
	Ddi_BddPartSortBySizeAcc(pMaxPart, 0);    // decreasing size
	for (j = Ddi_BddPartNum(pMaxPart) - 2; j >= 1; j--) {
	  Ddi_Bdd_t *p_j = Ddi_BddPartRead(pMaxPart, j);
	  
	  if (Ddi_BddSize(p_j) > size / 2)
	    break;
	  Ddi_Bdd_t *p_j1 = Ddi_BddPartExtract(pMaxPart, j + 1);
	  
	  Ddi_BddAndAcc(p_j, p_j1);
	  Ddi_Free(p_j1);
	}
      }
      for (j = 0; j < Ddi_BddPartNum(pMaxPart); j++) {
	Ddi_Bdd_t *p_j = Ddi_BddPartRead(pMaxPart, j);
	
	Ddi_BddOrAcc(p_j, pPart);
      }
      Ddi_Free(pPart);
      pPart = pMaxPart;
      Ddi_DataCopy(p_ii, pPart);
      Ddi_Free(pPart);
      
    }
    //    useRplus = 1;
    Ddi_BddSetFlattened(pConj);
    Ddi_BddSetPartConj(pConj);
    //    if (Ddi_BddPartNum(pConj)>=np0) tryDec=0;
  }
  
  Ddi_BddPartSortBySizeAcc(pConj, 1);   // increasing size
  if (maxp>0 && Ddi_BddPartNum(pConj)>maxp) {
    int compact = Ddi_BddPartNum(pConj)/maxp;
    if (Ddi_BddPartNum(pConj)%maxp > 0) compact++;
    while (Ddi_BddPartNum(pConj)>maxp) {
      for (int i=0;
           i<(Ddi_BddPartNum(pConj)-1) && Ddi_BddPartNum(pConj)>maxp;
           i++) {
        for (int k=1; k<compact; k++) {
          if (i>=Ddi_BddPartNum(pConj)-2) break;
          if (Ddi_BddPartNum(pConj)<=maxp) break;
          Ddi_Bdd_t *ref = Ddi_BddPartRead(pConj,i);
          Ddi_Bdd_t *toJoin = Ddi_BddPartExtract(pConj,i+1);
          Ddi_BddAndAcc(ref,toJoin);
          Ddi_Free(toJoin);
        }
      }        
    }
  }

  pPart = Ddi_BddDup(pConj);
  Ddi_Free(pConj);

  return pPart;
}

/**Function********************************************************************
   Synopsis    []
   Description []
   SideEffects []
   SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigDisjDecompRoots (
  Ddi_Bdd_t *f,
  Ddi_Var_t *pVar,
  Ddi_Var_t *cVar,
  int recurTh
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *roots = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Bdd_t *fDup = Ddi_BddDup(f);
  if (pVar!=NULL)
    Ddi_BddCofactorAcc(fDup,pVar,1);
  if (cVar!=NULL)
    Ddi_BddCofactorAcc(fDup,cVar,1);
  Ddi_Bdd_t *pConj = Ddi_AigPartitionTop(fDup, 0);
  Ddi_Free(fDup);
  Ddi_Bdd_t *pPart;
  int tryDec = 1, tryCompact = 1, increasingSize = 1;
  int prevPartNum = 0;

  Ddi_BddPartSortBySizeAcc(pConj, 1); 

  for (int ii = 0; ii < Ddi_BddPartNum(pConj); ii++) {
    Ddi_Bdd_t *p_ii = Ddi_BddPartRead(pConj, ii);

    Ddi_Bdd_t *p_ii_Part = Ddi_AigPartitionTop(p_ii, 1);
    int np_ii = Ddi_BddPartNum(p_ii_Part);
      
    Ddi_BddPartSortBySizeAcc(p_ii_Part, 1); // decreasing size
    
    for (int j = 0; j < np_ii; j++) {
      Ddi_Bdd_t *p_j = Ddi_BddPartRead(p_ii_Part, j);
      Ddi_BddarrayInsertLast(roots,p_j);    
    }
    Ddi_Free(p_ii_Part);
  }
  Ddi_Free(pConj);
  if (recurTh>0) {
    int n = Ddi_BddarrayNum(roots);
    if (n<100) {
      for (int i=0; i<n; i++) {
        Ddi_Bdd_t *r_i = Ddi_BddarrayRead(roots,i);
        if (Ddi_BddSize(r_i) > recurTh) {
          Ddi_Bddarray_t *newRoots = Ddi_AigDisjDecompRoots (r_i,NULL,NULL,0);
          Ddi_BddarrayAppend(roots,newRoots);
          Ddi_Free(newRoots);
        }
      }
    }
  }
  
  return roots;
}

/**Function********************************************************************
   Synopsis    []
   Description []
   SideEffects []
   SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigConjDecompRecur (
  Ddi_Bdd_t *f,
  int minp
)
{
  // TODO - this is a copy of the previous one
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *pConj = Ddi_AigPartitionTop(f, 0);
  Ddi_Bdd_t *pPart;
  int tryDec = 1, tryCompact = 1;

  while (tryDec && (Ddi_BddPartNum(pConj) < minp)) {

    int ii, np0 = Ddi_BddPartNum(pConj);

    Ddi_BddPartSortBySizeAcc(pConj, 0);   // decreasing size

    for (ii = 0; ii < Ddi_BddPartNum(pConj); ii++) {
      Ddi_Bdd_t *p_ii = Ddi_BddPartRead(pConj, ii);

      //      tryDec = 0;
      //      Ddi_AigStructRedRemAcc(p_ii, NULL);
      Ddi_Bdd_t *p_ii_Part = Ddi_AigPartitionTop(p_ii, 1);
      int np_ii = Ddi_BddPartNum(p_ii_Part);
      int j, j_max = -1, max = 1;
      Ddi_Bdd_t *pMaxPart = NULL, *pMax = NULL;
      int supset = 0;
      
      
      Ddi_BddPartSortBySizeAcc(p_ii_Part, 0); // decreasing size
      pPart = Ddi_BddDup(p_ii_Part);
      Ddi_Free(p_ii_Part);
      
      for (j = 0; j < np_ii; j++) {
	Ddi_Bdd_t *p_j = Ddi_BddPartRead(pPart, j);
	Ddi_Bdd_t *p_j_Part = Ddi_AigPartitionTop(p_j, 0);
	
	int size = Ddi_BddSize(p_j);
	int np = Ddi_BddPartNum(p_j_Part);
	
	Ddi_Free(p_j_Part);
	if ( /*j==0 || */ np > max) {
	  j_max = j;
	  max = np;
	}
      }
      
      if (j_max < 0) {
	Ddi_Free(pPart);
	continue;
	//      break;
      }

      tryDec = 1;

      pMax = Ddi_BddPartExtract(pPart, j_max);
      //      Ddi_AigStructRedRemAcc(pMax, NULL);
      pMaxPart = Ddi_AigPartitionTop(pMax, 0);
      Ddi_Free(pMax);
      Ddi_BddSetAig(pPart);
      if (tryCompact) {
	int j;
	int size = Ddi_BddSize(pMaxPart);
	
	Ddi_BddPartSortBySizeAcc(pMaxPart, 0);    // decreasing size
	for (j = Ddi_BddPartNum(pMaxPart) - 2; j >= 1; j--) {
	  Ddi_Bdd_t *p_j = Ddi_BddPartRead(pMaxPart, j);
	  
	  if (Ddi_BddSize(p_j) > size / 2)
	    break;
	  Ddi_Bdd_t *p_j1 = Ddi_BddPartExtract(pMaxPart, j + 1);
	  
	  Ddi_BddAndAcc(p_j, p_j1);
	  Ddi_Free(p_j1);
	}
      }
      for (j = 0; j < Ddi_BddPartNum(pMaxPart); j++) {
	Ddi_Bdd_t *p_j = Ddi_BddPartRead(pMaxPart, j);
	
	Ddi_BddOrAcc(p_j, pPart);
      }
      Ddi_Free(pPart);
      pPart = pMaxPart;
      Ddi_DataCopy(p_ii, pPart);
      Ddi_Free(pPart);
      
    }
    //    useRplus = 1;
    Ddi_BddSetFlattened(pConj);
    Ddi_BddSetPartConj(pConj);
    //    if (Ddi_BddPartNum(pConj)>=np0) tryDec=0;
  }
  
  Ddi_BddPartSortBySizeAcc(pConj, 1);   // increasing size
  pPart = Ddi_BddDup(pConj);
  Ddi_Free(pConj);

  return pPart;
}

/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigArrayClearAuxInt(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes
)
{
  aigArrayClearAuxIntIntern(bmgr,visitedNodes);
}



/**Function********************************************************************
  Synopsis    [Select partitions belonging to filter]
  Description [Select partitions belonging to filter]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_BddPartFilter (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *filter 
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  bAig_array_t *aigNodes = bAigArrayAlloc();
  int i;
  Ddi_Bdd_t *fFiltered = Ddi_BddMakePartConjVoid(ddm);
  
  Ddi_PostOrderBddAigVisitIntern(filter,aigNodes,-1);
  Ddi_PostOrderAigClearVisitedIntern(bmgr,aigNodes);
  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = 1;
  }
  for (i=0; i<Ddi_BddPartNum(f); i++) {
    Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
    bAigEdge_t baig = Ddi_BddToBaig(f_i);
    if (bAig_AuxInt(bmgr,baig)>0) {
      Ddi_BddPartInsertLast(fFiltered,f_i);
    }
  }
  Ddi_AigArrayClearAuxInt(bmgr,aigNodes);
  
  return fFiltered;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
VarOrdCompare(
  const void *v0p,
  const void *v1p
)
{
  return (DdiVarCompare(*((Ddi_Var_t **)v0p),*((Ddi_Var_t **)v1p)));
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
AuxIntAigCompare(
  const void *b0,
  const void *b1
)
{
  Ddi_Bdd_t *aig0 = *((Ddi_Bdd_t **)b0);
  Ddi_Bdd_t *aig1 = *((Ddi_Bdd_t **)b1);
  int aigInt0, aigInt1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(aig0);
  bAig_Manager_t *bmgr = ddm->aig.mgr;

  Pdtutil_Assert(Ddi_BddIsAig(aig0),"AIG expected in compare");
  Pdtutil_Assert(Ddi_BddIsAig(aig1),"AIG expected in compare");

  aigInt0 = bAig_AuxInt(bmgr,Ddi_BddToBaig(aig0));
  aigInt1 = bAig_AuxInt(bmgr,Ddi_BddToBaig(aig1));

  return (aigInt1-aigInt0);
}

/**Function********************************************************************
  Synopsis    [Return support of Aig]
  Description [Return support of Aig]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Varset_t *
DdiAigSupp (
  Ddi_Bdd_t *fAig
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *manager = ddm->aig.mgr;
  Ddi_Varset_t *supp = NULL;
  Ddi_Var_t *v;
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  Ddi_Var_t **vA=NULL;
  int j, k, nv=0;
  int computeVarsetCU = 1;
  int sorted = 0;

  if (bAig_NodeIsConstant(Ddi_BddToBaig(fAig))) {
    supp = Ddi_VarsetVoid(ddm);
  } else {
    postOrderAigVisitIntern(manager,Ddi_BddToBaig(fAig),visitedNodes,-1);
    postOrderAigClearVisitedIntern(manager,visitedNodes);

    for (j=nv=0; j<visitedNodes->num; j++) {
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (bAig_isVarNode(manager,baig)) {
	nv++;
      }
    }
    vA = Pdtutil_Alloc(Ddi_Var_t *, nv);
    for (j=k=0; j<visitedNodes->num; j++) {
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (bAig_isVarNode(manager,baig)) {
	v = (Ddi_Var_t *) bAig_VarPtr(manager, baig);
	if (v==NULL) {
          v = Ddi_VarFromBaig(ddm,baig);
	}
        Pdtutil_Assert(v!=NULL,"NULL var");
        vA[k++] = v;
        if (Ddi_VarIsAig(v)) {
	  computeVarsetCU = 0;
	}
      }
    }
    Pdtutil_Assert(k==nv,"wrong var num");
  }

  if (nv>0&&nv<200) {
    qsort((void **)vA,nv,sizeof(Ddi_Var_t *),VarOrdCompare);
    sorted = 1;
  }
  else if (nv>0 && !computeVarsetCU) {
    /* resize cnt aux arrays */
    int totVS = Ddi_VararrayNum(ddm->variables);
    int oldVS = ddm->varCntSortData.varSize;
    int *cntV;
    int minV=0, maxV=0;
    int l=0;

    if (oldVS == 0) {
      ddm->varCntSortData.varCnt = Pdtutil_Alloc(int, totVS);
    }
    else if (oldVS < totVS) {
      ddm->varCntSortData.varCnt =
        Pdtutil_Realloc(int, ddm->varCntSortData.varCnt, totVS);
    }
    for (j=oldVS; j<totVS; j++) {
      ddm->varCntSortData.varCnt[j] = 0;
    }
    oldVS = ddm->varCntSortData.varSize = totVS;

    /* cnt sort */
    cntV = ddm->varCntSortData.varCnt;
    for (j=0; j<nv; j++) {
      Ddi_Var_t *v_j = vA[j];
      /* sort by index */
      cntV[l=Ddi_VarIndex(v_j)]++;
      if (j==0) {
	minV=maxV=l;
      }
      else if (l>maxV) maxV=l;
      else if (l<minV) minV=l;
    }
    for (l=0,j=minV; j<=maxV; j++) {
      if (cntV[j]>0) {
	Ddi_Var_t *v_j = Ddi_VararrayRead(ddm->variables,j);
	cntV[j]=0;
	vA[l++]=v_j;
      }
    }

  }

  if (nv>0) {
    Ddi_MgrAbortOnSiftSuspend(ddm);
    Ddi_MgrSiftSuspend(ddm);

    if (computeVarsetCU) {
      DdNode *suppCU = Ddi_BddToCU(Ddi_MgrReadOne(ddm));
      Cudd_Ref(suppCU);
      if (!sorted) {
	qsort((void **)vA,nv,sizeof(Ddi_Var_t *),VarOrdCompare);
      }
      for (j=nv-1; j>=0; j--) {
        Ddi_Var_t *v_j = vA[j];
        DdNode *vCU_j = Ddi_VarToCU(v_j);
        DdNode *tmpCU = Cudd_bddAnd(ddm->mgrCU,suppCU,vCU_j);
        Cudd_Ref(tmpCU);
        Cudd_RecursiveDeref (ddm->mgrCU, suppCU);
        suppCU = tmpCU;
      }
      supp = Ddi_VarsetMakeFromCU(ddm,suppCU);
      Cudd_RecursiveDeref (ddm->mgrCU, suppCU);
    }
    else {
      supp = Ddi_VarsetVoid(ddm);
      Ddi_VarsetSetArray(supp);
      for (j=0;j<nv; j++) {
	Ddi_Var_t *v_j = vA[j];
        if (0&&!Ddi_VarsetIsVoid(supp)) {
          Ddi_Var_t *v_s = Ddi_VarsetTop(supp);
          // GpC: check this
	  // Pdtutil_Assert(DdiVarIsAfterVar(v_s,v_j),"wrong var ord");
        }
        Ddi_VarsetAddAcc(supp,v_j);
      }
    }

    Ddi_MgrSiftResume(ddm);
    Ddi_MgrAbortOnSiftResume(ddm);

  }

  Pdtutil_Free(vA);

  bAigArrayFree(visitedNodes);

  return(supp);
}

/**Function********************************************************************
  Synopsis    [Return support of Aig]
  Description [Return support of Aig]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Varset_t *
DdiAigArraySupp (
  Ddi_Bddarray_t *fAigA
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigA);
  bAig_Manager_t *manager = ddm->aig.mgr;
  Ddi_Varset_t *supp = NULL;
  Ddi_Var_t *v;
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  Ddi_Var_t **vA=NULL;
  int j, k, nv=0, nRoots=Ddi_BddarrayNum(fAigA);
  int computeVarsetCU = 1;
  int sorted = 0;

  for (j=0; j<nRoots; j++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fAigA,j);
    Ddi_PostOrderBddAigVisitIntern(f,visitedNodes,-1);
  }
  postOrderAigClearVisitedIntern(manager,visitedNodes);

  for (j=nv=0; j<visitedNodes->num; j++) {
    bAigEdge_t baig = visitedNodes->nodes[j];
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if (bAig_isVarNode(manager,baig)) {
      nv++;
    }
  }
  if (nv==0) {
    supp = Ddi_VarsetVoid(ddm);
  }
  else {
    vA = Pdtutil_Alloc(Ddi_Var_t *, nv);
    for (j=k=0; j<visitedNodes->num; j++) {
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (bAig_NodeIsConstant(baig)) {
        continue;
      }
      if (bAig_isVarNode(manager,baig)) {
        v = (Ddi_Var_t *) bAig_VarPtr(manager, baig);
        if (v==NULL) {
          v = Ddi_VarFromBaig(ddm,baig);
        }
        vA[k++] = v;
        if (Ddi_VarIsAig(v)) {
          computeVarsetCU = 0;
        }
      }
    }
    Pdtutil_Assert(k==nv,"wrong var num");

    if (nv>0&&nv<200) {
      qsort((void **)vA,nv,sizeof(Ddi_Var_t *),VarOrdCompare);
      sorted = 1;
    }
    else if (nv>0 && !computeVarsetCU) {
      /* resize cnt aux arrays */
      int totVS = Ddi_VararrayNum(ddm->variables);
      int oldVS = ddm->varCntSortData.varSize;
      int *cntV;
      int minV=0, maxV=0;
      int l=0;

      if (oldVS == 0) {
        ddm->varCntSortData.varCnt = Pdtutil_Alloc(int, totVS);
      }
      else if (oldVS < totVS) {
        ddm->varCntSortData.varCnt =
          Pdtutil_Realloc(int, ddm->varCntSortData.varCnt, totVS);
      }
      for (j=oldVS; j<totVS; j++) {
        ddm->varCntSortData.varCnt[j] = 0;
      }
      oldVS = ddm->varCntSortData.varSize = totVS;

      /* cnt sort */
      cntV = ddm->varCntSortData.varCnt;
      for (j=0; j<nv; j++) {
        Ddi_Var_t *v_j = vA[j];
        /* sort by index */
        cntV[l=Ddi_VarIndex(v_j)]++;
        if (j==0) {
          minV=maxV=l;
        }
        else if (l>maxV) maxV=l;
        else if (l<minV) minV=l;
      }
      for (l=0,j=minV; j<=maxV; j++) {
        if (cntV[j]>0) {
          Ddi_Var_t *v_j = Ddi_VararrayRead(ddm->variables,j);
          cntV[j]=0;
          vA[l++]=v_j;
        }
      }

    }
  }


  if (nv>0) {
    Ddi_MgrAbortOnSiftSuspend(ddm);
    Ddi_MgrSiftSuspend(ddm);

    if (computeVarsetCU) {
      DdNode *suppCU = Ddi_BddToCU(Ddi_MgrReadOne(ddm));
      Cudd_Ref(suppCU);
      if (!sorted) {
	qsort((void **)vA,nv,sizeof(Ddi_Var_t *),VarOrdCompare);
      }
      for (j=nv-1; j>=0; j--) {
        Ddi_Var_t *v_j = vA[j];
        DdNode *vCU_j = Ddi_VarToCU(v_j);
        DdNode *tmpCU = Cudd_bddAnd(ddm->mgrCU,suppCU,vCU_j);
        Cudd_Ref(tmpCU);
        Cudd_RecursiveDeref (ddm->mgrCU, suppCU);
        suppCU = tmpCU;
      }
      supp = Ddi_VarsetMakeFromCU(ddm,suppCU);
      Cudd_RecursiveDeref (ddm->mgrCU, suppCU);
    }
    else {
      supp = Ddi_VarsetVoid(ddm);
      Ddi_VarsetSetArray(supp);
      for (j=0; j<nv; j++) {
	Ddi_Var_t *v_j = vA[j];
        if (0&&!Ddi_VarsetIsVoid(supp)) {
          Ddi_Var_t *v_s = Ddi_VarsetTop(supp);
	  //  	  Pdtutil_Assert(DdiVarIsAfterVar(v_s,v_j),"wrong var ord");
        }
        Ddi_VarsetAddAcc(supp,v_j);
      }
    }

    Ddi_MgrSiftResume(ddm);
    Ddi_MgrAbortOnSiftResume(ddm);

  }

  Pdtutil_Free(vA);

  bAigArrayFree(visitedNodes);

  return(supp);
}

/**Function********************************************************************
  Synopsis    [Return support of Aig]
  Description [Return support of Aig]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigFanoutCount (
  Ddi_Bdd_t *fAig,
  Ddi_Var_t *v
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *manager = ddm->aig.mgr;

  int cnt = bAig_FanoutNodeCount(manager,Ddi_BddToBaig(fAig),
				 Ddi_VarBaigId(v));

  return(cnt);
}


/**Function********************************************************************
  Synopsis    [Return support of Aig]
  Description [Return support of Aig]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigVararraySortByFlow(
  Ddi_Vararray_t *vA,
  Ddi_Bdd_t *fAig
)
{
  return AigVararraySortByFlow(vA,fAig);
}

/**Function********************************************************************
  Synopsis    [Return support of Aig]
  Description [Return support of Aig]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigVararraySortByFanout(
  Ddi_Vararray_t *vA,
  Ddi_Bdd_t *fAig
)
{
  return AigVararraySortByFanout(vA,fAig);
}

/**Function********************************************************************
  Synopsis    [Return support of Aig]
  Description [Return support of Aig]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigFlowCount (
  Ddi_Bdd_t *fAig,
  Ddi_Var_t *v
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex = Ddi_VarBaigId(v);

  int i, cnt, *flow;

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,Ddi_BddToBaig(fAig),visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);

  flow = Pdtutil_Alloc(int,visitedNodes->num);

  for (i=cnt=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig, right, left;
    int ir, il;
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
    flow[i] = 0;
    if (bAig_NonInvertedEdge(baig) == bAig_NonInvertedEdge(varIndex)) {
      flow[i] = 1;
    }
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      flow[i] = flow[ir] || flow[il];
    }
    cnt += flow[i];
  }

  bAigArrayFree(visitedNodes);
  Pdtutil_Free(flow);

  return(cnt);
}



/**Function********************************************************************
  Synopsis    [Return Aig Not]
  Description [Return Aig Not]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Aig_t *
DdiAigNot (
  Ddi_Aig_t *a
)
{
  bAigEdge_t rBaig;
  rBaig = bAig_Not(a->aigNode);

  return(DdiAigMakeFromBaig(a->mgr,rBaig));
}

/**Function********************************************************************
  Synopsis    [Return Aig And]
  Description [Return Aig And]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Aig_t *
DdiAigAnd (
  Ddi_Aig_t *a,
  Ddi_Aig_t *b
)
{
  bAig_Manager_t *mgr = a->mgr;
  bAigEdge_t rBaig;
  rBaig = bAig_And(mgr,a->aigNode,b->aigNode);

  return(DdiAigMakeFromBaig(mgr,rBaig));
}

/**Function********************************************************************
  Synopsis    [Return Aig Or]
  Description [Return Aig Or]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Aig_t *
DdiAigOr (
  Ddi_Aig_t *a,
  Ddi_Aig_t *b
)
{
  bAig_Manager_t *mgr = a->mgr;
  bAigEdge_t rBaig;
  rBaig = bAig_Or(mgr,a->aigNode,b->aigNode);

  return(DdiAigMakeFromBaig(mgr,rBaig));
}

/**Function********************************************************************
  Synopsis    [Return Aig Xor]
  Description [Return Aig Xor]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Aig_t *
DdiAigXor (
  Ddi_Aig_t *a,
  Ddi_Aig_t *b
)
{
  bAig_Manager_t *mgr = a->mgr;
  bAigEdge_t rBaig;
  rBaig = bAig_Xor(mgr,a->aigNode,b->aigNode);

  return(DdiAigMakeFromBaig(mgr,rBaig));
}

/**Function********************************************************************
  Synopsis    [Return Aig And]
  Description [Return Aig And]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigCofactorAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Var_t *v,
  int val
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *newfAig;
  bAigEdge_t varIndex = Ddi_VarToBaig(v);

  if (Ddi_BddIsConstant(fAig)) return fAig;
  bAig_AuxPtrNum(bmgr,varIndex) = val ? bAig_One : bAig_Zero;

  nodeSetVisited(bmgr,varIndex);

  newfAig = Ddi_BddMakeFromBaig(Ddi_ReadMgr(fAig),
    composeIntern(bmgr,Ddi_BddToBaig(fAig),0));

  composeClearVisitedIntern(bmgr,Ddi_BddToBaig(fAig),0);
  nodeClearVisited(bmgr,varIndex);

  bAig_AuxPtr(bmgr,varIndex) = NULL;

  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);

  Ddi_Free(newfAig);

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Return Aig And]
  Description [Return Aig And]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
DdiAigArrayCofactorAcc (
  Ddi_Bddarray_t *fA,
  Ddi_Var_t *v,
  int val
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  Ddi_Vararray_t *vA = Ddi_VararrayAlloc (ddm,1);
  Ddi_Bddarray_t *cA = Ddi_BddarrayAlloc(ddm,1);
  Ddi_Bdd_t *aigVal = Ddi_BddMakeConstAig(ddm, val);

  Ddi_VararrayWrite(vA,0,v);
  Ddi_BddarrayWrite(cA,0,aigVal);

  Ddi_BddarrayComposeAcc(fA,vA,cA);

  Ddi_Free(vA);
  Ddi_Free(cA);
  Ddi_Free(aigVal);

  return(fA);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigComposeAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Vararray_t *vA,
  Ddi_Bddarray_t *gA
)
{
  int n, j;
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig;
  int freeG = 0;

  /* the length of the two arrays must be the same */
  n = Ddi_VararrayNum(vA);
  Pdtutil_Assert(n==Ddi_BddarrayNum(gA),
    "different length of var/func arrays in compose");
  bmgr = Ddi_ReadMgr(vA)->aig.mgr;

  for (j=0;j<n;j++) {
    bAigEdge_t bIndex;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in compose");
    if (!Ddi_BddIsAig(Ddi_BddarrayRead(gA,j))) {
      if (!freeG) {
	freeG = 1;
	gA = Ddi_BddarrayDup(gA);
      }
      Ddi_BddSetAig(Ddi_BddarrayRead(gA,j));
    }
    bIndex = Ddi_BddToBaig(Ddi_BddarrayRead(gA,j));

    bAig_AuxPtrNum(bmgr,varIndex) = bIndex;
    nodeSetVisited(bmgr,varIndex);
    bAig_Ref(bmgr, bIndex);
  }

  newfAig = Ddi_BddMakeFromBaig(Ddi_ReadMgr(fAig),
    composeIntern(bmgr,Ddi_BddToBaig(fAig),0));

  composeClearVisitedIntern(bmgr,Ddi_BddToBaig(fAig),0);

#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  for (j=0;j<n;j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in compose");

    if (bAig_AuxPtr(bmgr,varIndex) != NULL) {
      bAig_RecursiveDeref(bmgr,bAig_AuxPtrNum(bmgr,varIndex));
      bAig_AuxPtr(bmgr,varIndex) = NULL;
    }
    if (nodeVisited(bmgr,varIndex)) {
      nodeClearVisited(bmgr,varIndex);
    }
  }
#endif

  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);

  if (freeG) {
    Ddi_Free(gA);
  }

  Ddi_Free(newfAig);

  return(fAig);
}

/**Function********************************************************************

  Synopsis    [Count nodes of a bAig. Internal recursion]
  Description [Count nodes of a bAig. Internal recursion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigArraySize(
  Ddi_Bddarray_t *aigArray
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(aigArray);
  int i, count = 0;

  for (i=0; i<Ddi_BddarrayNum(aigArray); i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(aigArray,i);
    //Pdtutil_Assert( Ddi_BddIsAig(f), "AIG required by AIG array size");
    if (Ddi_BddIsPartConj(f)|| Ddi_BddIsPartDisj(f)) {
      int j;
      for (j=0; j<Ddi_BddPartNum(f); j++) {
	Ddi_Bdd_t *f_j = Ddi_BddPartRead(f,j);
	bAigEdge_t fBaig = Ddi_BddToBaig(f_j);
	count += myNodeCountIntern(ddm->aig.mgr,fBaig);
      }
    }
    else {
      bAigEdge_t fBaig = Ddi_BddToBaig(f);
      count += myNodeCountIntern(ddm->aig.mgr,fBaig);
    }
  }
  for (i=0; i<Ddi_BddarrayNum(aigArray); i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(aigArray,i);
    if (Ddi_BddIsPartConj(f)|| Ddi_BddIsPartDisj(f)) {
      int j;
      for (j=0; j<Ddi_BddPartNum(f); j++) {
	Ddi_Bdd_t *f_j = Ddi_BddPartRead(f,j);
	bAigEdge_t fBaig = Ddi_BddToBaig(f_j);
	myNodeClearVisitedIntern(ddm->aig.mgr,fBaig);
      }
    }
    else {
      bAigEdge_t fBaig = Ddi_BddToBaig(f);
      myNodeClearVisitedIntern(ddm->aig.mgr,fBaig);
    }
  }
  return count;
}

/**Function********************************************************************

  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigCnfLit(
  Solver& S,
  Ddi_Bdd_t *node
)
{
  return aigCnfLit(S, node);
}

/**Function********************************************************************
  Synopsis    [Print some statistics about an aig.]
  Description [Print some statistics about an aig.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigPrintStats (
  Ddi_Bdd_t *fAig
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
   bAigEdge_t fBaig = Ddi_BddToBaig(fAig);

   fprintf(dMgrO(ddm),"======================= AIG Statistics\n");
   bAig_PrintStats(ddm->aig.mgr, fBaig);
   fprintf(dMgrO(ddm),"======================================\n");
   return 1;
}


/**Function********************************************************************
  Synopsis    [Print some statistics about an aig.]
  Description [Print some statistics about an aig.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigPrintNodeStats (
  Ddi_Bdd_t *fAig,
  int npsVars
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
   bAigEdge_t fBaig = Ddi_BddToBaig(fAig);
   Ddi_Bdd_t *mono = Ddi_BddMakeMono(fAig);
   int size = Ddi_BddSize(fAig);
   double density = Ddi_BddCountMinterm(mono, npsVars)/(float)size;

   Ddi_Free(mono);
   fprintf(dMgrO(ddm),"================================================ AIG NODE Statistics\n");
   fprintf(dMgrO(ddm),"Size = %d, density = %g\n", size, density);
   bAig_PrintNodeStats(ddm->aig.mgr, fBaig);
   fprintf(dMgrO(ddm),"====================================================================\n");
   return 1;
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOrDpartDecompose (
  Ddi_Bdd_t *fAig,
  int nPart,
  int maxRedFactor
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Bdd_t *result=Ddi_AigOrDecompose(fAig);
  int sizeM, size_i;

  if (result != NULL)
  while (Ddi_BddPartNum(result) < nPart) {
    int i, maxp = -1;
    Ddi_Bdd_t *newpart, *oldpart;
    sizeM = Ddi_BddSize(fAig)/maxRedFactor;
    for (i=0; i<Ddi_BddPartNum(result); i++) {
      size_i = Ddi_BddSize(Ddi_BddPartRead(result,i));
      if (size_i > sizeM) {
	maxp = i; sizeM = size_i;
      }
    }
    if (maxp<0) break;
    oldpart = Ddi_BddPartExtract(result,maxp);
    newpart = Ddi_AigOrDecompose(oldpart);
    if (newpart == NULL) {
      Ddi_Free(oldpart);
      Ddi_Free(newpart);
      break;
    }
    Ddi_BddPartInsert(result,maxp,Ddi_BddPartRead(newpart,1));
    Ddi_BddPartInsert(result,maxp,Ddi_BddPartRead(newpart,0));
    Ddi_Free(oldpart);
    Ddi_Free(newpart);
  }
  return result;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOrDecompose (
  Ddi_Bdd_t *fAig
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
   bAigEdge_t fBaig = Ddi_BddToBaig(fAig), t0, t1;
   Ddi_Bdd_t *result=NULL, *f0, *f1;
   bAig_Manager_t  *bmgr = ddm->aig.mgr;

   if (bAig_OrDecompose(bmgr,fBaig,&t0,&t1) == 0) {
     return NULL;
   }

   f0 = Ddi_BddMakeFromBaig(ddm, t0);
   f1 = Ddi_BddMakeFromBaig(ddm, t1);

   {
     Ddi_Bdd_t *t = Ddi_BddOr(f0,f1);
     Pdtutil_Assert(Ddi_BddEqual(t,fAig),"Invalid Or decomp");
     Ddi_Free(t);
   }
   result = Ddi_BddMakePartDisjVoid(ddm);

   Ddi_BddPartInsertLast(result,f0);
   Ddi_BddPartInsertLast(result,f1);
   Ddi_Free(f0);
   Ddi_Free(f1);

   return result;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigDisjDecompWithVars(
  Ddi_Bdd_t *fAig, 
  Ddi_Bddarray_t *partitionLits
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
   Ddi_Bdd_t *fPart = Ddi_BddDup(fAig);
   int i;

   Ddi_BddSetPartDisj(fPart);

   for (i=0; i<Ddi_BddarrayNum(partitionLits); i++) {
     Ddi_Var_t *v = Ddi_BddTopVar(Ddi_BddarrayRead(partitionLits,i));
     Ddi_Bdd_t *fDup = Ddi_BddDup(fPart);
     Ddi_Bdd_t *lit0 = Ddi_BddMakeLiteralAig(v, 0);
     Ddi_Bdd_t *lit1 = Ddi_BddMakeLiteralAig(v, 1);
     int np = Ddi_BddPartNum(fPart);
     Ddi_BddCofactorAcc(fPart,v,0);
     Ddi_BddCofactorAcc(fDup,v,1);
     for (int j=0; j<np; j++) {
       Ddi_Bdd_t *p_j_0 = Ddi_BddPartRead(fPart,j);
       Ddi_Bdd_t *p_j_1 = Ddi_BddPartRead(fDup,j);
       Ddi_BddAndAcc(p_j_0,lit0);
       Ddi_BddAndAcc(p_j_1,lit1);
       Ddi_BddPartInsertLast(fPart,p_j_1);
     }
     Ddi_Free(fDup);
     Ddi_Free(lit0);
     Ddi_Free(lit1);
   }
   
   return fPart;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSubsetNode (
  Ddi_Bdd_t *fAig,
  int npsVars,
  int verbose
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
   bAigEdge_t fBaig = Ddi_BddToBaig(fAig), subset;
   Ddi_Bdd_t *subAig, *mono, *result=NULL;
   int i, size, bestSub=0;
   double density, bestDens=-1;

   for (i=0; i<Ddi_BddSize(fAig); i++) {
      subset = bAig_SubsetNode(ddm->aig.mgr, fBaig, i, verbose);
      subAig = Ddi_BddMakeFromBaig(ddm, subset);
      size = Ddi_BddSize(subAig);
      if (size)
	 density = Ddi_AigEstimateMintermCount(subAig, npsVars)/(float)size;
      else
	 density = 0;
      if (density >= bestDens) {
	 Ddi_Free(result);
	 result = Ddi_BddDup(subAig);
	 bestDens = density;
	 bestSub = i;
      }
      Ddi_Free(subAig);
   }

   if (verbose && result) {
      fprintf(dMgrO(ddm),"Best node to subset = %d\n", bestSub);
      fprintf(dMgrO(ddm),"Result: size = %d, density = %g ", Ddi_BddSize(result), bestDens);
      mono = Ddi_BddMakeMono(fAig);
      density = Ddi_BddCountMinterm(mono, npsVars)/(float)Ddi_BddSize(fAig);
      Ddi_Free(mono);
      fprintf(dMgrO(ddm),"(original: %d, %g)\n", Ddi_BddSize(fAig), density);
   }

   return result;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatNnfAbstrPba (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *initAbstr,
  Ddi_Bdd_t *g,
  Ddi_Vararray_t *ps,
  Ddi_Vararray_t *ns
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
   Ddi_Bdd_t *abstrF;
   Ddi_Varset_t *proj;
   Ddi_Vararray_t *projA;
   int chk=1, i, doRefine=1, sat=0, size0;
   Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
   long cpuTime=0, startTime=0;
   int maxRefIter=200;

   Pdtutil_Assert(initAbstr!=NULL,
                  "initial abstr needed for nnf pba");

   if (Ddi_AigSatAnd(f,g,NULL)) {
     return NULL;
   }
   
   proj = Ddi_BddSupp(initAbstr);
   projA = Ddi_VararrayMakeFromVarset(proj,1);
   Ddi_VararrayIntersectAcc(projA,ns);
   abstrF = Ddi_BddDup(initAbstr);
   startTime = util_cpu_time ();

   for (i=0, doRefine=1; doRefine; i++) {
     Ddi_Bdd_t *cex=Ddi_AigSatAndWithCexAndAbort(g,abstrF,
                      NULL,NULL,-1,NULL);
     if (cex==NULL) {
       doRefine = 0;
     }
     else if (i>=maxRefIter) {
       Ddi_BddAndAcc(abstrF,f);
       break;
     }
     else {
       Ddi_Bdd_t *refine = Ddi_BddDup(f);
       Ddi_Bdd_t *resOpt, *cexAbstr;
       int res, maxGen = -50; // negative for weak generalization
       
       //       cexAbstr = Ddi_BddNot(cex);
#if 0
       cexAbstr = Ddi_BddDup(cex);
#else
       cexAbstr = Ddi_AigInterpolantByGenClauses(g,
                  f, NULL, abstrF,
                  ps,ns,NULL,ns,NULL,NULL,NULL,maxGen,0,&res);
#endif
       //       Ddi_AigGeneralizeItpAcc (f, cexAbstr, NULL, 0);
       //Ddi_BddNotAcc(cexAbstr);
#if 0
       resOpt=Ddi_AigOptByMonotoneCoreAcc (refine,cexAbstr,NULL,0,-1.0);
#else
       Ddi_BddNotAcc(abstrF);
       Ddi_BddOrAcc(cexAbstr,abstrF);
       Ddi_BddNotAcc(abstrF);
#if 1
       Ddi_BddNotAcc(refine);
       Ddi_AigGeneralizeItpAcc (cexAbstr, refine, NULL, 0);
       //       Ddi_DataCopy(refine,cexAbstr);
       Ddi_BddNotAcc(refine);
#endif
       resOpt=Ddi_AigOptByMonotoneCoreAcc (refine,f,NULL,1,-1.0);
#endif       
       if (resOpt==NULL) {
         sat = 1;
         doRefine=0;
       }
       else {
         Ddi_DataCopy(abstrF,refine);
         //Ddi_BddAndAcc(abstrF,refine);
       }
       Ddi_Free(refine);
       Ddi_Free(cexAbstr);
     }
     Ddi_Free(cex);
   }
   Ddi_Free(proj);
   Ddi_Free(projA);

   cpuTime = util_cpu_time() - startTime;

   size0 = Ddi_BddSize(f);
   Ddi_DataCopy(f, abstrF);
   if (!sat) {
     if (verbosity >= Pdtutil_VerbLevelDevMin_c) {
       fprintf(dMgrO(ddm),"pba NNF ABS: %d(%d)->%d (%d iterations) - time; %s\n",

               size0, Ddi_BddSize(initAbstr), Ddi_BddSize(f), i,
               util_print_time(cpuTime)
               );
     }
   }

   if (chk && !sat) {
     Pdtutil_Assert(!Ddi_AigSatAnd(f,g,NULL),
                    "unsat needed for pba");
   }
   Ddi_Free(abstrF);
   if (sat) return NULL;
   else 
     return f;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatNnfSubset (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g,
  Ddi_Bdd_t *care
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
   Ddi_Bdd_t *subAig, *fNnf;
   int sat;
   Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
   Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
   Ddi_Vararray_t *aV = Ddi_VararrayAlloc(ddm,0);
   int chk = 0;

   fNnf = Ddi_AigNnf (f,NULL,constr,rV,aV,NULL);

   Ddi_BddSetAig(constr);
   if (care!=NULL) {
     Ddi_BddAndAcc(constr,care);
   }

   subAig = aigSat22NnfSubset(fNnf,g,constr,&sat,-1.0);
   if (sat) {
     Ddi_BddAigFromNnfAcc(subAig,rV);
   }

   Ddi_Free(constr);
   Ddi_Free(rV);
   Ddi_Free(aV);

   if (chk && sat) {
     /* verify result correctness (s => f): s*!f must be unsat */
     Ddi_Bdd_t *notf;
     notf = Ddi_BddNot(f);
     Pdtutil_Assert(!Ddi_AigSatAnd(notf,subAig,NULL), "invalid subset");
     Ddi_Free(notf);
   }

   Ddi_Free(fNnf);

   return subAig;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigNnfStats (
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *filterVars,
  int doExist
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);

   Ddi_Vararray_t *aV0 = Ddi_VararrayAlloc(ddm,0);
   Ddi_Vararray_t *aV1 = Ddi_VararrayAlloc(ddm,0);
   Ddi_Vararray_t *vars = Ddi_VararrayAlloc(ddm,0);
   Ddi_Bdd_t *f2 = Ddi_AigNnf (f,filterVars,NULL,vars,aV0,aV1);

   Ddi_Vararray_t *supp = Ddi_BddSuppVararray(f2);
   Ddi_VararrayWriteMark (supp, 1);

   Ddi_Bdd_t *cube = Ddi_BddMakeConstAig(ddm, 1);
   Ddi_Bddarray_t *lits = Ddi_BddarrayAlloc(ddm,0);
   
   int mon0 = 0, mon1 = 0, v01 = 0;
   int maxfo = 0, maxfl=0, ifo=-1, ifl=-1, mfl0, mfl1, mfo0, mfo1;
   for (int i=0; i<Ddi_VararrayNum(vars); i++) {
     Ddi_Var_t *v_i = Ddi_VararrayRead(vars,i);
     Ddi_Var_t *a0_i = Ddi_VararrayRead(aV0,i);
     Ddi_Var_t *a1_i = Ddi_VararrayRead(aV1,i);
     int m0 = Ddi_VarReadMark(a0_i);
     int m1 = Ddi_VarReadMark(a1_i);
     int mV = Ddi_VarReadMark(v_i);
     if (m0==m1) {
       int fo0 = DdiAigFanoutCount (f2,a0_i);
       int fo1 = DdiAigFanoutCount (f2,a1_i);
       int fl0 = DdiAigFlowCount (f2,a0_i);
       int fl1 = DdiAigFlowCount (f2,a1_i);
       if (fo0+fo1 > maxfo) {
         maxfo = fo0+fo1; mfo0 = fo0; mfo1 = fo1;
         ifo = i;
       }
       if (fl0+fl1 > maxfl) {
         maxfl = fl0+fl1; mfl0 = fl0; mfl1 = fl1;
         ifl = i;
       }
       v01++;
       continue;
     }
     if (m0>0) {
       mon0++;
       Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v_i, 0);
       Ddi_BddAndAcc(cube,lit);
       Ddi_BddarrayInsertLast(lits,lit);
       Ddi_Free(lit);
     }
     else {
       mon1++;
       Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v_i, 1);
       Ddi_BddAndAcc(cube,lit);
       Ddi_BddarrayInsertLast(lits,lit);
       Ddi_Free(lit);
     }
   }
   printf("maxfo: %d + %d - var: %d\n", mfo0, mfo1, ifo);
   printf("maxfl: %d + %d - var: %d\n", mfl0, mfl1, ifl);
   Ddi_VararrayWriteMark (supp, 0);
   Ddi_Free(supp); 
   printf("NNF MONOTONE vars: %d->0, %d->1 (01: %d)\n",
           mon0, mon1, v01);
   Ddi_Bdd_t *fSmooth = NULL;
   if (doExist) {
     int nExist = 0;
     Ddi_Bdd_t *cubeSm = Ddi_BddMakeConstAig(ddm, 1);
     fSmooth = Ddi_BddDup(f);
     for (int i = 0; nExist<doExist && i<Ddi_BddarrayNum(lits); i++) {
       Ddi_Bdd_t *lit = Ddi_BddarrayRead(lits,i);
       Ddi_Bdd_t *fDup = Ddi_BddDup(fSmooth);
       int sz0 = Ddi_BddSize(fDup);
       Ddi_AigConstrainCubeAcc(fDup,lit);
       Ddi_Var_t *v = Ddi_BddTopVar(lit); 
       Ddi_BddNotAcc(fDup);
       int enSmooth = strstr(Ddi_VarName(v),"PDTRAV")==NULL;
       enSmooth &= Ddi_AigSat(fDup);
       Ddi_BddNotAcc(fDup);
       if (enSmooth && Ddi_BddSize(fDup)>sz0/2) {
         nExist++;
         Pdtutil_Assert(Ddi_BddIncluded(fSmooth,fDup),"wrong var abstraction");
         Ddi_DataCopy(fSmooth,fDup);
         Ddi_BddAndAcc(cubeSm,lit);
       }
       Ddi_Free(fDup);
     }
     //     DdiLogBdd(cubeSm,0);
     printf("quantify %d/%d vars: %d->%d\n",
            nExist, mon0+mon1, Ddi_BddSize(f), Ddi_BddSize(fSmooth));
     Ddi_Free(cubeSm);
   }
   Ddi_Free(vars);
   Ddi_Free(cube);
   Ddi_Free(aV0);
   Ddi_Free(aV1);
   Ddi_Free(f2);
   return fSmooth;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatCore (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *care,
  Ddi_Bdd_t *eq,
  Ddi_Varset_t *projVars,
  int thresholdVars,
  int threshold,
  int strategy,
  int verbose
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
   Ddi_Bdd_t *subAig;
   int chk=0;
   int nnfSubsetting = 0;
   if (strategy==4) {
     strategy = 3;
     nnfSubsetting = 1;
   }
   else if (strategy==5) {
     strategy = 3;
     nnfSubsetting = 2;
   }

   if (verbose) {
     fprintf(dMgrO(ddm),"Aig SAT core (%d):\n", Ddi_BddSize(fAig));
   }

   switch (strategy) {
   case 1:
     {
       int res;
       Ddi_Bdd_t *window, *myCare;
       Ddi_Varset_t *vars = Ddi_BddSupp(fAig);
       Ddi_Varset_t *cvars = Ddi_BddSupp(care);
       Ddi_VarsetIntersectAcc(vars,cvars);
       Ddi_Free(cvars);
       if (1 && projVars != NULL) {
         Ddi_Free(vars);
         vars = Ddi_VarsetDup(projVars);
       }
       window = Ddi_AigExistProjectByGenClauses(fAig,care,
                                                NULL,vars,threshold,0,&res);
       Ddi_Free(vars);
       if (res) {
         Pdtutil_Assert(window==NULL,"wrong exist proj result");
         if (verbose) {
           fprintf(dMgrO(ddm),"SAT: no core\n");
         }
         return NULL;
       }
       Ddi_Free(vars);
       if (Ddi_BddIsOne(window) && (projVars!=NULL)) {
         Ddi_Free(window);
         window = Ddi_AigExistProjectByGenClauses(fAig,care,
                                                  NULL,projVars,1,0,&res);
       }
       subAig = Ddi_BddDup(fAig);
       Ddi_AigConstrainCubeAcc(subAig,window);
       Ddi_Free(subAig);
       subAig = Ddi_BddDup(window);
       if (1 && !Ddi_BddIsOne(subAig)) {
         myCare = Ddi_BddDup(care);
         Ddi_AigConstrainCubeAcc(myCare,window);
         vars = Ddi_BddSupp(window);
         Ddi_Free(window);
         window = Ddi_AigSatAndWithCexAndAbort(myCare,subAig,
                                               NULL,NULL,-1,NULL);
         Ddi_BddExistAcc(window,vars);
         Ddi_Free(vars);
         Ddi_Free(myCare);
         Ddi_Free(subAig);
         subAig = Ddi_BddDup(fAig);
         if (projVars != NULL) {
           Ddi_AigConstrainCubeAcc(subAig,window);
           Ddi_BddExistProjectAcc(window,projVars);
         }
       }
       Ddi_AigAndCubeAcc(subAig,window);
       Ddi_Free(window);
     }
     break;
   case 2:
     {
       int res;
       Ddi_Bdd_t *window, *myCare;
       Ddi_Varset_t *vars = Ddi_BddSupp(fAig);
       Ddi_Varset_t *cvars = Ddi_BddSupp(care);
       Ddi_VarsetDiffAcc(vars,cvars);
       Ddi_Free(cvars);
       if (1 && projVars != NULL) {
         Ddi_Free(vars);
         vars = Ddi_VarsetDup(projVars);
       }
       window = Ddi_AigExistProjectByGenClauses(fAig,care,
                                                NULL,vars,threshold,0,&res);
       Ddi_Free(vars);
       if (res) {
         Pdtutil_Assert(window==NULL,"wrong exist proj result");
         if (verbose) {
           fprintf(dMgrO(ddm),"SAT: no core\n");
         }
         return NULL;
       }
       subAig = Ddi_BddDup(window);
       //       Ddi_AigConstrainCubeAcc(subAig,window);
       Ddi_Free(window);
     }
     break;
   case 3:
     {
       int res, i, nPart=0;
       Ddi_Bdd_t *window, *myCare, *wPart;
       Ddi_Bdd_t *fAig2 = Ddi_BddDup(fAig);
       Ddi_Bdd_t *care2 = Ddi_BddDup(care);
       Ddi_Varset_t *vars, *cvars;
       int size1, size0;
       float ratio = 0.98;
       if (nnfSubsetting) {
	 ratio *= 1.5;
       }
       if (eq!=NULL) {
	 Ddi_Vararray_t *vars = Ddi_BddReadEqVars (eq);
	 Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst (eq);
	 Ddi_BddComposeAcc(fAig2,vars,subst);
	 Ddi_BddComposeAcc(care2,vars,subst);
       }
       size0 = Ddi_BddSize(care2);

       if (threshold>0 && size0<threshold) {
	 if (eq!=NULL) {
	   Ddi_Vararray_t *pVars = Ddi_BddSuppVararray(fAig2);
	   Ddi_Vararray_t *pVars2 = Ddi_BddSuppVararray(care2);
	   Ddi_VararrayUnionAcc(pVars,pVars2);
	   Ddi_Free(pVars2);
	   Ddi_VararrayWriteMark (pVars, 1);
	   if (Ddi_BddIsPartConj(eq)) {
	     int i, j;
	     subAig = Ddi_BddMakeConstAig(ddm,1);
	     for (i=0; i<Ddi_BddPartNum(eq); i++) {
	       Ddi_Bdd_t *e_i = Ddi_BddPartRead(eq,i);
	       Ddi_Vararray_t *vs_i = Ddi_BddSuppVararray(e_i);
	       int use_part=0;
	       for (j=0; j<Ddi_VararrayNum(vs_i); j++) {
		 Ddi_Var_t *v_j = Ddi_VararrayRead(vs_i,j);
		 if (Ddi_VarReadMark(v_j)>0) {
		   use_part = 1;
		 }
	       }
	       if (use_part) {
		 Ddi_BddAndAcc(subAig,e_i);
	       }
	       Ddi_Free(vs_i);
	     }
	   }
	   else {
	     subAig = Ddi_BddMakeAig(eq);
	   }
	   Ddi_VararrayWriteMark (pVars, 0);
	   Ddi_Free(pVars);
	 }
	 else {
	   subAig = Ddi_BddMakeConstAig(ddm,1);
	 }
	 Ddi_BddAndAcc(subAig,fAig2);
	 Ddi_BddAndAcc(subAig,care2);
       }
       else {
	 vars = Ddi_BddSupp(fAig);
	 cvars = Ddi_BddSupp(care);
	 Ddi_VarsetDiffAcc(vars,cvars);
	 Ddi_Free(cvars);
	 if (1 && projVars != NULL) {
	   Ddi_Free(vars);
	   vars = Ddi_VarsetDup(projVars);
	 }
	 window = Ddi_AigExistProjectByGenClauses(fAig,care,
                                                  NULL,vars,1,0,&res);
	 Ddi_Free(vars);
	 if (res) {
	   Pdtutil_Assert(window==NULL,"wrong exist proj result");
	   if (verbose) {
	     fprintf(dMgrO(ddm),"SAT: no core\n");
	   }
	   Ddi_Free(care2);
	   Ddi_Free(fAig2);
	   return NULL;
	 }
	 wPart = Ddi_AigPartitionTop(window,0);
	 subAig = Ddi_BddDup(fAig2);
	 if (thresholdVars<0) {
	   thresholdVars = Ddi_BddPartNum(wPart);
	 }
	 do {
	   Ddi_Bdd_t *save = Ddi_BddDup(subAig);
	   for (i=Ddi_BddPartNum(wPart)-1; i>=0; i--) {
	     Ddi_Bdd_t *newAig = Ddi_BddDup(subAig);
	     int size1, size0 = Ddi_BddSize(subAig);
	     if (nPart >= thresholdVars) break;
	     if (nnfSubsetting) {
	       Ddi_AigNnfSubsetWithCubeAcc(newAig,Ddi_BddPartRead(wPart,i));
	     }
	     else {
	       Ddi_AigAndCubeAcc(newAig,Ddi_BddPartRead(wPart,i));
	     }
	     size1 = Ddi_BddSize(newAig);
	     if (verbose) {
	       fprintf(dMgrO(ddm),"%d(%6.3f) ", i, ((float)size1)/size0);
	     }
	     if (size1<size0*ratio) {
	       Ddi_DataCopy(subAig,newAig);
	       Ddi_BddPartRemove(wPart,i);
	       nPart++;
	     }
	     Ddi_Free(newAig);
	   }
	   ratio = ratio * 1.05;
	   if (0 && nnfSubsetting) {
	     Pdtutil_Assert(Ddi_BddIncluded(subAig,save),
			    "wrong nnf subset");
	   }
	   Ddi_Free(save);
	 } while (ratio < 1.1 && nPart<thresholdVars);
	 //       Ddi_AigConstrainCubeAcc(subAig,window);
	 if (verbose) {
	   fprintf(dMgrO(ddm),
		   "\nAig SAT core used %d literals - size: %d\n",
		   nPart, Ddi_BddSize(subAig));
	 }
	 if (eq!=NULL) {
	   Ddi_Bdd_t *eqAig = Ddi_BddMakeAig(eq);
	   Ddi_BddAndAcc(subAig,eqAig);
	 }
	 Ddi_Free(window);
	 Ddi_Free(wPart);
       }
       Ddi_Free(care2);
       Ddi_Free(fAig2);
     }
     break;
   default:
     Pdtutil_Assert(0,"invalid aig sat core strategy");
   }

   if (chk) {
     /* verify result correctness (s => f): s*!f must be unsat */
     Ddi_Bdd_t *notfAig;
     notfAig = Ddi_BddNot(fAig);
     Pdtutil_Assert(!Ddi_AigSatAnd(notfAig,subAig,NULL), "invalid subset");
     Ddi_Free(notfAig);
   }

   return subAig;
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSubsetWithCubeAcc (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *cube,
  float ratio
)
{
  Ddi_Bdd_t *fSubset = Ddi_AigSubsetWithCube(f,cube,ratio);
  Ddi_DataCopy(f,fSubset);
  Ddi_Free(fSubset);
  return f;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSubsetWithCube (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *cube,
  float ratio
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
   Ddi_Bdd_t *constr = Ddi_BddMakePartConjFromCube(cube);
   int i, size0 = Ddi_BddSize(f);
   Ddi_Bdd_t *fSubset = Ddi_BddDup(f);
   Ddi_Bdd_t *constrOut = Ddi_BddMakeConstAig(ddm,1); 
   
   while (Ddi_BddPartNum(constr)>0) {
     int iMin = -1, sizeMin = size0+1;
     Ddi_Bdd_t *l;
     for (i=0; i<Ddi_BddPartNum(constr); i++) {
       Ddi_Bdd_t *l_i = Ddi_BddPartRead(constr,i);
       Ddi_Bdd_t *cof = Ddi_BddDup(fSubset);
       Ddi_AigConstrainCubeAcc(cof,l_i);
       int size_i = Ddi_BddSize(cof);
       Ddi_Free(cof);
       if (size_i<sizeMin) {
         iMin = i; sizeMin = size_i;
       }
     }
     l = Ddi_BddPartExtract(constr,iMin);
     Ddi_AigConstrainCubeAcc(fSubset,l);
     Ddi_Var_t *v_i = Ddi_BddTopVar(l);
     printf("state constr subset: %s (%d)\n", Ddi_VarName(v_i),
            !Ddi_BddIsComplement(l));
     Ddi_BddAndAcc(constrOut,l);
     Ddi_Free(l);
     if (Ddi_BddSize(fSubset) < size0*ratio) break;
   }
   Ddi_Free(constr);
   Ddi_BddAndAcc(fSubset,constrOut);
   Ddi_Free(constrOut);
   
   return fSubset;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSubsetWithCexOnControl (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *cex,
  Ddi_Bddarray_t *enables
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
   Ddi_Bddarray_t *constrEnables = Ddi_BddarrayDup(enables);
   Ddi_AigarrayConstrainCubeAcc(constrEnables,cex); 
   Ddi_Bdd_t *subset, *constrPart = Ddi_BddMakePartConjFromArray(enables);
   Ddi_Bdd_t *constrToUse;
   Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);

   int i;

   constrToUse = Ddi_BddMakePartConjVoid(ddm);
   for (i=0; i<Ddi_BddarrayNum(enables); i++) {
     Ddi_Bdd_t *ce_i = Ddi_BddarrayRead(constrEnables,i);
     Ddi_Bdd_t *p_i = Ddi_BddPartRead(constrPart,i);
     if (!Ddi_BddIsConstant(ce_i)) continue; // skip non constant
     if (Ddi_BddIsZero(ce_i)) {
       // complement
       Ddi_BddNotAcc(p_i);
     }
     Ddi_BddPartInsertLast(constrToUse,p_i);
   }

   subset = Ddi_AigConstrain(f,constrPart,1);
   Ddi_Free(constrToUse);
   if (Ddi_BddIsPartConj(subset)) {
     Ddi_AigStructRedRemAcc (constrPart,NULL);
     for (i=0; i<Ddi_BddPartNum(constrPart); i++) {
       Ddi_Bdd_t *c_i = Ddi_BddPartRead(constrPart,i);
       Ddi_BddPartInsertLast(subset,c_i);
     }
   }
   else {
     Ddi_BddSetAig(constrPart);
     Ddi_BddAndAcc(subset,constrPart);
     Ddi_AigStructRedRemAcc (subset,NULL);
   }
   Ddi_Free(constrEnables);
   Ddi_Free(constrPart);
   return subset;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSubsetWithCexConstr (
  Ddi_Bdd_t *cex,
  Ddi_Bddarray_t *enables
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(enables);
   Ddi_Bddarray_t *constrEnables = Ddi_BddarrayDup(enables);
   Ddi_AigarrayConstrainCubeAcc(constrEnables,cex); 
   Ddi_Bdd_t *constrPart = Ddi_BddMakePartConjFromArray(enables);
   Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);

   int i;

   for (i=0; i<Ddi_BddarrayNum(enables); i++) {
     Ddi_Bdd_t *ce_i = Ddi_BddarrayRead(constrEnables,i);
     Ddi_Bdd_t *p_i = Ddi_BddPartRead(constrPart,i);
     Pdtutil_Assert(Ddi_BddIsConstant(ce_i),"constant needed");
     if (Ddi_BddIsZero(ce_i)) {
       // complement
       Ddi_BddNotAcc(p_i);
     }
   }

   Ddi_Free(constrEnables);

   return constrPart;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSubset (
  Ddi_Bdd_t *fAig,
  int threshold,
  int verbose
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
   bAigEdge_t fBaig = Ddi_BddToBaig(fAig), subset;
   Ddi_Bdd_t *subAig, *checkAig, *notfAig;

   if (verbose) {
      fprintf(dMgrO(ddm),"======================= Initial AIG Statistics\n");
   }
   subset = bAig_Subset(ddm->aig.mgr, fBaig, threshold, verbose);
   subAig = Ddi_BddMakeFromBaig(ddm, subset);
   if (verbose) {
      fprintf(dMgrO(ddm),"======================== Subset AIG Statistics\n");
      bAig_PrintStats(ddm->aig.mgr, subset);
      fprintf(dMgrO(ddm),"==============================================\n");
   }

   /* verify result correctness (s => f): s*!f must be unsat */
   notfAig = Ddi_BddNot(fAig);
   checkAig = Ddi_BddAnd(notfAig, subAig);
   Ddi_Free(notfAig);
   Pdtutil_Assert(!Ddi_AigSat(checkAig), "invalid subset");
   Ddi_Free(checkAig);

   return subAig;
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSuperset (
  Ddi_Bdd_t *fAig,
  int threshold,
  int verbose
)
{
   Ddi_Bdd_t *superAig, *notfAig;

   notfAig = Ddi_BddNot(fAig);
   superAig = Ddi_BddNotAcc(Ddi_AigSubset(notfAig, threshold, verbose));
   Ddi_Free(notfAig);

   return superAig;
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSupersetNode (
  Ddi_Bdd_t *fAig,
  int npsVars,
  int verbose
)
{
   Ddi_Bdd_t *superAig, *notfAig;

   notfAig = Ddi_BddNot(fAig);
   superAig = Ddi_AigSubsetNode(notfAig, npsVars, verbose);
   if (superAig)
      Ddi_BddNotAcc(superAig);
   Ddi_Free(notfAig);

   return superAig;
}


/**Function********************************************************************
  Synopsis    [Return true (non 0) if the two DDs are equal (f==g).]
  Description [Return true (non 0) if the two DDs are equal (f==g).
    This test is presently limited to monolithic BDDs.]
  SideEffects []
******************************************************************************/
int
Ddi_AigEqualSat (
  Ddi_Bdd_t *f  /* first dd */,
  Ddi_Bdd_t *g  /* second dd */
)
{
  Ddi_Bdd_t *cmp = Ddi_BddXor(f,g);
  int ret = !Ddi_AigSat(cmp);
  Ddi_Free(cmp);
  return ret;
}

/**Function********************************************************************
  Synopsis    [Return true (non 0) if the two DDs are equal (f==g).]
  Description [Return true (non 0) if the two DDs are equal (f==g).
    This test is presently limited to monolithic BDDs.]
  SideEffects []
******************************************************************************/
int
Ddi_AigEqualSatWithCare (
  Ddi_Bdd_t *f  /* first dd */,
  Ddi_Bdd_t *g  /* second dd */,
  Ddi_Bdd_t *care  /* second dd */
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *cmp = Ddi_BddXor(f,g);
  Solver      S;
  int ret;

  if (Ddi_BddIsConstant(cmp)) {
    ret = Ddi_BddIsZero(cmp);
    Ddi_Free(cmp);
    return ret;
  }

  aig2CnfIdInit(ddm);
  MinisatClauses(S,cmp,care,NULL,0);
  aig2CnfIdClose(ddm);

  if (!S.okay()) {
    return ret=1;
  }
  else {
    S.solve();
    ret = !(S.okay());
  }

  Ddi_Free(cmp);
  return ret;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigCheckFixPoint (
  Ddi_Bdd_t *oldCheck,
  Ddi_Bdd_t *check,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *psVars,
  int maxIter
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(check);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *notOldCheck;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  Ddi_Bdd_t *careAig;
  Ddi_Varset_t *piVars, *auxV;
  Ddi_Bddarray_t *blockingArray = Ddi_BddarrayAlloc(ddm,0);
  int optCare=0, careSize=0;
  Ddi_Bdd_t *lit, *cexAig, *newState = NULL;;
  int timeLimit=100;
  int zeroOld = 0;
  int tryQbf = 0;

  Solver    S, S2;

  Ddi_Bdd_t *oldBdd = NULL;
  Ddi_Bdd_t *newSetBdd = NULL, *newBdd = NULL;

  //  Ddi_Bdd_t *oldBdd = Ddi_BddMakeMono(oldCheck);
  //  Ddi_Bdd_t *newSetBdd, *newBdd = Ddi_BddMakeMono(check);

  //  Ddi_BddExistProjectAcc(oldBdd,psVars);
  //  newSetBdd = Ddi_BddDiff(newBdd,oldBdd);
  //  if (Ddi_BddIsZero(newSetBdd)) {
  //  fprintf(dMgrO(ddm),"BDD fix point\n");
  //  }
  //  Ddi_Free(newSetBdd);

  vec<Lit> stateCex;
  vec<Lit> blocking;
  vec<Lit> assumps;

  int i, j, l, ret = -1, step, nState = Ddi_VarsetNum(psVars), nPi;
  int *checkStateVars, *piSatVars;
  int fullR;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;

  //  static int cnt = 0;
  // cnt++;
  if (Ddi_BddIsZero(check)) {
    Ddi_Free(blockingArray);
    return 1; /* UNSAT: no new val -> fix point */
  }

  if (care==NULL) {
    careAig = Ddi_BddMakeConstAig(ddm,1);
  }
  else {
    careAig = Ddi_BddDup(care);
    careSize = Ddi_BddSize(care);
  }
  notOldCheck = Ddi_BddNot(oldCheck);
  zeroOld = Ddi_BddIsZero(oldCheck);

  piVars = Ddi_BddSupp(oldCheck);
  if (Ddi_VarsetIsArray(psVars)) {
    Ddi_VarsetSetArray(piVars);
  }
  Ddi_VarsetDiffAcc(piVars,psVars);
  fullR = Ddi_VarsetIsVoid(piVars);

  if (tryQbf) {
    Ddi_Vararray_t *forallVars = Ddi_VararrayMakeFromVarset(piVars,1);
    Ddi_Bdd_t *myCheck = Ddi_BddAnd(check,careAig);
    int ret = Ddi_AigQbfAndSolve(myCheck,notOldCheck,forallVars);
    Ddi_Free(myCheck);
    Ddi_Free(forallVars);
    Ddi_Free(blockingArray);
    return (!ret);
  }


  auxV = Ddi_BddSupp(careAig);
  if (Ddi_VarsetIsArray(psVars)) {
    Ddi_VarsetSetArray(auxV);
  }
  Ddi_VarsetDiffAcc(auxV,psVars);
  Pdtutil_Assert(Ddi_VarsetIsVoid(auxV),"PI vars in care");
  Ddi_Free(auxV);

  auxV = Ddi_BddSupp(check);
  Ddi_VarsetSetArray(auxV);
  Ddi_VarsetDiffAcc(auxV,psVars);
  Ddi_VarsetSetArray(piVars);
  Ddi_VarsetUnionAcc(piVars,auxV);
  Ddi_Free(auxV);

  nPi = Ddi_VarsetNum(piVars);

  aig2CnfIdInit(ddm);
  ddm->settings.aig.aigCnfLevel = 0;
  //  if (aigCnfLevel>4)  ddm->settings.aig.aigCnfLevel = 4;

  stateCex.clear();
  blocking.clear();
  assumps.clear();

  if (zeroOld) {
    MinisatClauses(S,check,careAig,NULL,0);
    MinisatClauses(S,notOldCheck,NULL,NULL,0);
  }
  else {
    MinisatClauses2Solvers(S,S2,oldCheck,careAig,NULL,1);
    MinisatClauses2Solvers(S,S2,check,careAig,NULL,1);
    MinisatClauses(S,notOldCheck,NULL,NULL,0);
    MinisatClauses(S2,oldCheck,NULL,NULL,0);
    MinisatClauses(S,check,NULL,NULL,0);
  }

  while (S.nVars() > S2.nVars()) S2.newVar();
  while (S.nVars() < S2.nVars()) S.newVar();

  checkStateVars = Pdtutil_Alloc(int, nState);
  piSatVars = Pdtutil_Alloc(int, nPi);

  for (i=j=l=0; i<S.nVars(); i++) {
    int vCnf = i+1;
    bAigEdge_t baig = ddm-> cnf.cnf2aig[vCnf];
    if (!bAig_NodeIsConstant(baig)&&bAig_isVarNode(bmgr,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      if (Ddi_VarInVarset(psVars,v)) {
        checkStateVars[j++] = i;
	//	printf("%s\n",Ddi_VarName(v));
      }
      else if (Ddi_VarInVarset(piVars,v)) {
        piSatVars[l++] = i;
	//	printf("PI: %s\n",Ddi_VarName(v));
      }
    }
  }
  Pdtutil_Assert(j<=nState,"N state vars does not match");
  Pdtutil_Assert(l==nPi,"N pi vars does not match");

  if (j<nState) nState=j;

  for (step=0; (ret==-1); step++) {

    int sat;
    /* simple check */

    if (verbosity >= Pdtutil_VerbLevelDevMax_c) {
      fprintf(dMgrO(ddm),"simple check: %d\n", Ddi_BddSize(check));
    }

    if (1&&(maxIter>0)&&(step >= maxIter)) {
      ret = -1;
      break;
    }

    sat = S.okay();
    if (sat) {
      sat = S.solve(assumps,timeLimit);
    }

    if (S.undefined()) {
      ret = -1;
      break;
    }

    if (sat && (zeroOld || fullR)) {
      /* new state ! No fix point */
      ret = 0;
      break;
    }
    else if (sat)
    {
      stateCex.clear();
      blocking.clear();

      cexAig = Ddi_BddMakeConstAig(ddm,1);

      for (i=0; i<nState; i++) {
	int k = checkStateVars[i];
        if (S.model[k] != l_Undef) {
          int vCnf = k+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          int w = aig2CnfId(bmgr,baig);
          Lit l = MinisatLit(w);

          Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, 1);

          if (S.model[k]!=l_True) {
	    w = -w;
   	      Ddi_BddNotAcc(lit);
	    //	    	    printf("0");
          }
	  else {
	    //	    	    printf("1");
	  }
          stateCex.push(MinisatLit(w));
          blocking.push(MinisatLit(-w));

	  Ddi_BddAndAcc(cexAig,lit);
	  Ddi_Free(lit);
        }
      }
      //            printf("\n");

      sat = S2.okay();
      if (sat) {
        sat = S2.solve(stateCex);
      }

      if (!sat) {
	/* not found: new state => NO FIX-POINT */
        ret = 0;

	newState = cexAig;
        // sat = S2.solve();
        break;
      }
      else {
	Ddi_Free(cexAig);
      }

      if (sat) {
	//      else {
	/* not new: gen blocking set */
	Ddi_Bdd_t *blockingSet = Ddi_BddDup(oldCheck);

        if (nPi > 0) {

          Ddi_Bdd_t *cexPi = Ddi_BddMakeConstAig(ddm,1);

  	  /* extract PI cex */
          for (i=0; i<nPi; i++) {
	    int k = piSatVars[i];
            if (S2.model[k] != l_Undef) {
              int vCnf = k+1;
              bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
              Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
              Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
              if (S2.model[k]!=l_True) {
	        Ddi_BddNotAcc(lit);
              }
  	      Ddi_BddAndAcc(cexPi,lit);
  	      Ddi_Free(lit);
            }
          }
	  /* cofactor old set */
          Ddi_AigConstrainCubeAcc(blockingSet,cexPi);
	  Pdtutil_Assert(!Ddi_BddIsZero(blockingSet),"SAT - AIG don't match");
	  if (0)
  	  {
            Ddi_Bdd_t *bBdd = Ddi_BddMakeMono(blockingSet);
	    Pdtutil_Assert(Ddi_BddIncluded(bBdd,oldBdd),"overappr block set");
	    Ddi_BddDiffAcc(newBdd,bBdd);
	    Ddi_Free(bBdd);
  	  }
	  Ddi_Free(cexPi);
	}
	else {
	  Pdtutil_Assert(0, "NO PI in cex");
	}

 	Ddi_BddNotAcc(blockingSet);
	if (0)
	{
	  Ddi_Varset_t *supp = Ddi_BddSupp(blockingSet);
	  Ddi_VarsetDiffAcc(supp,psVars);
	  Pdtutil_Assert(Ddi_VarsetIsVoid(supp),"NON ps vars in bl. set");
	  Ddi_Free(supp);
	}
	//         MinisatClauses(S,blockingSet,NULL,NULL,0);
        MinisatClauses2Solvers(S,S2,blockingSet,NULL,NULL,0);
	while (S.nVars() > S2.nVars()) S2.newVar();
	while (S.nVars() < S2.nVars()) S.newVar();

	Ddi_BddarrayInsertLast(blockingArray,blockingSet);
	if (care!=NULL && Ddi_BddSize(blockingSet)>0) {
	  if (Ddi_BddSize(care)<20000 && Ddi_BddSize(blockingSet)< 20000) {
	    Ddi_BddAndAcc(care,blockingSet);
	    optCare=1;
	  }
	}
	Ddi_Free(blockingSet);
        // S.addClause(blocking);
	// ??? S2.addClause(blocking);
      }
    }
    else {
      /* unsat: FIX POINT */
      ret = 1;

      // Pdtutil_Assert(Ddi_BddIsZero(newBdd),"not ZERO BDD");
      break;
    }

  }

  aig2CnfIdClose(ddm);
  ddm->settings.aig.aigCnfLevel = aigCnfLevel;


  if (0 && !ret && newState!=NULL) {
    Ddi_Bdd_t *a = Ddi_BddAnd(care,newState);
    Ddi_Bdd_t *b = Ddi_BddAnd(oldCheck,newState);
    Ddi_Bdd_t *c = Ddi_BddAnd(check,newState);

    Pdtutil_Assert(Ddi_AigSat(a),"new state out of care");
    Pdtutil_Assert(Ddi_AigSat(c),"new state out of check");
    Pdtutil_Assert(!Ddi_AigSat(b),"new state in old check");

    Ddi_Free(a);
    Ddi_Free(b);
    Ddi_Free(c);
  }

  Ddi_Free(newState);

  Ddi_Free(careAig);
  Ddi_Free(piVars);
  Ddi_Free(notOldCheck);
  Ddi_Free(blockingArray);

  Ddi_Free(oldBdd);
  Ddi_Free(newBdd);

  if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),"\nfp: %d (%d steps)\n", ret, step+1);
  }

  if (!ret && optCare) {
    int rrl = Ddi_MgrReadAigRedRemLevel(ddm);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl+1);
    DdiAigRedRemovalAcc (care,NULL,-1,10.0);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl);
    fprintf(dMgrO(ddm),"CFP - refine CARE %d->%d\n",careSize,
	   Ddi_BddSize(care));
  }

  return (ret);

}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
Ddi_Varset_t *
Ddi_AigRefineRelationalPartWithCex (
  Ddi_Bdd_t *checkPart,
  Ddi_Bdd_t *cex,
  Ddi_Varset_t *psIn,
  char *prefix,
  int cegar
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cex);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  Ddi_Varset_t *refinedPs = Ddi_VarsetVoid(ddm);
  Ddi_Bdd_t *cexPart = NULL;
  Ddi_Bddarray_t *cexArray = NULL;
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm,0);

  int randChoice = 0;
  int i, j, n;
  int np = Ddi_BddPartNum(checkPart);

  Ddi_Vararray_t *vA;
  Ddi_Bddarray_t *vSubst;
  Ddi_Varset_t *s_0=NULL, *sCommon=NULL;
  Ddi_Vararray_t *sCommonA=NULL;
  Ddi_Bdd_t *res=NULL;
  int *varauxids = Ddi_MgrReadVarauxids(ddm);

  double time_limit=1.0;

  if (cegar<0) {
    cegar *= -1;
    randChoice = 1;
  }

  /* keep free (PI) vars and remove non free vars from cex
     under the assumption that common vars are shared by two
     adjacent partitions
  */
  sCommon=Ddi_VarsetVoid(ddm);
  Ddi_VarsetSetArray(sCommon);

  for (i=0; i<np-1; i++) {
    Ddi_Varset_t *s_i = Ddi_BddSupp(Ddi_BddPartRead(checkPart,i));
    Ddi_VarsetSetArray(s_i);
    if (i>0) {
      Ddi_VarsetIntersectAcc(s_0,s_i);
      Ddi_VarsetUnionAcc(sCommon,s_0);
    }
    Ddi_Free(s_0);
    s_0 = s_i;
  }
  Ddi_Free(s_0);
  sCommonA = Ddi_VararrayMakeFromVarset(sCommon,1);

  Pdtutil_Assert(varauxids!=NULL, "null varauxids array in dd manager");

  for (i=0; i<Ddi_VararrayNum(sCommonA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(sCommonA,i);
    int index = Ddi_VarIndex(v);

    Pdtutil_Assert(varauxids[index]>=-1, "wrong varauxid");

    varauxids[index]+=4;
    varauxids[index] = -varauxids[index];
  }

  cexPart = Ddi_AigPartitionTop(cex,0);
  cexArray = Ddi_BddarrayAlloc(ddm,0);
  for (i=0; i<Ddi_BddPartNum(cexPart); i++) {
    Ddi_Bdd_t *p_i = Ddi_BddPartRead(cexPart,i);
    Ddi_Var_t *v_i = Ddi_BddTopVar(p_i);
    int index = Ddi_VarIndex(v_i);
    if (varauxids[index]>=-1) {
      Ddi_BddarrayInsertLast(cexArray,p_i);
    }
  }
  Ddi_Free(cexPart);
  for (i=0; i<Ddi_VararrayNum(sCommonA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(sCommonA,i);
    int index = Ddi_VarIndex(v);

    Pdtutil_Assert(varauxids[index]<0, "wrong varauxid");

    varauxids[index] = -varauxids[index];
    varauxids[index] -= 4;
  }

  n = Ddi_BddarrayNum(cexArray);
  vA = Ddi_VararrayAlloc (ddm,n);
  vSubst = Ddi_BddarrayAlloc (ddm,n);

  Ddi_Free(sCommonA);

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *p = Ddi_BddarrayRead(cexArray,i);
    Ddi_Var_t *v = Ddi_BddTopVar(p);

    Ddi_VararrayWrite(vA,i,v);
    if (Ddi_BddIsComplement(p)) {
      Ddi_BddarrayWrite(vSubst,i,myZero);
    }
    else {
      Ddi_BddarrayWrite(vSubst,i,myOne);
    }
  }

  for (j=0; j<1; j++) {
    int dummyCnf;
    Solver    S;
    vec<Lit> lits, assumps;
    Lit dummyAssump;

    res = Ddi_BddDup(checkPart);

    Ddi_BddNotAcc(Ddi_BddPartRead(res,0));

    if (!randChoice) {
      aig2CnfIdInit(ddm);
      assumps.clear();

      MinisatClauses(S,res,NULL,NULL,0);
      S.newVar();
      dummyCnf = S.nVars();
      dummyAssump = MinisatLit(dummyCnf);

      for (i=0; i<n; i++) {
	Ddi_Bdd_t *p = Ddi_BddarrayRead(cexArray,i);
	bAigEdge_t pBaig;
	int pCnf;
	Lit l;

	pBaig = Ddi_BddToBaig(p);
	pCnf = bAig_NodeIsInverted(pBaig) ? -aig2CnfId(bmgr,pBaig) :
	  aig2CnfId(bmgr,pBaig);
	l = MinisatLit(pCnf);
	if (1 || (i%2 == j)) {
	  assumps.push(l);
	}
	else {
	  MinisatClause1(S,lits,pCnf);
	}
      }
    }

    //    for (i=j; i<n; i+=2) {
    for (i=0; i<n; i++) {
      Ddi_Bdd_t *p = Ddi_BddarrayRead(cexArray,i);
      Ddi_Var_t *v = Ddi_BddTopVar(p);
      char *vname = Ddi_VarName(v);
      Ddi_Var_t *refV;
      int checkVar=0;
      refV = Ddi_VarFindRefVar(v,prefix,'_');

      checkVar = refV!=NULL && !Ddi_VarInVarset(psIn,refV)
	&& !Ddi_VarInVarset(psIn,v);
      checkVar = checkVar && ((cegar==1) ? !Ddi_VarInVarset(refinedPs,refV) :
			      !Ddi_VarInVarset(refinedPs,v));
      if (checkVar) {
	Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
	//	Lit savedAssump = assumps[i/2];
	int sat;

	Ddi_BddarrayWrite(vSubst,i,lit);


	if (!randChoice) {
	  /* remove i-th assumption (replacing with dummy clause) */
	  //	assumps[i/2] = dummyAssump;
	  Lit savedAssump = assumps[i];
	  assumps[i] = dummyAssump;

	  if ((sat = S.okay())) {
	    sat = S.solve(assumps,time_limit);
	  }
	  if (S.undefined()) {
	    sat = 1;
	  }

	  //	assumps[i/2] = savedAssump;
	  assumps[i] = savedAssump;
	}
	else {
	  sat = rand()%2;
	}

	Ddi_Free(lit);

	if (sat) {
	  Ddi_VarsetAddAcc(refinedPs,refV);
	  if (cegar > 1) {
	    Ddi_VarsetAddAcc(refinedPs,v);
	  }
	  if (Ddi_BddIsComplement(p)) {
	    Ddi_BddarrayWrite(vSubst,i,myZero);
	  }
	  else {
	    Ddi_BddarrayWrite(vSubst,i,myOne);
	  }

	  if (randChoice) {
	    break;
	  }
	}

      }
    }

    if (!randChoice) {
      aig2CnfIdClose(ddm);
    }
    Ddi_Free(res);
  }

  Ddi_Free(sCommon);

  Ddi_Free(myOne);
  Ddi_Free(myZero);

  Ddi_Free(vA);
  Ddi_Free(vSubst);
  Ddi_Free(cexArray);

  return refinedPs;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigImgSimplify (
  Ddi_Bdd_t *img,
  Ddi_Bdd_t *care,
  Ddi_Bdd_t *cone,
  int inductiveLevel
)
{
  int chkRes = 0;
  Ddi_Bdd_t *img2 = Ddi_AigInductiveImgPlus(NULL,img,NULL,NULL,inductiveLevel);
  if (img2==NULL) return Ddi_BddDup(img);
  if (chkRes) {
    Pdtutil_Assert(!Ddi_AigSatAnd(img2,cone,care),"wrong simplify");
  }
  return img2;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatSubset (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  int inductiveLevel
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int chkRes = 0;
  Ddi_Bdd_t *aux, *fPart = Ddi_AigPartitionTop(f,1);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);

  if (Ddi_BddPartNum(fPart)==1) {
    Ddi_Free(fPart);
    return NULL;
  }
  Ddi_BddNotAcc(fPart);
  aux = Ddi_AigInductiveImgPlus(care,fPart,NULL,NULL,inductiveLevel);
  Ddi_BddNotAcc(fPart);
  Ddi_BddSetAig(fPart);
  if (aux!=NULL) {
    Ddi_Free(aux);
    if (chkRes) {
      Pdtutil_Assert(Ddi_AigSatAnd(fPart,care,NULL),"wrong sat subset");
    }
    if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
      fprintf(dMgrO(ddm),
	      "SAT subsetting: %d -> %d\n", Ddi_BddSize(f),
	      Ddi_BddSize(fPart));
    }
  }
  else {
    Ddi_Free(fPart);
  }
  return fPart;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigInductiveImgPlus (
  Ddi_Bdd_t *from,
  Ddi_Bdd_t *inductiveTo,
  Ddi_Bdd_t *care,
  Ddi_Bdd_t *toPlusCare,
  int inductiveLevel
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(inductiveTo);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *partTo = Ddi_BddIsPartConj(inductiveTo)?
    Ddi_BddDup(inductiveTo):Ddi_AigPartitionTop(inductiveTo,0);
  Ddi_Bdd_t *toPlus=NULL;
  Solver    S;
  vec<Lit> lits, assumps;
  int np0;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int refineTerms=1, improveParts=0;
  //  int timeLimit=ddm->settings.aig.satTimeLimit/5;
  int timeLimit=ddm->settings.aig.satTimeLimit;
  int undefined = 0;
  static int chkRes = 0;
  int tryRedRem = inductiveLevel<=2 && from!=NULL;

  if (improveParts) {
    int i;
    for (i=Ddi_BddPartNum(partTo)-1; i>=0; i--) {
      Ddi_Bdd_t *t_i = Ddi_BddPartRead(partTo,i);
      if (Ddi_BddSize(t_i)>3) {
	Ddi_Bdd_t *part_t_i = Ddi_AigPartitionTop(t_i,1);
	if (Ddi_BddPartNum(part_t_i)==2) {
	  int k, in=0;
	  Ddi_Bdd_t *big = Ddi_BddPartRead(part_t_i,0);
	  Ddi_Bdd_t *small = Ddi_BddPartRead(part_t_i,0);
	  if (Ddi_BddSize(big)<Ddi_BddSize(small)) {
	    Ddi_Bdd_t *tmp = big; big = small; small = tmp;
	  }
	  Ddi_Bdd_t *part_t_i_0 = Ddi_AigPartitionTop(big,0);
	  for (k=0; k<Ddi_BddPartNum(part_t_i_0); k++) {
	    Ddi_Bdd_t *tt_i = Ddi_BddOr(Ddi_BddPartRead(part_t_i_0,k),small);
	    if (k==0) {
	      Ddi_DataCopy(t_i,tt_i);
	    }
	    else {
	      Ddi_BddPartInsertLast(partTo,tt_i);
	    }
	    Ddi_Free(tt_i);
	  }
	  Ddi_Free(part_t_i);
	}
      }
    }
  }

  np0=Ddi_BddPartNum(partTo);

  if (np0>0 && tryRedRem) {
    Ddi_Bddarray_t *arrayTo = Ddi_BddarrayMakeFromBddPart(partTo);
    Ddi_Bdd_t *constr = Ddi_BddDup(from);
    if (care!=NULL && !Ddi_BddIsOne(care)) {
      Ddi_BddSetPartConj(constr);
      Ddi_BddPartInsertLast(constr,care);
    }
    if (toPlusCare!=NULL && !Ddi_BddIsOne(toPlusCare)) {
      Ddi_BddSetPartConj(constr);
      Ddi_BddPartInsertLast(constr,toPlusCare);
    }
    toPlus = Ddi_AigConstRed (arrayTo, constr, NULL, NULL,
                              0 /* doRedRem */, -1, 
			      0, 0, NULL, (float)timeLimit);
    if (toPlus!=NULL) {
      Ddi_BddSetAig(toPlus);
      Ddi_Free(partTo);
      partTo = Ddi_BddMakeConstAig(ddm,1);
    }
    Ddi_Free(constr);
    Ddi_Free(arrayTo);
  }
  else if (np0>1) {
    Ddi_Bdd_t *auxTo = Ddi_BddNot(partTo);
    int doRefineTo = 0;
    int i, *active, *trueActive, na, jjt=0;
    Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm,1);
    bAigEdge_t fBaig;
    int fCnf;
    int phase = 0;

    vec<Lit> targetClause;

    na = Ddi_BddPartNum(partTo);
    active = Pdtutil_Alloc(int,na);
    trueActive = Pdtutil_Alloc(int,na);

    aig2CnfIdInit(ddm);

    assumps.clear();

    if (from!=NULL) {
      MinisatClauses(S,from,NULL,NULL,1);
      fBaig = Ddi_BddToBaig(from);
      fCnf = bAig_NodeIsInverted(fBaig) ? -aig2CnfId(bmgr,fBaig) :
	aig2CnfId(bmgr,fBaig);
      assumps.push(MinisatLit(fCnf));
    }

    if (care!=NULL) {
      MinisatClauses(S,care,NULL,NULL,0);
    }
    if (toPlusCare!=NULL) {
      MinisatClauses(S,toPlusCare,NULL,NULL,0);
    }
    Pdtutil_Assert(Ddi_BddIsPartDisj(auxTo),"disj. part required");
    targetClause.clear();

    MinisatClauses(S,partTo,NULL,NULL,1);
    for (i=0; i<Ddi_BddPartNum(auxTo); i++) {
      Ddi_Bdd_t *t_i = Ddi_BddPartRead(auxTo,i);
      bAigEdge_t tBaig;
      int tCnf;

      active[i] = i;

      tBaig = Ddi_BddToBaig(t_i);
      tCnf = bAig_NodeIsInverted(tBaig) ? -aig2CnfId(bmgr,tBaig) :
	aig2CnfId(bmgr,tBaig);

      targetClause.push(MinisatLit(tCnf));
    }
    S.addClause(targetClause);

    if (from==0) {
      /* just refinement! */
      doRefineTo = 1;
      phase = 1;
    }

    do {
      int sat;
      if ((sat = S.okay())) {
        if (phase==0 && inductiveLevel > 1) {
          sat = S.solve(assumps,timeLimit);
        }
        else {
          sat = S.solve(NULL,timeLimit);
        }
      }
      doRefineTo = 0;
      if (S.undefined()) {
        sat = -1;
        undefined = 1;
      }
      else if (sat) {
	int ii, jj;
	vec<Lit> newTargetClause;
        newTargetClause.clear();
	for (ii=jj=0; ii<na; ii++) {
	  int k = var (targetClause[active[ii]]);
	  int sign_ii = sign (targetClause[active[ii]]);
          Pdtutil_Assert (S.model[k] != l_Undef, "undef literal in cex");
          if (S.model[k]!=(sign_ii?l_False:l_True)) {
            /* not satisfied in cex, keep in target */
            newTargetClause.push(targetClause[active[ii]]);
            active[jj++] = active[ii];
          }
          else if (phase==1 && inductiveLevel > 1) {
            vec<Lit> newTargetCareLit;
            newTargetCareLit.clear();
            /* satisfied in cex&toPlusCare, store in trueActive */
            trueActive[jjt++] = active[ii];
            /* set literal - restrict toPlusCare */
            newTargetCareLit.push(~targetClause[active[ii]]);
            S.addClause(newTargetCareLit);
          }
	}
	na = jj;
	doRefineTo = 1;
	S.addClause(newTargetClause);
      }
      else if (phase==0) {
	doRefineTo = 1;
        phase = 1;
      }
    } while (doRefineTo);

    Ddi_Free(auxTo);
    toPlus = Ddi_BddMakeConstAig(ddm,1);
    Ddi_BddSetPartConj(toPlus);
    aig2CnfIdClose(ddm);

    if (!undefined) {
      if (inductiveLevel > 1) {
        for (i=0; i<jjt; i++) {
          int ii = trueActive[i];
          Ddi_Bdd_t *t_i = Ddi_BddPartRead(partTo,ii);
          Ddi_BddPartInsertLast(toPlus,t_i);
          Ddi_BddPartWrite(partTo,ii,myOne);
        }
      }
      else {
        jjt = na;
      }
      /* disable redundant parts */
      for (i=0; i<na; i++) {
        int ii = active[i];
        Ddi_Bdd_t *t_i = Ddi_BddPartRead(partTo,ii);
        if (inductiveLevel == 1) {
          Ddi_BddPartInsertLast(toPlus,t_i);
        }
        Ddi_BddPartWrite(partTo,ii,myOne);
      }
      Ddi_BddSetAig(toPlus);

      if (inductiveLevel == 1) {
        na=0;
      }
      if (jjt>0 && verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        fprintf(dMgrO(ddm),
        "%d/%d (r:%d) INDUCTIVE components found in TO+ (size: %d)\n",
                jjt, np0, na,
                Ddi_BddSize(toPlus));
      }
    }
    else {
      if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        fprintf(dMgrO(ddm),
                "INDUCTIVE TO+ undefined\n");
      }
      //      Ddi_BddSetAig(toPlus);
      Ddi_Free(toPlus);
    }

    if (0&&refineTerms) {
      Ddi_Bdd_t *outPart=Ddi_BddDup(partTo);
      for (i=Ddi_BddPartNum(outPart)-1; i>=0; i--) {
	Ddi_Bdd_t *t_i = Ddi_BddPartRead(outPart,i);
	if (Ddi_BddIsOne(t_i)) {
	  Ddi_BddPartRemove(outPart,i);
	}
	else if (Ddi_BddSize(t_i)>1) {
	  Ddi_BddNotAcc(t_i);
	  Ddi_Bdd_t *part_t_i = Ddi_AigPartitionTop(t_i,0);
	  if (Ddi_BddPartNum(part_t_i)==2 &&Ddi_BddSize(t_i)>10) {
	    int k, in=0;
	    Ddi_Bdd_t *big = Ddi_BddPartRead(part_t_i,0);
	    Ddi_Bdd_t *small = Ddi_BddPartRead(part_t_i,0);
	    if (Ddi_BddSize(big)<Ddi_BddSize(small)) {
	      Ddi_Bdd_t *tmp = big; big = small; small = tmp;
	    }
	    Ddi_Bdd_t *part_t_i_0 = Ddi_AigPartitionTop(big,1);
	    for (k=0; k<Ddi_BddPartNum(part_t_i_0); k++) {
	      Ddi_Bdd_t *tt_i = Ddi_BddAnd(Ddi_BddPartRead(part_t_i_0,k),small);
	      Ddi_BddNotAcc(tt_i);
	      if (Ddi_BddIncluded(from,tt_i)) {
		in++;
	      }
	      Ddi_Free(tt_i);
	    }
	    printf("refined included: %d/%d\n", in, Ddi_BddPartNum(part_t_i_0));
	    Ddi_Free(part_t_i_0);
	  }
	  Ddi_Free(part_t_i);
	}
      }
      Ddi_Free(outPart);
    }

    if (!undefined && inductiveLevel > 4) {
      int done=0;
      Ddi_Bdd_t *refineTerm = Ddi_BddMakeConstAig(ddm,1);
      Ddi_Varsetarray_t *supps = Ddi_VarsetarrayAlloc(ddm,0);
      for (i=0; i<Ddi_BddPartNum(partTo); i++) {
	Ddi_Bdd_t *t_i = Ddi_BddPartRead(partTo,i);
        Ddi_Varset_t *suppTot = Ddi_BddSupp(t_i);
        Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(suppTot,1);
	int added=0, num = Ddi_VararrayNum(vA);
	if (num>2 && num < 12) {
          int j, skip=0;
          for (j=Ddi_VarsetarrayNum(supps)-1; !skip && j>=0; j--) {
            Ddi_Varset_t *s_j = Ddi_VarsetarrayRead(supps,j);
            Ddi_Varset_t *d_j = Ddi_VarsetDiff(suppTot,s_j);
            skip = Ddi_VarsetNum(d_j)<=2;
            Ddi_Free(d_j);
          }
          if (!skip) {
            Ddi_Bdd_t *over = Ddi_BddDup(from);
            Ddi_VarsetarrayInsertLast(supps,suppTot);
            Ddi_AigProjectAllSolutionImgAcc (over,suppTot,toPlus,-1,0);
            if (!Ddi_BddIsOne(over)) {
              Ddi_Varset_t *s = Ddi_BddSupp(over);
              if (Ddi_VarsetNum(s) <= num) {
                Ddi_VarsetarrayInsertLast(supps,s);
              }
              Ddi_Free(s);
              Ddi_BddAndAcc(refineTerm,over);
              done=1;
            }
            Ddi_Free(over);
          }
        }
        Ddi_Free(suppTot);
        Ddi_Free(vA);
      }
      if (done) {
        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          fprintf(dMgrO(ddm),
                "INDUCTIVE ternary IMG refine (size: %d)\n",
		Ddi_BddSize(refineTerm));
        }
        Ddi_BddAndAcc(toPlus,refineTerm);
      }
      Ddi_Free(supps);
      Ddi_Free(refineTerm);
    }

    if (0 && (inductiveLevel > 2)) {
      Ddi_Bdd_t *totAig = Ddi_BddMakeAig(partTo);
      int initSize=Ddi_BddSize(totAig);
      Ddi_Bdd_t *refineTerm = Ddi_BddMakeConstAig(ddm,1);
      Ddi_BddSetPartConj(totAig);
      if (inductiveLevel == 3) {
	Ddi_DataCopy(partTo,totAig);
      }
      Ddi_Free(totAig);
      for (i=0; i<Ddi_BddPartNum(partTo); i++) {

	Ddi_Bdd_t *t_i = Ddi_BddPartRead(partTo,i);
	int added=0, size = Ddi_BddSize(t_i);
	if (!Ddi_BddIsOne(t_i) && size>3 && (inductiveLevel==3 || size<100)) {
	  Ddi_Bdd_t *over = Ddi_BddDup(t_i);
	  Ddi_Var_t *topV;
	  int ii, reduction=5, nTry=0;
	  int done=0, okOver=0, size1;
	  int myInitSize=Ddi_BddSize(over);
	  do {
	    Ddi_Varset_t *suppTot = Ddi_BddSupp(over);
	    Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(suppTot,1);
	    for (ii=done=0; !done && ii<Ddi_VararrayNum(vA); ii++) {
	      Ddi_Var_t *v = Ddi_VararrayRead(vA,ii);
	      if (Ddi_VarInVarset(suppTot,v)) {
		Ddi_Bdd_t *over2 = Ddi_BddDup(over);
		if (1 || (inductiveLevel == 3)) {
		  Ddi_Varset_t *supp = Ddi_VarsetMakeFromVar(v);
		  DdiAigExistOverAcc (over2,supp,NULL);
		  Ddi_Free(supp);
		}
		if ((Ddi_BddSize(over2)*reduction > myInitSize)
		    && (Ddi_BddSize(over2) < myInitSize)) {
		  Ddi_BddNotAcc(over2);
		  done = !Ddi_AigSatAnd(over2,from,care);
		  Ddi_BddNotAcc(over2);
		  Ddi_DataCopy(over,over2);
		  Ddi_Free(suppTot);
		  suppTot = Ddi_BddSupp(over);
		}
		Ddi_Free(over2);
	      }
	    }
	    Ddi_Free(suppTot);
	    Ddi_Free(vA);
	    if (done && !Ddi_BddIsOne(over)) {
	      Ddi_BddAndAcc(refineTerm,over);
	      okOver = 1;
	    }
	    reduction *= 2;
	  } while (!okOver && nTry++<4);
	  Ddi_Free(over);
	}
      }
      if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
	fprintf(dMgrO(ddm),"INDUCTIVE ternary over (size: %d->%d)\n", initSize,
		Ddi_BddSize(refineTerm));
      }
      Ddi_BddAndAcc(toPlus,refineTerm);
      Ddi_Free(refineTerm);
    }
    Ddi_Free(myOne);
    Pdtutil_Free(active);
    Pdtutil_Free(trueActive);
  }

  Ddi_BddSetAig(partTo);
  Ddi_DataCopy(inductiveTo,partTo);
  Ddi_Free(partTo);

  if (chkRes && toPlus!=NULL && from!=NULL) {
    Ddi_Bdd_t *myFrom = Ddi_BddDup(from);
    if (care!=NULL) {
      Ddi_BddAndAcc(myFrom,care);
    }
    Pdtutil_Assert(Ddi_BddIncluded(myFrom,toPlus),"wrong inductive to");
    Ddi_Free(myFrom);
  }

  Ddi_BddSetAig(inductiveTo);

  if (toPlus != NULL && inductiveLevel > 3) {
    Ddi_AigGeneralizeItpAcc (from, toPlus, care, 0);
  }

  //  Ddi_AigStructRedRemAcc (toPlus,NULL);

  return toPlus;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigGeneralizeItpAcc (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *fPlus,
  Ddi_Bdd_t *care,
  int level
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *partFP = level>0 ? NULL : Ddi_AigPartitionTop(fPlus,0);
  Ddi_Bdd_t *fGen=NULL;
  int np0;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int timeLimit=ddm->settings.aig.satTimeLimit;
  int i, sat, np=1, nv;
  int undefined = 0;
  int chkRes = 1;
  int size0 = Ddi_BddSize(fPlus), size1;
  Ddi_Varset_t *vars;
  Ddi_Bdd_t *myCare;

  if (size0 < 4) {
    Ddi_Free(partFP);
    return fPlus;
  }

  vars = Ddi_BddSupp(fPlus);
  nv = Ddi_VarsetNum(vars);
  myCare = (care!=NULL) ? Ddi_BddDup(care) : Ddi_BddMakeConstAig(ddm,1);

  if (partFP == NULL || Ddi_BddPartNum(partFP)==1) {
    Ddi_Bdd_t *notFPlus = Ddi_BddNot(fPlus);
    fGen = Ddi_AigSatAndWithInterpolant(f,notFPlus,vars,NULL,myCare,NULL,
				      NULL,NULL,&sat,0,0,-1.0);
    Pdtutil_Assert(!sat,"wrong itp generalization");
    Ddi_Free(notFPlus);
  }
  else {
    int j, size = Ddi_BddSize(partFP);
    static float ratio[] = {0.05, 0.2, 0.5, 0.9, 1.0};
    Ddi_MgrSetOption(ddm,Pdt_DdiVerbosity_c,inum,Pdtutil_VerbLevelUsrMin_c);
    np = Ddi_BddPartNum(partFP);
    for (j=1; j<4; j++) {
      Ddi_Bdd_t *cl = Ddi_BddMakeClustered(partFP, size * ratio[j]);
      if (np > 20 && j<3) {
        Ddi_Free(cl);
      }
      else {
        Ddi_DataCopy(partFP,cl);
        Ddi_Free(cl);
        np = Ddi_BddPartNum(partFP);
        break;
      }
    }
    for (i=0; i<np; i++) {
      Ddi_Bdd_t *fp_i = Ddi_BddPartRead(partFP,i);
      Ddi_AigGeneralizeItpAcc (f,fp_i,myCare,level+1);
      //      Ddi_BddAndAcc(myCare,fp_i);
    }
    Ddi_MgrSetOption(ddm,Pdt_DdiVerbosity_c,inum,verbosity);
    fGen = Ddi_BddMakeAig(partFP);
  }

  Ddi_Free(partFP);

  if (chkRes) {
    Ddi_Bdd_t *b = Ddi_BddNot(fGen);
    Pdtutil_Assert(!Ddi_AigSatAnd(f,b,care),"wrong itp generalization");
    Ddi_Free(b);
    b = Ddi_BddNot(fPlus);
    Pdtutil_Assert(!Ddi_AigSatAnd(fGen,b,care),"wrong itp generalization");
    Ddi_Free(b);
  }

  Ddi_Free(vars);
  vars = Ddi_BddSupp(fGen);

  size1 = Ddi_BddSize(fGen);
  if (level==0 && verbosity >= Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),
            "ITP-based GEN. - vars: %d->%d - size: %d->%d (%d parts)\n",
            nv, Ddi_VarsetNum(vars), size0, size1, np);
  }

  if (size1 < 5*size0) {
    Ddi_DataCopy(fPlus,fGen);
  }

  Ddi_Free(myCare);
  Ddi_Free(fGen);
  Ddi_Free(vars);

  return fPlus;
}

#if 1
/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigRefineImgPlus (
  Ddi_Bdd_t *from,
  Ddi_Bdd_t *cone,
  Ddi_Bdd_t *pConj,
  Ddi_Bdd_t *toPlus,
  Ddi_Bdd_t *care,
  int refineLevel
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Solver    S, S2;
  vec<Lit> lits, assumps;
  int np0, maxRefine;
  int chkRes=1;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  Ddi_Vararray_t *gblVars;
  int growthFactor=1.0;
  Ddi_Bdd_t *toPlusRefined = Ddi_BddMakePartConjVoid(ddm);
  static int nsteps=0;
  long cpuTime=0, startTime=0;
  int timeLimit=ddm->settings.aig.satTimeLimit;

  startTime = util_cpu_time ();

  Pdtutil_Assert(Ddi_BddIsPartConj(pConj),"part conj required");

  maxRefine = Ddi_BddPartNum(pConj)*growthFactor;

  if ((np0=Ddi_BddPartNum(pConj))>1) {
    Ddi_Bdd_t *auxTo = Ddi_BddNot(pConj);
    int doRefineTo = 0;
    int i, *active, *gblCnf, na, nv;
    Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Varset_t *suppCone = Ddi_BddSupp(cone);
    Ddi_Varset_t *suppFrom = Ddi_BddSupp(from);

    vec<Lit> targetClause;

    Ddi_VarsetIntersectAcc(suppCone,suppFrom);
    gblVars = Ddi_VararrayMakeFromVarset(suppCone,1);
    Ddi_Free(suppCone);
    Ddi_Free(suppFrom);

    nv = Ddi_VararrayNum(gblVars);
    na = Ddi_BddPartNum(pConj);
    gblCnf = Pdtutil_Alloc(int,nv);
    active = Pdtutil_Alloc(int,na);

    aig2CnfIdInit(ddm);
    MinisatClauses(S,toPlus,care,NULL,0);
    MinisatClauses(S2,from,care,NULL,0);
    MinisatClauses(S,cone,NULL,NULL,0);
    targetClause.clear();

    for (i=0; i<Ddi_BddPartNum(auxTo); i++) {
      Ddi_Bdd_t *t_i = Ddi_BddPartRead(auxTo,i);
      bAigEdge_t tBaig;
      int tCnf;

      MinisatClauses(S,t_i,NULL,NULL,1);
      MinisatClauses(S2,t_i,NULL,NULL,1);
      active[i] = i;

      tBaig = Ddi_BddToBaig(t_i);
      tCnf = bAig_NodeIsInverted(tBaig) ? -aig2CnfId(bmgr,tBaig) :
	aig2CnfId(bmgr,tBaig);

      targetClause.push(MinisatLit(tCnf));
    }
    S.addClause(targetClause);

    for (i=0; i<nv; i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(gblVars,i);
      bAigEdge_t vBaig = Ddi_VarToBaig(v);
      int vCnf = aig2CnfId(bmgr,vBaig);
      gblCnf[i] = vCnf;
    }

    do {
      int sat;
      vec<Lit> assume;
      if ((sat = S.okay())) {
        assume.clear();
	sat = S.solve(assume,timeLimit);
      }
      doRefineTo = 0;
      if (sat==1) {
	int ii, jj;
        assume.clear();
	for (ii=0; ii<na; ii++) {
	  int k = var (targetClause[ii]);
	  int sign_ii = sign (targetClause[active[ii]]);
          Pdtutil_Assert (S.model[k] != l_Undef, "undef literal in cex");
	  if (S.model[k]==(sign_ii?l_False:l_True)) {
	    /* satisfied in cex: generalize */
	    /* build assumption clause for S2 */
	    Ddi_Bdd_t *constrFinal = Ddi_BddMakeConstAig(ddm, 1);
	    Ddi_Bdd_t *newTerm = Ddi_BddDup(Ddi_BddPartRead(auxTo,ii));
	    for (jj=0; jj<nv; jj++) {
	      int vCnf = gblCnf[jj];
	      int ph = S.model[vCnf-1]==l_True;
	      Pdtutil_Assert(S.model[vCnf-1] != l_Undef, "wrong model");
	      assume.push(MinisatLit((ph?vCnf:-vCnf)));
	    }
	    /* activation literal */
	    assume.push(targetClause[ii]);
	    sat = S2.solve(assume);
	    if (sat) {
	      doRefineTo = 0; ii=na;
	      Ddi_Free(newTerm);
	      Ddi_Free(constrFinal);
	      break;
	    }
	    Pdtutil_Assert(!sat,"unsat required");
	    /* get core cube */
	    for (jj=0; jj<S2.conflict.size(); jj++) {
	      Ddi_Bdd_t *lit;
	      Lit kLit = S2.conflict[jj];
	      int vSat = var(kLit);
	      int signSat = sign(kLit);
	      int vCnf = vSat+1;
	      bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	      Pdtutil_Assert(v!=NULL,"NULL var in solver final");
	      lit = Ddi_BddMakeLiteralAig(v,signSat);
	      Ddi_BddAndAcc(constrFinal,lit);
	      Ddi_Free(lit);
	    }
#if 1
	    Ddi_AigAndCubeAcc(newTerm,constrFinal);
#else
	    Ddi_DataCopy(newTerm,constrFinal);
#endif
	    Ddi_BddNotAcc(newTerm);
	    MinisatClauses(S,newTerm,NULL,NULL,0);
	    Ddi_BddPartInsertLast(toPlusRefined,newTerm);
	    Ddi_Free(newTerm);
	    Ddi_Free(constrFinal);
	    nsteps++;
	    break;
	  }
	}
	doRefineTo = ii<na || sat<0;
	if (maxRefine-- <= 0) doRefineTo = 0;
	if (timeLimit>=0 &&
	    ((util_cpu_time () - startTime)/1000.0 > timeLimit)) {
	  doRefineTo = 0;
      }

      }
    } while (doRefineTo);

    Ddi_Free(auxTo);
    Ddi_Free(gblVars);

    aig2CnfIdClose(ddm);

    Ddi_Free(myOne);
    Pdtutil_Free(active);
    Pdtutil_Free(gblCnf);
  }

  if (Ddi_BddPartNum(toPlusRefined)>0) {
    int np = Ddi_BddPartNum(toPlusRefined);
    Ddi_BddSetAig(toPlusRefined);
    if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
      fprintf(dMgrO(ddm),"INDUCTIVE refinement found %d terms - size: %d\n",
	      np, Ddi_BddSize(toPlusRefined));
    }
  }
  else {
    Ddi_BddSetAig(toPlusRefined);
  }
  if (chkRes) {
    Ddi_Bdd_t *chk = Ddi_BddDiff(from,toPlusRefined);
    Pdtutil_Assert(!Ddi_AigSat(chk),"wrong result of inductive refinement");
    Ddi_Free(chk);
  }
  Ddi_BddAndAcc(toPlusRefined,toPlus);

  return toPlusRefined;
}
#endif

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigTightenOrLoosen (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *constr,
  Ddi_Bdd_t *care,
  int tighten
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);

  Ddi_Bdd_t *over = Ddi_BddDup(f);
  Ddi_Var_t *topV;
  int ii, nv;
  int done=0, okOver=0, initSize=Ddi_BddSize(over), size1;
  Ddi_Varset_t *supp = Ddi_BddSupp(over);
  Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_Free(supp);
  nv = Ddi_VararrayNum(vA);
  if (tighten>1 && nv>4) {
    Ddi_Free(over);
    over = Ddi_AigPartitionTop(f,0);
  }
  else {
    Ddi_BddSetPartConj(over);
  }
  for (ii=done=0; ii<nv; ii++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,ii);
    Ddi_Bdd_t *over2 = Ddi_BddDup(over);
    int k, OK=0;
    supp = Ddi_VarsetMakeFromVar(v);
    if (tighten) Ddi_BddNotAcc(over2);
    for (k=0; k<Ddi_BddPartNum(over2); k++) {
      Ddi_Bdd_t *p_k = Ddi_BddDup(Ddi_BddPartRead(over2,k));
      int OK_k=0;
      DdiAigExistOverAcc (p_k,supp,NULL);
      OK_k = !Ddi_AigSatAnd(p_k,constr,care);
      if (OK_k) {
	Ddi_BddPartWrite(over2,k,p_k);
	OK=1;
      }
      Ddi_Free(p_k);
    }
    Ddi_Free(supp);
    if (tighten) Ddi_BddNotAcc(over2);
    if (OK) {
      Ddi_DataCopy(over,over2);
      done++;
    }
    Ddi_Free(over2);
  }
  Ddi_Free(vA);
  if (done>0 && verbosity >= Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),"ternary %s (size: %d->%d)(vars: %d/%d)\n",
	   tighten?"TIGHTEN":"LOOSEN", initSize,
	   Ddi_BddSize(over), done, nv);
  }
  Ddi_BddSetAig(over);
  return over;
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistVarAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Var_t *v,
  Ddi_Var_t *refv,
  Ddi_Bdd_t *care,
  int nosat,
  Ddi_AigSignatureArray_t *varSigs,
  Ddi_AigSignature_t *careSig,
  int partial,
  float timeLimit
)
{
  int j, eq;
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig, *cof0Aig, *cof1Aig, *bestAig;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, fBaig, careBaig, cof0, cof1, newfBaig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  int nLevel0=0;
  //int extRef = Ddi_MgrReadExtRef(ddm);
  int nc0, nm0, enFull, initSize, bestSize;
  Ddi_AigSignatureArray_t *cof0Sig=NULL, *cof1Sig=NULL;
  int approxResult = 0;
  long cpuTime=0, startTime=0;

  /* the length of the two arrays must be the same */

  float lazyRate = Ddi_MgrReadAigLazyRate (ddm);

  startTime = util_cpu_time ();

  bmgr = ddm->aig.mgr;
#if 0
  nodeSetVisited(bmgr,varIndex);
#endif
  fBaig = Ddi_BddToBaig(fAig);
  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }
  //  cofVar = v;

  initSize = Ddi_BddSize(fAig);

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  varIndex = Ddi_VarToBaig(v);

  Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");

  if (refv != 0) {
    bAigEdge_t refVarIndex = Ddi_VarToBaig(refv);
    Pdtutil_Assert(refVarIndex != bAig_NULL,"NULL variable in ExistVar");
    bAig_AuxAig0(bmgr,varIndex) = refVarIndex;
    bAig_AuxAig1(bmgr,varIndex) = bAig_Not(refVarIndex);
    bAig_Ref(bmgr, refVarIndex);
    bAig_Ref(bmgr, refVarIndex);
  }
  else {
    bAig_AuxAig0(bmgr,varIndex) = bAig_Zero;
    bAig_AuxAig1(bmgr,varIndex) = bAig_One;
  }

#if 1
  existDiffEvalIntern(ddm,visitedNodes,careBaig,1/*cache enable*/);
#endif
  cof0 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                      bAig_AuxAig0(bmgr,fBaig);
  cof1 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
                                      bAig_AuxAig1(bmgr,fBaig);

  cof0Aig = Ddi_BddMakeFromBaig(ddm,cof0);
  cof1Aig = Ddi_BddMakeFromBaig(ddm,cof1);

  bestAig = NULL;

  if (nosat < 2 && cof0 != cof1 || cof0 == bAig_NULL) {

#if 0
    /* reset precomputed AIGs */
    for (j=0; j<visitedNodes->num; j++) {
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (bAig_NonInvertedEdge(baig) != bAig_NonInvertedEdge(varIndex)) {
        bAig_AuxAig0(bmgr,baig) = bAig_AuxAig1(bmgr,baig) = bAig_NULL;
      }
    }
#endif

#if 0
    nLevel0 = bAigArraySortByLevel(ddm,visitedNodes,varIndex,-1);
#endif

    nc0 = ddm->stats.aig.n_check_2;
    nm0 = ddm->stats.aig.n_merge_2;

    if (0&&ddm->settings.aig.bddCompare)
    {
      Ddi_Bdd_t *auxBdd = aig2BddIntern(ddm,fBaig);
#if 0
      aig2BddClearVisitedIntern(bmgr,fBaig);
#endif
      Ddi_Free(auxBdd);
    }

    if (refv==NULL) {
      cof0Sig = DdiAigEvalSignature(ddm,visitedNodes,varIndex,0,varSigs);
      cof1Sig = DdiAigEvalSignature(ddm,visitedNodes,varIndex,1,varSigs);
      for (j=0; j<visitedNodes->num; j++) {
        bAigEdge_t baig = visitedNodes->nodes[j];
        if (!DdiEqSignatures(&cof0Sig->sArray[j],&cof1Sig->sArray[j],careSig)) {
          nodeAuxChar(bmgr,baig) = 1;
          ddm->stats.aig.n_diff++;
        }
        else {
          nodeAuxChar(bmgr,baig) = 0;
        }
        ddm->stats.aig.n_diff_1++;
      }
    }

    newfBaig = bAig_Or(bmgr,cof0,cof1);
    bestAig = Ddi_BddMakeFromBaig(ddm,newfBaig);
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"[%d]", Ddi_BddSize(bestAig));
      fflush(dMgrO(ddm));
    }

    enFull = !partial;
    bestSize = Ddi_BddSize(bestAig);

    if (bestSize <= initSize) {
      enFull = 0;
    }
    else if (partial > 2) {
      enFull = enFull||(Ddi_BddSize(bestAig) < (1+1.0*(lazyRate-1))*initSize);
    }
    else if (partial > 1) {
      enFull = enFull||(Ddi_BddSize(bestAig) < (1+1.5*(lazyRate-1))*initSize);
    }
    else {
      enFull = enFull||(Ddi_BddSize(bestAig) < (1+4*(lazyRate-1))*initSize);
    }
    if (timeLimit >= 0)
      enFull &= ((util_cpu_time () - startTime)/1000.0 < timeLimit);

    if (0&&(visitedNodes->num-nLevel0) > 300) {
      int reverse = 0;
      int i,j,k,size = (visitedNodes->num-nLevel0)/10;
      bAig_array_t *aigNodes = bAigArrayAlloc();
      bAig_array_t *visitedNodes1 = bAigArrayAlloc();
      if (0&&size > 100) {
	size = 100;
      }
      fprintf(dMgrO(ddm)," [p:%d+10*%d] ",nLevel0,size); fflush(dMgrO(ddm));
      for (i=nLevel0; i<visitedNodes->num; i++) {
        bAigArrayWriteLast(visitedNodes1,visitedNodes->nodes[i]);
      }
      for (i=0; i<visitedNodes1->num; i += size) {
	j = reverse ? i-size : i;
	if (j<0) {
	  j=0;
	}
	k = reverse ? i : i+size;
	if (k>visitedNodes1->num) {
	  k=visitedNodes1->num;
	}
	for (;j<k;j++) {
          bAigArrayWriteLast(aigNodes,visitedNodes1->nodes[j]);
	}
        fprintf(dMgrO(ddm),"."); fflush(dMgrO(ddm));
        AigSatDiffTot(ddm,aigNodes,careBaig,0,0,0/*cacheEnable*/);
        AigSatDiffTot(ddm,aigNodes,careBaig,0,1,0/*cacheEnable*/);
        bAigArrayFree(aigNodes);
        aigNodes = bAigArrayAlloc();
      }
      bAigArrayFree(aigNodes);
      bAigArrayFree(visitedNodes1);
    }
    else if (0&&enFull){
      fprintf(dMgrO(ddm)," [%d+%d] ",visitedNodes->num-nLevel0, nLevel0); fflush(dMgrO(ddm));
      AigSatDiffTot(ddm,visitedNodes,careBaig,0,0,0/*cacheEnable*/);
      AigSatDiffTot(ddm,visitedNodes,careBaig,0,1,0/*cacheEnable*/);
    }

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"{%d/%d}", ddm->stats.aig.n_merge_2-nm0,
                      ddm->stats.aig.n_check_2-nc0); fflush(dMgrO(ddm));
    }
    nc0 = ddm->stats.aig.n_check_2;
    nm0 = ddm->stats.aig.n_merge_2;

    cof0 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                      bAig_AuxAig0(bmgr,fBaig);
    cof1 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
                                      bAig_AuxAig1(bmgr,fBaig);


    Pdtutil_Assert(careBaig!=bAig_NULL,"NULL care");
#if 0
    if (0&&cof0 != cof1) {
      bAigEdge_t new, myCareBaig = bAig_Not(cof0);
      myCareBaig = bAig_And(bmgr,careBaig,myCareBaig);

      AigSatDiffTot(ddm,visitedNodes,myCareBaig,-1,0/*cacheEnable*/);
      new = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
                                          bAig_AuxAig1(bmgr,fBaig);
      cof1 = new;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
	fprintf(dMgrO(ddm),"{%d/%d}", ddm->stats.aig.n_merge_2-nm0,
                        ddm->stats.aig.n_check_2-nc0); fflush(dMgrO(ddm));
      }
      nc0 = ddm->stats.aig.n_check_2;
      nm0 = ddm->stats.aig.n_merge_2;
    }
    if (0&&cof0 != cof1) {
      bAigEdge_t new, myCareBaig = bAig_Not(cof1);
      myCareBaig = bAig_And(bmgr,careBaig,myCareBaig);

      AigSatDiffTot(ddm,visitedNodes,myCareBaig,1,0/*cacheEnable*/);
      new = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                          bAig_AuxAig0(bmgr,fBaig);
      cof0 = new;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
	fprintf(dMgrO(ddm),"{%d/%d}", ddm->stats.aig.n_merge_2-nm0,
                        ddm->stats.aig.n_check_2-nc0); fflush(dMgrO(ddm));
      }
    }
#else
#if 1
    if (enFull && cof0 != cof1) {
      int i, rootCompl=0;
      bAig_array_t *nodes0 = bAigArrayAlloc();
      bAig_array_t *nodes1 = bAigArrayAlloc();

      newfBaig = bAig_Or(bmgr,cof0,cof1);
      newfAig = Ddi_BddMakeFromBaig(ddm,newfBaig);
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
	fprintf(dMgrO(ddm),"[%d]", Ddi_BddSize(newfAig));
	fflush(dMgrO(ddm));
      }
      if (bestAig!=NULL && Ddi_BddSize(newfAig) < Ddi_BddSize(bestAig)) {
	Ddi_Free(bestAig);
	bestAig = newfAig;
      }
      else {
        Ddi_Free(newfAig);
      }

      rootCompl =
        bAig_NodeIsInverted(visitedNodes->nodes[visitedNodes->num-1]);
      for (i=0; i<visitedNodes->num; i++) {
        bAigEdge_t baig = bAig_NonInvertedEdge(visitedNodes->nodes[i]);
        visitedNodes->nodes[i] = baig;
        cof0 = bAig_AuxAig0(bmgr,baig);
        cof1 = bAig_AuxAig1(bmgr,baig);
#if 0
	printf("\n%d) r/c0/c1: %5d(%5d,%5d) %5d(%5d,%5d) %5d(%5d,%5d)",
	       i, baig, bAig_NodeReadIndexOfRightChild(bmgr,baig),
                     bAig_NodeReadIndexOfLeftChild(bmgr,baig),
         cof0, bAig_NodeReadIndexOfRightChild(bmgr,cof0),
               bAig_NodeReadIndexOfLeftChild(bmgr,cof0),
	 cof1, bAig_NodeReadIndexOfRightChild(bmgr,cof1),
               bAig_NodeReadIndexOfLeftChild(bmgr,cof1)
        );
#endif
        bAigArrayWriteLast(nodes0,cof0);
        bAigArrayWriteLast(nodes1,cof1);
      }
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
	fprintf(dMgrO(ddm),"\n");
      }
      if (rootCompl) {
        visitedNodes->nodes[visitedNodes->num-1] =
  	  bAig_Not(visitedNodes->nodes[visitedNodes->num-1]);
      }
      approxResult =
        AigOptOrIncrementalAcc (ddm,visitedNodes,nodes0,nodes1,careBaig,
	  -1,-1,NULL,timeLimit-(util_cpu_time ()-startTime)/1000.0);
      for (i=0; i<visitedNodes->num; i++) {
        bAigEdge_t baig = visitedNodes->nodes[i];
        cof0 = nodes0->nodes[i];
        cof1 = nodes1->nodes[i];
        bAig_AuxAig0(bmgr,baig) = cof0;
        bAig_AuxAig1(bmgr,baig) = cof1;
      }
    }
#else
    if (enFull && cof0 != cof1) {
      newfBaig = bAig_Or(bmgr,cof0,cof1);
      newfAig = Ddi_BddMakeFromBaig(ddm,newfBaig);
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
	fprintf(dMgrO(ddm),"[%d]", Ddi_BddSize(newfAig));
	fflush(dMgrO(ddm));
      }
      if (bestAig!=NULL && Ddi_BddSize(newfAig) < Ddi_BddSize(bestAig)) {
	Ddi_Free(bestAig);
	bestAig = newfAig;
      }
      else {
        Ddi_Free(newfAig);
      }
      AigSatOptMerge(ddm,visitedNodes,careBaig,1&&(nosat==0),1,
        cof0Sig,cof1Sig,careSig);
    }
    if (enFull && cof0 != cof1) {
      AigSatOptMerge(ddm,visitedNodes,careBaig,1&&(nosat==0),-1,
        cof0Sig,cof1Sig,careSig);
    }
#endif
#endif

    DdiAigSignatureArrayFree(cof0Sig);
    DdiAigSignatureArrayFree(cof1Sig);
    for (j=0; j<visitedNodes->num; j++) {
      bAigEdge_t baig = visitedNodes->nodes[j];
      nodeAuxChar(bmgr,baig) = 0;
    }

  }

  cof0 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                      bAig_AuxAig0(bmgr,fBaig);
  cof1 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
                                      bAig_AuxAig1(bmgr,fBaig);

  eq = 0;
  newfAig = NULL;
  if (cof0 == cof1) {
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"<EQ>"); fflush(dMgrO(ddm));
    }
    eq = 1;
  }
#if 0
  else {
    newfAig = Ddi_AigDiffOptByBdd(fAig,v);
  }
#endif
  if (newfAig == NULL) {
    newfBaig = bAig_Or(bmgr,cof0,cof1);
    newfAig = Ddi_BddMakeFromBaig(ddm,newfBaig);
  }

  existClearVisitedIntern(bmgr,fBaig);

#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  bmgr = ddm->aig.mgr;
  varIndex = Ddi_VarToBaig(v);
  bAig_AuxAig0(bmgr,varIndex) = bAig_NULL;
  bAig_AuxAig1(bmgr,varIndex) = bAig_NULL;
  if (nodeVisited(bmgr,varIndex)) {
    nodeClearVisited(bmgr,varIndex);
  }
#endif

  if (eq) {
    if (Ddi_BddSize(newfAig) > Ddi_BddSize(fAig)) {
      Ddi_BddOrAcc(cof0Aig,cof1Aig);
      if (Ddi_BddSize(newfAig) > Ddi_BddSize(cof0Aig)) {
	Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
	  printf("[%d<-COF0|COF1:%d]",
		 Ddi_BddSize(newfAig),Ddi_BddSize(cof0Aig));
	  fflush(dMgrO(ddm));
	}
	Ddi_Free(newfAig);
	newfAig = Ddi_BddDup(cof0Aig);
      }
    }
  }
  Ddi_Free(cof0Aig);
  Ddi_Free(cof1Aig);


  if (approxResult) {
    Ddi_Bdd_t *careBdd = Ddi_BddMakeFromBaig(ddm,careBaig);
    Ddi_Bdd_t *careBddAnd = Ddi_BddAnd(careBdd,newfAig);
    Ddi_Bdd_t *careBddOr = Ddi_BddDiff(careBdd,newfAig);
    Ddi_Bdd_t *fAndBdd = Ddi_BddDup(bestAig);
    Ddi_Bdd_t *fOrBdd = Ddi_BddDup(bestAig);
    int t = ddm->settings.aig.satTimeout;
    ddm->settings.aig.satTimeout = 0;
#if 0
    AigRedRemovalIncrementalAcc (fAndBdd,careBddAnd,
      Ddi_BddSize(fAndBdd),-1,NULL);
    AigRedRemovalIncrementalAcc (fOrBdd,careBddOr,
      Ddi_BddSize(fAndBdd),-1,NULL);
#else
    DdiAigRedRemovalAcc (fAndBdd,careBddAnd,-1,timeLimit/5);
    DdiAigRedRemovalAcc (fOrBdd,careBddOr,-1,timeLimit/5);
#endif
    ddm->settings.aig.satTimeout = t;
    Ddi_BddAndAcc(newfAig,fAndBdd);
    Ddi_BddOrAcc(newfAig,fOrBdd);
    DdiAigRedRemovalAcc (newfAig,careBdd,-1,timeLimit/5);
    Ddi_Free(careBdd);
    Ddi_Free(careBddAnd);
    Ddi_Free(careBddOr);
    Ddi_Free(fAndBdd);
    Ddi_Free(fOrBdd);
  }

  if (ddm->settings.aig.satCompare && bestAig!=NULL) {
    Ddi_Bdd_t *careBdd = Ddi_BddMakeFromBaig(ddm,careBaig);
    Ddi_Bdd_t *f1Bdd = Ddi_BddDup(newfAig);
    Ddi_BddXorAcc(f1Bdd,bestAig);
    if (careBdd!=NULL) {
      Ddi_BddAndAcc(f1Bdd,careBdd);
    }
    Pdtutil_Assert(!Ddi_AigSat(f1Bdd),"Wrong RED REMOVAL");
    Ddi_Free(f1Bdd);
    Ddi_Free(careBdd);
  }



  if (bestAig!=NULL && Ddi_BddSize(newfAig) > Ddi_BddSize(bestAig)) {
    Ddi_Free(newfAig);
    newfAig = Ddi_BddDup(bestAig);
  }
  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);

  for (j=0; j<visitedNodes->num; j++) {
    bAigEdge_t baig = visitedNodes->nodes[j];
    bAig_RecursiveDeref(bmgr,bAig_AuxAig0(bmgr,baig));
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
  }
  bAigArrayFree(visitedNodes);

  Ddi_Free(bestAig);
  Ddi_Free(newfAig);

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistEqVarAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Var_t *v,
  Ddi_Bdd_t *care,
  Ddi_AigSignatureArray_t *varSigs,
  Ddi_AigSignature_t *careSig
)
{
  int j, eq;
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig, *cof0Aig, *cof1Aig;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, fBaig, careBaig, cof0, cof1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  int extRef = Ddi_MgrReadExtRef(ddm);
  Ddi_AigSignatureArray_t *cof0Sig, *cof1Sig;
  int mySatTimeLimit = ddm->settings.aig.satTimeLimit;

  if (ddm->settings.aig.satTimeout > 0) {
    mySatTimeLimit = ddm->settings.aig.satTimeout;
  }

  /* the length of the two arrays must be the same */

  bmgr = ddm->aig.mgr;
  fBaig = Ddi_BddToBaig(fAig);
  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }
  //  cofVar = v;

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  varIndex = Ddi_VarToBaig(v);
  Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");

  cof0Sig = DdiAigEvalSignature(ddm,visitedNodes,varIndex,0,varSigs);
  cof1Sig = DdiAigEvalSignature(ddm,visitedNodes,varIndex,1,varSigs);

  if (0&&-!DdiEqSignatures(&cof0Sig->sArray[visitedNodes->num-1],
                    &cof1Sig->sArray[visitedNodes->num-1],careSig)) {
    fprintf(dMgrO(ddm),"<!EQ(S)>"); fflush(dMgrO(ddm));
    DdiAigSignatureArrayFree(cof0Sig);
    DdiAigSignatureArrayFree(cof1Sig);
    bAigArrayFree(visitedNodes);
    return(NULL);
  }

  bAig_AuxAig0(bmgr,varIndex) = bAig_Zero;
  bAig_AuxAig1(bmgr,varIndex) = bAig_One;

#if 1
  existDiffEvalIntern(ddm,visitedNodes,careBaig,1/*cache enable*/);
#endif
  cof0 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                      bAig_AuxAig0(bmgr,fBaig);
  cof1 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
                                      bAig_AuxAig1(bmgr,fBaig);
  cof0Aig = Ddi_BddMakeFromBaig(ddm,cof0);
  cof1Aig = Ddi_BddMakeFromBaig(ddm,cof1);

  if (bAig_AuxAig0(bmgr,fBaig) != bAig_AuxAig1(bmgr,fBaig)) {
    int diff;
    bAigEdge_t topCompare;
    Ddi_Bdd_t *topCompareAig;
    cof0 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                      bAig_AuxAig0(bmgr,fBaig);
    cof1 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
                                      bAig_AuxAig1(bmgr,fBaig);
    topCompare = bAig_And (bmgr,bAig_Not(cof0),cof1);
    topCompareAig = Ddi_BddMakeFromBaig(ddm,topCompare);
    if (care!=NULL) {
      Ddi_BddAndAcc(topCompareAig,care);
    }
    /* @@@@ */
    diff = Ddi_AigSatWithAbort(topCompareAig,mySatTimeLimit);
    Ddi_Free(topCompareAig);
    if (!diff) {
      /* top level merge cof0 -> cof1 */
#if 0
      bAigMergeCacheWrite(bmgr,
        bAig_AuxAig0(bmgr,fBaig),bAig_AuxAig1(bmgr,fBaig),careBaig,1);
#endif
      bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,fBaig));
      bAig_AuxAig1(ddm->aig.mgr,fBaig) = bAig_AuxAig0(ddm->aig.mgr,fBaig);
      bAig_Ref(bmgr, bAig_AuxAig0(bmgr,fBaig));
    }
    else {
      topCompare = bAig_And (bmgr,bAig_Not(cof1),cof0);
      topCompareAig = Ddi_BddMakeFromBaig(ddm,topCompare);
      if (care!=NULL) {
        Ddi_BddAndAcc(topCompareAig,care);
      }
      diff = Ddi_AigSatWithAbort(topCompareAig,ddm->settings.aig.satTimeLimit);
      Ddi_Free(topCompareAig);
      if (!diff) {
        /* top level merge cof0 -> cof1 */
#if 0 /* incompatible care !!!!! */
        bAigMergeCacheWrite(bmgr,
          bAig_AuxAig0(bmgr,fBaig),bAig_AuxAig1(bmgr,fBaig),careBaig,2);
#endif
        bAig_RecursiveDeref(bmgr,bAig_AuxAig0(bmgr,fBaig));
        bAig_AuxAig0(ddm->aig.mgr,fBaig) = bAig_AuxAig1(ddm->aig.mgr,fBaig);
        bAig_Ref(bmgr, bAig_AuxAig0(bmgr,fBaig));
      }
    }
  }

  cof0 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                      bAig_AuxAig0(bmgr,fBaig);
  cof1 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
                                      bAig_AuxAig1(bmgr,fBaig);

#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  bmgr = ddm->aig.mgr;
  varIndex = Ddi_VarToBaig(v);
  if (nodeVisited(bmgr,varIndex)) {
    nodeClearVisited(bmgr,varIndex);
  }
  bAig_AuxAig0(bmgr,varIndex) = bAig_NULL;
  bAig_AuxAig1(bmgr,varIndex) = bAig_NULL;
#endif

  eq = 0;
  newfAig = NULL;
  if (cof0 == cof1) {
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"<EQ>"); fflush(dMgrO(ddm));
    }
    newfAig = Ddi_BddMakeFromBaig(ddm,cof0);
    eq = 1;
    DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);
  }
  else {
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"<!EQ>"); fflush(dMgrO(ddm));
    }
    fAig = NULL;
  }
  Ddi_Free(cof0Aig);
  Ddi_Free(cof1Aig);

  DdiAigSignatureArrayFree(cof0Sig);
  DdiAigSignatureArrayFree(cof1Sig);

  for (j=0; j<visitedNodes->num; j++) {
    bAigEdge_t baig = visitedNodes->nodes[j];
    bAig_RecursiveDeref(bmgr,bAig_AuxAig0(bmgr,baig));
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
  }
  bAigArrayFree(visitedNodes);

  Ddi_Free(newfAig);
  Ddi_MgrCheckExtRef(ddm,extRef);

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiAigArrayExistEqVarAcc (
  Ddi_Bddarray_t *fAigArray,
  Ddi_Var_t *v,
  Ddi_Bdd_t *care,
  Ddi_AigSignatureArray_t *varSigs,
  Ddi_AigSignature_t *careSig
)
{
  int eq, i, nEq, nDiff1, nDiff2, nSkip;
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig, *cof0Aig, *cof1Aig;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, fBaig, careBaig, cof0, cof1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigArray);
  int extRef = Ddi_MgrReadExtRef(ddm);
  Ddi_AigSignatureArray_t *cof0Sig, *cof1Sig;
  int *roots, nRoots;
  Ddi_Varset_t **suppArray;

  /* the length of the two arrays must be the same */

  bmgr = ddm->aig.mgr;
  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }
  //  cofVar = v;

  nRoots = Ddi_BddarrayNum(fAigArray);
  roots = Pdtutil_Alloc(int,nRoots);

  visitedNodes = bAigArrayAlloc();
  suppArray = Ddi_BddarraySuppArray(fAigArray);

  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fAigArray,i);
    Ddi_Varset_t *fSupp = suppArray[i];
    if (Ddi_VarInVarset(fSupp,v)) {
      fBaig = Ddi_BddToBaig(f);
      postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
      postOrderAigClearVisitedIntern(bmgr,visitedNodes);
      roots[i] = visitedNodes->num-1;
    }
    else {
      roots[i] = -1;
    }
    Ddi_Free(fSupp);
  }
  /*postOrderAigClearVisitedIntern(bmgr,fBaig);*/
  aigArrayClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  Pdtutil_Free(suppArray);

  varIndex = Ddi_VarToBaig(v);
  Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");

  cof0Sig = DdiAigEvalSignature(ddm,visitedNodes,varIndex,0,varSigs);
  cof1Sig = DdiAigEvalSignature(ddm,visitedNodes,varIndex,1,varSigs);

  bAig_AuxAig0(bmgr,varIndex) = bAig_Zero;
  bAig_AuxAig1(bmgr,varIndex) = bAig_One;

#if 1
  existDiffEvalIntern(ddm,visitedNodes,careBaig,1/*cache enable*/);
#endif

  nEq = nDiff1 = nDiff2 = nSkip = 0;
  for (i=0; i<nRoots; i++) {
    int j = roots[i];
    if (j<0) {
      nSkip++;
      continue;
    }
    fBaig = visitedNodes->nodes[j];
    if (!DdiEqSignatures(&cof0Sig->sArray[j],&cof1Sig->sArray[j],careSig)) {
      nDiff1++;
      continue;
    }

    cof0 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                        bAig_AuxAig0(bmgr,fBaig);
    cof1 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
                                        bAig_AuxAig1(bmgr,fBaig);
    cof0Aig = Ddi_BddMakeFromBaig(ddm,cof0);
    cof1Aig = Ddi_BddMakeFromBaig(ddm,cof1);

    if (1 && bAig_AuxAig0(bmgr,fBaig) != bAig_AuxAig1(bmgr,fBaig)) {
      int diff;
      bAigEdge_t topCompare;
      Ddi_Bdd_t *topCompareAig;
      cof0 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                        bAig_AuxAig0(bmgr,fBaig);
      cof1 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
                                        bAig_AuxAig1(bmgr,fBaig);
      topCompare = bAig_Xor (bmgr,cof0,cof1);
      topCompareAig = Ddi_BddMakeFromBaig(ddm,topCompare);
      if (care!=NULL) {
        Ddi_BddAndAcc(topCompareAig,care);
      }
      diff = Ddi_AigSatWithAbort(topCompareAig,ddm->settings.aig.satTimeLimit);
      Ddi_Free(topCompareAig);
      if (!diff) {
        /* top level merge cof0 -> cof1 */
        bAig_AuxAig1(ddm->aig.mgr,fBaig) = bAig_AuxAig0(ddm->aig.mgr,fBaig);
      }
    }

    cof0 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                        bAig_AuxAig0(bmgr,fBaig);
    cof1 = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
                                        bAig_AuxAig1(bmgr,fBaig);


    eq = 0;
    newfAig = NULL;
    if (cof0 == cof1) {
      int size0, size1;
      size0 = myNodeCountIntern(bmgr,cof0);
      myNodeClearVisitedIntern(bmgr,cof0);
      size1 = myNodeCountIntern(bmgr,cof1);
      myNodeClearVisitedIntern(bmgr,cof1);
      if (size0<size1) {
        newfAig = Ddi_BddMakeFromBaig(ddm,cof0);
      }
      else {
        newfAig = Ddi_BddMakeFromBaig(ddm,cof1);
      }
      nEq++;
      eq = 1;
      Ddi_BddarrayWrite(fAigArray,i,newfAig);
    }
    else {
      nDiff2++;
    }
    Ddi_Free(newfAig);
    Ddi_Free(cof0Aig);
    Ddi_Free(cof1Aig);
  }

  fprintf(dMgrO(ddm),"<EQ:%d",nEq);
  fprintf(dMgrO(ddm)," !EQ(S):%d", nDiff1);
  fprintf(dMgrO(ddm)," !EQ:%d> (%d)", nDiff2, nSkip);

#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  bmgr = ddm->aig.mgr;
  varIndex = Ddi_VarToBaig(v);
  if (nodeVisited(bmgr,varIndex)) {
    bAig_AuxAig0(bmgr,varIndex) = bAig_NULL;
    bAig_AuxAig1(bmgr,varIndex) = bAig_NULL;
    nodeClearVisited(bmgr,varIndex);
  }
#endif

  DdiAigSignatureArrayFree(cof0Sig);
  DdiAigSignatureArrayFree(cof1Sig);
  bAigArrayFree(visitedNodes);

  Ddi_MgrCheckExtRef(ddm,extRef);

  Pdtutil_Free(roots);

}

/**Function********************************************************************
  Synopsis    [Conditional existential quantification (ternary overapprox).]
  Description [Conditional existential quantification (ternary overapprox).
               Existential quantification with ternary model is accepted
               (aborted) if resulting size is above (below) minSize.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistOverPartialAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *smooth,
  Ddi_Bdd_t *care,
  int minSize
)
{
  int j, abort, fSize, fSize0;
  Ddi_Vararray_t *vA;
  Ddi_Varset_t *suppSmooth = Ddi_BddSupp(fAig);
  Ddi_VarsetIntersectAcc(suppSmooth,smooth);
  vA = Ddi_VararrayMakeFromVarset(suppSmooth,1);
  fSize0 = Ddi_BddSize(fAig);
  for (j=0; j<Ddi_VararrayNum(vA); j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    Ddi_Bdd_t *fNew = Ddi_BddDup(fAig);
    DdiAigExistVarOverAcc (fNew,v,care);
    fSize = Ddi_BddSize(fNew);
    abort = 0;
    if (care != NULL && (fSize <= fSize0*1.05) && (fSize > minSize)) {
      Ddi_Bdd_t *a=Ddi_BddDiff(fNew,care);
      if (Ddi_AigSat(a)) {
	abort=1;
      }
      Ddi_Free(a);
    }
    if (!abort && (fSize <= fSize0*1.05) && (fSize > minSize)) {
      DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)fNew);
      fSize0 = fSize;
    }
    Ddi_Free(fNew);
  }
  Ddi_Free(vA);
  Ddi_Free(suppSmooth);
  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigMonotoneRedAcc (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *project,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Varset_t *suppSm, *suppAbstr;
  Ddi_Bdd_t *r;
  int i;


  if (Ddi_BddIsConstant(a)) {
    return NULL;
  }

  suppSm = Ddi_BddSupp(a);
  suppAbstr = Ddi_VarsetDup(suppSm);
  if (project!=NULL) {
    if (Ddi_VarsetIsArray(project)) {
      Ddi_VarsetSetArray(project);
      Ddi_VarsetSetArray(suppAbstr);
    }
    
    Ddi_VarsetDiffAcc(suppSm,project);
    Ddi_VarsetDiffAcc(suppAbstr,project);
  }
  
  r = DdiAigTernaryInterpolantAcc (a,NULL,suppAbstr,
          suppSm,NULL,care,0,0,timeLimit);

  Ddi_Free(suppSm);
  Ddi_Free(suppAbstr);

  Ddi_DataCopy (a,r);
  Ddi_Free(r);

  return a;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigTernaryInterpolantByGroupsAcc (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Varset_t *abstr,
  Ddi_Varset_t *smooth,
  Ddi_Varset_t *ternarySmooth,
  Ddi_Bdd_t *care,
  int maxVars,
  int phase,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Vararray_t *vA;
  Ddi_Varset_t *suppSm, *suppAbstr;
  Ddi_Bdd_t *newa;
  int i, nv;


  if (b!=NULL) {
    if (Ddi_AigSatAnd(a,b,care)) {
      return (NULL);
    }
  }

  suppSm = Ddi_BddSupp(a);
  suppAbstr = Ddi_VarsetDup(suppSm);
  if (Ddi_VarsetIsArray(smooth)) {
    Ddi_VarsetSetArray(suppSm);
  }
  if (Ddi_VarsetIsArray(abstr)) {
    Ddi_VarsetSetArray(suppAbstr);
  }
  Ddi_VarsetIntersectAcc(suppSm,smooth);
  Ddi_VarsetIntersectAcc(suppAbstr,abstr);

  if (0||Ddi_VarsetNum(suppAbstr)<maxVars) {
    Ddi_Bdd_t *r;
    r = DdiAigTernaryInterpolantAcc (a,b,suppAbstr,
          suppSm,ternarySmooth,care,0,phase,timeLimit);
    Ddi_Free(suppSm);
    Ddi_Free(suppAbstr);
    return r;
  }

  /* check monotonicity */
  if (phase != 3) {
    newa = DdiAigTernaryInterpolantAcc (a,b,suppAbstr,
           suppSm,ternarySmooth,care,0,0,timeLimit);
    Ddi_Free(suppSm);
    Ddi_Free(suppAbstr);
    suppSm = Ddi_BddSupp(newa);
    suppAbstr = Ddi_VarsetDup(suppSm);
  }
  else {
    newa = Ddi_BddDup(a);
  }

  if (Ddi_VarsetIsArray(smooth)) {
    Ddi_VarsetSetArray(suppSm);
  }
  if (Ddi_VarsetIsArray(abstr)) {
    Ddi_VarsetSetArray(suppAbstr);
  }
  Ddi_VarsetIntersectAcc(suppSm,smooth);
  Ddi_VarsetIntersectAcc(suppAbstr,abstr);

  vA = Ddi_VararrayMakeFromVarset(suppAbstr,1);
  Ddi_Free(suppAbstr);
  suppAbstr = Ddi_VarsetVoid(ddm);
  Ddi_VarsetSetArray(suppAbstr);

  //  newa = Ddi_BddDup(a);
  nv = Ddi_VararrayNum(vA);
  if (maxVars > nv/2) {
    maxVars = nv/2+1;
  }
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    int j=nv-i-1;
    Ddi_VarsetAddAcc(suppAbstr,Ddi_VararrayRead(vA,j));
    if ((i+1)%maxVars == 0 || i==(Ddi_VararrayNum(vA)-1)) {
      Ddi_Bdd_t *r;
      Ddi_Varset_t *mySuppSm = Ddi_VarsetIntersect(suppAbstr,suppSm);
      r = DdiAigTernaryInterpolantAcc (newa,b,suppAbstr,
	    mySuppSm,ternarySmooth,care,0,phase,timeLimit);
      Ddi_Free(suppAbstr);
      Ddi_Free(mySuppSm);
      if (r!=NULL) {
        Ddi_Free(newa);
        newa = r;
      }
      suppAbstr = Ddi_VarsetVoid(ddm);
      Ddi_VarsetSetArray(suppAbstr);
    }
  }
  Ddi_Free(suppAbstr);
  Ddi_Free(suppSm);
  Ddi_Free(vA);

  return newa;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigTernaryInterpolantAcc (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Varset_t *abstr,
  Ddi_Varset_t *smooth,
  Ddi_Varset_t *ternarySmooth,
  Ddi_Bdd_t *care,
  int chkProd,
  int phase,
  float timeLimit
)
{
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newaAig, *newbAig, *cof0Aig, *cof1Aig, *notaAig;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, auxVarIndex, auxVarIndex2,
    aBaig, bBaig, careBaig, cof0, cof1, f0, f1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int extRef = Ddi_MgrReadExtRef(ddm);
  int i, j, sat, nVars;
  Ddi_Vararray_t *vSm, *vA, *vAsave, *vAuxA, *vAuxB;
  Ddi_Bdd_t *prod;
  int assumeSingleTernary, *assumeTernary;
  int *redCodeBits=NULL;
  int redCodeSize, refinementDone, nCurrTernary;
  int checkSingleTernary;
  int checkFunction = 0;
  int doTernaryB = 0;
  Ddi_Bdd_t *myB=NULL;
  int size0 = Ddi_BddSize(a);
  int size0b = b==NULL ? 0 : Ddi_BddSize(b);
  int checkMonotonicity = 0;
  int myDbg = 0, nCached = 0;
  Ddi_Vararray_t *piNodes;
  Ddi_Varset_t *piSet;
  int nPi, *piCnfIds=NULL;
  double time_limit=-1.0;
  int undefinedResult = 0;
  long startTimeTot=0;
  int enMonotonicityCheck = phase<=2;
  int useVarsB=1;
  int maxMonotonicity = -1;
  int strategy = Ddi_MgrReadAigTernaryAbstrStrategy(ddm);

  static int ncalls=0;

  ncalls++;

  startTimeTot = util_cpu_time();


  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);

  Solver    S;
  vec<Lit> lits, assumeSingleTernaryArray, assumeNoTernaryArray;
  vec<Lit> prevCex;
  int prevCexUsed = 0;

  Ddi_Varset_t *suppSm=NULL, *suppAbstr=NULL;

  bmgr = ddm->aig.mgr;
  aBaig = Ddi_BddToBaig(a);
  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }

  if (Ddi_BddIsZero(a)) {
    return (Ddi_BddDup(a));
  }
  if (b != NULL && Ddi_BddIsZero(b)) {
    newaAig = Ddi_BddMakeConstAig(ddm,1);
    return (newaAig);
  }

  if (ddm->settings.aig.satTimeout) {
    time_limit = 1.0;
    if (ddm->settings.aig.satTimeout>1) {
      time_limit /= 5;
      if (ddm->settings.aig.satTimeout>2) {
        time_limit /= 5;
      }
    }
  }
  if (timeLimit >= 0) time_limit = timeLimit / 10.0;
  //  if (strategy == 1) time_limit = timeLimit * 3;

  if (b!=NULL && chkProd) {
    bBaig = Ddi_BddToBaig(b);

    prod = Ddi_BddAnd(a,b);

    if (care != NULL) {
      Ddi_BddAndAcc(prod,care);
    }

    if (DdiAigIsConst(prod,0)) {
      Ddi_Free(prod);
      return Ddi_BddDup(a);
    }

    sat = Ddi_AigSat(prod);
    Ddi_Free(prod);
    if (sat) {
      return (NULL);
    }

  }
  if (b!=NULL && !chkProd) {
    bBaig = Ddi_BddToBaig(b);
  }
  else {
    bBaig = bAig_NULL;
  }

  suppSm = Ddi_BddSupp(a);
  suppAbstr = Ddi_VarsetDup(suppSm);

  if (b != NULL && 0)
  {
    Ddi_Varset_t *suppB = Ddi_BddSupp(b);
    Ddi_Varset_t *oldSupp = Ddi_VarsetDup(suppAbstr);
    if (Ddi_VarsetIsArray(smooth)) {
      Ddi_VarsetSetArray(suppB);
    }
    Ddi_VarsetIntersectAcc(suppB,smooth);
    if (!Ddi_VarsetIsVoid(suppB)) {
      doTernaryB = 1;
      Ddi_VarsetUnionAcc(suppAbstr,suppB);
    }
    Ddi_VarsetIntersectAcc(suppB,oldSupp);
    Pdtutil_Assert(Ddi_VarsetIsVoid(suppB),"wrong support in interpolant");
    Ddi_Free(oldSupp);
    Ddi_Free(suppB);
  }

  if (Ddi_VarsetIsArray(smooth)) {
    Ddi_VarsetSetArray(suppSm);
  }
  Ddi_VarsetIntersectAcc(suppSm,smooth);
  if (Ddi_VarsetIsArray(abstr)) {
    Ddi_VarsetSetArray(suppAbstr);
  }
  Ddi_VarsetIntersectAcc(suppAbstr,abstr);

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,aBaig,visitedNodes,-1);
  if (doTernaryB) {
    postOrderAigVisitIntern(bmgr,bBaig,visitedNodes,-1);
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  vSm = Ddi_VararrayMakeFromVarset(suppSm,1);
  vA = Ddi_VararrayMakeFromVarset(suppAbstr,1);
  vAuxA = Ddi_VararrayAlloc(ddm,Ddi_VararrayNum(vA));
  vAuxB = Ddi_VararrayAlloc(ddm,Ddi_VararrayNum(vA));

  vAsave = Ddi_VararrayDup(vA);

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    char name[100];
    Ddi_Var_t *vAux;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    sprintf(name,"PDTRAV_TERNARY_ITP_DUMMY_VAR_%d",i);
    if ((vAux = Ddi_VarFromName(ddm,name))==NULL) {
      vAux = Ddi_VarNew(ddm);
      Ddi_VarAttachName (vAux, name);
    }
    Ddi_VararrayWrite(vAuxA,i,vAux);
    varIndex = Ddi_VarToBaig(v);
    auxVarIndex = Ddi_VarToBaig(vAux);
    if (useVarsB) {
      sprintf(name,"PDTRAV_TERNARY_ITP_DUMMY_VAR2_%d",i);
      if ((vAux = Ddi_VarFromName(ddm,name))==NULL) {
	vAux = Ddi_VarNew(ddm);
	Ddi_VarAttachName (vAux, name);
      }
      Ddi_VararrayWrite(vAuxB,i,vAux);
    }
    else {
      Ddi_VararrayWrite(vAuxB,i,vAux);
    }
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    Pdtutil_Assert(auxVarIndex != bAig_NULL,"NULL variable in ExistVar");
    Pdtutil_Assert(bAig_AuxAig0(bmgr,varIndex)==bAig_NULL,
      "NULL AuxAig0 required");
    Pdtutil_Assert(bAig_AuxAig1(bmgr,varIndex)==bAig_NULL,
      "NULL AuxAig1 required");
    /* set ternary X */
    f0 = bAig_NonInvertedEdge(auxVarIndex);
    f1 = bAig_NonInvertedEdge(varIndex);
    bAig_AuxAig0(bmgr,varIndex) = f0;
    bAig_AuxAig1(bmgr,varIndex) = f1;
    bAig_Ref(bmgr, f0);
    bAig_Ref(bmgr, f1);
  }

  //  existDiffEvalIntern(ddm,visitedNodes,careBaig,1/*cache enable*/);
  //  ternaryEvalIntern(ddm,visitedNodes,careBaig,4*visitedNodes->num/4-1);

  ternaryEvalIntern(ddm,visitedNodes,careBaig,-1);

  cof0 = bAig_AuxAig0(bmgr,aBaig);
  cof1 = bAig_AuxAig1(bmgr,aBaig);
  if (bAig_NodeIsInverted(aBaig)) {
    bAigSwap(cof0,cof1);
  }

  cof0Aig = Ddi_BddMakeFromBaig(ddm,cof0);
  cof1Aig = Ddi_BddMakeFromBaig(ddm,cof1);
  newaAig = Ddi_BddNot(cof0Aig);

  if (doTernaryB) {
    Ddi_Free(cof0Aig);
    Ddi_Free(cof1Aig);
    cof0 = bAig_AuxAig0(bmgr,bBaig);
    cof1 = bAig_AuxAig1(bmgr,bBaig);
    if (bAig_NodeIsInverted(bBaig)) {
      bAigSwap(cof0,cof1);
    }

    cof0Aig = Ddi_BddMakeFromBaig(ddm,cof0);
    cof1Aig = Ddi_BddMakeFromBaig(ddm,cof1);
    newbAig = Ddi_BddNot(cof0Aig);
    existClearVisitedIntern(bmgr,bBaig);
  }
  else {
    newbAig = NULL;
  }

  notaAig = NULL;
  if (b == NULL) {
    notaAig = Ddi_BddNot(cof1Aig);
  }

  existClearVisitedIntern(bmgr,aBaig);
  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);

  if (enMonotonicityCheck)
  {
    Ddi_Varset_t *bSupp=NULL, *cSupp=NULL, *aSupp = Ddi_BddSupp(newaAig);
    if (newbAig != NULL) bSupp = Ddi_BddSupp(newbAig);
    if (care != NULL) cSupp = Ddi_BddSupp(care);

    int monotonicityFound, redundancyCnt=0, monotonicityCnt=0;
    do {
      int j;
      monotonicityFound = 0;

      for (i=Ddi_VararrayNum(vA)-1,j=Ddi_VararrayNum(vSm)-1; i>=0; i--) {
	Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
	Ddi_Var_t *vSm_j = j<0?NULL:Ddi_VararrayRead(vSm,j);
	Ddi_Var_t *vAux = Ddi_VararrayRead(vAuxA,i);
	int vIn = Ddi_VarInVarset(aSupp,v);
	int vAuxIn = Ddi_VarInVarset(aSupp,vAux);

	if (j<0 || v!=vSm_j) continue;
	j--;

	if (maxMonotonicity >= 0 &&
            (monotonicityCnt+redundancyCnt) >= maxMonotonicity) break;
	if (newbAig != NULL) {
	  vIn |= Ddi_VarInVarset(bSupp,v);
	  vAuxIn |= Ddi_VarInVarset(bSupp,vAux);
	}
	if (care != NULL) {
	  vIn |= Ddi_VarInVarset(cSupp,v);
	  vAuxIn |= Ddi_VarInVarset(cSupp,v);
	}
	if (vIn && !vAuxIn) {
	  Ddi_BddCofactorAcc(newaAig,v,0);
	  if (newbAig != NULL) {
	    Ddi_BddCofactorAcc(newbAig,v,0);
	  }
	  if (notaAig != NULL) {
	    Ddi_BddCofactorAcc(notaAig,vAux,1);
	  }
	  monotonicityFound = 1;
	  monotonicityCnt++;
	  Ddi_VararrayRemove(vA,i);
	  Ddi_VararrayRemove(vAuxA,i);
	  Ddi_VararrayRemove(vAuxB,i);
          if (ternarySmooth != NULL) {
	    Ddi_VarsetAddAcc(ternarySmooth,v);
	  }
	}
	else if (!vIn && vAuxIn) {
       	  Ddi_BddCofactorAcc(newaAig,vAux,0);
	  if (newbAig != NULL) {
	    Ddi_BddCofactorAcc(newbAig,vAux,0);
	  }
	  if (notaAig != NULL) {
	    Ddi_BddCofactorAcc(notaAig,v,1);
	  }
	  monotonicityFound = 1;
	  Ddi_VararrayRemove(vA,i);
	  Ddi_VararrayRemove(vAuxA,i);
	  Ddi_VararrayRemove(vAuxB,i);
	  monotonicityCnt++;
          if (ternarySmooth != NULL) {
	    Ddi_VarsetAddAcc(ternarySmooth,v);
	  }
	}
	else if (!vIn && !vAuxIn) {
	  Ddi_VararrayRemove(vA,i);
	  Ddi_VararrayRemove(vAuxA,i);
	  Ddi_VararrayRemove(vAuxB,i);
	  redundancyCnt++;
          if (ternarySmooth != NULL) {
	    Ddi_VarsetAddAcc(ternarySmooth,v);
	  }
	}
      }
      if (monotonicityFound) {
	Ddi_Free(aSupp);
	aSupp = Ddi_BddSupp(newaAig);
	if (newbAig != NULL) {
	  Ddi_Free(bSupp);
	  bSupp = Ddi_BddSupp(newbAig);
	}
      }
    } while (monotonicityFound);
    Ddi_Free(aSupp);
    Ddi_Free(bSupp);
    Ddi_Free(cSupp);
    if (monotonicityCnt>0) {
      if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
	printf("ternary ITP - %d monotonicities & %d redundancies found\n",
	       monotonicityCnt, redundancyCnt);
      }
    }
  }


#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  for (i=0; i<Ddi_VararrayNum(vAsave); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vAsave,i);
    varIndex = Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    /* set ternary X */
    bAig_AuxAig0(bmgr,varIndex) = bAig_NULL;
    bAig_AuxAig1(bmgr,varIndex) = bAig_NULL;
    if (nodeVisited(bmgr,varIndex)) {
      nodeClearVisited(bmgr,varIndex);
    }
  }
#endif

  Ddi_Free(cof0Aig);
  Ddi_Free(cof1Aig);

  bAigArrayFree(visitedNodes);

#if 0
  f2 = Ddi_BddDup(a);
  Ddi_BddDiffAcc(f2,f1);
  Pdtutil_Assert(!Ddi_AigSat(f2),"Wrong exist over");
  Ddi_Free(f1);
  Ddi_Free(f2);
#endif

  if (b!=NULL)
  {
    Ddi_Bddarray_t *Lits = Ddi_BddarrayMakeLiteralsAig(vA, 0);
    Ddi_Bdd_t *chk = Ddi_BddCompose(newaAig,vAuxA,Lits);
    Pdtutil_Assert(!checkFunction || Ddi_BddIncluded(a,chk),
      "wrong ternary encoding");
    Ddi_BddAndAcc(chk,b);
    if (care != NULL) {
      Ddi_BddAndAcc(chk,care);
    }
    Pdtutil_Assert(!checkFunction || !Ddi_AigSat(chk),
      "wrong monotonicity reduction");
    Ddi_Free(Lits);
    Ddi_Free(chk);
  }
  else {
    Pdtutil_Assert(!checkFunction || notaAig!=NULL,
      "missing complement for reduction");
    newbAig = notaAig;
    notaAig = NULL;
  }

  nVars = nCurrTernary = Ddi_VararrayNum(vA);

  if (phase == 0 || nVars == 0) {

    if (nVars > 0) {
      Ddi_Bddarray_t *Lits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
      Ddi_Bddarray_t *LitsAux = Ddi_BddarrayMakeLiteralsAig(vA, 0);

      Ddi_BddComposeAcc(newaAig,vA,Lits);
      Ddi_BddComposeAcc(newaAig,vAuxA,LitsAux);
      if (newbAig != NULL) {
	Ddi_BddComposeAcc(newbAig,vA,Lits);
	Ddi_BddComposeAcc(newbAig,vAuxA,LitsAux);
      }

      Ddi_Free(Lits);
      Ddi_Free(LitsAux);
    }
    Ddi_Free(vSm);
    Ddi_Free(vA);
    Ddi_Free(vAsave);
    Ddi_Free(vAuxA);
    Ddi_Free(vAuxB);
    Ddi_Free(newbAig);
    Ddi_Free(suppSm);
    Ddi_Free(suppAbstr);
    return(newaAig);
  }

  if (newbAig != NULL) {
    myB=Ddi_BddDup(newbAig);
  }
  else {
    myB=Ddi_BddDup(b);
  }

  if (care!=NULL) {
    Ddi_BddAndAcc(myB,care);
  }

  if (useVarsB) {
    Ddi_Bddarray_t *Lits = Ddi_BddarrayMakeLiteralsAig(vAuxB, 1);
    Ddi_BddComposeAcc(myB,vA,Lits);
    Ddi_Free(Lits);
  }

  if (myDbg)
  {
    /* this is for debug */
    Ddi_Bdd_t *zeroAig = Ddi_BddMakeConstAig(ddm,0);

    for (i=0; i<nVars; i++) {
      int tCnf = assumeTernary[i];
      Ddi_Bdd_t *trya = Ddi_BddDup(newaAig);
      Ddi_Bddarray_t *Lits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
      Ddi_Bddarray_t *LitsAux = Ddi_BddarrayMakeLiteralsAig(vA, 0);

      Ddi_BddarrayWrite(Lits,i,zeroAig);
      Ddi_BddarrayWrite(LitsAux,i,zeroAig);

      Ddi_BddComposeAcc(trya,vA,Lits);
      Ddi_BddComposeAcc(trya,vAuxA,LitsAux);
      Ddi_Free(trya);
      Ddi_Free(Lits);
      Ddi_Free(LitsAux);
    }
    Ddi_Free(zeroAig);
  }

  /* load clauses to SAT manager */
  aig2CnfIdInit(ddm);

  MinisatClauses(S,newaAig,myB,NULL,0);

  /* this is just to set up cnf vars for non used ids */
  for (i=0; i<nVars; i++) {
    int k, mask, vCnf, vAuxCnf, vAuxCnf2, tCnf;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Var_t *vAux = Ddi_VararrayRead(vAuxA,i);
    Ddi_Var_t *vAux2 = Ddi_VararrayRead(vAuxB,i);
    varIndex = Ddi_VarToBaig(v);
    auxVarIndex = Ddi_VarToBaig(vAux);
    auxVarIndex2 = Ddi_VarToBaig(vAux2);
    vCnf = aig2CnfId(bmgr,varIndex);
    vAuxCnf = aig2CnfId(bmgr,auxVarIndex);
    vAuxCnf2 = useVarsB ? aig2CnfId(bmgr,auxVarIndex2) : -1;
  }
  /* synchronize aig-cnf ids */
  while (S.nVars()<=ddm->cnf.maxCnfId) S.newVar();

  S.newVar();
  assumeSingleTernary = S.nVars();
  assumeSingleTernaryArray.clear();
  assumeSingleTernaryArray.push(MinisatLit(assumeSingleTernary));
  assumeNoTernaryArray.clear();

  if (myDbg)
    fprintf(dMgrO(ddm),"AST: %d\n", assumeSingleTernary);

  assumeTernary = Pdtutil_Alloc(int, nVars);

  redCodeSize=1;
  for (j=1; j<nVars; j = j<<1) {
    redCodeSize++;
  }
  redCodeBits = Pdtutil_Alloc(int, redCodeSize);
  for (j=0; j<redCodeSize; j++) {
    S.newVar();
    redCodeBits[j] = S.nVars();
  }


  for (i=0; i<nVars; i++) {
    int k, mask, vCnf, vAuxCnf, vAuxCnf2, tCnf;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Var_t *vAux = Ddi_VararrayRead(vAuxA,i);
    Ddi_Var_t *vAux2 = Ddi_VararrayRead(vAuxB,i);
    varIndex = Ddi_VarToBaig(v);
    auxVarIndex = Ddi_VarToBaig(vAux);
    auxVarIndex2 = Ddi_VarToBaig(vAux2);

    vCnf = aig2CnfId(bmgr,varIndex);
    vAuxCnf = aig2CnfId(bmgr,auxVarIndex);
    vAuxCnf2 = useVarsB ? aig2CnfId(bmgr,auxVarIndex2) : -1;

    S.newVar();
    tCnf = assumeTernary[i] = S.nVars();

    if (myDbg)
      fprintf(dMgrO(ddm),"I: %d, T: %d - v: %d, va: %d, va2: %d, t: %d\n",
	     i, tCnf, vCnf, vAuxCnf, vAuxCnf2, tCnf);

    if (0 || (strategy != 1)) {
      /* tCnf => ternary encoding (!vCnf && !vAuxCnf) */
      MinisatClause2(S,lits,-tCnf,-vCnf);
      MinisatClause2(S,lits,-tCnf,-vAuxCnf);
    }
    /* !tCnf => binary encoding (vCnf = !vAuxCnf) */
    /* !tCnf & !vCnf => vAuxCnf) */
    MinisatClause3(S,lits,tCnf,vCnf,vAuxCnf);
    /* !tCnf & vCnf => !vAuxCnf) */
    MinisatClause3(S,lits,tCnf,-vCnf,-vAuxCnf);

    if (useVarsB) {
      /* !tCnf => (vAuxCnf2 = vCnf) */
      /* !tCnf & !vCnf => !vAuxCnf2) */
      MinisatClause3(S,lits,tCnf,vCnf,-vAuxCnf2);
      /* !tCnf & vCnf => vAuxCnf2) */
      MinisatClause3(S,lits,tCnf,-vCnf,vAuxCnf2);

#if 1
      /* !tCnf => ternary encoding (!vCnf & !vAuxCnf) */
      /* tCnf => !vCnf */
      MinisatClause2(S,lits,-tCnf,-vCnf);
      /* tCnf => !vAuxCnf */
      MinisatClause2(S,lits,-tCnf,-vAuxCnf);
#endif
    }

    assumeNoTernaryArray.push(MinisatLit(-tCnf));

    if (strategy != 1) {
      for (k=0, mask=1; k<redCodeSize; k++) {
	int bit = (i&mask) ? redCodeBits[k] : -redCodeBits[k];
	/* tCnf => !assumeSingleTernary + bit */
	if (myDbg)
	  fprintf(dMgrO(ddm),"CNT cl[%d,%d]: %d %d %d\n", i,k,
		 -tCnf, -assumeSingleTernary, bit);

	MinisatClause3(S,lits,-tCnf,-assumeSingleTernary,bit);
	mask = mask<<1;
      }
    }

  }

#if 0
        MinisatClause1(S,lits,-348);
        MinisatClause1(S,lits,-349);
        MinisatClause1(S,lits,350);
        MinisatClause1(S,lits,-351);
    if (!S.solve()) {
      fprintf(dMgrO(ddm),"UNSAT\n");
    }
#endif

  checkSingleTernary = 1;

  if (myDbg)
    Pdtutil_Assert(!S.solve(assumeNoTernaryArray),"UNSAT check required");

  prevCexUsed = 0;
  prevCex.clear();
  assumeSingleTernaryArray.copyTo(prevCex);

  piSet = Ddi_VarsetDiff(suppAbstr,abstr);
  piNodes = Ddi_VararrayMakeFromVarset(piSet,1);
  Ddi_Free(piSet);

  nPi = Ddi_VararrayNum(piNodes);
  piCnfIds = Pdtutil_Alloc(int,nPi);

  for (i=0; i<nPi; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(piNodes,i);
    bAigEdge_t baig = Ddi_VarToBaig(v);
    piCnfIds[i] = aig2CnfId(bmgr,baig);
  }

  /* strategy 1 (proof based solution) */
  if (strategy == 1) {
    int sat;
    S.minisat20_opt = true;
    if ((sat = S.okay())) {
      sat = S.solve(assumeNoTernaryArray,time_limit);
    }
    S.minisat20_opt = false;
    if (sat) {
      Pdtutil_Assert(0,"SAT check in ternary abstraction");
    }
    else if (S.undefined()) {
      fprintf(dMgrO(ddm),"TERNARY ABSTR UNDEFINED\n");
      undefinedResult=1;
    }
    else {
      for (i=0; i<nVars; i++) {
	int sat, k;
	Lit lit = assumeNoTernaryArray[i];
	for (k=0; k<S.conflict.size(); k++) {
	  Lit kLit = S.conflict[k];
	  if (var(kLit) == var(lit)) {
	    assumeTernary[i] = -1; /* disable it !!! */
	    nCurrTernary--;
	  }
	}
      }
      fprintf(dMgrO(ddm),"TERNARY_ABS (proof-based) found %d/%d abstractions\n",
	       nCurrTernary, nVars); fflush(dMgrO(ddm));
    }
  }
  else do {
    int id;
    refinementDone = 0;

    /* call SAT solver assuming at least one refinement */
    if ((sat = S.okay())) {
      sat = S.solve(prevCex,time_limit);
      sat = sat && !S.undefined();
    }

    if (sat) {
      /* a non redundant ternary node has been found: fix it and iterate */
      int k, mask, redIndex=0;
      Lit wireLit;
      int t, tCnf;

      if (checkSingleTernary) {
        for (k=0, mask=1; k<redCodeSize; k++) {
	  if (S.model[redCodeBits[k]-1]==l_True) {
	    redIndex += mask;
	  }
          mask = mask<<1;
        }
        refinementDone = 1;

        i=redIndex;
	tCnf = assumeTernary[i];
        Pdtutil_Assert(tCnf > 0,"enabled ternary control required");

	t = tCnf - 1;

        Pdtutil_Assert(S.model[t]==l_True,"missing ternary control set");

        MinisatClause1(S,lits,-tCnf);
	assumeTernary[i] = -1; /* disable it !!! */
	nCurrTernary--;

        if (!prevCexUsed && nPi > 5) {
	  prevCexUsed = 1;

	  for (k=0; k<nPi; k++) {
	    int piCnf = piCnfIds[k];
	    int pi = piCnf-1;
            if (S.model[pi]==l_False) {
	      piCnf = -piCnf;
	    }
	    prevCex.push(MinisatLit(piCnf));
	  }
        }
        else {
	  nCached++;
        }

      }
      else {
        refinementDone = 1;
	for (i=0; i<nVars; i++) {
	  Lit wireLit;
	  int id, wCnf, k, mask, refCnf;

	  tCnf = assumeTernary[i];
	  if (tCnf < 0) continue;

	  t = tCnf - 1;
	  if (S.model[t]==l_True) {
	    /* remove this ternary  */
	    MinisatClause1(S,lits,-tCnf);
	    assumeTernary[i] = -1; /* disable it !!! */
	    nCurrTernary--;
	    break;
	  }
	}
      }

    }
    else if (prevCexUsed) {
      refinementDone = 1;
      prevCexUsed = 0;
      prevCex.clear();
      assumeSingleTernaryArray.copyTo(prevCex);
    }
    else {
      if (checkSingleTernary && nCurrTernary>0) {
	checkSingleTernary = 0;
        refinementDone = 1;
        prevCex.clear();
      }
      else if (S.undefined()) {
	undefinedResult = 1;
        /* no refinement possible with SAT */
        fprintf(dMgrO(ddm),"TERNARY_ABS found %d/%d UNDEFINED abstractions - ",
	       nCurrTernary, nVars); fflush(dMgrO(ddm));
      }
      else {
        /* no refinement possible with SAT */
        fprintf(dMgrO(ddm),"TERNARY_ABS found %d/%d abstractions - ",
	       nCurrTernary, nVars); fflush(dMgrO(ddm));
      }
    }

  } while (refinementDone && nCurrTernary > 0);

  aig2CnfIdClose(ddm);

  if (strategy==1 && undefinedResult) {
    Ddi_Free(newaAig);
    newaAig = Ddi_BddDup(a);
  }
  else if (0 && undefinedResult) {
    Ddi_Free(newaAig);
    newaAig = Ddi_BddDup(a);
    if (doTernaryB) {
      Ddi_Free(newbAig);
      newbAig = Ddi_BddDup(b);
    }
    for (i=0; i<nVars; i++) {
      int tCnf = assumeTernary[i];
      if (tCnf >= 0 || checkMonotonicity) {
        Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
	Ddi_Bdd_t *chk, *g=NULL, *f = Ddi_BddDup(newaAig);
        DdiAigExistVarOverAcc (f,v,care);
        if (doTernaryB) {
	  g = Ddi_BddDup(newbAig);
          DdiAigExistVarOverAcc (g,v,care);
	}
	else {
	  g = Ddi_BddDup(b);
	}
	chk = Ddi_BddAnd(f,g);
	if (care!=NULL) {
	  Ddi_BddAndAcc(chk,care);
	}
	if (Ddi_AigSatWithAbort(chk,(int)time_limit)==0) {
	  /* invalid ternary abstraction */
	  DdiGenericDataCopy((Ddi_Generic_t *)newaAig,(Ddi_Generic_t *)f);
	  if (doTernaryB) {
	    DdiGenericDataCopy((Ddi_Generic_t *)newbAig,(Ddi_Generic_t *)g);
	  }
          if (ternarySmooth != NULL) {
	    Ddi_VarsetAddAcc(ternarySmooth,v);
	  }
	}
	Ddi_Free(chk);
	Ddi_Free(f);
	Ddi_Free(g);
      }
      if (timeLimit >= 0 &&
        ((util_cpu_time () - startTimeTot)/1000.0 > 2*timeLimit)) {
	break;
      }
    }
  }
  else
  {
    Ddi_Bddarray_t *Lits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
    Ddi_Bddarray_t *LitsAux = Ddi_BddarrayMakeLiteralsAig(vA, 0);
    Ddi_Bdd_t *zeroAig = Ddi_BddMakeConstAig(ddm,0);

    for (i=0; i<nVars; i++) {
      int tCnf = assumeTernary[i];
      if (tCnf >= 0 || checkMonotonicity) {
	Ddi_BddarrayWrite(Lits,i,zeroAig);
	Ddi_BddarrayWrite(LitsAux,i,zeroAig);
        if (ternarySmooth != NULL) {
	  Ddi_VarsetAddAcc(ternarySmooth,Ddi_VararrayRead(vA,i));
	}
      }
    }
    Ddi_BddComposeAcc(newaAig,vA,Lits);
    Ddi_BddComposeAcc(newaAig,vAuxA,LitsAux);
    if (newbAig != NULL) {
      Ddi_BddComposeAcc(newbAig,vA,Lits);
      Ddi_BddComposeAcc(newbAig,vAuxA,LitsAux);
    }

    if (Ddi_BddSize(newaAig) > Ddi_BddSize(a)) {
      DdiAigRedRemovalAcc (newaAig,care,1000,time_limit);
    }
    if (1&&(Ddi_BddSize(newaAig) > 1.00*Ddi_BddSize(a))) {
      fprintf(dMgrO(ddm),"INCREASED SIZE\n");
      Ddi_Free(newaAig);
      newaAig = Ddi_BddDup(a);
#if 0
      for (i=0; i<nVars; i++) {
	int tCnf = assumeTernary[i];
	if (tCnf >= 0) {
	  Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
	  Ddi_Bdd_t *f = Ddi_BddDup(newaAig);
          DdiAigExistVarOverAcc (f,v,care);
	  if (Ddi_BddSize(f)<Ddi_BddSize(newaAig)) {
	    Ddi_Free(newaAig);
	    newaAig=Ddi_BddDup(f);
	  }
	  else {
	    fprintf(dMgrO(ddm),"Aborted ternary abstr of %s\n", Ddi_VarName(v));
	  }
	  Ddi_Free(f);
        }
      }
#endif
    }
    Ddi_Free(zeroAig);
    Ddi_Free(Lits);
    Ddi_Free(LitsAux);
  }

  if (undefinedResult && strategy != 1) {
    ddiAbcOptAcc (newaAig,timeLimit);
  }
  if (newbAig != NULL) {
    prod = Ddi_BddAnd(newaAig,newbAig);
  }
  else {
    prod = Ddi_BddAnd(newaAig,b);
  }
  if (care != NULL) {
    Ddi_BddAndAcc(prod,care);
  }

  if (1&&undefinedResult) {
    if (strategy != 1 && !Ddi_AigSat(prod)) {
      fprintf(dMgrO(ddm),"validated UNDEFINED ternary interpolation\n");
    }
    else {
      Ddi_Free(newaAig);
      newaAig = Ddi_BddDup(a);
    }
  }
  else {
    Pdtutil_Assert(!checkFunction || !Ddi_AigSat(prod),
      "Wrong ternary interpolation\n");
  }

  fprintf(dMgrO(ddm),"size %d->%d\n", size0, Ddi_BddSize(newaAig));
  if (0&&newbAig!=NULL)
    fprintf(dMgrO(ddm),"\nTERNARY_ITP(B) conv. size %d->%d\n",
      size0b, Ddi_BddSize(newbAig));

  Ddi_Free(newbAig);

  /* free aig0 aig1 */


  Pdtutil_Free(piCnfIds);
  Pdtutil_Free(assumeTernary);
  Pdtutil_Free(redCodeBits);

  Ddi_Free(suppSm);
  Ddi_Free(suppAbstr);
  Ddi_Free(vA);
  Ddi_Free(vAsave);
  Ddi_Free(vSm);
  Ddi_Free(vAuxA);
  Ddi_Free(vAuxB);
  Ddi_Free(prod);
  Ddi_Free(myB);
  Ddi_Free(piNodes);

  Ddi_MgrCheckExtRef(ddm,extRef+1);

  return(newaAig);

}



/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistNnfAcc (
  Ddi_Bdd_t *a,
  Ddi_Varset_t *smooth,
  Ddi_Varset_t *project
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t  *bmgr;
  Ddi_Varset_t *supp;
  Ddi_Vararray_t *smoothA;
  Ddi_Bdd_t *aDup, *aDup2, *aNew;
  int i, j, nv, failCnt = 0;
  static int chkRes = 0;
  float growMax = 2.5;

  bmgr = ddm->aig.mgr;

  supp = Ddi_BddSupp(a);
  if (smooth != NULL) {
    if (Ddi_VarsetIsArray(smooth)) {
        Ddi_VarsetSetArray(supp);
    }
    Ddi_VarsetIntersectAcc(supp,smooth);
  }
  else {
    if (Ddi_VarsetIsArray(project)) {
        Ddi_VarsetSetArray(supp);
    }
    Ddi_VarsetDiffAcc(supp,project);
  }
  smoothA = Ddi_VararrayMakeFromVarset(supp,1);
  ddiAbcOptAcc (a,-1);

  aDup = Ddi_BddDup(a);
  aNew = NULL;

  nv = Ddi_VararrayNum(smoothA);
  Ddi_Vararray_t *sortedSm = Ddi_VararrayDup(smoothA);
  int *sizeMin = Pdtutil_Alloc(int, nv); 
  for (j=nv-1; j>=0; j--) {
    Ddi_Var_t *currSm = Ddi_VararrayRead(smoothA,j);
    Ddi_Bdd_t *cof0 = Ddi_BddCofactor(aDup,currSm,0);
    Ddi_Bdd_t *cof1 = Ddi_BddCofactor(aDup,currSm,1);
    sizeMin[j] = Ddi_BddSize(cof0);
    if (Ddi_BddSize(cof1) < sizeMin[j]) {
      sizeMin[j] = Ddi_BddSize(cof1);
    }
  }
  for (i=1; i<nv; i++) {
    Ddi_Var_t *tmp = Ddi_VararrayRead(sortedSm,i);
    int tmpSize = sizeMin[i];
    for (j=i-1; j>=0 && sizeMin[j]<tmpSize; j--) {
      sizeMin[j+1] = sizeMin[j];
      Ddi_VararrayWrite(sortedSm,j+1,Ddi_VararrayRead(sortedSm,j));
    }
    sizeMin[j+1] = tmpSize;
    Ddi_VararrayWrite(sortedSm,j+1,tmp);
  }
  Ddi_DataCopy(smoothA,sortedSm);
  Ddi_Free(sortedSm);
  Pdtutil_Free(sizeMin);

  for (j=Ddi_VararrayNum(smoothA)-1; j>=0; j--) {
    Ddi_Var_t *currSm = Ddi_VararrayRead(smoothA,j);
    int size2;
    Ddi_Bdd_t *aNnf;
    Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
    Ddi_Vararray_t *aV = Ddi_VararrayAlloc(ddm,0);
    
    aDup2 = Ddi_BddDup(aDup);
    aNnf = Ddi_AigNnf (aDup,NULL,constr,rV,aV,NULL);
    Ddi_BddSetAig(constr);

    Ddi_Free(aNew);

    for (i=0; i<Ddi_VararrayNum(rV); i++) {
      Ddi_Var_t *rV_i = Ddi_VararrayRead(rV,i);   
      Ddi_Var_t *aV_i = Ddi_VararrayRead(aV,i);   
      if (rV_i == currSm) {
	Ddi_Bddarray_t *substF = Ddi_BddarrayAlloc(ddm,0);
	Ddi_Vararray_t *substV = Ddi_VararrayAlloc(ddm,0);
	Ddi_Bdd_t *cof1 = Ddi_BddCofactor(aNnf,rV_i,1);
        Ddi_Bdd_t *cof0 = Ddi_BddCofactor(aNnf,aV_i,1);
	Ddi_Bdd_t *cof0b = Ddi_BddDup(cof0);
	Ddi_Bdd_t *cof1b = Ddi_BddDup(cof1);
	Ddi_Bdd_t *aNewb;
	//Ddi_Bdd_t *cof0 = Ddi_BddCofactor(aDup,rV_i,0);

	printf("quantifying: %s (%d|%d)\n", 
	       Ddi_VarName(rV_i), 
	       Ddi_BddSize(cof0),Ddi_BddSize(cof1));

	// full 0 cofactor
	Ddi_BddCofactorAcc(cof0,rV_i,0);
	// full 1 cofactor
	Ddi_BddCofactorAcc(cof1b,aV_i,0);
	Ddi_VararrayInsertLast(substV,aV_i);
	Ddi_BddarrayInsertLast(substF,cof0);

	Ddi_Free(aNew);
	aNew = Ddi_BddCompose(cof1,substV,substF);
	Ddi_VararrayWrite(substV,0,rV_i);
	Ddi_BddarrayWrite(substF,0,cof1b);
	aNewb = Ddi_BddCompose(cof0b,substV,substF);
	if (Ddi_BddSize(aNewb) < Ddi_BddSize(aNew)) {
	  Ddi_DataCopy(aNew,aNewb);
	}

	Ddi_Free(substV);
	Ddi_Free(substF);
	Ddi_Free(cof1);
	Ddi_Free(cof0);
	Ddi_Free(cof0b);
	Ddi_Free(cof1b);
	Ddi_Free(aNewb);

	Ddi_BddAigFromNnfAcc(aNew,rV);
	ddiAbcOptAcc (aNew,-1);
	//	Ddi_NnfClustSimplifyAcc(aNew,0);

	if (chkRes>=0) {
	  int eq;
	  Ddi_Bdd_t *cof1Ref = Ddi_BddCofactor(aDup2,rV_i,1);
	  Ddi_Bdd_t *cof0Ref = Ddi_BddCofactor(aDup2,rV_i,0);
	  Ddi_Free(aDup2);
	  aDup2 = Ddi_BddOr(cof1Ref,cof0Ref);
	  Ddi_Free(cof1Ref);
	  Ddi_Free(cof0Ref);
	  ddiAbcOptAcc (aDup2,-1);
	  if (Ddi_BddSize(aDup2) < Ddi_BddSize(aNew)) {
	    printf("using OR-based exist\n");

	    Ddi_Free(aNew);
	    aNew = Ddi_BddDup(aDup2);
	  }
	  eq = chkRes<1 || Ddi_BddEqualSat(aDup2,aNew);
	  Pdtutil_Assert(eq,"wrong nnf exist");
	}
	break;
      }

    }
    if (aNew!=NULL) {
      if (Ddi_BddSize(aNew) < Ddi_BddSize(aDup)*growMax) {
	Ddi_DataCopy(aDup,aNew);
      }
      else {
	failCnt++;
	if (failCnt>5) {
	  printf("QUITTING circuit based exist\n");
	  break;
	}
      }
    }
    Ddi_Free(aNew);
    Ddi_Free(aDup2);

  }    

  Ddi_DataCopy(a,aDup);
  Ddi_Free(aDup);
  return a;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
DdiAigarrayExistNnfAcc (
  Ddi_Bddarray_t *fA,
  Ddi_Varset_t *smooth,
  Ddi_Varset_t *project,
  Ddi_Vararray_t *ps,
  Ddi_Vararray_t *ns
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t  *bmgr;
  Ddi_Varset_t *supp;
  Ddi_Bddarray_t *fA2, *fAnnf;
  Ddi_Vararray_t *smoothA;
  int i, j, failCnt = 0;
  static int chkRes = 0;
  float growMax = 2.5;

  bmgr = ddm->aig.mgr;

  supp = Ddi_BddarraySupp(fA);
  if (smooth != NULL) {
    if (Ddi_VarsetIsArray(smooth)) {
        Ddi_VarsetSetArray(supp);
    }
    Ddi_VarsetIntersectAcc(supp,smooth);
  }
  else {
    if (Ddi_VarsetIsArray(project)) {
        Ddi_VarsetSetArray(supp);
    }
    Ddi_VarsetDiffAcc(supp,project);
  }
  smoothA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_AigarrayAbcOptAcc(fA,-1.0);

  if (0 && (ps!=NULL)) {
    int n = Ddi_BddarrayNum(fA);
    int ni = Ddi_VararrayNum(smoothA);
    Pdtutil_Assert(Ddi_VararrayNum(ps)==n,"wrong array num");
    Pdtutil_Assert(Ddi_VararrayNum(ns)==n,"wrong array num");
    int *piDep = Pdtutil_Alloc(int, n);
    int *piCnt = Pdtutil_Alloc(int, ni);
    Ddi_Bddarray_t *auxA = Ddi_BddarrayAlloc(ddm,n);
    for (i=0; i<ni; i++) {
      piCnt[i]=0;
    }
    for (i=0; i<n; i++) {
      Ddi_Vararray_t *piSupp;
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(fA,i);
      Ddi_Vararray_t *s = Ddi_BddSuppVararray(f_i);
      Ddi_Bddarray_t *sA = Ddi_BddarrayMakeLiterals(s, 1);
      Ddi_Bdd_t *myAnd = Ddi_BddMakeConst(ddm,1);

      for (j=0; j<Ddi_BddarrayNum(sA); j++) {
	Ddi_BddAndAcc(myAnd,Ddi_BddarrayRead(sA,j));
      }
      Ddi_BddarrayWrite(auxA,i,myAnd);

      Ddi_Free(myAnd);
      Ddi_Free(sA);
      Ddi_Free(s);
    }
    int again = 1;
    j=0;
    while (again) {
      Ddi_Bddarray_t *auxA2 = Ddi_BddarrayDup(auxA);
      Ddi_BddarrayComposeAcc(auxA2,ps,auxA);
      again = 0; j++;
      for (i=0; i<n; i++) {
	Ddi_Bdd_t *a_i = Ddi_BddarrayRead(auxA,i);
	Ddi_Bdd_t *a2_i = Ddi_BddarrayRead(auxA2,i);
	int n0, n1;
	Ddi_BddSetMono(a_i);
	Ddi_BddSetMono(a2_i);
	n0 = Ddi_BddSize(a_i);
	Ddi_BddAndAcc(a2_i,a_i);
	n1 = Ddi_BddSize(a2_i);
	if (n1>n0) {
	  again = 1;
	}
      }
      Ddi_Free(auxA);
      auxA = auxA2;
    }

    int cntNoPi = 0;
    Ddi_VararrayWriteMarkWithIndex (smoothA,1);
    Ddi_Varset_t *psVars = Ddi_VarsetMakeFromArray(ps);
    for (i=0; i<n; i++) {
      Ddi_Bdd_t *a_i = Ddi_BddarrayRead(auxA,i);
      Ddi_Vararray_t *s;
      Ddi_Varset_t *sv = Ddi_BddSupp(a_i);
      Ddi_VarsetDiffAcc(sv,psVars);
      s = Ddi_VararrayMakeFromVarset(sv,1);
      Ddi_Free(sv);
      if (Ddi_VararrayNum(s) == 0) {
	cntNoPi++;
      }
      else {
	for (j=0; j<Ddi_VararrayNum(s); j++) {
	  Ddi_Var_t *pi_j = Ddi_VararrayRead(s,j);
	  int index = Ddi_VarReadMark(pi_j)-1;
	  Pdtutil_Assert(index>=0&&index<ni,"wrong index");
	  piCnt[index]++;
	}
      }
    }
    printf("%d array components have no PI dependence\n",
	   cntNoPi);
    for (i=0; i<ni; i++) {
      printf("pi: %s - dep: %d\n", 
	     Ddi_VarName(Ddi_VararrayRead(smoothA,i)), 
	     piCnt[i]);
    }

    Ddi_VararrayWriteMark (smoothA,0);
    Ddi_Free(psVars);
    Ddi_Free(auxA);
    Pdtutil_Free(piDep);
    Pdtutil_Free(piCnt);
  }


  Ddi_Vararray_t *aV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);

  fAnnf = Ddi_AigarrayNnf (fA,smoothA,0,NULL,rV,aV,NULL);

  Pdtutil_Assert(Ddi_AigarrayNnfCheck (fAnnf,NULL),
		 "wrong nnf");

  Ddi_Vararray_t *aV2 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *rV2 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *substV = Ddi_VararrayAlloc(ddm,0);

  fA2 = Ddi_AigarrayNnf (fA,ps,0,NULL,rV2,aV2,NULL);
  for (i=0; i<Ddi_VararrayNum(rV2); i++) {
    Ddi_VararrayInsertLast(substV,Ddi_VararrayRead(rV2,i));
    Ddi_VararrayInsertLast(substV,Ddi_VararrayRead(aV2,i));
  }

  Ddi_BddarrayVararrayCofactorAcc(fAnnf, rV, 1);
  Ddi_BddarrayVararrayCofactorAcc(fAnnf, aV, 1);
  Ddi_BddarrayComposeAcc(fA2,substV,fAnnf);

  Ddi_AigarrayNnfCheck (fA2,fA);

  Ddi_Free(fA2);
  Ddi_Free(aV2);
  Ddi_Free(rV2);
  Ddi_Free(aV);
  Ddi_Free(rV);

  return fA;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistMonotoneAcc (
  Ddi_Bdd_t *a,
  Ddi_Varset_t *smooth,
  Ddi_Varset_t *project,
  Ddi_Bdd_t *care,
  int genMonotoneCube
)
{
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newaAig, *newbAig, *cof0Aig, *cof1Aig, *notaAig;
  bAig_array_t *visitedNodes;
  Ddi_Bddarray_t *vLits, *vAuxLits;
  bAigEdge_t varIndex, auxVarIndex, aBaig, bBaig, careBaig, cof0, cof1, f0, f1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int extRef = Ddi_MgrReadExtRef(ddm);
  int i, j, sat, nVars;
  Ddi_Vararray_t *vA, *vAuxA;
  Ddi_Bdd_t *prod;
  int assumeSingleExist, *assumeExist;
  int *redCodeBits=NULL;
  int redCodeSize, refinementDone, nCurrVars;
  int checkSingleExist;
  int checkFunction = 1;
  int doTernaryB = 0;
  Ddi_Bdd_t *myB=NULL;
  int size0 = Ddi_BddSize(a);
  int checkMonotonicity = 0;
  int myDbg = 0;
  int chkRes = 0;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  Ddi_Vararray_t *piNodes;
  Ddi_Varset_t *piSet;
  int nPi, *piCnfIds=NULL;
  int nCached = 0;
  Ddi_Bdd_t *monotoneCube=NULL;

  Solver    S;
  vec<Lit> lits, assumeSingleExistArray, assumeNoExistArray;
  vec<Lit> prevCex;
  int prevCexUsed = 0;

  Ddi_Varset_t *supp;

  bmgr = ddm->aig.mgr;
  aBaig = Ddi_BddToBaig(a);
  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }

  supp = Ddi_BddSupp(a);
  if (smooth != NULL) {
    if (Ddi_VarsetIsArray(smooth)) {
        Ddi_VarsetSetArray(supp);
    }
    piSet = Ddi_VarsetDiff(supp,smooth);
    Ddi_VarsetIntersectAcc(supp,smooth);
  }
  else {
    if (Ddi_VarsetIsArray(project)) {
        Ddi_VarsetSetArray(supp);
    }
    piSet = Ddi_VarsetIntersect(supp,project);
    Ddi_VarsetDiffAcc(supp,project);
  }

  if (genMonotoneCube) {
    monotoneCube = Ddi_BddMakeConstAig(ddm,1);
  }

  piNodes = Ddi_VararrayMakeFromVarset(piSet,1);
  Ddi_Free(piSet);
  vA = Ddi_VararrayMakeFromVarset(supp,1);
  vAuxA = Ddi_VararrayAlloc(ddm,Ddi_VararrayNum(vA));
  Ddi_Free(supp);

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    char name[100];
    Ddi_Var_t *vAux;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    sprintf(name,"PDTRAV_TERNARY_ITP_DUMMY_VAR_%d",i);
    if ((vAux = Ddi_VarFromName(ddm,name))==NULL) {
      vAux = Ddi_VarNew(ddm);
      Ddi_VarAttachName (vAux, name);
    }
    Ddi_VararrayWrite(vAuxA,i,vAux);
  }

  newaAig = Ddi_BddDup(a);
  vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
  vAuxLits = Ddi_BddarrayMakeLiteralsAig(vAuxA, 1);
  newbAig = Ddi_BddCompose(newaAig,vA,vAuxLits);

  nVars = Ddi_VararrayNum(vA);
  nCurrVars = 2*nVars;

  if (nVars == 0) {
    Ddi_Free(vA);
    Ddi_Free(vAuxA);
    Ddi_Free(newaAig);
    Ddi_Free(newbAig);
    Ddi_Free(vLits);
    Ddi_Free(vAuxLits);
    Ddi_Free(piNodes);
    return(NULL);
  }

  Ddi_BddDiffAcc(newbAig,newaAig);
  if (care != NULL) {
    Ddi_BddAndAcc(newbAig,care);
  }

  /* load clauses to SAT manager */
  aig2CnfIdInit(ddm);

  MinisatClauses(S,newbAig,NULL,NULL,0);
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    MinisatClauses(S,Ddi_BddarrayRead(vLits,i),NULL,NULL,1);
    MinisatClauses(S,Ddi_BddarrayRead(vAuxLits,i),NULL,NULL,1);
  }

  S.newVar();
  assumeSingleExist = S.nVars();
  assumeSingleExistArray.clear();
  assumeSingleExistArray.push(MinisatLit(assumeSingleExist));
  assumeNoExistArray.clear();

  if (myDbg)
    fprintf(dMgrO(ddm),"ASE: %d\n", assumeSingleExist);

  assumeExist = Pdtutil_Alloc(int, 2*nVars);

  redCodeSize=1;
  for (j=1; j<2*nVars; j = j<<1) {
    redCodeSize++;
  }
  redCodeBits = Pdtutil_Alloc(int, redCodeSize);
  for (j=0; j<redCodeSize; j++) {
    S.newVar();
    redCodeBits[j] = S.nVars();
  }

  for (i=0; i<nVars; i++) {
    int k, mask, vCnf, vAuxCnf, tCnf0, tCnf1;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Var_t *vAux = Ddi_VararrayRead(vAuxA,i);
    int i0 = 2*i;
    int i1 = 2*i+1;
    varIndex = Ddi_VarToBaig(v);
    auxVarIndex = Ddi_VarToBaig(vAux);

    vCnf = aig2CnfId(bmgr,varIndex);
    vAuxCnf = aig2CnfId(bmgr,auxVarIndex);

    S.newVar();
    tCnf0 = assumeExist[i0] = S.nVars();
    S.newVar();
    tCnf1 = assumeExist[i1] = S.nVars();

    if (myDbg)
      fprintf(dMgrO(ddm),"I:%d - v:%d, v0:%d, t0:%d, t1:%d\n",
        i, vCnf, vAuxCnf, tCnf0, tCnf1);

    assumeNoExistArray.push(MinisatLit(-tCnf0));
    assumeNoExistArray.push(MinisatLit(-tCnf1));

    /* tCnf0 => exist encoding (vCnf && !vAuxCnf) */
    MinisatClause2(S,lits,-tCnf0,vCnf);
    MinisatClause2(S,lits,-tCnf0,-vAuxCnf);
    /* tCnf1 => exist encoding (!vCnf && vAuxCnf) */
    MinisatClause2(S,lits,-tCnf1,-vCnf);
    MinisatClause2(S,lits,-tCnf1,vAuxCnf);

    /* !tCnf0 => !vCnf + vAuxCnf */
    MinisatClause3(S,lits,tCnf0,-vCnf,vAuxCnf);
    /* !tCnf1 => vCnf + !vAuxCnf */
    MinisatClause3(S,lits,tCnf1,vCnf,-vAuxCnf);

    for (k=0, mask=1; k<redCodeSize; k++) {
      int bit = (i0&mask) ? redCodeBits[k] : -redCodeBits[k];
      /* tCnf0 => !assumeSingleExist + bit */
      MinisatClause3(S,lits,-tCnf0,-assumeSingleExist,bit);
      bit = (i1&mask) ? redCodeBits[k] : -redCodeBits[k];
      /* tCnf1 => !assumeSingleExist + bit */
      MinisatClause3(S,lits,-tCnf1,-assumeSingleExist,bit);
      mask = mask<<1;
    }

  }

  checkSingleExist = 1;

  prevCexUsed = 0;
  prevCex.clear();
  assumeSingleExistArray.copyTo(prevCex);

  if (myDbg)
    Pdtutil_Assert(!S.solve(assumeNoExistArray),"UNSAT check required");

  nPi = Ddi_VararrayNum(piNodes);
  piCnfIds = Pdtutil_Alloc(int,nPi);

  for (i=0; i<nPi; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(piNodes,i);
    bAigEdge_t baig = Ddi_VarToBaig(v);
    piCnfIds[i] = aig2CnfId(bmgr,baig);
  }

  do {
    int id;
    refinementDone = 0;

    /* call SAT solver assuming at least one refinement */
    if ((sat = S.okay())) {
      if (checkSingleExist) {
	sat = S.solve(prevCex); /* timeout */
      }
      else {
	sat = S.solve();
      }
    }

    if (sat) {
      /* a non redundant ternary node has been found: fix it and iterate */
      int k, mask, redIndex=0;
      Lit wireLit;
      int t, tCnf;

      Pdtutil_Assert(checkSingleExist,"wrong setting");

      if (checkSingleExist) {
        for (k=0, mask=1; k<redCodeSize; k++) {
	  if (S.model[redCodeBits[k]-1]==l_True) {
	    redIndex += mask;
	  }
          mask = mask<<1;
        }
        refinementDone = 1;

        i=redIndex;
	tCnf = assumeExist[i];
        Pdtutil_Assert(tCnf > 0,"enabled exist control required");

	t = tCnf - 1;

        Pdtutil_Assert(S.model[t]==l_True,"missing exist control set");

        MinisatClause1(S,lits,-tCnf);
	assumeExist[i] = -1; /* disable it !!! */
	nCurrVars--;
      }

      if (!prevCexUsed) {
	prevCexUsed = 1;

	for (k=0; k<nPi; k++) {
	  int piCnf = piCnfIds[k];
	  int pi = piCnf-1;
          if (S.model[pi]==l_False) {
	    piCnf = -piCnf;
	  }
	  prevCex.push(MinisatLit(piCnf));
	}
      }
      else {
	nCached++;
      }
    }
    else if (prevCexUsed) {
      refinementDone = 1;
      prevCexUsed = 0;
      prevCex.clear();
      assumeSingleExistArray.copyTo(prevCex);
    }
    else if (chkRes) {
        /* no refinement possible with SAT */
	sat = S.solve();
	Pdtutil_Assert(!sat,"wrong multiple exist");
    }

  } while (refinementDone);

  aig2CnfIdClose(ddm);
  nCurrVars = nVars;
  {
    Ddi_Bdd_t *zeroAig = Ddi_BddMakeConstAig(ddm,0);
    Ddi_Bdd_t *oneAig = Ddi_BddMakeConstAig(ddm,1);

    for (i=0; i<nVars; i++) {
      int tCnf;
      Ddi_Bdd_t *chkCof0, *chkCof1;
      Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
      //      Pdtutil_Assert(assumeExist[2*i]<0 || assumeExist[2*i+1]<0,
      //  "wrong assume exit");
      if (myDbg && (assumeExist[2*i] >= 0 || assumeExist[2*i] >= 0)) {
	chkCof0 = Ddi_BddCofactor(a,v,0);
	chkCof1 = Ddi_BddCofactor(a,v,1);
      }
      if ((tCnf = assumeExist[2*i]) >= 0) {
        if (genMonotoneCube) {
          Ddi_BddAndAcc(monotoneCube,Ddi_BddarrayRead(vLits,i));
        }
	Ddi_BddarrayWrite(vLits,i,oneAig);
	nCurrVars--;
        if (myDbg) {
  	  Ddi_BddDiffAcc(chkCof0,chkCof1);
          if (care != NULL) {
            Ddi_BddAndAcc(chkCof0,care);
	  }
	  Pdtutil_Assert(!Ddi_AigSat(chkCof0),"wrong cofactor selection");
	  Ddi_Free(chkCof0); Ddi_Free(chkCof1);
	}
      }
      else if ((tCnf = assumeExist[2*i+1]) >= 0) {
        if (genMonotoneCube) {
          Ddi_BddDiffAcc(monotoneCube,Ddi_BddarrayRead(vLits,i));
        }
	Ddi_BddarrayWrite(vLits,i,zeroAig);
	nCurrVars--;
        if (myDbg) {
  	  Ddi_BddDiffAcc(chkCof1,chkCof0);
          if (care != NULL) {
            Ddi_BddAndAcc(chkCof1,care);
  	  }
	  Pdtutil_Assert(!Ddi_AigSat(chkCof1),"wrong cofactor selection");
	  Ddi_Free(chkCof0); Ddi_Free(chkCof1);
	}
      }
    }
    Ddi_BddComposeAcc(newaAig,vA,vLits);
    Ddi_Free(zeroAig);
    Ddi_Free(oneAig);
  }

  if (chkRes)
  {
    Ddi_Bdd_t *chk = Ddi_BddDiff(a,newaAig);
    if (care != NULL) {
      Ddi_BddAndAcc(chk,care);
    }
    Pdtutil_Assert(!Ddi_AigSat(chk),"wrong monotone exist result");
    Ddi_Free(chk);
  }

  if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),"\nMONOTONE_EXIST conv. with %d/%d red candidates (size %d->%d)\n",
	  nVars-nCurrVars, nVars, size0, Ddi_BddSize(newaAig));
  }

  DdiGenericDataCopy((Ddi_Generic_t *)a,(Ddi_Generic_t *)newaAig);
  Ddi_Free(newaAig);
  Ddi_Free(newbAig);

  Pdtutil_Free(assumeExist);
  Pdtutil_Free(redCodeBits);
  Pdtutil_Free(piCnfIds);
  Ddi_Free(vA);
  Ddi_Free(vAuxA);
  Ddi_Free(vLits);
  Ddi_Free(vAuxLits);
  Ddi_Free(piNodes);

  if (genMonotoneCube && nCurrVars < nVars) {
    extRef++;
  }
  if (chkRes) {
    Ddi_MgrCheckExtRef(ddm,extRef+1);
  }
  if (nCurrVars < nVars) {
    if (genMonotoneCube) {
      return(monotoneCube);
    }
    return(a);
  }
  else {
    Ddi_Free(monotoneCube);
    return(NULL);
  }
}



/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigFuncDepAcc (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *refVars,
  Ddi_Varset_t *filterVars,
  Ddi_Bdd_t *auxEqMerge,
  Ddi_Bdd_t *eqConstr,
  Ddi_Vararray_t *eqVars,
  Ddi_Bddarray_t *substLits,
  int *nEqTotP
)
{
  Ddi_Varset_t *chkVars, *supp;
  Ddi_Bdd_t *aPart, *eqAig, *cof0Aig, *cof1Aig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int i, np, again0, again1, nEqRef = 0, nEqTot = 0, freeEqVars = 0,
      size0 = Ddi_BddSize(a);
    Ddi_Bddarray_t *newSubstLits;
  Ddi_Vararray_t *newEqVars;
  bAig_Manager_t *bmgr = ddm->aig.mgr;

  int enMerge = 1;

  supp = Ddi_BddSupp(a);

  if (eqVars == NULL) {
    eqVars = Ddi_VararrayAlloc(ddm,0);
    substLits = Ddi_BddarrayAlloc(ddm,0);
    freeEqVars = 1;
  }

  /* filterVars are equivalence candidates */
  if (filterVars != NULL) {
    Ddi_VarsetIntersectAcc(supp,filterVars);
  }

  /* refVars are not considered for equivalence */
  if (refVars != NULL) {
    chkVars = Ddi_VarsetDiff(supp,refVars);
    Ddi_VarsetIntersectAcc(supp,refVars);
  }
  else {
    chkVars = Ddi_VarsetDup(supp);
  }

  aPart = Ddi_AigPartitionTop(a,0);
  np = Ddi_BddPartNum(aPart);

  if (np<500)
  do {

    Ddi_Bdd_t *newEqConstr = Ddi_BddMakeConstAig(ddm, 1);

    again0 = again1 = 0;

    newEqVars = Ddi_VararrayAlloc(ddm,0);
    newSubstLits = Ddi_BddarrayAlloc(ddm,0);

    /* temporarily disabled ! */
    for (i=Ddi_BddPartNum(aPart)-1; enMerge && i>=0; i--) {
      int j, l, ni, nj;
      Ddi_Bdd_t *p_i = Ddi_BddPartRead(aPart,i);
      Ddi_Varset_t *si = Ddi_BddSupp(p_i);
      int sizePi = Ddi_BddSize(p_i);
      Ddi_VarsetSetArray(si);
      ni = Ddi_VarsetNum(si);
      for (j=i-1; j>=0; j--) {
        Ddi_Bdd_t *p_j = Ddi_BddPartRead(aPart,j);
        Ddi_Varset_t *sj = Ddi_BddSupp(p_j);
	nj = Ddi_VarsetNum(sj);
	if (nj!=ni) {
	  Ddi_Free(sj); continue;
	}
	Ddi_VarsetSetArray(sj);
        Ddi_VarsetDiffAcc(sj,si);
        if (Ddi_VarsetIsVoid(sj)) {
      	  Ddi_BddAndAcc(p_j,p_i);
    	  Ddi_BddPartRemove(aPart,i);
    	  Ddi_Free(sj);
    	  break;
        }
	else if (Ddi_BddSize(p_j)==sizePi) {
	  /* check sharing */
	  bAigEdge_t aBaig = Ddi_BddToBaig(p_i);
	  bAigEdge_t bBaig = Ddi_BddToBaig(p_j);
	  bAigEdge_t newBaigA, newBaigB;
	  Ddi_Bdd_t *newFa, *newFb;
          bAig_array_t *visitedNodes = bAigArrayAlloc();
	  int nA, nB, ii, nCut;
	  int *cut;
	  Ddi_Bddarray_t *cutFSubst = Ddi_BddarrayAlloc(ddm,0);
	  Ddi_Vararray_t *cutFVars = Ddi_VararrayAlloc(ddm,0);

	  postOrderAigVisitIntern(bmgr,aBaig,visitedNodes,-1);
	  nA = visitedNodes->num;
	  postOrderAigVisitIntern(bmgr,bBaig,visitedNodes,-1);
	  nB = visitedNodes->num;

	  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
	  aigArrayClearAuxAigIntern(bmgr,visitedNodes);
	  cut = Pdtutil_Alloc(int,nB);

	  for (ii=nCut=0; ii<visitedNodes->num; ii++) {
	    bAigEdge_t baig = visitedNodes->nodes[ii];
	    bAig_AuxInt(bmgr,baig) = ii;
	    cut[ii] = 0;
	    if (ii>=nA &&
                !bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
	      int ir = rightChildAuxInt(bmgr,baig);
	      int il = leftChildAuxInt(bmgr,baig);
	      if (ir < nA) cut[ir] = 1;
	      if (il < nA) cut[il] = 1;
	    }
	  }

	  for (ii=0; ii<visitedNodes->num; ii++) {
	    bAigEdge_t baig1,baig = visitedNodes->nodes[ii];
	    baig = bAig_NonInvertedEdge(baig);

	    if (bAig_NodeIsConstant(baig)) {
	      continue;
	    }
	    else if (bAig_isVarNode(bmgr,baig)/* || ii<nA && !cut[ii]*/) {
	      baig1 = bAig_NonInvertedEdge(baig);
	    }
	    else if (cut[ii]>0) {

	      char name[100];
	      Ddi_Bdd_t *f = Ddi_BddMakeFromBaig(ddm,baig);
	      Ddi_Var_t *aV;
	      sprintf(name,"_CUT_AUXV_%d", Ddi_VararrayNum(cutFVars));
	      aV = Ddi_VarFromName(ddm,name);
	      if (aV == NULL) {
		aV = Ddi_VarNew(ddm);
		Ddi_VarAttachName (aV, name);
	      }

	      Ddi_VararrayInsertLast(cutFVars,aV);
	      Ddi_BddarrayInsertLast(cutFSubst,f);
	      Ddi_Free(f);

	      baig1 = Ddi_VarToBaig(aV);
	    }
	    else {
	      /* compute baig1 */
	      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
	      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
	      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
		bAig_AuxAig1(bmgr,r);
	      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
		bAig_AuxAig1(bmgr,l);
	      baig1 = bAig_And(bmgr,right,left);
	    }

	    bAig_Ref(bmgr, baig1);
	    bAig_AuxAig1(bmgr,baig) = baig1;
	  }


          newBaigA = bAig_NodeIsInverted(aBaig) ?
               bAig_Not(bAig_AuxAig1(bmgr,aBaig)) :
               bAig_AuxAig1(bmgr,aBaig);
          newBaigB = bAig_NodeIsInverted(bBaig) ?
               bAig_Not(bAig_AuxAig1(bmgr,bBaig)) :
               bAig_AuxAig1(bmgr,bBaig);
	  newFa = Ddi_BddMakeFromBaig(ddm,newBaigA);
	  newFb = Ddi_BddMakeFromBaig(ddm,newBaigB);

	  for (ii=0; ii<visitedNodes->num; ii++) {
	    bAigEdge_t baig1;
	    bAigEdge_t baig = visitedNodes->nodes[ii];

	    baig1 = bAig_AuxAig1(bmgr,baig);
	    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
	      bAig_RecursiveDeref(bmgr,baig1);
	    }
	    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
	    bAig_AuxInt(bmgr,baig) = -1;
	  }

	  Ddi_Free(newFa);
	  Ddi_Free(newFb);
	  Pdtutil_Free(cut);
	  Ddi_Free(cutFSubst);
	  Ddi_Free(cutFVars);

	  bAigArrayFree(visitedNodes);
	}
        Ddi_Free(sj);
      }
      Ddi_Free(si);
    }

    Ddi_VarsetSetArray(chkVars);
    for (i=Ddi_BddPartNum(aPart)-1; 1 && i>=0; i--) {
      int j, l;
      Ddi_Bdd_t *p = Ddi_BddPartRead(aPart,i);
      Ddi_Varset_t *si = Ddi_BddSupp(p);
      Ddi_Vararray_t *siA = NULL;
      int nextPart = 0;
      int implFound = 0;
      Ddi_VarsetSetArray(si);
      Ddi_VarsetIntersectAcc(si,chkVars);
      siA = Ddi_VararrayMakeFromVarset(si,1);

      for (j=0; !nextPart && j<Ddi_VararrayNum(siA); j++) {
        Ddi_Var_t *v = Ddi_VararrayRead(siA,j);

	Ddi_Bdd_t *residualP = NULL;
	Ddi_Bdd_t *cof0 = Ddi_BddCofactor(p,v,0);
	Ddi_Bdd_t *cof1 = Ddi_BddCofactor(p,v,1);
	if (!Ddi_AigSatAnd(cof0,cof1,NULL)) {
	  Ddi_Bdd_t *cof01 = Ddi_BddOr(cof0,cof1);
	  Ddi_BddNotAcc(cof01);
	  if (Ddi_AigSat(cof01)) {
	    int jj;
	    Ddi_Bdd_t *pp = Ddi_AigPartitionTop(p,0);
	    for (jj=Ddi_BddPartNum(pp)-1; jj>=0; jj--) {
	      Ddi_Bdd_t *pp_jj = Ddi_BddPartRead(pp,jj);
	      Ddi_Varset_t *s_jj = Ddi_BddSupp(pp_jj);
	      if (!Ddi_VarInVarset(s_jj,v)) {
		if (residualP == NULL) {
		  residualP = Ddi_BddMakeConstAig(ddm,1);
		}
		Ddi_BddAndAcc(residualP,pp_jj);
		Ddi_BddPartRemove(pp,jj);
	      }
	      Ddi_Free(s_jj);
	    }
	    if (residualP != NULL) {
	      //	      fprintf(dMgrO(ddm),"potential composition Uncovered for %s\n",
	      //     Ddi_VarName(v));
	      Ddi_BddSetAig(pp);
	      Ddi_Free(cof0);
	      Ddi_Free(cof1);
	      Ddi_Free(cof01);
	      cof0 = Ddi_BddCofactor(pp,v,0);
	      cof1 = Ddi_BddCofactor(pp,v,1);
	      cof01 = Ddi_BddOr(cof0,cof1);
	      Ddi_BddNotAcc(cof01);
	    }
	    else {
	      //printf("potential composition Hidden\n");
	    }
	    Ddi_Free(pp);
	  }
	  if (!Ddi_AigSat(cof01)) {
	    Ddi_Bddarray_t *subst = Ddi_BddarrayAlloc(ddm,0);
	    Ddi_Vararray_t *vars = Ddi_VararrayAlloc(ddm,0);
	    /* v=f found */
	    // fprintf(dMgrO(ddm),"composition found for %s !\n", Ddi_VarName(v));
	    again1 = 1;
	    Ddi_BddarrayInsertLast(subst,cof1);
	    Ddi_VararrayInsertLast(vars,v);
	    Ddi_BddarrayInsertLast(newSubstLits,cof1);
	    Ddi_VararrayInsertLast(newEqVars,v);
	    if (eqConstr != NULL) {
	      Ddi_Bdd_t *myEqConstr = Ddi_BddMakeLiteralAig(v,1);
	      Ddi_BddXnorAcc(myEqConstr,cof1);
	      Ddi_BddAndAcc(eqConstr,myEqConstr);
	      Ddi_Free(myEqConstr);
	    }
	    if (residualP != NULL) {
	      Ddi_BddPartWrite(aPart,i,residualP);
	    }
	    else {
	      Ddi_BddPartRemove(aPart,i);
	    }
	    Ddi_BddComposeAcc(aPart,vars,subst);
	    np--;
	    //	    Ddi_BddComposeAcc(a,newEqVars,subst);

	    Ddi_Free(subst);
	    Ddi_Free(vars);
	    Ddi_Free(cof0);
	    Ddi_Free(cof1);
	    Ddi_Free(residualP);
	    Ddi_Free(cof01);
	    nextPart = 1;
	    break;
	  }
	  Ddi_Free(cof01);
	  Ddi_Free(residualP);
	}

	Ddi_Free(cof0);
	Ddi_Free(cof1);
      }
      Ddi_Free(si);
      Ddi_Free(siA);
    }

    if (again1) {
      int j;
      for (j=0; j<Ddi_VararrayNum(newEqVars); j++) {
        int k;
        for (k=Ddi_VararrayNum(newEqVars)-1; k>j; k--) {
	  if (Ddi_VararrayRead(newEqVars,j)==Ddi_VararrayRead(newEqVars,k)) {
	    Ddi_Bdd_t *myEqConstr =
              Ddi_BddMakeLiteralAig(Ddi_VararrayRead(newEqVars,k),1);
	    Ddi_BddXnorAcc(myEqConstr,Ddi_BddarrayRead(newSubstLits,k));
	    Ddi_BddPartInsertLast(aPart,myEqConstr);
	    Ddi_Free(myEqConstr);
	    Ddi_VararrayRemove(newEqVars,k);
	    Ddi_BddarrayRemove(newSubstLits,k);
	    fprintf(dMgrO(ddm),"equal vars\n");
	  }
        }
      }
      Ddi_BddComposeAcc(aPart,newEqVars,newSubstLits);
      Ddi_AigarrayComposeAcc(substLits,newEqVars,newSubstLits);

      Ddi_BddarrayAppend(substLits,newSubstLits);
      Ddi_VararrayAppend(eqVars,newEqVars);
      if (auxEqMerge != NULL) {
        Ddi_BddComposeAcc(auxEqMerge,newEqVars,newSubstLits);
      }
      Ddi_Free(newEqVars); Ddi_Free(newSubstLits);
    }
    else {
      Ddi_Free(newEqVars);
      Ddi_Free(newSubstLits);
    }

    Ddi_Free(newEqConstr);

  } while (again1);

  nEqTot = Ddi_VararrayNum(eqVars);
  if (nEqTotP != NULL) {
    *nEqTotP = nEqTot;
  }

  Ddi_BddSetAig(aPart);

  if (Ddi_VararrayNum(eqVars) > 0) {
    fprintf(dMgrO(ddm),"(func dep: %d (#eq: %d - #eqRef: %d)",
	   size0, Ddi_VararrayNum(eqVars), nEqRef);fflush(dMgrO(ddm));
    fprintf(dMgrO(ddm)," -> %d)\n", Ddi_BddSize(aPart));
  }

  if (freeEqVars) {
    Ddi_Free(eqVars);
    Ddi_Free(substLits);
  }

  Ddi_Free(chkVars);
  Ddi_Free(supp);

  return aPart;

}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigEquivVarsSimpleAcc (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *refVars,
  Ddi_Varset_t *filterVars,
  Ddi_Bdd_t *auxEqMerge,
  Ddi_Vararray_t *eqVars,
  Ddi_Bddarray_t *substLits,
  int *nEqTotP
)
{
  Ddi_Varset_t *chkVars, *supp;
  Ddi_Bdd_t *aPart, *eqAig, *cof0Aig, *cof1Aig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int i, np, again0, again1, nEqRef = 0, nEqTot = 0, freeEqVars = 0,
      size0 = Ddi_BddSize(a);
  Ddi_Bdd_t *eqConstr = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bddarray_t *newSubstLits;
  Ddi_Vararray_t *newEqVars;

  supp = Ddi_BddSupp(a);

  if (eqVars == NULL) {
    eqVars = Ddi_VararrayAlloc(ddm,0);
    substLits = Ddi_BddarrayAlloc(ddm,0);
    freeEqVars = 1;
  }

  if (filterVars != NULL) {
    Ddi_VarsetIntersectAcc(supp,filterVars);
  }
  if (refVars != NULL) {
    Ddi_Vararray_t *other;
    chkVars = Ddi_VarsetDiff(supp,refVars);
    Ddi_VarsetIntersectAcc(supp,refVars);
  }
  else {
    chkVars = Ddi_VarsetDup(supp);
  }

  do {

  Ddi_Bdd_t *newEqConstr = Ddi_BddMakeConstAig(ddm, 1);
  again0 = again1 = 0;
  aPart = Ddi_AigPartitionTop(a,0);
  np = Ddi_BddPartNum(aPart);
  newEqVars = Ddi_VararrayAlloc(ddm,0);
  newSubstLits = Ddi_BddarrayAlloc(ddm,0);

  for (i=Ddi_BddPartNum(aPart)-1; 1 && i>=0; i--) {
    Ddi_Bdd_t *p1 = Ddi_BddPartRead(aPart,i);
    Ddi_Varset_t *s1 = Ddi_BddSupp(p1);
    if (Ddi_VarsetNum(s1) == 1) {
#if 0
      Ddi_VarsetIntersectAcc(s1,chkVars);
      if (Ddi_VarsetNum(s1) == 1) {
	Ddi_Var_t *v = Ddi_VarsetTop (s1);
        Ddi_Bdd_t *substLit = Ddi_BddMakeConstAig(ddm,!Ddi_BddIsComplement(p1));
	//	printf("IMPL found: %s\n", Ddi_VarName(v));
        Pdtutil_Assert(substLits!=NULL,"NULL substLits array");
        Ddi_VararrayInsertLast(newEqVars,v);
	Ddi_BddarrayInsertLast(newSubstLits,substLit);
	Ddi_VarsetIntersectAcc(s1,chkVars);
        if (Ddi_VarsetNum(s1) == 0) {
	  Ddi_BddAndAcc(newEqConstr,p1);
	  Ddi_VarsetRemoveAcc(supp,v);
	  nEqRef++;
	}
	else {
	  //	  Ddi_BddAndAcc(newEqConstr,p1);
	  Ddi_VarsetRemoveAcc(chkVars,v);
	  //	  nEqRef++;
	}
	Ddi_Free(substLit);
	again0 = 1;
      }
#endif
    }
    Ddi_Free(s1);
  }

  if (again0) {
    Ddi_BddComposeAcc(a,newEqVars,newSubstLits);
    //    NO ! Constrain must be complete !
    //    Ddi_BddComposeAcc(eqConstr,newEqVars,newSubstLits);
    Ddi_BddarrayAppend(substLits,newSubstLits);
    Ddi_VararrayAppend(eqVars,newEqVars);
    Ddi_BddAndAcc(eqConstr,newEqConstr);
    if (auxEqMerge != NULL) {
      Ddi_BddComposeAcc(auxEqMerge,newEqVars,newSubstLits);
    }
    Ddi_Free(newEqVars); Ddi_Free(newSubstLits);
    newEqVars = Ddi_VararrayAlloc(ddm,0);
    newSubstLits = Ddi_BddarrayAlloc(ddm,0);
  }

  for (i=Ddi_BddPartNum(aPart)-1; i>=0; i--) {
    Ddi_Bdd_t *p1 = Ddi_BddPartRead(aPart,i);
    Ddi_Varset_t *s1 = Ddi_BddSupp(p1);
    if (i>0) {
      Ddi_Bdd_t *p0 = Ddi_BddPartRead(aPart,i-1);
      Ddi_Varset_t *s0 = Ddi_BddSupp(p0);
      if (Ddi_VarsetNum(s1) == 2 && Ddi_VarsetNum(s0) == 2) {
        Ddi_VarsetIntersectAcc(s0, s1);
        if (Ddi_VarsetNum(s0) == 2) {
  	  Ddi_BddAndAcc(p0,p1);
	  Ddi_BddPartRemove(aPart,i);
	  i--; p1 = p0;
        }
      }
      Ddi_Free(s0);
    }
    if (Ddi_VarsetNum(s1) == 1) {
    }
    else if (Ddi_VarsetNum(s1) == 2) {
      Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(s1,1);
      Ddi_Var_t *v0 = Ddi_VararrayRead(vA,0);
      Ddi_Var_t *v1 = Ddi_VararrayRead(vA,1);
      Ddi_Bdd_t *c0 = Ddi_BddCofactor(p1,v0,0);
      Ddi_Bdd_t *c1 = Ddi_BddCofactor(p1,v0,1);
      Ddi_Var_t *substV=NULL, *eqV=NULL;
      Ddi_BddNotAcc(c1);
      if (Ddi_BddEqual(c0,c1)) {
	int comp = !Ddi_BddIsComplement(c0);
	Ddi_Bdd_t *eqF = NULL;
	// fprintf(dMgrO(ddm),"equiv found: %s - %s\n", Ddi_VarName(v0), Ddi_VarName(v1));
	if (Ddi_VarInVarset(supp,v0) && Ddi_VarInVarset(chkVars,v1)) {
	  substV = v0; eqV = v1;
	  Ddi_VarsetRemoveAcc(supp,v0);
	  Ddi_VarsetRemoveAcc(chkVars,v1);
	}
	else if (Ddi_VarInVarset(supp,v1) && Ddi_VarInVarset(chkVars,v0)) {
	  substV = v1; eqV = v0;
	  Ddi_VarsetRemoveAcc(supp,v1);
	  Ddi_VarsetRemoveAcc(chkVars,v0);
	}
	else if (Ddi_VarInVarset(chkVars,v1) && Ddi_VarInVarset(chkVars,v0)) {
	  substV = v0; eqV = v1;
	  Ddi_VarsetRemoveAcc(chkVars,v0);
	  Ddi_VarsetRemoveAcc(chkVars,v1);
	}
	else if (Ddi_VarInVarset(supp,v1) && Ddi_VarInVarset(supp,v0)) {
	  substV = v0; eqV = v1;
	  Ddi_VarsetRemoveAcc(supp,v0);
	  Ddi_VarsetRemoveAcc(supp,v1);
	  eqF = Ddi_BddMakeLiteralAig(eqV,1);
	}
	if (eqV != NULL) {
	  if (eqVars != NULL) {
            Ddi_Bdd_t *substLit = Ddi_BddMakeLiteralAig(substV, !comp);
	    Pdtutil_Assert(substLits!=NULL,"NULL substLits array");
            Ddi_VararrayInsertLast(newEqVars,eqV);
	    Ddi_BddarrayInsertLast(newSubstLits,substLit);
	    if (eqF != NULL) {
	      Ddi_BddXnorAcc(eqF,substLit);
	      Ddi_BddAndAcc(newEqConstr,eqF);
	      Ddi_Free(eqF);
	      nEqRef++;
	    }
	    Ddi_Free(substLit);
	    again1 = 1;
	  }
	}

      }
      Ddi_Free(c0);
      Ddi_Free(c1);
      Ddi_Free(vA);
    }
    else if (0) {
      Ddi_VarsetIntersectAcc(s1,chkVars);
      Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(s1,1);
      int j;
      for (j=0; j<Ddi_VararrayNum(vA); j++) {
        Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
        Ddi_Bdd_t *c0 = Ddi_BddCofactor(p1,v,0);
        Ddi_Bdd_t *c1 = Ddi_BddCofactor(p1,v,1);
        if (!Ddi_AigSatAnd(c0,c1,NULL)) {
          Ddi_BddOrAcc(c0,c1); Ddi_BddNotAcc(c0);
          if (!Ddi_AigSat(c0)) {
            fprintf(dMgrO(ddm),"functional dependency found on part %d(|%d|) (v: %s)\n",
		   i, Ddi_BddSize(c0), Ddi_VarName(v));
	  }
        }
        else {
  	  Ddi_BddNotAcc(c0);
	  Ddi_BddNotAcc(c1);
	  if (!Ddi_AigSat(c0)) {
	    fprintf(dMgrO(ddm),"implication dependency found on part %d (v: ! %s)\n",
		 i, Ddi_VarName(v));
	  }
	  if (!Ddi_AigSat(c1)) {
	    fprintf(dMgrO(ddm),"implication dependency found on part %d (v: %s)\n",
		 i, Ddi_VarName(v));
	  }
        }
        Ddi_Free(c0);
        Ddi_Free(c1);
      }
      Ddi_Free(vA);
    }


    Ddi_Free(s1);
  }

  if (again1) {
    int j;
    for (j=0; j<Ddi_VararrayNum(newEqVars); j++) {
      int k;
      for (k=j+1; k<Ddi_VararrayNum(newEqVars); k++) {
	if (Ddi_VararrayRead(newEqVars,j)==Ddi_VararrayRead(newEqVars,k)) {
	  fprintf(dMgrO(ddm),"equal vars\n");
	}
      }
    }

    Ddi_BddComposeAcc(a,newEqVars,newSubstLits);
    //    NO ! Constrain must be complete !
    //    Ddi_BddComposeAcc(eqConstr,newEqVars,newSubstLits);
    Ddi_BddarrayAppend(substLits,newSubstLits);
    Ddi_VararrayAppend(eqVars,newEqVars);
    Ddi_BddAndAcc(eqConstr,newEqConstr);
    if (auxEqMerge != NULL) {
      Ddi_BddComposeAcc(auxEqMerge,newEqVars,newSubstLits);
    }
  }
  Ddi_Free(newEqConstr);
  Ddi_Free(newEqVars);
  Ddi_Free(newSubstLits);

  } while (0 && (again0 || again1));

  nEqTot = Ddi_VararrayNum(eqVars);
  if (nEqTotP != NULL) {
    *nEqTotP = nEqTot;
  }
  if (Ddi_VararrayNum(eqVars) > 0) {
    fprintf(dMgrO(ddm),"(Simple EQ: %d (#eq: %d - #eqRef: %d)",
	   size0, Ddi_VararrayNum(eqVars), nEqRef);fflush(dMgrO(ddm));
    fprintf(dMgrO(ddm)," -> %d)\n", Ddi_BddSize(a));
  }
  if (nEqRef==0) {
    Ddi_Free(eqConstr);
  }

  if (freeEqVars) {
    Ddi_Free(eqVars);
    Ddi_Free(substLits);
  }

  Ddi_Free(aPart);
  Ddi_Free(chkVars);
  Ddi_Free(supp);

  return eqConstr;

}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigEquivVarsAcc0 (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *refVars,
  Ddi_Varset_t *filterVars,
  Ddi_Bdd_t *auxEqMerge,
  Ddi_Vararray_t *eqVars,
  Ddi_Bddarray_t *substLits
)
{
  Ddi_Bdd_t *newaAig, *eqAig, *cof0Aig, *cof1Aig;
  bAig_array_t *visitedNodes;
  Ddi_Bddarray_t *vLits, *vAuxLits;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int i, j, sat, nVars;
  Ddi_Vararray_t *vA;
  int size0 = Ddi_BddSize(a);
  int myDbg = 0;
  int chkRes = 0;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int *eqClasses, *eqId;
  Ddi_Varset_t *supp;
  int nEq=0, startEqIndex=-1;
  Ddi_Varset_t *chkVars;

  supp = Ddi_BddSupp(a);

  if (filterVars != NULL) {
    Ddi_VarsetIntersectAcc(supp,filterVars);
  }
  if (refVars != NULL) {
    Ddi_Vararray_t *other;
    chkVars = Ddi_VarsetDiff(supp,refVars);
    Ddi_VarsetIntersectAcc(supp,refVars);
    vA = Ddi_VararrayMakeFromVarset(supp,1);
    other = Ddi_VararrayMakeFromVarset(chkVars,1);
    startEqIndex = Ddi_VararrayNum(vA);
    Ddi_VararrayAppend(vA,other);
    Ddi_Free(other);
  }
  else {
    vA = Ddi_VararrayMakeFromVarset(supp,1);
    chkVars = Ddi_VarsetDup(supp);
  }
  vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
  Ddi_Free(supp);
  nVars = Ddi_VararrayNum(vA);

  eqId = Pdtutil_Alloc(int,nVars);
  eqClasses = Pdtutil_Alloc(int,nVars);
  eqAig = Ddi_BddMakePartConjVoid(ddm);

  for (i=0; i<nVars; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    eqClasses[i] = i;
    eqId[i] = -1;
  }

  for (i=0; i<(startEqIndex>=0?startEqIndex:nVars)/* && nEq == 0 */; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Bdd_t *c0, *c1;
    int eq = 0;
    Ddi_VarsetRemoveAcc(chkVars,v);
    if (eqClasses[i]!=i) continue;
    cof0Aig = Ddi_BddCofactor(a,v,0);
    c0 = DdiAigImpliedVarsAcc(cof0Aig,care,chkVars);
    if (c0 != NULL) {
      cof1Aig = Ddi_BddCofactor(a,v,1);
      c1 = DdiAigImpliedVarsAcc(cof1Aig,care,chkVars);
      if (c1 != NULL) {
	Ddi_Bdd_t *cube0 = Ddi_BddMakeConst(ddm, 1);
	Ddi_Bdd_t *cube1 = Ddi_BddMakeConst(ddm, 1);
	Ddi_Bdd_t *impl0 = Ddi_BddMakeLiteral(v, 1);
	Ddi_Bdd_t *impl1 = Ddi_BddMakeLiteral(v, 0);
	Ddi_Bdd_t *refLit0 = Ddi_BddMakeLiteralAig(v, 0);
	Ddi_Bdd_t *refLit1 = Ddi_BddMakeLiteralAig(v, 1);
	int eqFound = 0;
	Ddi_BddSetMono(c0);
	Ddi_BddSetMono(c1);

	for (j=(startEqIndex>=0 ? startEqIndex : i+1); j<nVars; j++) {
	  if (eqClasses[j]==j) {
	    int eq = 0;
	    Ddi_Var_t *v_j = Ddi_VararrayRead(vA,j);
	    Ddi_Bdd_t *c1_j, *c0_j = Ddi_BddCofactor(c0,v_j,0);
	    if (Ddi_BddIsZero(c0_j)) {
	      c1_j = Ddi_BddCofactor(c1,v_j,1);
	      if (Ddi_BddIsZero(c1_j)) {
		Ddi_Bdd_t *eqL, *lit = Ddi_BddMakeLiteral(v_j, 1);
		Ddi_BddAndAcc(cube0,lit);
		Ddi_BddNotAcc(lit);
		Ddi_BddAndAcc(cube1,lit);
		Ddi_BddarrayWrite(vLits,j,refLit0);
		Ddi_Free(lit);
	        eq = -1;
	      }
	      Ddi_Free(c1_j);
	    }
	    else {
	      Ddi_Free(c0_j);
	      c0_j = Ddi_BddCofactor(c0,v_j,1);
	      if (Ddi_BddIsZero(c0_j)) {
	        c1_j = Ddi_BddCofactor(c1,v_j,0);
	  	if (Ddi_BddIsZero(c1_j)) {
		  Ddi_Bdd_t *eqL, *lit = Ddi_BddMakeLiteral(v_j, 0);
		  Ddi_BddAndAcc(cube0,lit);
		  eqL = Ddi_BddOr(impl0,lit);
		  Ddi_BddPartInsertLast(eqAig,eqL);
		  Ddi_Free(eqL);
		  Ddi_BddNotAcc(lit);
		  Ddi_BddAndAcc(cube1,lit);
		  eqL = Ddi_BddOr(impl1,lit);
		  Ddi_BddPartInsertLast(eqAig,eqL);
		  Ddi_Free(eqL);
		  Ddi_BddarrayWrite(vLits,j,refLit1);
		  Ddi_Free(lit);
		  eq = 1;
	        }
		Ddi_Free(c1_j);
	      }
	    }
	    Ddi_Free(c0_j);
	    if (eq == 1) eqClasses[j] = i;
	    if (eq == -1) eqClasses[j] = -i;
	    if (eq) {
	      nEq++; eqFound = 1;
	      Ddi_VarsetRemoveAcc(chkVars,v_j);
	    }
	  }
	}
	if (eqFound) {
	  Ddi_BddOrAcc(impl0,cube0);
	  Ddi_BddOrAcc(impl1,cube1);
	  Ddi_BddPartInsertLast(eqAig,impl0);
	  Ddi_BddPartInsertLast(eqAig,impl1);
	}
	Ddi_Free(cube0);
	Ddi_Free(cube1);
	Ddi_Free(impl0);
	Ddi_Free(impl1);
	Ddi_Free(refLit0);
	Ddi_Free(refLit1);
	Ddi_Free(c0);
      }
      Ddi_Free(cof1Aig);
      Ddi_Free(c1);
    }
    Ddi_Free(c0);
    Ddi_Free(cof0Aig);
  }

  Ddi_BddSetAig(eqAig);
  newaAig = Ddi_BddCompose(a,vA,vLits);
  if (auxEqMerge != NULL) {
    Ddi_BddComposeAcc(auxEqMerge,vA,vLits);
  }

  if (chkRes) {
    Ddi_Bdd_t *chk = Ddi_BddAnd(eqAig,newaAig);
    Ddi_BddXorAcc(chk,a);
    if (care != NULL) {
      Ddi_BddAndAcc(chk,care);
    }
    Pdtutil_Assert(!Ddi_AigSat(chk), "wrong equiv reduction");
    Ddi_Free(chk);
  }

  if (nEq>0) {
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      fprintf(dMgrO(ddm),"FOUND %d EQUIVALENCES - size %d -> %d\n",
        nEq, Ddi_BddSize(a), Ddi_BddSize(newaAig));
    }
    Ddi_DataCopy(a,newaAig);
  }
  else {
    Ddi_Free(eqAig);
  }

  Ddi_Free(newaAig);

  if (eqVars != NULL) {
    Pdtutil_Assert(substLits!=NULL,"NULL substLits array");
    Pdtutil_Assert(Ddi_VararrayNum(vA)==Ddi_BddarrayNum(vLits),
      "variable and bdd arrays of different length");
    for (i=0; i<Ddi_VararrayNum(vA); i++) {
      Ddi_VararrayInsertLast(eqVars,Ddi_VararrayRead(vA,i));
      Ddi_BddarrayInsertLast(substLits,Ddi_BddarrayRead(vLits,i));
    }
  }

  Pdtutil_Free(eqClasses);
  Pdtutil_Free(eqId);
  Ddi_Free(chkVars);
  Ddi_Free(vLits);
  Ddi_Free(vA);

  return(eqAig);

}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigEquivVarsAcc1 (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *refVars,
  Ddi_Varset_t *filterVars,
  Ddi_Bdd_t *auxEqMerge,
  Ddi_Vararray_t *eqVars,
  Ddi_Bddarray_t *substLits
)
{
  Ddi_Bdd_t *newaAig=NULL, *eqAig, *cof0Aig, *cof1Aig;
  Ddi_Bddarray_t *vLits, *vAuxLits;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int i, j, sat, nVars, phase, jEnd;
  Ddi_Vararray_t *vA;
  int size0 = Ddi_BddSize(a);
  int myDbg = 0;
  int chkRes = 1;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int *eqClasses, *impl;
  int *potentialImpl;
  Ddi_Varset_t *supp;
  int nEq=0, nEqc=0, startEqIndex=-1, eqFound=0,nCurrVars;
  Ddi_Varset_t *chkVars;
  Solver    S;
  vec<Lit> lits;

  supp = Ddi_BddSupp(a);

  if (filterVars != NULL) {
    Ddi_VarsetIntersectAcc(supp,filterVars);
  }
  if (refVars != NULL) {
    Ddi_Vararray_t *other;
    chkVars = Ddi_VarsetDiff(supp,refVars);
    Ddi_VarsetIntersectAcc(supp,refVars);
    vA = Ddi_VararrayMakeFromVarset(supp,1);
    other = Ddi_VararrayMakeFromVarset(chkVars,1);
    startEqIndex = Ddi_VararrayNum(vA);
    Ddi_VararrayAppend(vA,other);
    Ddi_Free(other);
  }
  else {
    vA = Ddi_VararrayMakeFromVarset(supp,1);
    chkVars = Ddi_VarsetDup(supp);
  }

  vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
  Ddi_Free(supp);
  nVars = Ddi_VararrayNum(vA);

  impl = Pdtutil_Alloc(int,nVars);
  eqClasses = Pdtutil_Alloc(int,nVars);
  eqAig = Ddi_BddMakePartConjVoid(ddm);

  for (i=0; i<nVars; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    eqClasses[i] = i+1;
    impl[i] = 0;
  }

  /* load clauses to SAT manager */
  aig2CnfIdInit(ddm);

  MinisatClauses(S,a,NULL,NULL,0);
  if (care != NULL) {
    MinisatClauses(S,care,NULL,NULL,0);
  }
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    MinisatClauses(S,Ddi_BddarrayRead(vLits,i),NULL,NULL,1);
  }

  potentialImpl = Pdtutil_Alloc(int, 2*nVars);

  jEnd = startEqIndex>=0?startEqIndex:nVars;
  for (i=-1; (jEnd>0)&&i<jEnd; i++) {
    Ddi_Bdd_t *c0, *c1;
    int eq = 0;
    bAigEdge_t varIndex;
    int k, mask, vCnf, refCnf, tCnf[2];
    int jStart = (startEqIndex>=0 ? startEqIndex : i+1);

    vec<Lit> assumeClause, assume[2], assumeAux0, assumeAux1;

    if (i>=0 && eqClasses[i]!=(i+1)) continue;

    assume[0].clear();
    assume[1].clear();
    assumeAux0.clear();
    assumeAux1.clear();

    /* dummy var for const equiv */
    S.newVar();
    tCnf[0] = S.nVars();
    S.newVar();
    tCnf[1] = S.nVars();
    refCnf = vCnf = 1; /* dummy for constant equiv */

    assume[0].push(MinisatLit(tCnf[0]));
    assume[1].push(MinisatLit(tCnf[1]));

    if (i>=0) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
      varIndex = Ddi_VarToBaig(v);
      refCnf = vCnf = aig2CnfId(bmgr,varIndex);

      if (myDbg)
	printf("I:%d - v:%d, t0:%d, t1:%d\n",
	       i, vCnf, tCnf[0], tCnf[1]);

      assumeAux0.push(MinisatLit(-vCnf));
      assumeAux1.push(MinisatLit(vCnf));

      /* tCnf0 => !vCnf */
      MinisatClause2(S,lits,-tCnf[0],-vCnf);
      /* tCnf1 => vCnf */
      MinisatClause2(S,lits,-tCnf[1],vCnf);
      /* !tCnf0 + !tCnf1 => free */
    }

    for (phase=0; phase<((i==-1)?1:2); phase++) {
      int refinementDone=1;

      assumeClause.clear();
      assumeClause.push(MinisatLit(-tCnf[phase]));

      for (j=jStart; j<nVars; j++) {
	Ddi_Var_t *v_j = Ddi_VararrayRead(vA,j);
	int j0 = 2*j;
	int j1 = 2*j+1;

	if (eqClasses[j]!=(j+1)) continue;

	if (phase==0) impl[j]=0;

	varIndex = Ddi_VarToBaig(v_j);
	vCnf = aig2CnfId(bmgr,varIndex);

	potentialImpl[j0] = -refCnf;
	potentialImpl[j1] = refCnf;

	/* tCnf0 => !vCnf + vCnf */
	assumeClause.push(MinisatLit(-vCnf));
	assumeClause.push(MinisatLit(vCnf));
      }
      S.addClause(assumeClause);

      do {
	int id;
	refinementDone = 0;
	int assumeSize0 = assumeClause.size();

	/* call SAT solver assuming at least one refinement */
	if ((sat = S.okay())) {
	  sat = S.solve(assume[phase]);
	}

	if (sat) {
	  int vSolver, vCnf;
	  int found = 0;

	  assumeClause.clear();
	  assumeClause.push(MinisatLit(-tCnf[phase]));

	  for (j=jStart; j<nVars; j++) {
	    Ddi_Var_t *v_j = Ddi_VararrayRead(vA,j);
	    int j0 = 2*j;
	    int j1 = 2*j+1;

	    if (eqClasses[j]!=(j+1)) continue;

	    varIndex = Ddi_VarToBaig(v_j);
	    vCnf = aig2CnfId(bmgr,varIndex);

	    vSolver = vCnf - 1;

	    if (potentialImpl[j0] && S.model[vSolver]==l_True) {
	      /* var true: 1 implication still possible */
	      potentialImpl[j0] = 0; /* disable 0 implication !!! */
	    }
	    else if (potentialImpl[j1] && S.model[vSolver]==l_False) {
	      /* var false: 0 implication still possible */
	      potentialImpl[j1] = 0; /* disable 1 implication !!! */
	    }
	    if (potentialImpl[j0]!=0) {
	      assumeClause.push(MinisatLit(vCnf));
	    }
	    if (potentialImpl[j1]!=0) {
	      assumeClause.push(MinisatLit(-vCnf));
	    }
	  }
	  Pdtutil_Assert(assumeSize0>assumeClause.size(),
		       "no enabled control found");
	  S.addClause(assumeClause);
	  refinementDone = 1;
	}
      } while (refinementDone);

      for (j=jStart; j<nVars; j++) {
	Ddi_Var_t *v_j = Ddi_VararrayRead(vA,j);
	int j0 = 2*j;
	int j1 = 2*j+1;

	if (eqClasses[j]!=(j+1)) continue;

	varIndex = Ddi_VarToBaig(v_j);
	vCnf = aig2CnfId(bmgr,varIndex);

	if (potentialImpl[j0]!=0) {
	  if (i==-1) {
	    /* constant equivalence */
	    Pdtutil_Assert(phase==0,"second phase for const equiv");
	    eqClasses[j] = -(nVars+1); /* 0 equiv */
	    nEqc++; eqFound = 1;
	    continue;
	  }
	  /* phase (i) => 0 (j) */
	  Pdtutil_Assert(potentialImpl[j0]==-refCnf,"wrong cnf var");
	  Pdtutil_Assert(potentialImpl[j1]==0,"wrong implication");
	  if (phase==0) {
	    impl[j]=-1;
	  }
	  else if (impl[j] == 1) {
	    /* 1 (i) => 0 (j) */
	    /* 0 (i) => 1 (j) */
	    eqClasses[j]=-(i+1);
	    nEq++; eqFound = 1;
	  }
	}
	else if (potentialImpl[j1]!=0) {
	  if (i==-1) {
	    /* constant equivalence */
	    Pdtutil_Assert(phase==0,"second phase for const equiv");
	    eqClasses[j] = nVars+1; /* 1 equiv */
	    nEqc++; eqFound = 1;
	    continue;
	  }
	  /* phase (i) => 1 (j) */
	  Pdtutil_Assert(potentialImpl[j1]==refCnf,"wrong cnf var");
	  if (phase==0) {
	    impl[j]=1;
	  }
	  else if (impl[j] == -1) {
	    /* 1 (i) => 1 (j) */
	    /* 0 (i) => 0 (j) */
	    eqClasses[j]=i+1;
	    nEq++; eqFound = 1;
	  }
	}
      }
    }

  }

  aig2CnfIdClose(ddm);

  nCurrVars=nVars;
  if (eqFound) {
    Ddi_Bdd_t *zeroAig = Ddi_BddMakeConstAig(ddm,0);
    Ddi_Bdd_t *oneAig = Ddi_BddMakeConstAig(ddm,1);

    for (i=0; i<nVars; i++) {
      if (eqClasses[i]!=(i+1)) {
	int phase = eqClasses[i]>0;
	int ref_i = abs(eqClasses[i])-1;
	Ddi_Bdd_t *refLit=NULL, *eq=NULL;
	if (ref_i == nVars) {
	  /* constant class */
	  refLit = Ddi_BddMakeConstAig(ddm,phase);
	}
	else {
	  /* var equiv */
	  Ddi_Var_t *vRef = Ddi_VararrayRead(vA,ref_i);
	  refLit = Ddi_BddMakeLiteralAig(vRef, phase);
	}
	eq = Ddi_BddXnor(Ddi_BddarrayRead(vLits,i),refLit);

	Ddi_BddarrayWrite(vLits,i,refLit);
        Ddi_BddPartInsertLast(eqAig,eq);
	nCurrVars--;
	Ddi_Free(eq);
	Ddi_Free(refLit);
      }
    }
    Ddi_BddSetAig(eqAig);
    newaAig = Ddi_BddCompose(a,vA,vLits);
    if (auxEqMerge != NULL) {
      Ddi_BddComposeAcc(auxEqMerge,vA,vLits);
    }
    Ddi_Free(zeroAig);
    Ddi_Free(oneAig);
  }

  if (chkRes && eqFound) {
    Ddi_Bdd_t *chk = Ddi_BddAnd(eqAig,newaAig);

    if (myDbg) {
      fprintf(dMgrO(ddm),"VARS: ");
      for (i=0; i<nVars; i++) {
	printf("%s ", Ddi_VarName(Ddi_VararrayRead(vA,i)));
      }
      fprintf(dMgrO(ddm),"\n");
      fprintf(dMgrO(ddm),"EQ: ");
      for (i=0; i<nVars; i++) {
	printf("%d ", eqClasses[i]);
      }
      fprintf(dMgrO(ddm),"\n");
    }


    Ddi_BddXorAcc(chk,a);
    if (care != NULL) {
      Ddi_BddAndAcc(chk,care);
    }
    Pdtutil_Assert(!Ddi_AigSat(chk), "wrong equiv reduction");
    Ddi_Free(chk);
  }

  if (nEq>0 || nEqc>0) {
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      fprintf(dMgrO(ddm),"FOUND %d(%d const) EQUIVALENCES - size %d -> %d\n",
        nEq+nEqc, nEqc, Ddi_BddSize(a), Ddi_BddSize(newaAig));
    }
    Ddi_DataCopy(a,newaAig);
  }
  else {
    Ddi_Free(eqAig);
  }

  Ddi_Free(newaAig);

  if (eqVars != NULL) {
    Pdtutil_Assert(substLits!=NULL,"NULL substLits array");
    Pdtutil_Assert(Ddi_VararrayNum(vA)==Ddi_BddarrayNum(vLits),
      "variable and bdd arrays of different length");
    for (i=0; i<Ddi_VararrayNum(vA); i++) {
      Ddi_VararrayInsertLast(eqVars,Ddi_VararrayRead(vA,i));
      Ddi_BddarrayInsertLast(substLits,Ddi_BddarrayRead(vLits,i));
    }
  }

  Pdtutil_Free(potentialImpl);
  Pdtutil_Free(eqClasses);
  Pdtutil_Free(impl);
  Ddi_Free(chkVars);
  Ddi_Free(vLits);
  Ddi_Free(vA);

  return(eqAig);

}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigEquivVarsAcc (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *refVars,
  Ddi_Varset_t *filterVars,
  Ddi_Bdd_t *auxEqMerge,
  Ddi_Vararray_t *eqVars,
  Ddi_Bddarray_t *substLits
)
{
  return DdiAigEquivVarsEqGivenAcc (a, care, refVars, filterVars, 
				    auxEqMerge, NULL, NULL,
				    eqVars, substLits);

}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigEquivVarsEqGivenAcc (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *refVars,
  Ddi_Varset_t *filterVars,
  Ddi_Bdd_t *auxEqMerge,
  Ddi_Vararray_t *eqVarsGiven,
  Ddi_Bddarray_t *substLitsGiven,
  Ddi_Vararray_t *eqVars,
  Ddi_Bddarray_t *substLits
)
{
  Ddi_Bdd_t *newaAig=NULL, *eqAig=NULL, *cof0Aig, *cof1Aig, *eq2 = NULL, *a2=NULL;
  Ddi_Bddarray_t *vLits, *vAuxLits;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int i, j, sat, nVars, phase, jEnd;
  Ddi_Vararray_t *vA, *vAref;
  int size0 = Ddi_BddSize(a);
  int myDbg = 0;
  int chkRes = 0;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int *eqClasses;
  int *potentialImpl;
  Ddi_Varset_t *supp, *suppRef=NULL;
  int nEq=0, nEqc=0, startEqIndex=-1, eqFound=0,nCurrVars;
  int oldAlg=-1, refinementDone;
  int  constOnly=0;
  Solver    S;
  vec<Lit> lits;
  int *vCnfA, *tCnfA, *newReps, nRef = -1;
  char *cexVal, *complEq, *activeClass;
  vec<Lit> assumeClause, assumeSat;
  vec<vec<Lit> > splitClasses0, splitClasses1;
  int noNewClasses=0;
  static int ncalls=0;

  ncalls++;
#if 0
  supp = Ddi_BddSupp(a);
  if (filterVars != NULL) {
    Ddi_VarsetIntersectAcc(supp,filterVars);
  }
  if (Ddi_VarsetNum(supp)>6) oldAlg=0;
  Ddi_Free(supp);
#endif

  if (oldAlg==0)
    return DdiAigEquivVarsAcc0(a,care,refVars,filterVars,auxEqMerge,
			       eqVars,substLits);
  else if (oldAlg==1)
    return DdiAigEquivVarsAcc1(a,care,refVars,filterVars,auxEqMerge,
			       eqVars,substLits);
  supp = Ddi_BddSupp(a);


  if (refVars != NULL) {
    if (Ddi_VarsetIsArray(refVars)) {
      Ddi_VarsetSetArray(supp);
    }
    suppRef = Ddi_VarsetIntersect(supp,refVars);
    vAref = Ddi_VararrayMakeFromVarset(suppRef,1);
    Ddi_VarsetDiffAcc(supp,suppRef);
    Ddi_Free(suppRef);
  }

  if (filterVars != NULL) {
    if (Ddi_VarsetIsArray(filterVars)) {
      Ddi_VarsetSetArray(supp);
    }
    Ddi_VarsetIntersectAcc(supp,filterVars);
  }

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  if (refVars != NULL) {
    nRef = Ddi_VararrayNum(vAref);
    Ddi_VararrayAppend(vAref,vA);
    Ddi_Free(vA);
    vA = vAref;
  }

  if (eqVarsGiven!=NULL) {
    Ddi_Vararray_t *vR, *vS, *vRS;
    int ng = Ddi_VararrayNum(eqVarsGiven);
    Pdtutil_Assert(substLitsGiven!=NULL,"missing subst lits given");
    Pdtutil_Assert(ng==Ddi_BddarrayNum(substLitsGiven),
		   "vars/subst arrays of different size");
    //    noNewClasses=1;

    vS = Ddi_VararrayDup(eqVarsGiven);
    vR = Ddi_BddarraySuppVararray(substLitsGiven);
    vRS = Ddi_VararrayIntersect(vR,vS);
    Pdtutil_Assert(Ddi_VararrayNum(vRS)==0,"error in eq set");
    Ddi_Free(vRS);
    Ddi_VararrayAppend(vR,vS);
    Ddi_VararrayIntersectAcc(vR,vA);
    Ddi_Free(vA);
    Ddi_Free(vS);
    vA = vR;
  }

  vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
  Ddi_Free(supp);
  nVars = Ddi_VararrayNum(vA);

  if (nVars>0) {

  eqClasses = Pdtutil_Alloc(int,nVars+1);
  vCnfA = Pdtutil_Alloc(int,nVars+1);
  tCnfA = Pdtutil_Alloc(int,nVars+1);
  newReps = Pdtutil_Alloc(int,nVars+1);
  cexVal = Pdtutil_Alloc(char,nVars+1);
  complEq = Pdtutil_Alloc(char,nVars+1);
  activeClass = Pdtutil_Alloc(char,nVars+1);
  eqAig = Ddi_BddMakePartConjVoid(ddm);
  splitClasses0.clear();
  splitClasses0.growTo(nVars+1);
  splitClasses1.clear();
  splitClasses1.growTo(nVars+1);

  for (i=0; i<nVars+1; i++) {
    vec<Lit> splitClass;
    splitClass.clear();

    splitClass.copyTo(splitClasses0[i]);
    splitClass.copyTo(splitClasses1[i]);

    activeClass[i] = 0;
    eqClasses[i] = (i==0)?0:-1;
    newReps[i] = -1;
    cexVal[i] = 0;
    complEq[i] = 0;
  }

  /* load clauses to SAT manager */
  aig2CnfIdInit(ddm);

  MinisatClauses(S,a,NULL,NULL,0);
  if (care != NULL) {
    MinisatClauses(S,care,NULL,NULL,0);
  }
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    MinisatClauses(S,Ddi_BddarrayRead(vLits,i),NULL,NULL,1);
  }

  potentialImpl = Pdtutil_Alloc(int, 2*nVars);

  assumeClause.clear();

  for (i=0; i<=nVars; i++) {

    if (i==0) {
      vCnfA[i] = -1; /* dummy */
    }
    else {
      Ddi_Var_t *v_i = Ddi_VararrayRead(vA,i-1);
      bAigEdge_t varIndex = Ddi_VarToBaig(v_i);
      vCnfA[i] = aig2CnfId(bmgr,varIndex);
    }
    /*  var for const equiv */
    S.newVar();
    tCnfA[i] = S.nVars();

    /* at least one class split */
    assumeClause.push(MinisatLit(tCnfA[i]));

  }

  S.addClause(assumeClause);

  if (eqVarsGiven!=NULL) {
    int ng = Ddi_VararrayNum(eqVarsGiven);
    int *ldr = Pdtutil_Alloc(int, ng);
    int *sub = Pdtutil_Alloc(int, ng);
    int n0=0, ne=0, ac=0;
    vec<Lit> lits;

    // mark from 1 to nVars
    Ddi_VararrayWriteMarkWithIndex (vA,1);

    for (i=0; i<ng; i++) {
      Ddi_Var_t *sub_v = Ddi_VararrayRead(eqVarsGiven,i);
      Ddi_Bdd_t *ldr_l = Ddi_BddarrayRead(substLitsGiven,i);
      int sub_i = Ddi_VarReadMark(sub_v);
      int ldr_i = -1;
      int myCnf;
      if (sub_i<=0) continue; // go to next eq
      if (Ddi_BddIsConstant(ldr_l)) {
	ldr_i = 0;
      }
      else {
	Ddi_Var_t *ldr_v = Ddi_BddLitVar(ldr_l);
        ldr_i = Ddi_VarReadMark(ldr_v);
	if (ldr_i<=0) continue;
	Pdtutil_Assert(Ddi_VararrayRead(vA,ldr_i-1)==ldr_v,"var not found");
      }
      Pdtutil_Assert(sub_i>0 && sub_i<=nVars,"wrong ldr index");
      Pdtutil_Assert(ldr_i>=0 && ldr_i<=nVars,"wrong ldr index");

      eqClasses[sub_i] = ldr_i;
      if (ldr_i==0) {
	complEq[sub_i] = Ddi_BddIsOne(ldr_l);; // complemented means 1 constant
      }
      else {
	complEq[sub_i] = Ddi_BddIsComplement(ldr_l); // complement of leader
      }
      myCnf = complEq[sub_i] ? -vCnfA[sub_i] : vCnfA[sub_i];

      if (activeClass[ldr_i]==0) {
	splitClasses0[ldr_i].clear();
	splitClasses0[ldr_i].push(MinisatLit(-tCnfA[ldr_i]));
	if (ldr_i > 0) {
	  splitClasses1[ldr_i].push(MinisatLit(-tCnfA[ldr_i]));
	  splitClasses0[ldr_i].push(MinisatLit(vCnfA[ldr_i]));
	  splitClasses1[ldr_i].push(MinisatLit(-vCnfA[ldr_i]));
	}
	eqClasses[ldr_i]=ldr_i;
      }
      splitClasses0[ldr_i].push(MinisatLit(myCnf));
      if (ldr_i == 0) {
	n0++;
      }
      else {
	splitClasses1[ldr_i].push(MinisatLit(-myCnf));
	ne++;
      }
      activeClass[ldr_i] = 2;
      activeClass[sub_i] = 1;
    }

    //  NO: we need new classes given by class split
    //  assumeClause.clear();
    for (i=0; i<=nVars; i++) {
      if (activeClass[i]<2) {
	/* disable split guard */
	assumeSat.push(MinisatLit(-tCnfA[i]));
	if (activeClass[i]==0) {
	  eqClasses[i]=-2;
	}
      }
      else {
	/* Re write clause for at least one class split */
	//  NO: we need new classes given by class split
	//  assumeClause.push(MinisatLit(tCnfA[i]));
	S.addClause(splitClasses0[i]);
	if (i==0) {
	  Pdtutil_Assert(splitClasses0[0].size()>1,"split class problem");
	}
	else {
	  Pdtutil_Assert(splitClasses0[i].size()>2,"split class problem");
	  Pdtutil_Assert(splitClasses1[i].size()>2,"split class problem");
	  S.addClause(splitClasses1[i]);
	}
	splitClasses0[i].clear();
	splitClasses1[i].clear();
	ac++;
      }
    }
    //    printf("ASSUME CL: %d\n",assumeClause.size());
    //    S.addClause(assumeClause);

    Ddi_VararrayWriteMark (vA, 0);
    if (n0+ne>0) {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	fprintf(dMgrO(ddm),"RECHECKED %d(%d const) EQUIVALENCES (ac: %d)\n",
		n0+ne, n0, ac);
      }
    }

    Pdtutil_Free(ldr);
    Pdtutil_Free(sub);
  }

  do {
    int id;
    refinementDone = 0;

    /* call SAT solver assuming at least one refinement */

    //    printf("ASSUME: %d\n",assumeSat.size());
    if ((sat = S.okay())) {
      sat = S.solve(assumeSat);
    }

    if (sat) {
      int vSolver, vCnf;
      int splitDone = 0;

      assumeSat.clear();

      if (myDbg) {
	printf("CEX: ");
	for (i=1; i<=nVars; i++) {
	  /* copy cex */
	  int vSolver = vCnfA[i]-1;
	  if (S.model[vSolver]==l_True) {
	    fprintf(dMgrO(ddm),"1");
	  }
	  else if (S.model[vSolver]==l_False) {
	    fprintf(dMgrO(ddm),"0");
	  }
	}
	printf("\n");
      }
      for (i=0; i<=nVars; i++) {
	if (eqClasses[i]<-1) continue; // skip as disabled
	if (i>0) {
	  /* copy cex */
	  int vSolver = vCnfA[i]-1;
	  if (S.model[vSolver]==l_True) {
	    cexVal[i]=1;
	  }
	  else if (S.model[vSolver]==l_False) {
	    cexVal[i]=0;
	  }
	  else {
	    Pdtutil_Assert(0,"wrong model value");
	  }
	}
	activeClass[i]=0;
	splitClasses0[i].clear();
	splitClasses1[i].clear();
	if (eqClasses[i]==i) {
	  /* class representative */
	  /* tCnfA[i] => split class */
	  splitClasses0[i].push(MinisatLit(-tCnfA[i]));
	  if (i>0) {
	    splitClasses1[i].push(MinisatLit(-tCnfA[i]));
	    splitClasses0[i].push(MinisatLit(vCnfA[i]));
	    splitClasses1[i].push(MinisatLit(-vCnfA[i]));
	  }
	  activeClass[i]=1; /* this is a class: possibly unchanged */
	  newReps[i] = -1;
	}
	else if (eqClasses[i] == -1) {
	  /* not yet assigned: put in const class */
	  int myCnf;
	  eqClasses[i] = 0;
	  complEq[i] = cexVal[i];
	  myCnf = complEq[i] ? -vCnfA[i] : vCnfA[i];
	  splitClasses0[0].push(MinisatLit(myCnf));
	  splitClasses1[0].push(MinisatLit(-myCnf));
	  activeClass[0] = 2;
	  splitDone = 1;
	}
	else {
	  /* class member: get representative */
	  int isCompl = complEq[i];
	  int rep_i = eqClasses[i];
	  if (cexVal[i] != (isCompl?((cexVal[rep_i]+1)%2):cexVal[rep_i])) {
	    /* split */
	    splitDone = 1;
	    if (noNewClasses) {
	      eqClasses[i] = -2;
	      activeClass[rep_i] = 2;
	      continue;
	    }
	    //	    if (rep_i==0 && eqVarsGiven) printf("%d\n", i);
	    if (newReps[rep_i]<0) {
	      /* this is a new repr */
	      newReps[rep_i] = i;
	      eqClasses[i] = i;
	      complEq[i] = 0; /* new rep: reset compl flag */
	      /* class representative */
	      /* tCnfA[i] => split class */
	      splitClasses0[i].push(MinisatLit(-tCnfA[i]));
	      splitClasses1[i].push(MinisatLit(-tCnfA[i]));
	      splitClasses0[i].push(MinisatLit(vCnfA[i]));
	      splitClasses1[i].push(MinisatLit(-vCnfA[i]));
	      /* split: two changed classes */
	      activeClass[i] = activeClass[rep_i] = 2;
	    }
	    else {
	      /* join existing new rep */
	      int myCnf;
	      rep_i = newReps[rep_i];
	      eqClasses[i] = rep_i;
	      complEq[i] = cexVal[i] != cexVal[rep_i];
	      myCnf = complEq[i] ? -vCnfA[i] : vCnfA[i];
	      splitClasses0[rep_i].push(MinisatLit(myCnf));
	      splitClasses1[rep_i].push(MinisatLit(-myCnf));
	    }
	  }
	  else {
	    /* keep in class */
	    int myCnf = complEq[i] ? -vCnfA[i] : vCnfA[i];
	    splitClasses0[rep_i].push(MinisatLit(myCnf));
	    splitClasses1[rep_i].push(MinisatLit(-myCnf));
	  }
	}
      }

      if (myDbg) {
	printf("*************\n");
      }

      for (i=0; i<=nVars; i++) {
	if (!activeClass[i]) {
	  /* not yet a class: disable split guard */
          assumeSat.push(MinisatLit(-tCnfA[i]));
	  if (myDbg) {
	    fprintf(dMgrO(ddm),"A: %d\n",-tCnfA[i]);
	  }
	}
	else if (activeClass[i]>1) {
          Pdtutil_Assert (splitClasses0[i].size()>=((i==0)?1:2),
            "wrong clause num");
          if (splitClasses0[i].size()==((i==0)?1:2)) {
	    /* singleton class generated by split: disable split */
	    MinisatClause1(S,lits,-tCnfA[i]);
	    if (myDbg) {
	      fprintf(dMgrO(ddm),"C: %d\n",-tCnfA[i]);
	    }
	  }
	  else {
	    int k;
	    /* active class with at least 2 elements: enable split */
	    S.addClause(splitClasses0[i]);
	    if (i>0) {
	      S.addClause(splitClasses1[i]);
	    }
	    if (myDbg) {
	      fprintf(dMgrO(ddm),"OR: ");
	      for (k=0; k<splitClasses0[i].size(); k++) {
		int v = var(splitClasses0[i][k]);
		int s = sign(splitClasses0[i][k]);
		printf("%s%d ", s?"-":"",v+1);
	      }
	      fprintf(dMgrO(ddm),"\n");
	    }
	  }
	}
      }
      if (myDbg) {
	printf("*+++++++++++*\n");
      }
      Pdtutil_Assert(splitDone, "no split with SAT");
      refinementDone = 1;
    }
  } while (refinementDone);

  for (j=1; j<=nVars; j++) {
    if (eqClasses[j]<-1) continue; // skip as disabled
    if (eqClasses[j]!=j && (nRef<0 || (j>=nRef && eqClasses[j]<nRef))) {
      //    if (eqClasses[j]!=j) {
      if (eqClasses[j]==0) nEqc++;
      else nEq++;
      eqFound = 1;
    }
  }

  aig2CnfIdClose(ddm);

  nCurrVars=nVars;
  if (eqFound) {
    Ddi_Bdd_t *zeroAig = Ddi_BddMakeConstAig(ddm,0);
    Ddi_Bdd_t *oneAig = Ddi_BddMakeConstAig(ddm,1);

    for (i=1; i<=nVars; i++) {
      if (eqClasses[i]<-1) continue; // skip as disabled
      if (eqClasses[i]!=i && (nRef<0 || (i>=nRef && eqClasses[i]<nRef))) {
	int isCompl = complEq[i];
	int ref_i = eqClasses[i];
	Ddi_Bdd_t *refLit=NULL, *eq=NULL;
	if (ref_i == 0) {
	  /* constant 0 class */
	  refLit = Ddi_BddMakeConstAig(ddm,isCompl);
	// fprintf(dMgrO(ddm),"%s - %d\n", Ddi_VarName(Ddi_VararrayRead(vA,i-1)), !isCompl);
	}
	else if (constOnly) {
	  continue;
	}
	else {
	  /* var equiv */
	  Ddi_Var_t *vRef = Ddi_VararrayRead(vA,ref_i-1);
	  refLit = Ddi_BddMakeLiteralAig(vRef, !isCompl);
	  //fprintf(dMgrO(ddm),"[%d] %s - %s %s\n", ref_i, Ddi_VarName(Ddi_VararrayRead(vA,i-1)),
	  // isCompl?"!":"", Ddi_VarName(vRef));
	}
	eq = Ddi_BddXnor(Ddi_BddarrayRead(vLits,i-1),refLit);

	Ddi_BddarrayWrite(vLits,i-1,refLit);
        Ddi_BddPartInsertLast(eqAig,eq);
	nCurrVars--;
	Ddi_Free(eq);
	Ddi_Free(refLit);
      }
    }
    Ddi_BddSetAig(eqAig);
    newaAig = Ddi_BddCompose(a,vA,vLits);
    if (auxEqMerge != NULL) {
      Ddi_BddComposeAcc(auxEqMerge,vA,vLits);
    }
    Ddi_Free(zeroAig);
    Ddi_Free(oneAig);
  }

  if (chkRes && eqFound) {
    Ddi_Bdd_t *chk = Ddi_BddAnd(eqAig,newaAig);

    if (myDbg) {
      fprintf(dMgrO(ddm),"VARS: ");
      for (i=1; i<=nVars; i++) {
	printf("%s ", Ddi_VarName(Ddi_VararrayRead(vA,i-1)));
      }
      fprintf(dMgrO(ddm),"\n");
      fprintf(dMgrO(ddm),"EQ: ");
      for (i=1; i<=nVars; i++) {
	printf("%d ", eqClasses[i]);
      }
      fprintf(dMgrO(ddm),"\n");
      fprintf(dMgrO(ddm),"CM: ");
      for (i=1; i<=nVars; i++) {
	printf("%d ", complEq[i]);
      }
      fprintf(dMgrO(ddm),"\n");
    }

    Ddi_BddXorAcc(chk,a);
    if (care != NULL) {
      Ddi_BddAndAcc(chk,care);
    }
    Pdtutil_Assert(!Ddi_AigSat(chk), "wrong equiv reduction");
    Ddi_Free(chk);
  }

  if (nEq>0 || nEqc>0) {
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      fprintf(dMgrO(ddm),"FOUND %d(%d const) EQUIVALENCES - size %d -> %d\n",
        nEq+nEqc, nEqc, Ddi_BddSize(a), Ddi_BddSize(newaAig));
    }
    Ddi_DataCopy(a,newaAig);
  }
  else {
    Ddi_Free(eqAig);
  }

  Ddi_Free(newaAig);

  if (eqVars != NULL) {
    Pdtutil_Assert(substLits!=NULL,"NULL substLits array");
    Pdtutil_Assert(Ddi_VararrayNum(vA)==Ddi_BddarrayNum(vLits),
      "variable and bdd arrays of different length");
    if (Ddi_VararrayNum(eqVars)>0) {
      /* handle transitive equivs */
      Ddi_BddarrayComposeAcc(substLits, vA, vLits);
    }
    for (i=0; i<Ddi_VararrayNum(vA); i++) {
      if (eqClasses[i+1]<-1) continue; // skip as disabled
      if (eqClasses[i+1]!=(i+1)) {
	Ddi_VararrayInsertLast(eqVars,Ddi_VararrayRead(vA,i));
	Ddi_BddarrayInsertLast(substLits,Ddi_BddarrayRead(vLits,i));
      }
    }
  }

  Pdtutil_Free(potentialImpl);
  Pdtutil_Free(eqClasses);
  Pdtutil_Free(activeClass);
  Pdtutil_Free(vCnfA);
  Pdtutil_Free(tCnfA);
  Pdtutil_Free(complEq);
  Pdtutil_Free(cexVal);
  Pdtutil_Free(newReps);

  }

  Ddi_Free(vLits);
  Ddi_Free(vA);

  if (eqVarsGiven!=NULL) {
    Ddi_Bdd_t *eqR = DdiAigEquivVarsAcc (a,care,refVars,filterVars,
						auxEqMerge,
						eqVars,substLits);
    if (eqR!=NULL) {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	fprintf(dMgrO(ddm),"ADDITIONAL (not rechecked) EQ FOUND\n");
      }
      if (eqAig==NULL) {
	eqAig = eqR;
      }
      else {
	Ddi_BddAndAcc(eqAig,eqR);
	Ddi_Free(eqR);
      }
    }
  }

  return(eqAig);

}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigEquivVarsInConstrain (
  Ddi_Bdd_t *constr,
  Ddi_Vararray_t *filterVars,
  Ddi_Bdd_t *auxEqMerge,
  Ddi_Vararray_t *eqVars,
  Ddi_Bddarray_t *substFuncs
)
{
  Ddi_Bdd_t *newaAig=NULL, *eqAig=NULL, *cof0Aig, *cof1Aig, *eq2 = NULL, *a2=NULL;
  Ddi_Bddarray_t *vLits, *vAuxLits;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(constr);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int i, j, iter, sat, nVars, nGates, phase, jEnd;
  Ddi_Vararray_t *vA, *vAref;
  int myDbg = 0;
  int chkRes = 1;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int *eqClasses;
  int *potentialImpl;
  int nEq=0, nEqc=0, nEqC1=0, nEqI=0, startEqIndex=-1, eqFound=0,nCurrVars;
  int oldAlg=-1, refinementDone;
  int  constOnly=0;
  Solver    S;
  vec<Lit> lits;
  int *gCnfA, *vCnfA, *tCnfA, *newReps, *classCnt;
  char *cexVal, *complEq, *activeClass;
  bAig_array_t *visitedNodes;
  int chkCircDep = 1;

  vec<Lit> assumeClause, assumeSat;
  vec<vec<Lit> > splitClasses0, splitClasses1;

  static int ncalls=0;

  ncalls++;

  Pdtutil_Assert (filterVars != NULL,"filter vars required");

  vA = Ddi_BddSuppVararray(constr);
  Ddi_VararrayIntersectAcc(vA,filterVars);

  vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
  nVars = Ddi_VararrayNum(vA);

  if (nVars<=0) {
    Ddi_Free(vA);
    Ddi_Free(vLits);
    return NULL;
  }

  visitedNodes = bAigArrayAlloc();
  for (i=0; i<nVars; i++) {
    Ddi_Var_t *v_i = Ddi_VararrayRead(vA,i);
    postOrderAigVisitIntern(bmgr,Ddi_VarToBaig(v_i),visitedNodes,-1);
  }
  Pdtutil_Assert(visitedNodes->num==nVars,"baig array size problem");
  Ddi_PostOrderBddAigVisitIntern(constr,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  nGates = visitedNodes->num;

  vCnfA = Pdtutil_Alloc(int,nVars+1);
  tCnfA = Pdtutil_Alloc(int,nVars+1);
  splitClasses0.clear();
  splitClasses0.growTo(nVars+1);
  splitClasses1.clear();
  splitClasses1.growTo(nVars+1);
  classCnt = Pdtutil_Alloc(int,nVars+1);

  eqClasses = Pdtutil_Alloc(int,nGates+1);
  activeClass = Pdtutil_Alloc(char,nGates+1);

  gCnfA = Pdtutil_Alloc(int,nGates+1);
  newReps = Pdtutil_Alloc(int,nGates+1);
  cexVal = Pdtutil_Alloc(char,nGates+1);
  complEq = Pdtutil_Alloc(char,nGates+1);

  for (i=0; i<nGates+1; i++) {
    eqClasses[i] = (i==0)?0:-1;
    newReps[i] = -1;
    cexVal[i] = 0;
    complEq[i] = 0;
    activeClass[i] = 0;
  }

  for (i=0; i<nVars+1; i++) {
    vec<Lit> splitClass;
    splitClass.clear();
    splitClass.copyTo(splitClasses0[i]);
    splitClass.copyTo(splitClasses1[i]);
    classCnt[i]=0;
  }

  /* load clauses to SAT manager */
  aig2CnfIdInit(ddm);
  for (i=0; i<nVars; i++) {
    Ddi_Var_t *v_i = Ddi_VararrayRead(vA,i);
    /* just gen aig2cnf code */
    int f = DdiAig2CnfId(bmgr,Ddi_VarToBaig(v_i));
  }
  bAigArrayMinisatClauses(ddm, S, visitedNodes, 0);
  /* the following is just to assert constr */
  if (Ddi_BddIsPartConj(constr)) {
    for (i=0; i<Ddi_BddPartNum(constr); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(constr,i);
      int fCnf = DdiAig2CnfIdSigned(bmgr,Ddi_BddToBaig(f_i));
      MinisatClause1(S,lits,fCnf);
    }
  }
  else {
    int fCnf = DdiAig2CnfIdSigned(bmgr,Ddi_BddToBaig(constr));
    MinisatClause1(S,lits,fCnf);
  }

  assumeClause.clear();

  for (i=0; i<=nVars; i++) {

    if (i==0) {
      vCnfA[i] = -1; /* dummy */
    }
    else {
      Ddi_Var_t *v_i = Ddi_VararrayRead(vA,i-1);
      bAigEdge_t varIndex = Ddi_VarToBaig(v_i);
      vCnfA[i] = aig2CnfId(bmgr,varIndex);
    }
    /*  var for const equiv */
    S.newVar();
    tCnfA[i] = S.nVars();

    /* at least one class split */
    assumeClause.push(MinisatLit(tCnfA[i]));
  }

  S.addClause(assumeClause);

  for (i=0; i<=nGates; i++) {
    if (i==0) {
      gCnfA[i] = -1; /* dummy */
    }
    else {
      bAigEdge_t baig = visitedNodes->nodes[i-1];
      gCnfA[i] = aig2CnfId(bmgr,baig);
    }
  }

  iter=0;
  do {
    int id;
    refinementDone = 0;
    iter++;
    /* call SAT solver assuming at least one refinement */
    if ((sat = S.okay())) {
      sat = S.solve(assumeSat);
    }

    if (sat) {
      int vSolver, vCnf;
      int splitDone = 0;

      assumeSat.clear();

      if (myDbg) {
	printf("CEX: ");
	for (i=1; i<=nGates; i++) {
	  /* copy cex */
	  int vSolver = gCnfA[i]-1;
	  if (S.model[vSolver]==l_True) {
	    fprintf(dMgrO(ddm),"1");
	  }
	  else if (S.model[vSolver]==l_False) {
	    fprintf(dMgrO(ddm),"0");
	  }
	}
	printf("\n");
      }
      for (i=0; i<=nGates; i++) {
	if (activeClass[i]<0) continue; // skip gate
	if (i>0) {
	  /* copy cex */
	  int vSolver = gCnfA[i]-1;
	  if (S.model[vSolver]==l_True) {
	    cexVal[i]=1;
	  }
	  else if (S.model[vSolver]==l_False) {
	    cexVal[i]=0;
	  }
	  else {
	    Pdtutil_Assert(0,"wrong model value");
	  }
	}
	activeClass[i]=0;
	if (i<=nVars) {
	  splitClasses0[i].clear();
	  splitClasses1[i].clear();
	}
	if (eqClasses[i]==i) {
	  /* class representative */
	  /* tCnfA[i] => split class */
	  Pdtutil_Assert(i<=nVars,"wrong class id");
	  splitClasses0[i].push(MinisatLit(-tCnfA[i]));
	  if (i>0) {
	    splitClasses1[i].push(MinisatLit(-tCnfA[i]));
	    splitClasses0[i].push(MinisatLit(vCnfA[i]));
	    splitClasses1[i].push(MinisatLit(-vCnfA[i]));
	  }
	  activeClass[i]=1; /* this is a class: possibly unchanged */
	  newReps[i] = -1;
	}
	else if (eqClasses[i] == -1) {
	  /* not yet assigned: put in const class */
	  int myCnf;
	  eqClasses[i] = 0;
	  complEq[i] = cexVal[i];
	  myCnf = complEq[i] ? -gCnfA[i] : gCnfA[i];
	  splitClasses0[0].push(MinisatLit(myCnf));
	  splitClasses1[0].push(MinisatLit(-myCnf));
	  activeClass[0] = 2;
	  splitDone = 1;
	}
	else {
	  /* class member: get representative */
	  int isCompl = complEq[i];
	  int rep_i = eqClasses[i];
	  Pdtutil_Assert(rep_i<=nVars,"wrong class rep");
	  if (cexVal[i] != (isCompl?((cexVal[rep_i]+1)%2):cexVal[rep_i])) {
	    /* split */
	    splitDone = 1;
	    if (newReps[rep_i]<0) {
	      if (i>nVars) {
		// just a gate, not a rep. remove as not eq to any other var
		eqClasses[i] = -1;
		activeClass[i] = -1;
		activeClass[rep_i] = 2;
		splitDone = 1;
	      } 
	      else {
		/* this is a new repr */
		newReps[rep_i] = i;
		eqClasses[i] = i;
		complEq[i] = 0; /* new rep: reset compl flag */
		/* class representative */
		/* tCnfA[i] => split class */
		splitClasses0[i].push(MinisatLit(-tCnfA[i]));
		splitClasses1[i].push(MinisatLit(-tCnfA[i]));
		splitClasses0[i].push(MinisatLit(vCnfA[i]));
		splitClasses1[i].push(MinisatLit(-vCnfA[i]));
		/* split: two changed classes */
		activeClass[i] = activeClass[rep_i] = 2;
	      }
	    }
	    else {
	      /* join existing new rep */
	      int myCnf;
	      rep_i = newReps[rep_i];
	      eqClasses[i] = rep_i;
	      complEq[i] = cexVal[i] != cexVal[rep_i];
	      myCnf = complEq[i] ? -gCnfA[i] : gCnfA[i];
	      splitClasses0[rep_i].push(MinisatLit(myCnf));
	      splitClasses1[rep_i].push(MinisatLit(-myCnf));
	    }
	  }
	  else {
	    /* keep in class */
	    int myCnf = complEq[i] ? -gCnfA[i] : gCnfA[i];
	    splitClasses0[rep_i].push(MinisatLit(myCnf));
	    splitClasses1[rep_i].push(MinisatLit(-myCnf));
	  }
	}
      }

      if (myDbg) {
	printf("*************\n");
      }

      for (i=0; i<=nVars; i++) {
	classCnt[i]=0;
      }
      for (i=0; i<=nGates; i++) {
	if (activeClass[i]<0) continue;
	int rep_i = eqClasses[i];
	Pdtutil_Assert(rep_i<=nVars,"wrong class rep");
	classCnt[rep_i]++;
      }

      if (myDbg || 0) {
	int sum=0;
	sum=0;
	printf("nG: %d - NV: %d\n",nGates, nVars);
	for (i=0; i<=nVars; i++) {
	  sum+= classCnt[i];
	  printf ("[%d]: %d ", i, classCnt[i]);
	}
	printf("\nTOT: %d\n", sum);

      }

      for (i=0; i<=nVars; i++) {
	if (activeClass[i]<0) {
	  // just skip
	  if (myDbg) {
	    fprintf(dMgrO(ddm),"Skip: %d\n",i);
	  }
	}
	else if (activeClass[i]==0) {
	  if (i<=nVars) {
	    /* not yet a class: disable split guard */
	    assumeSat.push(MinisatLit(-tCnfA[i]));
	    if (myDbg) {
	      fprintf(dMgrO(ddm),"A: %d\n",-tCnfA[i]);
	    }
	  }
	}
	else if (activeClass[i]>1) {
	  Pdtutil_Assert(i<=nVars,"wrong class rep");
          Pdtutil_Assert (splitClasses0[i].size()>=((i==0)?1:2),
            "wrong clause num");
          if (splitClasses0[i].size()==((i==0)?1:2)) {
	    /* singleton class generated by split: disable split */
	    MinisatClause1(S,lits,-tCnfA[i]);
	    if (myDbg) {
	      fprintf(dMgrO(ddm),"C: %d\n",-tCnfA[i]);
	    }
	  }
	  else {
	    int k;
	    /* active class with at least 2 elements: enable split */
	    S.addClause(splitClasses0[i]);
	    if (i>0) {
	      S.addClause(splitClasses1[i]);
	    }
	    if (myDbg) {
	      fprintf(dMgrO(ddm),"OR: ");
	      for (k=0; k<splitClasses0[i].size(); k++) {
		int v = var(splitClasses0[i][k]);
		int s = sign(splitClasses0[i][k]);
		printf("%s%d ", s?"-":"",v+1);
	      }
	      fprintf(dMgrO(ddm),"\n");
	    }
	  }
	}
      }
      if (myDbg) {
	printf("*+++++++++++*\n");
      }
      Pdtutil_Assert(splitDone, "no split with SAT");
      refinementDone = 1;
    }
  } while (refinementDone);

  for (j=1; j<=nGates; j++) {
    if (eqClasses[j]!=j) {
      //    if (eqClasses[j]!=j) {
      if (j<=nVars) {
	if (eqClasses[j]==0) { 
	  nEqc++; eqFound = 1;
	}
	else if (eqClasses[j]>0) nEqI++;
      }
      else {
	if (eqClasses[j]>0) {
	  nEq++;
	  eqFound = 1;
	}
	else if (eqClasses[j]==0) nEqC1++;
      }
    }
  }

  aig2CnfIdClose(ddm);

  Ddi_Bdd_t *constrAig = Ddi_BddMakeAig(constr);

  nCurrVars=nVars;
  if (eqFound) {
    Ddi_Bdd_t *zeroAig = Ddi_BddMakeConstAig(ddm,0);
    Ddi_Bdd_t *oneAig = Ddi_BddMakeConstAig(ddm,1);

    Ddi_Bddarray_t *subst = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_Vararray_t *vars = Ddi_VararrayAlloc(ddm, 0);

    for (i=1; i<=nGates; i++) {
      if (eqClasses[i]!=i) {
	int isCompl = complEq[i];
	int ref_i = eqClasses[i];
	Ddi_Bdd_t *sF=NULL, *eq=NULL;
	Ddi_Var_t *vRef = NULL;

	if (i<=nVars) {
	  printf("var equiv not handled  yet\n");
	  eqClasses[i]=-1;
	  continue;
	}
	Pdtutil_Assert(ref_i<=nVars,"wrong class rep");
	if (ref_i == 0) {
	  /* constant 0 class */
	  if (i>nVars) {
	    eqClasses[i]=-1;
	    continue;
	  }
	  sF = Ddi_BddMakeConstAig(ddm,isCompl);
	// fprintf(dMgrO(ddm),"%s - %d\n", Ddi_VarName(Ddi_VararrayRead(vA,i-1)), !isCompl);
	}
	else if (constOnly) {
	  eqClasses[i]=-1;
	  continue;
	}
	else if (ref_i<0) {
	  eqClasses[i]=-1;
	  continue;
	}
	else if (classCnt[ref_i]<=0) {
	  eqClasses[i]=-1;
	  nEq--;
	  continue;
	}
	else {
	  /* var equiv */
	  int mult=0;
	  vRef = Ddi_VararrayRead(vA,ref_i-1);
	  bAigEdge_t baig = bAig_NonInvertedEdge(visitedNodes->nodes[i-1]);
	  sF = Ddi_BddMakeFromBaig(ddm,baig);
	  if (isCompl) Ddi_BddNotAcc(sF);
	  if (classCnt[ref_i]>2) {
	    Ddi_Varset_t *s = Ddi_BddSupp(sF);
	    if (Ddi_VarInVarset(s,vRef)) {
	      printf("multiple equiv %d->%d not handled  yet\n", i, ref_i);
	      eqClasses[i]=-1;
	      mult=1;
	    }
	    Ddi_Free(s);
	    //	    continue;
	  }
	  if (mult) {
	    Ddi_Free(sF);
	    continue;
	  }
	  classCnt[ref_i] = 0;
	  //	  fprintf(dMgrO(ddm),"%s - %s %s\n", Ddi_VarName(Ddi_VararrayRead(vA,i-1)),
	  //	 isCompl?"!":"", Ddi_VarName(vRef));
	}

	Ddi_VararrayInsertLast(vars,vRef);
	Ddi_BddarrayInsertLast(subst,sF);

	if (myDbg) {
	  Ddi_Bdd_t *e = Ddi_BddDup(Ddi_BddarrayRead(vLits,ref_i-1));
	  Ddi_BddXnorAcc(e,sF);
	  Pdtutil_Assert(Ddi_BddIncluded(constrAig,e),"eq not implied");
	  Ddi_Free(e);
	}

	nCurrVars--;
	Ddi_Free(eq);
	Ddi_Free(sF);
      }
    }

    if (chkCircDep) {
      int prevCirc = nVars;
      int nCirc;
      do {
	Ddi_Vararray_t *supp = Ddi_BddarraySuppVararray(subst);
	Ddi_VararrayIntersectAcc(supp,vars);
	nCirc = Ddi_VararrayNum(supp);
	if (nCirc>0) {
	  Pdtutil_Assert(nCirc<prevCirc,"circular dep");
#if 0
	  Ddi_BddarrayComposeAcc(subst,vars,subst);
#else
	  Ddi_VararrayWriteMark (supp, 1);
	  for (i=Ddi_VararrayNum(vars)-1;i>=0;i--) {
	    Ddi_Var_t *v = Ddi_VararrayRead(vars,i);
	    if (Ddi_VarReadMark(v)>0) {
	      Ddi_VararrayRemove(vars,i);
	      Ddi_BddarrayRemove(subst,i);
	      nCirc--;
	    }
	  }
	  Ddi_VararrayWriteMark (supp, 0);
	  if (nCirc>0)
	    printf("removed %d potential circular dependencies\n", nCirc);
#endif
	  prevCirc = nCirc;
	}
	Ddi_Free(supp);
      } while (nCirc>0);
    }

    int lim=-1;
    if (lim>0)
    for (i=Ddi_VararrayNum(vars)-1; i>=lim; i--) {
      Ddi_VararrayRemove(vars,i);
      Ddi_BddarrayRemove(subst,i);
    }
    newaAig = Ddi_BddCompose(constr,vars,subst);
    if (auxEqMerge != NULL) {
      Ddi_BddComposeAcc(auxEqMerge,vars,subst);
    }

    if (eqVars != NULL) {
      Pdtutil_Assert(substFuncs!=NULL,"NULL substLits array");
      Pdtutil_Assert(Ddi_VararrayNum(vA)==Ddi_BddarrayNum(vLits),
		     "variable and bdd arrays of different length");

      eqAig = Ddi_BddMakeEq(vars,subst);
      Ddi_BddSetAig(eqAig);


      if (Ddi_VararrayNum(eqVars)>0) {
	/* handle transitive equivs */
	Ddi_BddarrayComposeAcc(substFuncs, vars, subst);
      }
      Ddi_VararrayAppend(eqVars,vars);
      Ddi_BddarrayAppend(substFuncs,subst);
      Ddi_Free(vars);
      Ddi_Free(subst);
    }

    Ddi_Free(zeroAig);
    Ddi_Free(oneAig);
  }

  Ddi_Free(constrAig);

  if (chkRes && eqFound) {
    Ddi_Bdd_t *chk = Ddi_BddMakeAig(newaAig);
    Ddi_Bdd_t *chk2 = Ddi_BddMakeAig(constr);

    Ddi_BddAndAcc(chk,eqAig);
    if (myDbg) {
      fprintf(dMgrO(ddm),"VARS: ");
      for (i=1; i<=nVars; i++) {
	printf("%s ", Ddi_VarName(Ddi_VararrayRead(vA,i-1)));
      }
      fprintf(dMgrO(ddm),"\n");
      fprintf(dMgrO(ddm),"EQ: ");
      for (i=1; i<=nVars; i++) {
	printf("%d ", eqClasses[i]);
      }
      fprintf(dMgrO(ddm),"\n");
      fprintf(dMgrO(ddm),"CM: ");
      for (i=1; i<=nVars; i++) {
	printf("%d ", complEq[i]);
      }
      fprintf(dMgrO(ddm),"\n");
    }

    Ddi_BddSetAig(chk);
    Pdtutil_Assert(Ddi_BddEqualSat(chk,chk2), "wrong equiv reduction");
    Ddi_Free(chk);
    Ddi_Free(chk2);
  }

  if (nEq>0 || nEqc>0) {
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      fprintf(dMgrO(ddm),"FOUND %d(%d const) EQUIVALENCES - size %d -> %d\n",
        nEq+nEqc, nEqc, Ddi_BddSize(constr), Ddi_BddSize(newaAig));
    }
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      fprintf(dMgrO(ddm),"FOUND %d PI EQ - %d gate CONST\n", nEqI, nEqC1);
    }
    Ddi_DataCopy(constr,newaAig);
  }
  else {
    Ddi_Free(eqAig);
  }

  Ddi_Free(newaAig);


  Pdtutil_Free(eqClasses);
  Pdtutil_Free(activeClass);
  Pdtutil_Free(gCnfA);
  Pdtutil_Free(vCnfA);
  Pdtutil_Free(tCnfA);
  Pdtutil_Free(complEq);
  Pdtutil_Free(cexVal);
  Pdtutil_Free(newReps);

  Ddi_Free(vLits);
  Ddi_Free(vA);

  if (eq2 != NULL) {
    Ddi_BddXorAcc(eq2,eqAig);
    Ddi_BddXorAcc(a2,constr);

    Pdtutil_Assert(!Ddi_AigSat(eq2), "wrong equiv reduction");
    Pdtutil_Assert(!Ddi_AigSat(a2), "wrong equiv reduction");

    Ddi_Free(eq2);
  }
  Ddi_Free(a2);

  return(eqAig);

}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigConstRed (
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *constr,
  void *coreCl,
  void *cnfMappedV,
  int doRedRem,
  int maxGateWindow,
  int assertF,
  int checkOnlyRedPhase,
  void *nnfCoreMgrVoid,
  float timeLimit
)
{
  Ddi_Bdd_t *newaAig=NULL, *eqAig=NULL, *cof0Aig, *cof1Aig, *eq2 = NULL, *a2=NULL;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int i, j, iter, sat, nVars, nGates, nF, phase, jEnd;
  Ddi_Vararray_t *vA, *vAref;
  int myDbg = 0;
  int chkRes = 1;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int *eqClasses;
  int *potentialImpl;
  int nEq=0, nEqc=0, nEqC1=0, nEqI=0, startEqIndex=-1, eqFound=0,nCurrVars;
  int oldAlg=-1, refinementDone;
  int  constOnly=0;
  Solver    S;
  vec<Lit> lits;
  int *gCnfA, *outL;
  char *cexVal, *complEq, *activeGate;
  bAig_array_t *visitedNodes;
  int chkCircDep = 1;
  float activeRatio = 1.0;
  int nActive;
  int maxOutL;
  int abort=0;
  int reduceDone=0;
  int chooseOut=maxGateWindow<0;
  nnfCoreMgr_t *nnfCoreMgr = (nnfCoreMgr_t *)nnfCoreMgrVoid;
  int checkOnlyRedOne = checkOnlyRedPhase > 0;
  int checkOnlyRedZero = checkOnlyRedPhase < 0;
  vec<vec<Lit> > *coreClauses = (vec<vec<Lit> > *)coreCl;
  bAig_array_t *cnfMappedVars = (bAig_array_t *) cnfMappedV;

  vec<Lit> assumeClause, assumeSat;
  vec<vec<Lit> > splitClasses0, splitClasses1;

  static int ncalls=0;

  ncalls++;

  nF = Ddi_BddarrayNum(fA);
  if (nnfCoreMgr != NULL) {
    visitedNodes = nnfCoreMgr->aNodes;
  }
  else {
    visitedNodes = bAigArrayAlloc();
    for (i=0; i<nF; i++) {
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(fA,i);
      Ddi_PostOrderBddAigVisitIntern(f_i,visitedNodes,-1);
    }
    postOrderAigClearVisitedIntern(bmgr,visitedNodes);
    bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,-1);
  }

  nGates = visitedNodes->num;
  if (nGates<2) {
    if (nnfCoreMgr == NULL) {
      bAigArrayFree(visitedNodes);
    }
    return NULL;
  }
  if (maxGateWindow<=0) maxGateWindow = nGates+1;

  eqClasses = Pdtutil_Alloc(int,nGates+1);
  gCnfA = Pdtutil_Alloc(int,nGates+1);
  outL = Pdtutil_Alloc(int,nGates+1);
  activeGate = Pdtutil_Alloc(char,nGates+1);
  cexVal = Pdtutil_Alloc(char,nGates+1);
  complEq = Pdtutil_Alloc(char,nGates+1);

  for (i=0; i<nGates; i++) {
    bAigEdge_t baig = bAig_NonInvertedEdge(visitedNodes->nodes[i-1]);
    bAig_AuxInt(bmgr,baig) = 0; // fanout
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      bAigEdge_t right, left;
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      bAig_AuxInt(bmgr,right) = bAig_AuxInt(bmgr,right)+1;
      bAig_AuxInt(bmgr,left) = bAig_AuxInt(bmgr,left)+1;
    }
  }

  int nActiveTot=0;
  for (i=0; i<nGates+1; i++) {
    eqClasses[i] = (i==0)?0:-1;
    cexVal[i] = 0;
    complEq[i] = 0;
    activeGate[i] = (char)(i>0 && i<maxGateWindow ? 1 : 0);
    // active if is a gate with fanout 1 and input pin with fo>1
    if (activeGate[i]) {
      int fo, foR, foL;
      bAigEdge_t right, left;
      bAigEdge_t baig = bAig_NonInvertedEdge(visitedNodes->nodes[i-1]);
      if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
	activeGate[i] = 0;
	continue;
      }
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      fo = bAig_AuxInt(bmgr,baig);
      foR = bAig_AuxInt(bmgr,right);
      foL = bAig_AuxInt(bmgr,left);
      if (fo==1 || (foR==1 && foL==1)) {
	activeGate[i] = 0;
	continue;
      }
      nActiveTot++;
    }
  }
  nActive = nGates;
  aigArrayClearAuxIntIntern(bmgr,visitedNodes);

  /* load clauses to SAT manager */
  aig2CnfIdInit(ddm);

  if (cnfMappedVars!=NULL) {
    aig2CnfIdLoad(ddm,cnfMappedVars,0);
  }
  if (coreClauses!=NULL) {
    Pdtutil_Assert(cnfMappedVars!=NULL,"missing cnf var mapping");
    for (i=0; i<=cnfMappedVars->num; i++) {
      S.newVar();
    }
    for (i=0; i<coreClauses->size(); i++) {
      vec<Lit>& c = (*coreClauses)[i];
      S.addClause(c);
    }
  }
  if (constr!=NULL) {
    MinisatClauses(S,constr,NULL,NULL,0);
  }
  if (!assertF) {
    bAigArrayMinisatClausesWithNum(ddm, S, visitedNodes, 0, maxGateWindow);
  }
  else {
    bAigArrayMinisatClauses(ddm, S, visitedNodes, 0);
    for (i=0; i<nF; i++) {
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(fA,i);
      bAigEdge_t baig = Ddi_BddToBaig(f_i);
      int fCnf = DdiAig2CnfIdSigned(bmgr,baig);
      MinisatClause1(S,lits,fCnf);
    }
  }
  if (nnfCoreMgr!=NULL) {
    int nv = Ddi_VararrayNum(nnfCoreMgr->rV);
    for (i=0; i<nv; i++) {
      Ddi_Var_t *r_i = Ddi_VararrayRead(nnfCoreMgr->rV,i);
      Ddi_Var_t *a0_i = Ddi_VararrayRead(nnfCoreMgr->aV0,i);
      Ddi_Var_t *a1_i = Ddi_VararrayRead(nnfCoreMgr->aV1,i);
      bAigEdge_t vR = Ddi_VarToBaig(r_i);
      bAigEdge_t vA0 = Ddi_VarToBaig(a0_i);
      bAigEdge_t vA1 = Ddi_VarToBaig(a1_i);
      int rCnf = aig2CnfId(bmgr,vR);
      int a0Cnf = aig2CnfId(bmgr,vA0);
      int a1Cnf = aig2CnfId(bmgr,vA1);
      vec<Lit> lits;
      /* r -> !a0 */
      MinisatClause2(S,lits,-rCnf,-a0Cnf);
      /* !r -> !a1 */
      MinisatClause2(S,lits,rCnf,-a1Cnf);
    }
  }

  assumeClause.clear();

  maxOutL = bAigArraySetOutLevels(ddm, visitedNodes, fA);

  for (i=0; i<=nGates; i++) {
    if (i==0) {
      gCnfA[i] = -1; /* dummy */
    }
    else {
      bAigEdge_t baig = bAig_NonInvertedEdge(visitedNodes->nodes[i-1]);
      gCnfA[i] = aig2CnfId(bmgr,baig);
      outL[i] = bAig_AuxInt(bmgr,baig);
    }
  }
  aigArrayClearAuxIntIntern(bmgr,visitedNodes);

  iter=0;

  long startTimeTot = util_cpu_time();

  do {
    int id;
    refinementDone = 0;
    iter++;
    /* call SAT solver assuming at least one refinement */
    if ((sat = S.okay())) {
      sat = S.solve();
    }

    if (sat) {
      int vSolver, vCnf;
      int splitDone = 0;
      int limit0=0, limit1=0;
      if (timeLimit > 0) {
	limit0 = (util_cpu_time()-startTimeTot)/1000 > timeLimit/2;
	limit1 = (util_cpu_time()-startTimeTot)/1000 > timeLimit;
      }

      if (limit1) {
	abort=1;
	break;
      }

      if (!reduceDone && ((iter>0 && limit0)
			  || iter==10 && (assumeClause.size()>maxGateWindow))) {
	int nAlive=assumeClause.size();
	int nObs=0, avgRedL=0, nA=0;
	float alpha;
	int ref = nGates/2;
	activeRatio = ((float)maxGateWindow) / assumeClause.size();
	nActive=0;
	reduceDone = 1;
	for (i=1; i<=nGates; i++) {
	  if (!activeGate[i]) continue;
	  if (eqClasses[i]==0) {
	    avgRedL += (outL[i]);
	    nA++;
	  }
	}
        if (nA>0) avgRedL /= nA;

	for (i=nGates-1; i>0; i--) {
	  if (!activeGate[i]) continue;
	  if (eqClasses[i]<-1) continue; // skip gate
	  //	  activeGate[i] = (char)(rand()%1000 < activeRatio*1000);
	  //	  activeGate[i] = (char)(nObs>maxGateWindow && nActive<maxGateWindow);
	  alpha = (1.0 - abs(i-ref)/(float)ref) * 2.0;
	  // activeGate[i] = (char)(rand()%1000 < alpha*activeRatio*1000);
	  if (chooseOut) 
	    activeGate[i] = outL[i]<10;
	  else {
	    activeGate[i] = outL[i]>avgRedL;
	    //	    timeLimit *= 5;
	  }
	  nObs++;
	  if (activeGate[i]) {
	    nActive++;
	  }
	  else {
	    eqClasses[i]=-2;
	  }
	}
	if (verbosity > Pdtutil_VerbLevelUsrMax_c) {
	  printf("redrem refinement %d/%d (%d) active/alive gate window\n", 
		 nActive, nObs, nGates);
	}
      }

      assumeClause.clear();

      if (myDbg) {
	printf("CEX: ");
	for (i=1; i<=nGates; i++) {
	  /* copy cex */
	  int vSolver = gCnfA[i]-1;
	  if (S.model[vSolver]==l_True) {
	    fprintf(dMgrO(ddm),"1");
	  }
	  else if (S.model[vSolver]==l_False) {
	    fprintf(dMgrO(ddm),"0");
	  }
	}
	printf("\n");
      }
      for (i=1; i<=nGates; i++) {
	if (!activeGate[i]) continue;
	if (eqClasses[i]<-1) continue; // skip gate
	if (i>0) {
	  /* copy cex */
	  int vSolver = gCnfA[i]-1;
	  if (S.model[vSolver]==l_True) {
	    cexVal[i]=1;
	  }
	  else if (S.model[vSolver]==l_False) {
	    cexVal[i]=0;
	  }
	  else {
	    Pdtutil_Assert(0,"wrong model value");
	  }
	}
	if (eqClasses[i] == -1) {
	  int isOr = nnfCoreMgr==NULL ? 1 : nnfCoreMgr->gateType[i-1] == 'O';
          if (checkOnlyRedOne && (cexVal[i]==isOr?1:0)) {
            /* just disable */
            eqClasses[i] = -2;
            splitDone = 1;
          }
          else if (checkOnlyRedZero && (cexVal[i]==isOr?0:1)) {
            /* just disable */
            eqClasses[i] = -2;
            splitDone = 1;
          }
          else {
            /* not yet assigned: put in const class */
            int myCnf;
            eqClasses[i] = 0;
            complEq[i] = cexVal[i];
            myCnf = complEq[i] ? -gCnfA[i] : gCnfA[i];
            assumeClause.push(MinisatLit(myCnf));
            splitDone = 1;
          }
	}
	else {
	  /* class member: get representative */
	  int isCompl = complEq[i];
	  int rep_i = eqClasses[i];
	  Pdtutil_Assert(rep_i==0,"wrong const class rep");
	  if (cexVal[i] != (isCompl?1:0)) {
	    /* split */
	    splitDone = 1;
	    eqClasses[i] = -2; // removed
	  }
	  else {
	    /* keep in class */
	    int myCnf = complEq[i] ? -gCnfA[i] : gCnfA[i];
	    assumeClause.push(MinisatLit(myCnf));
	  }
	}
      }

      if (0 && iter%50==0 && doRedRem) {
	int avgRedId=0, minRedId=-1, maxRedId=-1;
	int avgRedL=0, minRedL=-1, maxRedL=-1;
	for (i=1; i<=nGates; i++) {
	  if (!activeGate[i]) continue;
	  if (eqClasses[i]==0) {
	    avgRedId += (i-1);
	    avgRedL += (outL[i]);
	    if (minRedId<0) minRedId = i-1;
	    if (minRedL<0 || minRedL>outL[i]) minRedL = outL[i];
	    maxRedId = i-1;
	    if (maxRedL<0 || maxRedL<outL[i]) maxRedL = outL[i];
	  }
	}
	avgRedId /= assumeClause.size();
	avgRedL /= assumeClause.size();
	Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	  fprintf(dMgrO(ddm),
		  "SAT iteration %d - active: %d min/avg/max red id: %d/%d/%d",
		  iter, assumeClause.size(), minRedId, avgRedId, maxRedId);
	  fprintf(dMgrO(ddm),
		  " - minL/avgL/maxL: %d/%d/%d (%d)\n",
		  minRedL, avgRedL, maxRedL, maxOutL);
	}

      }

      if (myDbg) {
	printf("*************\n");
      }
      Pdtutil_Assert(1||splitDone||reduceDone, "no split with SAT");

      if (verbosity > Pdtutil_VerbLevelDevMed_c) {
	printf("redrem refinement (#g: %d) %d -> red#: %d\n", nActive, iter, assumeClause.size());
      }
      S.addClause(assumeClause);

      refinementDone = 1;
    }
  } while (refinementDone);

  for (j=1; !abort && j<=nGates; j++) {
    if (eqClasses[j]==0) {
      nEqc++; eqFound = 1;
    }
  }

  aig2CnfIdClose(ddm);

  Ddi_Bdd_t *redAig = Ddi_BddMakePartConjVoid(ddm); 

  if (eqFound) {
    int avgRedId=0, minRedId=-1, maxRedId=-1;
    for (i=1; i<=nGates; i++) {
      if (!activeGate[i]) continue;
      if (eqClasses[i]==0) {
	int isCompl = complEq[i];
	bAigEdge_t baig = bAig_NonInvertedEdge(visitedNodes->nodes[i-1]);
	Ddi_Bdd_t *f_i = Ddi_BddMakeFromBaig(ddm,baig);
	if (!isCompl) Ddi_BddNotAcc(f_i);
	Ddi_BddPartInsertLast(redAig,f_i);
	Ddi_Free(f_i);
	avgRedId += (i-1);
	if (minRedId<0) minRedId = i-1;
	maxRedId = i-1;
      }
    }
    avgRedId /= nEqc;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      fprintf(dMgrO(ddm),"min/avg/max red id: %d/%d/%d\n",
	      minRedId, avgRedId, maxRedId);
    }
  }

  if (nnfCoreMgr == NULL) {
    bAigArrayFree(visitedNodes);
  }

  if (chkRes && eqFound) {
  }

  if (nEqc>0) {
    int size0 = Ddi_BddarraySize(fA);
    int n=Ddi_BddPartNum(redAig);
    int useOdcAssume = 1 && doRedRem;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      fprintf(dMgrO(ddm),"FOUND %d const REDUNDANCIES\n", nEqc);
    }

    Ddi_Bddarray_t *simplA, *redA = Ddi_BddarrayMakeFromBddPart(redAig);
    if (useOdcAssume) {
      if (0) {
        for (int i=0; i<Ddi_BddarrayNum(redA); i++) {
          Ddi_Bdd_t *f_i = Ddi_BddarrayRead(redA,i);
          Pdtutil_Assert(Ddi_BddIncluded(constr,f_i),"red problem");
        }
      }
      simplA = Ddi_AigarrayStructRedRemOdcWithAssume (fA,redA,
                   nnfCoreMgrVoid);
      if (doRedRem) {
        Ddi_DataCopy(fA,simplA);
      }
    }
    else {
      if (doRedRem) {
        Ddi_BddarrayAppend(redA,fA);
      }
      simplA = Ddi_AigarrayStructRedRem (redA,NULL,n);
      if (doRedRem) {
        for (i=Ddi_BddarrayNum(fA)-1; i>=0; i--) {
          Ddi_Bdd_t *f_i = Ddi_BddarrayExtract(simplA,n+i);
          Ddi_BddarrayWrite(fA,i,f_i);
          Ddi_Free(f_i);
        }
      }
    }
    Ddi_Free(redAig);
    if (useOdcAssume) {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        fprintf(dMgrO(ddm),"reduced F size %d -> %d\n",
                size0, Ddi_BddarraySize(fA));
      }
    }
    else {
      redAig = Ddi_BddMakePartConjFromArray(simplA);
      Ddi_Free(redA);
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        fprintf(dMgrO(ddm),"red size: %d - F size %d -> %d\n",
                Ddi_BddSize(redAig), size0, Ddi_BddarraySize(fA));
      }
    }
    Ddi_Free(simplA);

  }
  else {
    Ddi_Free(redAig);
  }


  Pdtutil_Free(eqClasses);
  Pdtutil_Free(gCnfA);
  Pdtutil_Free(outL);
  Pdtutil_Free(activeGate);
  Pdtutil_Free(complEq);
  Pdtutil_Free(cexVal);

  if (redAig!=NULL && maxGateWindow<nGates/5) {
    if (doRedRem>1) {
      Ddi_Bdd_t *redAig2 = Ddi_AigConstRed (fA,constr,NULL, NULL,
         doRedRem-1, maxGateWindow, assertF, 0, NULL, -1.0);
      if (redAig2!=NULL) {
	if (Ddi_BddIsPartConj(redAig2)) {
	  int j;
	  Ddi_BddSetPartConj(redAig);
	  for (j=0;j<Ddi_BddPartNum(redAig2); j++) {
	    Ddi_BddPartInsertLast(redAig,Ddi_BddPartRead(redAig2,j));
	  }
	}
	else {
	  Ddi_BddAndAcc(redAig,redAig2);
	}
	Ddi_Free(redAig2);
      }
    }
  }

  return(redAig);

}



/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigEquivVarsAcc2 (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *refVars,
  Ddi_Varset_t *filterVars,
  Ddi_Bdd_t *auxEqMerge,
  Ddi_Vararray_t *eqVars,
  Ddi_Bddarray_t *substLits
)
{
  Ddi_Bdd_t *newaAig=NULL, *eqAig=NULL, *cof0Aig, *cof1Aig;
  Ddi_Bddarray_t *vLits, *vAuxLits;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int i, j, sat, nVars, phase, jEnd;
  Ddi_Vararray_t *vA, *vAref;
  int size0 = Ddi_BddSize(a);
  int myDbg = 0;
  int chkRes = 1;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  Ddi_Varset_t *supp, *suppRef=NULL;
  int nEq=0, nEqc=0, startEqIndex=-1, eqFound=0,nCurrVars;
  int oldAlg=-1, refinementDone;
  int  constOnly=0;
  Solver    S;
  vec<Lit> lits;
  int nRef = -1;
  vec<Lit> assumeClause, assumeSat;
  vec<vec<Lit> > splitClasses[2];

  static int ncalls=0;

  ncalls++;

  if (oldAlg==0)
    return DdiAigEquivVarsAcc0(a,care,refVars,filterVars,auxEqMerge,
			       eqVars,substLits);
  else if (oldAlg==1)
    return DdiAigEquivVarsAcc1(a,care,refVars,filterVars,auxEqMerge,
			       eqVars,substLits);

  supp = Ddi_BddSupp(a);

  if (refVars != NULL) {
    suppRef = Ddi_VarsetIntersect(supp,refVars);
    vAref = Ddi_VararrayMakeFromVarset(suppRef,1);
    Ddi_VarsetDiffAcc(supp,suppRef);
    Ddi_Free(suppRef);
  }

  if (filterVars != NULL) {
    Ddi_VarsetIntersectAcc(supp,filterVars);
  }

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  if (refVars != NULL) {
    nRef = Ddi_VararrayNum(vAref);
    Ddi_VararrayAppend(vAref,vA);
    Ddi_Free(vA);
    vA = vAref;
  }

  vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
  Ddi_Free(supp);
  nVars = Ddi_VararrayNum(vA);

  if (nVars>0) {

    Pdtutil_EqClasses_t *eqCl = Pdtutil_EqClassesAlloc(nVars+1);

    /* all menbers unassigned and classes not active */
    Pdtutil_EqClassesReset(eqCl);
    /* define constant class */
    Pdtutil_EqClassSetLdr(eqCl,0,0);

    eqAig = Ddi_BddMakePartConjVoid(ddm);
    splitClasses[0].clear();
    splitClasses[0].growTo(nVars+1);
    splitClasses[1].clear();
    splitClasses[1].growTo(nVars+1);

    for (i=0; i<nVars+1; i++) {
      vec<Lit> splitClass;
      splitClass.clear();

      splitClass.copyTo(splitClasses[0][i]);
      splitClass.copyTo(splitClasses[1][i]);
    }


    /* load clauses to SAT manager */
    aig2CnfIdInit(ddm);

    MinisatClauses(S,a,NULL,NULL,0);
    if (care != NULL) {
      MinisatClauses(S,care,NULL,NULL,0);
    }
    for (i=0; i<Ddi_VararrayNum(vA); i++) {
      MinisatClauses(S,Ddi_BddarrayRead(vLits,i),NULL,NULL,1);
    }

    /* generate activation vars and clause */
    assumeClause.clear();

    for (i=0; i<=nVars; i++) {
      int actV;
      if (i==0) {
        Pdtutil_EqClassCnfVarWrite(eqCl,0,-1); /* dummy */
      }
      else {
	Ddi_Var_t *v_i = Ddi_VararrayRead(vA,i-1);
	bAigEdge_t varIndex = Ddi_VarToBaig(v_i);
        Pdtutil_EqClassCnfVarWrite(eqCl,i,aig2CnfId(bmgr,varIndex));
      }
      /*  activation var */
      S.newVar();
      actV = S.nVars();
      Pdtutil_EqClassCnfActWrite(eqCl,i,actV);
      /* at least one class split */
      assumeClause.push(MinisatLit(actV));
    }
    S.addClause(assumeClause);

    /* initially no assumptions */
    assumeSat.clear();

    do {
      int id;
      refinementDone = 0;

      /* call SAT solver assuming at least one refinement */
      if ((sat = S.okay())) {
	sat = S.solve(assumeSat);
      }

      if (sat) {
	int vSolver, vCnf, actCnf;
	int splitNum = Pdtutil_EqClassesSplitNum(eqCl);

	ncalls++;
	assumeSat.clear();

	if (myDbg) {
	  printf("CEX: ");
	  for (i=1; i<=nVars; i++) {
	    /* copy cex */
	    int vSolver = Pdtutil_EqClassCnfVarRead(eqCl,i)-1;
	    if (S.model[vSolver]==l_True) {
	      printf("1");
	    }
	    else if (S.model[vSolver]==l_False) {
	      printf("0");
	    }
	  }
	  printf("\n");
	}

	for (i=1; i<=nVars; i++) {
	  if (i>0) {
	    /* copy cex */
	    int vSolver = Pdtutil_EqClassCnfVarRead(eqCl,i)-1;
	    if (S.model[vSolver]==l_True) {
	      Pdtutil_EqClassSetVal(eqCl,i,1);
	    }
	    else if (S.model[vSolver]==l_False) {
	      Pdtutil_EqClassSetVal(eqCl,i,0);
	    }
	    else {
	      Pdtutil_Assert(0,"wrong model value");
	    }
	  }
	}

	/* constant class */
	actCnf = Pdtutil_EqClassCnfActRead(eqCl,0);
	vCnf = Pdtutil_EqClassCnfVarRead(eqCl,0);
	splitClasses[0][0].clear();
	/* init split activation clause */
	/* actCnf[0] => (... | ... | ...) */
	splitClasses[0][0].push(MinisatLit(-actCnf));

	for (i=1; i<=nVars; i++) {
	  int myCnf, ldr_i;

	  actCnf = Pdtutil_EqClassCnfActRead(eqCl,i);
	  vCnf = Pdtutil_EqClassCnfVarRead(eqCl,i);

	  splitClasses[0][i].clear();
	  splitClasses[1][i].clear();

	  switch (Pdtutil_EqClassUpdate(eqCl,i)) {

	    case Pdtutil_EqClass_JoinConst_c:
	      /* not yet assigned: proper const class joined */
	      myCnf = Pdtutil_EqClassIsCompl(eqCl,i) ? -vCnf : vCnf;
	      splitClasses[0][0].push(MinisatLit(myCnf));
	      // NOT NECESSARY !
	      // splitClasses1[0].push(MinisatLit(-myCnf));
	      break;
	    case Pdtutil_EqClass_SplitLdr_c:
	    case Pdtutil_EqClass_Ldr_c:
	      /* existing or new class leader */
	      /* init split activation clauses */
	      /* actCnf => (!vCnf => (... | ... | ...)) */
	      splitClasses[0][i].push(MinisatLit(-actCnf));
	      splitClasses[0][i].push(MinisatLit(vCnf));
	      /* actCnfA[i] => (vCnfA[i] => (... | ... | ...)) */
	      splitClasses[1][i].push(MinisatLit(-actCnf));
	      splitClasses[1][i].push(MinisatLit(-vCnf));
	      break;
	    case Pdtutil_EqClass_JoinSplit_c:
	    case Pdtutil_EqClass_SameClass_c:
	      ldr_i = Pdtutil_EqClassLdr(eqCl,i);
	      Pdtutil_Assert(ldr_i>=0&&ldr_i<=nVars,"wrong class leader index");
	      myCnf = Pdtutil_EqClassIsCompl(eqCl,i) ? -vCnf : vCnf;
	      /* ask value different from leader (in OR with other members) */
	      splitClasses[0][ldr_i].push(MinisatLit(myCnf));
	      splitClasses[1][ldr_i].push(MinisatLit(-myCnf));
	      break;
	    case Pdtutil_EqClass_None_c:
	    default:
	      Pdtutil_Assert(0, "wrong class state");
	      break;
	  }
	}

	if (myDbg) {
	  printf ("*************\n");
	}

	for (i=0; i<=nVars; i++) {
	  actCnf = Pdtutil_EqClassCnfActRead(eqCl,i);
	  if (!Pdtutil_EqClassIsLdr(eqCl,i) ||
	       Pdtutil_EqClassNum(eqCl,i)==0) {
	    /* not a class: disable split guard */
	    assumeSat.push(MinisatLit(-actCnf));
	    if (myDbg) {
	      printf("A: %d\n",-actCnf);
	    }
	  }
	  else {
	    Pdtutil_Assert(Pdtutil_EqClassNum(eqCl,i)>0,"zero class");
	    Pdtutil_Assert (splitClasses[0][i].size()>=((i==0)?1:2),
			  "wrong clause num");
	    if (splitClasses[0][i].size()==((i==0)?1:2)) {
	    /* singleton class generated by split: disable split */
	      Pdtutil_Assert(Pdtutil_EqClassNum(eqCl,i)==1||i==0,"zero class");
	      MinisatClause1(S,lits,-actCnf);
	      if (myDbg) {
		printf("C: %d\n",-actCnf);
	      }
	    }
	    else {
	      int k;
	      /* active class with at least 2 elements: enable split */
	      S.addClause(splitClasses[0][i]);
	      if (i>0) {
		S.addClause(splitClasses[1][i]);
	      }
	      if (myDbg) {
		printf("OR: ");
		for (k=0; k<splitClasses[0][i].size(); k++) {
		  int v = var(splitClasses[0][i][k]);
		  int s = sign(splitClasses[0][i][k]);
		  printf("%s%d ", s?"-":"",v+1);
		}
		printf("\n");
	      }
	    }
	  }
	}
	if (myDbg) {
	  printf ("*+++++++++++*\n");
	}

	splitNum = Pdtutil_EqClassesSplitNum(eqCl) - splitNum;

	Pdtutil_EqClassesSplitLdrReset(eqCl);

	Pdtutil_Assert(splitNum>0, "no split with SAT");
	refinementDone = 1;
      }
    } while (refinementDone);

    for (j=1; j<=nVars; j++) {
      if (!Pdtutil_EqClassIsLdr(eqCl,j)) {
	int ldr_j = Pdtutil_EqClassLdr(eqCl,j);
	if (nRef<0 || (j>=nRef && ldr_j<nRef)) {
	  if (ldr_j==0) nEqc++;
	  else nEq++;
	  eqFound = 1;
	}
      }
    }

    aig2CnfIdClose(ddm);

    nCurrVars=nVars;
    if (eqFound) {
      Ddi_Bdd_t *zeroAig = Ddi_BddMakeConstAig(ddm,0);
      Ddi_Bdd_t *oneAig = Ddi_BddMakeConstAig(ddm,1);

      for (i=1; i<=nVars; i++) {
	if (!Pdtutil_EqClassIsLdr(eqCl,i)) {
	  Ddi_Bdd_t *refLit=NULL, *eq=NULL;
	  int ldr_i = Pdtutil_EqClassLdr(eqCl,i);
	  int isCompl = Pdtutil_EqClassIsCompl(eqCl,i);
	  if (nRef>=0 && (i>=nRef && ldr_i>=nRef)) continue;
	  if (ldr_i == 0) {
	    /* constant 0 class */
	    refLit = Ddi_BddMakeConstAig(ddm,isCompl);
	    // printf("%s - %d\n",
	    // Ddi_VarName(Ddi_VararrayRead(vA,i-1)), !isCompl);
	  }
	  else if (constOnly) {
	    continue;
	  }
	  else {
	    /* var equiv */
	    Ddi_Var_t *vRef = Ddi_VararrayRead(vA,ldr_i-1);
	    refLit = Ddi_BddMakeLiteralAig(vRef, !isCompl);
	    //	  printf("%s - %s %s\n", Ddi_VarName(Ddi_VararrayRead(vA,i-1)),
	    //	 isCompl?"!":"", Ddi_VarName(vRef));
	  }
	  eq = Ddi_BddXnor(Ddi_BddarrayRead(vLits,i-1),refLit);

	  Ddi_BddarrayWrite(vLits,i-1,refLit);
	  Ddi_BddPartInsertLast(eqAig,eq);
	  nCurrVars--;
	  Ddi_Free(eq);
	  Ddi_Free(refLit);
	}
      }
      Ddi_BddSetAig(eqAig);
      newaAig = Ddi_BddCompose(a,vA,vLits);
      if (auxEqMerge != NULL) {
	Ddi_BddComposeAcc(auxEqMerge,vA,vLits);
      }
      Ddi_Free(zeroAig);
      Ddi_Free(oneAig);
    }

    if (chkRes && eqFound) {
      Ddi_Bdd_t *chk = Ddi_BddAnd(eqAig,newaAig);

      if (myDbg) {
	printf("VARS: ");
	for (i=1; i<=nVars; i++) {
	  printf("%s ", Ddi_VarName(Ddi_VararrayRead(vA,i-1)));
	}
	printf("\n");
	printf("EQ: ");
	for (i=1; i<=nVars; i++) {
	  printf("%d ", Pdtutil_EqClassLdr(eqCl,i));
	}
	printf("\n");
	printf("CM: ");
	for (i=1; i<=nVars; i++) {
	  printf("%d ", Pdtutil_EqClassIsCompl(eqCl,i));
	}
	printf("\n");
      }

      Ddi_BddXorAcc(chk,a);
      if (care != NULL) {
	Ddi_BddAndAcc(chk,care);
      }
      Pdtutil_Assert(!Ddi_AigSat(chk), "wrong equiv reduction");
      Ddi_Free(chk);
    }

    if (nEq>0 || nEqc>0) {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      fprintf(stdout, "FOUND %d(%d const) EQUIVALENCES - size %d -> %d\n",
        nEq+nEqc, nEqc, Ddi_BddSize(a), Ddi_BddSize(newaAig));
      }
      Ddi_DataCopy(a,newaAig);
    }
    else {
      Ddi_Free(eqAig);
    }

    Ddi_Free(newaAig);

    if (eqVars != NULL) {
      Pdtutil_Assert(substLits!=NULL,"NULL substLits array");
      Pdtutil_Assert(Ddi_VararrayNum(vA)==Ddi_BddarrayNum(vLits),
		     "variable and bdd arrays of different length");
      for (i=0; i<Ddi_VararrayNum(vA); i++) {
	if (Pdtutil_EqClassIsLdr(eqCl,i)) {
	  Ddi_VararrayInsertLast(eqVars,Ddi_VararrayRead(vA,i));
	  Ddi_BddarrayInsertLast(substLits,Ddi_BddarrayRead(vLits,i));
	}
      }
    }

    Pdtutil_EqClassesFree(eqCl);

  }

  Ddi_Free(vLits);
  Ddi_Free(vA);

  return(eqAig);

}



/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigImplicationsAcc (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *refVars,
  Ddi_Varset_t *filterVars,
  Ddi_Bddarray_t *implArray
)
{
  Ddi_Bdd_t *newaAig, *implAig, *cof0Aig, *cof1Aig;
  bAig_array_t *visitedNodes;
  Ddi_Bddarray_t *vLits, *vAuxLits;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int i, j, sat, nVars;
  Ddi_Vararray_t *vA;
  int size0 = Ddi_BddSize(a);
  int myDbg = 0;
  int chkRes = 0;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int *eqClasses, *eqId;
  Ddi_Varset_t *supp;
  int nEq=0, startEqIndex=-1;
  Ddi_Varset_t *chkVars;

  supp = Ddi_BddSupp(a);

  if (filterVars != NULL) {
    Ddi_VarsetIntersectAcc(supp,filterVars);
  }
  if (refVars != NULL) {
    Ddi_Vararray_t *other;
    chkVars = Ddi_VarsetDiff(supp,refVars);
    Ddi_VarsetIntersectAcc(supp,refVars);
    vA = Ddi_VararrayMakeFromVarset(supp,1);
    other = Ddi_VararrayMakeFromVarset(chkVars,1);
    startEqIndex = Ddi_VararrayNum(vA);
    Ddi_VararrayAppend(vA,other);
    Ddi_Free(other);
  }
  else {
    vA = Ddi_VararrayMakeFromVarset(supp,1);
    chkVars = Ddi_VarsetDup(supp);
  }
  vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
  Ddi_Free(supp);
  nVars = Ddi_VararrayNum(vA);

  eqId = Pdtutil_Alloc(int,nVars);
  eqClasses = Pdtutil_Alloc(int,nVars);
  implAig = Ddi_BddMakeConst(ddm,1);
  Ddi_BddSetAig(implAig);

  for (i=0; i<nVars; i++) {
    eqClasses[i] = i;
  }

  for (i=0; i<(startEqIndex>=0?startEqIndex:nVars)/* && nEq == 0 */; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Bdd_t *c0, *c1;
    int eq = 0;
    Ddi_VarsetRemoveAcc(chkVars,v);
    if (eqClasses[i]!=i) continue;
    cof0Aig = Ddi_BddCofactor(a,v,0);
    c0 = DdiAigImpliedVarsAcc(cof0Aig,care,chkVars);
    cof1Aig = Ddi_BddCofactor(a,v,1);
    c1 = DdiAigImpliedVarsAcc(cof1Aig,care,chkVars);
    if (c0 != NULL) {
      Ddi_Bdd_t *impl = Ddi_BddMakeLiteral(v, 1);
      if (implArray != NULL) {
	Ddi_Bdd_t *p = Ddi_BddMakeAig(impl);
	Ddi_BddSetPartDisj(p);
	Ddi_BddPartInsertLast(p,c0);
	Ddi_BddarrayInsertLast(implArray,p);
	Ddi_Free(p);
      }
      Ddi_BddSetMono(c0);
      Ddi_BddOrAcc(impl,c0);
      Ddi_BddSetAig(impl);
      Ddi_BddAndAcc(implAig,impl);
      Ddi_Free(impl);
    }
    if (c1 != NULL) {
      Ddi_Bdd_t *impl = Ddi_BddMakeLiteral(v, 0);
      if (implArray != NULL) {
	Ddi_Bdd_t *p = Ddi_BddMakeAig(impl);
	Ddi_BddSetPartDisj(p);
	Ddi_BddPartInsertLast(p,c1);
	Ddi_BddarrayInsertLast(implArray,p);
	Ddi_Free(p);
      }
      Ddi_BddSetMono(c1);
      Ddi_BddOrAcc(impl,c1);
      Ddi_BddSetAig(impl);
      Ddi_BddAndAcc(implAig,impl);
      Ddi_Free(impl);
    }
    Ddi_Free(c0);
    Ddi_Free(c1);
    Ddi_Free(cof0Aig);
    Ddi_Free(cof1Aig);
  }

  Ddi_BddSetAig(implAig);

  if (chkRes) {
    Ddi_Bdd_t *chk = Ddi_BddDiff(a,implAig);
    if (care != NULL) {
      Ddi_BddAndAcc(chk,care);
    }
    Pdtutil_Assert(!Ddi_AigSat(chk), "wrong implication reduction");
    Ddi_Free(chk);
  }

  if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),"\nIMPLICATION extraction size %d\n", Ddi_BddSize(implAig));
  }

  Pdtutil_Free(eqClasses);
  Ddi_Free(chkVars);
  Ddi_Free(vLits);
  Ddi_Free(vA);

  return(implAig);

}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigImpliedVarsAcc (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *filterVars
)
{
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newaAig, *cof0Aig, *cof1Aig, *notaAig;
  bAig_array_t *visitedNodes;
  Ddi_Bddarray_t *vLits, *vAuxLits;
  bAigEdge_t varIndex, auxVarIndex, aBaig, bBaig, careBaig, cof0, cof1, f0, f1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int extRef = Ddi_MgrReadExtRef(ddm);
  int i, j, sat, nVars;
  Ddi_Vararray_t *vA, *vAuxA;
  Ddi_Bdd_t *prod;
  int assumeSingleExist, *assumeExist;
  int *redCodeBits=NULL;
  int redCodeSize, refinementDone, nCurrVars;
  int checkSingleExist;
  int checkFunction = 1;
  int doTernaryB = 0;
  Ddi_Bdd_t *myB=NULL;
  int size0 = Ddi_BddSize(a);
  int checkMonotonicity = 0;
  int myDbg = 0;
  int chkRes = 0;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  Ddi_Vararray_t *piNodes;
  Ddi_Varset_t *piSet;
  int nPi, *piCnfIds=NULL;
  int nCached = 0, nRefLoops=0;
  Ddi_Bdd_t *impliedCube=NULL;

  Solver    S;
  vec<Lit> lits, assumeSingleExistArray, assumeClause;
  vec<Lit> prevCex;
  int prevCexUsed = 0;

  Ddi_Varset_t *supp;

  bmgr = ddm->aig.mgr;
  aBaig = Ddi_BddToBaig(a);
  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }

  supp = Ddi_BddSupp(a);
  impliedCube = Ddi_BddMakeConstAig(ddm,1);

  if (filterVars != NULL) {
    if (Ddi_VarsetIsArray(filterVars)) {
      Ddi_VarsetSetArray(supp);
    }
    Ddi_VarsetIntersectAcc(supp,filterVars);
  }
  vA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_Free(supp);

  newaAig = Ddi_BddDup(a);
  vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);

  nVars = Ddi_VararrayNum(vA);
  nCurrVars = 2*nVars;

  if (nVars == 0) {
    Ddi_Free(vA);
    Ddi_Free(newaAig);
    Ddi_Free(vLits);
    Ddi_Free(impliedCube);
    return(NULL);
  }

  if (care != NULL) {
    Ddi_BddAndAcc(newaAig,care);
  }

  /* load clauses to SAT manager */
  aig2CnfIdInit(ddm);

  MinisatClauses(S,newaAig,NULL,NULL,0);
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    MinisatClauses(S,Ddi_BddarrayRead(vLits,i),NULL,NULL,1);
  }

  S.newVar();
  assumeSingleExist = S.nVars();
  assumeSingleExistArray.clear();
  assumeSingleExistArray.push(MinisatLit(assumeSingleExist));
  assumeClause.clear();

  if (myDbg)
    fprintf(dMgrO(ddm),"ASE: %d\n", assumeSingleExist);

  assumeExist = Pdtutil_Alloc(int, 2*nVars);

  for (i=0; i<nVars; i++) {
    int k, mask, vCnf, vAuxCnf, tCnf0, tCnf1;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    int i0 = 2*i;
    int i1 = 2*i+1;
    varIndex = Ddi_VarToBaig(v);
    vCnf = aig2CnfId(bmgr,varIndex);

    S.newVar();
    tCnf0 = assumeExist[i0] = S.nVars();
    S.newVar();
    tCnf1 = assumeExist[i1] = S.nVars();

    if (myDbg)
      fprintf(dMgrO(ddm),"I:%d - v:%d, v0:%d, t0:%d, t1:%d\n",
        i, vCnf, vAuxCnf, tCnf0, tCnf1);

    assumeClause.push(MinisatLit(tCnf0));
    assumeClause.push(MinisatLit(tCnf1));

    /* tCnf0 => !vCnf */
    MinisatClause2(S,lits,-tCnf0,-vCnf);
    /* tCnf1 => vCnf */
    MinisatClause2(S,lits,-tCnf1,vCnf);

    /* !tCnf0 + !tCnf1 => free */

  }

  S.addClause(assumeClause);
  checkSingleExist = 1;

  prevCexUsed = 0;
  prevCex.clear();
  assumeSingleExistArray.copyTo(prevCex);

  nPi = nVars;
  piCnfIds = Pdtutil_Alloc(int,nVars);

  for (i=0; i<nVars; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    bAigEdge_t baig = Ddi_VarToBaig(v);
    piCnfIds[i] = aig2CnfId(bmgr,baig);
  }

  do {
    int id;
    refinementDone = 0;

    /* call SAT solver assuming at least one refinement */
    if ((sat = S.okay())) {
      sat = S.solve();
    }

    if (sat) {
      /* a non redundant ternary node has been found: fix it and iterate */
      int k, mask, redIndex=0;
      Lit wireLit;
      int t, tCnf;

      int found = 0;
      for (i=0; i<2*nVars; i++) {
        tCnf = assumeExist[i];
        if (tCnf < 0) continue;

        t = tCnf - 1;

        if (S.model[t]!=l_True) continue;

        MinisatClause1(S,lits,-tCnf);
        assumeExist[i] = -1; /* disable it !!! */
        nCurrVars--;
        found = 1;
      }
      Pdtutil_Assert(found,"no enabled control found");
      refinementDone = 1;
      nRefLoops++;
    }

  } while (refinementDone);

  aig2CnfIdClose(ddm);
  Ddi_Free(newaAig);
  newaAig = Ddi_BddDup(a);
  nCurrVars = nVars;
  {
    Ddi_Bdd_t *zeroAig = Ddi_BddMakeConstAig(ddm,0);
    Ddi_Bdd_t *oneAig = Ddi_BddMakeConstAig(ddm,1);

    for (i=0; i<nVars; i++) {
      int tCnf;
      Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
      if ((tCnf = assumeExist[2*i]) >= 0) {
        Ddi_BddAndAcc(impliedCube,Ddi_BddarrayRead(vLits,i));
	Ddi_BddarrayWrite(vLits,i,oneAig);
	nCurrVars--;
      }
      else if ((tCnf = assumeExist[2*i+1]) >= 0) {
        Ddi_BddDiffAcc(impliedCube,Ddi_BddarrayRead(vLits,i));
	Ddi_BddarrayWrite(vLits,i,zeroAig);
	nCurrVars--;
      }
    }
    Ddi_BddComposeAcc(newaAig,vA,vLits);
    Ddi_Free(zeroAig);
    Ddi_Free(oneAig);
  }

  if (chkRes)
  {
    Ddi_Bdd_t *chk = Ddi_BddDiff(a,newaAig);
    if (care != NULL) {
      Ddi_BddAndAcc(chk,care);
    }
    Pdtutil_Assert(!Ddi_AigSat(chk),"wrong monotome exist result");
    Ddi_Free(chk);
  }

  if (verbosity >= Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"\nIMPLICATION conv. with %d/%d red candidates (size %d->%d)\n",
	  nVars-nCurrVars, nVars, size0, Ddi_BddSize(newaAig));
  }

  DdiGenericDataCopy((Ddi_Generic_t *)a,(Ddi_Generic_t *)newaAig);
  Ddi_Free(newaAig);

  Pdtutil_Free(assumeExist);
  Pdtutil_Free(redCodeBits);
  Pdtutil_Free(piCnfIds);
  Ddi_Free(vA);
  Ddi_Free(vLits);


  if (nCurrVars < nVars) {
    Ddi_MgrCheckExtRef(ddm,extRef+1);
    return(impliedCube);
  }
  else {
    Ddi_Free(impliedCube);
    Ddi_MgrCheckExtRef(ddm,extRef);
    return(NULL);
  }
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigTernaryReductionAcc (
  Ddi_Bdd_t *a,
  Ddi_Varset_t *smooth,
  Ddi_Varset_t *project,
  Ddi_Bdd_t *care
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int doTernary;
  Pdtutil_Assert(smooth!=NULL||project!=NULL,"smooth or project vars needed");

  do {
    Ddi_Varset_t *sm = Ddi_BddSupp(a);
    if (smooth != NULL) {
      if (Ddi_VarsetIsArray(smooth)) {
        Ddi_VarsetSetArray(sm);
      }
      Ddi_VarsetIntersectAcc(sm,smooth);
    }
    else {
      if (Ddi_VarsetIsArray(project)) {
        Ddi_VarsetSetArray(sm);
      }
      Ddi_VarsetDiffAcc(sm,project);
    }

    doTernary = 0;
    if (DdiAigExistMonotoneAcc (a,sm,NULL,care,0) != NULL) {
      doTernary = 1;
    }
    Ddi_Free(sm);
  } while (doTernary);

  return a;

}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigMonotoneReductionAcc (
  Ddi_Bdd_t *a,
  Ddi_Varset_t *smooth,
  Ddi_Varset_t *project,
  Ddi_Bdd_t *care
)
{
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newaAig, *newbAig, *cof0Aig, *cof1Aig;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, auxVarIndex, aBaig, bBaig, careBaig, cof0, cof1, f0, f1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int extRef = Ddi_MgrReadExtRef(ddm);
  int i, j, sat, nVars;
  Ddi_Vararray_t *vA, *vAuxA;
  Ddi_Bdd_t *prod;
  int assumeSingleTernary, *assumeTernary;
  int *redCodeBits=NULL;
  int redCodeSize, refinementDone, nCurrTernary;
  int checkSingleTernary;
  int checkFunction = 0;
  int doTernaryB = 0;
  Ddi_Bdd_t *myB=NULL;
  int size0 = Ddi_BddSize(a);
  int checkMonotonicity = 0;
  int myDbg = 0;

  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);

  Ddi_Varset_t *supp;

  bmgr = ddm->aig.mgr;
  aBaig = Ddi_BddToBaig(a);
  careBaig = bAig_One;

  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }

  supp = Ddi_BddSupp(a);

  if (smooth != NULL) {
    Ddi_VarsetIntersectAcc(supp,smooth);
  }
  else {
    Ddi_VarsetDiffAcc(supp,project);
  }

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,aBaig,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  vAuxA = Ddi_VararrayAlloc(ddm,Ddi_VararrayNum(vA));
  Ddi_Free(supp);

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    char name[100];
    Ddi_Var_t *vAux;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    sprintf(name,"PDTRAV_TERNARY_ITP_DUMMY_VAR_%d",i);
    if ((vAux = Ddi_VarFromName(ddm,name))==NULL) {
      vAux = Ddi_VarNew(ddm);
      Ddi_VarAttachName (vAux, name);
    }
    Ddi_VararrayWrite(vAuxA,i,vAux);
    varIndex = Ddi_VarToBaig(v);
    auxVarIndex = bAig_VarNodeFromName(bmgr,name);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    Pdtutil_Assert(auxVarIndex != bAig_NULL,"NULL variable in ExistVar");
    Pdtutil_Assert(bAig_AuxAig0(bmgr,varIndex)==bAig_NULL,
      "NULL AuxAig0 required");
    Pdtutil_Assert(bAig_AuxAig1(bmgr,varIndex)==bAig_NULL,
      "NULL AuxAig1 required");
    /* set ternary X */
    f0 = bAig_NonInvertedEdge(auxVarIndex);
    f1 = bAig_NonInvertedEdge(varIndex);
    bAig_AuxAig0(bmgr,varIndex) = f0;
    bAig_AuxAig1(bmgr,varIndex) = f1;
    bAig_Ref(bmgr, f0);
    bAig_Ref(bmgr, f1);
  }

  //  existDiffEvalIntern(ddm,visitedNodes,careBaig,1/*cache enable*/);
  //  ternaryEvalIntern(ddm,visitedNodes,careBaig,4*visitedNodes->num/4-1);

  ternaryEvalIntern(ddm,visitedNodes,careBaig,-1);

  cof0 = bAig_AuxAig0(bmgr,aBaig);
  cof1 = bAig_AuxAig1(bmgr,aBaig);
  if (bAig_NodeIsInverted(aBaig)) {
    bAigSwap(cof0,cof1);
  }

  cof0Aig = Ddi_BddMakeFromBaig(ddm,cof0);
  cof1Aig = Ddi_BddMakeFromBaig(ddm,cof1);
  newaAig = Ddi_BddNot(cof0Aig);

  existClearVisitedIntern(bmgr,aBaig);
  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);

  {
    Ddi_Varset_t *aSupp = Ddi_BddSupp(newaAig);

    int monotonicityFound, redundancyCnt=0, monotonicityCnt=0;
    do {
      monotonicityFound = 0;

      for (i=Ddi_VararrayNum(vA)-1; i>=0; i--) {
	Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
	Ddi_Var_t *vAux = Ddi_VararrayRead(vAuxA,i);
	int vIn = Ddi_VarInVarset(aSupp,v);
	int vAuxIn = Ddi_VarInVarset(aSupp,vAux);
	if (vIn && !vAuxIn) {
	  Ddi_BddCofactorAcc(newaAig,v,0);
	  monotonicityFound = 1;
	  monotonicityCnt++;
	  Ddi_VararrayRemove(vA,i);
	  Ddi_VararrayRemove(vAuxA,i);
	}
	else if (!vIn && vAuxIn) {
	  Ddi_BddCofactorAcc(newaAig,vAux,0);
	  monotonicityFound = 1;
	  Ddi_VararrayRemove(vA,i);
	  Ddi_VararrayRemove(vAuxA,i);
	  monotonicityCnt++;
	}
	else if (!vIn && !vAuxIn) {
	  Ddi_VararrayRemove(vA,i);
	  Ddi_VararrayRemove(vAuxA,i);
	  redundancyCnt++;
	}
      }
      if (monotonicityFound) {
	Ddi_Free(aSupp);
	aSupp = Ddi_BddSupp(newaAig);
      }
    } while (monotonicityFound);
    Ddi_Free(aSupp);
    if (monotonicityCnt>0) {
      if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
	printf("ternary ITP - %d monotonicities & %d redundancies found\n",
	       monotonicityCnt, redundancyCnt);
      }
    }
  }


#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    varIndex = Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    /* set ternary X */
    bAig_AuxAig0(bmgr,varIndex) = bAig_NULL;
    bAig_AuxAig1(bmgr,varIndex) = bAig_NULL;
    if (nodeVisited(bmgr,varIndex)) {
      nodeClearVisited(bmgr,varIndex);
    }
  }
#endif

  Ddi_Free(cof0Aig);
  Ddi_Free(cof1Aig);

  bAigArrayFree(visitedNodes);

  nVars = Ddi_VararrayNum(vA);

  {
    Ddi_Bddarray_t *Lits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
    Ddi_Bddarray_t *LitsAux = Ddi_BddarrayMakeLiteralsAig(vA, 0);
    Ddi_Bdd_t *zeroAig = Ddi_BddMakeConstAig(ddm,0);

    Ddi_BddComposeAcc(newaAig,vA,Lits);
    Ddi_BddComposeAcc(newaAig,vAuxA,LitsAux);
    Ddi_Free(zeroAig);
    Ddi_Free(Lits);
    Ddi_Free(LitsAux);
  }

  fprintf(dMgrO(ddm),"\nMONOTONE_RED conv. size %d->%d\n", size0, Ddi_BddSize(newaAig));

  Ddi_Free(vA);
  Ddi_Free(vAuxA);

  DdiGenericDataCopy((Ddi_Generic_t *)a,(Ddi_Generic_t *)newaAig);
  Ddi_Free(newaAig);

  Ddi_MgrCheckExtRef(ddm,extRef);

  return(a);

}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistOverAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *smooth,
  Ddi_Bdd_t *care
)
{
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig, *cof0Aig, *cof1Aig;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, fBaig, careBaig, cof0, cof1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  int extRef = Ddi_MgrReadExtRef(ddm);
  int i;
  Ddi_Vararray_t *vA;
  Ddi_Varset_t *supp = Ddi_BddSupp(fAig);

#if 0
  Ddi_Bdd_t *f2, *f1 = Ddi_BddDup(fAig);
  Ddi_BddExistAcc(f1,smooth);
#endif

  if (Ddi_VarsetIsArray(smooth)) {
     Ddi_VarsetSetArray(supp);
  }
  Ddi_VarsetIntersectAcc(supp,smooth);

  bmgr = ddm->aig.mgr;
  fBaig = Ddi_BddToBaig(fAig);
  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_Free(supp);
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    varIndex = Ddi_VarToBaig(v);

    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    Pdtutil_Assert(bAig_AuxAig0(bmgr,varIndex)==bAig_NULL,
      "NULL AuxAig0 required");
    /* set ternary X */
    bAig_AuxAig0(bmgr,varIndex) = bAig_Zero;
    bAig_AuxAig1(bmgr,varIndex) = bAig_Zero;
  }

  //  existDiffEvalIntern(ddm,visitedNodes,careBaig,1/*cache enable*/);
  //  ternaryEvalIntern(ddm,visitedNodes,careBaig,4*visitedNodes->num/4-1);

  ternaryEvalIntern(ddm,visitedNodes,careBaig,-1);

  cof0 = bAig_AuxAig0(bmgr,fBaig);
  cof1 = bAig_AuxAig1(bmgr,fBaig);
  if (bAig_NodeIsInverted(fBaig)) {
    bAigSwap(cof0,cof1);
  }

  cof0Aig = Ddi_BddMakeFromBaig(ddm,cof0);
  cof1Aig = Ddi_BddMakeFromBaig(ddm,cof1);
  newfAig = Ddi_BddNot(cof0Aig);

  existClearVisitedIntern(bmgr,fBaig);
  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);

#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    varIndex = Ddi_VarToBaig(v);

    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    /* set ternary X */
    bAig_AuxAig0(bmgr,varIndex) = bAig_NULL;
    bAig_AuxAig1(bmgr,varIndex) = bAig_NULL;
    if (nodeVisited(bmgr,varIndex)) {
      nodeClearVisited(bmgr,varIndex);
    }
  }
#endif

  Ddi_Free(cof0Aig);
  Ddi_Free(cof1Aig);
  Ddi_Free(vA);

  bAigArrayFree(visitedNodes);

  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);
  Ddi_Free(newfAig);

#if 0
  f2 = Ddi_BddDup(fAig);
  Ddi_BddDiffAcc(f2,f1);
  Pdtutil_Assert(!Ddi_AigSat(f2),"Wrong exist over");
  Ddi_Free(f1);
  Ddi_Free(f2);
#endif

  Ddi_MgrCheckExtRef(ddm,extRef);

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistItpAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *smooth,
  Ddi_Bdd_t *care,
  int maxIter
)
{
  Ddi_Bdd_t *fPlus;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  int extRef = Ddi_MgrReadExtRef(ddm);
  int i;

  fPlus = Ddi_BddDup(fAig);
  DdiAigExistOverAcc (fPlus,smooth,care);

  Ddi_AigOptByInterpolantAcc(fAig,fPlus,care);
  
  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)fPlus);
  Ddi_Free(fPlus);
  
  Ddi_MgrCheckExtRef(ddm,extRef);

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistSkolemAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *smooth,
  Ddi_Bdd_t *care
)
{
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig, *cof0Aig, *cof1Aig, *fExist;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, fBaig, careBaig, cof0, cof1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  int extRef = Ddi_MgrReadExtRef(ddm);
  int i;
  Ddi_Vararray_t *vA, *vA1;
  Ddi_Bddarray_t *fA1;
  Ddi_Varset_t *supp = Ddi_BddSupp(fAig);
  Ddi_Varset_t *smoothIncr;

  
  if (Ddi_VarsetIsArray(smooth)) {
     Ddi_VarsetSetArray(supp);
  }
  Ddi_VarsetIntersectAcc(supp,smooth);
  vA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_Free(supp);

  newfAig = Ddi_BddDup(fAig);
  fExist = Ddi_BddDup(fAig);

  vA1 = Ddi_VararrayAlloc(ddm,1);
  fA1 = Ddi_BddarrayAlloc(ddm,1);
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);

    Ddi_Bdd_t *c0 = Ddi_BddCofactor(fExist,v,0);
    Ddi_Bdd_t *c1 = Ddi_BddCofactor(fExist,v,1);
    DdiAigExistOverAcc (c1,smooth,care);
    Ddi_BddNotAcc(c0);
    DdiAigExistOverAcc (c0,smooth,care);
    Ddi_BddNotAcc(c0);
    int replace;
    Ddi_Bdd_t *a = Ddi_BddDiff(c1,c0);
    Ddi_Bdd_t *b = Ddi_BddDiff(c0,c1);

    Ddi_BddNotAcc(c0);
    Ddi_BddNotAcc(b);
    Ddi_Bdd_t *aOpt = Ddi_BddDup(a);
    replace = Ddi_BddSize(aOpt)<Ddi_BddSize(c0);
    if (replace) Ddi_DataCopy(c0,aOpt);
    replace = Ddi_BddSize(c1)<Ddi_BddSize(c0);
    if (replace) Ddi_DataCopy(c0,c1);
    //    Ddi_BddNotAcc(a);
    Ddi_VararrayWrite(vA1,0,v);
    Ddi_BddarrayWrite(fA1,0,c0);
    Ddi_BddComposeAcc(newfAig,vA1,fA1);

    int aol = Ddi_MgrReadAigAbcOptLevel (ddm);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,3);
    ddiAbcOptAcc (newfAig,-1);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,aol);
    printf("Skolem iteration %d: size %d\n",
           i, Ddi_BddSize(newfAig));
    Ddi_Free(a);
    Ddi_Free(aOpt);
    Ddi_Free(b);
    Ddi_Free(c0);
    Ddi_Free(c1);
  }

  Ddi_Free(vA);
  Ddi_Free(vA1);
  Ddi_Free(fA1);

  Ddi_AigOptByInterpolantAcc(newfAig,fAig,care);

  //  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);
  Ddi_Free(newfAig);
  Ddi_Free(fExist);

  Ddi_MgrCheckExtRef(ddm,extRef);

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistVarOverAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Var_t *smoothVar,
  Ddi_Bdd_t *care
)
{
  int j;
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig, *cof0Aig, *cof1Aig;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, fBaig, careBaig, cof0, cof1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  int extRef = Ddi_MgrReadExtRef(ddm);

  //  Ddi_Varset_t *supp = Ddi_BddSupp(fAig);
  //  Ddi_Varset_t *smooth = Ddi_VarsetMakeFromVar(smoothVar);

#if 0
  Ddi_Bdd_t *f2, *f1 = Ddi_BddDup(fAig);
  Ddi_BddExistAcc(f1,smooth);
#endif

  //  Ddi_VarsetIntersectAcc(supp,smooth);
  //  Ddi_Free(smooth);
  //  if (Ddi_VarsetIsVoid(supp)) {
  //    Ddi_Free(supp);
  //    return(fAig);
  //  }

  bmgr = ddm->aig.mgr;
  fBaig = Ddi_BddToBaig(fAig);
  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  varIndex = Ddi_VarToBaig(smoothVar);

  Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
  //  Pdtutil_Assert(bAig_AuxAig0(bmgr,varIndex)==bAig_NULL,
  //    "NULL AuxAig0 required");
  bAig_AuxAig0(bmgr,varIndex) = bAig_Zero;
  bAig_AuxAig1(bmgr,varIndex) = bAig_Zero;

  //  existDiffEvalIntern(ddm,visitedNodes,careBaig,1/*cache enable*/);
  //  ternaryEvalIntern(ddm,visitedNodes,careBaig,visitedNodes->num/2);
  ternaryEvalIntern(ddm,visitedNodes,careBaig,-1);

  cof0 = bAig_AuxAig0(bmgr,fBaig);
  cof1 = bAig_AuxAig1(bmgr,fBaig);
  if (bAig_NodeIsInverted(fBaig)) {
    bAigSwap(cof0,cof1);
  }

  cof0Aig = Ddi_BddMakeFromBaig(ddm,cof0);
  cof1Aig = Ddi_BddMakeFromBaig(ddm,cof1);
  newfAig = Ddi_BddNot(cof0Aig);

  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);

#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  bAig_AuxAig0(bmgr,varIndex) = bAig_NULL;
  bAig_AuxAig1(bmgr,varIndex) = bAig_NULL;
  if (nodeVisited(bmgr,varIndex)) {
    nodeClearVisited(bmgr,varIndex);
  }
#endif

  Ddi_Free(cof0Aig);
  Ddi_Free(cof1Aig);
  //  Ddi_Free(supp);

  bAigArrayFree(visitedNodes);

  if (0)
  {
    Ddi_Bdd_t *a=Ddi_BddDiff(fAig,newfAig);
    Pdtutil_Assert(Ddi_AigSatBerkmin(a)==0,"invalid overappr");
    Ddi_Free(a);
  }


  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);
  Ddi_Free(newfAig);

#if 0
  f2 = Ddi_BddDup(fAig);
  Ddi_BddDiffAcc(f1,f2);
  Pdtutil_Assert(!Ddi_AigSat(f1),"Wrong exist over");
  Ddi_Free(f1);
  Ddi_Free(f2);
#endif

  Ddi_MgrCheckExtRef(ddm,extRef);

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigTernaryArrayImg (
  Ddi_Bdd_t *from,
  Ddi_Bddarray_t *delta,
  Ddi_Vararray_t *ps,
  Ddi_Vararray_t *inVars
)
{
  bAig_Manager_t  *bmgr;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, fBaig, careBaig, cof0, cof1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  int extRef = Ddi_MgrReadExtRef(ddm);
  int i;
  Ddi_Vararray_t *vA;
  Ddi_Bdd_t *to = Ddi_BddMakePartConjVoid(ddm);
  Ddi_Bdd_t *myFrom;

  bmgr = ddm->aig.mgr;

  if (Ddi_BddIsPartConj(from)) {
    myFrom = Ddi_BddDup(from);
  }
  else {
    myFrom = Ddi_AigPartitionTop(from,0);
  }

  visitedNodes = bAigArrayAlloc();
  for (i=0; i<Ddi_BddarrayNum(delta); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(delta, i);
    if (!Ddi_BddIsConstant(fAig)) {
      fBaig = Ddi_BddToBaig(fAig);
      postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  /* initially set ternary X on all vars */
  for (i=0; i<Ddi_VararrayNum(inVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(inVars,i);
    varIndex = Ddi_VarToBaig(v);

    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    Pdtutil_Assert(bAig_AuxAig0(bmgr,varIndex)==bAig_NULL,
      "NULL AuxAig0 required");
    /* set ternary X */
    bAig_AuxAig0(bmgr,varIndex) = bAig_Zero;
    bAig_AuxAig1(bmgr,varIndex) = bAig_Zero;
  }
  /* set constant values */
  for (i=0; i<Ddi_BddPartNum(myFrom); i++) {
    Ddi_Bdd_t *lit = Ddi_BddPartRead(myFrom,i);
    fBaig = Ddi_BddToBaig(lit);
    Pdtutil_Assert(bAig_isVarNode(bmgr,fBaig),"Literal required");
    /* set ternary X */
    if (Ddi_BddIsComplement(lit)) {
      bAig_AuxAig0(bmgr,fBaig) = bAig_One;
      bAig_AuxAig1(bmgr,fBaig) = bAig_Zero;
    }
    else {
      bAig_AuxAig1(bmgr,fBaig) = bAig_One;
      bAig_AuxAig0(bmgr,fBaig) = bAig_Zero;
    }
  }

  ternaryEvalIntern(ddm,visitedNodes,bAig_NULL,-1);

  for (i=0; i<Ddi_BddarrayNum(delta); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(delta, i);
    Ddi_Var_t *v = Ddi_VararrayRead(ps, i);
    fBaig = Ddi_BddToBaig(fAig);
    cof0 = bAig_AuxAig0(bmgr,fBaig);
    cof1 = bAig_AuxAig1(bmgr,fBaig);
    if (bAig_NodeIsInverted(fBaig)) {
      bAigSwap(cof0,cof1);
    }
    if (cof0 != cof1) {
      Ddi_Bdd_t *lit=NULL;
      /* not an X */
      if (cof1 == bAig_Zero) {
        lit = Ddi_BddMakeLiteralAig(v,0);
      }
      else if (cof1 == bAig_One) {
        lit = Ddi_BddMakeLiteralAig(v,1);
      }
      else {
	Pdtutil_Assert(0,"constant baig expected");
      }
      if (lit!=NULL) {
        Ddi_BddPartInsertLast(to,lit);
	Ddi_Free(lit);
      }
    }
  }

  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);

#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  for (i=0; i<Ddi_VararrayNum(inVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(inVars,i);
    varIndex = Ddi_VarToBaig(v);

    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    /* set ternary X */
    bAig_AuxAig0(bmgr,varIndex) = bAig_NULL;
    bAig_AuxAig1(bmgr,varIndex) = bAig_NULL;
    if (nodeVisited(bmgr,varIndex)) {
      nodeClearVisited(bmgr,varIndex);
    }
  }

  for (i=0; i<Ddi_BddPartNum(myFrom); i++) {
    Ddi_Bdd_t *lit = Ddi_BddPartRead(myFrom,i);
    fBaig = Ddi_BddToBaig(lit);
    Pdtutil_Assert(bAig_isVarNode(bmgr,fBaig),"Literal required");
    /* set ternary X */
    if (Ddi_BddIsComplement(lit)) {
      bAig_AuxAig0(bmgr,fBaig) = bAig_NULL;
      bAig_AuxAig1(bmgr,fBaig) = bAig_NULL;
    }
    else {
      bAig_AuxAig1(bmgr,fBaig) = bAig_NULL;
      bAig_AuxAig0(bmgr,fBaig) = bAig_NULL;
    }
  }

#endif

  Ddi_Free(myFrom);
  bAigArrayFree(visitedNodes);
  if (Ddi_BddPartNum(to) == 0) {
    Ddi_Free(to);
    to = Ddi_BddMakeConstAig(ddm,1);
  }

  return(to);
}



/**Function********************************************************************
  Synopsis    [Operate generalization based on Monotone split]
  Description [Operate generalization based on Monotone split. b => a.
a is generalized w.r.t. b.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSplitMonotoneGen (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *care
)
{
  Ddi_Bdd_t *newA = Ddi_BddDup(a);

  Ddi_AigSplitMonotoneGenAcc (newA,b,care);

  return newA;
}


/**Function********************************************************************
  Synopsis    [Operate generalization based on Monotone split]
  Description [Operate generalization based on Monotone split. b => a.
a is generalized w.r.t. b.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSplitMonotoneGenAcc (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *care
)
{
  Ddi_Bdd_t *newA;
  newA = aigSplitMonotoneGen (a,b,care,0);
  Ddi_DataCopy(a,newA);
  Ddi_Free(newA);
  newA = aigSplitMonotoneGen (a,b,care,1);
  Ddi_DataCopy(a,newA);
  Ddi_Free(newA);

  return a;
}

/**Function********************************************************************
  Synopsis    [Operate generalization based on Monotone split]
  Description [Operate generalization based on Monotone split. b => a.
a is generalized w.r.t. b.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSplitMonotoneGen (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *care,
  int useCompl
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *a2, *aNeg = Ddi_BddNot(a); // aNeg & b is UNSAT
  Ddi_Bdd_t *p, *pPart;
  Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bddarray_t *subst;
  Ddi_ClauseArray_t *pPartClauses, *assumeClauses;
  Ddi_Clause_t *assumeClause, *finalClause, *finalCube;
  Ddi_Bdd_t *constrCube;

  Ddi_Bdd_t *aNegMonotone = Ddi_AigNnf (aNeg,NULL,constr,rV,aV,NULL);

  Ddi_SatSolver_t *solver = Ddi_SatSolverAlloc();
  int i, sat, nAbstr=0, nVars;
  int chkRes=0;

  static int nCalls=0;

  Ddi_Free(constr);

  nCalls++;

  Ddi_Free(aNeg);

  if (useCompl) {
    Ddi_Bddarray_t *substTot = Ddi_BddarrayMakeLiteralsAig(rV, 0);
    Ddi_Bddarray_t *subst2 = Ddi_BddarrayMakeLiteralsAig(aV, 0);
    Ddi_Vararray_t *vars = Ddi_VararrayDup(aV);
    Ddi_BddarrayAppend(substTot,subst2);
    Ddi_VararrayAppend(vars,rV);

    Ddi_BddComposeAcc(aNegMonotone,vars,substTot);

    Ddi_Free(vars);
    Ddi_Free(substTot);
    Ddi_Free(subst2);
  }

  p = Ddi_BddAnd(aNegMonotone,b);
  if (care!=NULL && !Ddi_BddIsOne(care)) {
    Ddi_BddAndAcc(p,care);
  }
  pPart = Ddi_AigPartitionTop(p,0);
  Ddi_Free(p);

  DdiAig2CnfIdInit(ddm);

  for (i=0; i<Ddi_VararrayNum(aV); i++) {
    Ddi_Var_t *a_i = Ddi_VararrayRead(aV,i);
    Ddi_Var_t *r_i = Ddi_VararrayRead(rV,i);
    bAigEdge_t aBaig = Ddi_VarToBaig(a_i);
    bAigEdge_t rBaig = Ddi_VarToBaig(r_i);
    int aCnf = DdiAig2CnfId(bmgr,aBaig);
    int rCnf = DdiAig2CnfId(bmgr,rBaig);
    DdiSolverSetVar(solver, aCnf);
    DdiSolverSetVar(solver, rCnf);
 }

  pPartClauses = Ddi_AigClauses(pPart,0,NULL);

  assumeClause = Ddi_ClauseAlloc(0,Ddi_VararrayNum(aV));

  nVars = Ddi_VararrayNum(aV);
  //  int dummy = DdiSatSolverGetFreeVar(solver);

  Ddi_SatSolverAddClauses(solver,pPartClauses);
  assumeClauses = Ddi_ClauseArrayAlloc(0);

  for (i=0; i<Ddi_VararrayNum(aV); i++) {
    Ddi_Var_t *a_i = Ddi_VararrayRead(aV,i);
    Ddi_Var_t *r_i = Ddi_VararrayRead(rV,i);
    //    Ddi_Var_t *aaa_i = Ddi_VararrayRead(rV,i);
    int act_i = DdiSatSolverGetFreeVar(solver);

    bAigEdge_t aBaig = Ddi_VarToBaig(a_i);
    bAigEdge_t rBaig = Ddi_VarToBaig(r_i);
    //    bAigEdge_t aaaBaig = Ddi_VarToBaig(aaa_i);
    int aCnf = DdiAig2CnfId(bmgr,aBaig);
    int rCnf = DdiAig2CnfId(bmgr,rBaig);
    // int act_i = DdiAig2CnfId(bmgr,aaaBaig);

    DdiClauseArrayAddClause3(assumeClauses,-act_i,aCnf,rCnf);
    DdiClauseArrayAddClause3(assumeClauses,-act_i,-aCnf,-rCnf);

    DdiClauseAddLiteral(assumeClause, act_i);
  }

  Ddi_SatSolverAddClauses(solver,assumeClauses);

  sat = Ddi_SatSolve(solver,assumeClause,-1);

  Pdtutil_Assert(!sat,"unsat needed by generalization");

  finalClause = Ddi_SatSolverFinal(solver,-1);
  finalCube = Ddi_ClauseNegLits(finalClause);
  Pdtutil_Assert(!Ddi_SatSolve(solver,finalCube,-1),"unsat needed");

  constrCube = Ddi_BddMakeConstAig(ddm,1);
  for (i=Ddi_VararrayNum(aV)-1; i>=0; i--) {
    int ass_i = assumeClause->lits[i];
    Ddi_Var_t *a_i = Ddi_VararrayRead(aV,i);
    int j;
    for (j=0; j<finalCube->nLits; j++) {
      if (finalCube->lits[j] == ass_i) break;
    }
    if (j>=finalClause->nLits) {
      // not found - abstract
      Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(a_i, useCompl?0:1);
      Ddi_BddAndAcc(constrCube,lit);
      Ddi_Free(lit);
      //    Ddi_BddCofactorAcc(aNegMonotone,a_i,useCompl?0:1);
      nAbstr++;
    }
  }
  if (nAbstr>0) {
    Ddi_AigConstrainCubeAcc(aNegMonotone,constrCube);
  }
  Ddi_Free(constrCube);

  Ddi_ClauseFree(finalCube);
  Ddi_ClauseFree(finalClause);
  Ddi_ClauseFree(assumeClause);
  Ddi_ClauseArrayFree(assumeClauses);
  Ddi_ClauseArrayFree(pPartClauses);

  Ddi_SatSolverQuit(solver);

  DdiAig2CnfIdClose(ddm);

  subst = Ddi_BddarrayMakeLiteralsAig(rV, 0);
  a2 = Ddi_BddCompose(aNegMonotone,aV,subst);

  if (chkRes) {
    Pdtutil_Assert(!Ddi_AigSatAnd(a2,b,care),"wrong monotone gen.");
  }

  Ddi_BddNotAcc(a2);
  if (chkRes) {
    aNeg = Ddi_BddNot(a);
    Pdtutil_Assert(!Ddi_AigSatAnd(a2,aNeg,care),"over-appr. monotone gen.");
    Ddi_Free(aNeg);
  }
  if (nAbstr>0) {
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      printf("monotone gen: abstr %d/%d vars: %d -> %d\n", nAbstr, nVars,
	     Ddi_BddSize(a), Ddi_BddSize(a2)));
  }

  Ddi_Free(pPart);
  Ddi_Free(aNegMonotone);
  Ddi_Free(aV);
  Ddi_Free(rV);
  Ddi_Free(subst);

  return a2;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigNnf (
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *monotoneVars,
  Ddi_Bdd_t *splitVarConstrain,
  Ddi_Vararray_t *refVars,
  Ddi_Vararray_t *auxVars0,
  Ddi_Vararray_t *auxVars1
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *newFa, *fA;
  Ddi_Bdd_t *newf;
  int n, i, assumeRed=-0;
  int chk=0;

  if (Ddi_BddIsPartConj(f)) {
    fA = Ddi_BddarrayMakeFromBddPart(f);
    newf = Ddi_BddMakePartConjVoid(ddm);
    assumeRed = 1;
  }
  else if (Ddi_BddIsPartDisj(f)) {
    fA = Ddi_BddarrayMakeFromBddPart(f);
    newf = Ddi_BddMakePartDisjVoid(ddm);
  }
  else {
    fA = Ddi_BddarrayAlloc(ddm,1);
    Ddi_BddarrayWrite(fA,0,f);
    newf = Ddi_BddMakePartConjVoid(ddm);
  }

  newFa = Ddi_AigarrayNnf (fA,monotoneVars,assumeRed,
				     splitVarConstrain,refVars,
				     auxVars0,auxVars1);
  n = Ddi_BddarrayNum(fA);

  Ddi_Free(fA);

  /* remove odd components */
  for (i=0; i<n; i++) {
    Ddi_BddPartInsertLast(newf,Ddi_BddarrayRead(newFa,2*i));
  }

  Ddi_Free(newFa);

  if (!Ddi_BddIsPartConj(f) && !Ddi_BddIsPartDisj(f)) {
    Ddi_BddSetAig(newf);
  }

  if (chk) {
    Ddi_Bdd_t *f1 = Ddi_BddMakeAig(f);
    Ddi_Bdd_t *f2 = Ddi_BddMakeAig(newf);
    Ddi_Varset_t *suppF1 = Ddi_BddSupp(f1);
    if (splitVarConstrain != NULL) {
      Ddi_Bdd_t *sp = Ddi_BddMakeAig(splitVarConstrain);
      Ddi_BddAndAcc(f2,sp);
      Ddi_Free(sp);
    }
    Ddi_BddExistProjectAcc(f2,suppF1);
    Pdtutil_Assert(Ddi_BddEqualSat(f1,f2),"wrong monotone split");
    Ddi_Free(suppF1);
    Ddi_Free(f1);
    Ddi_Free(f2);
  }

  return newf;

}

/**Function********************************************************************
  Synopsis    [Operate structural equivalence reduction]
  Description [Operate structural equivalence reduction.
               Project is the set of variables for existential projection.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigStructEquivAcc (
  Ddi_Bdd_t *f,
  Ddi_Varset_t *project
)
{
  Ddi_Bdd_t *newf = Ddi_AigStructEquiv(f,project);
  Ddi_DataCopy(f,newf);
  Ddi_Free(newf);
  return f;
}

/**Function********************************************************************
  Synopsis    [Operate structural equivalence reduction]
  Description [Operate structural equivalence reduction.
               Project is the set of variables for existential projection.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigStructEquiv (
  Ddi_Bdd_t *f,
  Ddi_Varset_t *project
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *newFa, *fA, *shareA=NULL;
  Ddi_Bdd_t *newf, *aux, *fPart;
  int n, i, assumeRed=-0;
  int chk=0; int freeF=0, negF=0;
  int size01=0, size0 = Ddi_BddSize(f), size1;
  char auxMsg[100];
  int enRepart=0;
  Ddi_Bdd_t *constrCube;
  Ddi_Bdd_t *andCube;
  int advance = 0, totEq=0, nIter=0;

  sprintf(auxMsg,"");

  Pdtutil_Assert(Ddi_BddIsAig(f),"Aig required");

  newf = Ddi_BddDup(f);

  fPart = Ddi_AigPartitionTop(f,0);
  if (Ddi_BddPartNum(fPart)==1) {
    Ddi_Free(fPart); fPart = Ddi_AigPartitionTop(f,1);
  }

  if (Ddi_BddIsPartDisj(fPart)) {
    negF=1;
    Ddi_BddNotAcc(fPart);
    Ddi_BddNotAcc(newf);
  }

  andCube = Ddi_BddMakePartConjVoid(ddm);

  n = Ddi_BddPartNum(fPart);

  do {

    Ddi_BddPartSortBySizeAcc(fPart,0); // decreasing size

    constrCube = Ddi_BddMakePartConjVoid(ddm);

    for (i=Ddi_BddPartNum(fPart)-1; i>=0; i--) {
      Ddi_Bdd_t *p_i = Ddi_BddPartRead(fPart,i);
      if (Ddi_BddSize(p_i)>1) break;
      p_i = Ddi_BddPartExtract(fPart,i);
      Ddi_BddPartInsertLast(constrCube,p_i);
      Ddi_BddPartInsertLast(andCube,p_i);
    }

    advance = Ddi_BddPartNum(constrCube);

    if (advance) {
      Ddi_AigConstrainCubeAcc(newf,constrCube);
      Ddi_Free(fPart); fPart = Ddi_AigPartitionTop(newf,0);
    }
    Ddi_Free(constrCube);
    totEq += advance;
    //    printf("eq: %d\n", totEq);
    nIter++;

  } while (advance);

  Ddi_Free(fPart);

  Ddi_BddSetAig(andCube);
  Ddi_BddAndAcc(newf,andCube);
  Ddi_Free(andCube);

  if (negF) {
    Ddi_BddNotAcc(newf);
  }

  if (chk) {
    Ddi_Bdd_t *f1 = Ddi_BddMakeAig(f);
    Ddi_Bdd_t *f2 = Ddi_BddMakeAig(newf);
    Pdtutil_Assert(Ddi_BddEqualSat(f1,f2),"wrong monotone split");
    Ddi_Free(f1);
    Ddi_Free(f2);
  }

  size1 = Ddi_BddSize(newf);

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c-1,
    printf("STRUCT EQUIV[%s%d]: %d%s -> %d (tot eq: %d)\n", negF?"OR:":"AND:",
	   n, size0, auxMsg, size1, totEq));

  return newf;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigStructRedRemAcc (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *share
)
{
  Ddi_Bdd_t *newf = Ddi_AigStructRedRem(f,share);
  Ddi_DataCopy(f,newf);
  Ddi_Free(newf);
  return f;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigExistByXorAcc (
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *smooth
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *fAig = Ddi_BddMakeAig(f);
  Ddi_Bdd_t *newf = Ddi_AigPartitionTop(fAig,0);
  Ddi_Vararray_t *vars;
  Ddi_Bddarray_t *subst;
  Ddi_Var_t *looking = NULL;
  int nSm = Ddi_VararrayNum(smooth);
  Ddi_Bddarray_t *impl0 = Ddi_BddarrayAlloc(ddm,nSm); 
  Ddi_Bddarray_t *impl1 = Ddi_BddarrayAlloc(ddm,nSm); 
  vars = Ddi_VararrayAlloc (ddm,0);
  subst = Ddi_BddarrayAlloc(ddm,0);

  Ddi_VararrayWriteMarkWithIndex (smooth,1);

  Ddi_BddSetFlattened(fAig);

  Ddi_BddPartSortBySizeAcc(newf,0);
  for(int i=0; i<Ddi_BddPartNum(newf); i++) {
    Ddi_Bdd_t *p_i = Ddi_BddPartRead(newf,i);
    Ddi_Bddarray_t *decomp = Ddi_AigPartitionTopXorOrXnor(p_i,0);
    if (decomp!=NULL) {
      Ddi_Bdd_t *p_i_0 = Ddi_BddarrayRead(decomp,0);
      Ddi_Bdd_t *p_i_1 = Ddi_BddarrayRead(decomp,1);
      Ddi_Var_t *v_0 = Ddi_BddTopVar(p_i_0);
      Ddi_Var_t *v_1 = Ddi_BddTopVar(p_i_1);
      Pdtutil_Assert(Ddi_BddarrayNum(decomp)==2,"wrong equiv decomp");
      if (Ddi_BddSize(p_i_0)==1 && Ddi_VarReadMark (v_0)) {
        Ddi_VararrayInsertLast(vars,v_0);
        if (Ddi_BddIsComplement(p_i_0)) Ddi_BddNotAcc(p_i_1);
        Ddi_BddarrayInsertLast(subst,p_i_1);
      }
      else if (Ddi_BddSize(p_i_1)==1 && Ddi_VarReadMark (v_1)) {
        Ddi_VararrayInsertLast(vars,v_1);
        if (Ddi_BddIsComplement(p_i_1)) Ddi_BddNotAcc(p_i_0);
        Ddi_BddarrayInsertLast(subst,p_i_0);
      }
      Ddi_Free(decomp);
      continue;
    }
    if (Ddi_BddSize(p_i) > 8) continue;
    Ddi_Vararray_t *sA = Ddi_BddSuppVararray(p_i);
    if (Ddi_VararrayNum(sA) != 2) {
      Ddi_Free(sA);
      continue;
    }
    Ddi_Var_t *v_0 = Ddi_VararrayRead(sA,0);
    Ddi_Var_t *v_1 = Ddi_VararrayRead(sA,1);
    Ddi_Free(sA);
    if (!Ddi_VarReadMark (v_0)) {
      /* swap */
      Ddi_Var_t *t = v_0; v_0 = v_1; v_1 = t;
    }
    if (Ddi_VarReadMark (v_0) && !Ddi_VarReadMark (v_1)) {
      int ii = Ddi_VarReadMark (v_0) - 1;
      Ddi_Bdd_t *c0 = Ddi_BddCofactor(p_i,v_0,0);
      Ddi_Bdd_t *c1 = Ddi_BddCofactor(p_i,v_0,1);
      if (Ddi_BddIsOne(c0)) {
        Ddi_BddarrayWrite(impl1,ii,c1);
      }
      else {
        Ddi_BddarrayWrite(impl0,ii,c0);
      }
      Ddi_Free(c0);
      Ddi_Free(c1);
    }
  }
  int cnt=0;
  for (int i=0; i<nSm; i++) {
    Ddi_Var_t *v_i = Ddi_VararrayRead(smooth,i);
    Ddi_Bdd_t *i0 = Ddi_BddarrayRead(impl0,i);
    Ddi_Bdd_t *i1 = Ddi_BddarrayRead(impl1,i);
    if (i0!=NULL && i1!=NULL) {
      Ddi_BddNotAcc(i0);
      if (Ddi_BddEqual(i0,i1)) {
        cnt++;
        Ddi_VararrayInsertLast(vars,v_i);
        Ddi_BddarrayInsertLast(subst,i1);
      }
    }
  }

  Ddi_VararrayWriteMark (smooth,0);

  if (Ddi_VararrayNum(vars)>0) {
    Ddi_BddComposeAcc(f,vars,subst);
    Ddi_BddComposeAcc(fAig,vars,subst);
  }
  Ddi_Free(impl0);
  Ddi_Free(impl1);
  Ddi_Free(vars);
  Ddi_Free(subst);

  Ddi_Free(newf);
  Ddi_Free(fAig);
  return f;
}




/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigExistByCircQuant (
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *smooth
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *fAig = Ddi_BddMakeAig(f);
  Ddi_Bdd_t *newf = Ddi_AigPartitionTop(fAig,0);
  Ddi_Vararray_t *vars;

  Ddi_BddSetFlattened(fAig);

  Ddi_BddPartSortBySizeAcc(newf,0);

  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  Ddi_MgrSetVerbosity(ddm,Pdtutil_VerbLevelUsrMin_c);

  Ddi_Bdd_t *fExist = Ddi_BddMakeConstAig(ddm,1); 
  Ddi_Varset_t *sm = Ddi_VarsetMakeFromArray(smooth);
  for (int i=Ddi_BddPartNum(newf)-1; i>=0; i--) {
    Ddi_Bdd_t *f_i = Ddi_BddPartExtract(newf,i);
    Ddi_Varset_t *noSm = Ddi_BddSupp(newf);
    Ddi_Varset_t *s_i = Ddi_BddSupp(f_i);
    Ddi_Varset_t *s = Ddi_BddSupp(fExist);
    Ddi_VarsetIntersectAcc(s_i,sm);
    Ddi_VarsetDiffAcc(s_i,noSm);
    Ddi_VarsetDiffAcc(s_i,s);
    if (Ddi_VarsetNum(s_i)>0) {
      Ddi_BddExistAcc(f_i,s_i);
    }
    Ddi_BddAndAcc(fExist,f_i);
    Ddi_Free(s);
    s = Ddi_BddSupp(fExist);
    Ddi_VarsetDiffAcc(s,noSm);
    Ddi_VarsetIntersectAcc(s,sm);
    if (Ddi_BddSize(fExist)<1000 && Ddi_VarsetNum(s)>0) {
      Ddi_BddExistAcc(fExist,s);
    }
    Ddi_Free(s);
    Ddi_Free(s_i);
    Ddi_Free(f_i);
    Ddi_Free(noSm);
  }
  Ddi_Free(sm);
  Ddi_DataCopy(f,fExist);
  Ddi_Free(fExist);
  Ddi_MgrSetVerbosity(ddm,verbosity);

  Ddi_Free(newf);
  Ddi_Free(fAig);
  return f;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigStructRedRem (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *share
)
{
  Ddi_Bdd_t *newf = aigStructRedRemRecur(f,share,0);
  return newf;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigStructRedRemByOdcChainAcc (
  Ddi_Bdd_t *f,
  int byLevel
)
{
  Ddi_Bdd_t *newf = Ddi_AigStructRedRemByOdcChain(f,byLevel);
  Ddi_DataCopy(f,newf);
  Ddi_Free(newf);
  return f;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
recursiveImplyNode (
  bAig_Manager_t  *bmgr,
  int *impliedStart,
  char *impliedVal,
  bAigEdge_t baig,
  int i,                    
  int inOrderTime
)
{
  if (impliedVal[i]!=0)
    return 0;

  int isCompl = bAig_NodeIsInverted(baig);
  
  impliedStart[i] = inOrderTime;
  impliedVal[i] = isCompl ? -1 : 1;

  if (isCompl || bAig_NodeIsConstant(baig) ||
      bAig_isVarNode(bmgr,baig))
    return 1;

  int ir = rightChildAuxInt(bmgr,baig);
  int il = leftChildAuxInt(bmgr,baig);
  bAigEdge_t r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
  bAigEdge_t l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

  int nr = recursiveImplyNode (bmgr,impliedStart,impliedVal,
                               r, ir, inOrderTime);
  int nl = recursiveImplyNode (bmgr,impliedStart,impliedVal,
                               l, il, inOrderTime);
  return 1 + nr + nl;
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigStructRedRemByOdcChain (
  Ddi_Bdd_t *f,
  int byLevel
)
{
  Ddi_Bdd_t *newf=NULL;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes, *auxNodes;
  int i, n, *impliedStart, nImpl, nTotImpl, inOrderTime;
  char *impliedVal;
  
  visitedNodes = bAigArrayAlloc();
  auxNodes = bAigArrayAlloc();
  Ddi_PostOrderBddAigVisitIntern(f,auxNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,auxNodes);
  aigArrayLevelizeIntern(bmgr,auxNodes);

  inOrderTime = 0;
  if (byLevel) {
    postOrderBddAigByAuxIntVisitIntern(f, visitedNodes,
                                     &inOrderTime, -1);
  }
  else {
    postOrderBddAigByMaxRefVisitIntern(f, visitedNodes,
                                     &inOrderTime);
  }
  
  Pdtutil_Assert(inOrderTime==visitedNodes->num,
                   "mismatching inorder times");
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  bAigArrayAuxIntClear(bmgr,visitedNodes);
  bAigArrayAuxIntSetId(bmgr,visitedNodes);

  n = visitedNodes->num;
  impliedStart = Pdtutil_Alloc(int, n);
  impliedVal = Pdtutil_Alloc(char, n);
  for (i=0; i<n; i++) {
    impliedStart[i] = -1;
    impliedVal[i] = 0;
  }

  int prevTime = -1;
  for (i=n-1, nImpl=nTotImpl=0; i>=0; ) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      break;
    }
    int i0 = rightChildAuxInt(bmgr,baig);
    int i1 = leftChildAuxInt(bmgr,baig);
    bAigEdge_t lower = bAig_NodeReadIndexOfRightChild(bmgr,baig);
    int isCompl;
    if (i0>i1) {
      int t = i0; i0 = i1; i1 = t;
      lower = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
    }
    isCompl = bAig_NodeIsInverted(lower);
    inOrderTime = bAig_AuxInt1(bmgr,baig);
    if (prevTime>inOrderTime) {
      // stop - already seen
      break;
    }
    prevTime = inOrderTime;
#if 1
    int ni = recursiveImplyNode (bmgr,impliedStart,impliedVal,
                               lower, i0, inOrderTime);
#else
    impliedStart[i0] = inOrderTime;
    impliedVal[i0] = isCompl ? -1 : 1;
    int doRecur=1;
    if (doRecur && !isCompl &&
        !bAig_NodeIsConstant(lower) &&
        !bAig_isVarNode(bmgr,lower)) {      
      int ir = rightChildAuxInt(bmgr,lower);
      int il = leftChildAuxInt(bmgr,lower);
      if (impliedVal[ir]==0) {
        bAigEdge_t r = bAig_NodeReadIndexOfRightChild(bmgr,lower);
        impliedVal[ir] = bAig_NodeIsInverted(r) ? -1 : 1;
        impliedStart[ir] = inOrderTime;
      }
      if (impliedVal[il]==0) {
        bAigEdge_t l = bAig_NodeReadIndexOfLeftChild(bmgr,lower);
        impliedVal[il] = bAig_NodeIsInverted(l) ? -1 : 1;
        impliedStart[il] = inOrderTime;
      }
    }
#endif
    nImpl++; nTotImpl += ni;
    i = i1;
  }

  //  static int enRed = 1000;
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAigEdge_t f = bAig_AuxAig0(bmgr,baig);

    if (f == bAig_NULL) {
      if (bAig_NodeIsConstant(baig)) {
        f = bAig_Zero;
      }
      else if (bAig_isVarNode(bmgr,baig)) {
        f = bAig_NonInvertedEdge(baig);
      }
      else {
        bAigEdge_t r, l;
        int ir = rightChildAuxInt(bmgr,baig);
        int il = leftChildAuxInt(bmgr,baig);
        bAigEdge_t right=bAig_NodeReadIndexOfRightChild(bmgr,baig);
        bAigEdge_t left=bAig_NodeReadIndexOfLeftChild(bmgr,baig);
        inOrderTime = bAig_AuxInt1(bmgr,baig);
        if (impliedStart[ir]>=0 && impliedStart[ir]<inOrderTime) {
          Pdtutil_Assert(impliedVal[ir]!=0,"implication problem");
          r = (impliedVal[ir]>0) ? bAig_One : bAig_Zero;
        }
	else {
	  r = bAig_AuxAig0(bmgr,right);
	}
        if (bAig_NodeIsInverted(right)) {
	  r = bAig_Not(r);
        }
        if (impliedStart[il]>=0 && impliedStart[il]<inOrderTime) {
          Pdtutil_Assert(impliedVal[il]!=0,"implication problem");
          l = (impliedVal[il]>0) ? bAig_One : bAig_Zero;
        }
	else {
	  l = bAig_AuxAig0(bmgr,left);
	}
        if (bAig_NodeIsInverted(left)) {
	  l = bAig_Not(l);
        }
        f = bAig_And(bmgr,r,l);
      }
      bAig_Ref(bmgr, f);
      if (0 && !bAig_NodeIsConstant(f) &&
          f != bAig_NonInvertedEdge(baig)) {
        int id = bAig_AuxInt(bmgr,f);
        if (id>=0) {
          if (impliedStart[id]>=0 &&
              impliedStart[id]<inOrderTime) {
            Pdtutil_Assert(impliedVal[id]!=0,
                           "implication problem");
            bAig_RecursiveDeref(bmgr,f);
            f = (impliedVal[id]>0) ? bAig_One : bAig_Zero;
            bAig_Ref(bmgr, f);
          }
        }
      }
      bAig_AuxAig0(bmgr,baig) = f;
    }
  }

  bAigEdge_t baig = visitedNodes->nodes[n-1];
  newf = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig0(bmgr,baig));
  if (bAig_NodeIsInverted(baig)) {
    Ddi_BddNotAcc(newf);
  }

  
  bAigArrayAuxIntClear(bmgr,auxNodes);
  bAigArrayFree(auxNodes);

  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);
  bAigArrayAuxInt1Clear(bmgr,visitedNodes);
  bAigArrayFree(visitedNodes);
  Pdtutil_Free(impliedStart);
  Pdtutil_Free(impliedVal);

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c,
      printf("STRUCT ODC LINEAR CHAIN: %d(Tot:%d)/%d terms found - size -> %d\n",
	     nImpl, nTotImpl, n, Ddi_BddSize(newf)));

  static int chk = 0;
  if (chk) {
    Pdtutil_Assert(Ddi_BddEqualSat(newf,f),"wrong chain red rem");
  }
  return newf;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigStructRedRemRecur (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *share,
  int tryRecur
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *newFa, *fA, *shareA=NULL;
  Ddi_Bdd_t *newf, *aux, *fDup=NULL;
  int n, i, assumeRed=0;
  int chk=0; int freeF=0, negF=0;
  int size01=0, size0 = Ddi_BddSize(f), size1;
  char auxMsg[100];
  int enRepart=0;

  sprintf(auxMsg,"");

  if (size0<4) return Ddi_BddDup(f);

  if (chk) fDup = Ddi_BddDup(f);

  if (Ddi_BddIsAig(f)) {
    Ddi_Bdd_t *f1 = Ddi_AigPartitionTop(f,0);
    if (Ddi_BddPartNum(f1)==1) {
      Ddi_Free(f1); f1 = Ddi_AigPartitionTop(f,1);
      negF=1;
      Ddi_BddNotAcc(f1);
    }
    if (enRepart && (size0 > 10000) && (Ddi_BddPartNum(f1)<50)) {
      Ddi_AigRePartitionAcc(f1,100);
      aux = Ddi_BddMakeAig(f1);
      size01 = Ddi_BddSize(aux);
      Ddi_Free(aux);
      sprintf(auxMsg," (%d)", size01);
    }
    f = f1;
    freeF = 1;
  }

  if (0 && (size0 > 50000)) {
    int j;
    Ddi_BddPartSortBySizeAcc(f,1); // increasing size
    printf("PART [%d] - size: %d:\n", Ddi_BddPartNum(f), size0);
    for (j=0; j<Ddi_BddPartNum(f); j++) {
      printf("%d ", Ddi_BddSize(Ddi_BddPartRead(f,j)));
    }
    printf("\n");
  }

  if (Ddi_BddIsPartConj(f)) {
    fA = Ddi_BddarrayMakeFromBddPart(f);
    newf = Ddi_BddMakePartConjVoid(ddm);
    assumeRed = Ddi_BddarrayNum(fA);
  }
  else if (Ddi_BddIsPartDisj(f)) {
    Ddi_BddNotAcc(f);
    fA = Ddi_BddarrayMakeFromBddPart(f);
    Ddi_BddNotAcc(f);
    newf = Ddi_BddMakePartConjVoid(ddm);
    assumeRed = Ddi_BddarrayNum(fA);
    negF = 1;
  }

  if (share != NULL) {
    if (Ddi_BddIsPartConj(share) || Ddi_BddIsPartDisj(share)) {
      shareA = Ddi_BddarrayMakeFromBddRoots(share);
    }
    else {
      shareA = Ddi_BddarrayAlloc(ddm,1);
      Ddi_BddarrayWrite(shareA,0,share);
    }
  }

  newFa = Ddi_AigarrayStructRedRem (fA,shareA,assumeRed);
  n = Ddi_BddarrayNum(fA);

  Ddi_Free(fA);

  if (n<50 && tryRecur>0) {
    /* not working because of sharing */
    Ddi_Bdd_t *optp;
    Ddi_Bdd_t *shareRef = Ddi_BddMakePartConjFromArray(newFa);
    Ddi_Bdd_t *auxOne = Ddi_BddMakeConstAig(ddm,1);
    if (share!=NULL) Ddi_BddPartInsertLast(shareRef,share);
    for (i=0; i<n; i++) {
      Ddi_BddPartWrite(shareRef,i,auxOne);
      optp = aigStructRedRemRecur(
	Ddi_BddarrayRead(newFa,i),NULL,tryRecur-1);
      Ddi_BddPartInsertLast(newf,optp);
      Ddi_BddPartWrite(shareRef,i,optp);
      Ddi_Free(optp);
    }
    Ddi_Free(shareRef);
    Ddi_Free(auxOne);
  }
  else {
    for (i=0; i<n; i++) {
      Ddi_BddPartInsertLast(newf,Ddi_BddarrayRead(newFa,i));
    }
  }

  Ddi_Free(newFa);

  if (!Ddi_BddIsPartConj(f) && !Ddi_BddIsPartDisj(f)) {
    Ddi_BddSetAig(newf);
  }

  if (freeF) {
    Ddi_Free(f);
    Ddi_BddSetAig(newf);
  }
  if (negF) {
    Ddi_BddNotAcc(newf);
  }

  if (chk) {
    Ddi_Bdd_t *f1 = Ddi_BddMakeAig(fDup);
    Ddi_Bdd_t *f2 = Ddi_BddMakeAig(newf);
    Pdtutil_Assert(Ddi_BddEqualSat(f1,f2),"wrong monotone split");
    Ddi_Free(f1);
    Ddi_Free(f2);
  }
  Ddi_Free(fDup);

  size1 = Ddi_BddSize(newf);

  if (size1<0.8*size0) {
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c,
      printf("STRUCT ODC[%s%d]: %d%s -> %d\n",
	     negF?"OR:":"AND:", n, size0, auxMsg, size1));
  }
  else {
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c-1,
      printf("STRUCT ODC[%s%d]: %d%s -> %d\n", negF?"OR:":"AND:",
      n, size0, auxMsg, size1));
  }

  return newf;

}



/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_NnfClustSimplifyAcc (
  Ddi_Bdd_t *f,
  int fast
)
{
  Ddi_Bdd_t *f2 = Ddi_NnfClustSimplify(f,fast);
  Ddi_DataCopy(f,f2);
  Ddi_Free(f2);
  return f;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_NnfOdcSimplifyAcc (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  int level
)
{
  Ddi_Bdd_t *f2 = Ddi_NnfOdcSimplify(f,care,level);
  Ddi_DataCopy(f,f2);
  Ddi_Free(f2);
  return f;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_NnfClustSimplify (
  Ddi_Bdd_t *f,
  int fast
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
   Ddi_Bdd_t *fNew=NULL, *fNnf=NULL;
   Ddi_Bdd_t *constr = NULL;
   Ddi_Vararray_t *rV = NULL;
   Ddi_Vararray_t *aV = NULL;
   int chk = 0;
   int size0, sizeAbc=0, size1, sizef, i=0;
   int useAbc=1;

   sizef = Ddi_BddSize(f);
   if (ddm->settings.aig.nnfClustSimplify<=0) {
     return (Ddi_BddDup(f));
   }
   else if (ddm->settings.aig.nnfClustSimplify==2) {
     Ddi_Bdd_t *fDup = Ddi_BddDup(f);
     ddiAbcOptAcc (fDup,-1);
     return (fDup);
   }

   constr = Ddi_BddMakeConstAig(ddm,1);
   rV = Ddi_VararrayAlloc(ddm,0);
   aV = Ddi_VararrayAlloc(ddm,0);

   if (useAbc) {
    int aol = Ddi_MgrReadAigAbcOptLevel (ddm);
    Ddi_Bdd_t *fDup = Ddi_BddDup(f);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,1);
    ddiAbcOptAcc (fDup,-1);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,aol);
    sizeAbc = Ddi_BddSize(fDup);
    fNnf = Ddi_AigNnf (fDup,NULL,constr,rV,aV,NULL);
    Ddi_Free(fDup);
   }
   else {
     fNnf = Ddi_AigNnf (f,NULL,constr,rV,aV,NULL);
   }
   if (Ddi_BddSize(fNnf)>1.2*sizef) {
     Ddi_Free(fNnf);
     Ddi_Free(constr);
     Ddi_Free(rV);
     Ddi_Free(aV);
     return (Ddi_BddDup(f));
   }
   
   Ddi_BddSetAig(constr);

   do {
     size0 = Ddi_BddSize(fNnf);
     if (!fast || ddm->settings.aig.itpClust) {
       fNew = aigNnfClustSimplify (fNnf);
       Ddi_Free(fNnf);
       fNnf = fNew;
     }

     if (ddm->settings.aig.itpNorm) {
       fNew = aigNnfClustNormalize (fNnf,0);
       Ddi_Free(fNnf);
       fNnf = fNew;
       fNew = aigNnfClustNormalize (fNnf,1);
       Ddi_Free(fNnf);
       fNnf = fNew;
       fNew = aigNnfClustNormalize3 (fNnf);
       Ddi_Free(fNnf);
       fNnf = fNew;
     }
#if 0
     fNew = aigNnfClustRefactor (fNnf);
     Ddi_Free(fNnf);
     fNnf = fNew;
#endif
     if (ddm->settings.aig.itpSimp && size0 < 2000000) {
       fNew = aigNnfTransImplSimplify (fNnf);
       Ddi_Free(fNnf);
       fNnf = fNew;
     }
     size1 = Ddi_BddSize(fNnf);

     if (useAbc) {
       int aol = Ddi_MgrReadAigAbcOptLevel (ddm);
       Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,1);
       ddiAbcOptAcc (fNnf,-1);
       Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,aol);
     }

     i++;
   } while (size1 < 0.95*size0);

   fNew = fNnf;
   Ddi_BddAigFromNnfAcc(fNnf,rV);

   Ddi_Free(constr);
   Ddi_Free(rV);
   Ddi_Free(aV);

   Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
     if (useAbc) {
       fprintf(dMgrO(ddm),"TOT NNF SIMPL: %d -> (abcBal: %d) -> %d (%d iterations)\n", 
	       sizef, sizeAbc, Ddi_BddSize(fNew), i);
     }
     else {
       fprintf(dMgrO(ddm),"TOT NNF SIMPL: %d -> %d (%d iterations)\n", 
	       sizef, Ddi_BddSize(fNew), i);
     }
   }

   if (chk) {
     /* verify result correctness (s => f): s*!f must be unsat */
     Pdtutil_Assert(Ddi_AigEqualSat(f,fNew), "invalid subset");
   }

   return fNew;
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_NnfOdcSimplify (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  int level
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
   Ddi_Bdd_t *fNew, *fNnf;
   Ddi_Bdd_t *constr = NULL;
   Ddi_Vararray_t *rV = NULL;
   Ddi_Vararray_t *aV = NULL;
   int chk = 1;
   int size0, sizeAbc=0, size1, sizef, i=0;
   int useAbc=1;

   sizef = Ddi_BddSize(f);

   constr = Ddi_BddMakeConstAig(ddm,1);
   rV = Ddi_VararrayAlloc(ddm,0);
   aV = Ddi_VararrayAlloc(ddm,0);

   fNnf = Ddi_AigNnf (f,NULL,constr,rV,aV,NULL);

   Ddi_BddSetAig(constr);
   if (care!=NULL) {
     Ddi_BddAndAcc(constr,care);
   }

   do {
     size0 = Ddi_BddSize(fNnf);
     fNew = aigNnfClustOdcSat (fNnf,constr);
     Ddi_Free(fNnf);
     fNnf = fNew;
     size1 = Ddi_BddSize(fNnf);
     i++;
   } while (size1 < 0.99*size0);

   Ddi_BddAigFromNnfAcc(fNew,rV);

   Ddi_Free(constr);
   Ddi_Free(rV);
   Ddi_Free(aV);

   Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
     fprintf(dMgrO(ddm),"TOT NNF ODC SIMPL: %d -> %d (%d iterations)\n", 
	       sizef, Ddi_BddSize(fNew), i);
   }

   if (chk) {
     Ddi_Bdd_t *f1 = Ddi_BddDup(f);
     Ddi_Bdd_t *f2 = Ddi_BddDup(fNew);
     if (care!=NULL) {
       Ddi_BddAndAcc(f1,care);
       Ddi_BddAndAcc(f2,care);
     }
     /* verify result correctness (s => f): s*!f must be unsat */
     Pdtutil_Assert(Ddi_AigEqualSat(f1,f2), "invalid subset");
     Ddi_Free(f1);
     Ddi_Free(f2);
   }

   return fNew;
}



/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_NnfIteSimplifyAcc (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *aForItp,
  Ddi_Bdd_t *bForItp,
  Ddi_Bdd_t *care
)
{
  Ddi_Bdd_t *f2 = Ddi_NnfIteSimplify(f,aForItp,bForItp,care);
  Ddi_DataCopy(f,f2);
  Ddi_Free(f2);
  return f;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_NnfIteSimplify (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *aForItp,
  Ddi_Bdd_t *bForItp,
  Ddi_Bdd_t *care
)
{
   Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
   Ddi_Bdd_t *fNew=NULL, *fNnf;
   int chk = 0;
   int size0, size00, sizeAbc=0, size1, sizef, i=0;
   int useAbc=1;
   float growFactor = 1.00;
   Ddi_Bdd_t *fDup = Ddi_BddDup(f);
   int doCompl = 0; // bForItp!=NULL;

   sizef = Ddi_BddSize(f);

   if (useAbc) {
    int aol = Ddi_MgrReadAigAbcOptLevel (ddm);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,1);
    ddiAbcOptAcc (fDup,-1);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,aol);
    sizeAbc = Ddi_BddSize(fDup);
    Ddi_AigStructRedRemAcc (fDup,NULL);
   }

   if (doCompl) {
     Ddi_BddNotAcc(fDup);
   }

   int iter=0;
   size00 = Ddi_BddSize(fDup);
   do {
     int size2;
     Ddi_Bdd_t *fNew2, *f0, *f1, *f0b;
     Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
     Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
     Ddi_Vararray_t *aV = Ddi_VararrayAlloc(ddm,0);

     size0 = Ddi_BddSize(fDup);
     //     Ddi_BddNotAcc(fDup);
     fNnf = Ddi_AigNnf (fDup,NULL,constr,rV,aV,NULL);
     Ddi_BddSetAig(constr);

     Ddi_Free(fNew);
     fNew = aigNnfClustIteDecomp (fNnf, rV, aV);
     //    fNew = aigNnfClustIteDecomp (fNnf, NULL, NULL);
     //     fNew = Ddi_BddDup(fNnf);
     if (!Ddi_BddIsPartDisj(fNew)) {
       fprintf(dMgrO(ddm),"NNF ITE: %d -> %d (iter: %d)\n", 
	       Ddi_BddSize(fNnf), Ddi_BddSize(fNew), iter++);
       Ddi_BddAigFromNnfAcc(fNew,rV);
     }
     else {
       fprintf(dMgrO(ddm),"NNF ITE: %d -> %d+%d = %d (iter: %d)\n", 
	     Ddi_BddSize(fNnf), Ddi_BddSize(Ddi_BddPartRead(fNew,0)), 
	       Ddi_BddSize(Ddi_BddPartRead(fNew,1)), Ddi_BddSize(fNew),
	       iter++);
       //       Ddi_BddNotAcc(fNew);
       f0 = Ddi_BddPartRead(fNew,0);
       f1 = Ddi_BddPartRead(fNew,1);
       if (Ddi_BddSize(f1)<Ddi_BddSize(f0)) {
	 f0 = Ddi_BddPartRead(fNew,1);
	 f1 = Ddi_BddPartRead(fNew,0);
       }
       f0b = NULL;
       if (0 && (Ddi_BddSize(f0) > size0/4)) {
	 Ddi_Bdd_t *fNewSplit = aigNnfClustIteDecomp (f0, rV, aV);
	 Ddi_DataCopy(f0,fNewSplit);
	 Ddi_Free(fNewSplit);
	 fNewSplit = f0;
	 fprintf(dMgrO(ddm),"NNF ITE: %d -> %d+%d = %d\n", 
		 Ddi_BddSize(f0), Ddi_BddSize(Ddi_BddPartRead(f0,0)), 
		 Ddi_BddSize(Ddi_BddPartRead(f0,1)), Ddi_BddSize(f0));
	 f0b = Ddi_BddPartRead(f0,1);
	 f0 = Ddi_BddPartRead(f0,0);
	 Ddi_BddAigFromNnfAcc(f0b,rV);
       }
       Ddi_AigOptByBddSweepTop(f0,NULL,2);
       Ddi_AigOptByBddSweepTop(f1,NULL,2);

       Ddi_BddAigFromNnfAcc(f0,rV);
       Ddi_BddAigFromNnfAcc(f1,rV);
       if (bForItp!=NULL) {
	 Ddi_NnfClustSimplifyAcc(f0,0);
#if 1
	 if (Ddi_BddSize(f0) > size00/10)
	   Ddi_AigOptByMonotoneCoreAcc (f0,
				      bForItp,care,0,-1.0);
#else
	 if (1) {
	   Ddi_Bdd_t *bConstr = Ddi_BddAnd(bForItp,f0);
	   Ddi_AigOptByMonotoneCoreAcc (f1,
				      bConstr,care,0,-1.0);
	   Ddi_Free(bConstr);
	 }
#endif
       }
     }
     Ddi_BddSetAig(fNew);
     Ddi_Free(constr);
     Ddi_Free(rV);
     Ddi_Free(aV);

     size1 = Ddi_BddSize(fNew);

     Ddi_AigOptByBddSweepTop(fNew,NULL,2);
     if (1 || iter%10 == 0)
       Ddi_NnfClustSimplifyAcc(fNew,0); 
     if (aForItp!=NULL) {
       Ddi_AigOptByMonotoneCoreAcc (fNew,
				  aForItp,care,1,-1.0);
     }

     size1 = size2 = Ddi_BddSize(fNew);

     Ddi_Free(fNnf);

     if (size2 < growFactor*size0) {
       Ddi_DataCopy(fDup,fNew);
     }
     else {
       break;
     }
     i++;
   } while (size1 < growFactor*size0 && size1 > size00/2);

   Ddi_NnfClustSimplifyAcc(fNew,0); 

   Ddi_Free(fDup);
   if (doCompl) {
     Ddi_BddNotAcc(fNew);
   }

   Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
     if (useAbc) {
       fprintf(dMgrO(ddm),"TOT NNF ITE: %d -> (abcBal: %d) -> %d (%d iterations)\n", 
	       sizef, sizeAbc, Ddi_BddSize(fNew), i);
     }
     else {
       fprintf(dMgrO(ddm),"TOT NNF ITE: %d -> %d (%d iterations)\n", 
	       sizef, Ddi_BddSize(fNew), i);
     }
   }

   if (chk) {
     /* verify result correctness (s => f): s*!f must be unsat */
     Pdtutil_Assert(Ddi_AigEqualSat(f,fNew), "invalid subset");
   }

   return fNew;
}



/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigNnfClustSimplify (
  Ddi_Bdd_t *a
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *a2=NULL;
  int sizeA;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, n;
  int totRoot=0, totIn=0, totRoot2=0, totIn2=0, nRed=0, chkRes=0;
  int clstDup=0, clstDup2=0, clstRed2=0, clstRed3=0, clstRed3a=0, clstRed3b=0, clstRed=0;
  nnfGate_t *nnfGates;
  int nLdr=0, nLdrFi=0, nPi=0;
  //  int nRecImpl = 2;
  int *auxV, auxN=0;

  static int nCalls=0, nRedTot=0, maxJoin=50000;

  nCalls++;

  sizeA = Ddi_BddSize(a);
  if (sizeA < 4) {
    return Ddi_BddDup(a);
  }

  /* get array of baig nodes */
  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(a,NULL,NULL,NULL,NULL,1,0);
  n = nnfCoreMgr->aNodes->num; 

  nnfGates = Pdtutil_Alloc(nnfGate_t, n);
  auxV = Pdtutil_Alloc(int, n);

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].foCnt = nnfGates[i].foImplCnt = nnfGates[i].foAux = 
      nnfGates[i].fiImplCnt = nnfGates[i].fiTransImplCnt = 
      nnfGates[i].foAux2 = nnfGates[i].redGate = 0;
    nnfGates[i].fo = NULL;
    nnfGates[i].foImpl = NULL;
    nnfGates[i].fiImpl = NULL;
    nnfGates[i].ldrFiNum = 0;
    nnfGates[i].clstLdr = i;
    nnfGates[i].clstLdr2 = i;
    nnfGates[i].lastIn = -1;
    nnfGates[i].redJoin = -1;
    nnfGates[i].baig = bAig_NULL;
    nnfGates[i].fi.r = -1;
    nnfGates[i].fi.l = -1;
  }

  bAigArrayAuxIntSetId(bmgr,nnfCoreMgr->aNodes);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      nPi++;
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    nnfGates[ir].foCnt++;
    nnfGates[il].foCnt++;
    nnfGates[i].fi.r = ir;
    nnfGates[i].fi.l = il;
  }
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].fo = Pdtutil_Alloc(int, nnfGates[i].foCnt);
  }

  for (i=n-1; i>=0; i--) {
    int isOr, isOrL, isOrR;
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    isOr = nnfCoreMgr->gateType[i] == 'O';
    isOrR = nnfCoreMgr->gateType[ir] == 'O';
    isOrL = nnfCoreMgr->gateType[il] == 'O';
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[ir]) {
      if (nnfGates[ir].foCnt==1) {
	nnfGates[ir].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[il]) {
      if (nnfGates[il].foCnt==1) {
	nnfGates[il].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfGates[ir].foCnt==1) {
      nnfGates[ir].clstLdr2 = nnfGates[i].clstLdr2;
    }
    if (nnfGates[il].foCnt==1) {
      nnfGates[il].clstLdr2 = nnfGates[i].clstLdr2;
    }

    if (nnfGates[i].clstLdr==i) {
      totRoot++;
    }
    else {
      totIn++;
    }
    if (nnfGates[i].clstLdr2==i) {
      totRoot2++;
    }
    else {
      totIn2++;
    }
  }

  // sort gate indexes by clstLdr2
  for (i=0; i<n; i++) {
    auxV[i] = 0;
  }
  for (i=0; i<n; i++) {
    int ldr2 = nnfGates[i].clstLdr2;
    Pdtutil_Assert(ldr2>=0&&ldr2<n,"wrong ldr2");
    auxV[ldr2]++;
  }
  for (i=1; i<n; i++) {
    auxV[i] += auxV[i-1];
  }
  // foAux2 has the sorted indexes
  for (i=n-1; i>=0; i--) {
    int ldr2 = nnfGates[i].clstLdr2;
    nnfGates[auxV[ldr2]-1].foAux2 = i;
    auxV[ldr2]--;
  }
  // check SORTing
  for (i=1; i<nnfCoreMgr->aNodes->num; i++) {
    int ii0 = nnfGates[i-1].foAux2;
    int ii = nnfGates[i].foAux2;
    Pdtutil_Assert(nnfGates[ii0].clstLdr2<=nnfGates[ii].clstLdr2,
		   "sort problem");
  }

  // sort fanout lists by cluster
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    int ii = nnfGates[i].foAux2;
    int ir = nnfGates[ii].fi.r;
    int il = nnfGates[ii].fi.l;
    
    if (ir>=0 && il>=0) {
      nnfGates[ir].fo[nnfGates[ir].foAux++] = ii;
      nnfGates[il].fo[nnfGates[il].foAux++] = ii;
    }
    nnfGates[i].foAux2 = 0;
    auxV[i] = 0;
  }


  for (i=0; i<n; i++) {
    int isOr, isOrL, isOrR;
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr == ir) {
	nnfGates[ldr].ldrFiNum++;
      }
      if (nnfGates[il].clstLdr == il) {
	nnfGates[ldr].ldrFiNum++;
      }
      if (nnfGates[i].clstLdr2 == nnfGates[i].clstLdr) {
	nnfGates[ir].foImplCnt++;
	nnfGates[il].foImplCnt++;
      }
    }
  }

  for (i=0; i<n; i++) {
    if (nnfGates[i].clstLdr == i && nnfGates[i].ldrFiNum>0) {
      nLdr++;
      nLdrFi += nnfGates[i].ldrFiNum;
    }
  }

  /* analyze fo lists */
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    Pdtutil_Assert(nnfGates[i].foCnt==nnfGates[i].foAux,"fanout cnt problem");
    nnfGates[i].foAux = 0;
  }

  int tryMe = 0;
  static int tryFo2 = 0;
  static int doEnJoin = 1;

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    int j, red2=0, red=0, red3=0, red3b=0;
    if (nnfGates[i].foCnt==0) continue;
    if (tryMe) {
      bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
      if (bAig_isVarNode(bmgr,baig)) {
	char *name = bAig_NodeReadName(bmgr,baig);
	if (strcmp(name,"PDTRAV_NNF_RAIL_0_l48$NS") == 0) {
	  int doCount = 0, doCount2 = 0;
	  for (j=0; j<nnfGates[i].foCnt; j++) {
	    int foId = nnfGates[i].fo[j];
	    nnfGates[nnfGates[foId].clstLdr].foAux = 0;
	  }
	  for (j=0; j<nnfGates[i].foCnt; j++) {
	    int foId = nnfGates[i].fo[j];
	    if (nnfGates[nnfGates[foId].clstLdr].foAux==0) {
	      nnfGates[nnfGates[foId].clstLdr].foAux = 1;
	      doCount++;
	    }
	  }
	  for (j=0; j<nnfGates[i].foCnt; j++) {
	    int foId = nnfGates[i].fo[j];
	    nnfGates[nnfGates[foId].clstLdr].foAux = 0;
	  }
	  for (j=0; j<nnfGates[i].foCnt; j++) {
	    int jj, foId = nnfGates[i].fo[j];
	    for (jj=0; jj<nnfGates[foId].foCnt; jj++) {
	      int foId2 = nnfGates[foId].fo[jj];
	      if (nnfGates[nnfGates[foId2].clstLdr].foAux==0) {
		nnfGates[nnfGates[foId2].clstLdr].foAux = 1;
		doCount2++;
	      }
	    }
	  }
	  printf("found: fo: %d - macrogates: direct: %d - fanout: %d\n",
		   nnfGates[i].foCnt, doCount, doCount2);

	}
      }
    }
    if (tryFo2 && nnfGates[i].foCnt==2) {
      int fo0 = nnfGates[i].fo[0];
      int fo1 = nnfGates[i].fo[1];
      int ldr20 = nnfGates[fo0].clstLdr2;
      int ldr21 = nnfGates[fo1].clstLdr2;
      if (ldr20 == ldr21) {
	printf("fo2 found: %d -> %d %d (ldr2: %d)\n", i, fo0, fo1, ldr20);
      }
    }
    for (j=0; j<nnfGates[i].foCnt; j++) {
      int foId = nnfGates[i].fo[j];
      if (j>0) {
	int foId0 = nnfGates[i].fo[j-1];
	Pdtutil_Assert(nnfGates[foId0].clstLdr2<=nnfGates[foId].clstLdr2,
		   "sort fo problem");
      }
      if (nnfGates[nnfGates[foId].clstLdr].foAux++ > 0) {
	clstDup++;
      }
    }
    for (j=0; j<nnfGates[i].foCnt; j++) {
      int foId = nnfGates[i].fo[j];
      nnfGates[nnfGates[foId].clstLdr].foAux = 0;
    }
    for (j=0; j<nnfGates[i].foCnt; j++) {
      int foId = nnfGates[i].fo[j];
      if (nnfGates[nnfGates[foId].clstLdr2].foAux++ > 0) {
	clstDup2++;
      }
    }
    for (j=0; j<nnfGates[i].foCnt; j++) {
      int ldr, foId0, foId = nnfGates[i].fo[j];
      int ldr2 = nnfGates[foId].clstLdr2;
      if (nnfGates[foId].redGate) continue;

      if (nnfGates[nnfGates[foId].clstLdr2].foAux > 1) {
	red++;
	if (nnfGates[foId].clstLdr2==nnfGates[foId].clstLdr) {
	  red2++;
	  foId0 = nnfGates[nnfGates[foId].clstLdr2].lastIn;
	  //  Pdtutil_Assert(foId0>=0,"missing foid");
	  if (1 && (foId0>=0)) {
	    Pdtutil_Assert(nnfCoreMgr->gateType[foId]==
			   nnfCoreMgr->gateType[foId0],"same gate needed");
	    if (nnfGates[foId].fi.r==i) {
	      nnfGates[foId].fi.r = -1;
	    }
	    else {
	      Pdtutil_Assert(nnfGates[foId].fi.l==i,"wrong fi id");
	      nnfGates[foId].fi.l = -1;
	    }
	  }
	  nnfGates[nnfGates[foId].clstLdr2].lastIn = foId;
	}
	else {
	  int k, k0, k1;
	  int isAnd = nnfCoreMgr->gateType[foId] == 'A';
	  int reduced = 0, implied = 0, foAux2Set = 0, disable=0;
	  Pdtutil_Assert(nnfGates[nnfGates[foId].clstLdr].foCnt==1,
			 "problems with fo cnt");
	  /* mark dominator gates from clstLdr to clstLdr2 */
	  ldr = nnfGates[foId].clstLdr; 
	  while (ldr!=nnfGates[foId].clstLdr2) {
	    if (nnfGates[ldr].redGate || nnfGates[ldr].redJoin) {
	      disable = 1;
	    }
	    nnfGates[ldr].foAux2 = 1;
	    ldr = nnfGates[ldr].fo[0];
	  } 
	  nnfGates[ldr].foAux2 = 1;
	  if (!disable) {
	  // sort lists by clstLdr2 !!!
	  for (k0=j-1;(k0>=0) && 
		 nnfGates[nnfGates[i].fo[k0]].clstLdr2==ldr2; k0--);
	  for (k1=j+1;(k1<nnfGates[i].foCnt) && 
		 nnfGates[nnfGates[i].fo[k1]].clstLdr2==ldr2; k1++);
     	  for (k=k0+1; k<k1; k++) {
	  //	  for (k=0; k<nnfGates[i].foCnt; k++) {
	    int foId_k = nnfGates[i].fo[k];
	    if (k==j) continue;
	    if (nnfGates[foId_k].redGate) continue;
	    implied = nnfGates[nnfGates[foId_k].clstLdr].foAux2;
	    if (implied) {
	      /* dominated */
	      int isAnd_k = nnfCoreMgr->gateType[foId_k] == 'A';
	      red2++;
	      nRedTot++;
	      if (isAnd ^ isAnd_k) {
		nnfGates[foId].baig = isAnd ? bAig_Zero : bAig_One;
		reduced=1;
	      }
	      else {
		if (nnfGates[foId].fi.r==i) {
		  nnfGates[foId].fi.r = -1;
		  reduced=1;
		}
		else if (nnfGates[foId_k].fi.l==i) {
		  nnfGates[foId].fi.l = -1;
		  reduced=1;
		}
	      }
	      if (reduced) {
		nnfGates[foId].redGate = 1;
		if (0) printf("RED: %d - %d: ldr: %d\n",
			 foId, foId_k, nnfGates[foId_k].clstLdr);
		break;
	      }
	    }
	    else if (1&&(nnfGates[foId].clstLdr2==nnfGates[foId_k].clstLdr2)) {
	      if (nnfGates[foId].clstLdr == nnfGates[foId_k].clstLdr) {
		red2++;
		reduced=1;
		if (nnfGates[foId].fi.r==i) {
		  nnfGates[foId].fi.r = -1;
		}
		else if (nnfGates[foId].fi.l==i) {
		  nnfGates[foId].fi.l = -1;
		}
		break;
	      }
	      else {
		int foIdLdr = nnfGates[foId].clstLdr;
		int foIdLdrFo = nnfGates[foIdLdr].fo[0];
		int foId_k_Ldr = nnfGates[foId_k].clstLdr;
		int foId_k_LdrFo = nnfGates[foId_k_Ldr].fo[0];
		int tmp, swapped = 0, kk, kFo;
		if (doEnJoin && (nnfGates[foIdLdrFo].clstLdr == 
		     nnfGates[foId_k_LdrFo].clstLdr) && 
		    (!nnfGates[foIdLdrFo].redGate) &&
		    (!nnfGates[foId_k_LdrFo].redGate)) {
		  if (1 && (foIdLdrFo != foId_k_LdrFo)) {
		    // shuffle gates 
		    int foIdLdrFoDominates = 0, enJoin = doEnJoin || 
		      (maxJoin-->0);
		    if (0 && (foIdLdrFo == 340786 || foIdLdrFo == 340783 || 
			      foId_k_LdrFo == 340786 || foId_k_LdrFo == 340783)) {
		      printf("OOO\n");
		    } 
		    //		    nnfGates[foId_k_LdrFo].redGate = 1;
		    for (kk = foId_k_LdrFo; 
			 kk!=nnfGates[foIdLdrFo].clstLdr;
			 kk=kFo) {
		      kFo = nnfGates[kk].fo[0];
		      if (kFo==foIdLdrFo) {
			foIdLdrFoDominates = 1; break;
		      }
		    }
		    if (!foIdLdrFoDominates) {
		      if (nnfGates[foIdLdrFo].fi.r==foIdLdr) {
			tmp = nnfGates[foIdLdrFo].fi.l;
		      }
		      else {
			tmp = nnfGates[foIdLdrFo].fi.r;
		      } 
		      if (0 && (tmp>foId_k_LdrFo)) {
			// no dominance - need to force swap to keep 
			// stable sorting
      			foIdLdrFoDominates = 1;
			//      			enJoin = 0;
		      }
		      //		      enJoin = 0;
		    }
		    if (foIdLdrFoDominates && enJoin) {
		      // Pdtutil_Assert(foIdLdr<foId_k_LdrFo,"problem with macrogate sorting");
		      //    if (foIdLdr>foId_k_LdrFo)
		      if (nnfGates[foId_k_LdrFo].fi.r==foId_k_Ldr) {
			tmp = nnfGates[foId_k_LdrFo].fi.l;
			if (tmp>=0)
			  nnfGates[foId_k_LdrFo].fi.l = foIdLdr;
			else enJoin = 0;
		      }
		      else {
			Pdtutil_Assert(nnfGates[foId_k_LdrFo].fi.l==
				       foId_k_Ldr,"problem");
			tmp = nnfGates[foId_k_LdrFo].fi.r;
			if (tmp>=0)
			  nnfGates[foId_k_LdrFo].fi.r = foIdLdr;
			else enJoin = 0;
		      } 
		      //    if (tmp>foIdLdrFo || 
		      if (tmp>=0) {
			if (maxJoin<500) {
			  printf("maxjoin: %d\n", maxJoin);
			}
			if (nnfGates[foIdLdrFo].fi.r==foIdLdr) {
			  nnfGates[foIdLdrFo].fi.r = tmp;
			}
			else {
			  Pdtutil_Assert(nnfGates[foIdLdrFo].fi.l==
					 foIdLdr,"problem");
			  nnfGates[foIdLdrFo].fi.l = tmp;
			} 
			// adjust new tmp fanout
			for (kk=0;(kk<nnfGates[tmp].foCnt); kk++) {
			  if (nnfGates[tmp].fo[kk]==foId_k_LdrFo) {
			    nnfGates[tmp].fo[kk]=foIdLdrFo;
			    break;
			  }
			}
			// reset foAux2 before changing fanout
			ldr = foIdLdr; 
			while (ldr!=nnfGates[foId].clstLdr2) {
			  Pdtutil_Assert(nnfGates[ldr].foAux2,
					 "foAux2 not set");
			  nnfGates[ldr].foAux2 = 0;
			  ldr = nnfGates[ldr].fo[0];
			} 
			Pdtutil_Assert(nnfGates[ldr].foAux2,
					 "foAux2 not set");
			nnfGates[ldr].foAux2 = 0;
			foAux2Set = 1;
			// adjust new foIdLdr fanout
			nnfGates[foIdLdr].fo[0] = foId_k_LdrFo;
			foIdLdrFo = foId_k_LdrFo;
		      }
		      else enJoin = 0;
		    }
		    else if (enJoin) {
		      // none is macrogate leader or foId_k_LdrFo is
		      //Pdtutil_Assert(foId_k_Ldr<foIdLdrFo, "problem with macrogate sorting");
		      if (nnfGates[foIdLdrFo].fi.r==foIdLdr) {
			tmp = nnfGates[foIdLdrFo].fi.l;
			nnfGates[foIdLdrFo].fi.l = foId_k_Ldr;
		      }
		      else {
			Pdtutil_Assert(nnfGates[foIdLdrFo].fi.l==
				       foIdLdr,"problem");
			tmp = nnfGates[foIdLdrFo].fi.r;
			nnfGates[foIdLdrFo].fi.r = foId_k_Ldr;
		      } 
		      if (nnfGates[foId_k_LdrFo].fi.r==foId_k_Ldr) {
			nnfGates[foId_k_LdrFo].fi.r = tmp;
		      }
		      else {
			Pdtutil_Assert(nnfGates[foId_k_LdrFo].fi.l==
				       foId_k_Ldr,"problem");
			nnfGates[foId_k_LdrFo].fi.l = tmp;
		      } 
		      // adjust new tmp fanout
		      if (tmp>=0)
			for (kk=0;(kk<nnfGates[tmp].foCnt); kk++) {
			  if (nnfGates[tmp].fo[kk]==foIdLdrFo) {
			    nnfGates[tmp].fo[kk]=foId_k_LdrFo;
			    break;
			  }
			}
		      // adjust new foId_k_Ldr fanout
		      nnfGates[foId_k_Ldr].fo[0] = foIdLdrFo;
		      foId_k_LdrFo = foIdLdrFo;
		    }
		    if (enJoin) {
		      swapped = 1;
		      nnfGates[foIdLdrFo].redGate = 1;
		    }
		  }
		}
		Pdtutil_Assert(foIdLdrFo==foId_k_LdrFo || !swapped,"problem");
		if (foIdLdrFo == foId_k_LdrFo) {
		  int foJoin = foIdLdrFo;
		  if (nnfGates[foJoin].redJoin<0) {
		    red3++;
		    nRedTot++;
		    reduced=1;
		    if (nnfGates[foId].fi.r==i) {
		      nnfGates[foId].fi.r = -1;
		    }
		    else if (nnfGates[foId].fi.l==i) {
		      nnfGates[foId].fi.l = -1;
		    }
		    if (nnfGates[foId_k].fi.r==i) {
		      nnfGates[foId_k].fi.r = -1;
		    }
		    else if (nnfGates[foId_k].fi.l==i) {
		      nnfGates[foId_k].fi.l = -1;
		    }
		    if (0)
		      printf("JOINING: %d - %d: ldr: %d - %d - in: %d\n",
			     foId_k, foId, nnfGates[foId_k].clstLdr,
			     nnfGates[foId].clstLdr, foJoin);
		    nnfGates[foJoin].redJoin = i;
		    nnfGates[foId].redGate = 1;
		    nnfGates[foId_k].redGate = 1;
		  }
		  else {
		    red3b++;
		  }
		  break;
		}
	      }
	    }
	  }
	  }
	  if (!foAux2Set) {
	    /* mark dominator gates from clstLdr to clstLdr2 */
	    ldr = nnfGates[foId].clstLdr; 
	    while (ldr!=nnfGates[foId].clstLdr2) {
	      Pdtutil_Assert(nnfGates[ldr].foAux2,
			     "foAux2 not set");
	      nnfGates[ldr].foAux2 = 0;
	      ldr = nnfGates[ldr].fo[0];
	    } 
	    Pdtutil_Assert(nnfGates[ldr].foAux2,
			   "foAux2 not set");
	    nnfGates[ldr].foAux2 = 0;
	  }
	}
      }
    }
    for (j=0; j<nnfGates[i].foCnt; j++) {
      int foId = nnfGates[i].fo[j];
      nnfGates[nnfGates[foId].clstLdr2].foAux = 0;
      nnfGates[nnfGates[foId].clstLdr2].redGate = 0;
      nnfGates[nnfGates[foId].clstLdr2].lastIn = -1;
    }
    if (red>0) {
      clstRed++;
    }
    if (red2>0) {
      clstRed2++;
    }
    if (red3>0) {
      clstRed3++;
      clstRed3a += red3;
      clstRed3b += red3b;
    }
  }

  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
  
  n = nnfCoreMgr->aNodes->num;
  
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    if (!nnfCoreMgr->isCore[i]) {
      if (nnfCoreMgr->gateType[i] != 'I') {
	int val = nnfCoreMgr->gateType[i] == 'A' ? 0 : 1;
	bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
	//Pdtutil_Assert(nodeAuxChar(bmgr,baig)==0,"aux char not clean");
	//	nodeAuxChar(bmgr,baig) = (char) ((val==0) ? -1 : 1);
	nRed++;
      }
    }
  }

  int start_ii = 0;
#if 0
  // sort gate indexes by clstLdr (macrogate
  for (i=0; i<n; i++) {
    auxV[i] = 0;
  }
  for (i=0; i<n; i++) {
    int ldr = nnfGates[i].clstLdr;
    Pdtutil_Assert(ldr>=0&&ldr<n,"wrong ldr2");
    auxV[ldr]++;
  }
  for (i=1; i<n; i++) {
    auxV[i] += auxV[i-1];
  }
  // foAux2 has the sorted indexes
  for (i=n-1; i>=0; i--) {
    int ldr = nnfGates[i].clstLdr;
    nnfGates[auxV[ldr]-1].foAux = i;
    nnfGates[i].foAux2 = auxV[ldr]-1;
    auxV[ldr]--;
  }
  // check SORTing
  for (i=1; i<nnfCoreMgr->aNodes->num; i++) {
    int ii0 = nnfGates[i-1].foAux;
    int ii = nnfGates[i].foAux;
    Pdtutil_Assert(nnfGates[ii0].clstLdr<=nnfGates[ii].clstLdr,
		   "sort problem");
  }

#else
  int ii, jj;
  /* TOPOLOGICAL SORT */

  /* first re-compute fanouts */
  for (i=0; i<n; i++) {
    nnfGates[i].foCnt=0;
  }
  for (i=0; i<n; i++) {
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int iJoin = nnfGates[i].redJoin;
    if (ir>=0)
      nnfGates[ir].foCnt++;
    if (il>=0)
      nnfGates[il].foCnt++;
    if (iJoin>=0)
      nnfGates[iJoin].foCnt++;
  }

  nnfGates[n-1].foAux = n-1;
  for (ii=jj=n-1; ii>=0; ii--) {
    bAigEdge_t baig;
    int ir, il, iJoin;

    Pdtutil_Assert(jj<=ii,"index problem");
    i = nnfGates[ii].foAux;
    baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig))
      continue; // skip it

    ir = nnfGates[i].fi.r;
    il = nnfGates[i].fi.l;
    iJoin = nnfGates[i].redJoin;

    if (ir>=0) {
      nnfGates[ir].foCnt--;
      if (nnfGates[ir].foCnt == 0) {
	// last fanout edge
	Pdtutil_Assert(jj>0,"wrong gate index");
	nnfGates[--jj].foAux = ir;
      }
    }
    if (il>=0) {
      nnfGates[il].foCnt--;
      if (nnfGates[il].foCnt == 0) {
	// last fanout edge
	Pdtutil_Assert(jj>0,"wrong gate index");
	nnfGates[--jj].foAux = il;
      }
    }
    if (iJoin>=0) {
      nnfGates[iJoin].foCnt--;
      if (nnfGates[iJoin].foCnt == 0) {
	// last fanout edge
	Pdtutil_Assert(jj>0,"wrong gate index");
	nnfGates[--jj].foAux = iJoin;
      }
    }
  }

  start_ii = jj;
  Pdtutil_Assert(start_ii>=0,"wrong gate start index");
#endif

  for (ii=start_ii; ii<n; ii++) {
    i = nnfGates[ii].foAux;
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    bAigEdge_t r, l, f = nnfGates[i].baig;
    int ir, il;

    if (f == bAig_NULL) {

      // printf("computing gate: %d ", i);
      if (bAig_NodeIsConstant(baig)) {
        f = bAig_Zero;
      }
      else if (bAig_isVarNode(bmgr,baig)) {
        f = bAig_NonInvertedEdge(baig);
	// printf("var\n", i);
      }
      else {
	int isAnd = nnfCoreMgr->gateType[i] == 'A';
        ir = nnfGates[i].fi.r;
        il = nnfGates[i].fi.l;
	//  printf("<- %d %d\n", ir, il);
	if (ir==-1) {
	  if (il==-1) {
	    f = isAnd ? bAig_One : bAig_Zero;
	  }
	  else {
	    f = nnfGates[il].baig;
	  }
	}
	else if (il==-1) {
	  f = nnfGates[ir].baig;
	}
	else {
	  r = nnfGates[ir].baig;
	  l = nnfGates[il].baig;
	  if (isAnd) 
	    f = bAig_And(bmgr,r,l);
	  else 
	    f = bAig_Or(bmgr,r,l);
	}
        if (nnfGates[i].redJoin>=0) {
	  int iJoin = nnfGates[i].redJoin;
	  r = nnfGates[iJoin].baig;
	  if (isAnd) {
	    f = bAig_Or(bmgr,f,r);
	  }
	  else {
	    f = bAig_And(bmgr,f,r);
	  }
	}
      }
      nnfGates[i].baig = f;
      bAig_Ref(bmgr, f);
    }
  }

  a2 = Ddi_BddMakeFromBaig(ddm,nnfGates[n-1].baig);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfGates[i].baig;
    bAig_RecursiveDeref(bmgr,baig);
    Pdtutil_Free(nnfGates[i].fo);
    Pdtutil_Free(nnfGates[i].foImpl);
    Pdtutil_Free(nnfGates[i].fiImpl);
  }

  Pdtutil_Free(nnfGates);
  Pdtutil_Free(auxV);

  nnfCoreMgrFree(nnfCoreMgr);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
    fprintf(dMgrO(ddm),
     "AIGNNF STRUCTOPT #red: D:%d/D2:%d, R:%d/R2:%d/R3:%d(%d/%d)\n", 
	    clstDup, clstDup2, clstRed, clstRed2, clstRed3, 
	    clstRed3a, clstRed3b);
    fprintf(dMgrO(ddm),
     "AIGNNF STRUCTOPT #red: %d - s %d->%d - R:%d/I:%d/R2:%d/I2:%d\n", 
	    nRed, sizeA, Ddi_BddSize(a2),
	    totRoot, totIn, totRoot2, totIn2);
    fprintf(dMgrO(ddm),
     "AIGNNF STRUCTOPT #ldr: %d - #ldrFi %.1f - clst Size: %.1f\n", 
       nLdr, ((float)nLdrFi)/nLdr, ((float)(n-nPi))/nLdr);
  }

  if (chkRes) {
    Pdtutil_Assert(Ddi_AigEqualSat(a2,a),"error in AIG NNF STRUCT OPT");
  }

  return(a2);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigNnfTransImplSimplify (
  Ddi_Bdd_t *a
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *a2=NULL;
  int sizeA;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, n;
  int totRoot=0, totIn=0, totRoot2=0, totIn2=0, nRed=0, chkRes=0;
  int clstDup=0, clstDup2=0, clstRed2=0, clstRed3=0, clstRed=0;
  nnfGate_t *nnfGates;
  int nLdr=0, nLdrFi=0, nPi=0;
  //  int nRecImpl = 2;
  int totImplLdr=0, totLdr=0, totImplLdrInp=0, totImpFiLdr=0, 
    totImpLdrFiCnt=0, totImplRed=0, totTransFi=0;
  int *auxV, nAux=0;
  int totFiImpl0=0;
  int totFiImpl1=0;
  int totFiImpl2=0;
  int totFiImpl3=0;
  int enTransFi3=0; /* higher cost little impact */
  int *fiImplArray = NULL;
  
  static int nCalls=0, nRedTot=0;

  nCalls++;

  sizeA = Ddi_BddSize(a);
  if (sizeA < 4) {
    return Ddi_BddDup(a);
  }

  /* get array of baig nodes */
  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(a,NULL,NULL,NULL,NULL,1,0);
  n = nnfCoreMgr->aNodes->num; 

  nnfGates = Pdtutil_Alloc(nnfGate_t, n);
  auxV = Pdtutil_Alloc(int, n);

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].foCnt = nnfGates[i].foImplCnt = nnfGates[i].foAux = 
      nnfGates[i].fiImplCnt = nnfGates[i].fiTransImplCnt = 
      nnfGates[i].foAux2 = nnfGates[i].redGate = 0;
    nnfGates[i].fo = NULL;
    nnfGates[i].link = NULL;
    nnfGates[i].ldrCut = NULL;
    nnfGates[i].foImpl = NULL;
    nnfGates[i].fiImpl = NULL;
    nnfGates[i].ldrFiNum = 0;
    nnfGates[i].clstLdr = i;
    nnfGates[i].clstLdr2 = i;
    nnfGates[i].lastIn = 0;
    nnfGates[i].redJoin = -1;
    nnfGates[i].baig = bAig_NULL;
    nnfGates[i].fi.r = -1;
    nnfGates[i].fi.l = -1;
  }

  bAigArrayAuxIntSetId(bmgr,nnfCoreMgr->aNodes);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      nPi++;
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    nnfGates[ir].foCnt++;
    nnfGates[il].foCnt++;
    nnfGates[i].fi.r = ir;
    nnfGates[i].fi.l = il;
  }
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].fo = Pdtutil_Alloc(int, nnfGates[i].foCnt);
  }

  for (i=n-1; i>=0; i--) {
    int isOr, isOrL, isOrR;
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    isOr = nnfCoreMgr->gateType[i] == 'O';
    isOrR = nnfCoreMgr->gateType[ir] == 'O';
    isOrL = nnfCoreMgr->gateType[il] == 'O';
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[ir]) {
      if (nnfGates[ir].foCnt==1) {
	nnfGates[ir].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[il]) {
      if (nnfGates[il].foCnt==1) {
	nnfGates[il].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfGates[ir].foCnt==1) {
      nnfGates[ir].clstLdr2 = nnfGates[i].clstLdr2;
    }
    if (nnfGates[il].foCnt==1) {
      nnfGates[il].clstLdr2 = nnfGates[i].clstLdr2;
    }

    nnfGates[ir].fo[nnfGates[ir].foAux++] = i;
    nnfGates[il].fo[nnfGates[il].foAux++] = i;

    if (nnfGates[i].clstLdr==i) {
      totRoot++;
    }
    else {
      totIn++;
    }
    if (nnfGates[i].clstLdr2==i) {
      totLdr++;
      totRoot2++;
    }
    else {
      totIn2++;
    }
  }

  for (i=0; i<n; i++) {
    int isOr, isOrL, isOrR;
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr2;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr2 == ir) {
	nnfGates[ldr].ldrFiNum++;
      }
      if (nnfGates[il].clstLdr2 == il) {
	nnfGates[ldr].ldrFiNum++;
      }
      if (ldr == nnfGates[i].clstLdr) {
	if (nnfGates[ir].clstLdr2 == ir) {
	  nnfGates[ir].foImplCnt++;
	  nnfGates[ldr].fiImplCnt++;
	}
	if (nnfGates[il].clstLdr2 == il) {
	  nnfGates[il].foImplCnt++;
	  nnfGates[ldr].fiImplCnt++;
	}
      }
    }
  }

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    if (nnfGates[i].foImplCnt>0) {
      Pdtutil_Assert(nnfGates[i].foCnt>1,"problem with impl fo");
      nnfGates[i].foImpl = Pdtutil_Alloc(int, nnfGates[i].foImplCnt);
    }
    if (nnfGates[i].fiImplCnt>0) {
      totImpFiLdr++;
      totImpLdrFiCnt += nnfGates[i].fiImplCnt;
    }
  }

  //  fiImplArray = Pdtutil_Alloc(int, totImpLdrFiCnt);
  totImpLdrFiCnt = 0;

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    if (nnfGates[i].fiImplCnt>0) {
      //     nnfGates[i].fiImpl = fiImplArray + totImpLdrFiCnt;
      nnfGates[i].fiImpl = Pdtutil_Alloc(int, nnfGates[i].fiImplCnt);
      totImpLdrFiCnt += nnfGates[i].fiImplCnt;
    }
  }

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    if (nnfGates[i].foImplCnt>0) {
      int j, k=0;
      Pdtutil_Assert(nnfGates[i].clstLdr2==i,"problem with impl ldr");
      totImplLdr++;
      totImplLdrInp += nnfGates[i].foImplCnt;
      for (j=k=0; j<nnfGates[i].foCnt; j++) {
	int foId = nnfGates[i].fo[j];
	if (nnfGates[foId].clstLdr2 == nnfGates[foId].clstLdr) {
	  int ldr = nnfGates[foId].clstLdr2;
	  nnfGates[i].foImpl[k++] = foId;
	  nnfGates[ldr].fiImpl[nnfGates[ldr].lastIn++] = i;
	  //	  printf("impl: %d -> %d\n", i, ldr);
      	}
      }
      Pdtutil_Assert(k==nnfGates[i].foImplCnt,"error counting impl fo");
    }
  }

  for (i=0; i<n; i++) {
    Pdtutil_Assert(nnfGates[i].lastIn==nnfGates[i].fiImplCnt,"impl fi problem");
    nnfGates[i].lastIn = 0;
    if (nnfGates[i].clstLdr2 == i && nnfGates[i].ldrFiNum>0) {
      nLdr++;
      nLdrFi += nnfGates[i].ldrFiNum;
      nnfGates[i].ldrCut = Pdtutil_Alloc(int, nnfGates[i].ldrFiNum*2);
    }
  }

  for (i=0; i<n; i++) {
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr2;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr2 == ir) {
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = ir;
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = i;
      }
      if (nnfGates[il].clstLdr2 == il) {
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = il;
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = i;
      }
    }
  }

  for (i=0; i<n; i++) {
    Pdtutil_Assert(nnfGates[i].lastIn==2*nnfGates[i].ldrFiNum,"impl fi problem");
    nnfGates[i].foAux = 0;
  }

  // filter out duplicates
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    int j, k;
    if (nnfGates[i].fiImplCnt <= 1) continue;
    for (j=0; j<nnfGates[i].fiImplCnt; j++) {
      int impl = nnfGates[i].fiImpl[j];
      nnfGates[impl].foAux++;
    }
    for (j=k=0; j<nnfGates[i].fiImplCnt; j++) {
      int impl = nnfGates[i].fiImpl[j];
      if (nnfGates[impl].foAux==1) {
	nnfGates[i].fiImpl[k++] = impl;
      }
      nnfGates[impl].foAux--;
    }
    Pdtutil_Assert(k<=nnfGates[i].fiImplCnt,"ellor filtering dups");
    nnfGates[i].fiImplCnt = k;
  }


  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    int j, k;
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr2;
    int isAnd = nnfCoreMgr->gateType[i] == 'A';

    if (nnfGates[i].clstLdr2 != i) continue;
    if (nnfGates[i].fiImplCnt == 0) continue;
    Pdtutil_Assert(ir>=0&&il>=0,"fi problem");

    for (j=0; j<nnfGates[i].fiImplCnt; j++) {
      int impl = nnfGates[i].fiImpl[j];
      int isAnd_j = nnfCoreMgr->gateType[impl] == 'A';
      if (!(isAnd ^ isAnd_j)) {
	Pdtutil_Assert(nnfGates[impl].clstLdr2 == impl,"impl ldr2 error");
	// take transitive implications
	for (k=0; k<nnfGates[impl].fiImplCnt; k++) {
	  int impl_k = nnfGates[impl].fiImpl[k];
	  if (nnfGates[impl_k].foAux++ == 0) {
	    auxV[nAux++] = impl_k;
	  }
	}
      }
      // add direct implication
      if (nnfGates[impl].foAux++ == 0) {
	auxV[nAux++] = impl;
      }
    }

    if (0) {
      int ii,jj;
      for (ii=0; ii<nAux; ii++) {
	for (jj=0; jj<ii; jj++) {
	  Pdtutil_Assert(auxV[ii]!=auxV[jj],"duplicate impl");
	}
      }
    }
    // look for redundant inputs
    for (j=0; j<nnfGates[i].ldrFiNum; j++) {
      int pin = nnfGates[i].ldrCut[2*j];
      int gate = nnfGates[i].ldrCut[2*j+1];
      int implied = 0;
      int redVal = -1;
      int isAnd_gate = nnfCoreMgr->gateType[gate] == 'A';
      Pdtutil_Assert(nnfGates[gate].clstLdr2 == i,"ldr2 problem");

      if (nnfGates[pin].foAux > 0) {
	// implied
	implied = 1;
	if (nnfGates[gate].clstLdr == i) {
	  // this is an (non transitive) implying input
	  if (nnfGates[pin].foAux == 1) {
	    // not redundant
	    implied = 0;
	  }
	  else {
	    // decrement to prevent multiple deletion
	    nnfGates[pin].foAux--;
	  }
	}
      }
      else {
        int ir = nnfGates[pin].fi.r;
        int il = nnfGates[pin].fi.l;
	int implCnt=0;
	if (ir>=0 && il>=0) {
	  int isAnd_pin = nnfCoreMgr->gateType[pin] == 'A';
	  if (nnfGates[ir].foAux > 0) implCnt++;
	  if (nnfGates[il].foAux > 0) implCnt++;
	  if (implCnt==2) {
	    totFiImpl2++;
	    /* two pins implied: gate implied ! */
	    implied = 1;
	  }
	  else if (implCnt==1) {
	    if (isAnd ^ isAnd_pin) {
	      totFiImpl1++;
	      /* 1 pin implied: gate of other type: other pin redundant ! */
	      implied = 1;
	    }
	    else {
	      totFiImpl0++;
	      /* implied input pin, propagate other val */
	      if (nnfGates[il].foAux > 0) redVal = ir;
	      else redVal = il;
	      implied = 2;
	    }
	  }
	  else if (enTransFi3 && (isAnd ^ isAnd_pin)) {
	    int kk;
	    /* look for an implying implied node */
	    for (kk=0; kk<nnfGates[pin].fiImplCnt; kk++) {
	      int impl_kk = nnfGates[pin].fiImpl[kk];
	      if (nnfGates[impl_kk].foAux) {
		/* implied */
		totFiImpl3++;
		implied = 1;
		break;
	      }
	    }
	  }
	}
      }
      if (implied) {
	totImplRed++;
	if ((isAnd ^ isAnd_gate) && implied==1) {
	  nnfGates[gate].baig = isAnd_gate ? bAig_Zero : bAig_One;
	}
	else {
	  if (nnfGates[gate].fi.r==pin) {
	    nnfGates[gate].fi.r = redVal;
	  }
	  else if (nnfGates[gate].fi.l==pin) {
	    nnfGates[gate].fi.l = redVal;
	  }
	}
      }

    }

    // store new list of implications and reset
    nnfGates[i].fiImpl = Pdtutil_Realloc(int, nnfGates[i].fiImpl, nAux);
    nnfGates[i].fiImplCnt = nAux;
    for (j=0; j<nAux; j++) {
      int impl = auxV[j];
      nnfGates[i].fiImpl[j] = impl;
      nnfGates[impl].foAux = 0;
    }
    totTransFi+=nAux;
    nAux = 0;
  }



  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
  
  n = nnfCoreMgr->aNodes->num;
  
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    if (!nnfCoreMgr->isCore[i]) {
      if (nnfCoreMgr->gateType[i] != 'I') {
	int val = nnfCoreMgr->gateType[i] == 'A' ? 0 : 1;
	bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
	//Pdtutil_Assert(nodeAuxChar(bmgr,baig)==0,"aux char not clean");
	//	nodeAuxChar(bmgr,baig) = (char) ((val==0) ? -1 : 1);
	nRed++;
      }
    }
  }

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    bAigEdge_t r, l, f = nnfGates[i].baig;
    int ir, il;

    if (f == bAig_NULL) {
      if (bAig_NodeIsConstant(baig)) {
        f = bAig_Zero;
      }
      else if (bAig_isVarNode(bmgr,baig)) {
        f = bAig_NonInvertedEdge(baig);
      }
      else {
	int isAnd = nnfCoreMgr->gateType[i] == 'A';
        ir = nnfGates[i].fi.r;
        il = nnfGates[i].fi.l;
	if (ir==-1) {
	  if (il==-1) {
	    f = isAnd ? bAig_One : bAig_Zero;
	  }
	  else {
	    f = nnfGates[il].baig;
	  }
	}
	else if (il==-1) {
	  f = nnfGates[ir].baig;
	}
	else {
	  r = nnfGates[ir].baig;
	  l = nnfGates[il].baig;
	  if (isAnd) 
	    f = bAig_And(bmgr,r,l);
	  else 
	    f = bAig_Or(bmgr,r,l);
	}
        if (nnfGates[i].redJoin>=0) {
	  int iJoin = nnfGates[i].redJoin;
	  r = nnfGates[iJoin].baig;
	  if (isAnd) {
	    f = bAig_Or(bmgr,f,r);
	  }
	  else {
	    f = bAig_And(bmgr,f,r);
	  }
	}
      }
      nnfGates[i].baig = f;
      bAig_Ref(bmgr, f);
    }
  }

  a2 = Ddi_BddMakeFromBaig(ddm,nnfGates[n-1].baig);

  //  Pdtutil_Free(fiImplArray);
  
  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfGates[i].baig;
    bAig_RecursiveDeref(bmgr,baig);
    Pdtutil_Free(nnfGates[i].fo);
    Pdtutil_Free(nnfGates[i].foImpl);
    Pdtutil_Free(nnfGates[i].fiImpl);
    Pdtutil_Free(nnfGates[i].link);
    Pdtutil_Free(nnfGates[i].ldrCut);
  }

  Pdtutil_Free(nnfGates);
  Pdtutil_Free(auxV);

  nnfCoreMgrFree(nnfCoreMgr);

  if (totImplRed>0) {
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
     fprintf(dMgrO(ddm),
     "AIGNNF TRANS IMPL impl ldr fo:%d/%d (fi:%d/%d) - #ldr:%d - red:%d\n", 
	    totImplLdr, totImplLdrInp, totImpFiLdr, totImpLdrFiCnt, 
	    totLdr, totImplRed);
     printf("TRANS IMPL: %d -> %d (tot trans IMPL: %d)\n", 
	    Ddi_BddSize(a), Ddi_BddSize(a2), totTransFi);
     printf("TRANS IMPL IND 2: %d/%d/%d (2: %d)\n", 
	    totFiImpl0, totFiImpl1, totFiImpl3, totFiImpl2);
    }
  }


  if (chkRes && totImplRed>0) {
    if (chkRes==1 || sizeA<50000) 
      Pdtutil_Assert(Ddi_AigEqualSat(a2,a),"error in AIG NNF STRUCT OPT");
  }

  return(a2);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigNnfClustNormalize (
  Ddi_Bdd_t *a,
  int leftFirst
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *a2=NULL;
  int sizeA;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, n, maxLdrFiNum;
  int totRoot=0, totIn=0, totRoot2=0, totIn2=0, nRed=0, chkRes=0;
  int clstDup=0, clstDup2=0, clstRed2=0, clstRed3=0, clstRed=0;
  nnfGate_t *nnfGates;
  int nLdr=0, nLdrFi=0, nPi=0;
  int splitNorm[10] = {0};
  int splitNorm0[10] = {0};
  int foCnt2Max=0, foCnt2Min, foCntMax=0, foCntRed=0;
  float hitRatio = 0.9;
  int hitLow=0, hitHigh=0;
  static int nCalls=0, nRedTot=0, potNorm=0, potNorm0=0;
  int fastRun = 0;
  
  nCalls++;

  sizeA = Ddi_BddSize(a);
  if (sizeA < 4) {
    return Ddi_BddDup(a);
  }

  fastRun = sizeA < 1000000;
  
  /* get array of baig nodes */
  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(a,NULL,NULL,NULL,NULL,1,leftFirst);
  n = nnfCoreMgr->aNodes->num; 

  nnfGates = Pdtutil_Alloc(nnfGate_t, n);

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].foCnt = nnfGates[i].foAux = 
      nnfGates[i].foAux2 = nnfGates[i].redGate = 0;
    nnfGates[i].fo = NULL;
    nnfGates[i].link = NULL;
    nnfGates[i].ldrCut = NULL;
    nnfGates[i].ldrFiNum = 0;
    nnfGates[i].clstLdr = i;
    nnfGates[i].clstLdr2 = i;
    nnfGates[i].lastIn = 0;
    nnfGates[i].redJoin = -1;
    nnfGates[i].baig = bAig_NULL;
    nnfGates[i].fi.r = -1;
    nnfGates[i].fi.l = -1;
  }

  bAigArrayAuxIntSetId(bmgr,nnfCoreMgr->aNodes);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      nPi++;
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    nnfGates[ir].foCnt++;
    nnfGates[il].foCnt++;
    nnfGates[i].fi.r = ir;
    nnfGates[i].fi.l = il;
  }
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].fo = Pdtutil_Alloc(int, nnfGates[i].foCnt);
  }

  for (i=n-1; i>=0; i--) {
    int isOr, isOrL, isOrR;
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    isOr = nnfCoreMgr->gateType[i] == 'O';
    isOrR = nnfCoreMgr->gateType[ir] == 'O';
    isOrL = nnfCoreMgr->gateType[il] == 'O';
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[ir]) {
      if (nnfGates[ir].foCnt==1) {
	nnfGates[ir].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[il]) {
      if (nnfGates[il].foCnt==1) {
	nnfGates[il].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfGates[ir].foCnt==1) {
      nnfGates[ir].clstLdr2 = nnfGates[i].clstLdr2;
    }
    if (nnfGates[il].foCnt==1) {
      nnfGates[il].clstLdr2 = nnfGates[i].clstLdr2;
    }

    nnfGates[ir].fo[nnfGates[ir].foAux++] = i;
    nnfGates[il].fo[nnfGates[il].foAux++] = i;

    if (nnfGates[i].clstLdr==i) {
      totRoot++;
    }
    else {
      totIn++;
    }
    if (nnfGates[i].clstLdr2==i) {
      totRoot2++;
    }
    else {
      totIn2++;
    }
  }

  for (i=0; i<n; i++) {
    int isOr, isOrL, isOrR;
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr == ir) {
	nnfGates[ldr].ldrFiNum++;
      }
      if (nnfGates[il].clstLdr == il) {
	nnfGates[ldr].ldrFiNum++;
      }
    }
  }

  for (i=0; i<n; i++) {
    int t;
    int foCnt2=0;
    nnfGates[i].foAux = 0;
    if (nnfGates[i].clstLdr == i && nnfGates[i].ldrFiNum>0) {
      nLdr++;
      nLdrFi += nnfGates[i].ldrFiNum;
      nnfGates[i].ldrCut = Pdtutil_Alloc(int, nnfGates[i].ldrFiNum);
    }
    for (t=0; t<nnfGates[i].foCnt; t++) {
      int foId_t = nnfGates[i].fo[t];
      int other;
      int rr = nnfGates[foId_t].fi.r;
      int ll = nnfGates[foId_t].fi.l;
      if (rr==i) other = ll;
      else other = rr;
      if (nnfGates[other].foCnt>1000) {
	foCnt2++;
      }
    }
    if (foCnt2>foCnt2Max) {
      foCnt2Max = foCnt2;
    }
    if (nnfGates[i].foCnt > foCntMax){
      foCntMax = nnfGates[i].foCnt;
    }
  }
  //  printf("FOcnt Max: %d/%d\n", foCnt2Max, foCntMax);
  foCnt2Max = 0;
  foCnt2Min = foCntMax;

  for (i=0; i<n; i++) {
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr == ir) {
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = ir;
      }
      if (nnfGates[il].clstLdr == il) {
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = il;
      }
    }
  }

  maxLdrFiNum = 0;
  for (i=0; i<n; i++) {
    if (nnfGates[i].ldrFiNum>maxLdrFiNum) {
      maxLdrFiNum = nnfGates[i].ldrFiNum;
    }
    if (nnfGates[i].clstLdr == i && nnfGates[i].ldrFiNum>0) {
      int isAnd = nnfCoreMgr->gateType[i] == 'A';
      int k, locNorm=0, locNorm0=0;
      for (k=0; k<nnfGates[i].ldrFiNum; k++) {
	int in = nnfGates[i].ldrCut[k];
	if (in<0) continue;
	nnfGates[in].foAux2 = 1+k;
      }
      for (k=0; k<nnfGates[i].ldrFiNum; k++) {
	int t, in = nnfGates[i].ldrCut[k];
	if (in<0) continue;
        if (fastRun && k>100) break;
	for (t=0; t<nnfGates[in].foCnt; t++) {
	  int foId_t = nnfGates[in].fo[t];
	  // if (nnfGates[foId_t].clstLdr != i) {
	  if (nnfGates[foId_t].clstLdr < i) {
	    int isAnd_t = nnfCoreMgr->gateType[foId_t] == 'A';
	    if (!(isAnd_t ^ isAnd)) {
	      int other;
	      int rr = nnfGates[foId_t].fi.r;
	      int ll = nnfGates[foId_t].fi.l;
	      if (rr==in) other = ll;
	      else other = rr;
	      if (nnfGates[other].foAux2) {
		potNorm++;
		locNorm++;
		if (nnfGates[foId_t].clstLdr < i) {
		  potNorm0++;
		  locNorm0++;
		}
#if 0
		printf("refactoring: %d %c %d (%d,%d)\n", 
		       rr, isAnd ? '&': '|',ll, i, 
		       nnfGates[foId_t].clstLdr);
#endif
		nnfGates[i].ldrCut[k] = foId_t;
		nnfGates[i].ldrCut[nnfGates[other].foAux2-1] = -1;
		nnfGates[rr].foAux2 = 0;
		nnfGates[ll].foAux2 = 0;
#if 0
		if (t<(nnfGates[in].foCnt*hitRatio)) {
		  hitLow++;
		}
		else {
		  hitHigh++;
		}
		if (0 && potNorm%1000 == 0) {
		  printf("REDUCED fo hit: low %d / high %d /%d\n", 
			 hitLow, hitHigh, potNorm);
		}
#endif
		break;
	      }
	    }
	  }
	}
      }
      if (locNorm >= 10) locNorm = 9;
      if (locNorm0 >= 10) locNorm0 = 9;
      splitNorm[locNorm]++;
      splitNorm0[locNorm0]++;
      for (k=0; k<nnfGates[i].ldrFiNum; k++) {
	int in = nnfGates[i].ldrCut[k];
	if (in<0) continue;
	nnfGates[in].foAux2 = 0;
      }
    }
  }


  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
  
  n = nnfCoreMgr->aNodes->num;
  
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    if (!nnfCoreMgr->isCore[i]) {
      if (nnfCoreMgr->gateType[i] != 'I') {
	int val = nnfCoreMgr->gateType[i] == 'A' ? 0 : 1;
	bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
	//Pdtutil_Assert(nodeAuxChar(bmgr,baig)==0,"aux char not clean");
	//	nodeAuxChar(bmgr,baig) = (char) ((val==0) ? -1 : 1);
	nRed++;
      }
    }
  }

  bAigEdge_t *cutBaigs = Pdtutil_Alloc(bAigEdge_t, maxLdrFiNum);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    bAigEdge_t r, l, f = nnfGates[i].baig;
    int ir, il;

    if (f == bAig_NULL) {
      if (bAig_NodeIsConstant(baig)) {
        f = bAig_Zero;
      }
      else if (bAig_isVarNode(bmgr,baig)) {
        f = bAig_NonInvertedEdge(baig);
      }
      else if (nnfGates[i].clstLdr == i && nnfGates[i].ldrFiNum>0) {
	int isAnd = nnfCoreMgr->gateType[i] == 'A';
	int k, t;
	f = isAnd ? bAig_One : bAig_Zero;
	for (k=t=0; k<nnfGates[i].ldrFiNum; k++) {
	  int in = nnfGates[i].ldrCut[k];
	  if (in<0) continue;
	  Pdtutil_Assert(in<=i,"forward merge in nnf normalize");
	  cutBaigs[t++] = nnfGates[in].baig;
	  bAig_Ref(bmgr, nnfGates[in].baig);
	}
	while (t>1) {
	  for (k=0; k<t; k++) {
	    if (k%2==0) {
	      cutBaigs[k/2] = cutBaigs[k];
	    }
	    else {
	      if (isAnd) {
		f = bAig_And(bmgr,cutBaigs[k/2],cutBaigs[k]);
	      }
	      else {
		f = bAig_Or(bmgr,cutBaigs[k/2],cutBaigs[k]);
	      }
	      bAig_Ref(bmgr, f);
	      bAig_RecursiveDeref(bmgr,cutBaigs[k/2]);
	      bAig_RecursiveDeref(bmgr,cutBaigs[k]);
	      cutBaigs[k/2] = f;
	    }
	  }
	  t = (k+1)/2;
	}
	f = cutBaigs[0];
	bAig_Deref(bmgr, f);
#if 0
	for (k=t=0; k<nnfGates[i].ldrFiNum; k++) {
	  int in = nnfGates[i].ldrCut[k];
	  if (in<0) continue;
	  Pdtutil_Assert(in<=i,"forward merge in nnf normalize");
	  r = nnfGates[in].baig;
	  if (isAnd) {
	    f = bAig_And(bmgr,f,r);
	  }
	  else {
	    f = bAig_Or(bmgr,f,r);
	  }
	}
#endif
      }
      else {
	int isAnd = nnfCoreMgr->gateType[i] == 'A';
        ir = nnfGates[i].fi.r;
        il = nnfGates[i].fi.l;
	if (ir==-1) {
	  if (il==-1) {
	    f = isAnd ? bAig_One : bAig_Zero;
	  }
	  else {
	    f = nnfGates[il].baig;
	  }
	}
	else if (il==-1) {
	  f = nnfGates[ir].baig;
	}
	else {
	  r = nnfGates[ir].baig;
	  l = nnfGates[il].baig;
	  if (isAnd) 
	    f = bAig_And(bmgr,r,l);
	  else 
	    f = bAig_Or(bmgr,r,l);
	}
        if (nnfGates[i].redJoin>=0) {
	  int iJoin = nnfGates[i].redJoin;
	  r = nnfGates[iJoin].baig;
	  if (isAnd) {
	    f = bAig_Or(bmgr,f,r);
	  }
	  else {
	    f = bAig_And(bmgr,f,r);
	  }
	}
      }
      nnfGates[i].baig = f;
      bAig_Ref(bmgr, f);
    }
  }

  Pdtutil_Free(cutBaigs);

  a2 = Ddi_BddMakeFromBaig(ddm,nnfGates[n-1].baig);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfGates[i].baig;
    bAig_RecursiveDeref(bmgr,baig);
    Pdtutil_Free(nnfGates[i].fo);
    Pdtutil_Free(nnfGates[i].link);
    Pdtutil_Free(nnfGates[i].ldrCut);
  }

  Pdtutil_Free(nnfGates);

  nnfCoreMgrFree(nnfCoreMgr);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
    fprintf(dMgrO(ddm),
     "AIGNNF NORMALIZE #ldr: %d - #ldrFi %.1f - clst Size: %.1f ", 
       nLdr, ((float)nLdrFi)/nLdr, ((float)(n-nPi))/nLdr);
    for (i=1; i<10; i++) {
      if (splitNorm[i]>0) {
	fprintf(dMgrO(ddm)," L[%d]:%d", i, splitNorm[i]);
      }
    }
    fprintf(dMgrO(ddm)," |");
    for (i=1; i<10; i++) {
      if (splitNorm[i]>0) {
	fprintf(dMgrO(ddm)," L0[%d]:%d", i, splitNorm0[i]);
      }
    }
    fprintf(dMgrO(ddm),"\n");
    fprintf(dMgrO(ddm),
     "AIGNNF NORMALIZE #pot: %d - #pot0: %d - s %d->%d\n", 
	    potNorm, potNorm0, sizeA, Ddi_BddSize(a2));
  }

  if (chkRes) {
    Pdtutil_Assert(Ddi_AigEqualSat(a2,a),"error in AIG NNF STRUCT OPT");
  }

  return(a2);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigNnfClustNormalize2 (
  Ddi_Bdd_t *a
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *a2=NULL;
  int sizeA;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, n, maxLdrFiNum;
  int totRoot=0, totIn=0, totRoot2=0, totIn2=0, chkRes=0;
  int clstDup=0, clstDup2=0, clstRed2=0, clstRed3=0, clstRed=0;
  nnfGate_t *nnfGates;
  int nLdr=0, nLdrFi=0, maxLdrFi=0, maxLdrFi2=0, nPi=0;
  int splitNorm[10] = {0};
  int splitNorm0[10] = {0};
  int foCnt2Max=0, foCnt2Min, foCntMax=0, foCntRed=0;
  float hitRatio = 0.9;
  int hitLow=0, hitHigh=0;
  int nRedTot=0, nNotRedTot=0, potNorm0=0;
  int *auxV, nAux=0;

  static int nCalls=0;

  nCalls++;

  sizeA = Ddi_BddSize(a);
  if (sizeA < 4) {
    return Ddi_BddDup(a);
  }

  /* get array of baig nodes */
  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(a,NULL,NULL,NULL,NULL,1,0);
  n = nnfCoreMgr->aNodes->num; 

  nnfGates = Pdtutil_Alloc(nnfGate_t, n);
  auxV = Pdtutil_Alloc(int, n);

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].foCnt = nnfGates[i].foAux = 
      nnfGates[i].foAux2 = nnfGates[i].redGate = 0;
    nnfGates[i].fo = NULL;
    nnfGates[i].ldrFiNum = 0;
    nnfGates[i].clstLdr = i;
    nnfGates[i].clstLdr2 = i;
    nnfGates[i].lastIn = 0;
    nnfGates[i].redJoin = -1;
    nnfGates[i].baig = bAig_NULL;
    nnfGates[i].fi.r = -1;
    nnfGates[i].fi.l = -1;
  }

  bAigArrayAuxIntSetId(bmgr,nnfCoreMgr->aNodes);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      nPi++;
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    nnfGates[ir].foCnt++;
    nnfGates[il].foCnt++;
    nnfGates[i].fi.r = ir;
    nnfGates[i].fi.l = il;
  }
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].fo = Pdtutil_Alloc(int, nnfGates[i].foCnt);
  }

  for (i=n-1; i>=0; i--) {
    int isOr, isOrL, isOrR;
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    isOr = nnfCoreMgr->gateType[i] == 'O';
    isOrR = nnfCoreMgr->gateType[ir] == 'O';
    isOrL = nnfCoreMgr->gateType[il] == 'O';
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[ir]) {
      if (nnfGates[ir].foCnt==1) {
	nnfGates[ir].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[il]) {
      if (nnfGates[il].foCnt==1) {
	nnfGates[il].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfGates[ir].foCnt==1) {
      nnfGates[ir].clstLdr2 = nnfGates[i].clstLdr2;
    }
    if (nnfGates[il].foCnt==1) {
      nnfGates[il].clstLdr2 = nnfGates[i].clstLdr2;
    }

    if (nnfGates[i].clstLdr==i) {
      totRoot++;
    }
    else {
      totIn++;
    }
    if (nnfGates[i].clstLdr2==i) {
      totRoot2++;
    }
    else {
      totIn2++;
    }
  }

  // sort gate indexes by clstLdr2
  for (i=0; i<n; i++) {
    auxV[i] = 0;
  }
  for (i=0; i<n; i++) {
    int ldr2 = nnfGates[i].clstLdr2;
    Pdtutil_Assert(ldr2>=0&&ldr2<n,"wrong ldr2");
    auxV[ldr2]++;
  }
  for (i=1; i<n; i++) {
    auxV[i] += auxV[i-1];
  }
  // foAux2 has the sorted indexes
  for (i=0; i<n; i++) {
    int ldr2 = nnfGates[i].clstLdr2;
    nnfGates[auxV[ldr2]-1].foAux2 = i;
    auxV[ldr2]--;
  }
  // check SORTing
  for (i=1; i<nnfCoreMgr->aNodes->num; i++) {
    int ii0 = nnfGates[i-1].foAux2;
    int ii = nnfGates[i].foAux2;
    Pdtutil_Assert(nnfGates[ii0].clstLdr2<=nnfGates[ii].clstLdr2,
		   "sort problem");
  }

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    int ii = nnfGates[i].foAux2;
    int ir = nnfGates[ii].fi.r;
    int il = nnfGates[ii].fi.l;
    
    if (ir>=0 && il>=0) {
      nnfGates[ir].fo[nnfGates[ir].foAux++] = ii;
      nnfGates[il].fo[nnfGates[il].foAux++] = ii;
    }
    nnfGates[i].foAux2 = 0;
    auxV[i] = 0;
  }

  for (i=0; i<n; i++) {
    int isOr, isOrL, isOrR;
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr == ir) {
	nnfGates[ldr].ldrFiNum++;
      }
      if (nnfGates[il].clstLdr == il) {
	nnfGates[ldr].ldrFiNum++;
      }
    }
  }

  maxLdrFiNum = 0;
  for (i=0; i<n; i++) {
    int t;
    int foCnt2=0;
    nnfGates[i].foAux = 0;
    if (nnfGates[i].ldrFiNum>maxLdrFiNum) {
      maxLdrFiNum = nnfGates[i].ldrFiNum;
    }
    if (nnfGates[i].clstLdr == i && nnfGates[i].ldrFiNum>0) {
      if (nnfGates[i].ldrFiNum>3) {
	nLdr++;
	nLdrFi += nnfGates[i].ldrFiNum;
	if (maxLdrFi < nnfGates[i].ldrFiNum) {
	  maxLdrFi = nnfGates[i].ldrFiNum;
	}
	else if (maxLdrFi2 < nnfGates[i].ldrFiNum) {
	  maxLdrFi2 = nnfGates[i].ldrFiNum;
	}
      }
      nnfGates[i].ldrCut = Pdtutil_Alloc(int, nnfGates[i].ldrFiNum);
    }
    for (t=0; t<nnfGates[i].foCnt; t++) {
      int foId_t = nnfGates[i].fo[t];
      int other;
      int rr = nnfGates[foId_t].fi.r;
      int ll = nnfGates[foId_t].fi.l;
      if (rr==i) other = ll;
      else other = rr;
      if (nnfGates[other].foCnt>1000) {
	foCnt2++;
      }
    }
    if (foCnt2>foCnt2Max) {
      foCnt2Max = foCnt2;
    }
    if (nnfGates[i].foCnt > foCntMax){
      foCntMax = nnfGates[i].foCnt;
    }
  }
  //  printf("#macroGates / avg/max/max2 cut size: %d/%f/%d/%d\n", nLdr, 
  //	 ((float) nLdrFi)/nLdr, maxLdrFi, maxLdrFi2);
  //  printf("FOcnt Max: %d/%d\n", foCnt2Max, foCntMax);
  foCnt2Max = 0;
  foCnt2Min = foCntMax;

  for (i=0; i<n; i++) {
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr == ir) {
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = ir;
      }
      if (nnfGates[il].clstLdr == il) {
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = il;
      }
    }
  }

  int maxDelta = 1000;
  for (i=0; i<n; i++) {
    int t, j;
    if (nnfGates[i].clstLdr != i || nnfGates[i].foCnt==0) continue;
    if (nnfGates[i].redGate) continue;
    for (t=0; t<nnfGates[i].foCnt; t++) {
      int foId_t = nnfGates[i].fo[t];
      int ldr_t = nnfGates[foId_t].clstLdr;
      Pdtutil_Assert(nnfGates[ldr_t].ldrFiNum>0,"no cut");
      nnfGates[ldr_t].foAux2++;
    }
    for (j=i+1; j<n&&j<i+maxDelta; j++) {
      int t, nRed=0;
      int ldr0 = -1;
      if (nnfGates[j].clstLdr != j || nnfGates[j].foCnt==0) continue;
      if (nnfGates[j].redGate) continue;
      for (t=0; t<nnfGates[j].foCnt; t++) {
	int foId_t = nnfGates[j].fo[t];
	int ldr_t = nnfGates[foId_t].clstLdr;
	Pdtutil_Assert(nnfGates[ldr_t].ldrFiNum>0,"no cut");
	if (nnfGates[ldr_t].foAux2 > 0) {
	  /* i&&j possible in macrogate ldr_t */
	  /* re sort cut */
	  int k, k0=nnfGates[ldr_t].foAux, found0=0, found1=0;
	  int enable = 1;
	  if (k0>0) {
	    for (k=0; k<k0&&k<nnfGates[ldr_t].ldrFiNum; k++) {
	      int in = nnfGates[ldr_t].ldrCut[k];
	      if (in==i || in==j) {
		/* already used: disable */
		enable = 0;
	      }
	    }
	  }
	  if (enable) {
	    for (k=k0; k<nnfGates[ldr_t].ldrFiNum; k++) {
	      int n=nnfGates[ldr_t].ldrFiNum;
	      int in = nnfGates[ldr_t].ldrCut[k];
	      if (in==i) {
		if (found0++ > 0) {
		  /* dupplicate */
		  nnfGates[ldr_t].ldrCut[k] = nnfGates[ldr_t].ldrCut[n-1];
		  nnfGates[ldr_t].ldrFiNum--; n--;
		  /* retry same index */
		  k--; continue;
		}
		else if (k>k0)
		  nnfGates[ldr_t].ldrCut[k] = nnfGates[ldr_t].ldrCut[k0];
	      }
	      else if (in==j) {
		if (found1++ > 0) {
		  /* dupplicate */
		  nnfGates[ldr_t].ldrCut[k] = nnfGates[ldr_t].ldrCut[n-1];
		  nnfGates[ldr_t].ldrFiNum--; n--;
		  /* retry same index */
		  k--; continue;
		}
		else if (k!=(k0+1))
		  nnfGates[ldr_t].ldrCut[k] = nnfGates[ldr_t].ldrCut[k0+1];
	      }
	    }
	    if (ldr0<0) ldr0 = ldr_t;
	    nnfGates[ldr_t].ldrCut[k0] = i;
	    nnfGates[ldr_t].ldrCut[k0+1] = j;
	    Pdtutil_Assert(found0>=1 && found1>=1,"missing factor");
	    nnfGates[ldr_t].foAux += 2;
	    nnfGates[ldr_t].foAux2 = 0;
	    nRed++;
	  }
	}
      }
      if (nRed>1) {
	nRedTot += nRed-1;
	//	nnfGates[j].redGate = 1;
	break;
      }
      else {
	nNotRedTot++;
	if (nRed>0) {
	  Pdtutil_Assert(ldr0>=0,"no ldr0");
	  Pdtutil_Assert(nnfGates[ldr0].foAux>=2,"problem with ldr0");
	  nnfGates[ldr0].foAux -= 2;
	  Pdtutil_Assert(nnfGates[ldr0].foAux2==0,"problem with ldr0");
	  nnfGates[ldr0].foAux2 = 1;
	}
      }
    }
    for (t=0; t<nnfGates[i].foCnt; t++) {
      int foId_t = nnfGates[i].fo[t];
      int ldr_t = nnfGates[foId_t].clstLdr;
      nnfGates[ldr_t].foAux2 = 0;
    }
  }


  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
  
  n = nnfCoreMgr->aNodes->num;
  
  bAigEdge_t *cutBaigs = Pdtutil_Alloc(bAigEdge_t, maxLdrFiNum);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    bAigEdge_t r, l, f = nnfGates[i].baig;
    int ir, il;

    if (f == bAig_NULL) {
      if (bAig_NodeIsConstant(baig)) {
        f = bAig_Zero;
      }
      else if (bAig_isVarNode(bmgr,baig)) {
        f = bAig_NonInvertedEdge(baig);
      }
      else if (nnfGates[i].clstLdr == i && nnfGates[i].ldrFiNum>0) {
	int isAnd = nnfCoreMgr->gateType[i] == 'A';
	int k, t;
	f = isAnd ? bAig_One : bAig_Zero;
	for (k=t=0; k<nnfGates[i].ldrFiNum; k++) {
	  int in = nnfGates[i].ldrCut[k];
	  if (in<0) continue;
	  Pdtutil_Assert(in<=i,"forward merge in nnf normalize");
	  cutBaigs[t++] = nnfGates[in].baig;
	  bAig_Ref(bmgr, nnfGates[in].baig);
	}
	while (t>1) {
	  for (k=0; k<t; k++) {
	    if (k%2==0) {
	      cutBaigs[k/2] = cutBaigs[k];
	    }
	    else {
	      if (isAnd) {
		f = bAig_And(bmgr,cutBaigs[k/2],cutBaigs[k]);
	      }
	      else {
		f = bAig_Or(bmgr,cutBaigs[k/2],cutBaigs[k]);
	      }
	      bAig_Ref(bmgr, f);
	      bAig_RecursiveDeref(bmgr,cutBaigs[k/2]);
	      bAig_RecursiveDeref(bmgr,cutBaigs[k]);
	      cutBaigs[k/2] = f;
	    }
	  }
	  t = (k+1)/2;
	}
	f = cutBaigs[0];
	bAig_Deref(bmgr, f);
#if 0
	for (k=t=0; k<nnfGates[i].ldrFiNum; k++) {
	  int in = nnfGates[i].ldrCut[k];
	  if (in<0) continue;
	  Pdtutil_Assert(in<=i,"forward merge in nnf normalize");
	  r = nnfGates[in].baig;
	  if (isAnd) {
	    f = bAig_And(bmgr,f,r);
	  }
	  else {
	    f = bAig_Or(bmgr,f,r);
	  }
	}
#endif
      }
      else {
	int isAnd = nnfCoreMgr->gateType[i] == 'A';
        ir = nnfGates[i].fi.r;
        il = nnfGates[i].fi.l;
	if (ir==-1) {
	  if (il==-1) {
	    f = isAnd ? bAig_One : bAig_Zero;
	  }
	  else {
	    f = nnfGates[il].baig;
	  }
	}
	else if (il==-1) {
	  f = nnfGates[ir].baig;
	}
	else {
	  r = nnfGates[ir].baig;
	  l = nnfGates[il].baig;
	  if (isAnd) 
	    f = bAig_And(bmgr,r,l);
	  else 
	    f = bAig_Or(bmgr,r,l);
	}
        if (nnfGates[i].redJoin>=0) {
	  int iJoin = nnfGates[i].redJoin;
	  r = nnfGates[iJoin].baig;
	  if (isAnd) {
	    f = bAig_Or(bmgr,f,r);
	  }
	  else {
	    f = bAig_And(bmgr,f,r);
	  }
	}
      }
      nnfGates[i].baig = f;
      bAig_Ref(bmgr, f);
    }
  }

  Pdtutil_Free(cutBaigs);

  a2 = Ddi_BddMakeFromBaig(ddm,nnfGates[n-1].baig);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfGates[i].baig;
    bAig_RecursiveDeref(bmgr,baig);
    Pdtutil_Free(nnfGates[i].fo);
    Pdtutil_Free(nnfGates[i].ldrCut);
  }

  Pdtutil_Free(nnfGates);
  Pdtutil_Free(auxV);

  nnfCoreMgrFree(nnfCoreMgr);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
    fprintf(dMgrO(ddm),
     "AIGNNF REFACTOR #red: %d(%d) - s %d->%d\n", 
	    nRedTot, nNotRedTot, sizeA, Ddi_BddSize(a2));
  }

  if (chkRes) {
    Pdtutil_Assert(Ddi_AigEqualSat(a2,a),"error in AIG NNF STRUCT OPT");
  }

  return(a2);
}

static int printCut (
  nnfGate_t *nnfGates,
  int ldr
)
{
  int k, k0, n;
  n = nnfGates[ldr].ldrFiNum;
  k0 = nnfGates[ldr].foAux;
  printf("cut size: %d (sorted: %d)\n", n, k0);
  for (k=0; k<n; k++) {
    int in = nnfGates[ldr].ldrCut[k];
    if (k==k0) printf("| ");
    printf("[%d]%d ", k, in);
  }
  printf("\n");
}

static int resortCut (
  nnfGate_t *nnfGates,
  int ldr,
  int i,
  int j
)
{
  int k, k0, n;
  int found0=0, found1=0;

  k0 = nnfGates[ldr].foAux;
  n = nnfGates[ldr].ldrFiNum;
  Pdtutil_Assert(k0%2==0,"invalif foAux");
  Pdtutil_Assert(k0>=0,"invalif foAux");
  Pdtutil_Assert(k0<n,"invalif foAux");

	if (ldr==245623 && i==8382 && j==48867) {
	  printf("found\n");
	}

  //  printf("resorting: %d OP %d (%d)\n", i, j, ldr);

  for (k=k0; k<n; k++) {
    int in = nnfGates[ldr].ldrCut[k];
    if (in==i) {
      Pdtutil_Assert(found0==0,"dupicate in cut");
      found0++;
      if (k>k0)
	nnfGates[ldr].ldrCut[k] = nnfGates[ldr].ldrCut[k0];
    }
    else if (in==j) {
      Pdtutil_Assert(found1==0,"dupicate in cut");
      found1++;
      if (k!=(k0+1))
	nnfGates[ldr].ldrCut[k] = nnfGates[ldr].ldrCut[k0+1];
    }
  }
  Pdtutil_Assert(found0>=1 && found1>=1,"missing factor");
  nnfGates[ldr].ldrCut[k0] = i;
  nnfGates[ldr].ldrCut[k0+1] = j;
  nnfGates[ldr].foAux += 2;

  return 1;
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigNnfClustNormalize3 (
  Ddi_Bdd_t *a
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *a2=NULL;
  int sizeA;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, n, maxLdrFiNum;
  int totRoot=0, totIn=0, totRoot2=0, totIn2=0, chkRes=0;
  int clstDup=0, clstDup2=0, clstRed2=0, clstRed3=0, clstRed=0;
  nnfGate_t *nnfGates;
  int nLdr=0, nLdrFi=0, maxLdrFi=0, maxLdrFi2=0, nPi=0;
  int splitNorm[10] = {0};
  int splitNorm0[10] = {0};
  int foCnt2Max=0, foCnt2Min, foCntMax=0, foCntRed=0;
  float hitRatio = 0.9;
  int hitLow=0, hitHigh=0;
  int nRedTot=0, nNotRedTot=0, potNorm0=0;
  int *auxV, nAux=0, *used[2], nUsed[2]={0,0};

  static int nCalls=0;
  static listWithI_t nullPoint = {-1,-1};

  nCalls++;

  sizeA = Ddi_BddSize(a);
  if (sizeA < 4) {
    return Ddi_BddDup(a);
  }

  /* get array of baig nodes */
  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(a,NULL,NULL,NULL,NULL,1,0);
  n = nnfCoreMgr->aNodes->num; 

  nnfGates = Pdtutil_Alloc(nnfGate_t, n);
  auxV = Pdtutil_Alloc(int, n);
  used[0] = Pdtutil_Alloc(int, n);
  used[1] = Pdtutil_Alloc(int, n);

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].foCnt = nnfGates[i].foAux = 
      nnfGates[i].foAux2 = nnfGates[i].redGate = 0;
    nnfGates[i].fo = NULL;
    nnfGates[i].ldrCut = NULL;
    nnfGates[i].link = NULL;
    nnfGates[i].listFirst[0] = nnfGates[i].listFirst[1] = nullPoint;
    nnfGates[i].ldrFiNum = 0;
    nnfGates[i].clstLdr = i;
    nnfGates[i].clstLdr2 = i;
    nnfGates[i].lastIn = 0;
    nnfGates[i].redJoin = -1;
    nnfGates[i].baig = bAig_NULL;
    nnfGates[i].fi.r = -1;
    nnfGates[i].fi.l = -1;
  }

  bAigArrayAuxIntSetId(bmgr,nnfCoreMgr->aNodes);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      nPi++;
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    nnfGates[ir].foCnt++;
    nnfGates[il].foCnt++;
    nnfGates[i].fi.r = ir;
    nnfGates[i].fi.l = il;
  }
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].fo = Pdtutil_Alloc(int, nnfGates[i].foCnt);
  }

  for (i=n-1; i>=0; i--) {
    int isOr, isOrL, isOrR;
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    isOr = nnfCoreMgr->gateType[i] == 'O';
    isOrR = nnfCoreMgr->gateType[ir] == 'O';
    isOrL = nnfCoreMgr->gateType[il] == 'O';
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[ir]) {
      if (nnfGates[ir].foCnt==1) {
	nnfGates[ir].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[il]) {
      if (nnfGates[il].foCnt==1) {
	nnfGates[il].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfGates[ir].foCnt==1) {
      nnfGates[ir].clstLdr2 = nnfGates[i].clstLdr2;
    }
    if (nnfGates[il].foCnt==1) {
      nnfGates[il].clstLdr2 = nnfGates[i].clstLdr2;
    }

    if (nnfGates[i].clstLdr==i) {
      totRoot++;
    }
    else {
      totIn++;
    }
    if (nnfGates[i].clstLdr2==i) {
      totRoot2++;
    }
    else {
      totIn2++;
    }
  }

  // sort gate indexes by clstLdr2
  for (i=0; i<n; i++) {
    auxV[i] = 0;
  }
  for (i=0; i<n; i++) {
    int ldr2 = nnfGates[i].clstLdr2;
    Pdtutil_Assert(ldr2>=0&&ldr2<n,"wrong ldr2");
    auxV[ldr2]++;
  }
  for (i=1; i<n; i++) {
    auxV[i] += auxV[i-1];
  }
  // foAux2 has the sorted indexes
  for (i=0; i<n; i++) {
    int ldr2 = nnfGates[i].clstLdr2;
    nnfGates[auxV[ldr2]-1].foAux2 = i;
    auxV[ldr2]--;
  }
  // check SORTing
  for (i=1; i<nnfCoreMgr->aNodes->num; i++) {
    int ii0 = nnfGates[i-1].foAux2;
    int ii = nnfGates[i].foAux2;
    Pdtutil_Assert(nnfGates[ii0].clstLdr2<=nnfGates[ii].clstLdr2,
		   "sort problem");
  }

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    int ii = nnfGates[i].foAux2;
    int ir = nnfGates[ii].fi.r;
    int il = nnfGates[ii].fi.l;
    
    if (ir>=0 && il>=0) {
      nnfGates[ir].fo[nnfGates[ir].foAux++] = ii;
      nnfGates[il].fo[nnfGates[il].foAux++] = ii;
    }
    nnfGates[i].foAux2 = 0;
    auxV[i] = 0;
  }

  for (i=0; i<n; i++) {
    int isOr, isOrL, isOrR;
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr == ir) {
	nnfGates[ldr].ldrFiNum++;
      }
      if (nnfGates[il].clstLdr == il) {
	nnfGates[ldr].ldrFiNum++;
      }
    }
  }

  maxLdrFiNum = 0;

  for (i=0; i<n; i++) {
    int t;
    int foCnt2=0;
    nnfGates[i].foAux = 0;
    if (nnfGates[i].ldrFiNum>maxLdrFiNum) {
      maxLdrFiNum = nnfGates[i].ldrFiNum;
    }
    if (nnfGates[i].clstLdr == i && nnfGates[i].ldrFiNum>0) {
      if (nnfGates[i].ldrFiNum>3) {
	nLdr++;
	nLdrFi += nnfGates[i].ldrFiNum;
	if (maxLdrFi < nnfGates[i].ldrFiNum) {
	  maxLdrFi = nnfGates[i].ldrFiNum;
	}
	else if (maxLdrFi2 < nnfGates[i].ldrFiNum) {
	  maxLdrFi2 = nnfGates[i].ldrFiNum;
	}
      }
      nnfGates[i].ldrCut = Pdtutil_Alloc(int, nnfGates[i].ldrFiNum);
      nnfGates[i].link = Pdtutil_Alloc(listWithI_t, nnfGates[i].ldrFiNum);
      for (t=0; t< nnfGates[i].ldrFiNum; t++) {
	nnfGates[i].link[t] = nullPoint;
      }
    }
    for (t=0; t<nnfGates[i].foCnt; t++) {
      int foId_t = nnfGates[i].fo[t];
      int other;
      int rr = nnfGates[foId_t].fi.r;
      int ll = nnfGates[foId_t].fi.l;
      if (rr==i) other = ll;
      else other = rr;
      if (nnfGates[other].foCnt>1000) {
	foCnt2++;
      }
    }
    if (foCnt2>foCnt2Max) {
      foCnt2Max = foCnt2;
    }
    if (nnfGates[i].foCnt > foCntMax){
      foCntMax = nnfGates[i].foCnt;
    }
  }
  //  printf("#macroGates / avg/max/max2 cut size: %d/%f/%d/%d\n", nLdr, 
  //	 ((float) nLdrFi)/nLdr, maxLdrFi, maxLdrFi2);
  //  printf("FOcnt Max: %d/%d\n", foCnt2Max, foCntMax);
  foCnt2Max = 0;
  foCnt2Min = foCntMax;

  for (i=0; i<n; i++) {
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr == ir) {
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = ir;
      }
      if (nnfGates[il].clstLdr == il) {
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = il;
      }
    }
  }

  /* remove duplicates in cuts */
  for (i=0; i<n; i++) {
    int k, k1;
    int cutN = nnfGates[i].ldrFiNum;
    if (cutN<2) continue;
    if (nnfGates[i].clstLdr != i) continue;
    for (k=k1=0; k<cutN; k++) {
      int j = nnfGates[i].ldrCut[k];
      if (nnfGates[j].foAux2 == 0) {
	nnfGates[j].foAux2 = 1;
	nnfGates[i].ldrCut[k1++] = j;
      }
    }
    Pdtutil_Assert(k1<=cutN,"problem with duplicates in cut");
    cutN = nnfGates[i].ldrFiNum = k1;
    for (k=0; k<cutN; k++) {
      int j = nnfGates[i].ldrCut[k];
      nnfGates[j].foAux2 = 0;
    }
  }

  for (i=0; i<n; i++) {
    int t, k, j, other;
    int a;
    if (nnfGates[i].clstLdr != i || nnfGates[i].foCnt<2) continue;
    if (nnfGates[i].redGate) continue;
    for (t=0; t<nnfGates[i].foCnt; t++) {
      int foId_t = nnfGates[i].fo[t];
      int ldr_t = nnfGates[foId_t].clstLdr;
      int cutN = nnfGates[ldr_t].ldrFiNum;
      int isAnd = nnfCoreMgr->gateType[ldr_t] == 'A' ? 1 : 0;
      int k0 = nnfGates[ldr_t].foAux; /* skip already used cut nodes */
      if (nnfGates[ldr_t].redGate) continue;
      if (k0>=cutN) continue;
      nnfGates[ldr_t].redGate = 1;
      auxV[nAux++] = ldr_t;
      Pdtutil_Assert(cutN>0,"no cut");
      Pdtutil_Assert(k0>=0,"no cut");
      //      printf("i: %d (%c), ldr: %d - ", i, isAnd?'A':'O', ldr_t);
      if (k0>0) {
	int skip = 0;
	for (k=0; k<k0; k++) {
	  int j = nnfGates[ldr_t].ldrCut[k];
	  if (i==j) {
	    /* already refactored as j: skip */ 
	    skip = 1;
	  }
	}
	if (skip) continue;
      }
      for (k=k0; k<cutN; k++) {
	int j = nnfGates[ldr_t].ldrCut[k];
	int ldr = -1;
	if (j==i) continue; /* skip ref node */
	// printf("j: %d ", j);

	if (nnfGates[j].listFirst[isAnd].val < 0) {
	  /* new var */
	  used[isAnd][nUsed[isAnd]++] = j;
	}
	nnfGates[ldr_t].link[k] = nnfGates[j].listFirst[isAnd];
	nnfGates[j].listFirst[isAnd].val = ldr_t;
	nnfGates[j].listFirst[isAnd].i = k;
      }
      //      printf("\n");
    }
    for (a=0; a<2; a++) {
      for (k=0; k<nUsed[a]; k++) {
	int ldr, id, cnt=0, nRed=0;
	listWithI_t l;
	j = used[a][k];
	/* scan list of ldrs */
	Pdtutil_Assert(j>=0&&j<n,"invalid j");
	for (l=nnfGates[j].listFirst[a]; 
	     l.val>=0; l=nnfGates[l.val].link[l.i]) {
	  ldr = l.val;
	  Pdtutil_Assert(ldr>=0&&ldr<n,"invalid ldr");
	  if (nnfGates[ldr].foAux2 == 0) {
	    cnt++;
	  }
	}
	for (l=nnfGates[j].listFirst[a]; l.val>=0;) {
	  ldr = l.val;
	  id = l.i;
	  Pdtutil_Assert(ldr>=0&&ldr,"invalid ldr");
	  Pdtutil_Assert(id>=0,"invalid id");
	  if (nnfGates[ldr].foAux2 == 0) {
	    if (cnt>1) {
	      /* refactor (i OP j) */
	      resortCut (nnfGates, ldr, i, j);
	      nRed++;
	      nnfGates[ldr].foAux2 = 1;
	    }
	  }
	  /* cleanup list */
	  l=nnfGates[ldr].link[id];
	  nnfGates[ldr].link[id] = nullPoint;
	}
	nnfGates[j].listFirst[a] = nullPoint;
	if (nRed>1) {
	  nRedTot += nRed-1;
	}
      }
      nUsed[a] = 0;
    }
    for (k=0; k<nAux; k++) {
      int ldr = auxV[k];
      Pdtutil_Assert(ldr>=0&&ldr<n,"invalid ldr");
      nnfGates[ldr].foAux2 = 0;
      nnfGates[ldr].redGate = 0;
    }
    nAux=0;
  }

  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
  
  n = nnfCoreMgr->aNodes->num;
  
  bAigEdge_t *cutBaigs = Pdtutil_Alloc(bAigEdge_t, maxLdrFiNum);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    bAigEdge_t r, l, f = nnfGates[i].baig;
    int ir, il;

    if (f == bAig_NULL) {
      if (bAig_NodeIsConstant(baig)) {
        f = bAig_Zero;
      }
      else if (bAig_isVarNode(bmgr,baig)) {
        f = bAig_NonInvertedEdge(baig);
      }
      else if (nnfGates[i].clstLdr == i && nnfGates[i].ldrFiNum>0) {
	int isAnd = nnfCoreMgr->gateType[i] == 'A';
	int k, t;
	f = isAnd ? bAig_One : bAig_Zero;
	for (k=t=0; k<nnfGates[i].ldrFiNum; k++) {
	  int in = nnfGates[i].ldrCut[k];
	  if (in<0) continue;
	  Pdtutil_Assert(in<=i,"forward merge in nnf normalize");
	  cutBaigs[t++] = nnfGates[in].baig;
	  bAig_Ref(bmgr, nnfGates[in].baig);
	}
	while (t>1) {
	  for (k=0; k<t; k++) {
	    if (k%2==0) {
	      cutBaigs[k/2] = cutBaigs[k];
	    }
	    else {
	      if (isAnd) {
		f = bAig_And(bmgr,cutBaigs[k/2],cutBaigs[k]);
	      }
	      else {
		f = bAig_Or(bmgr,cutBaigs[k/2],cutBaigs[k]);
	      }
	      bAig_Ref(bmgr, f);
	      bAig_RecursiveDeref(bmgr,cutBaigs[k/2]);
	      bAig_RecursiveDeref(bmgr,cutBaigs[k]);
	      cutBaigs[k/2] = f;
	    }
	  }
	  t = (k+1)/2;
	}
	f = cutBaigs[0];
	bAig_Deref(bmgr, f);
      }
      else {
	int isAnd = nnfCoreMgr->gateType[i] == 'A';
        ir = nnfGates[i].fi.r;
        il = nnfGates[i].fi.l;
	if (ir==-1) {
	  if (il==-1) {
	    f = isAnd ? bAig_One : bAig_Zero;
	  }
	  else {
	    f = nnfGates[il].baig;
	  }
	}
	else if (il==-1) {
	  f = nnfGates[ir].baig;
	}
	else {
	  r = nnfGates[ir].baig;
	  l = nnfGates[il].baig;
	  if (isAnd) 
	    f = bAig_And(bmgr,r,l);
	  else 
	    f = bAig_Or(bmgr,r,l);
	}
        if (nnfGates[i].redJoin>=0) {
	  int iJoin = nnfGates[i].redJoin;
	  r = nnfGates[iJoin].baig;
	  if (isAnd) {
	    f = bAig_Or(bmgr,f,r);
	  }
	  else {
	    f = bAig_And(bmgr,f,r);
	  }
	}
      }
      nnfGates[i].baig = f;
      bAig_Ref(bmgr, f);
    }
  }

  Pdtutil_Free(cutBaigs);

  a2 = Ddi_BddMakeFromBaig(ddm,nnfGates[n-1].baig);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfGates[i].baig;
    bAig_RecursiveDeref(bmgr,baig);
    Pdtutil_Free(nnfGates[i].fo);
    Pdtutil_Free(nnfGates[i].ldrCut);
    Pdtutil_Free(nnfGates[i].link);
  }

  Pdtutil_Free(nnfGates);
  Pdtutil_Free(auxV);
  Pdtutil_Free(used[0]);
  Pdtutil_Free(used[1]);

  nnfCoreMgrFree(nnfCoreMgr);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
    fprintf(dMgrO(ddm),
     "AIGNNF REFACTOR2 #red: %d(%d) - s %d->%d\n", 
	    nRedTot, nNotRedTot, sizeA, Ddi_BddSize(a2));
  }

  if (chkRes) {
    Pdtutil_Assert(Ddi_AigEqualSat(a2,a),"error in AIG NNF STRUCT OPT");
  }

  return(a2);
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigNnfClustOdcSat (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *care
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *a2=NULL;
  int sizeA;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, n, maxLdrFiNum;
  int totRoot=0, totIn=0, totRoot2=0, totIn2=0, chkRes=0;
  int clstDup=0, clstDup2=0, clstRed2=0, clstRed3=0, clstRed=0;
  nnfGate_t *nnfGates;
  int nLdr=0, nLdrFi=0, maxLdrFi=0, maxLdrFi2=0, nPi=0;
  int splitNorm[10] = {0};
  int splitNorm0[10] = {0};
  int foCnt2Max=0, foCnt2Min, foCntMax=0, foCntRed=0;
  float hitRatio = 0.9;
  int hitLow=0, hitHigh=0;
  int nRedTot=0, nNotRedTot=0, potNorm0=0;
  int *auxV, nAux=0, *used[2], nUsed[2]={0,0};

  static int nCalls=0;
  static listWithI_t nullPoint = {-1,-1};

  nCalls++;

  sizeA = Ddi_BddSize(a);
  if (sizeA < 4) {
    return Ddi_BddDup(a);
  }

  /* get array of baig nodes */
  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(a,NULL,NULL,NULL,NULL,1,0);
  n = nnfCoreMgr->aNodes->num; 

  nnfGates = Pdtutil_Alloc(nnfGate_t, n);
  auxV = Pdtutil_Alloc(int, n);
  used[0] = Pdtutil_Alloc(int, n);
  used[1] = Pdtutil_Alloc(int, n);

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].foCnt = nnfGates[i].foAux = 
      nnfGates[i].foAux2 = nnfGates[i].redGate = 0;
    nnfGates[i].fo = NULL;
    nnfGates[i].ldrCut = NULL;
    nnfGates[i].link = NULL;
    nnfGates[i].listFirst[0] = nnfGates[i].listFirst[1] = nullPoint;
    nnfGates[i].ldrFiNum = 0;
    nnfGates[i].clstLdr = i;
    nnfGates[i].clstLdr2 = i;
    nnfGates[i].lastIn = 0;
    nnfGates[i].redJoin = -1;
    nnfGates[i].baig = bAig_NULL;
    nnfGates[i].fi.r = -1;
    nnfGates[i].fi.l = -1;
  }

  bAigArrayAuxIntSetId(bmgr,nnfCoreMgr->aNodes);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      nPi++;
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    nnfGates[ir].foCnt++;
    nnfGates[il].foCnt++;
    nnfGates[i].fi.r = ir;
    nnfGates[i].fi.l = il;
  }
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].fo = Pdtutil_Alloc(int, nnfGates[i].foCnt);
  }

  for (i=n-1; i>=0; i--) {
    int isOr, isOrL, isOrR;
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    isOr = nnfCoreMgr->gateType[i] == 'O';
    isOrR = nnfCoreMgr->gateType[ir] == 'O';
    isOrL = nnfCoreMgr->gateType[il] == 'O';
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[ir]) {
      if (nnfGates[ir].foCnt==1) {
	nnfGates[ir].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[il]) {
      if (nnfGates[il].foCnt==1) {
	nnfGates[il].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfGates[ir].foCnt==1) {
      nnfGates[ir].clstLdr2 = nnfGates[i].clstLdr2;
    }
    if (nnfGates[il].foCnt==1) {
      nnfGates[il].clstLdr2 = nnfGates[i].clstLdr2;
    }

    if (nnfGates[i].clstLdr==i) {
      totRoot++;
    }
    else {
      totIn++;
    }
    if (nnfGates[i].clstLdr2==i) {
      totRoot2++;
    }
    else {
      totIn2++;
    }
  }

  // sort gate indexes by clstLdr2
  for (i=0; i<n; i++) {
    auxV[i] = 0;
  }
  for (i=0; i<n; i++) {
    int ldr2 = nnfGates[i].clstLdr2;
    Pdtutil_Assert(ldr2>=0&&ldr2<n,"wrong ldr2");
    auxV[ldr2]++;
  }
  for (i=1; i<n; i++) {
    auxV[i] += auxV[i-1];
  }
  // foAux2 has the sorted indexes
  for (i=0; i<n; i++) {
    int ldr2 = nnfGates[i].clstLdr2;
    nnfGates[auxV[ldr2]-1].foAux2 = i;
    auxV[ldr2]--;
  }
  // check SORTing
  for (i=1; i<nnfCoreMgr->aNodes->num; i++) {
    int ii0 = nnfGates[i-1].foAux2;
    int ii = nnfGates[i].foAux2;
    Pdtutil_Assert(nnfGates[ii0].clstLdr2<=nnfGates[ii].clstLdr2,
		   "sort problem");
  }

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    int ii = nnfGates[i].foAux2;
    int ir = nnfGates[ii].fi.r;
    int il = nnfGates[ii].fi.l;
    
    if (ir>=0 && il>=0) {
      nnfGates[ir].fo[nnfGates[ir].foAux++] = ii;
      nnfGates[il].fo[nnfGates[il].foAux++] = ii;
    }
    nnfGates[i].foAux2 = 0;
    auxV[i] = 0;
  }

  for (i=0; i<n; i++) {
    int isOr, isOrL, isOrR;
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr == ir) {
	nnfGates[ldr].ldrFiNum++;
      }
      if (nnfGates[il].clstLdr == il) {
	nnfGates[ldr].ldrFiNum++;
      }
    }
  }

  maxLdrFiNum = 0;

  for (i=0; i<n; i++) {
    int t;
    int foCnt2=0;
    nnfGates[i].foAux = 0;
    if (nnfGates[i].ldrFiNum>maxLdrFiNum) {
      maxLdrFiNum = nnfGates[i].ldrFiNum;
    }
    if (nnfGates[i].clstLdr == i && nnfGates[i].ldrFiNum>0) {
      if (nnfGates[i].ldrFiNum>3) {
	nLdr++;
	nLdrFi += nnfGates[i].ldrFiNum;
	if (maxLdrFi < nnfGates[i].ldrFiNum) {
	  maxLdrFi = nnfGates[i].ldrFiNum;
	}
	else if (maxLdrFi2 < nnfGates[i].ldrFiNum) {
	  maxLdrFi2 = nnfGates[i].ldrFiNum;
	}
      }
      nnfGates[i].ldrCut = Pdtutil_Alloc(int, nnfGates[i].ldrFiNum);
    }
    for (t=0; t<nnfGates[i].foCnt; t++) {
      int foId_t = nnfGates[i].fo[t];
      int other;
      int rr = nnfGates[foId_t].fi.r;
      int ll = nnfGates[foId_t].fi.l;
      if (rr==i) other = ll;
      else other = rr;
      if (nnfGates[other].foCnt>1000) {
	foCnt2++;
      }
    }
    if (foCnt2>foCnt2Max) {
      foCnt2Max = foCnt2;
    }
    if (nnfGates[i].foCnt > foCntMax){
      foCntMax = nnfGates[i].foCnt;
    }
  }
  //  printf("#macroGates / avg/max/max2 cut size: %d/%f/%d/%d\n", nLdr, 
  //	 ((float) nLdrFi)/nLdr, maxLdrFi, maxLdrFi2);
  //  printf("FOcnt Max: %d/%d\n", foCnt2Max, foCntMax);
  foCnt2Max = 0;
  foCnt2Min = foCntMax;

  for (i=0; i<n; i++) {
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (ir>=0 && il>=0) {
      if (nnfGates[ir].clstLdr == ir) {
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = ir;
      }
      if (nnfGates[il].clstLdr == il) {
	nnfGates[ldr].ldrCut[nnfGates[ldr].lastIn++] = il;
      }
    }
  }

  /* remove duplicates in cuts */
  for (i=0; i<n; i++) {
    int k, k1;
    int cutN = nnfGates[i].ldrFiNum;
    if (cutN<2) continue;
    if (nnfGates[i].clstLdr != i) continue;
    for (k=k1=0; k<cutN; k++) {
      int j = nnfGates[i].ldrCut[k];
      if (nnfGates[j].foAux2 == 0) {
	nnfGates[j].foAux2 = 1;
	nnfGates[i].ldrCut[k1++] = j;
      }
    }
    Pdtutil_Assert(k1<=cutN,"problem with duplicates in cut");
    cutN = nnfGates[i].ldrFiNum = k1;
    for (k=0; k<cutN; k++) {
      int j = nnfGates[i].ldrCut[k];
      nnfGates[j].foAux2 = 0;
    }
  }

  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
  
  n = nnfCoreMgr->aNodes->num;
  
  bAigEdge_t *cutBaigs = Pdtutil_Alloc(bAigEdge_t, maxLdrFiNum);
  bAigEdge_t *evalBaigs = Pdtutil_Alloc(bAigEdge_t, maxLdrFiNum);
  void *S22 = Minisat22NewSolverVoidP();

  long unsatTime=0, startTime = util_cpu_time();

  aig2CnfIdInit(ddm);

  if (care!=NULL) {
    // do it incremental ???
    Minisat22Clauses(S22,care,NULL,NULL,0);
  }

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    bAigEdge_t r, l, f = nnfGates[i].baig;
    int ir, il;

    if (f == bAig_NULL) {
      if (bAig_NodeIsConstant(baig)) {
        f = bAig_Zero;
      }
      else if (bAig_isVarNode(bmgr,baig)) {
        f = bAig_NonInvertedEdge(baig);
      }
      else if (nnfGates[i].clstLdr == i && nnfGates[i].ldrFiNum>0) {
	int isAnd = nnfCoreMgr->gateType[i] == 'A';
	int k, t, tEval;
	f = isAnd ? bAig_One : bAig_Zero;

	if (isAnd && /* i<n/10 && */ nnfGates[i].ldrFiNum>2) {
	  // first loop to find redundancies
	  int red;
	  for (k=t=0; k<nnfGates[i].ldrFiNum; k++) {
	    int in = nnfGates[i].ldrCut[k];
	    int isOr_i = nnfCoreMgr->gateType[in] == 'O';
	    Pdtutil_Assert(in<=i,"forward merge in nnf normalize");
	    cutBaigs[t] = bAig_NonInvertedEdge(nnfCoreMgr->aNodes->nodes[in]);
	    if (isOr_i) cutBaigs[t] = bAig_Not(cutBaigs[t]);
	    t++; 
	  }
	  // find one redundant wire
	  //	  nRedTot += nnfAndFindOdcIncr(S22,ddm,cutBaigs,nnfGates[i].ldrFiNum,&unsatTime);
      	  nRedTot += nnfAndFindOdc(S22,ddm,cutBaigs,nnfGates[i].ldrFiNum,&unsatTime);
	  for (k=0; k<nnfGates[i].ldrFiNum; k++) {
	    if (cutBaigs[k] == bAig_NULL) {
	      nnfGates[i].ldrCut[k] = -1;
	    }
	  }
	}

	// second loop to encode
	for (k=t=0; k<nnfGates[i].ldrFiNum; k++) {
	  int in = nnfGates[i].ldrCut[k];
	  int isOr_i = nnfCoreMgr->gateType[in] == 'O';
	  if (in<0) continue; // skip
	  Pdtutil_Assert(in<=i,"forward merge in nnf normalize");
	  evalBaigs[t] = nnfGates[in].baig;
	  cutBaigs[t] = bAig_NonInvertedEdge(nnfCoreMgr->aNodes->nodes[in]);
	  if (isOr_i) cutBaigs[t] = bAig_Not(cutBaigs[t]);
	  t++; 
	  bAig_Ref(bmgr, nnfGates[in].baig);
	}

	tEval = t;
	while (t>1) {
	  for (k=0; k<t; k++) {
	    if (k%2==0) {
	      evalBaigs[k/2] = evalBaigs[k];
	    }
	    else {
	      if (isAnd) {
		f = bAig_And(bmgr,evalBaigs[k/2],evalBaigs[k]);
	      }
	      else {
		f = bAig_Or(bmgr,evalBaigs[k/2],evalBaigs[k]);
	      }
	      bAig_Ref(bmgr, f);
	      bAig_RecursiveDeref(bmgr,evalBaigs[k/2]);
	      bAig_RecursiveDeref(bmgr,evalBaigs[k]);
	      evalBaigs[k/2] = f;
	    }
	  }
	  t = (k+1)/2;
	}
	f = evalBaigs[0];

	Minisat22AndOrClauses(S22,bmgr,isAnd,baig,cutBaigs,tEval,1);

	bAig_Deref(bmgr, f);
      }
      else {
	int isAnd = nnfCoreMgr->gateType[i] == 'A';
        ir = nnfGates[i].fi.r;
        il = nnfGates[i].fi.l;
	if (ir==-1) {
	  if (il==-1) {
	    f = isAnd ? bAig_One : bAig_Zero;
	  }
	  else {
	    f = nnfGates[il].baig;
	  }
	}
	else if (il==-1) {
	  f = nnfGates[ir].baig;
	}
	else {
	  r = nnfGates[ir].baig;
	  l = nnfGates[il].baig;
	  if (isAnd) {
	    f = bAig_And(bmgr,r,l);
	  }
	  else {
	    f = bAig_Or(bmgr,r,l);
	  }
#if 0
	  cutBaigs[0] = bAig_NonInvertedEdge(nnfCoreMgr->aNodes->nodes[ir]);
	  if (nnfCoreMgr->gateType[ir] == 'O')
	    cutBaigs[0] = bAig_Not(cutBaigs[0]);
	  cutBaigs[1] = bAig_NonInvertedEdge(nnfCoreMgr->aNodes->nodes[il]);
	  if (nnfCoreMgr->gateType[il] == 'O')
	    cutBaigs[1] = bAig_Not(cutBaigs[1]);
	  Minisat22AndOrClauses(S22,bmgr,isAnd,baig,cutBaigs,2,1);
#endif
	}
      }
      nnfGates[i].baig = f;
      bAig_Ref(bmgr, f);
    }
  }

  if (0) {
    bAigEdge_t fbaig = nnfCoreMgr->aNodes->nodes[n-1]; //nnfGates[n-1].baig;
    int fCnf = aig2CnfId(bmgr,fbaig);
    if (Ddi_BddIsComplement(a)) {
      fCnf = -fCnf;
    }
    Minisat22Clause1(S22,fCnf);
    Pdtutil_Assert(!Minisat22Solve(S22),"unsat needed");
  }

  Pdtutil_Free(cutBaigs);
  Pdtutil_Free(evalBaigs);
  Minisat22FreeSolverVoidP(S22);
  aig2CnfIdClose(ddm);

  a2 = Ddi_BddMakeFromBaig(ddm,nnfGates[n-1].baig);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfGates[i].baig;
    bAig_RecursiveDeref(bmgr,baig);
    Pdtutil_Free(nnfGates[i].fo);
    Pdtutil_Free(nnfGates[i].ldrCut);
    Pdtutil_Free(nnfGates[i].link);
  }

  Pdtutil_Free(nnfGates);
  Pdtutil_Free(auxV);
  Pdtutil_Free(used[0]);
  Pdtutil_Free(used[1]);

  nnfCoreMgrFree(nnfCoreMgr);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    long elapsedTime = util_cpu_time() - startTime;

    fprintf(dMgrO(ddm),
     "AIGNNF NNF ODC #red: %d - s %d->%d (unsattime: %s - Time: %s)\n", 
	    nRedTot, sizeA, Ddi_BddSize(a2), 
	    util_print_time(unsatTime), util_print_time(elapsedTime));
  }

  if (chkRes) {
    Pdtutil_Assert(Ddi_AigEqualSat(a2,a),"error in AIG NNF STRUCT OPT");
  }

  return(a2);
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigNnfClustIteDecomp (
  Ddi_Bdd_t *a,
  Ddi_Vararray_t *rV,
  Ddi_Vararray_t *aV
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *a0=NULL, *a1=NULL;
  int sizeA;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, n, maxLdrFiNum;
  int totRoot=0, totIn=0, totRoot2=0, totIn2=0, chkRes=0;
  int clstDup=0, clstDup2=0, clstRed2=0, clstRed3=0, clstRed=0;
  nnfGate_t *nnfGates;
  int nLdr=0, nLdrFi=0, maxLdrFi=0, maxLdrFi2=0, nPi=0;
  int splitNorm[10] = {0};
  int splitNorm0[10] = {0};
  int foCnt2Max=0, foCnt2Min, foCntMax=0, foCntRed=0;
  float hitRatio = 0.9;
  int hitLow=0, hitHigh=0;
  int nRedTot=0, nNotRedTot=0, potNorm0=0;
  int *auxV, nAux=0;
  bAig_array_t *cof1Nodes;
  bAigEdge_t cof1ConstrBaig;
  Ddi_Bdd_t *cof1Constr;
  int level=-1;

  static int nCalls=0;

  nCalls++;

  sizeA = Ddi_BddSize(a);
  if (sizeA < 4) {
    return Ddi_BddDup(a);
  }

  /* get array of baig nodes */
  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(a,NULL,NULL,NULL,NULL,1,0);
  n = nnfCoreMgr->aNodes->num; 

  nnfGates = Pdtutil_Alloc(nnfGate_t, n);
  auxV = Pdtutil_Alloc(int, n);

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].foCnt = nnfGates[i].foAux = 
      nnfGates[i].foAux2 = nnfGates[i].redGate = 0;
    nnfGates[i].fo = NULL;
    nnfGates[i].ldrFiNum = 0;
    nnfGates[i].clstLdr = i;
    nnfGates[i].clstLdr2 = i;
    nnfGates[i].lastIn = 0;
    nnfGates[i].redJoin = 0;
    nnfGates[i].baig = bAig_NULL;
    nnfGates[i].fi.r = -1;
    nnfGates[i].fi.l = -1;
  }

  bAigArrayAuxIntSetId(bmgr,nnfCoreMgr->aNodes);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      nPi++;
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    nnfGates[ir].foCnt++;
    nnfGates[il].foCnt++;
    nnfGates[i].fi.r = ir;
    nnfGates[i].fi.l = il;
  }

  for (i=n-1; i>=0; i--) {
    int isOr, isOrL, isOrR;
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    isOr = nnfCoreMgr->gateType[i] == 'O';
    isOrR = nnfCoreMgr->gateType[ir] == 'O';
    isOrL = nnfCoreMgr->gateType[il] == 'O';
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[ir]) {
      nnfGates[ir].foAux++;
      if (nnfGates[ir].foCnt==1) {
	nnfGates[ir].clstLdr = nnfGates[i].clstLdr;
      }
    }
    else if (nnfCoreMgr->gateType[i] == 'O' && 
	     nnfCoreMgr->gateType[ir] == 'I') {
      nnfGates[ir].foAux++;
    }
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[il]) {
      nnfGates[il].foAux++;
      if (nnfGates[il].foCnt==1) {
	nnfGates[il].clstLdr = nnfGates[i].clstLdr;
      }
    }
    else if (nnfCoreMgr->gateType[i] == 'O' && 
	     nnfCoreMgr->gateType[il] == 'I') {
      nnfGates[il].foAux++;
    }
    if (nnfGates[ir].foCnt==1) {
      nnfGates[ir].clstLdr2 = nnfGates[i].clstLdr2;
    }
    if (nnfGates[il].foCnt==1) {
      nnfGates[il].clstLdr2 = nnfGates[i].clstLdr2;
    }

    if (nnfGates[i].clstLdr==i) {
      totRoot++;
    }
    else {
      totIn++;
    }
    if (nnfGates[i].clstLdr2==i) {
      totRoot2++;
    }
    else {
      totIn2++;
    }
    if (1) {
      nnfGates[i].foAux2 = nnfGates[i].foCnt - nnfGates[i].foAux;
      Pdtutil_Assert(nnfGates[i].foAux2>=0,"negative fanout");
    }
  }


  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].fo = Pdtutil_Alloc(int, nnfGates[i].foCnt);
    nnfGates[i].foCnt = 0;
  }

  // sort fanout lists by cluster
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    
    int ldr2 = nnfGates[i].clstLdr2;
    nnfGates[ldr2].foAux2++; // count cluster size

    if (ir>=0 && il>=0) {
      nnfGates[ir].fo[nnfGates[ir].foCnt++] = i;
      nnfGates[il].fo[nnfGates[il].foCnt++] = i;
    }
  }

  int maxCl = 0, imaxCl=-1;
  int frontierMax = 0;
  for (i=0; i<n; i++) {
    if (nnfGates[i].foAux2 > maxCl) {
      maxCl = nnfGates[i].foAux2;
      imaxCl = i;
    }
  }
  for (i=0; i<n; i++) {
    int j, foToMaxCl=0;
    for (j=0; j<nnfGates[i].foCnt; j++) {
      int jj = nnfGates[i].fo[j];
      int ldr2 = nnfGates[jj].clstLdr2;
      if (ldr2 == imaxCl) {
	foToMaxCl=1;
      }
      nnfGates[ldr2].lastIn++;
      if (0 && nnfGates[ldr2].lastIn>1 && 
	  nnfGates[ldr2].foAux2>6 && nnfGates[ldr2].foAux2<12) {
	printf("found\n");
      }
    }
    if (foToMaxCl) {
      frontierMax++;
    }
    for (j=0; j<nnfGates[i].foCnt; j++) {
      int jj = nnfGates[i].fo[j];
      int ldr2 = nnfGates[jj].clstLdr2;
      nnfGates[ldr2].lastIn=0; // reset counter
    }    
    nnfGates[i].foAux2 = 0; // reset clust size
  }


  printf("maxCluster size: %d - frontier: %d\n", maxCl, frontierMax); 

  for (i=n-1; i>=0; i--) {
    int isOr, isOrL, isOrR;
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (0 && (ldr==25847)) {
      printf("OK\n");
    }  
    if (nnfGates[i].clstLdr == i) {
      nnfGates[ldr].lastIn = 1;
    }

    if (ir>=0 && il>=0) {

      if (nnfGates[ir].clstLdr == ir) {
	/* ir is cluster leader */
	if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[ir]) {
	  /* same gate but fo > 1 */
	  nnfGates[ir].foAux += nnfGates[ldr].foAux;
	}
#if 1
	else {
	  nnfGates[ir].foAux2 += nnfGates[ldr].foAux-1;
	}
#else
	nnfGates[ldr].foAux2 += nnfGates[ir].foAux;
#endif
      }
      if (nnfGates[il].clstLdr == il) {
	/* il is cluster leader */
	if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[il]) {
	  /* same gate but fo > 1 */
	  nnfGates[il].foAux += nnfGates[ldr].foAux;
	}
#if 1
	else {
	  nnfGates[il].foAux2 += nnfGates[ldr].foAux-1;
	}
#else
	nnfGates[ldr].foAux2 += nnfGates[il].foAux;
#endif
      }
      int ldr2 = nnfGates[i].clstLdr2;
      if (nnfGates[ir].clstLdr2 != ldr2 || nnfGates[il].clstLdr2 != ldr2) {
	nnfGates[ldr2].ldrFiNum++;
      }
      nnfGates[ldr2].redJoin++;

      int ldr = nnfGates[i].clstLdr;
      if (nnfGates[ir].clstLdr != ldr) {
	if (nnfGates[ir].foCnt==1) {
	  nnfGates[ldr].lastIn = 0;
	}
	nnfGates[ldr].ldrFiNum++;
      }
      if (nnfGates[il].clstLdr != ldr) {
	if (nnfGates[il].foCnt==1) {
	  nnfGates[ldr].lastIn = 0;
	}
	nnfGates[ldr].ldrFiNum++;
      }

    }
 
  }

  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
  //  aigArrayLevelizeMaxFromOutIntern(bmgr,nnfCoreMgr->aNodes);
  aigArrayLevelizeIntern(bmgr,nnfCoreMgr->aNodes);

  int imaxFoAux = -1;
  int imaxFoAux2 = -1;
  int nMgP[4] = {0};

  int best, maxl=0, iLev=-1, iClst2, maxClst2=0, nMgForRefact=0, nMgPin=0;

  struct {
    int n;
    int bestId[10];
    int bestVal[10];
  } bestArray = {0,{0}};

  for (i=n-1; i>=0; i--) {
    int isOr, isOrL, isOrR;
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    int level = bAig_AuxInt(bmgr,baig);

    int sum = nnfGates[i].foAux + nnfGates[i].foAux2;
    int dif = abs(nnfGates[i].foAux - nnfGates[i].foAux2);
    int myFo = (/*level+*/1) * (nnfGates[i].foCnt + (sum + dif));// / (level + 4);

    int min = 10;
    int en = nnfGates[i].foAux>min && nnfGates[i].foAux2>min;
    if (dif > sum/2 && dif < 6*sum/7) myFo += dif; 
    if (level>maxl) {
      iLev = i;
      maxl = level;
    }
    if (nnfGates[i].lastIn) {
      int np = nnfGates[i].ldrFiNum;
      if (np>5) np=5;
      nMgP[np-2]++;
      nMgForRefact++;
      nMgPin += nnfGates[i].ldrFiNum;
      if (np==2) {
      }
    }
    if (nnfGates[i].clstLdr2 == i) {
      if (nnfGates[i].redJoin > maxClst2) {
	maxClst2 = nnfGates[i].redJoin;
	iClst2 = i;
      } 
    }

    if (en && (imaxFoAux<0 || myFo>best)) {
      int j;
      imaxFoAux = i;
      nRedTot = nnfGates[i].foAux;
      nNotRedTot = nnfGates[i].foAux2;
      best = myFo;
      printf("new best: %d - lev: %d, fo (%d=: %d - %d\n", i, level,
	     nnfGates[i].foCnt, nnfGates[i].foAux, nnfGates[i].foAux2);
      for (j=bestArray.n; j>0; j--) {
	if (j<10) {
	  bestArray.bestId[j] = bestArray.bestId[j-1];
	  bestArray.bestVal[j] = bestArray.bestVal[j-1];
	}
      }
      bestArray.bestId[0] = i;
      bestArray.bestVal[0] = myFo;
      if (bestArray.n<10)
	bestArray.n++;
    }
  }


#if 0

  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];

    int level = bAig_AuxInt(bmgr,baig);

    if (nnfGates[i].lastIn) {
      int np = nnfGates[i].ldrFiNum;
      if (np>5) np=5;
      if (np==2) {
    	int ir = nnfGates[i].fi.r;
	int il = nnfGates[i].fi.l;
	bAigEdge_t i10 = nnfCoreMgr->aNodes->nodes[ir];
	bAigEdge_t i11 = nnfCoreMgr->aNodes->nodes[il];
	bAigEdge_t look = bAig_hashLookup(bmgr, i10, i11);
	if (look == bAig_NULL) {
	  bAig_hashInsert(bmgr, baig, i10, i11);
	}
	bAig_AuxInt(bmgr,baig) = i;
      }
      else if (1 && (np==3)) {
	bAigEdge_t look;
    	int ir = nnfGates[i].fi.r;
	int il = nnfGates[i].fi.l;
	if (nnfGates[ir].clstLdr == i) {
	  Pdtutil_Assert(nnfGates[il].clstLdr == il,"macrogate problem");
	  bAig_AuxInt(bmgr,nnfCoreMgr->aNodes->nodes[ir]) = ir;
	}
	else if (nnfGates[il].clstLdr == i) {
	  Pdtutil_Assert(nnfGates[ir].clstLdr == ir,"macrogate problem");
	  bAig_AuxInt(bmgr,nnfCoreMgr->aNodes->nodes[il]) = il;
	}
      }
    }
  }

  int nShareable = 0;

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];

    int level = bAig_AuxInt(bmgr,baig);

    if (nnfGates[i].lastIn) {
      int np = nnfGates[i].ldrFiNum;
      if (np>5) np=5;
      if (np==3) {
	bAigEdge_t i0, i10, i11;
	bAigEdge_t look;
    
	int ir = nnfGates[i].fi.r;
	int il = nnfGates[i].fi.l;
	if (nnfGates[ir].clstLdr == i) {
	  Pdtutil_Assert(nnfGates[il].clstLdr == il,"macrogate problem");
	  i0 = nnfGates[il].baig;
	  i10 = nnfCoreMgr->aNodes->nodes[nnfGates[ir].fi.r];
	  i11 = nnfCoreMgr->aNodes->nodes[nnfGates[ir].fi.l];
	}
	else if (nnfGates[il].clstLdr == i) {
	  Pdtutil_Assert(nnfGates[ir].clstLdr == ir,"macrogate problem");
	  i0 = nnfGates[ir].baig;
	  i10 = nnfCoreMgr->aNodes->nodes[nnfGates[il].fi.r];
	  i11 = nnfCoreMgr->aNodes->nodes[nnfGates[il].fi.l];
	}
	look = bAig_hashLookup(bmgr, i10, i11);
	if (look == bAig_NULL) {
	  look = bAig_hashLookup(bmgr, i11, i0);
	}
	if (look != bAig_NULL) {
	  int id = bAig_AuxInt(bmgr,look);
	  if ((id>=0) && 
	    (nnfCoreMgr->gateType[id] == nnfCoreMgr->gateType[i])) {
	    // can be shared 
	    nShareable++;
	  } 
	}
      }
    }
  }

#endif

  printf("n macrogate for refactor: %d - avg cut: %f (%d/%d/%d/%d)\n", 
	 nMgForRefact, nMgPin / (float)nMgForRefact,
	 nMgP[0],nMgP[1],nMgP[2],nMgP[3]);
  printf("max out level: %d - i: %d\n", maxl, iLev);
  int clstCut = nnfGates[iClst2].ldrFiNum;
  printf("max clst2 size: %d / cut: %d - i: %d\n", maxClst2, clstCut, iClst2);
  
  bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[imaxFoAux];
  level = bAig_AuxInt(bmgr,baig);

  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);

  int j, jMax=-1;
  int nRedGate = 0, nRedLdr = 0, nRedLdr2 = 0, nRedGateFo1 = 0, nFrontier = 0;
  int cntOr=0, cntAnd=0;
  float bestf;

  if (rV == NULL) {

  for (j=0; j<=bestArray.n; j++) {
    int foCnt;
    nRedGate = nRedGateFo1 = nRedLdr = nRedLdr2 = nFrontier = cntOr = cntAnd=0;
    if (j==bestArray.n) 
      imaxFoAux = jMax;
    else
      imaxFoAux = bestArray.bestId[j];
    foCnt = nnfGates[imaxFoAux].foCnt;

    for (i=0; i<n; i++) {
      nnfGates[i].lastIn = 0; // used just as flag, not for its orig purpose
    }

    for (i=0; i<n; i++) {
      int isOr;
      bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
      int ldr = nnfGates[i].clstLdr2;
      nnfGates[i].redGate = i==imaxFoAux ? 1 : 0;
      nnfGates[i].redJoin = 0;
      if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
	nPi++;
	continue;
      }
      isOr = nnfCoreMgr->gateType[i] == 'O';
      int ir = nnfGates[i].fi.r;
      int il = nnfGates[i].fi.l;
      if (i!=imaxFoAux) {
	if (nnfGates[ir].redGate &&
	    nnfGates[il].redGate) {
	  nnfGates[i].redGate = 1;
	  nnfGates[i].redJoin = 1;
	  if (nnfCoreMgr->gateType[ir] == nnfCoreMgr->gateType[i]) {
	    nnfGates[i].redJoin &= nnfGates[ir].redJoin;
	  }
	  if (nnfCoreMgr->gateType[il] == nnfCoreMgr->gateType[i]) {
	    nnfGates[i].redJoin &= nnfGates[il].redJoin;
	  }
	}
	else if (nnfGates[ir].redGate) {
	  int isOrR = nnfCoreMgr->gateType[ir] == 'O';
	  if (nnfGates[ir].redJoin) {
	    isOrR = !isOrR; // flip redundancy
	  }
	  if (isOr == isOrR || ir==imaxFoAux)
	    nnfGates[i].redGate = 1;
	  else {
	    /* frontier */
	    if (nnfGates[ir].redGate==1) {
	      nnfGates[ir].redGate = 2;
	      nFrontier++;
	      if (nnfGates[ir].foCnt==1) {
		nRedGateFo1++;
		if (nnfGates[ldr].lastIn==0) {
		  nnfGates[ldr].lastIn=1;
		  nRedLdr++;
		}
	      }
	    }
	  }
	}
	else if (nnfGates[il].redGate) {
	  int isOrL = nnfCoreMgr->gateType[il] == 'O';
	  if (nnfGates[il].redJoin) {
	    isOrL = !isOrL; // flip redundancy
	  }
	  if (isOr == isOrL || il==imaxFoAux)
	    nnfGates[i].redGate = 1;
	  else {
	    /* frontier */
	    if (nnfGates[il].redGate==1) {
	      nnfGates[il].redGate = 2;
	      nFrontier++;
	      if (nnfGates[il].foCnt==1) {
		nRedGateFo1++;
		if (nnfGates[ldr].lastIn==0) {
		  nnfGates[ldr].lastIn=1;
		  nRedLdr++;
		}
	      }
	    }
	  }
	}
      }
      if (nnfGates[i].redGate) {
	nRedGate++;
      }
      if (ir==imaxFoAux || il==imaxFoAux) {
	if (isOr) cntOr++;
	else cntAnd++;
      }
    }

    if (1) // disabled as ITE needed later to join cofactors.
    for (i=n-1; i>=0; i--) {
      int isOr;
      bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
      int ldr = nnfGates[i].clstLdr2;
      if (i==imaxFoAux) continue;
      if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
	continue;
      }
      isOr = nnfCoreMgr->gateType[i] == 'O';
      int ir = nnfGates[i].fi.r;
      int il = nnfGates[i].fi.l;
      if (nnfGates[i].redGate>=1) {
	if (nnfGates[ir].redGate!=1 && nnfGates[ir].foCnt==1) {
	  if (nnfGates[ir].redGate==2) nFrontier--;
	  nnfGates[ir].redGate = 1;
	}
	if (nnfGates[il].redGate!=1 && nnfGates[il].foCnt==1) {
	  if (nnfGates[ir].redGate==2) nFrontier--;
	  nnfGates[il].redGate = 1;
	}
      }
    }

    printf("nRedGates(fo1): %d(%d)- redLdr: %d - frontier: %d fanout: %d- f-f: %d\n", 
	   nRedGate, nRedGateFo1, nRedLdr, 
	   nFrontier, foCnt, nFrontier-foCnt); 
    int sum = nnfGates[imaxFoAux].foAux + nnfGates[imaxFoAux].foAux2;
    int dif = abs(nnfGates[imaxFoAux].foAux - nnfGates[imaxFoAux].foAux2);
    int myFo = foCnt + (sum + dif);
    if (dif > sum/2 && dif < 6*sum/7) myFo += dif; 
#if 0
    if (j==0 || (myFo-nFrontier>best)) {
      bestf = myFo-nFrontier;
      jMax = imaxFoAux;
    }
#else
    if (j==0 || (foCnt-nFrontier-nRedLdr-dif)/(float)sum>bestf) {
      bestf = (foCnt-nFrontier-nRedLdr-dif)/(float)sum;
      jMax = imaxFoAux;
    }
#endif
  }
  imaxFoAux = jMax;
  }

  n = nnfCoreMgr->aNodes->num;
  cof1Nodes = bAigArrayAlloc();
  cof1ConstrBaig = bAig_NULL;

#define isCofNode(i) (((i)==imaxFoAux) || ((i)==imaxFoAux))

  //  imaxFoAux = -1;
  int nAdded=0; int maxEn=113;
  int enMerge = 1, enMergeTot = 0;

  if (rV!=NULL) {
    int nv = Ddi_VararrayNum(rV);
    int *varIdsR = Pdtutil_Alloc(int, nv);
    int *varIdsA = Pdtutil_Alloc(int, nv);
    enMergeTot = 0; // disable

    for (i=0; i<nv; i++) {
      varIdsR[i] = -1;
      varIdsA[i] = -1;
    }

    Ddi_VararrayWriteMarkWithIndex (rV,1);
    Ddi_VararrayWriteMarkWithIndex (aV,1);

    for (i=0; i<n; i++) {
      bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
      if (bAig_isVarNode(bmgr,baig)) {
	Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	int ii = Ddi_VarReadMark (v) - 1;
	if (ii>=0 && ii<nv) {
	  if (v == Ddi_VararrayRead(rV,ii)) {
	    varIdsR[ii] = i;
	  }
	  else if (v == Ddi_VararrayRead(aV,ii)) {
	    varIdsA[ii] = i;
	  }
	}
      }
    }

    int iMax=-1, foMax;
    for (i=0; i<nv; i++) {
      int iR = varIdsR[i];
      int iA = varIdsA[i];
      if (iA>=0 && iR>=0) {
	//	int foR = nnfGates[iR].foCnt;
	//	int foA = nnfGates[iA].foCnt;
	int foR = nnfGates[iR].foAux;
	int foA = nnfGates[iA].foAux;
	//	foR += nnfGates[iR].foAux + nnfGates[iR].foAux2;
	//	foA += nnfGates[iA].foAux + nnfGates[iA].foAux2;
	if (foR<foA) {
	  foR = nnfGates[iA].foCnt;
	  foA = nnfGates[iR].foCnt;
	}
	int foAvg = (foR+foA)/2;
	int foNew = foAvg - abs(2*foA-foR);
	if (iMax<0 || (foNew>foMax)) {
	  iMax = i;
	  foMax = foNew;
	}
      }
    }

    if (iMax>=0) {
      int iR = varIdsR[iMax];
      int iA = varIdsA[iMax];
      int foR = nnfGates[iR].foCnt;
      int foA = nnfGates[iA].foCnt;
      int foRaux = nnfGates[iR].foAux;
      int foAaux = nnfGates[iA].foAux;
      int foRaux2 = nnfGates[iR].foAux2;
      int foAaux2 = nnfGates[iA].foAux2;
      bAigEdge_t baigR = nnfCoreMgr->aNodes->nodes[iR];
      bAigEdge_t baigA = nnfCoreMgr->aNodes->nodes[iA];

      imaxFoAux = iR;
      imaxFoAux2 = iA;

      char *nameR = bAig_NodeReadName(bmgr,baigR);
      char *nameA = bAig_NodeReadName(bmgr,baigA);
      printf("Split on PI: %30s/%3s - fo: %d-%d - aux: %d-%d (%d-%d)\n", 
	     nameA, nameR, foR, foA, foRaux, foAaux, foRaux2, foAaux2);

    }

    Pdtutil_Free(varIdsR);
    Pdtutil_Free(varIdsA);

    Ddi_VararrayWriteMark (rV,0);
    Ddi_VararrayWriteMark (aV,0);    
  }

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    bAigEdge_t r, l, f1, f0;
    int ir, il;

    enMerge = enMergeTot && (1 || maxEn>0); // enable

    f0 = f1 = nnfGates[i].baig;
    bAigArrayPush(cof1Nodes,baig);

    if (bAig_NodeIsConstant(baig)) {
      f0 = f1 = bAig_Zero;
    }
    else if (bAig_isVarNode(bmgr,baig)) {
      f0 = f1 = bAig_NonInvertedEdge(baig);
    }
    else {
      int isAnd = nnfCoreMgr->gateType[i] == 'A';
      int merge = 0;
      ir = nnfGates[i].fi.r;
      il = nnfGates[i].fi.l;
      /* f0 */
      r = nnfGates[ir].baig;
      l = nnfGates[il].baig;
      if (isAnd) {
	f0 = bAig_And(bmgr,r,l);
	bAig_Ref(bmgr, f0);
      }
      else {
	if (enMerge && (!nnfGates[i].redGate) && 
	    (!nnfGates[i].redJoin) && (r==bAig_Zero && !isCofNode(ir))) {
	  //if (r==bAig_Zero) {
	  // Pdtutil_Assert(nnfCoreMgr->gateType[ir] == 'A',"missing and");
	  Pdtutil_Assert(cof1ConstrBaig!=bAig_NULL,
			 "problem with cofactor merge");
	  Pdtutil_Assert(!enMerge || l==cof1Nodes->nodes[il],"problem");
	  r = bAig_And(bmgr,cof1Nodes->nodes[ir],cof1ConstrBaig);
	  bAig_Ref(bmgr, r);
	  f0 = bAig_Or(bmgr,r,l);
	  bAig_Ref(bmgr, f0);
          bAig_RecursiveDeref(bmgr,r);
     	  merge = 1;
	  //	  Pdtutil_Assert(nnfGates[ir].redGate>1,"frontier gate problem");
	  if (nnfGates[ir].redGate==2) {
	    nAdded++; nnfGates[ir].redGate=3; 
	  }
	}
	else if (enMerge && (!nnfGates[i].redGate) && 
	  (!nnfGates[i].redJoin) && (l==bAig_Zero && !isCofNode(il))) {
	  //else if (l==bAig_Zero) {
	  Pdtutil_Assert(cof1ConstrBaig!=bAig_NULL,
			 "problem with cofactor merge");
	  Pdtutil_Assert(!enMerge || cof1Nodes->nodes[ir]==r,"problem");
	  l = bAig_And(bmgr,cof1Nodes->nodes[il],cof1ConstrBaig);
	  bAig_Ref(bmgr, l);
	  f0 = bAig_Or(bmgr,r,l);
	  bAig_Ref(bmgr, f0);
	  bAig_RecursiveDeref(bmgr,l);
	  merge = 1;
	  //	  Pdtutil_Assert(nnfGates[il].redGate>1,"frontier gate problem");
	  if (nnfGates[il].redGate==2) {
	    nAdded++; nnfGates[il].redGate=3; 
	  }
	}
	else {
	  f0 = bAig_Or(bmgr,r,l);
	  bAig_Ref(bmgr, f0);
	}
      }
      /* f1 */
      if (merge) maxEn--;
      if (merge && enMerge) {
	f1 = f0;
	bAig_Ref(bmgr, f1);
      }
      else {
	r = cof1Nodes->nodes[ir];
	l = cof1Nodes->nodes[il];
	if (isAnd) {
	  if (enMerge && (!nnfGates[i].redGate) && 
	      (!nnfGates[i].redJoin) && (r==bAig_One && !isCofNode(ir))) {
	    //if (r==bAig_One) {
	    Pdtutil_Assert(cof1ConstrBaig!=bAig_NULL,
			   "problem with cofactor merge");
	    Pdtutil_Assert(!enMerge || l==nnfGates[il].baig,"problem");
	    r = bAig_Or(bmgr,nnfGates[ir].baig,cof1ConstrBaig);
	    bAig_Ref(bmgr, r);
	    f1 = bAig_And(bmgr,r,l);
	    bAig_Ref(bmgr, f1);
	    bAig_RecursiveDeref(bmgr,r);
	    maxEn--;
	    if (enMerge) {
	      bAig_RecursiveDeref(bmgr,f0);
	      f0 = f1;
	      bAig_Ref(bmgr, f0);
	    }
	    //	    Pdtutil_Assert(nnfGates[ir].redGate>1,"frontier gate problem");
	    if (nnfGates[ir].redGate==2) {
	      nAdded++; nnfGates[ir].redGate=3; 
	    }
	  }
	  else if (enMerge && (!nnfGates[i].redGate) &&
	    (!nnfGates[i].redJoin) && (l==bAig_One && !isCofNode(il))) {
	    //else if (l==bAig_One) {
	    Pdtutil_Assert(cof1ConstrBaig!=bAig_NULL,
			   "problem with cofactor merge");
	    Pdtutil_Assert(!enMerge || nnfGates[ir].baig==r,"problem");
	    l = bAig_Or(bmgr,nnfGates[il].baig,cof1ConstrBaig);
	    bAig_Ref(bmgr, l);
	    f1 = bAig_And(bmgr,r,l);
	    bAig_Ref(bmgr, f1);
	    bAig_RecursiveDeref(bmgr,1);
	    maxEn--;
	    if (enMerge) {
	      bAig_RecursiveDeref(bmgr,f0);
	      f0 = f1;
	      bAig_Ref(bmgr, f0);
	    }
	    //	    Pdtutil_Assert(nnfGates[il].redGate>1,"frontier gate problem");
	    if (nnfGates[il].redGate==2) {
	      nAdded++; nnfGates[il].redGate=3; 
	    }
	  }
	  else {
	    f1 = bAig_And(bmgr,r,l);
	    bAig_Ref(bmgr, f1);
	  }
	}
	else {
	  f1 = bAig_Or(bmgr,r,l);
	  bAig_Ref(bmgr, f1);
	}
      }
      //      bAig_Ref(bmgr, f1);

      nnfGates[i].baig = f0;
      cof1Nodes->nodes[i] = f1;
      if (0 && nnfGates[i].redGate==1 && 
	  !bAig_NodeIsConstant(f0)&&!bAig_NodeIsConstant(f1)) {
	printf("Why ???\n");
      }
      if (enMerge && f0!=f1 && 
	  !bAig_NodeIsConstant(f0)&&!bAig_NodeIsConstant(f1)) {
	//	printf("Catched\n");
	Pdtutil_Assert(cof1ConstrBaig!=bAig_NULL,
		       "problem with cofactor merge");
	f0 = bAig_And(bmgr,f0,bAig_Not(cof1ConstrBaig));
	bAig_Ref(bmgr, f0);
	f1 = bAig_And(bmgr,f1,cof1ConstrBaig);
	bAig_Ref(bmgr, f1);
	bAig_RecursiveDeref(bmgr,nnfGates[i].baig);
	bAig_RecursiveDeref(bmgr,cof1Nodes->nodes[i]);
	r = f0;
	f0 = bAig_Or(bmgr,f0,f1);
	bAig_Ref(bmgr, f0);
	bAig_RecursiveDeref(bmgr,r);
	bAig_RecursiveDeref(bmgr,f1);
	f1 = f0;
	bAig_Ref(bmgr, f1);
	nnfGates[i].baig = f0;
	cof1Nodes->nodes[i] = f1;
      }

    }

    if (i==imaxFoAux) {
      bAig_RecursiveDeref(bmgr,f0);
      //      cof1ConstrBaig = bAig_NonInvertedEdge(f1);
      cof1ConstrBaig = f1;
      f0 = bAig_Zero;
      f1 = bAig_One;
    }
    else if (i==imaxFoAux2) {
      bAig_RecursiveDeref(bmgr,f0);
      bAig_RecursiveDeref(bmgr,f1);
      f1 = bAig_Zero;
      f0 = bAig_One;
    }
    nnfGates[i].baig = f0;
    cof1Nodes->nodes[i] = f1;

  }
  printf("added gates: %d - fanout: %d\n", nAdded, nnfGates[imaxFoAux].foCnt); 

  a0 = Ddi_BddMakeFromBaig(ddm,nnfGates[n-1].baig);
  a1 = Ddi_BddMakeFromBaig(ddm,cof1Nodes->nodes[n-1]);
  if (0 && Ddi_BddIsComplement(a)) {
    Ddi_BddNotAcc(a0);
    Ddi_BddNotAcc(a1);
  }
  if (imaxFoAux>=0) {
    cof1Constr = Ddi_BddMakeFromBaig(ddm,cof1ConstrBaig);
    if (!Ddi_BddEqual(a0,a1)) {
      Ddi_BddAndAcc(a1,cof1Constr);
      Ddi_BddDiffAcc(a0,cof1Constr);
    }
    Ddi_Free(cof1Constr);
  }

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfGates[i].baig;
    bAig_RecursiveDeref(bmgr,baig);
    baig = cof1Nodes->nodes[i];
    bAig_RecursiveDeref(bmgr,baig);
  }
  bAig_RecursiveDeref(bmgr,cof1ConstrBaig);

  bAigArrayFree(cof1Nodes);

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    Pdtutil_Free(nnfGates[i].fo);
  }

  Pdtutil_Free(nnfGates);
  Pdtutil_Free(auxV);

  nnfCoreMgrFree(nnfCoreMgr);

  if (Ddi_BddEqual(a0,a1)) {
    Ddi_AigStructRedRemAcc (a0,NULL);
  }
  else {
    Ddi_AigStructRedRemAcc (a0,NULL);
    Ddi_AigStructRedRemAcc (a1,NULL);
    
    Ddi_BddSetPartDisj(a0);
    Ddi_BddPartInsertLast(a0,a1);
  }
  Ddi_Free(a1);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),
     "AIGNNF ITE PART #fo max: %d+%d - s: %d->%d (level: %d) - FO or: %d, and: %d\n", 
	    nRedTot, nNotRedTot, sizeA, Ddi_BddSize(a0), level, cntOr, cntAnd);
  }

  if (chkRes) {
    Ddi_Bdd_t *aNew = Ddi_BddMakeAig(a0);
    Pdtutil_Assert(Ddi_AigEqualSat(aNew,a),"error in AIG NNF STRUCT OPT");
    Ddi_Free(aNew);
  }

  return(a0);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigNnfClustRefactor (
  Ddi_Bdd_t *a
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *a0=NULL, *a1=NULL;
  int sizeA;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, n, maxLdrFiNum;
  int totRoot=0, totIn=0, totRoot2=0, totIn2=0, chkRes=0;
  int clstDup=0, clstDup2=0, clstRed2=0, clstRed3=0, clstRed=0;
  nnfGate_t *nnfGates;
  int nLdr=0, nLdrFi=0, maxLdrFi=0, maxLdrFi2=0, nPi=0;
  int splitNorm[10] = {0};
  int splitNorm0[10] = {0};
  int foCnt2Max=0, foCnt2Min, foCntMax=0, foCntRed=0;
  float hitRatio = 0.9;
  int hitLow=0, hitHigh=0;
  int nRedTot=0, nNotRedTot=0, potNorm0=0;
  int *auxV, nAux=0;
  bAigEdge_t cof1ConstrBaig;
  bAig_array_t *dummyNodes;
  Ddi_Bdd_t *cof1Constr;
  int level=-1;
  int nHashed=0;

  static int nCalls=0;

  nCalls++;

  sizeA = Ddi_BddSize(a);
  if (sizeA < 4) {
    return Ddi_BddDup(a);
  }

  /* get array of baig nodes */
  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(a,NULL,NULL,NULL,NULL,1,0);
  n = nnfCoreMgr->aNodes->num; 

  nnfGates = Pdtutil_Alloc(nnfGate_t, n);
  auxV = Pdtutil_Alloc(int, n);

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    nnfGates[i].foCnt = nnfGates[i].foAux = 
      nnfGates[i].foAux2 = nnfGates[i].redGate = 0;
    nnfGates[i].fo = NULL;
    nnfGates[i].ldrFiNum = 0;
    nnfGates[i].clstLdr = i;
    nnfGates[i].clstLdr2 = i;
    nnfGates[i].lastIn = 0;
    nnfGates[i].redJoin = 0;
    nnfGates[i].baig = bAig_NULL;
    nnfGates[i].fi.r = -1;
    nnfGates[i].fi.l = -1;
  }

  bAigArrayAuxIntSetId(bmgr,nnfCoreMgr->aNodes);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      nPi++;
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    nnfGates[ir].foCnt++;
    nnfGates[il].foCnt++;
    nnfGates[i].fi.r = ir;
    nnfGates[i].fi.l = il;
  }

  for (i=n-1; i>=0; i--) {
    int isOr, isOrL, isOrR;
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      continue;
    }
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
    isOr = nnfCoreMgr->gateType[i] == 'O';
    isOrR = nnfCoreMgr->gateType[ir] == 'O';
    isOrL = nnfCoreMgr->gateType[il] == 'O';
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[ir]) {
      if (nnfGates[ir].foCnt==1) {
	nnfGates[ir].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfCoreMgr->gateType[i] == nnfCoreMgr->gateType[il]) {
      if (nnfGates[il].foCnt==1) {
	nnfGates[il].clstLdr = nnfGates[i].clstLdr;
      }
    }
    if (nnfGates[ir].foCnt==1) {
      nnfGates[ir].clstLdr2 = nnfGates[i].clstLdr2;
    }
    if (nnfGates[il].foCnt==1) {
      nnfGates[il].clstLdr2 = nnfGates[i].clstLdr2;
    }

    if (nnfGates[i].clstLdr==i) {
      totRoot++;
    }
    else {
      totIn++;
    }
    if (nnfGates[i].clstLdr2==i) {
      totRoot2++;
    }
    else {
      totIn2++;
    }
  }

  int maxL = -1, iMax = -1;
  // lastIn fields used for level
  for (i=0; i<n; i++) {
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    if (ir>=0 && il>=0) {
      int foR = nnfGates[ir].foCnt;
      int foL = nnfGates[il].foCnt;
      int levelR = foR>1 ? 0 : nnfGates[ir].lastIn;
      int levelL = foL>1 ? 0 : nnfGates[il].lastIn;
      int level = levelR;
      if (levelL>level) level = levelL;
      level++;
      nnfGates[i].lastIn = level;
      if (level>maxL) {
	maxL = level;
	iMax=i;
      }
    }
    else {
      nnfGates[i].lastIn = 0;
    }
  }
  printf("max fo 1 chain: %d - gate: %d\n", maxL, iMax);

  for (i=n-1; i>=0; i--) {
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    if (nnfGates[i].clstLdr == i) {
      // foAux = 1 means all macrogate pins with fo>0 (sharing possible)
      nnfGates[i].foAux = 1;
    }

    if (ir>=0 && il>=0) {
      int ldr = nnfGates[i].clstLdr;
      int ldr2 = nnfGates[i].clstLdr2;
      int cutPins=0;
      if (nnfGates[ir].clstLdr != ldr) {
	Pdtutil_Assert(nnfGates[ir].clstLdr == ir,
		       "wrong gate pattitioning");
	if (nnfGates[ir].foCnt==1) {
	  nnfGates[ldr].foAux = 0;
	}
	else cutPins++;
	nnfGates[ldr].ldrFiNum++;
      }
      if (nnfGates[il].clstLdr != ldr) {
	Pdtutil_Assert(nnfGates[il].clstLdr == il,
		       "wrong gate pattitioning");
	if (nnfGates[il].foCnt==1) {
	  nnfGates[ldr].foAux = 0;
	}
	else cutPins++;
	nnfGates[ldr].ldrFiNum++;
      }
      if (cutPins==2) {
	// macrogate full entry gate 
	nnfGates[i].foAux2 = 1;
      }
      if (nnfGates[ir].clstLdr2 != ldr2) {
	nnfGates[ldr2].ldrFiNum++;
      }
    }
  }

  int nMgP[4] = {0};
  int best, maxl=0, iLev=-1, iClst2, maxClst2=0, nMgForRefact=0, nMgPin=0;

  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);

  for (i=n-1; i>=0; i--) {
    int ir = nnfGates[i].fi.r;
    int il = nnfGates[i].fi.l;
    int ldr = nnfGates[i].clstLdr;

    // macrogate leader with all shareable cut pins
    if (nnfGates[i].foAux) {
      int np = nnfGates[i].ldrFiNum;
      if (np>5) np=5;
      nMgP[np-2]++;
      nMgForRefact++;
      nMgPin += nnfGates[i].ldrFiNum;
      if (np==2) {
      }
    }
    if (nnfGates[i].foAux2 && !nnfGates[ldr].foAux) {
      nnfGates[i].foAux2 = 0; // disable
    }
    if (nnfGates[i].foAux2) {
      // macrogate full entry 
      bAigEdge_t look, baig = nnfCoreMgr->aNodes->nodes[i];
      bAigEdge_t i10 = nnfCoreMgr->aNodes->nodes[ir];
      bAigEdge_t i11 = nnfCoreMgr->aNodes->nodes[il];
      int isOr = nnfCoreMgr->gateType[i] == 'O';
      int isOrR = nnfCoreMgr->gateType[ir] == 'O';
      int isOrL = nnfCoreMgr->gateType[il] == 'O';
      i10 = bAig_NonInvertedEdge(i10);
      i11 = bAig_NonInvertedEdge(i11);
      if (isOrR) {
	i10 = bAig_Not(i10);
      }
      if (isOrL) {
	i11 = bAig_Not(i11);
      }
      if (isOr) {
	// or has complemented pins
	i10 = bAig_Not(i10);
	i11 = bAig_Not(i11);
      }
      look = bAig_hashLookup(bmgr, i10, i11);
      nHashed++;
      Pdtutil_Assert (look != bAig_NULL,"missing hash entry");
      Pdtutil_Assert (look == bAig_NonInvertedEdge(baig),
		      "wrong hash entry");
      bAig_AuxInt(bmgr,baig) = i;
    }
  }

  int maxShare = 100000;
  int nShareable = 0, dummyShareable=0, nOther=0;
  dummyNodes = bAigArrayAlloc();

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];

    int level = bAig_AuxInt(bmgr,baig);

    if (nnfGates[i].foAux) {
      int np = nnfGates[i].ldrFiNum;
      if (np>5) np=5;
      if (np==3) {
	bAigEdge_t i0, i10, i11;
	bAigEdge_t look;
	int id;
	int ir = nnfGates[i].fi.r;
	int il = nnfGates[i].fi.l;
	int isOrR, isOrL, isOr = nnfCoreMgr->gateType[i] == 'O';
	int newR=-1, newL=-1, hashFound=0;

	if (nnfGates[ir].clstLdr == i && !nnfGates[ir].redJoin) {
	  Pdtutil_Assert(nnfGates[il].clstLdr == il,"macrogate problem");
	  i0 = nnfCoreMgr->aNodes->nodes[il];
	  newR = nnfGates[ir].fi.r;
	  newL = nnfGates[ir].fi.l;
	  isOrR = nnfCoreMgr->gateType[newR] == 'O';
	  isOrL = nnfCoreMgr->gateType[newL] == 'O';
	  i10 = nnfCoreMgr->aNodes->nodes[newR];
	  i11 = nnfCoreMgr->aNodes->nodes[newL];
	}
	else if (nnfGates[il].clstLdr == i && !nnfGates[il].redJoin) {
	  Pdtutil_Assert(nnfGates[ir].clstLdr == ir,"macrogate problem");
	  i0 = nnfCoreMgr->aNodes->nodes[ir];
	  newR = nnfGates[il].fi.r;
	  newL = nnfGates[il].fi.l;
	  isOrR = nnfCoreMgr->gateType[newR] == 'O';
	  isOrL = nnfCoreMgr->gateType[newL] == 'O';
	  i10 = nnfCoreMgr->aNodes->nodes[newR];
	  i11 = nnfCoreMgr->aNodes->nodes[newL];
	}
	if (newR<0 || newL<0) continue;
	i10 = bAig_NonInvertedEdge(i10);
	i11 = bAig_NonInvertedEdge(i11);
	if (isOrR) {
	  i10 = bAig_Not(i10);
	}
	if (isOrL) {
	  i11 = bAig_Not(i11);
	}
	if (isOr) {
	  // or has complemented pins
	  i0 = bAig_Not(i0);
	  i10 = bAig_Not(i10);
	  i11 = bAig_Not(i11);
	}

	hashFound = 0;
	look = bAig_hashLookup(bmgr, i10, i0);
	id = -1;
	if (look != bAig_NULL) {
	  id = bAig_AuxInt(bmgr,look);
	  if (id==-2) {
	      dummyShareable++;
	      look = bAig_NULL;
	  }
	  if (id>=0 && id<i) {
	    Pdtutil_Assert(nnfCoreMgr->gateType[id] == 
			   nnfCoreMgr->gateType[i],"gate type mismatch");
	    // gate(i11,gate(i10,i0))
	    // gate(newL,id)
#if 1
	    if (maxShare-- > 0) {
	    nnfGates[i].fi.r = newL;
	    nnfGates[i].fi.l = id;
	    }
#endif
	  }
	  else {
	    id = -1;
	    if (bAig_hashLookup(bmgr, bAig_Not(i10), 
				bAig_Not(i0))!= bAig_NULL) {
	      nOther++;
	    }
	  }
	}
	if (look == bAig_NULL || id<0) {
	  look = bAig_hashLookup(bmgr, i11, i0);
	  if (look != bAig_NULL) {
	    hashFound |= 2;
	    id = bAig_AuxInt(bmgr,look);
	    if (id==-2) {
	      dummyShareable++;
	    }
	    if (id>=0 && id<i) {
	      Pdtutil_Assert(nnfCoreMgr->gateType[id] == 
			   nnfCoreMgr->gateType[i],"gate type mismatch");
	      // gate(i10,gate(i11,i0))
	      // gate(newR,id)
#if 1
	    if (maxShare-- > 0) {
	      nnfGates[i].fi.r = newR;
	      nnfGates[i].fi.l = id;
	    }
#endif
	    }
	  }
	  else {
	    id = -1;
	    if (bAig_hashLookup(bmgr, bAig_Not(i11), 
				bAig_Not(i0))!= bAig_NULL) {
	      nOther++;
	    }
	  }
	}
	if (id>=0) {
	  // can be shared 
	  nShareable++;
	  // mark to disable refactoring
	  nnfGates[id].redJoin = 1; 
	}
	else if (!hashFound) {
	  // generate dummyGates
	  bAigEdge_t dummy;
	  dummy = isOr ? bAig_Or(bmgr,i10,i0):bAig_And(bmgr,i11,i0);
	  bAig_Ref(bmgr, dummy);
	  bAigArrayPush(dummyNodes,dummy);
	  bAig_AuxInt(bmgr,dummy) = -2;
	  dummy = isOr ? bAig_Or(bmgr,i11, i0):bAig_And(bmgr,i11,i0);
	  bAig_Ref(bmgr, dummy);
	  bAigArrayPush(dummyNodes,dummy);
	  bAig_AuxInt(bmgr,dummy) = -2;
	}
      }
    }
  }

  printf("n macrogate for refactor: %d - avg cut: %f (%d/%d/%d/%d)\n", 
	 nMgForRefact, nMgPin / (float)nMgForRefact,
	 nMgP[0],nMgP[1],nMgP[2],nMgP[3]);
  printf("n macrogate shearable: %d - dummy shareable: %d - hashed: %d - other gate: %d\n", 
	 nShareable, dummyShareable, nHashed, nOther);
  
  bAigEdge_t baig;

  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
  bAigArrayAuxIntClear(bmgr,dummyNodes);

  int j, jMax=-1;
  int nRedGate = 0, nRedLdr = 0, nRedLdr2 = 0, nRedGateFo1 = 0, nFrontier = 0;
  int cntOr=0, cntAnd=0;
  float bestf;


  n = nnfCoreMgr->aNodes->num;

  int nAdded=0; int maxEn=113;
  int enMerge = 1, enMergeTot = 1;

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    bAigEdge_t r, l, f0;
    int ir, il;

    if (bAig_NodeIsConstant(baig)) {
      f0 = bAig_Zero;
    }
    else if (bAig_isVarNode(bmgr,baig)) {
      f0 = bAig_NonInvertedEdge(baig);
    }
    else {
      int isAnd = nnfCoreMgr->gateType[i] == 'A';
      int merge = 0;
      ir = nnfGates[i].fi.r;
      il = nnfGates[i].fi.l;
      Pdtutil_Assert(i>=0&&il>=0,"fi index problem");
      Pdtutil_Assert(ir<i&&il<i,"fi index problem");
      /* f0 */
      r = nnfGates[ir].baig;
      Pdtutil_Assert(r!=bAig_NULL,"null baig");
      l = nnfGates[il].baig;
      Pdtutil_Assert(l!=bAig_NULL,"null baig");
      if (isAnd) {
	f0 = bAig_And(bmgr,r,l);
	bAig_Ref(bmgr, f0);
      }
      else {
	f0 = bAig_Or(bmgr,r,l);
	bAig_Ref(bmgr, f0);
      }

    }

    Pdtutil_Assert(f0!=bAig_NULL,"null baig");
    nnfGates[i].baig = f0;

  }

  a0 = Ddi_BddMakeFromBaig(ddm,nnfGates[n-1].baig);

  for (i=0; i<n; i++) {
    bAigEdge_t baig = nnfGates[i].baig;
    bAig_RecursiveDeref(bmgr,baig);
  }
  for (i=0; i<dummyNodes->num; i++) {
    bAigEdge_t baig = dummyNodes->nodes[i];
    bAig_RecursiveDeref(bmgr,baig);
  }
  bAigArrayFree(dummyNodes);

  Pdtutil_Free(nnfGates);
  Pdtutil_Free(auxV);

  nnfCoreMgrFree(nnfCoreMgr);

  Ddi_AigStructRedRemAcc (a0,NULL);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),
     "AIGNNF REFACT #share: %d - size %d->%d\n", 
	    nShareable, sizeA, Ddi_BddSize(a0));
  }

  if (chkRes) {
    Ddi_Bdd_t *aNew = Ddi_BddMakeAig(a0);
    Pdtutil_Assert(Ddi_AigEqualSat(aNew,a),"error in AIG NNF STRUCT OPT");
    Ddi_Free(aNew);
  }


  return(a0);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Vararray_t *
Ddi_NnfDualRailVars (
  Ddi_Vararray_t *refVars,
  int twoRails
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(refVars);
  Ddi_Vararray_t *vA;
  int i, n, useBddVars=1;
  char name[10000];

  n = Ddi_VararrayNum(refVars);
  vA = Ddi_VararrayAlloc(ddm,0);

  for (i=0; i<Ddi_VararrayNum(refVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(refVars,i);
    Ddi_Var_t *vAux;

    sprintf(name,"PDTRAV_NNF_RAIL_0_%s",Ddi_VarName(v));

    vAux = Ddi_VarFindOrAdd(ddm, name, useBddVars);
    if (twoRails>0) {
      // write rail 1 (reference) var
      Ddi_VararrayInsertLast(vA,v);
    }
    // write rail 0 var
    Ddi_VararrayInsertLast(vA,vAux);
  }

  Pdtutil_Assert(Ddi_VararrayNum(vA)==(twoRails?2:1)*n,
                 "wrong array size in dual rail vars");
  return vA;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_NnfDualRailEq(
  Ddi_Bdd_t *eqConstr0,
  Ddi_Vararray_t *refV
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(eqConstr0);
  Ddi_Bdd_t *eqConstr = Ddi_BddDup(eqConstr0);
  Ddi_Vararray_t *varsNew, *vars = Ddi_BddReadEqVars (eqConstr);
  Ddi_Bddarray_t *substNew, *subst = Ddi_BddReadEqSubst (eqConstr);
  int i, n, n1;
  Ddi_Vararray_t *dualV;
  Ddi_Bddarray_t *dLits, *rLits;

  dualV = Ddi_NnfDualRailVars(refV, 0);
  rLits = Ddi_BddarrayMakeLiteralsAig(refV,1);
  dLits = Ddi_BddarrayMakeLiteralsAig(dualV,1);

  varsNew = Ddi_VararrayAlloc(ddm,0);
  substNew = Ddi_BddarrayAlloc(ddm,0);


  for (i=0; i<Ddi_VararrayNum(refV); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(refV,i);
    Ddi_VarWriteMark (v, i+1);
  }

  n = Ddi_VararrayNum(vars);

  for (i=n1=0; i<n; i++) {
    Ddi_Var_t *vEq, *v2, *v = Ddi_VararrayRead(vars,i);
    Ddi_Bdd_t *rLit, *dLit, *eq = Ddi_BddarrayRead(subst,i);
    int i0, i1, isCompl = Ddi_BddIsComplement(eq);

    if (Ddi_BddIsConstant(eq)) {
      // keep as it is and go ahead
      Ddi_VararrayInsertLast(varsNew,v);
      Ddi_BddarrayInsertLast(substNew,eq);
      n1++;
      continue;
    }

    Pdtutil_Assert (Ddi_BddIsLiteralAig(eq),"literal needed");

    vEq = Ddi_BddTopVar(eq);
    i0 = Ddi_VarReadMark (v) - 1;
    i1 = Ddi_VarReadMark (vEq) - 1;

    Pdtutil_Assert ((i0>=0)&&(i1>=0),"literal needed");

    v2 = Ddi_VararrayRead(dualV,i0);
    rLit = Ddi_BddarrayRead(rLits,i1);
    dLit = Ddi_BddarrayRead(dLits,i1);

    Ddi_VararrayInsertLast(varsNew,v);
    Ddi_VararrayInsertLast(varsNew,v2);

    if (isCompl) {
      Ddi_BddarrayInsertLast(substNew,dLit);
      Ddi_BddarrayInsertLast(substNew,rLit);
    } else {
      Ddi_BddarrayInsertLast(substNew,rLit);
      Ddi_BddarrayInsertLast(substNew,dLit);
    }

  }

  Pdtutil_Assert(Ddi_VararrayNum(varsNew)==2*n-n1,"wrong var array size");
  Ddi_VararrayWriteMark (refV, 0);

  Ddi_DataCopy(vars,varsNew);
  Ddi_DataCopy(subst,substNew);

  Ddi_Free(varsNew);
  Ddi_Free(substNew);

  Ddi_Free(dualV);
  Ddi_Free(rLits);
  Ddi_Free(dLits);

  return eqConstr;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Vararray_t *
Ddi_NnfDualRailFilterRefVars (
  Ddi_Vararray_t *refVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(refVars);
  Ddi_Vararray_t *vA;
  int i;

  vA = Ddi_VararrayAlloc(ddm,0);

  for (i=0; i<Ddi_VararrayNum(refVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(refVars,i);
    if (strncmp("PDTRAV_NNF_RAIL_0_",Ddi_VarName(v),18)==0) continue;

    Ddi_VararrayInsertLast(vA,v);
  }

  return vA;
}



/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigarrayNnfCheck (
  Ddi_Bddarray_t *fA,
  Ddi_Bddarray_t *fRef
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  Ddi_Bddarray_t *rLits, *chkFA;
  Ddi_Vararray_t *supp, *refV, *dualV;
  int i, n = Ddi_BddarrayNum(fA);
  int ret = 1, cntDiff = 0;
  Ddi_Bddarray_t *fOK = Ddi_BddarrayAlloc(ddm,0);

  supp = Ddi_BddarraySuppVararray(fA);
  refV = Ddi_NnfDualRailFilterRefVars (supp);
  dualV = Ddi_NnfDualRailVars(refV, 0);
  rLits = Ddi_BddarrayMakeLiteralsAig(refV,0);

  chkFA = Ddi_BddarrayCompose(fA,dualV,rLits);
  Ddi_Free(supp);
  Ddi_Free(refV);
  Ddi_Free(dualV);
  Ddi_Free(rLits);

  for (i=0; /*ret &&*/ i<n; i+=2) {
    Ddi_Bdd_t *f_i = Ddi_BddarrayRead(chkFA,i);
    Ddi_Bdd_t *f_i0 = Ddi_BddNot(Ddi_BddarrayRead(chkFA,i+1));
    if (!Ddi_AigEqualSat(f_i,f_i0)) {
      ret = 0;
      cntDiff++;
    }
    else if (fRef!=NULL) {
      Ddi_Bdd_t *fr_i = Ddi_BddarrayRead(fRef,i/2);
      Ddi_BddarrayInsertLast(fOK,fr_i);
    }
    Ddi_Free(f_i0);
  }

  Ddi_Free(chkFA);
  Ddi_Free(fOK);

  return ret;

}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_BddAigFromNnf(
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *refV
)
{
  Ddi_Bdd_t *newF = Ddi_BddDup(f);

  Ddi_BddAigFromNnfAcc(newF,refV);

  return(newF);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_BddAigFromNnfAcc(
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *refV
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *rLits;
  Ddi_Vararray_t *dualV;

  dualV = Ddi_NnfDualRailVars(refV, 0);
  rLits = Ddi_BddarrayMakeLiteralsAig(refV,0);

  Ddi_BddComposeAcc(f,dualV,rLits);

  Ddi_Free(dualV);
  Ddi_Free(rLits);

  return(f);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_BddAigFromNnfTwoRailsAcc(
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *refV
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *rLits, *rLits0, *rLits1;
  Ddi_Vararray_t *dualV;
  int i, nv = Ddi_VararrayNum(refV);

  Pdtutil_Assert(0,"This has to be rewritten - not working");
  dualV = Ddi_NnfDualRailVars(refV, 1);
  rLits0 = Ddi_BddarrayMakeLiteralsAig(refV,0);
  rLits1 = Ddi_BddarrayMakeLiteralsAig(refV,1);
  rLits = Ddi_BddarrayAlloc(ddm,0);
  for (i=0; i<nv; i++) {
    Ddi_BddarrayInsertLast(rLits,Ddi_BddarrayRead(rLits0,i));
    Ddi_BddarrayInsertLast(rLits,Ddi_BddarrayRead(rLits1,i));
  }
  
  Ddi_BddComposeAcc(f,dualV,rLits);

  Ddi_Free(dualV);
  Ddi_Free(rLits);
  Ddi_Free(rLits0);
  Ddi_Free(rLits1);

  return(f);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
AigFromNnfFullAcc(
  Ddi_Bdd_t *f,
  nnfCoreMgr_t *nnfMgr
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Vararray_t *refV = nnfMgr->rV;
  Ddi_Bddarray_t *rLits;
  Ddi_Vararray_t *dualV0, *dualV1;

  dualV0 = nnfMgr->aV0;
  dualV1 = nnfMgr->aV1;
  rLits = Ddi_BddarrayMakeLiteralsAig(refV,0);
  Ddi_BddComposeAcc(f,dualV0,rLits);
  Ddi_Free(rLits);
  rLits = Ddi_BddarrayMakeLiteralsAig(refV,1);
  Ddi_BddComposeAcc(f,dualV1,rLits);

  Ddi_Free(rLits);

  return(f);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_BddarrayAigFromNnfAcc(
  Ddi_Bddarray_t *fA,
  Ddi_Vararray_t *refV,
  char *varPrefix,
  int joinOutputs
)
{
  Ddi_Bddarray_t *newFA = Ddi_BddarrayAigFromNnf(fA,refV,varPrefix,
                                                 joinOutputs);
  Ddi_DataCopy(fA,newFA);
  Ddi_Free(newFA);
  return fA;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_BddarrayAigFromNnf(
  Ddi_Bddarray_t *fA,
  Ddi_Vararray_t *refV,
  char *varPrefix,
  int joinOutputs
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  Ddi_Bddarray_t *rLits, *newFA;
  Ddi_Vararray_t *dualV;
  int i, n = Ddi_BddarrayNum(fA);

  dualV = Ddi_NnfDualRailVars(refV, 0);
  rLits = Ddi_BddarrayMakeLiteralsAig(refV,0);

  if (joinOutputs) {
    newFA = Ddi_BddarrayAlloc(ddm,n/2);
    for (i=0; i<n; i+=2) {
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(fA,i);
      Ddi_BddarrayWrite(newFA,i/2,f_i);
    }
  }
  else {
    newFA = Ddi_BddarrayDup(fA);
  }

  if (varPrefix!=NULL) {
    Ddi_Vararray_t *dualV2 =
      Ddi_VararrayMakeNewAigVars(dualV, varPrefix, NULL);
    Ddi_Vararray_t *refV2 =
      Ddi_VararrayMakeNewAigVars(refV, varPrefix, NULL);
    Ddi_Free(rLits);
    rLits = Ddi_BddarrayMakeLiteralsAig(refV2,0);

    Ddi_BddarrayComposeAcc(newFA,dualV2,rLits);

    Ddi_Free(dualV2);
    Ddi_Free(refV2);
  }
  else {
    Ddi_BddarrayComposeAcc(newFA,dualV,rLits);
  }

  Ddi_Free(dualV);
  Ddi_Free(rLits);

  return(newFA);
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_BddarrayNnfOutputSplit(
  Ddi_Bddarray_t *fA
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  int i, n = Ddi_BddarrayNum(fA);
  Ddi_Bddarray_t *newFA=Ddi_BddarrayAlloc(ddm,2*n);

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f_i = Ddi_BddarrayRead(fA,i);
    Ddi_Bdd_t *f_i0 = Ddi_BddNot(f_i);
    Ddi_BddarrayWrite(newFA,2*i,f_i);
    Ddi_BddarrayWrite(newFA,2*i+1,f_i0);
    Ddi_Free(f_i0);
  }

  return(newFA);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_BddarrayNnfOutputSplitAcc(
  Ddi_Bddarray_t *fA
)
{
  Ddi_Bddarray_t *newFA = Ddi_BddarrayNnfOutputSplit(fA);
  Ddi_DataCopy(fA,newFA);
  Ddi_Free(newFA);
  return fA;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayNnf (
  Ddi_Bddarray_t *fA,
  Ddi_Vararray_t *monotoneVars,
  int assumeRed,
  Ddi_Bdd_t *splitVarConstrain,
  Ddi_Vararray_t *refVars,
  Ddi_Vararray_t *auxVars0,
  Ddi_Vararray_t *auxVars1
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, varAuxIndex, fBaig, f0, f1;
  Ddi_Vararray_t *vA, *vAuxA0=NULL, *vAuxA1=NULL;
  int i, n;
  Ddi_Bddarray_t *newFa;
  int  useAigNnfVars = 0, fullSubst = auxVars1!=NULL;
  char name[10000];

  n = Ddi_BddarrayNum(fA);

  visitedNodes = bAigArrayAlloc();

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    if (!Ddi_BddIsConstant(fAig)) {
      fBaig = Ddi_BddToBaig(fAig);
      postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  if (assumeRed) {
    for (i=0; i<visitedNodes->num; i++) {
      fBaig = visitedNodes->nodes[i];
      nodeAuxChar(bmgr,fBaig) = 0;
    }
    for (i=0; i<Ddi_BddarrayNum(fA); i++) {
      Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
      int isNeg = Ddi_BddIsComplement(fAig);
      fBaig = Ddi_BddToBaig(fAig);
      nodeAuxChar(bmgr,fBaig) = isNeg ? -1 : 1;
    }
  }


  if (monotoneVars == NULL) {
    vA = Ddi_BddarraySuppVararray(fA);
  }
  else {
    vA = Ddi_VararrayDup(monotoneVars);
  }
  vAuxA0 = Ddi_VararrayAlloc(ddm,Ddi_VararrayNum(vA));
  if (fullSubst) {
    vAuxA1 = Ddi_VararrayAlloc(ddm,Ddi_VararrayNum(vA));
  }
  if (splitVarConstrain != NULL) {
    Ddi_BddSetPartConj(splitVarConstrain);
  }

  /* initially set ternary X on all vars */
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Var_t *vAux;
    varIndex = Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    Pdtutil_Assert(bAig_AuxAig0(bmgr,varIndex)==bAig_NULL,
      "NULL AuxAig0 required");

    sprintf(name,"PDTRAV_NNF_RAIL_0_%s",Ddi_VarName(v));

    if ((vAux = Ddi_VarFromName(ddm,name))==NULL) {
      if (useAigNnfVars)
	vAux = Ddi_VarNewBaig(ddm,name);
      else {
	vAux = Ddi_VarNew(ddm);
	Ddi_VarAttachName (vAux, name);
      }
    }
    Ddi_VararrayWrite(vAuxA0,i,vAux);
    varAuxIndex = Ddi_VarToBaig(vAux);

    /* set ternary X */
    bAig_AuxAig1(bmgr,varIndex) = varIndex;
    bAig_AuxAig0(bmgr,varIndex) = varAuxIndex;
    bAig_Ref(bmgr, varIndex);
    bAig_Ref(bmgr, varAuxIndex);
    if (splitVarConstrain != NULL) {
      Ddi_Bdd_t *litRef = Ddi_BddMakeLiteralAig(v,1);
      Ddi_Bdd_t *lit0 = Ddi_BddMakeLiteralAig(vAux,1);
      Ddi_Bdd_t *eq = Ddi_BddXor(litRef,lit0);
      Ddi_BddPartInsertLast(splitVarConstrain,eq);
      Ddi_Free(lit0);
      Ddi_Free(litRef);
      Ddi_Free(eq);
    }

    if (fullSubst) {
      sprintf(name,"PDTRAV_NNF_RAIL_1_%s",Ddi_VarName(v));

      if ((vAux = Ddi_VarFromName(ddm,name))==NULL) {
	if (useAigNnfVars)
	  vAux = Ddi_VarNewBaig(ddm,name);
	else {
	  vAux = Ddi_VarNew(ddm);
	  Ddi_VarAttachName (vAux, name);
	}
      }
      Ddi_VararrayWrite(vAuxA1,i,vAux);
      varAuxIndex = Ddi_VarToBaig(vAux);

      /* set ternary X */
      bAig_RecursiveDeref(bmgr,varIndex); /* undo previous ref */
      bAig_AuxAig1(bmgr,varIndex) = varAuxIndex;
      bAig_Ref(bmgr, varAuxIndex);
      if (splitVarConstrain != NULL) {
	Ddi_Bdd_t *litRef = Ddi_BddMakeLiteralAig(v,1);
	Ddi_Bdd_t *lit1 = Ddi_BddMakeLiteralAig(vAux,1);
	Ddi_Bdd_t *eq = Ddi_BddXnor(litRef,lit1);
	Ddi_BddPartInsertLast(splitVarConstrain,eq);
	Ddi_Free(lit1);
	Ddi_Free(litRef);
	Ddi_Free(eq);
      }
    }
  }

  monotoneSplitIntern(ddm,visitedNodes,assumeRed);
  newFa = Ddi_BddarrayAlloc(ddm,2*n);

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    Ddi_Bdd_t *fAig0, *fAig1;
    fBaig = Ddi_BddToBaig(fAig);
    if (assumeRed) {
      nodeAuxChar(bmgr,fBaig) = 0;
    }
    if (Ddi_BddIsConstant(fAig)) {
      f0 = bAig_One;
      f1 = bAig_Zero;
    }
    else {
      f0 = bAig_AuxAig0(bmgr,fBaig);
      f1 = bAig_AuxAig1(bmgr,fBaig);
    }
    Pdtutil_Assert(f0!=bAig_NULL,"NULL baig");
    Pdtutil_Assert(f1!=bAig_NULL,"NULL baig");
    if (bAig_NodeIsInverted(fBaig)) {
      bAigSwap(f0,f1);
    }
    fAig0 = Ddi_BddMakeFromBaig(ddm,f0);
    fAig1 = Ddi_BddMakeFromBaig(ddm,f1);
    Ddi_BddarrayWrite(newFa,2*i,fAig1);
    Ddi_BddarrayWrite(newFa,2*i+1,fAig0);
    Ddi_Free(fAig0);
    Ddi_Free(fAig1);
  }

  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);

  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);

    varIndex = Ddi_VarToBaig(v);

    if (varIndex != bAig_NULL) {
      bAig_AuxAig0(bmgr,varIndex) = bAig_NULL;
      bAig_AuxAig1(bmgr,varIndex) = bAig_NULL;
    }
  }

  bAigArrayFree(visitedNodes);

  if (refVars!=NULL) {
    Ddi_DataCopy(refVars,vA);
  }
  if (auxVars0!=NULL) {
    Ddi_DataCopy(auxVars0,vAuxA0);
  }
  if (auxVars1!=NULL) {
    Ddi_DataCopy(auxVars1,vAuxA1);
  }

  Ddi_Free(vA);
  Ddi_Free(vAuxA0);
  Ddi_Free(vAuxA1);

  return(newFa);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigCheckMonotone (
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *monotoneVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *fA;
  int ret;

  if (Ddi_BddIsPartConj(f)) {
    fA = Ddi_BddarrayMakeFromBddPart(f);
  }
  else if (Ddi_BddIsPartDisj(f)) {
    fA = Ddi_BddarrayMakeFromBddPart(f);
  }
  else {
    fA = Ddi_BddarrayAlloc(ddm,1);
    Ddi_BddarrayWrite(fA,0,f);
  }

  ret = Ddi_AigarrayCheckMonotone (fA,monotoneVars);

  Ddi_Free(fA);

  return ret;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigarrayCheckMonotone (
  Ddi_Bddarray_t *fA,
  Ddi_Vararray_t *monotoneVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  bAigEdge_t fBaig;
  Ddi_Vararray_t *vA;
  int i, n;
  int OK=1;

  n = Ddi_BddarrayNum(fA);

  visitedNodes = bAigArrayAlloc();

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    if (!Ddi_BddIsConstant(fAig)) {
      fBaig = Ddi_BddToBaig(fAig);
      postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  if (monotoneVars == NULL) {
    vA = Ddi_BddarraySuppVararray(fA);
  }
  else {
    vA = Ddi_VararrayDup(monotoneVars);
  }

  Ddi_VararrayWriteMark (vA, 1);

  for (i=0; i<visitedNodes->num; i++) {
    fBaig = visitedNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxAig0(bmgr,fBaig)==bAig_NULL,"wrong aux");
    Pdtutil_Assert(bAig_AuxAig1(bmgr,fBaig)==bAig_NULL,"wrong aux");
  }

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    int isNeg = Ddi_BddIsComplement(fAig);
    if (!Ddi_BddIsConstant(fAig)) {
      fBaig = Ddi_BddToBaig(fAig);
      if (isNeg) {
        bAig_AuxAig0(bmgr,fBaig)=fBaig;
      }
      else {
        bAig_AuxAig1(bmgr,fBaig)=fBaig;
      }
    }
  }

  for (i=visitedNodes->num-1; i>=0; i--) {
    int isPos, isNeg;
    fBaig = visitedNodes->nodes[i];
    isNeg = bAig_AuxAig0(bmgr,fBaig)!=bAig_NULL;
    isPos = bAig_AuxAig1(bmgr,fBaig)!=bAig_NULL;
    Pdtutil_Assert(isNeg || isPos,"baig without phase");
    if (!(bAig_NodeIsConstant(fBaig)) && bAig_isVarNode(bmgr,fBaig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,fBaig);
      if (isNeg && Ddi_VarReadMark(v)>0) {
	OK = 0;
	printf("complemented var in monotone check: %s\n", Ddi_VarName(v));
      }
    }
    else if (!(bAig_NodeIsConstant(fBaig))) {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,fBaig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,fBaig);
      int isNegR = bAig_NodeIsInverted(right);
      int isNegL = bAig_NodeIsInverted(left);

      if (isNeg&&isPos) {
	// OK = 0;
        bAig_AuxAig0(bmgr,right)=right;
        bAig_AuxAig1(bmgr,right)=right;
        bAig_AuxAig0(bmgr,left)=left;
        bAig_AuxAig1(bmgr,left)=left;
      }
      else {
	if (isNeg) {
	  isNegR = !isNegR;
	  isNegL = !isNegL;
	}
	if (isNegR) {
	  bAig_AuxAig0(bmgr,right)=right;
	}
	else {
	  bAig_AuxAig1(bmgr,right)=right;
	}
	if (isNegL) {
	  bAig_AuxAig0(bmgr,left)=left;
	}
	else {
	  bAig_AuxAig1(bmgr,left)=left;
	}
      }
    }
  }

  for (i=visitedNodes->num-1; i>=0; i--) {
    int isPos, isNeg;
    fBaig = visitedNodes->nodes[i];
    bAig_AuxAig0(bmgr,fBaig)=bAig_NULL;
    bAig_AuxAig1(bmgr,fBaig)=bAig_NULL;
  }

  Ddi_VararrayWriteMark (vA, 0);

  bAigArrayFree(visitedNodes);

  Ddi_Free(vA);
  return OK;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigConstrainByStructRedRem (
  Ddi_Bdd_t *f,
  Ddi_Bddarray_t *shareA,
  Ddi_Bdd_t *constr
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *fNew;
  Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,0);
  Ddi_BddarrayWrite(fA,0,f);
  Ddi_AigarrayStructRedRemWithConstrAcc (fA,shareA,constr);
  fNew = Ddi_BddarrayExtract(fA,0);
  Ddi_Free(fA);
  return fNew;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigConstrainByStructRedRemAcc (
  Ddi_Bdd_t *f,
  Ddi_Bddarray_t *shareA,
  Ddi_Bdd_t *constr
)
{
  Ddi_Bdd_t *fNew = Ddi_AigConstrainByStructRedRem (f,shareA,constr);
  Ddi_DataCopy(f,fNew);
  Ddi_Free(fNew);
  return f;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayStructRedRemWithConstrAcc (
  Ddi_Bddarray_t *fA,
  Ddi_Bddarray_t *shareA,
  Ddi_Bdd_t *constr
)
{
  int nc, i;
  Ddi_Bddarray_t *fArray, *newfA;
  Ddi_Bdd_t *myConstr = Ddi_AigPartitionTop(constr,0);

  fArray = Ddi_BddarrayMakeFromBddPart(myConstr);
  nc = Ddi_BddarrayNum(fArray);
  Ddi_BddarrayAppend(fArray,fA);
  newfA = Ddi_AigarrayStructRedRem (fArray,shareA,nc);
  Ddi_Free(fArray);
  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *newf_i = Ddi_BddarrayRead(newfA,nc+i);
    Ddi_BddarrayWrite(fA,i,newf_i);
  }
  Ddi_Free(newfA);
  Ddi_Free(myConstr);
  return fA;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayStructRedRem (
  Ddi_Bddarray_t *fA,
  Ddi_Bddarray_t *shareA,
  int assumeRed
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes, *shareNodes;
  bAigEdge_t varIndex, varAuxIndex, fBaig, f;
  int i, n, nshared=0;
  Ddi_Bddarray_t *newFa;
  int  useAigMonotoneVars = 0;
  char name[10000];

  n = Ddi_BddarrayNum(fA);

  visitedNodes = bAigArrayAlloc();
  shareNodes = bAigArrayAlloc();

  if (shareA != NULL) {
    for (i=0; i<Ddi_BddarrayNum(shareA); i++) {
      Ddi_Bdd_t *fAig = Ddi_BddarrayRead(shareA, i);
      if (!Ddi_BddIsConstant(fAig)) {
	fBaig = Ddi_BddToBaig(fAig);
	postOrderAigVisitIntern(bmgr,fBaig,shareNodes,-1);
      }
    }
    postOrderAigClearVisitedIntern(bmgr,shareNodes);
    aigArrayClearAuxAigIntern(bmgr,shareNodes);

    for (i=0; i<shareNodes->num; i++) {
      bAigEdge_t baig = shareNodes->nodes[i];
      Pdtutil_Assert(bAig_AuxInt(bmgr,baig)==-1,"wrong aux int");
      bAig_AuxInt(bmgr,baig)=1;
    }
  }

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    if (!Ddi_BddIsConstant(fAig)) {
      fBaig = Ddi_BddToBaig(fAig);
      postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  vec<bAigEdge_t> saveAuxChars;
  vec<char> saveAuxCharVal;

  if (assumeRed) {
    int n = Ddi_BddarrayNum(fA);
    if (assumeRed>=1 && assumeRed<n) {
      n = assumeRed;
    }
    for (i=0; i<visitedNodes->num; i++) {
      fBaig = visitedNodes->nodes[i];
      char oldc = nodeAuxChar(bmgr,fBaig);
      if (oldc!=0) {
        saveAuxChars.push(fBaig);
        saveAuxCharVal.push(oldc);
      }
      nodeAuxChar(bmgr,fBaig) = 0;
    }
    for (i=0; i<n; i++) {
      Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
      int isNeg = Ddi_BddIsComplement(fAig);
      fBaig = Ddi_BddToBaig(fAig);
      char oldc = nodeAuxChar(bmgr,fBaig);
      if (oldc!=0) {
        saveAuxChars.push(fBaig);
        saveAuxCharVal.push(oldc);
      }
      nodeAuxChar(bmgr,fBaig) = isNeg ? -1 : 1;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    if (bAig_AuxInt(bmgr,baig)==1) {
      /* shared */
      bAig_AuxAig0(bmgr,baig) = bAig_NonInvertedEdge(baig);
      bAig_Ref(bmgr, baig);
      nshared++;
    }
  }


  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMed_c,
     printf("SHARED NODES: %d/%d\n", nshared,visitedNodes->num));

  newAigEvalIntern(ddm,visitedNodes);
  newFa = Ddi_BddarrayAlloc(ddm,n);

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    Ddi_Bdd_t *fAig0;
    fBaig = Ddi_BddToBaig(fAig);
    if (assumeRed) {
      nodeAuxChar(bmgr,fBaig) = 0;
    }
    if (Ddi_BddIsConstant(fAig)) {
      f = bAig_Zero;
    }
    else {
      f = bAig_AuxAig0(bmgr,fBaig);
    }
    Pdtutil_Assert(f!=bAig_NULL,"NULL baig");
    if (bAig_NodeIsInverted(fBaig)) {
      f = bAig_Not(f);
    }
    fAig0 = Ddi_BddMakeFromBaig(ddm,f);
    Ddi_BddarrayWrite(newFa,i,fAig0);
    Ddi_Free(fAig0);
  }

  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);
  bAigArrayClearFreeAuxAig(bmgr,shareNodes);

  for (int i=0; i<saveAuxChars.size(); i++) {
    bAigEdge_t baig = saveAuxChars[i];
    nodeAuxChar(bmgr,baig) = saveAuxCharVal[i];
  }
  if (shareA != NULL) {
    for (i=0; i<shareNodes->num; i++) {
      bAigEdge_t baig = shareNodes->nodes[i];
      bAig_AuxInt(bmgr,baig)=-1;
    }
  }

  bAigArrayFree(visitedNodes);
  bAigArrayFree(shareNodes);

  return(newFa);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayStructRedRemOdcWithAssume (
  Ddi_Bddarray_t *fA,
  Ddi_Bddarray_t *assume,
  void *nnfCoreMgrVoid
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, varAuxIndex, fBaig, f;
  int i, n, na, nshared=0;
  Ddi_Bddarray_t *newFa;
  int  useAigMonotoneVars = 0;
  char name[10000];
  nnfCoreMgr_t *nnfCoreMgr = (nnfCoreMgr_t *)nnfCoreMgrVoid;

  n = Ddi_BddarrayNum(fA);
  na = Ddi_BddarrayNum(assume);

  if (nnfCoreMgr!=NULL) {
    visitedNodes = nnfCoreMgr->aNodes;
  }
  else {
    visitedNodes = bAigArrayAlloc();

    for (i=0; i<Ddi_BddarrayNum(fA); i++) {
      Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
      if (!Ddi_BddIsConstant(fAig)) {
        fBaig = Ddi_BddToBaig(fAig);
        postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
      }
    }
    postOrderAigClearVisitedIntern(bmgr,visitedNodes);
    aigArrayClearAuxAigIntern(bmgr,visitedNodes);
  }

  vec<bAigEdge_t> saveAuxChars;
  vec<char> saveAuxCharVal;

  for (i=0; i<visitedNodes->num; i++) {
    fBaig = visitedNodes->nodes[i];
    char oldc = nodeAuxChar(bmgr,fBaig);
    if (oldc!=0) {
      saveAuxChars.push(fBaig);
      saveAuxCharVal.push(oldc);
    }
    nodeAuxChar(bmgr,fBaig) = 0;
  }
  for (i=0; i<na; i++) {
    Ddi_Bdd_t *aAig = Ddi_BddarrayRead(assume, i);
    int isNeg = Ddi_BddIsComplement(aAig);
    fBaig = Ddi_BddToBaig(aAig);
    char oldc = nodeAuxChar(bmgr,fBaig);
    if (oldc!=0) {
      saveAuxChars.push(fBaig);
      saveAuxCharVal.push(oldc);
    }
    nodeAuxChar(bmgr,fBaig) = isNeg ? -1 : 1;
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    if (bAig_AuxInt(bmgr,baig)==1) {
      /* shared */
      bAig_AuxAig0(bmgr,baig) = bAig_NonInvertedEdge(baig);
      bAig_Ref(bmgr, baig);
      nshared++;
    }
  }

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMed_c,
        printf("REDREM with ODC asume - NODES/ASS: %d/%d\n",
               visitedNodes->num, na));

  newAigEvalInternNnf(ddm,visitedNodes,nnfCoreMgr);
  newFa = Ddi_BddarrayAlloc(ddm,n);

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    Ddi_Bdd_t *fAig0;
    fBaig = Ddi_BddToBaig(fAig);
    if (Ddi_BddIsConstant(fAig)) {
      f = bAig_Zero;
    }
    else {
      f = bAig_AuxAig0(bmgr,fBaig);
    }
    Pdtutil_Assert(f!=bAig_NULL,"NULL baig");
    if (bAig_NodeIsInverted(fBaig)) {
      f = bAig_Not(f);
    }
    fAig0 = Ddi_BddMakeFromBaig(ddm,f);
    Ddi_BddarrayWrite(newFa,i,fAig0);
    Ddi_Free(fAig0);
  }

  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);

  for (i=0; i<na; i++) {
    Ddi_Bdd_t *aAig = Ddi_BddarrayRead(assume, i);
    fBaig = Ddi_BddToBaig(aAig);
    nodeAuxChar(bmgr,fBaig) = 0;
  }
  for (int i=0; i<saveAuxChars.size(); i++) {
    bAigEdge_t baig = saveAuxChars[i];
    nodeAuxChar(bmgr,baig) = saveAuxCharVal[i];
  }

  if (nnfCoreMgr==NULL) {
    bAigArrayFree(visitedNodes);
  }
  
  return(newFa);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayInsertCuts (
  Ddi_Bddarray_t *fA,
  Ddi_Bddarray_t *cuts,
  Ddi_Vararray_t *vars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes, *shareNodes;
  bAigEdge_t varIndex, varAuxIndex, fBaig, f;
  int i, n, nshared=0;
  Ddi_Bddarray_t *newFa;
  int  useAigMonotoneVars = 0;
  char name[10000];

  n = Ddi_BddarrayNum(fA);

  visitedNodes = bAigArrayAlloc();
  shareNodes = bAigArrayAlloc();

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    if (!Ddi_BddIsConstant(fAig)) {
      fBaig = Ddi_BddToBaig(fAig);
      postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);


  for (i=0; i<Ddi_BddarrayNum(cuts); i++) {
    Ddi_Var_t *cutVar = Ddi_VararrayRead(vars,i);
    bAigEdge_t vBaig = Ddi_VarToBaig(cutVar);
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(cuts, i);
    bAigEdge_t fBaig = Ddi_BddToBaig(fAig);
    int isNeg = Ddi_BddIsComplement(fAig);
    bAigEdge_t cutBaig = bAig_NonInvertedEdge(vBaig);
    if (isNeg) {
      cutBaig = bAig_Not(cutBaig);
    }
    bAig_Ref(bmgr, cutBaig);
    bAig_AuxAig0(bmgr,fBaig) = cutBaig;
  }

  newAigEvalIntern(ddm,visitedNodes);
  newFa = Ddi_BddarrayAlloc(ddm,n);

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    Ddi_Bdd_t *fAig0;
    fBaig = Ddi_BddToBaig(fAig);
    if (Ddi_BddIsConstant(fAig)) {
      f = bAig_Zero;
    }
    else {
      f = bAig_AuxAig0(bmgr,fBaig);
    }
    Pdtutil_Assert(f!=bAig_NULL,"NULL baig");
    if (bAig_NodeIsInverted(fBaig)) {
      f = bAig_Not(f);
    }
    fAig0 = Ddi_BddMakeFromBaig(ddm,f);
    Ddi_BddarrayWrite(newFa,i,fAig0);
    Ddi_Free(fAig0);
  }

  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);
  for (i=0; i<Ddi_BddarrayNum(cuts); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(cuts, i);
    bAigEdge_t fBaig = Ddi_BddToBaig(fAig);
    if (bAig_AuxAig0(bmgr,fBaig)!=bAig_NULL) {
      bAig_RecursiveDeref(bmgr,bAig_AuxAig0(bmgr,fBaig));
    }
  }

  bAigArrayFree(visitedNodes);

  return(newFa);
}


/**Function********************************************************************
  Synopsis    [Operate constrain w.r.t. AIG node]
  Description [Operate constrain w.r.t. AIG node.
Accumulated version.
Constrain is assumed and internally propagated as a constant
(0 if phase 0, 1 otherwise.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigConstrain (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *constrain,
  int phase
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *newf;
  if (Ddi_BddIsPartConj(f)) {
    Ddi_Bddarray_t *fA = Ddi_BddarrayMakeFromBddPart(f);
    Ddi_AigarrayConstrainAcc (fA,constrain,phase);
    newf = Ddi_BddMakePartConjFromArray(fA);
    Ddi_Free(fA);
  }
  else {
    Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,1);
    Ddi_BddarrayWrite(fA,0,f);
    Ddi_AigarrayConstrainAcc (fA,constrain,phase);
    newf = Ddi_BddarrayExtract(fA,0);
  }
  return newf;
}

/**Function********************************************************************
  Synopsis    [Operate constrain w.r.t. AIG node]
  Description [Operate constrain w.r.t. AIG node.
Accumulated version.
Constrain is assumed and internally propagated as a constant
(0 if phase 0, 1 otherwise.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigConstrainAcc (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *constrain,
  int phase
)
{
  Ddi_Bdd_t *newf = Ddi_AigConstrain(f,constrain,phase);
  Ddi_DataCopy(f,newf);
  Ddi_Free(newf);
  return f;
}

/**Function********************************************************************
  Synopsis    [Operate constrain w.r.t. AIG node]
  Description [Operate constrain w.r.t. AIG node.
Accumulated version.
Constrain is assumed and internally propagated as a constant
(0 if phase 0, 1 otherwise.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayConstrainAcc (
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *constrain,
  int phase
)
{
  Ddi_Bddarray_t *newfA = Ddi_AigarrayConstrain(fA,constrain,phase);
  Ddi_DataCopy(fA,newfA);
  Ddi_Free(newfA);
  return fA;
}


/**Function********************************************************************
  Synopsis    [Operate constrain w.r.t. AIG node]
  Description [Operate constrain w.r.t. AIG node.
Accumulated version.
Constrain is assumed and internally propagated as a constant
(0 if phase 0, 1 otherwise.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayConstrain (
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *constrain,
  int phase
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes, *shareNodes;
  bAigEdge_t varIndex, varAuxIndex, fBaig, f;
  int i, n, nshared=0;
  Ddi_Bddarray_t *newFa;
  int  useAigMonotoneVars = 0;
  char name[10000];
  Ddi_Bdd_t *myConstr = Ddi_BddDup(constrain);

  if (!Ddi_BddIsPartConj(myConstr)) {
    Ddi_BddSetPartConj(myConstr);
  }

  n = Ddi_BddarrayNum(fA);

  visitedNodes = bAigArrayAlloc();

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    if (!Ddi_BddIsConstant(fAig)) {
      fBaig = Ddi_BddToBaig(fAig);
      postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  for (i=0; i<visitedNodes->num; i++) {
    fBaig = visitedNodes->nodes[i];
    nodeAuxChar(bmgr,fBaig) = 0;
  }
  for (i=0; i<Ddi_BddPartNum(myConstr); i++) {
    Ddi_Bdd_t *c_i = Ddi_BddPartRead(myConstr,i);
    int isNeg = Ddi_BddIsComplement(c_i);
    fBaig = Ddi_BddToBaig(c_i);
    // complement depending on phase
    if (!phase) isNeg = !isNeg;
    nodeAuxChar(bmgr,fBaig) = isNeg ? -1 : 1;
  }

  newAigEvalIntern(ddm,visitedNodes);
  newFa = Ddi_BddarrayAlloc(ddm,n);

  for (i=0; i<Ddi_BddPartNum(myConstr); i++) {
    Ddi_Bdd_t *c_i = Ddi_BddPartRead(myConstr,i);
    fBaig = Ddi_BddToBaig(c_i);
    nodeAuxChar(bmgr,fBaig) = 0;
  }

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fA, i);
    Ddi_Bdd_t *fAig0;
    fBaig = Ddi_BddToBaig(fAig);
    if (Ddi_BddIsConstant(fAig)) {
      f = bAig_Zero;
    }
    else {
      f = bAig_AuxAig0(bmgr,fBaig);
    }
    Pdtutil_Assert(f!=bAig_NULL,"NULL baig");
    if (bAig_NodeIsInverted(fBaig)) {
      f = bAig_Not(f);
    }
    fAig0 = Ddi_BddMakeFromBaig(ddm,f);
    Ddi_BddarrayWrite(newFa,i,fAig0);
    Ddi_Free(fAig0);
  }

  bAigArrayClearFreeAuxAig(bmgr,visitedNodes);


  bAigArrayFree(visitedNodes);

  Ddi_Free(myConstr);

  return(newFa);
}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigArrayFindEquiv (
  Ddi_Bddarray_t *fAigarray,
  Ddi_Bdd_t *care,
  int maxObserve,
  int filterVars,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigarray);
  long elapsedTime=0;

  Ddi_Bdd_t *miters = Ddi_BddMakePartConjVoid(ddm);

  AigArrayRedRemovalIncrByEqClasses(fAigarray, care, miters,
				    maxObserve, filterVars, 0, timeLimit);

  return miters;
}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigFindEquiv (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *care,
  int maxObserve,
  int filterVars,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  long elapsedTime=0;

  Ddi_Bdd_t *miters = Ddi_BddMakePartConjVoid(ddm);

  AigRedRemovalIncrByEqClasses(fAig, care, miters,
                               maxObserve, filterVars, timeLimit);

  return miters;
}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
DdiAigArrayRedRemovalControlAcc (
  Ddi_Bddarray_t *fAigarray,
  Ddi_Bdd_t *care,
  int maxObserve,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigarray);
  int ibr = Ddi_MgrReadAigSatIncrByRefinement(ddm);
  long elapsedTime=0;
  int onlyOuts=2;

  if (1||!onlyOuts) {
    /* check constants only */
    Ddi_MgrSetAigSatIncrByRefinement(ddm, 2);
    elapsedTime = util_cpu_time();
    AigArrayRedRemovalIncrByEqClasses(fAigarray, care, NULL,
                                      maxObserve, 0, 0, timeLimit);
    //    AigArrayRedRemovalIncrByControlClasses(fAigarray, care, 0, timeLimit);
    elapsedTime = util_cpu_time() - elapsedTime;
  }
  if (1&&(timeLimit<0 || elapsedTime<timeLimit*1000)) {
    /* check constants and equivalences */
    Ddi_MgrSetAigSatIncrByRefinement(ddm, 3);
    AigArrayRedRemovalIncrByControlClasses(fAigarray, care, onlyOuts,
					   timeLimit-elapsedTime/1000.0);
  }
  Ddi_MgrSetAigSatIncrByRefinement(ddm,ibr);
  return fAigarray;
}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigRedRemovalControlAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *care,
  int maxObserve,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,1);

  Ddi_BddarrayWrite(fA,0,fAig);


  DdiAigArrayRedRemovalControlAcc (fA,care,maxObserve,timeLimit);

  Ddi_DataCopy(fAig,Ddi_BddarrayRead(fA,0));

  Ddi_Free(fA);

  return fAig;
}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
DdiAigArrayRedRemovalAcc (
  Ddi_Bddarray_t *fAigarray,
  Ddi_Bdd_t *care,
  int maxObserve,
  float timeLimit
)
{
  int j, nVars;
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig, *cof0Aig, *cof1Aig;
  bAig_array_t *visitedNodes;
  bAigEdge_t fBaig, careBaig, cof1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigarray);
  int nChecks, nChecks2, nRed, nRed2;
  int extRef = Ddi_MgrReadExtRef(ddm);
  int i, val, size1, size0 = Ddi_BddarraySize(fAigarray);
  Ddi_AigSignatureArray_t *varSigs, *fSig, *fSig1;
  Ddi_AigSignature_t careSig;
  int doMultipleChecks = 0;
  int enaPhase1 = 1;
  int enaPhase2 = 1;
  int enEqCheck = 1;
  float optFactor = 10.0;
  int checkResult = 0;
  int redRem=Ddi_MgrReadAigRedRemLevel(ddm);
  bAig_array_t *cachedNodes = bAigArrayAlloc();
  int nRuns=2;

  if (redRem==1) {
    if (++ddm->settings.aig.redRemCnt >= ddm->settings.aig.redRemMaxCnt) {
      ddm->settings.aig.redRemCnt = 0;
    }
    else {
      redRem = 0;
    }
  }
  else if (redRem > 2) {
    optFactor = 1;
  }

  bmgr = ddm->aig.mgr;


  do {
    int size2 = -1;
    size1 = Ddi_BddarraySize(fAigarray);
    if (size1<1000) {
  	optFactor = 1.0;
    }
    if (size1 > 500 && Ddi_MgrReadAigAbcOptLevel(ddm)>0) {
      //      ddiAbcOptAcc (fAigarray,1.0);
      size2 = Ddi_BddarraySize(fAigarray);
    }
    if (redRem && (1||size2 < 0 || size2 > (0.9*size1))) {
  	if (nRuns > 0) {
  	  int mySize = Ddi_BddarraySize(fAigarray);
  	  nRuns--;
    	  if (mySize>0) {
            AigArrayRedRemovalIncrementalAcc (fAigarray,care,
	      (int)(mySize/optFactor),maxObserve,cachedNodes,timeLimit,0);
  	    mySize = Ddi_BddarraySize(fAigarray);
	  }
    	  if (mySize>0) {
            AigArrayRedRemovalIncrementalAcc (fAigarray,care,
	      (int)(mySize/optFactor),maxObserve,cachedNodes,timeLimit,1);
	  }

  	  if (Ddi_BddarraySize(fAigarray)<mySize*0.99) {
    	    if (Ddi_BddarraySize(fAigarray)>0) {
    	      nRuns=2; /* reset runs */
	    }
  	  }
  	}
    }
    if (Ddi_BddarraySize(fAigarray) > 0.95 * size1 && optFactor > 1) {
      optFactor *= 0.5;
    }

  } while (Ddi_BddarraySize(fAigarray) < 0.99 * size1 && optFactor > 0);
  for (i=0; i<cachedNodes->num; i++) {
    bAigEdge_t baig = cachedNodes->nodes[i];
    bAig_CacheAig(bmgr,baig) = bAig_NULL;
    bAig_RecursiveDeref(bmgr,baig);
  }
  bAigArrayFree(cachedNodes);

  return (fAigarray);

}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigRedRemovalOdcAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *care,
  int maxWindow,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  int j, nVars, nAigVars;
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  long startTimeTot = util_cpu_time();
  unsigned long time_limit = ~0;
  int size0 = Ddi_BddSize(fAig);
  Ddi_Bdd_t *red, *myCare = Ddi_BddDup(care);
  Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,1);

  Ddi_BddarrayWrite(fA,0,fAig);


  red = Ddi_AigConstRed (fA, myCare, NULL, NULL,
           1 /* doRedRem */, maxWindow, 0, 0, NULL, timeLimit);

  if (red!=NULL) {
    Ddi_BddSetAig(red);
    Ddi_BddAndAcc(red,Ddi_BddarrayRead(fA,0));
    // Pdtutil_Assert(Ddi_AigEqualSat(red,fAig),"wrong red rem");

    Ddi_DataCopy(fAig,red);
    Ddi_AigStructRedRemAcc (fAig,NULL);
    Ddi_Free(red);
  }

  Ddi_Free(fA);
  Ddi_Free(myCare);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"RedRemOdc %d -> %d\n", size0, Ddi_BddSize(fAig)); 
    fflush(dMgrO(ddm));
  }

  return fAig;

}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigRedRemovalAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *care,
  int maxObserve,
  float timeLimit
)
{
  return DdiAigRedRemovalNnfAcc (fAig,care,maxObserve,timeLimit,1);
}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigRedRemovalNnfAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *care,
  int maxObserve,
  float timeLimit,
  int doNnfEncoding
)
{
  int j, nVars, nAigVars;
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig, *cof0Aig, *cof1Aig;
  bAig_array_t *visitedNodes;
  bAigEdge_t fBaig, careBaig, cof1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  int nChecks, nChecks2, nRed, nRed2;
  int extRef = Ddi_MgrReadExtRef(ddm);
  int i, val, size1, size0 = Ddi_BddSize(fAig);
  Ddi_AigSignatureArray_t *varSigs, *fSig, *fSig1;
  Ddi_AigSignature_t careSig;
  int doMultipleChecks = 0;
  int enaPhase1 = 1;
  int enaPhase2 = 1;
  int enEqCheck = 1;
  float optFactor = 5.0;
  int checkResult = 0;
  int redRem=Ddi_MgrReadAigRedRemLevel(ddm);
  int useObserveDC = 1;
  int maxSize = 1000000;
  long startTimeTot = util_cpu_time();
  unsigned long time_limit = ~0;
  int newByEqClassesAndControl = 0 && care!=NULL && !Ddi_BddIsOne(care);

  if (newByEqClassesAndControl) {
    if (!doNnfEncoding) {
      Ddi_Bdd_t *red, *res;
      Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,1);
      Ddi_BddarrayWrite(fA,0,fAig);

      red = Ddi_AigConstRed (fA, care, NULL, NULL,
	  1 /* doRedRem */, maxObserve, 0, 0, NULL, timeLimit);
      if (red!=NULL) {
	Ddi_Free(red);
	res = Ddi_BddarrayRead(fA,0);
	if (Ddi_BddSize(res)<Ddi_BddSize(fAig)) {
	  long endTime = util_cpu_time();
	  printf("NNF CONST RED: %d -> %d (time: %s)\n", Ddi_BddSize(fAig), 
		 Ddi_BddSize(res), util_print_time(endTime-startTimeTot));
	  Ddi_DataCopy(fAig,res);
	}
      }
      Ddi_Free(fA);
      return fAig;
    }
    else {
      Ddi_Bdd_t *red, *myCare = Ddi_BddDup(care);
      Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,1);

      Ddi_Bddarray_t *rLits;
      Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
      Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
      Ddi_Vararray_t *aV0 = Ddi_VararrayAlloc(ddm,0);
      Ddi_Vararray_t *aV1 = Ddi_VararrayAlloc(ddm,0);
      Ddi_Bdd_t *fNnf;

      fNnf = Ddi_AigNnf (fAig,NULL,constr,rV,aV0,aV1);
      Ddi_BddSetAig(constr);
      Ddi_BddAndAcc(myCare,constr);

      Ddi_BddarrayWrite(fA,0,fNnf);
      //    maxObserve = Ddi_BddSize(fNnf);
      red = Ddi_AigConstRed (fA, myCare, NULL, NULL,
                             maxObserve>0?1:1 /* doRedRem */, 
			     maxObserve, 0, 0, NULL, timeLimit);
      Ddi_Free(fNnf);
      if (red!=NULL) {
	Ddi_Free(red);
	fNnf = Ddi_BddarrayRead(fA,0);
	rLits = Ddi_BddarrayMakeLiteralsAig(rV, 0);
	Ddi_BddComposeAcc(fNnf,aV0,rLits);
	Ddi_Free(rLits);
	rLits = Ddi_BddarrayMakeLiteralsAig(rV, 1);
	Ddi_BddComposeAcc(fNnf,aV1,rLits);
	Ddi_Free(rLits);
	if (Ddi_BddSize(fNnf)<Ddi_BddSize(fAig)) {
	  long endTime = util_cpu_time();
	  printf("NNF CONST RED: %d -> %d (time: %s)\n", Ddi_BddSize(fAig), 
		 Ddi_BddSize(fNnf), util_print_time(endTime-startTimeTot));
	  Ddi_DataCopy(fAig,fNnf);
	}
      }
      Ddi_Free(rV);
      Ddi_Free(aV0);
      Ddi_Free(aV1);
      Ddi_Free(constr);
    
      Ddi_Free(fA);
      Ddi_Free(myCare);
      return fAig;
    }
  }

  if (Ddi_BddIsPartConj(fAig)) {
    int i;
    for (i=0; i<Ddi_BddPartNum(fAig); i++) {
      DdiAigRedRemovalAcc (Ddi_BddPartRead(fAig,i),care,maxObserve,timeLimit);
    }
    return(fAig);
  }

  //ddm->settings.aig.satIncrByRefinement = 3;
  timeLimit = 10.0;
  if (timeLimit > 0) {
    time_limit = util_cpu_time() + (int)timeLimit*1000;
  }

  if (0)
  {
    Ddi_Bddarray_t *atpgArray = Ddi_BddarrayAlloc(ddm,1);
    Ddi_BddarrayWrite(atpgArray,0,fAig);

    Ddi_AigarrayNetStore(atpgArray,
      (char *)"atpgVerilog.v",NULL,Pdtutil_Aig2Verilog_c);

    Ddi_Free(atpgArray);
  }


  if (redRem==1) {
    if (++ddm->settings.aig.redRemCnt >= ddm->settings.aig.redRemMaxCnt) {
      ddm->settings.aig.redRemCnt = 0;
    }
    else {
      redRem = 0;
    }
  }

  bmgr = ddm->aig.mgr;

  if (1) {
    int nRuns=2;
    Ddi_Bdd_t *fDup = Ddi_BddDup(fAig);

    do {
      int size2 = -1;
      bAig_array_t *cachedNodes = bAigArrayAlloc();
      size1 = Ddi_BddSize(fAig);
      if (size1<800) {
	optFactor = 2.0;
      }
      if (size1<500) {
	optFactor = 1.0;
      }
      if (size1 > 500 && Ddi_MgrReadAigAbcOptLevel(ddm)>0) {
	int enOpt=1;
	if (size1 > 20000) {
	  Ddi_Varset_t *supp = Ddi_BddSupp(fAig);
	  enOpt = Ddi_VarsetNum(supp) < 200;
	  Ddi_Free(supp);
	}
	if (enOpt)
        ddiAbcOptAcc (fAig,timeLimit/2);
	size2 = Ddi_BddSize(fAig);
      }
      if (redRem>0 && ((size2 < 0 && size1 < maxSize)
		     || ((size2 > (0.9*size1)) && size2 < maxSize))) {
	int mySize = Ddi_BddSize(fAig);
	if (nRuns > 0 || mySize>30000) {
	  int doApprOnAbort=0;
	  Ddi_Bdd_t *saveAig=NULL;
	  nRuns--;
          int maxCut;
	  if (mySize>10000) {
	    optFactor = mySize/3000;
	    useObserveDC = 0;
	  }
	  maxCut = (int)(mySize/optFactor);
	  //	  maxObserve = (int)(maxCut*3);
	  if (redRem>3) {
	    doApprOnAbort=1;
	    saveAig = Ddi_BddDup(fAig);
	  }

	  //          DdiAigCheckRedFull(fAig,care);
	  if (0 && mySize>=5000) {
	    AigRedRemovalIncrByControlClasses(fAig, care, timeLimit);
	  }
	  mySize = Ddi_BddSize(fAig);
	  if (0&& mySize<1000000 && util_cpu_time()<time_limit) {
	    int incrByRef = ddm->settings.aig.satIncrByRefinement;
	    if (0&&incrByRef>=1) {
	      ddm->settings.aig.satIncrByRefinement=1;
	    }
	    if (timeLimit>0) {
	      timeLimit = (time_limit-util_cpu_time())/1000.0;
	    }
	    if (ddm->settings.aig.satIncrByRefinement==1) {
              AigRedRemovalIncrementalAcc (fAig,care,maxCut,maxObserve,
	        cachedNodes,timeLimit,doApprOnAbort,useObserveDC,0);
	    }
	    ddm->settings.aig.satIncrByRefinement=2;
            AigRedRemovalIncrementalAcc (fAig,care,maxCut,maxObserve,
	      cachedNodes,timeLimit,doApprOnAbort,useObserveDC,1);
	    ddm->settings.aig.satIncrByRefinement=incrByRef;
	  }
	  if (doApprOnAbort) {
	    Ddi_Bdd_t *f0 = Ddi_BddDup(saveAig);
	    Ddi_Bdd_t *f1 = Ddi_BddDup(saveAig);
	    Ddi_Bdd_t *c0 = Ddi_BddNot(fAig);
	    Ddi_Bdd_t *c1 = Ddi_BddDup(fAig);
	    if (care != NULL) {
	      Ddi_BddAndAcc(c0,care);
	      Ddi_BddAndAcc(c1,care);
	    }
            for (i=0; i<cachedNodes->num; i++) {
              bAigEdge_t baig = cachedNodes->nodes[i];
              bAig_CacheAig(bmgr,baig) = bAig_NULL;
              bAig_RecursiveDeref(bmgr,baig);
            }
            AigRedRemovalIncrementalAcc (f0,c0,
	      maxCut,maxObserve,cachedNodes,timeLimit,0,1,0);
            for (i=0; i<cachedNodes->num; i++) {
              bAigEdge_t baig = cachedNodes->nodes[i];
              bAig_CacheAig(bmgr,baig) = bAig_NULL;
              bAig_RecursiveDeref(bmgr,baig);
            }
            AigRedRemovalIncrementalAcc (f1,c1,
	      maxCut,maxObserve,cachedNodes,timeLimit,0,1,0);
            for (i=0; i<cachedNodes->num; i++) {
              bAigEdge_t baig = cachedNodes->nodes[i];
              bAig_CacheAig(bmgr,baig) = bAig_NULL;
              bAig_RecursiveDeref(bmgr,baig);
            }
	    Ddi_BddDiffAcc(f0,saveAig);
	    Ddi_BddAndAcc(f1,saveAig);
	    Ddi_BddOrAcc(f0,f1);
            AigRedRemovalIncrementalAcc (f0,care,
	      maxCut,maxObserve,cachedNodes,timeLimit,0,1,0);
            for (i=0; i<cachedNodes->num; i++) {
              bAigEdge_t baig = cachedNodes->nodes[i];
              bAig_CacheAig(bmgr,baig) = bAig_NULL;
              bAig_RecursiveDeref(bmgr,baig);
            }
	    Ddi_Free(c0);
	    Ddi_Free(c1);
	    Ddi_Free(f1);
	    if (Ddi_BddSize(f0) < Ddi_BddSize(saveAig)) {
              DdiGenericDataCopy((Ddi_Generic_t *)saveAig,(Ddi_Generic_t *)f0);
	    }
	    Ddi_Free(f0);
            DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)saveAig);
	    Ddi_Free(saveAig);
	  }
   	  if (Ddi_BddSize(fAig)<mySize*0.95) {
	    nRuns=2; /* reset runs */
	  }
          if (timeLimit >= 0 &&
            ((util_cpu_time () - startTimeTot)/1000.0 > 2*timeLimit)) {
            optFactor = 0;
          }
	}
      }
      for (i=0; i<cachedNodes->num; i++) {
        bAigEdge_t baig = cachedNodes->nodes[i];
        bAig_CacheAig(bmgr,baig) = bAig_NULL;
        bAig_RecursiveDeref(bmgr,baig);
      }
      bAigArrayFree(cachedNodes);
      if (Ddi_BddSize(fAig) < 0.95 * size1 && optFactor > 1) {
        optFactor *= 0.5;
      }

    } while (Ddi_BddSize(fAig) < 0.95 * size1 && optFactor > 0);

    if (checkResult) {
      Ddi_BddXorAcc(fDup,fAig);
      if (care!=NULL) {
        Ddi_BddAndAcc(fDup,care);
        Pdtutil_Assert(!Ddi_AigSat(fDup),"Wrong RED REMOVAL ph 1");
      }
    }
    Ddi_Free(fDup);

    return (fAig);
  }

  /* try with incrByRef = 3 ? */
  if (0) {
    int nRuns=2;
    Ddi_Bdd_t *fDup = Ddi_BddDup(fAig);

    do {
      int size2 = -1;
      bAig_array_t *cachedNodes = bAigArrayAlloc();
      size1 = Ddi_BddSize(fAig);
      if (size1<800) {
	optFactor = 2.0;
      }
      if (size1<500) {
	optFactor = 1.0;
      }
      if (size1 > 500 && Ddi_MgrReadAigAbcOptLevel(ddm)>0) {
        ddiAbcOptAcc (fAig,timeLimit/2);
	size2 = Ddi_BddSize(fAig);
      }
      if (redRem>0 && ((size2 < 0 && size1 < maxSize)
		     || ((size2 > (0.9*size1)) && size2 < maxSize))) {
	int mySize = Ddi_BddSize(fAig);
	if (nRuns > 0 || mySize>30000) {
	  int doApprOnAbort=0;
	  Ddi_Bdd_t *saveAig=NULL;
	  nRuns--;
          int maxCut;
	  if (mySize>10000) {
	    optFactor = mySize/3000;
	    useObserveDC = 0;
	  }
	  maxCut = (int)(mySize/optFactor);
	  //	  maxObserve = (int)(maxCut*3);
	  if (redRem>3) {
	    doApprOnAbort=1;
	    saveAig = Ddi_BddDup(fAig);
	  }

	  //          DdiAigCheckRedFull(fAig,care);
	  if (0 && mySize>=5000) {
	    AigRedRemovalIncrByControlClasses(fAig, care, timeLimit);
	  }
	  mySize = Ddi_BddSize(fAig);
	  if (mySize<1000000 && util_cpu_time()<time_limit) {
	    int incrByRef = ddm->settings.aig.satIncrByRefinement;
	    if (0&&incrByRef>=1) {
	      ddm->settings.aig.satIncrByRefinement=1;
	    }
	    if (timeLimit>0) {
	      timeLimit = (time_limit-util_cpu_time())/1000.0;
	    }
	    if (ddm->settings.aig.satIncrByRefinement==1) {
              AigRedRemovalIncrementalAcc (fAig,care,maxCut,maxObserve,
	        cachedNodes,timeLimit,doApprOnAbort,useObserveDC,0);
	    }
	    ddm->settings.aig.satIncrByRefinement=3;
            AigRedRemovalIncrementalAcc (fAig,care,maxCut,maxObserve,
	      cachedNodes,timeLimit,doApprOnAbort,useObserveDC,1);
	    ddm->settings.aig.satIncrByRefinement=incrByRef;
	  }
	  if (doApprOnAbort) {
	    Ddi_Bdd_t *f0 = Ddi_BddDup(saveAig);
	    Ddi_Bdd_t *f1 = Ddi_BddDup(saveAig);
	    Ddi_Bdd_t *c0 = Ddi_BddNot(fAig);
	    Ddi_Bdd_t *c1 = Ddi_BddDup(fAig);
	    if (care != NULL) {
	      Ddi_BddAndAcc(c0,care);
	      Ddi_BddAndAcc(c1,care);
	    }
            for (i=0; i<cachedNodes->num; i++) {
              bAigEdge_t baig = cachedNodes->nodes[i];
              bAig_CacheAig(bmgr,baig) = bAig_NULL;
              bAig_RecursiveDeref(bmgr,baig);
            }
            AigRedRemovalIncrementalAcc (f0,c0,
	      maxCut,maxObserve,cachedNodes,timeLimit,0,1,0);
            for (i=0; i<cachedNodes->num; i++) {
              bAigEdge_t baig = cachedNodes->nodes[i];
              bAig_CacheAig(bmgr,baig) = bAig_NULL;
              bAig_RecursiveDeref(bmgr,baig);
            }
            AigRedRemovalIncrementalAcc (f1,c1,
	      maxCut,maxObserve,cachedNodes,timeLimit,0,1,0);
            for (i=0; i<cachedNodes->num; i++) {
              bAigEdge_t baig = cachedNodes->nodes[i];
              bAig_CacheAig(bmgr,baig) = bAig_NULL;
              bAig_RecursiveDeref(bmgr,baig);
            }
	    Ddi_BddDiffAcc(f0,saveAig);
	    Ddi_BddAndAcc(f1,saveAig);
	    Ddi_BddOrAcc(f0,f1);
            AigRedRemovalIncrementalAcc (f0,care,
	      maxCut,maxObserve,cachedNodes,timeLimit,0,1,0);
            for (i=0; i<cachedNodes->num; i++) {
              bAigEdge_t baig = cachedNodes->nodes[i];
              bAig_CacheAig(bmgr,baig) = bAig_NULL;
              bAig_RecursiveDeref(bmgr,baig);
            }
	    Ddi_Free(c0);
	    Ddi_Free(c1);
	    Ddi_Free(f1);
	    if (Ddi_BddSize(f0) < Ddi_BddSize(saveAig)) {
              DdiGenericDataCopy((Ddi_Generic_t *)saveAig,(Ddi_Generic_t *)f0);
	    }
	    Ddi_Free(f0);
            DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)saveAig);
	    Ddi_Free(saveAig);
	  }
   	  if (Ddi_BddSize(fAig)<mySize*0.95) {
	    nRuns=2; /* reset runs */
	  }
          if (timeLimit >= 0 &&
            ((util_cpu_time () - startTimeTot)/1000.0 > 2*timeLimit)) {
            optFactor = 0;
          }
	}
      }
      for (i=0; i<cachedNodes->num; i++) {
        bAigEdge_t baig = cachedNodes->nodes[i];
        bAig_CacheAig(bmgr,baig) = bAig_NULL;
        bAig_RecursiveDeref(bmgr,baig);
      }
      bAigArrayFree(cachedNodes);
      if (Ddi_BddSize(fAig) < 0.95 * size1 && optFactor > 1) {
        optFactor *= 0.5;
      }

    } while (Ddi_BddSize(fAig) < 0.99 * size1 && optFactor > 0);

    if (checkResult) {
      Ddi_BddXorAcc(fDup,fAig);
      if (care!=NULL) {
        Ddi_BddAndAcc(fDup,care);
        Pdtutil_Assert(!Ddi_AigSat(fDup),"Wrong RED REMOVAL ph 1");
      }
    }
    Ddi_Free(fDup);

    return (fAig);
  }



#if 1
  doMultipleChecks = 1;
#endif

  if (Ddi_BddSize(fAig) > 30000) return(fAig);

  enaPhase2 = 1&&(Ddi_BddSize(fAig) < 1000);

  /* the length of the two arrays must be the same */

  if (Ddi_BddIsConstant(fAig)) {
    return (fAig);
  }

  bmgr = ddm->aig.mgr;

  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }


  nVars = Ddi_MgrReadNumVars(ddm);
  nAigVars = Ddi_MgrReadNumAigVars(ddm);
  varSigs = DdiAigSignatureArrayAlloc(nVars+nAigVars);
  DdiSetSignaturesRandom(varSigs,nVars);
  /* compute care signature */
  if (care==NULL) {
    DdiSetSignatureConstant(&careSig,1);
    if (Ddi_BddSize(fAig) > 5000) {
      enaPhase2 = enEqCheck = 0;
    }
  }
  else {
    float coverRate;
    bAig_array_t *careNodes = bAigArrayAlloc();
    bAigEdge_t careBaig = Ddi_BddToBaig(care);
    Ddi_AigSignatureArray_t *auxSig;
    int i,cover = 0;
    unsigned int j;
    postOrderAigVisitIntern(ddm->aig.mgr,careBaig,careNodes,-1);
    postOrderAigClearVisitedIntern(ddm->aig.mgr,careNodes);
    auxSig = DdiAigEvalSignature(ddm,careNodes,bAig_NULL,0,varSigs);
    careSig = auxSig->sArray[careNodes->num-1];
    DdiAigSignatureArrayFree(auxSig);
    bAigArrayFree(careNodes);
    if (bAig_NodeIsInverted(careBaig)) {
      DdiComplementSignature(&careSig);
    }
    for (i=0;i<DDI_AIG_SIGNATURE_SLOTS;i++) {
      unsigned long mask = 1;
      for (j=0;j<sizeof(unsigned long)*8;j++) {
	if (careSig.s[i] & mask) {
  	  cover++;
	}
	mask = mask << 1;
      }
    }
    coverRate = ((float)cover)/
                (sizeof(unsigned long)*8*DDI_AIG_SIGNATURE_SLOTS);
    fprintf(dMgrO(ddm),"random sig in CARE %d/%d (%g)\n",cover,
      sizeof(unsigned long)*8*DDI_AIG_SIGNATURE_SLOTS,coverRate);
    if (coverRate < 0.30) {
      enaPhase2 = enEqCheck = 0;
    }
    if (Ddi_BddSize(fAig) > 10000) {
      enaPhase2 = enEqCheck = 0;
    }
  }

  fprintf(dMgrO(ddm),"RED REMOVAL: %d -> (%d) ", size0, Ddi_BddSize(fAig));
  fflush(dMgrO(ddm));

  fBaig = Ddi_BddToBaig(fAig);
  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  /* check redundant variables */

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxAig0(bmgr,baig) = bAig_Zero;
    bAig_AuxAig1(bmgr,baig) = bAig_NonInvertedEdge(baig);
    bAig_Ref(bmgr, baig);
  }

  nChecks = nChecks2 = nRed = nRed2 = 0;

  if (enaPhase1) {

  fSig = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs);

  if (!doMultipleChecks) {
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t val, baig = visitedNodes->nodes[i];
    Ddi_AigSignature_t sConst;
    int rem = 0;
    int phase = 0 && !bAig_NodeIsInverted(baig);
    bAigNodeComputeAuxVal(bmgr,baig,1);
    val = bAig_AuxAig1(bmgr,baig);
    if (bAig_NodeIsConstant(val)) {
      continue;
    }
    DdiSetSignatureConstant(&sConst,phase);
    if (DdiEqSignatures(&sConst,&fSig->sArray[i],&careSig)) {
      Ddi_Bdd_t *checkAig = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig1(bmgr,baig));
      if (care != NULL) {
	Ddi_BddAndAcc(checkAig,care);
      }
      rem = !Ddi_AigSat(checkAig);
      Ddi_Free(checkAig);
      nChecks++;
      if (rem) {
	nRed += rem;
        bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
        bAig_AuxAig1(bmgr,baig) = bAig_Zero;
        bAig_Ref(bmgr, bAig_Zero);
      }
    }
    DdiSetSignatureConstant(&sConst,!phase);
    if (!(rem == 1) &&
        (DdiEqSignatures(&sConst,&fSig->sArray[i],&careSig))) {
      Ddi_Bdd_t *checkAig = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig1(bmgr,baig));
      Ddi_BddNotAcc(checkAig);
      if (care != NULL) {
	Ddi_BddAndAcc(checkAig,care);
      }
      rem = !Ddi_AigSat(checkAig);
      Ddi_Free(checkAig);
      nChecks++;
      if (rem) {
	nRed += rem;
        bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
        bAig_AuxAig1(bmgr,baig) = bAig_One;
        bAig_Ref(bmgr, bAig_One);
      }
    }
  }

  }
  else {

    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t val, baig = visitedNodes->nodes[i];
      Ddi_AigSignature_t sConst;
      int phase = 0 && !bAig_NodeIsInverted(baig);
      val = bAig_AuxAig1(bmgr,baig);
      if (bAig_NodeIsConstant(val)) {
          continue;
      }
      DdiSetSignatureConstant(&sConst,phase);
      nodeAuxChar(bmgr,baig) = 1;
      if ((i < 1000) && DdiEqSignatures(&sConst,&fSig->sArray[i],&careSig)) {
        nodeAuxChar(bmgr,baig) = 0;
	nChecks2++;
      }
    }
    nRed2 += AigSatRedCheck(ddm,visitedNodes,careBaig,0);
    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t val, baig = visitedNodes->nodes[i];
      Ddi_AigSignature_t sConst;
      int phase = 1 && !bAig_NodeIsInverted(baig);
      val = bAig_AuxAig1(bmgr,baig);
      if (bAig_NodeIsConstant(val)) {
        continue;
      }
      DdiSetSignatureConstant(&sConst,phase);
      nodeAuxChar(bmgr,baig) = 1;
      if ((i < 1000) && DdiEqSignatures(&sConst,&fSig->sArray[i],&careSig)) {
        nodeAuxChar(bmgr,baig) = 0;
	nChecks2++;
      }
    }
    nRed2 += AigSatRedCheck(ddm,visitedNodes,careBaig,1);
    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      nodeAuxChar(bmgr,baig) = 0;
    }


  }

  DdiAigSignatureArrayFree(fSig);

  }

  /* intermediate result */
  cof1 = bAig_AuxAig1(bmgr,fBaig);
  if (bAig_NodeIsInverted(fBaig)) {
    cof1 = bAig_Not(cof1);
  }
  newfAig = Ddi_BddMakeFromBaig(ddm,cof1);
  fBaig = cof1;

  fprintf(dMgrO(ddm)," -> (%d) ", Ddi_BddSize(newfAig));
  fflush(dMgrO(ddm));

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = bAig_AuxAig1(bmgr,visitedNodes->nodes[i]);
    if (baig != bAig_NULL && !bAig_NodeIsConstant(baig)) {
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig));
    }
  }
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);
  bAigArrayFree(visitedNodes);

  if (enEqCheck && !Ddi_BddIsConstant(newfAig)) {

    int n;
    int **compareLitArray;

    visitedNodes = bAigArrayAlloc();
    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
    postOrderAigClearVisitedIntern(bmgr,visitedNodes);
    aigArrayClearAuxAigIntern(bmgr,visitedNodes);

    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      bAig_AuxAig0(bmgr,baig) = bAig_Zero;
      bAig_AuxAig1(bmgr,baig) = bAig_NonInvertedEdge(baig);
      bAig_Ref(bmgr, baig);
    }

    bAig_AuxAig1(bmgr,fBaig) = bAig_NonInvertedEdge(fBaig);

    n = visitedNodes->num;
    compareLitArray = Pdtutil_Alloc(int *, n);

    fSig = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs);

    for (i=0; i<visitedNodes->num; i++) {
      compareLitArray[i] = NULL;
    }
    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t val_i, val_j, baig_i = visitedNodes->nodes[i];
      //Ddi_AigSignature_t sConst;
      int size = 0, num = 0;
      //int phase = 0 && !bAig_NodeIsInverted(baig_i);
      val_i = bAig_AuxAig1(bmgr,baig_i);
      if (bAig_NodeIsConstant(val_i)) {
        continue;
      }
      for (j=0; j<i; j++) {
        bAigEdge_t baig_j = visitedNodes->nodes[j];
        val_j = bAig_AuxAig1(bmgr,baig_j);
        if (bAig_NodeIsConstant(val_j) || (val_i == val_j)) {
	  continue;
	}
        if (num < 10 &&
	    DdiEqSignatures(&fSig->sArray[i],&fSig->sArray[j],&careSig)) {
	  nChecks2++;
	  if (num > size-3) {
            if (size == 0) {
	      size = 4;
	      compareLitArray[i] = Pdtutil_Alloc(int,size);
	    }
	    else {
	      size *= 2;
	      compareLitArray[i] = Pdtutil_Realloc(int,
                compareLitArray[i],size);
	    }
    	  }
    	  compareLitArray[i][num++] = j;
    	  compareLitArray[i][num++] = 1;
	}
      }
      if (num>0) {
        compareLitArray[i][num] = -1;
      }
    }
    nRed2 += AigSatRedEqCheck(ddm,visitedNodes,careBaig,compareLitArray,1);
    for (i=0; i<visitedNodes->num; i++) {
      Pdtutil_Free(compareLitArray[i]);
    }
    Pdtutil_Free(compareLitArray);

    /* intermediate result */
    cof1 = bAig_AuxAig1(bmgr,fBaig);
    if (bAig_NodeIsInverted(fBaig)) {
      cof1 = bAig_Not(cof1);
    }
    Ddi_Free(newfAig);
    newfAig = Ddi_BddMakeFromBaig(ddm,cof1);
    fBaig = cof1;

    fprintf(dMgrO(ddm)," -> <%d> ", Ddi_BddSize(newfAig));
    fflush(dMgrO(ddm));

    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = bAig_AuxAig1(bmgr,visitedNodes->nodes[i]);
      if (baig != bAig_NULL && !bAig_NodeIsConstant(baig)) {
        bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig));
      }
    }
    aigArrayClearAuxAigIntern(bmgr,visitedNodes);
    bAigArrayFree(visitedNodes);

    if (0&&nRed2) {
      Ddi_Bdd_t *tmp = Ddi_BddXor(newfAig,fAig);
      Ddi_BddAndAcc(tmp,care);
      Pdtutil_Assert(!Ddi_AigSat(tmp),"Wrong RED REMOVAL ph 1");
      Ddi_Free(tmp);
    }

    DdiAigSignatureArrayFree(fSig);
  }

  if (!Ddi_BddIsConstant(newfAig)) {

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  bAig_AuxAig1(bmgr,fBaig) = bAig_NonInvertedEdge(fBaig);
  bAig_Ref(bmgr, fBaig);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxAig0(bmgr,baig) = bAig_Zero;
    bAig_AuxAig1(bmgr,baig) = bAig_NonInvertedEdge(baig);
    bAig_Ref(bmgr, baig);
  }

  if (enaPhase2) {

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxRef(bmgr,baig) = 0;

    if (!(bAig_NodeIsConstant(baig))) {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      bAig_AuxRef(bmgr,right)++;
      bAig_AuxRef(bmgr,left)++;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    int rem = 0, last = visitedNodes->num-1;

#if 1
    if (bAig_AuxRef(bmgr,baig) == 1) {
#else
    if (!bAig_isVarNode(bmgr,baig)) {
#endif
      continue;
    }
    if (bAig_NodeIsConstant(bAig_AuxAig1(bmgr,baig))) {
      continue;
    }

    fSig = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs);
    fSig1 = DdiAigEvalSignature(ddm,visitedNodes,baig,1,varSigs);

    rem = 0;
    if (0||DdiEqSignatures(&fSig1->sArray[last],&fSig->sArray[last],&careSig)) {
      int currSigBit = varSigs->currBit;
      rem = existOptMergeIntern(ddm,visitedNodes,
        i,-1/*mergedirection*/,1,0,careBaig,varSigs);
      if (currSigBit != varSigs->currBit) {
        DdiSetSignatureBit(&careSig,currSigBit,1);
      }
      if (rem >= 0) {
        nChecks++;
        nRed += rem;
	/*        fprintf(dMgrO(ddm),rem ? "-" : "="); fflush(dMgrO(ddm));*/
      }
    }
    DdiAigSignatureArrayFree(fSig);
    DdiAigSignatureArrayFree(fSig1);
    if (!(rem == 1)) {
      fSig = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs);
      fSig1 = DdiAigEvalSignature(ddm,visitedNodes,baig,0,varSigs);
      if (DdiEqSignatures(&fSig1->sArray[last],&fSig->sArray[last],&careSig)) {
        int currSigBit = varSigs->currBit;
        rem = existOptMergeIntern(ddm,visitedNodes,
          i,-1/*mergedirection*/,0,0,careBaig,varSigs);
        if (currSigBit != varSigs->currBit) {
          DdiSetSignatureBit(&careSig,currSigBit,1);
        }
        if (rem >= 0) {
          nChecks++;
 	  nRed += rem;
	  //          fprintf(dMgrO(ddm),rem ? "-" : "="); fflush(dMgrO(ddm));
        }
      }
      DdiAigSignatureArrayFree(fSig);
      DdiAigSignatureArrayFree(fSig1);
    }
    if (0&&rem == 1) {
      Ddi_Bdd_t *tmp;
      cof1 = bAig_AuxAig1(bmgr,fBaig);
      if (bAig_NodeIsInverted(fBaig)) {
        cof1 = bAig_Not(cof1);
      }
      tmp = Ddi_BddMakeFromBaig(ddm,cof1);
      Ddi_BddXorAcc(tmp,fAig);
      Ddi_BddAndAcc(tmp,care);
      Pdtutil_Assert(!Ddi_AigSat(tmp),"Wrong RED REMOVAL ph 1");
      Ddi_Free(tmp);
    }
    }

  }

  DdiAigSignatureArrayFree(varSigs);

#if 0
  /* recompute */

  for (i=0; i<visitedNodes->num; i++) {
    bAigNodeComputeAuxVal(bmgr,visitedNodes->nodes[i],1);
  }
#endif

  cof1 = bAig_AuxAig1(bmgr,fBaig);

  cof1Aig = Ddi_BddMakeFromBaig(ddm,cof1);

  Ddi_Free(newfAig);
  newfAig = Ddi_BddDup(cof1Aig);
  if (bAig_NodeIsInverted(fBaig)) {
    Ddi_BddNotAcc(newfAig);
  }

  existClearVisitedIntern(bmgr,fBaig);

  Ddi_Free(cof1Aig);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = bAig_AuxAig1(bmgr,visitedNodes->nodes[i]);
    if (baig != bAig_NULL) {
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig));
    }
  }
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);
  bAigArrayFree(visitedNodes);

  if (0&&!enaPhase2) {

  cof0Aig = Ddi_BddDup(newfAig);

  for (val=0; val<2; val++)
  {
    int k;
    Ddi_Varset_t *supp = Ddi_BddSupp(newfAig);
    Ddi_Vararray_t *vAtot = Ddi_VararrayMakeFromVarset(supp,1);

    Ddi_Vararray_t *vA = NULL;

    for (k=0; k<Ddi_VararrayNum(vAtot); k++) {
      Ddi_Var_t *v=Ddi_VararrayRead(vAtot,k);
      if (vA == NULL) {
        vA = Ddi_VararrayAlloc(ddm,0);
      }
      Ddi_VararrayInsertLast(vA,v);
      if (k==(Ddi_VararrayNum(vAtot)-1)) {
        Ddi_Bddarray_t *checks = Ddi_BddarrayAlloc(ddm,0);
        int *satArray;
        int *satArray2;
        int i;

        Ddi_Free(supp);
        for (i=0; i<Ddi_VararrayNum(vA); i++) {
          Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
          Ddi_Bdd_t *chk = Ddi_BddCofactor(newfAig,v,val);
          Ddi_BddXorAcc(chk,newfAig);
          Ddi_BddarrayWrite(checks,i,chk);
          Ddi_Free(chk);
        }
        fprintf(dMgrO(ddm),"[%d] ",Ddi_BddarraySize(checks)); fflush(dMgrO(ddm));
        satArray = Ddi_AigSatMultiple(checks,care);
        satArray2 = Ddi_AigSatMultipleMinisat(checks,care);
        for (i=0; i<Ddi_VararrayNum(vA); i++) {
	  Pdtutil_Assert(satArray[i]==satArray2[i],"Invalid minisat multiple res");
	}

        for (i=0; i<Ddi_VararrayNum(vA); i++) {
          Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
#if 0
          Ddi_Bdd_t *c = Ddi_BddDup(Ddi_BddarrayRead(checks,i));
          if (care != NULL) {
            Ddi_BddAndAcc(c,care);
          }
          Pdtutil_Assert(Ddi_AigSat(c)==satArray[i],"multiple SAT error");
          Ddi_Free(c);
#endif
          if (satArray[i]==0) {
            Ddi_BddCofactorAcc(newfAig,v,val);
          }
        }
        Ddi_Free(checks);
        Pdtutil_Free(satArray);
        Ddi_Free(vA);

        if (0)
        {
          Ddi_Bdd_t *c = Ddi_BddXor(cof0Aig,newfAig);
          if (care != NULL) {
            Ddi_BddAndAcc(c,care);
          }
          Pdtutil_Assert(!Ddi_AigSat(c),"multiple SAT opt error");
          Ddi_Free(c);
        }

      }
    }
    Ddi_Free(vAtot);
  }

  Ddi_Free(cof0Aig);

  }

  }


  if (ddm->settings.aig.bddCompare) {
    Ddi_Bdd_t *tmp = Ddi_BddMakeMono(fAig);
    Ddi_Bdd_t *tmp1 = Ddi_BddMakeMono(newfAig);
    Ddi_Bdd_t *c = Ddi_BddMakeMono(care);
    Ddi_BddAndAcc(tmp,c);
    Ddi_BddAndAcc(tmp1,c);
    Pdtutil_Assert(Ddi_BddEqual(tmp1,tmp),
        "Wrong result of AIG RED REM.");
    Ddi_Free(tmp);
    Ddi_Free(tmp1);
    Ddi_Free(c);
  }
  else if (1) {
    Ddi_Bdd_t *f1Bdd = Ddi_BddDup(newfAig);
    Ddi_BddXorAcc(f1Bdd,fAig);
    if (care!=NULL) {
      Ddi_BddAndAcc(f1Bdd,care);
    }
    Pdtutil_Assert(!Ddi_AigSat(f1Bdd),"Wrong RED REMOVAL");
    Ddi_Free(f1Bdd);
  }



  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);
  Ddi_Free(newfAig);
  Ddi_MgrCheckExtRef(ddm,extRef);

  fprintf(dMgrO(ddm)," %d (red/checks = (%d+%d)/(%d+%d))\n",
    Ddi_BddSize(fAig), nRed, nRed2, nChecks, nChecks2);

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int AigRedRemovalSelectHeur(
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  bAig_array_t *bfsNodes,
  int maxCutNum,
  int *nRef,
  int heur,         // 0..4 force heur, < 0 stateful
  int domMinOccurs, // dominator parameter
  int current,      // current heuristic
  int nOldSize,
  int nCurrSize,
  //int nFails,
  int nTotIter,
  int *enChk
)
{
  // enChk array,
  int rndCnt = 0;
  int nCuts = 0;
  int i, j;
  int divFactor = 1 << (nTotIter + 1);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  // [0] = RND, [1] = FO CNT, [2] = PI DIST., [3] = ALL, [4] = DOM
  int policyOrder[] = {4,0,2,1,3};

  if (heur >= 0) {
    current = heur;
  } else {
    switch (current) {
      case -1: /* fall-through */
        current = current + 1;
        break;
      case 0:
      case 1:
      case 2:
      case 3:
        if (((nOldSize - nCurrSize) < (nOldSize / divFactor))) {
          current = current + 1;
        }
        break;
      default:
        return -1;
    }
  }

  if (0 == policyOrder[current]) {
    //printf("%d - RND\n", policyOrder[0]);
    //srand(time(NULL));
    if (visitedNodes->num < 128) // all nodes
      rndCnt = visitedNodes->num;
    else if (visitedNodes->num >= 128 && visitedNodes->num < 1024) // max 33%
      rndCnt = visitedNodes->num / 3;
    else if (visitedNodes->num >= 2048 && visitedNodes->num < 16384) // max 10%
      rndCnt = visitedNodes->num / 10;
    else //(visitedNodes->num >= 16384)  // max 1%
      rndCnt = visitedNodes->num / 100;
  }/*  else if (current == policyOrder[1]) { */
/*       fprintf(dMgrO(ddm),"%d - FO CNT\n", policyOrder[1]); */
/*     } else if (current == policyOrder[2]) { */
/*       fprintf(dMgrO(ddm),"%d - PI DIST\n", policyOrder[2]); */
/*     } else if (current == policyOrder[3]) { */
/*       fprintf(dMgrO(ddm),"%d - ALL\n", policyOrder[3]); */
/*   } else if (current == policyOrder[4]) { */
/*       fprintf(dMgrO(ddm),"%d - DOM\n", policyOrder[4]); */
/*     } */

  if (0 == policyOrder[current] || 1 == policyOrder[current] ||
        2 == policyOrder[current] || 3 == policyOrder[current]) {

    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig;
      baig = visitedNodes->nodes[i];
      bAig_AuxInt(bmgr,baig) = i;
    }

    for (j=nCuts=0; j<bfsNodes->num; j++) {
      //  for (j=bfsNodes->num-1; j>=0; j--) {
      bAigEdge_t baig = bfsNodes->nodes[j];
      i = bAig_AuxInt(bmgr,baig);

      if (i<0 || i>=visitedNodes->num) {
	continue;
      }

      if (bAig_NodeIsConstant(baig)) {
	continue;
      }
      /*
      if (nCuts>maxCutNum) {
	continue;
      }
      */

      if (0 == policyOrder[current]){
	/* random heuristic  */
	if (rndCnt > 0){
	  if ((rand() % 100) > 49 ){
	    enChk[i] = 1;
	    rndCnt--;
	  }
	}
      }

      if (1 == policyOrder[current]){
	/* fanout > 1 heuristic */
	if (nRef[i] > 1)
	  enChk[i] = 1;
      }

      if (2 == policyOrder[current]){
	/* PI + PI dependencies heuristic */
	int ir, il;
	ir = bAig_NodeReadIndexOfRightChild(bmgr,baig);
	il = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
	if (bAig_isVarNode(bmgr,baig) || (bAig_isVarNode(bmgr,ir)&&(bAig_isVarNode(bmgr,il)))){
	  enChk[i] = 1;
	}
      }

      if (3 == policyOrder[current]) { // all nodes
	enChk[i] = 1;
      }
      nCuts++;
    }
  }

  if (4 == policyOrder[current]){
    // fanout free regions
    int *doms =(int *)malloc(visitedNodes->num*sizeof(int));
    int *occ =(int *)malloc(visitedNodes->num*sizeof(int));
    for(i=0;i<visitedNodes->num;i++){
      occ[i]=0;
      doms[i]=0;
    }

    dom_stats(bmgr, visitedNodes, doms, NULL, domMinOccurs);

    //printf("visitedNodes->num=%d\n", visitedNodes->num);

    for (i=0;i<visitedNodes->num;i++){
      //printf(" %d ",doms[i]);
      if (doms[i] >= 0 && doms[i] < visitedNodes->num)
	occ[doms[i]]++;
    }
    for (i=0;i<visitedNodes->num;i++){
      if (occ[i]>domMinOccurs){
	enChk[i]=1;
      }
    }
    free(occ);
    free(doms);
  }

  return current;
}





/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
AigRedRemovalIncrementalAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *care,
  int maxCutNum,
  int maxObserve,
  bAig_array_t *cachedNodes,
  float timeLimit,
  int doApproxOnAbort,
  int enableObservabilityDC,
  int redVal
)
{
#if 0
  Ddi_Mgr_t *ddm=Ddi_ReadMgr(fAig);
  Ddi_Bddarray_t *fAigArray;
  Ddi_Bdd_t *newfAig;
  unsigned long startTime, time_limit=~0;
  int k, incrByRef=ddm->settings.aig.satIncrByRefinement;

  startTime = util_cpu_time();
  if (timeLimit > 0) {
    time_limit = startTime + (int)timeLimit*1000.0;
  }
  for (k=2; k<3 && startTime<time_limit; k++) {
    if (0 && incrByRef > 1) {
      ddm->settings.aig.satIncrByRefinement = k;
    }
    fAigArray = Ddi_BddarrayAlloc(ddm, 1);
    Ddi_BddarrayWrite(fAigArray, 0, fAig);
    AigArrayRedRemovalIncrementalAcc(fAigArray, care, maxCutNum, maxObserve,
	cachedNodes, timeLimit>0 ? (time_limit-startTime)/1000.0 : -1, redVal);

    newfAig = Ddi_BddarrayExtract(fAigArray, 0);
    DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);
    Ddi_Free(newfAig);
    Ddi_Free(fAigArray);
    if (incrByRef <= 1) {
      break;
    }
    startTime = util_cpu_time();
  }
  ddm->settings.aig.satIncrByRefinement = incrByRef;
  return fAig;
#else
  int nVars;
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig;
  bAig_array_t *visitedNodes, *bfsNodes;
  bAigEdge_t fBaig, careBaig, cof1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  //int extRef = Ddi_MgrReadExtRef(ddm);
  int i, j, nCuts, partSizeTh = 200;
  int *partIndex;
  int *partSize;
  int bddCompare = 0;
  int *nRef;
  int nFo1=0, nFo2=0;
  int *enChk, *enChkHist;
  int cutBlockSize = /* maxCutNum */ -1 /* just one block */;
  redrem_stats rrStats = {0,0,0,0,0,0,0,0};
  int bfsOrder = 0;
  int incrByRefinement = ddm->settings.aig.satIncrByRefinement;
  int enRandSim = 0 && maxCutNum > 1000;
  Ddi_AigSignatureArray_t *varSigs=NULL;
  Ddi_AigSignatureArray_t *nodeSigs=NULL;
  int enMultipleSat=0;
  int enDominators = 0;

  static int myCnt = 0;
  myCnt++;

  if (Ddi_BddIsConstant(fAig)) {
    return (fAig);
  }

  //ddm->settings.aig.satIncrByRefinement = 3;
  //AigRedRemovalIncrByControlClasses(fAig, care, -1);
  //ddm->settings.aig.satIncrByRefinement = incrByRefinement;

  if (maxObserve >= 0 && maxCutNum >= maxObserve) {
    maxObserve = maxCutNum*6;
  }

  if (ddm->aig.auxLits == NULL) {
    ddm->aig.auxLits = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Lock(ddm->aig.auxLits);
  }
  if (ddm->aig.auxLits2 == NULL) {
    ddm->aig.auxLits2 = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Lock(ddm->aig.auxLits2);
  }

  bmgr = ddm->aig.mgr;

  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
    enMultipleSat = Ddi_BddSize(care) > 10;
  }

  nVars = Ddi_MgrReadNumVars(ddm);


  fprintf(dMgrO(ddm),"R/R(%d) -> ", Ddi_BddSize(fAig)); fflush(dMgrO(ddm));

  /* create manager ??? */

  fBaig = Ddi_BddToBaig(fAig);
  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);

  bfsNodes = bAigArrayAlloc();
  if (bfsOrder) {
    bfsAigVisitIntern(bmgr,fBaig,bfsNodes,-1);
  }
  else {
    postOrderAigVisitIntern(bmgr,fBaig,bfsNodes,-1);
  }
  postOrderAigClearVisitedIntern(bmgr,bfsNodes);

  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  if (enRandSim) {
    //    maxCutNum = visitedNodes->num;
    varSigs = DdiAigSignatureArrayAlloc(nVars);
    DdiSetSignaturesRandom(varSigs, nVars);
    if (care != NULL) {
      int num = DdiAigConstrainSignatures(NULL, care, varSigs, 5, NULL, 50);
      if (!num) {
        fprintf(dMgrO(ddm),"Signature constraining failed.\n");
      }
      else {
        fprintf(dMgrO(ddm),"Signature constraining: %d\n", num);
      }
    }
    nodeSigs = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs);
  }

  //  (void) bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,-1);

  partIndex = Pdtutil_Alloc(int,visitedNodes->num);
  partSize = Pdtutil_Alloc(int,visitedNodes->num);
  enChk = Pdtutil_Alloc(int,visitedNodes->num);
  enChkHist = Pdtutil_Alloc(int,visitedNodes->num);

  nRef = Pdtutil_Alloc(int,visitedNodes->num);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig, right, left;
    int ir, il;
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
    nRef[i] = 0;
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      nRef[ir]++; nRef[il]++;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    partSize[i] = 0;
    if (nRef[i] != 1) {
      partIndex[i] = i;
      partSize[i] = 1;
    }
    else {
      partIndex[i] = -1;
    }
    if (nRef[i] == 2) {
      nFo2++;
    }
  }
  for (i=visitedNodes->num-1; i>=0; i--) {
    bAigEdge_t baig, right, left;
    int ir, il;
    baig = visitedNodes->nodes[i];
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      Pdtutil_Assert(partIndex[i]>=0,"Invalid part index");
      if (nRef[ir] == 1) {
        partIndex[ir] = partIndex[i];
        partSize[partIndex[i]]++;
      }
      if (nRef[il] == 1) {
        partIndex[il] = partIndex[i];
        partSize[partIndex[i]]++;
      }
    }
  }
  /* merge */
  for (j=0; j<2; j++) {
  for (i=visitedNodes->num-1; i>=0; i--) {
    bAigEdge_t baig, right, left;
    int ir, il, partid;
    baig = visitedNodes->nodes[i];
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      Pdtutil_Assert(partIndex[i]>=0,"Invalid part index");
      partid = partIndex[i];
      if (partIndex[partid] != partid) {
	/* partition merged */
        if (nRef[ir] == 1) {
          partIndex[ir] = partIndex[i];
        }
        if (nRef[il] == 1) {
          partIndex[il] = partIndex[i];
        }
      }
      /* partition not merged - propagate merge */
      if (nRef[ir] != 1 && partIndex[ir] == ir &&
          partSize[ir]+partSize[partid] < partSizeTh) {
        partIndex[ir] = partid;
	partSize[partid] += partSize[ir];
      }
      if (nRef[il] != 1 && partIndex[il] == il &&
          partSize[il]+partSize[partid] < partSizeTh) {
        partIndex[il] = partid;
	partSize[partid] += partSize[il];
      }
    }
  }
  }

  for (i=0; i<visitedNodes->num; i++) {
    if (partIndex[i] == i) {
      nFo1++;
    }
  }

  fprintf(dMgrO(ddm),"(part(fo2):%d(%d)/%d)\n",nFo1,nFo2,visitedNodes->num);fflush(dMgrO(ddm));


  /*
	TODO
  */

  int current = -1, nOldSize = 0, nCurrSize = 0, nTotIter = 0;
  float myTimeLimit = 0.25;
  int divFactor, nFails = 0;
  int singleDone=0, *nodeClass;

  nodeClass = Pdtutil_Alloc(int,visitedNodes->num);
  for (i=0; i<visitedNodes->num;i++) {
    enChk[i] = 0;
    enChkHist[i] = -1;
    nodeClass[i] = 2;
  }

  do {
    do {
      current = AigRedRemovalSelectHeur(ddm,visitedNodes,bfsNodes,maxCutNum,nRef,-1,3,
		   current,nOldSize,nCurrSize,/*nFails,*/nTotIter,enChk);
      nCurrSize = 0;
      //int cnt = 0, cnt0 = 0;
      for (i=0; i<visitedNodes->num;i++) {
	// we enable it, otherwise nothing can be said
	//if (enChkHist[i] == -1) {
	//  cnt++;
	//}
	//if (enChk[i] == 1) {
	//  cnt0++;
	//}
	nodeClass[i] = (enChkHist[i]==-1 && enChk[i]) ? 6 : nodeClass[i];
	enChkHist[i] = (enChkHist[i]==-1 && enChk[i]) ? 1 : enChkHist[i];
	enChk[i] = (enChkHist[i] == 0) ? 0 : enChk[i];
	nCurrSize += enChk[i];
      }

      //printf("%d %d \n", cnt, cnt0);
      if (current == -1) {
	myTimeLimit = 2.0;
      } else {
	myTimeLimit *= 2.0;
      }
    } while (current == -1);
    nOldSize = nCurrSize;
    nCurrSize = 0;

    // red rem here!!!
    if (1 || incrByRefinement) {
      //      cntCalls++;

      bAig_array_t *fBaigs = bAigArrayAlloc();
      bAigArrayWriteLast(fBaigs, fBaig);

      AigRedRemovalIncrByRefinementIntern (ddm,visitedNodes,fBaigs,careBaig,
          maxCutNum,enChk,nRef,cachedNodes,&rrStats,nodeClass,
          myTimeLimit,-1,redVal, 0, &singleDone
      );
      //AigRedRemovalIncrByRefinementIntern (ddm,visitedNodes,fBaigs,careBaig,
      //    maxCutNum,-1/*maxObserve*/,enChk,nRef,cachedNodes,&rrStats,
      //    nodeClass,myTimeLimit,doApproxOnAbort,enableObservabilityDC,
      //    redVal, 0, &singleDone
      //);
      bAigArrayFree(fBaigs);
    }

    for (i=0; i<visitedNodes->num; i++) {
      enChkHist[i] = (enChkHist[i] == 1 && enChk[i] == 0) ? 0 : enChkHist[i];
      nCurrSize += enChk[i];
    }

    fprintf(dMgrO(ddm),"redrem (heur=%d) SAT filter %d -> %d\n", current, nOldSize, nCurrSize);

    nTotIter++;
    divFactor = 1 << (nTotIter + 1);

    if (nCurrSize == nOldSize) {
      nFails+=2;
    } else if ((nOldSize - nCurrSize) < (nOldSize / divFactor)) {
      nFails++;
    } else {
      nFails = 0;
    }
  } while (0 && nFails<3);

  /* multiple */
  bAig_array_t *fBaigs = bAigArrayAlloc();
  bAigArrayWriteLast(fBaigs, fBaig);

  AigRedRemovalIncrByRefinementIntern (ddm,visitedNodes,fBaigs,careBaig,
     maxCutNum,enChk,nRef,cachedNodes,&rrStats,nodeClass,
     timeLimit,-1,redVal, 1, &singleDone
  );
  //AigRedRemovalIncrByRefinementIntern (ddm,visitedNodes,fBaigs,careBaig,
  //   maxCutNum,-1/*maxObserve*/,enChk,nRef,cachedNodes,&rrStats,
  //   nodeClass,timeLimit,doApproxOnAbort,enableObservabilityDC,
  //   redVal, 1, &singleDone
  //);
  bAigArrayFree(fBaigs);
  Pdtutil_Free(nodeClass);

 /*
   TODO
 */

/* #if 0 */
/* #if 0 */
/*   for (i=nCuts=0; i<visitedNodes->num; i++) { */
/*     if (partIndex[i] == i) { */
/*       for (j=0; j<visitedNodes->num; j++) { */
/*         bAigEdge_t baig = visitedNodes->nodes[i]; */
/*         enChk[j] = 0; */
/*         if (bAig_NodeIsConstant(baig)) { */
/* 	  continue; */
/*         } */
/* 	if (nCuts>maxCutNum) { */
/* 	  continue; */
/* 	} */
/*         if (partIndex[j]==i){ */
/*           enChk[j] = 1; */
/*           nCuts++; */
/*         } */
/*       } */
/* #else */
/*   if (cutBlockSize<0) cutBlockSize = visitedNodes->num;  */
/*   for (i=nCuts=0; i<visitedNodes->num; i+=cutBlockSize) { */
/*     { */
/*       for (j=i; j<visitedNodes->num; j++) { */
/*         bAigEdge_t baig = visitedNodes->nodes[j]; */
/*         enChk[j] = 0; */
/*         if (bAig_NodeIsConstant(baig)) { */
/* 	  continue; */
/*         } */
/* 	if (nCuts>maxCutNum) { */
/* 	  continue; */
/* 	} */
/*         if (j<i+cutBlockSize){ */
/*           enChk[j] = 1; */
/*           nCuts++; */
/*         } */
/*       } */
/* #endif */
/*       AigRedRemovalIncrementalIntern ( */
/*         ddm,visitedNodes,fBaig,careBaig,maxCutNum,maxObserve,enChk,nRef, */
/*         cachedNodes,&rrStats,1 */
/*       ); */
/*       fprintf(dMgrO(ddm),"*"); fflush(dMgrO(ddm));  */
/*       if (nCuts>maxCutNum) { */
/*         break; */
/*       } */
/*     } */
/*   } */
/* #else */

/* #if 0 */
/*   for (j=bfsNodes->num/2; j>=0; j--) { */
/*     bAigEdge_t baig = bfsNodes->nodes[j]; */
/*     i = bAig_AuxInt(bmgr,baig); */
/*     enChk[i] = 0; */
/*     if (bAig_NodeIsConstant(baig)) { */
/*       continue; */
/*     } */
/*     if (nCuts>maxCutNum/2) { */
/*       continue; */
/*     } */
/*     enChk[i] = 1; */
/*     nCuts++; */
/*   } */
/* #endif */

/*   if (enDominators) { */
/*     int nDom = 0; */
/*     int *dominators = Pdtutil_Alloc(int,visitedNodes->num); */
/*     maxCutNum = bfsNodes->num; */
/*     dom_stats(ddm->aig.mgr, visitedNodes, dominators, 2); */

/*     for (j=0; j<visitedNodes->num; j++) { */
/*       enChk[j] = 0; */
/*     } */
/*     for (j=0; j<visitedNodes->num; j++) { */
/*       Pdtutil_Assert(dominators[j]<visitedNodes->num,"Wrong dominator"); */
/*       if (dominators[j]>=0) */
/* 	//        enChk[j] = 1; */
/*         enChk[dominators[j]] = 1; */
/*     } */
/*     for (j=0; j<visitedNodes->num; j++) { */
/*       if (enChk[j]) nDom++; */
/*     } */
/*     fprintf(dMgrO(ddm),"\ndominators enable %d/%d cuts\n", nDom, visitedNodes->num); */
/*     Pdtutil_Free(dominators); */
/*   } */
/*   else  */
/*   for (j=nCuts=0; j<bfsNodes->num; j++) { */
/*     //  for (j=bfsNodes->num-1; j>=0; j--) { */
/*     bAigEdge_t baig = bfsNodes->nodes[j]; */
/*     i = bAig_AuxInt(bmgr,baig); */
/*     enChk[i] = 0; */
/*     if (bAig_NodeIsConstant(baig)) { */
/*       continue; */
/*     } */
/*     if (nCuts>maxCutNum) { */
/*       continue; */
/*     } */
/*     enChk[i] = 1; */
/*     nCuts++; */
/*   } */

/*   if (varSigs != NULL) { */
/*     int j, nEn, pEn, t = DDI_AIG_SIGNATURE_BITS; */
/*     for (j=nEn=pEn=0; j<visitedNodes->num; j++) { */
/*       bAigEdge_t baig = visitedNodes->nodes[j]; */
/*       int cnt = CountSignatureBits(&(nodeSigs->sArray[j]),1); */
/*       float pct = 2*((float)(t/2-cnt))/t; */
/*       if (pct<0) pct = -pct; */
/*       pEn += enChk[j]; */
/*       enChk[j] &= pct > 0.6; */
/*       nEn += enChk[j]; */
/*     } */
/*     DdiAigSignatureArrayFree(nodeSigs); */
/*     fprintf(dMgrO(ddm),"\nsignatures enables %d/%d(%d) nodes\n", nEn, pEn,  */
/*       visitedNodes->num); */
/*   } */

/*   if (incrByRefinement) { */
/*     int newEn=0, newEn1=0; */
/*     int twoPhase = 1; */
/*     int tryAgain = enMultipleSat?5:3; */
/*     float myTimeLimit = tryAgain ? 2.0 : timeLimit; */
/*     bAig_array_t *fBaigs = bAigArrayAlloc(); */

/*     bAigArrayWriteLast(fBaigs,fBaig); */

/*     if (visitedNodes->num > 10000) { */
/*       myTimeLimit *= ((float)visitedNodes->num)/10000; */
/*     } */
/*     cntCalls++; */
/*     AigRedRemovalIncrByRefinementIntern ( */
/*       ddm,visitedNodes,fBaigs,careBaig,maxCutNum,-1/\*maxObserve*\/,enChk,nRef, */
/*       cachedNodes,&rrStats,twoPhase ? myTimeLimit : timeLimit, */
/*       doApproxOnAbort,enableObservabilityDC,redVal, twoPhase ? 0 : 2 */
/*     ); */
/*     if (twoPhase)  { */
/*       for (j=0; j<visitedNodes->num; j++) { */
/* 	newEn += enChk[j]; */
/*       } */
/*       fprintf(dMgrO(ddm),"redrem SAT filter %d -> %d\n", nCuts, newEn); */
/*       while (tryAgain>0) { */
/* 	myTimeLimit *= 2; */
/*         AigRedRemovalIncrByRefinementIntern ( */
/*           ddm,visitedNodes,fBaigs,careBaig,maxCutNum,-1/\*maxObserve*\/,enChk,nRef, */
/*           cachedNodes,&rrStats,myTimeLimit, */
/*           doApproxOnAbort,enableObservabilityDC,redVal, 0 */
/*         ); */
/*         for (j=0; j<visitedNodes->num; j++) { */
/*   	  newEn1 += enChk[j]; */
/*         } */
/*         fprintf(dMgrO(ddm),"redrem SAT filter %d -> %d\n", newEn, newEn1); */
/* 	if (newEn1-newEn == 0) tryAgain=0; */
/* 	newEn = newEn1; newEn1 = 0; */
/* 	tryAgain--; */
/*       } */
/*       if (1) */
/*       AigRedRemovalIncrByRefinementIntern ( */
/*         ddm,visitedNodes,fBaigs,careBaig,maxCutNum,-1/\*maxObserve*\/,enChk,nRef, */
/* 	cachedNodes,&rrStats,timeLimit,doApproxOnAbort,enableObservabilityDC, */
/* 	redVal, 1 */
/*       ); */
/*       else  */
/*         AigRedRemovalIncrementalIntern ( */
/*           ddm,visitedNodes,fBaig,careBaig,maxCutNum,maxObserve,enChk,nRef, */
/*           cachedNodes,&rrStats,timeLimit,doApproxOnAbort,enableObservabilityDC */
/*         ); */
/*     } */

/*     bAigArrayFree(fBaigs); */

/*   } */
/*   else  if (0){ */
/*     AigRedRemovalIncrementalIntern ( */
/*       ddm,visitedNodes,fBaig,careBaig,maxCutNum,maxObserve,enChk,nRef, */
/*       cachedNodes,&rrStats,timeLimit,doApproxOnAbort,enableObservabilityDC */
/*     ); */
/*   } */

/* #endif */

  /* recompute aig */

  fBaig = Ddi_BddToBaig(fAig);

  /* intermediate result */
  cof1 = bAig_AuxAig1(bmgr,fBaig);
  if (bAig_NodeIsInverted(fBaig)) {
    cof1 = bAig_Not(cof1);
  }
  newfAig = Ddi_BddMakeFromBaig(ddm,cof1);
  fprintf(dMgrO(ddm),"<%d>(chk/cach/red/abo:%d/%d/%d/%d)\n",
          Ddi_BddSize(newfAig),
          rrStats.nChecks, rrStats.nCached, rrStats.nRed, rrStats.nAbort);

  fprintf(dMgrO(ddm),"d:%ld-c:%ld,p:%ld,l:%ld\n",
	 rrStats.decisions,rrStats.conflicts,
	 rrStats.propagations,rrStats.learnts_literals);

  fflush(dMgrO(ddm));

  /* free temp nodes */

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1;
    bAigEdge_t baig = visitedNodes->nodes[i];

    baig1 = bAig_AuxAig1(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }

    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig;
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
    bAig_CacheAig(bmgr,baig) = bAig_NULL;
  }
  Pdtutil_Free(nRef);

  Pdtutil_Free(partIndex);
  Pdtutil_Free(partSize);
  Pdtutil_Free(enChk);

  DdiAigSignatureArrayFree(varSigs);
  bAigArrayFree(visitedNodes);

  if (bddCompare) {
    Ddi_Bdd_t *tmp = Ddi_BddMakeMono(fAig);
    Ddi_Bdd_t *tmp1 = Ddi_BddMakeMono(newfAig);
    Ddi_Bdd_t *c = Ddi_BddMakeMono(care);
    Ddi_BddAndAcc(tmp,c);
    Ddi_BddAndAcc(tmp1,c);
    Pdtutil_Assert(Ddi_BddEqual(tmp1,tmp),
        "Wrong result of AIG RED REM.");
    Ddi_Free(tmp);
    Ddi_Free(tmp1);
    Ddi_Free(c);
  }
  else if (1 || ddm->settings.aig.satCompare && !doApproxOnAbort) {
    Ddi_Bdd_t *f1Bdd = Ddi_BddDup(newfAig);
    Ddi_BddXorAcc(f1Bdd,fAig);
    if (care!=NULL) {
      Ddi_BddAndAcc(f1Bdd,care);
    }
    Pdtutil_Assert(!Ddi_AigSat(f1Bdd),"Wrong RED REMOVAL");
    Ddi_Free(f1Bdd);
  }

  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);
  Ddi_Free(newfAig);
  //  Ddi_MgrCheckExtRef(ddm,extRef);

  return(fAig);
#endif
}


/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
AigArrayRedRemovalIncrementalAcc (
  Ddi_Bddarray_t *fAigarray,
  Ddi_Bdd_t *care,
  int maxCuts,
  int maxObserve,
  bAig_array_t *cachedNodes,
  float timeLimit,
  int redVal
)
{
#if 1
  int *doms, *occ, *dist, *foc, *ham, *enChk, *enChkHist, *nodeClass, *classHist;
  int i, j, il, ir, dom, dcMax=0, focMax=0, pidMax=0, strategy=0, enable, cnt;
  int again, singleDone, nVars, nCuts, nSingle=0, nRoots=0, iterNum, iterLimit;
  int incrByRef, size, maxCutNum=200, minCutNum=80;
  bAig_array_t *dcNodes, *foNodes, *pcNodes, *psNodes, *testNodes;
  Ddi_AigSignatureArray_t *varSigs=NULL;
  Ddi_AigSignatureArray_t *nodeSigs=NULL;
  Ddi_Mgr_t *ddm=Ddi_ReadMgr(fAigarray);
  bAig_Manager_t *bmgr=ddm->aig.mgr;
  bAig_array_t *visitedNodes, *rootNodes;
  bAigEdge_t baig, left, right, fBaig, careBaig;
  Ddi_Bddarray_t *newArray;
  Ddi_Bdd_t *fAig, *fXor, *newfAig;
  redrem_stats rrStats = {0,0,0,0,0,0,0,0};
  float timeLimitSingle, timeLimitTotal=timeLimit;
  unsigned long startTime, endTime;
  char *heur;

  startTime = util_cpu_time();
  incrByRef = ddm->settings.aig.satIncrByRefinement;
  if (0&&incrByRef == 3) {
    maxCutNum = 100;
    minCutNum = 40;
  }
  if (ddm->aig.auxLits == NULL) {
    ddm->aig.auxLits = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Lock(ddm->aig.auxLits);
  }
  if (ddm->aig.auxLits2 == NULL) {
    ddm->aig.auxLits2 = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Lock(ddm->aig.auxLits2);
  }

  newArray = Ddi_BddarrayDup(fAigarray);
  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }

  visitedNodes = bAigArrayAlloc();
  rootNodes = bAigArrayAlloc();
  for (i=0; i<Ddi_BddarrayNum(newArray); i++) {
    fAig = Ddi_BddarrayRead(newArray, i);
    if (!Ddi_BddIsConstant(fAig)) {
      fBaig = Ddi_BddToBaig(fAig);
      bAigArrayWriteLast(rootNodes,fBaig);
      postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
      nRoots++;
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);
  size = visitedNodes->num;
  enChk = Pdtutil_Alloc(int,visitedNodes->num);
  foc = Pdtutil_Alloc(int,visitedNodes->num);
  if (incrByRef) {
    /* generate info for heuristic strategies */
    enChkHist = Pdtutil_Alloc(int,visitedNodes->num);
    nodeClass = Pdtutil_Alloc(int,visitedNodes->num);
    classHist = Pdtutil_Alloc(int,visitedNodes->num);
    doms = Pdtutil_Alloc(int,visitedNodes->num);
    occ = Pdtutil_Alloc(int,visitedNodes->num);
    dist = Pdtutil_Alloc(int,visitedNodes->num);
    ham = Pdtutil_Alloc(int,visitedNodes->num);
    for (i=0; i<visitedNodes->num;i++) {
      ham[i] = foc[i] = occ[i] = dist[i] = enChk[i] = enChkHist[i] = 0;
      nodeClass[i] = classHist[i] = 2;
      doms[i] = -1;
    }

    dom_stats(bmgr, visitedNodes, doms, occ, 0);

    nVars = Ddi_MgrReadNumVars(ddm);
    varSigs = DdiAigSignatureArrayAlloc(nVars);
    DdiSetSignaturesRandom(varSigs, nVars);
    if (care != NULL) {
      assert(DdiAigConstrainSignatures(NULL, care, varSigs, 5, NULL, 50));
    }
    nodeSigs = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs);
    for (i=0; i<visitedNodes->num; i++) {
      baig = visitedNodes->nodes[i];
      cnt = DdiCountSignatureBits(&nodeSigs->sArray[i], 1, -1);
      cnt = 2*(DDI_AIG_SIGNATURE_BITS/2-cnt);
      if (cnt<0) cnt = -cnt;
      ham[i] = cnt;
    }
    DdiAigSignatureArrayFree(nodeSigs);
    DdiAigSignatureArrayFree(varSigs);

    for (i=0; i<visitedNodes->num; i++) {
      baig = visitedNodes->nodes[i];
      bAig_AuxInt(bmgr, baig) = i;

      if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
	right = bAig_NodeReadIndexOfRightChild(bmgr, baig);
	left = bAig_NodeReadIndexOfLeftChild(bmgr, baig);
	ir = bAig_AuxInt(bmgr, right);
	il = bAig_AuxInt(bmgr, left);
	foc[il]++;
	foc[ir]++;
      }
    }

    for (i=0; i<visitedNodes->num; i++) {
      baig = visitedNodes->nodes[i];

      if (doms[i]>=0 && doms[i]<visitedNodes->num) {
	dom = visitedNodes->nodes[doms[i]];
	occ[bAig_AuxInt(bmgr, dom)] += occ[i];
      }
      if (occ[i] > dcMax) {
	dcMax = occ[i];
      }

      if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
	right = bAig_NodeReadIndexOfRightChild(bmgr, baig);
	left = bAig_NodeReadIndexOfLeftChild(bmgr, baig);
	ir = bAig_AuxInt(bmgr, right);
	il = bAig_AuxInt(bmgr, left);
	if (dist[il] < dist[ir]) {
	  dist[i] = dist[il]+1;
	} else {
	  dist[i] = dist[ir]+1;
	}
	if (dist[i] > pidMax) {
	  pidMax = dist[i];
	}
      }

      if (foc[i] > focMax) {
	focMax = foc[i];
      }
    }

    /* sort arrays */
    dcNodes = bAigArraySortByValue(visitedNodes, occ, dcMax, 1);
    foNodes = bAigArraySortByValue(visitedNodes, foc, focMax, 1);
    pcNodes = bAigArraySortByValue(visitedNodes, dist, pidMax, 0);
    psNodes = bAigArraySortByValue(visitedNodes, ham, DDI_AIG_SIGNATURE_BITS, 0);

    nSingle = nCuts = strategy = 0;
    timeLimitSingle = 0.25;
    again = 1;
    iterLimit = 3;
    do {
      nCuts = singleDone = 0;
      iterNum++;
      /* collect single candidates */
      do {
	switch (strategy) {
          case 0: testNodes = dcNodes; heur = "DOM"; break; /* dominators */
          case 1: testNodes = foNodes; heur = "FOC"; break; /* fan-out count */
          case 2: testNodes = pcNodes; heur = "PID"; break; /* pi-distance */
          case 3: testNodes = psNodes; heur = "PSD"; break; /* prob. sim. */
          case 4: testNodes = visitedNodes; heur = "RND"; break; /* random */
          case 5: testNodes = visitedNodes; heur = "ALL"; break; /* all ??? */
          default: again = 0;
	}
	if (!again) break;
	for (i=0; i<testNodes->num && nCuts<maxCutNum; i++) {
	  baig = testNodes->nodes[i];
	  j = bAig_AuxInt(bmgr, baig);
	  assert(j>=0);
	  if (enChkHist[j]) continue;
	  switch (strategy) {
            case 0: enable = occ[j]>20; break;//visitedNodes->num/20; break; /* dominators */
            case 1: enable = foc[j]>2; break; /* fan-out count */
            case 2: enable = dist[j]<3; break; /* pi-distance */
	    case 3: enable = ham[j]>0.6*DDI_AIG_SIGNATURE_BITS; break; /* prob. sim. */
            default: enable = 1;
	  }
	  if (!enable) {
	    strategy++;
	    break;
	  }
	  enChk[j] = 1;
	  enChkHist[j] = 2;
	  nodeClass[j] = 6;
	  nCuts++;
	}
	if (i == visitedNodes->num) {
	  again = 0;
	  break;
	}
      } while (nCuts<maxCutNum);

      /* run in single mode */
      if (nCuts) {
	printf("R/R %s(heur=%s,%d) ", nRoots>1 ? "array ": "", heur, incrByRef);
	AigRedRemovalIncrByRefinementIntern(ddm,visitedNodes,rootNodes,careBaig,
          maxCutNum,enChk,NULL,cachedNodes,&rrStats,nodeClass,timeLimitSingle,
          timeLimitTotal,redVal,0,&singleDone
        );
      }
      if (timeLimit > 0) {
	endTime = util_cpu_time();
	timeLimitTotal -= (endTime-startTime)/1000.0;
	startTime = endTime;
      }
      if (singleDone) {
	for (i=0; i<visitedNodes->num; i++) {
	  if (enChk[i]) {
	    assert(enChkHist[i]);
	    enChkHist[i] = 1;
	    classHist[i] = nodeClass[i];
	    nodeClass[i] = 2;
	    enChk[i] = 0;
	    nSingle++;
	  } else if (0) {
	    if (enChkHist[i]) {
	      enChkHist[i] = 2;
	    }
	  }
	}
	timeLimitSingle = 0.25;
	iterNum = 0;
	again = again && nSingle<minCutNum;
      } else {
	/* time out ? */
	if (timeLimit>0 && timeLimitTotal<0) {
	  again = 0;
	} else {
	  timeLimitSingle *= 2;
	  again = again && iterNum<iterLimit;
	}
      }
    } while (again);

    if (1 || nSingle) {
      fprintf(dMgrO(ddm),"R/R %s %d", nRoots>1 ? "array ": "", size);
      for (i=0; i<visitedNodes->num; i++) {
	enChkHist[i] &= 0x1;
      }
      AigRedRemovalIncrByRefinementIntern(ddm,visitedNodes,rootNodes,careBaig,
          maxCutNum,enChkHist,NULL,cachedNodes,&rrStats,classHist,timeLimitSingle,
          -1,redVal,1,&singleDone
      );
    }
  } else {
    /* incrByRef = 0 */
    for (i=nCuts=0; i<visitedNodes->num; i++) {
      baig = visitedNodes->nodes[i];
      bAig_AuxAig0(bmgr,baig) = bAig_NULL;
      bAig_AuxAig1(bmgr,baig) = bAig_NonInvertedEdge(baig);
      bAig_AuxInt(bmgr,baig) = i;
      bAig_Ref(bmgr, baig);
      foc[i] = enChk[i] = 0;
      if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
	right = bAig_NodeReadIndexOfRightChild(bmgr, baig);
	left = bAig_NodeReadIndexOfLeftChild(bmgr, baig);
	ir = bAig_AuxInt(bmgr, right);
	il = bAig_AuxInt(bmgr, left);
	foc[il]++;
	foc[ir]++;
      }
      if (nCuts < maxCutNum*10) {
	enChk[i] = 1;
	nCuts++;
      }
    }
    fprintf(dMgrO(ddm),"R/R %s(size=%d) ", nRoots>1 ? "array ": "", size);
    AigArrayRedRemovalIncrementalIntern (
      ddm,visitedNodes,rootNodes,careBaig,maxCutNum,maxObserve,enChk,foc,
      cachedNodes,&rrStats,timeLimit
    );
  }

  /* recompute aigs */
  for (i=0; i<Ddi_BddarrayNum(newArray); i++) {
    fAig = Ddi_BddarrayRead(newArray,i);
    if (Ddi_BddIsConstant(fAig)) {
      continue;
    }
    fBaig = Ddi_BddToBaig(fAig);
    baig = bAig_AuxAig1(bmgr,fBaig);
    if (bAig_NodeIsInverted(fBaig)) {
      baig = bAig_Not(baig);
    }
    newfAig = Ddi_BddMakeFromBaig(ddm, baig);
    Ddi_BddarrayWrite(newArray, i, newfAig);
    Ddi_Free(newfAig);
  }

  if (incrByRef) {
    fprintf(dMgrO(ddm),"Size=%d -> %d ", size, Ddi_BddarraySize(newArray));
  } else {
    fprintf(dMgrO(ddm),"<%d>", Ddi_BddarraySize(newArray));
  }
  fprintf(dMgrO(ddm),"(chk/cach/red/abo:%d/%d/%d/%d)\n",
         rrStats.nChecks, rrStats.nCached, rrStats.nRed, rrStats.nAbort);
  fprintf(dMgrO(ddm),"d:%ld-c:%ld,p:%ld,l:%ld\n", rrStats.decisions, rrStats.conflicts,
	 rrStats.propagations,rrStats.learnts_literals);
  fflush(dMgrO(ddm));

  /* free temp nodes */
  for (i=0; i<visitedNodes->num; i++) {
    fBaig = visitedNodes->nodes[i];

    baig = bAig_AuxAig1(bmgr, fBaig);
    if (baig != bAig_NULL && !bAig_NodeIsConstant(baig)) {
      bAig_RecursiveDeref(bmgr,baig);
    }
    bAig_AuxAig1(bmgr, fBaig) = bAig_NULL;
    bAig_AuxInt(bmgr, fBaig) = -1;
    bAig_CacheAig(bmgr, fBaig) = bAig_NULL;
  }

  Pdtutil_Free(enChk);
  Pdtutil_Free(foc);
  bAigArrayFree(visitedNodes);
  bAigArrayFree(rootNodes);
  if (incrByRef) {
    Pdtutil_Free(enChkHist);
    Pdtutil_Free(nodeClass);
    Pdtutil_Free(classHist);
    Pdtutil_Free(doms);
    Pdtutil_Free(occ);
    Pdtutil_Free(dist);
    Pdtutil_Free(ham);
    bAigArrayFree(dcNodes);
    bAigArrayFree(foNodes);
    bAigArrayFree(pcNodes);
    bAigArrayFree(psNodes);
  }
  if (1 || ddm->settings.aig.satCompare) {
    for (i=0; i<Ddi_BddarrayNum(newArray); i++) {
      fAig = Ddi_BddarrayRead(fAigarray, i);
      if (Ddi_BddIsConstant(fAig)) {
        continue;
      }
      fXor = Ddi_BddDup(Ddi_BddarrayRead(newArray, i));
      Ddi_BddXorAcc(fXor, fAig);
      if (care != NULL) {
        Ddi_BddAndAcc(fXor, care);
      }
      Pdtutil_Assert(!Ddi_AigSat(fXor),"Wrong RED REMOVAL");
      Ddi_Free(fXor);
    }
  }

  for (i=0; i<Ddi_BddarrayNum(newArray); i++) {
    fAig = Ddi_BddarrayRead(newArray,i);
    Ddi_BddarrayWrite(fAigarray, i, fAig);
  }

  Ddi_Free(newArray);
  return fAigarray;
#else
  int nVars;
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig;
  Ddi_Bddarray_t *newArray;
  bAig_array_t *visitedNodes, *rootNodes;
  bAigEdge_t fBaig, careBaig, cof1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigarray);
  //int extRef = Ddi_MgrReadExtRef(ddm);
  int i, j, nCuts, partSizeTh = 200;
  int *partIndex;
  int *partSize;
  int bddCompare = 0;
  int *nRef;
  int nFo1=0, nFo2=0;
  int *enChk;
  int cutBlockSize = /* maxCutNum */ -1 /* just one block */;
  redrem_stats rrStats = {0,0,0,0,0,0,0,0};
  int enMultipleSat=0;
  int incrByRefinement = 1;

  if (maxObserve >= 0 && maxCutNum >= maxObserve) {
    maxObserve = maxCutNum*2;
  }

  newArray = Ddi_BddarrayDup(fAigarray);

  if (ddm->aig.auxLits == NULL) {
    ddm->aig.auxLits = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Lock(ddm->aig.auxLits);
  }
  if (ddm->aig.auxLits2 == NULL) {
    ddm->aig.auxLits2 = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Lock(ddm->aig.auxLits2);
  }

  bmgr = ddm->aig.mgr;

  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
    enMultipleSat = Ddi_BddSize(care) > 10;
  }

  fprintf(dMgrO(ddm),"R/R array (%d) -> ", Ddi_BddarraySize(fAigarray)); fflush(dMgrO(ddm));

  /* create manager ??? */

  nVars = Ddi_MgrReadNumVars(ddm);

  visitedNodes = bAigArrayAlloc();
  rootNodes = bAigArrayAlloc();

  for (i=0; i<Ddi_BddarrayNum(newArray); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(newArray,i);
    if (Ddi_BddIsConstant(fAig)) {
      continue;
    }

    fBaig = Ddi_BddToBaig(fAig);
    bAigArrayWriteLast(rootNodes,fBaig);
    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  }

  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  //  (void) bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,-1);

  partIndex = Pdtutil_Alloc(int,visitedNodes->num);
  partSize = Pdtutil_Alloc(int,visitedNodes->num);
  enChk = Pdtutil_Alloc(int,visitedNodes->num);

  nRef = Pdtutil_Alloc(int,visitedNodes->num);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig, right, left;
    int ir, il;
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
    nRef[i] = 0;
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      nRef[ir]++; nRef[il]++;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    partSize[i] = 0;
    if (nRef[i] != 1) {
      partIndex[i] = i;
      partSize[i] = 1;
    }
    else {
      partIndex[i] = -1;
    }
    if (nRef[i] == 2) {
      nFo2++;
    }
  }
#if 0
  for (i=visitedNodes->num-1; i>=0; i--) {
    bAigEdge_t baig, right, left;
    int ir, il;
    baig = visitedNodes->nodes[i];
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      Pdtutil_Assert(partIndex[i]>=0,"Invalid part index");
      if (nRef[ir] == 1) {
        partIndex[ir] = partIndex[i];
        partSize[partIndex[i]]++;
      }
      if (nRef[il] == 1) {
        partIndex[il] = partIndex[i];
        partSize[partIndex[i]]++;
      }
    }
  }
  /* merge */
  for (j=0; j<2; j++) {
  for (i=visitedNodes->num-1; i>=0; i--) {
    bAigEdge_t baig, right, left;
    int ir, il, partid;
    baig = visitedNodes->nodes[i];
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      Pdtutil_Assert(partIndex[i]>=0,"Invalid part index");
      partid = partIndex[i];
      if (partIndex[partid] != partid) {
	/* partition merged */
        if (nRef[ir] == 1) {
          partIndex[ir] = partIndex[i];
        }
        if (nRef[il] == 1) {
          partIndex[il] = partIndex[i];
        }
      }
      /* partition not merged - propagate merge */
      if (nRef[ir] != 1 && partIndex[ir] == ir &&
          partSize[ir]+partSize[partid] < partSizeTh) {
        partIndex[ir] = partid;
	partSize[partid] += partSize[ir];
      }
      if (nRef[il] != 1 && partIndex[il] == il &&
          partSize[il]+partSize[partid] < partSizeTh) {
        partIndex[il] = partid;
	partSize[partid] += partSize[il];
      }
    }
  }
  }
#endif
  for (i=0; i<visitedNodes->num; i++) {
    if (partIndex[i] == i) {
      nFo1++;
    }
  }

  fprintf(dMgrO(ddm),"(part(fo2):%d(%d)/%d)",nFo1,nFo2,visitedNodes->num);fflush(dMgrO(ddm));

  if (!incrByRefinement) {
    for (i=nCuts=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      bAig_AuxAig0(bmgr,baig) = bAig_NULL;
      bAig_AuxAig1(bmgr,baig) = bAig_NonInvertedEdge(baig);
      bAig_Ref(bmgr, baig);
    }
  }

  for (j=nCuts=0; j<visitedNodes->num; j++) {
    bAigEdge_t baig = visitedNodes->nodes[j];
    enChk[j] = 0;
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if (nCuts>maxCutNum) {
      continue;
    }
    enChk[j] = 1;
    nCuts++;
  }

  if (incrByRefinement) {
    int newEn=0, newEn1=0;
    int twoPhase = 1;
    int tryAgain = 5*enMultipleSat;
    float myTimeLimit = tryAgain ? 2.0 : timeLimit;
    bAig_array_t *fBaigs = rootNodes;
    int enableObservabilityDC=0;
    int doApproxOnAbort=0;
    int singleDone=0;
    int *nodeClass;

    nodeClass = Pdtutil_Alloc(int, visitedNodes->num);
    for (i=0; i<visitedNodes->num; i++) {
      nodeClass[i] = 2;
    }
    ddm->settings.aig.satIncrByRefinement=1;
    if (visitedNodes->num > 10000) {
      myTimeLimit *= ((float)visitedNodes->num)/10000;
    }
    //    cntCalls++;
#if 0
    AigRedRemovalIncrByRefinementIntern (
      ddm,visitedNodes,fBaigs,careBaig,maxCutNum,-1/*maxObserve*/,enChk,nRef,
      cachedNodes,&rrStats,twoPhase ? myTimeLimit : timeLimit,
      0,enableObservabilityDC,redVal, twoPhase ? 0 : 2
    );
#endif
    if (twoPhase)  {
      for (j=0; j<visitedNodes->num; j++) {
	newEn += enChk[j];
      }
      fprintf(dMgrO(ddm),"redrem SAT filter %d -> %d\n", nCuts, newEn);
      while (0&&tryAgain>0) {
	myTimeLimit *= 2;
	AigRedRemovalIncrByRefinementIntern (ddm,visitedNodes,fBaigs,careBaig,
          maxCutNum,enChk,nRef,cachedNodes,&rrStats,
          nodeClass,myTimeLimit,-1,
          redVal, 0, &singleDone
        );
	//AigRedRemovalIncrByRefinementIntern (ddm,visitedNodes,fBaigs,careBaig,
        //  maxCutNum,-1/*maxObserve*/,enChk,nRef,cachedNodes,&rrStats,
        //  nodeClass,myTimeLimit,doApproxOnAbort,enableObservabilityDC,
        //  redVal, 0, &singleDone
        //);
        for (j=0; j<visitedNodes->num; j++) {
  	  newEn1 += enChk[j];
        }
        fprintf(dMgrO(ddm),"redrem SAT filter %d -> %d\n", newEn, newEn1);
	if (newEn1-newEn == 0) tryAgain=0;
	newEn = newEn1; newEn1 = 0;
	tryAgain--;
      }
      if (1)
	AigRedRemovalIncrByRefinementIntern (ddm,visitedNodes,fBaigs,careBaig,
          maxCutNum,enChk,nRef,cachedNodes,&rrStats,
          nodeClass,timeLimit,-1,
          redVal, 2, &singleDone
        );
	//AigRedRemovalIncrByRefinementIntern (ddm,visitedNodes,fBaigs,careBaig,
        //  maxCutNum,-1/*maxObserve*/,enChk,nRef,cachedNodes,&rrStats,
        //  nodeClass,timeLimit,doApproxOnAbort,enableObservabilityDC,
        //  redVal, 2, &singleDone
        //);
    }
    Pdtutil_Free(nodeClass);
  }
  else {
    AigArrayRedRemovalIncrementalIntern (
      ddm,visitedNodes,rootNodes,careBaig,maxCutNum,maxObserve,enChk,nRef,
      cachedNodes,&rrStats,timeLimit
    );
  }

  /* recompute aigs */
  for (i=0; i<Ddi_BddarrayNum(newArray); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(newArray,i);
    if (Ddi_BddIsConstant(fAig)) {
      continue;
    }

    fBaig = Ddi_BddToBaig(fAig);

    /* intermediate result */
    cof1 = bAig_AuxAig1(bmgr,fBaig);
    if (bAig_NodeIsInverted(fBaig)) {
      cof1 = bAig_Not(cof1);
    }
    newfAig = Ddi_BddMakeFromBaig(ddm,cof1);
    Ddi_BddarrayWrite(newArray,i,newfAig);
    Ddi_Free(newfAig);
  }

  fprintf(dMgrO(ddm),"<%d>(chk/cach/red/abo:%d/%d/%d/%d)\n",
          Ddi_BddarraySize(newArray),
          rrStats.nChecks, rrStats.nCached, rrStats.nRed, rrStats.nAbort);

  fprintf(dMgrO(ddm),"d:%ld-c:%ld,p:%ld,l:%ld\n",
	 rrStats.decisions,rrStats.conflicts,
	 rrStats.propagations,rrStats.learnts_literals);

  fflush(dMgrO(ddm));

  /* free temp nodes */

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1;
    bAigEdge_t baig = visitedNodes->nodes[i];

    baig1 = bAig_AuxAig1(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }

    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig;
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
    bAig_CacheAig(bmgr,baig) = bAig_NULL;
  }
#if 1
  Pdtutil_Free(nRef);

  Pdtutil_Free(partIndex);
  Pdtutil_Free(partSize);
  Pdtutil_Free(enChk);

  bAigArrayFree(visitedNodes);
  bAigArrayFree(rootNodes);

  if (1 || ddm->settings.aig.satCompare) {
    for (i=0; i<Ddi_BddarrayNum(newArray); i++) {
      Ddi_Bdd_t *f1Bdd;
      Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fAigarray,i);
      if (Ddi_BddIsConstant(fAig)) {
        continue;
      }

      fBaig = Ddi_BddToBaig(fAig);

      /* intermediate result */
      cof1 = bAig_AuxAig1(bmgr,fBaig);
      if (bAig_NodeIsInverted(fBaig)) {
        cof1 = bAig_Not(cof1);
      }
      f1Bdd = Ddi_BddDup(Ddi_BddarrayRead(newArray,i));
      Ddi_BddXorAcc(f1Bdd,fAig);
      if (care!=NULL) {
        Ddi_BddAndAcc(f1Bdd,care);
      }
      Pdtutil_Assert(!Ddi_AigSat(f1Bdd),"Wrong RED REMOVAL");
      Ddi_Free(f1Bdd);
    }
  }
#endif

  for (i=0; i<Ddi_BddarrayNum(newArray); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(newArray,i);
    Ddi_BddarrayWrite(fAigarray,i,fAig);
  }

  Ddi_Free(newArray);
  //  Ddi_MgrCheckExtRef(ddm,extRef);
#endif
  return fAigarray;
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
MinisatAssume
(
  Ddi_Bdd_t *f,
  vec<Lit>& assumps
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat, fCnf;
  if (Ddi_BddIsZero(f)) {
    return;
  }
  if (Ddi_BddIsOne(f)) {
    return;
  }

  if (Ddi_BddIsPartConj(f)) {
    int i;
    for (i=0; i<Ddi_BddPartNum(f); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
      if (!Ddi_BddIsOne(f_i)) {
        bAigEdge_t baig = f_i->data.aig->aigNode;
        fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) : aig2CnfId(ddm->aig.mgr,baig);
        assumps.push(MinisatLit(fCnf));
      }
    }
  }
  else {
    if (!Ddi_BddIsOne(f)) {
      bAigEdge_t baig = f->data.aig->aigNode;
      fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
        aig2CnfId(ddm->aig.mgr,baig);
      assumps.push(MinisatLit(fCnf));
    }
  }

}



/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
AigRedRemovalIncrementalIntern1 (
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  bAigEdge_t fBaig,
  bAigEdge_t careBaig,
  int maxCutNum,
  int maxObserve,
  int *enChk,
  int *nRef,
  bAig_array_t *cachedNodes,
  redrem_stats *rrStatsP,
  float timeLimit,
  int doApproxOnAbort
)
{
  Solver    S;
  vec<Lit> lits, observeLits;
  vec<Lit> assumps, assumpsReverse;
  Ddi_Bddarray_t *cutLits;
  int *cutIndex, i, j, nCuts;
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes1;
  int f, a, b, c, aa, bb, sat, saveCare;
  bAigEdge_t newfBaig, enabledBaig;
  int redundantClauses = 0;
  int *eqVars=NULL;
  int *nodeClass=NULL;
  int nAssumps;
  double time_limit=-1.0;
  int time_factor = 8;
  int satIncremental = ddm->settings.aig.satIncremental;
  long startTimeTot=0;
  bAig_array_t *visitedNodes2;
  int enabledHead;

  startTimeTot = util_cpu_time();

  aig2CnfIdInit(ddm);
  assumps.clear();
  assumpsReverse.clear();


  if (ddm->settings.aig.satTimeout) {
    time_limit = 1.0;
    if (ddm->settings.aig.satTimeout>1) {
      time_limit /= 5;
      if (ddm->settings.aig.satTimeout>2) {
        time_limit /= 5;
      }
    }
  }
  if (timeLimit >= 0) time_limit = timeLimit / 10.0;


  cutLits = ddm->aig.auxLits;
  Pdtutil_Assert(cutLits!=NULL,"cutlits array required");

  cutIndex = Pdtutil_Alloc(int,visitedNodes->num);
  eqVars = Pdtutil_Alloc(int,visitedNodes->num);
  nodeClass = Pdtutil_Alloc(int,visitedNodes->num);

  //  maxObserve = visitedNodes->num-100;
  if (maxObserve >= visitedNodes->num) {
    maxObserve = -1;
  }
  //  maxObserve = -1;

  for (i=nCuts=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1;
    bAigEdge_t baig = visitedNodes->nodes[i];
    cutIndex[i] = -1;
    int enableCheck = enChk[i];

    baig1 = bAig_AuxAig1(bmgr,baig);
    nodeClass[i]=0; /* default class */

    if (bAig_NodeIsConstant(baig1)) {
      continue;
    }

    if (!bAig_isVarNode(bmgr,baig)) {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig1));
      baig1 = bAig_And(bmgr,right,left);
    }

    if (enableCheck) {
      Ddi_Var_t *cutV, *wireV;
      Ddi_Bdd_t *cutL, *wireL;

      nodeClass[i]=1; /* red candidate class */

      bAig_Ref(bmgr, baig1);
      bAig_AuxAig0(bmgr,baig) = baig1;

      /* create cut var and wire connection var */
      if (Ddi_BddarrayNum(cutLits)/2 <= nCuts) {
	char name[10000];
        sprintf(name,"_RED_REM_CUTV_%d",nCuts);
        Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
        Pdtutil_Assert(bAig_VarNodeFromName(bmgr,name)==bAig_NULL,
          "duplicate baig name");
	cutV = Ddi_VarNew(ddm);
        Ddi_VarAttachName (cutV, name);
        sprintf(name,"_RED_REM_WIREV_%d",nCuts);
        Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
	wireV = Ddi_VarNew(ddm);
        Ddi_VarAttachName (wireV, name);
        cutL = Ddi_BddMakeLiteralAig(cutV,1);
        wireL = Ddi_BddMakeLiteralAig(wireV,1);
	Ddi_BddarrayInsertLast(cutLits,cutL);
	Ddi_BddarrayInsertLast(cutLits,wireL);
	Ddi_Free(cutL);
	Ddi_Free(wireL);
      }
      cutL=Ddi_BddarrayRead(cutLits,nCuts*2);

      cutIndex[i] = nCuts++;

      baig1 = Ddi_BddToBaig(cutL);

    }
    else {
      nodeClass[i]=2; /* out of red candidate class */
      if ((maxObserve >= 0) && (i>=maxObserve)
        && !bAig_isVarNode(bmgr,baig)) {
        bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
        bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
        int ir = bAig_AuxInt(bmgr,right);
        int il = bAig_AuxInt(bmgr,left);
	if (nodeClass[ir] <= 2 || nodeClass[il] <= 2) {
          nodeClass[i]=3; /* observability frontier class */
	}
	else {
          nodeClass[i]=4; /* ignore class: FO of observability frontier */
	}
      }
    }

    bAig_Ref(bmgr, baig1);
    bAig_AuxAig1(bmgr,baig) = baig1;

  }

  /* generate clauses */
  visitedNodes1 = bAigArrayAlloc();

  postOrderAigVisitIntern(bmgr,careBaig,visitedNodes1,-1);
  //    done within next loop !
  //    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes1,-1);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAigEdge_t baig1 = bAig_AuxAig1(bmgr,baig);
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if ((maxObserve < 0) || (nodeClass[i]<4)) {
      postOrderAigVisitIntern(bmgr,baig,visitedNodes1,-1);
      postOrderAigVisitIntern(bmgr,baig1,visitedNodes1,-1);
      if (cutIndex[i] >= 0) {
        baig1 = bAig_AuxAig0(bmgr,baig);
        postOrderAigVisitIntern(bmgr,baig1,visitedNodes1,-1);
      }
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes1);

  for (i=0; i<visitedNodes1->num; i++) {
    int fCnf;
    bAigEdge_t baig = visitedNodes1->nodes[i];
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (!bAig_isVarNode(bmgr,baig)) {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      /* convert AIG node to cnf clauses */
      /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
      f = aig2CnfId(bmgr,baig);
      a = bAig_NodeIsInverted(right) ? -aig2CnfId(bmgr,right) :
                                        aig2CnfId(bmgr,right);
      b = bAig_NodeIsInverted(left) ? -aig2CnfId(bmgr,left) :
                                       aig2CnfId(bmgr,left);

      /* f -a -b */
      MinisatClause3(S,lits,f,-a,-b);
      /* -f a */
      MinisatClause2(S,lits,-f,a);
      /* -f b */
      MinisatClause2(S,lits,-f,b);
    }

    fCnf = aig2CnfId(bmgr,baig);

  }

  /* care */

  c = bAig_NodeIsInverted(careBaig) ? -aig2CnfId(bmgr,careBaig) :
                                       aig2CnfId(bmgr,careBaig);
  while (abs(c) > S.nVars()) S.newVar();

  saveCare = c;
  MinisatClause1(S,lits,c);

  if (maxObserve < 0) {

    newfBaig = bAig_AuxAig1(bmgr,fBaig);
    /* fBaig != newfBaig */
    aa=a = aig2CnfId(bmgr,bAig_NonInvertedEdge(fBaig));
    bb=b = bAig_NodeIsInverted(newfBaig) ? -aig2CnfId(bmgr,newfBaig) :
                                         aig2CnfId(bmgr,newfBaig);

    while (abs(a) > S.nVars() || abs(b) > S.nVars()) S.newVar();

    MinisatClause2(S,lits,a,b);
    MinisatClause2(S,lits,-a,-b);
  }
  else {
    observeLits.clear();
  }


  for (i=0; i<visitedNodes->num; i++) {
    //    Ddi_Bddarray_t *wireLits = Ddi_BddarrayAlloc(ddm,0);
    bAigEdge_t baig = visitedNodes->nodes[i];
    int id = cutIndex[i];
    if (id >= 0) {
      Ddi_Bdd_t *cutL=Ddi_BddarrayRead(cutLits,id*2);
      Ddi_Bdd_t *wireL=Ddi_BddarrayRead(cutLits,id*2+1);
      bAigEdge_t cutBaig, wireBaig, fBaig;
      int c, w, f;
      cutBaig = Ddi_BddToBaig(cutL);
      wireBaig = Ddi_BddToBaig(wireL);

      fBaig = bAig_AuxAig0(bmgr,baig);
      Pdtutil_Assert(fBaig != bAig_NULL,"NULL baig");

      f = aig2CnfId(bmgr,fBaig);
      w = aig2CnfId(bmgr,wireBaig);
      c = aig2CnfId(bmgr,cutBaig);

      /* f -c -w */
      MinisatClause3(S,lits,f,-c,-w);
      /* -f c -w */
      MinisatClause3(S,lits,-f,c,-w);
#if 0
      /* -f -c w */
      MinisatClause3(S,lits,-f,-c,w);
      /* f c w */
      MinisatClause3(S,lits,f,c,w);
#endif

#if 0
      /* w */
      MinisatClause1(S,lits,w);
#else
      {
        Lit l = MinisatLit(w);
        assumps.push(l);
      }
#endif

    }
  }

  /* redundant vars/clauses here */
  if (redundantClauses || maxObserve>=0) {
    for (i=0; i<visitedNodes->num; i++) {
      int ir, il;
      int id = cutIndex[i];
      bAigEdge_t baig1, right, left;
      bAigEdge_t baig = visitedNodes->nodes[i];
      int f0, f1, eq01;
      eqVars[i] = -1;
      if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
        continue;
      }
      baig1 = bAig_AuxAig1(bmgr,baig);
      if (bAig_NodeIsConstant(baig1) || bAig_isVarNode(bmgr,baig1)) {
        continue;
      }
      f0 = aig2CnfId(bmgr,bAig_NonInvertedEdge(baig));
      f1 = bAig_NodeIsInverted(baig1) ? -aig2CnfId(bmgr,baig1) :
                                         aig2CnfId(bmgr,baig1);

      if ((redundantClauses || i>maxObserve) && (f0!=f1)) {
        right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
        left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
        ir = bAig_AuxInt(bmgr,right);
        il = bAig_AuxInt(bmgr,left);
        Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");

        /* fanin already observed */
	if (!redundantClauses && nodeClass[i]>=4) {
	  continue;
	}

        S.newVar();
        eqVars[i] = eq01 = S.nVars();
        /* eq01 = (f0==f1) */

	//	Pdtutil_Assert((f0==aa)&&(f1==bb),"aa");

        /* f0 -f1 -eq01 */
        MinisatClause3(S,lits,f0,-f1,-eq01);

        /* -f0 f1 -eq01 */
        MinisatClause3(S,lits,-f0,f1,-eq01);
#if 1
        /* -f0 -f1 eq01 */
        MinisatClause3(S,lits,-f0,-f1,eq01);
        /* f0 f1 eq01 */
        MinisatClause3(S,lits,f0,f1,eq01);
#endif
	if (maxObserve >= 0 && i > maxObserve) {
          observeLits.push(MinisatLit(-eq01));
	}

	if (!redundantClauses || eqVars[ir]<0 || eqVars[il]<0) continue;
        if (id < 0) {
          /* eqL & eqR => eq01 */
          /* eq01 -eqL -eqR */
          MinisatClause3(S,lits,eq01,-eqVars[il],-eqVars[ir]);
	}
	else {
          Ddi_Bdd_t *wireL=Ddi_BddarrayRead(cutLits,id*2+1);
          bAigEdge_t wireBaig = Ddi_BddToBaig(wireL);
	  int w = aig2CnfId(bmgr,wireBaig);

          /* w & eqL & eqR => eq01 */
          /* eq01 -eqL -eqR -w */
          MinisatClause4(S,lits,eq01,-eqVars[il],-eqVars[ir],w);
	}
      }
    }
    if (maxObserve >= 0 && observeLits.size()>0) {
      S.addClause(observeLits);
    }
  }

  nAssumps = assumps.size();
  for (i=nAssumps-1; i>=0; i--) {
    assumpsReverse.push(assumps[i]);
  }

  /* make checks with incremental sat */
  visitedNodes2 = bAigArrayAlloc();

  enabledBaig = visitedNodes->nodes[visitedNodes->num-1];
  bAigArrayWriteLast(visitedNodes2,enabledBaig);
  nodeVisited(bmgr,enabledBaig) += 4;
  enabledHead = 0;

  while (enabledHead < visitedNodes2->num) {

    bAigEdge_t redConstant = bAig_NULL;
    int id, enableCheck=1;
    bAigEdge_t baig1, baig;

    enabledBaig = visitedNodes2->nodes[enabledHead++];
    i = bAig_AuxInt(bmgr,enabledBaig);
    enChk[i]=2;

    Pdtutil_Assert(i<visitedNodes->num && i>=0, "invalid index");

    id = cutIndex[i];
    baig = visitedNodes->nodes[i];

    Pdtutil_Assert(bAig_NonInvertedEdge(baig) ==
                 bAig_NonInvertedEdge(enabledBaig), "invalid baig found");

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (timeLimit >= 0 &&
      ((util_cpu_time () - startTimeTot)/1000.0 > timeLimit)) {
      enableCheck = 0;
    }

    baig1 = bAig_AuxAig1(bmgr,baig);

    if (enableCheck && id >= 0) {
      Ddi_Bdd_t *cutL=Ddi_BddarrayRead(cutLits,id*2);
      Ddi_Bdd_t *wireL=Ddi_BddarrayRead(cutLits,id*2+1);
      bAigEdge_t cutBaig, wireBaig, fBaig;
      int c;
      Lit saveLit;
      int idAss = nAssumps-id-1;
      long cpuTime=0, startTime=0;

      cutBaig = Ddi_BddToBaig(cutL);
      wireBaig = Ddi_BddToBaig(wireL);

      fBaig = bAig_AuxAig0(bmgr,baig);
      Pdtutil_Assert(fBaig != bAig_NULL,"NULL baig");

      c = aig2CnfId(bmgr,cutBaig);

      saveLit = assumpsReverse[idAss];

      rrStatsP->nChecks++;

      assumpsReverse[idAss] = MinisatLit(c);
      if ((sat = S.okay())) {
        if (!satIncremental) {
          S.resetDB();
        }
        startTime = util_cpu_time ();
        sat = S.solve(assumpsReverse,time_limit*time_factor);
        cpuTime = util_cpu_time () - startTime;
        if (time_factor>1 && cpuTime/1000.0>time_limit) {
          time_factor /= 2;
        }
      }
      if (S.undefined()) {
        rrStatsP->nAbort++;
	if (doApproxOnAbort) {
          sat = 0;
	}
	else {
          sat = 1;
	}
      }
      if (!sat) {
        /* redundancy found ! Replace with 1 constant */
        rrStatsP->nRed++;
        redConstant = bAig_One;
        /* c */
        MinisatClause1(S,lits,c);
        Pdtutil_Assert(enableCheck,"wrong cached emable");
      }
      else {
        assumpsReverse[idAss] = MinisatLit(-c);
        if ((sat = S.okay())) {
          if (!satIncremental) {
            S.resetDB();
          }
          startTime = util_cpu_time ();
          sat = S.solve(assumpsReverse,time_limit*time_factor);
          cpuTime = util_cpu_time () - startTime;
        }
        if (S.undefined()) {
          rrStatsP->nAbort++;
  	  if (doApproxOnAbort) {
            sat = 0;
	  }
	  else {
            sat = 1;
	  }
        }
        if (!sat) {
          /* redundancy found ! Replace with 1 constant */
          rrStatsP->nRed++;
          redConstant = bAig_Zero;
          /* !c */
          MinisatClause1(S,lits,-c);
          Pdtutil_Assert(enableCheck,"wrong cached emable");
        }
        else {
          /* resume old assump */
          // assumps[id] = saveLit;
          lits.clear();
          /* w */
          lits.push(saveLit);
          S.addClause(lits);
        }
      }

      if (rrStatsP->nChecks%20 == 0) {
        fprintf(dMgrO(ddm),"."); fflush(dMgrO(ddm));
      }
      /* dummy clause */
      assumpsReverse[idAss] = MinisatLit(saveCare);
      //      assumpsReverse.pop();
    }
    else if (id >= 0) {
      /* cached observable point */
      lits.clear();
      /* w */
      lits.push(assumpsReverse[nAssumps-id-1]);
      S.addClause(lits);
      //      assumpsReverse.pop();
      /* dummy clause */
      // not necessary
      // assumpsReverse[nAssumps-id-1] = MinisatLit(saveCare);
    }

    if (redConstant != bAig_NULL) {
      /* set constant */
      baig1 = redConstant;
      bAig_Ref(bmgr, baig1);
      bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
      bAig_AuxAig1(bmgr,baig) = baig1;
    }
    else if (!bAig_isVarNode(bmgr,baig)) {
      /* insert fanin nodes in FIFO queue */
      bAigEdge_t right = rightChild(bmgr,baig);
      bAigEdge_t left = leftChild(bmgr,baig);
      if (nodeVisited(bmgr,left) < 4) {
        nodeVisited(bmgr,left) += 4;
        bAigArrayWriteLast(visitedNodes2,left);
      }
      if (nodeVisited(bmgr,right) < 4) {
        nodeVisited(bmgr,right) += 4;
        bAigArrayWriteLast(visitedNodes2,right);
      }
    }
  }

  postOrderAigClearVisitedIntern(bmgr,visitedNodes2);
  bAigArrayFree(visitedNodes2);

  /* RECOMPUTATION @@@@@ */

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1, baig;

    if (enChk[i]!=2) continue;

    baig = visitedNodes->nodes[i];
    baig1 = bAig_AuxAig1(bmgr,baig);
    if (baig1 != bAig_NULL && bAig_NodeIsConstant(baig1)) {
      /* redundant node */
      //      fprintf(dMgrO(ddm),"RED FOUND\n");
      continue;
    }

    if (bAig_isVarNode(bmgr,baig)) {
      bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
      baig1 = bAig_NonInvertedEdge(baig);
      bAig_Ref(bmgr, baig1);
      bAig_AuxAig1(bmgr,baig) = baig1;
      continue;
    }

    Pdtutil_Assert(!bAig_NodeIsConstant(baig),"constant baig found");

    if (!bAig_NodeIsConstant(baig)) {
      /* re-compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
      bAig_Ref(bmgr, baig1);
      bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
      bAig_AuxAig1(bmgr,baig) = baig1;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1;
    bAigEdge_t baig = visitedNodes->nodes[i];

    baig1 = bAig_AuxAig0(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
  }

  aig2CnfIdClose(ddm);

  rrStatsP->decisions        += S.stats.decisions;
  rrStatsP->conflicts        += S.stats.conflicts;
  rrStatsP->propagations     += S.stats.propagations;
  rrStatsP->learnts_literals += S.stats.learnts_literals;

  Pdtutil_Free(eqVars);
  Pdtutil_Free(nodeClass);
  Pdtutil_Free(cutIndex);
  bAigArrayFree(visitedNodes1);

}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
AigRedRemovalIncrementalIntern (
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  bAigEdge_t fBaig,
  bAigEdge_t careBaig,
  int maxCutNum,
  int maxObserve,
  int *enChk,
  int *nRef,
  bAig_array_t *cachedNodes,
  redrem_stats *rrStatsP,
  float timeLimit,
  int doApproxOnAbort,
  int enableObservabilityDC
)
{
  Solver    S;
  vec<Lit> lits, observeLits;
  vec<Lit> assumps, assumpsReverse;
  Ddi_Bddarray_t *cutLits, *observeCutLits;
  int *cutIndex, *observeCut, i, nCuts, nObserveCuts;
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes1;
  int f, a, b, c, aa, bb, sat, observeOut=-1;
  bAigEdge_t newfBaig;
  int redundantClauses = 0;
  int *eqVars=NULL;
  int *nodeClass=NULL;
  int *cnfCutIds=NULL;
  int nAssumps;
  double time_limit=-1.0;
  int time_factor = 1;
  int satIncremental = ddm->settings.aig.satIncremental;
  long startTimeTot=0;
  int refObserve = -1;
  Ddi_Bdd_t *observeSelect = NULL;
  int useObserveLits=0;
  int checkedNotRed = 0;
  int incrByRefinement = ddm->settings.aig.satIncrByRefinement;
  Ddi_Bdd_t *fAig = Ddi_BddMakeFromBaig(ddm,fBaig);
  Ddi_Bdd_t *careAig = Ddi_BddMakeFromBaig(ddm,careBaig);
  int enCached=1;


  startTimeTot = util_cpu_time();

  aig2CnfIdInit(ddm);
  assumps.clear();
  assumpsReverse.clear();

  observeLits.clear();

  if (ddm->settings.aig.satTimeout) {
    time_limit = 1.0;
    if (ddm->settings.aig.satTimeout>1) {
      time_limit /= 5;
      if (ddm->settings.aig.satTimeout>2) {
        time_limit /= 5;
      }
    }
  }
  if (timeLimit >= 0) time_limit = timeLimit / 30.0;

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
    Pdtutil_Assert(bAig_AuxAig1(bmgr,baig) == bAig_NULL, "NULL baig1 required");
    bAig_AuxAig1(bmgr,baig) = bAig_NonInvertedEdge(baig);
    bAig_Ref(bmgr, baig);
  }


  cutLits = ddm->aig.auxLits;
  Pdtutil_Assert(cutLits!=NULL,"cutlits array required");
  observeCutLits = ddm->aig.auxLits2;
  Pdtutil_Assert(observeCutLits!=NULL,"cutlits array required");

  cutIndex = Pdtutil_Alloc(int,visitedNodes->num);
  observeCut = Pdtutil_Alloc(int,visitedNodes->num);
  eqVars = Pdtutil_Alloc(int,visitedNodes->num);
  nodeClass = Pdtutil_Alloc(int,visitedNodes->num);
  cnfCutIds = Pdtutil_Alloc(int,visitedNodes->num);

  //  maxObserve = visitedNodes->num-100;
  if (maxObserve >= visitedNodes->num) {
    maxObserve = -1;
  }
  //  maxObserve = -1;

  for (i=visitedNodes->num-1; i>=0; i--) {
    if (enChk[i]) nodeClass[i] = 1;
    if (maxObserve>=0 && i>maxObserve) {
      nodeClass[i] = 4;
    }
    else {
      nodeClass[i] = 2;
    }
    cnfCutIds[i] = -1;
  }
  if (maxCutNum < visitedNodes->num && nodeClass[visitedNodes->num-1]==2) {
    nodeClass[visitedNodes->num-1]=4;
  }
  for (i=visitedNodes->num-1; i>=0; i--) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    if (nodeClass[i] < 4) continue;
    if (!bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      int ir = bAig_AuxInt(bmgr,right);
      int il = bAig_AuxInt(bmgr,left);
      if (maxObserve<0) {
        if (nodeClass[ir] == 1 || nodeClass[il] == 1) {
	  nodeClass[i] = 3;
        }
        else {
	  nodeClass[ir] = nodeClass[il] = 4;
        }
      }
      else if (i>maxObserve) {
        if (nodeClass[ir] < 3 || nodeClass[il] < 3) {
	  nodeClass[i] = 3;
        }
      }
    }
  }
  if (0 && maxObserve < 0 && maxCutNum < visitedNodes->num) {
    maxObserve = 1;
  }

  for (i=nCuts=nObserveCuts=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1;
    bAigEdge_t baig = visitedNodes->nodes[i];
    cutIndex[i] = -1;
    observeCut[i] = -1;
    int enableCheck = enChk[i];

    baig1 = bAig_AuxAig1(bmgr,baig);
    //    nodeClass[i]=0; /* default class */

    if (bAig_NodeIsConstant(baig1)) {
      continue;
    }

    if (!bAig_isVarNode(bmgr,baig)) {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig1));
      baig1 = bAig_And(bmgr,right,left);
    }

    if (enableCheck) {
      Ddi_Var_t *cutV, *wireV;
      Ddi_Bdd_t *cutL, *wireL;

      Pdtutil_Assert(nodeClass[i]==1,"wrong node class");
      //      nodeClass[i]=1; /* red candidate class */

      bAig_Ref(bmgr, baig1);
      bAig_AuxAig0(bmgr,baig) = baig1;

      /* create cut var and wire connection var */
      if (Ddi_BddarrayNum(cutLits)/2 <= nCuts) {
	char name[10000];
        sprintf(name,"_RED_REM_CUTV_%d",nCuts);
        Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
        Pdtutil_Assert(bAig_VarNodeFromName(bmgr,name)==bAig_NULL,
          "duplicate baig name");
	cutV = Ddi_VarNew(ddm);
        Ddi_VarAttachName (cutV, name);
        sprintf(name,"_RED_REM_WIREV_%d",nCuts);
        Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
	wireV = Ddi_VarNew(ddm);
        Ddi_VarAttachName (wireV, name);
        cutL = Ddi_BddMakeLiteralAig(cutV,1);
        wireL = Ddi_BddMakeLiteralAig(wireV,1);
	Ddi_BddarrayInsertLast(cutLits,cutL);
	Ddi_BddarrayInsertLast(cutLits,wireL);
	Ddi_Free(cutL);
	Ddi_Free(wireL);
      }
      cutL=Ddi_BddarrayRead(cutLits,nCuts*2);

      cutIndex[i] = nCuts++;

      baig1 = Ddi_BddToBaig(cutL);

    }
    else {
      Ddi_Var_t *cutV=NULL, *wireV=NULL;
      Ddi_Bdd_t *cutL, *wireL;
      char name[10000];

      Pdtutil_Assert(nodeClass[i]>1,"wrong node class");
      //      nodeClass[i]=2; /* out of red candidate class */
      //      if ((maxObserve >= 0) && (i>=maxObserve)
      if ((nodeClass[i]>2)
        && !bAig_isVarNode(bmgr,baig)) {

        bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
        bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
        int ir = bAig_AuxInt(bmgr,right);
        int il = bAig_AuxInt(bmgr,left);
	if (nodeClass[i] == 3) {
	  //	if (nodeClass[ir] <= 2 || nodeClass[il] <= 2) {
	  //          nodeClass[i]=3; /* observability frontier class */

	  if (enableObservabilityDC) {
            /* create cut var and wire connection var */

            bAig_Ref(bmgr, baig1);
            bAig_AuxAig0(bmgr,baig) = baig1;

            if (Ddi_BddarrayNum(observeCutLits) <= nObserveCuts) {
              sprintf(name,"_RED_REM_OBS_CUTV_%d",nObserveCuts);
              Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Dupl. cut var");
              Pdtutil_Assert(bAig_VarNodeFromName(bmgr,name)==bAig_NULL,
              "duplicate baig name");
  	      cutV = Ddi_VarNew(ddm);
              Ddi_VarAttachName (cutV, name);
              cutL = Ddi_BddMakeLiteralAig(cutV,1);
	      Ddi_BddarrayInsertLast(observeCutLits,cutL);
	      Ddi_Free(cutL);
            }
            cutL=Ddi_BddarrayRead(observeCutLits,nObserveCuts);
            sprintf(name,"_RED_REM_OBSERVE_WIREV");
            wireV = Ddi_VarFromName(ddm,name);
            if (wireV==NULL) {
	      wireV = Ddi_VarNew(ddm);
              Ddi_VarAttachName (wireV, name);
	    }
	    Pdtutil_Assert(wireV != NULL,"NULL wire variable");
	    if (refObserve<0) {
              refObserve = 1;
	      observeSelect = Ddi_BddMakeLiteralAig(wireV,1);
	    }

            observeCut[i] = nObserveCuts++;

            baig1 = Ddi_BddToBaig(cutL);

	  }

	}
	else {
          nodeClass[i]=4; /* ignore class: FO of observability frontier */
	}
      }
    }

    bAig_Ref(bmgr, baig1);
    bAig_AuxAig1(bmgr,baig) = baig1;

  }

  /* generate clauses */
  visitedNodes1 = bAigArrayAlloc();

  postOrderAigVisitIntern(bmgr,careBaig,visitedNodes1,-1);
  //    done within next loop !
  //    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes1,-1);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAigEdge_t baig1 = bAig_AuxAig1(bmgr,baig);
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if ((maxObserve < 0) || (nodeClass[i]<4)) {
      postOrderAigVisitIntern(bmgr,baig,visitedNodes1,-1);
      postOrderAigVisitIntern(bmgr,baig1,visitedNodes1,-1);

      if (cutIndex[i] >= 0) {
        baig1 = bAig_AuxAig0(bmgr,baig);
        postOrderAigVisitIntern(bmgr,baig1,visitedNodes1,-1);
      }
      else if (observeCut[i] >= 0) {
        baig1 = bAig_AuxAig0(bmgr,baig);
        postOrderAigVisitIntern(bmgr,baig1,visitedNodes1,-1);
      }
    }
#if 1
    /* observability care !!! */
    else if (enableObservabilityDC){
      postOrderAigVisitIntern(bmgr,baig1,visitedNodes1,-1);
    }
#endif
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes1);

  for (i=0; i<visitedNodes1->num; i++) {
    int fCnf;
    bAigEdge_t baig = visitedNodes1->nodes[i];
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (!bAig_isVarNode(bmgr,baig)) {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      /* convert AIG node to cnf clauses */
      /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
      f = aig2CnfId(bmgr,baig);
      a = bAig_NodeIsInverted(right) ? -aig2CnfId(bmgr,right) :
                                        aig2CnfId(bmgr,right);
      b = bAig_NodeIsInverted(left) ? -aig2CnfId(bmgr,left) :
                                       aig2CnfId(bmgr,left);

      /* f -a -b */
      MinisatClause3(S,lits,f,-a,-b);
      /* -f a */
      MinisatClause2(S,lits,-f,a);
      /* -f b */
      MinisatClause2(S,lits,-f,b);
    }

    fCnf = aig2CnfId(bmgr,baig);

  }

  /* care */

  c = bAig_NodeIsInverted(careBaig) ? -aig2CnfId(bmgr,careBaig) :
                                       aig2CnfId(bmgr,careBaig);
  while (abs(c) > S.nVars()) S.newVar();

  MinisatClause1(S,lits,c);

  if (maxObserve < 0) {

    newfBaig = bAig_AuxAig1(bmgr,fBaig);
    /* fBaig != newfBaig */
    aa=a = aig2CnfId(bmgr,bAig_NonInvertedEdge(fBaig));
    bb=b = bAig_NodeIsInverted(newfBaig) ? -aig2CnfId(bmgr,newfBaig) :
                                         aig2CnfId(bmgr,newfBaig);

    while (abs(a) > S.nVars() || abs(b) > S.nVars()) S.newVar();

    MinisatClause2(S,lits,a,b);
    MinisatClause2(S,lits,-a,-b);
  }
  else {
    observeLits.clear();

    if (enableObservabilityDC) {
      newfBaig = bAig_AuxAig1(bmgr,fBaig);
      observeOut = bAig_NodeIsInverted(fBaig) ? -aig2CnfId(bmgr,newfBaig) :
                                        aig2CnfId(bmgr,newfBaig);
      //      MinisatClause1(S,lits,observeOut);
      //      assumps.push(MinisatLit(observeOut));
    }
  }


  for (i=0; i<visitedNodes->num; i++) {
    //    Ddi_Bddarray_t *wireLits = Ddi_BddarrayAlloc(ddm,0);
    bAigEdge_t baig = visitedNodes->nodes[i];
    int id = cutIndex[i];
    int observeId = observeCut[i];

    if (id >= 0) {
      Ddi_Bdd_t *cutL=Ddi_BddarrayRead(cutLits,id*2);
      Ddi_Bdd_t *wireL=Ddi_BddarrayRead(cutLits,id*2+1);
      bAigEdge_t cutBaig, wireBaig, fBaig;
      int c, w, f;

      cutBaig = Ddi_BddToBaig(cutL);
      wireBaig = Ddi_BddToBaig(wireL);

      Pdtutil_Assert(nodeClass[i]==1,"Wrong node class");

      fBaig = bAig_AuxAig0(bmgr,baig);
      Pdtutil_Assert(fBaig != bAig_NULL,"NULL baig");

      f = aig2CnfId(bmgr,fBaig);
      w = aig2CnfId(bmgr,wireBaig);
      c = cnfCutIds [i] = aig2CnfId(bmgr,cutBaig);

      /* w => c=f */
      /* f -c -w */
      MinisatClause3(S,lits,f,-c,-w);
      /* -f c -w */
      MinisatClause3(S,lits,-f,c,-w);
#if 0
      /* -f -c w */
      MinisatClause3(S,lits,-f,-c,w);
      /* f c w */
      MinisatClause3(S,lits,f,c,w);
#endif

#if 0
      /* w */
      MinisatClause1(S,lits,w);
#else
      {
        Lit l = MinisatLit(w);
        assumps.push(l);
      }
#endif

    }
    else if (observeId >= 0) {

      Ddi_Bdd_t *cutL=Ddi_BddarrayRead(observeCutLits,observeId);
      Ddi_Bdd_t *wireL=observeSelect;
      bAigEdge_t cutBaig, wireBaig, fBaig;
      int c, w, f;
      int f0;
      bAigEdge_t fBaigRef=bAig_NonInvertedEdge(baig);
      cutBaig = Ddi_BddToBaig(cutL);
      wireBaig = Ddi_BddToBaig(wireL);

      /* observe frontier: connect cutl either to reference f or to
         aux1 f, depending on common selection variable */

      fBaig = bAig_AuxAig0(bmgr,baig);
      Pdtutil_Assert(fBaig != bAig_NULL,"NULL baig");

      f0 = aig2CnfId(bmgr,fBaigRef);
      f = aig2CnfId(bmgr,fBaig);
      w = aig2CnfId(bmgr,wireBaig);
      c = cnfCutIds [i] = aig2CnfId(bmgr,cutBaig);

#if 1
      /* f -c -w */
      MinisatClause3(S,lits,f,-c,-w);
      /* -f c -w */
      MinisatClause3(S,lits,-f,c,-w);
      /* f0 -c w */
      MinisatClause3(S,lits,f0,-c,w);
      /* -f0 c w */
      MinisatClause3(S,lits,-f0,c,w);
#endif
    }
  }

  /* redundant vars/clauses here */
  if ((redundantClauses || maxObserve>=0)) {
    for (i=0; i<visitedNodes->num; i++) {
      int ir, il;
      int id = cutIndex[i];
      bAigEdge_t baig1, right, left;
      bAigEdge_t baig = visitedNodes->nodes[i];
      int f0, f1, eq01;
      eqVars[i] = -1;
      if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
        continue;
      }
      baig1 = bAig_AuxAig1(bmgr,baig);
      if (nodeClass[i]==3 && enableObservabilityDC) {
        baig1 = bAig_AuxAig0(bmgr,baig);
	Pdtutil_Assert(baig1 != bAig_NULL,"NULL baig");
      }
      if (bAig_NodeIsConstant(baig1) || bAig_isVarNode(bmgr,baig1)) {
        continue;
      }
      f0 = aig2CnfId(bmgr,bAig_NonInvertedEdge(baig));
      f1 = bAig_NodeIsInverted(baig1) ? -aig2CnfId(bmgr,baig1) :
                                         aig2CnfId(bmgr,baig1);

      if ((redundantClauses || nodeClass[i]>2) && (f0!=f1)) {
        right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
        left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
        ir = bAig_AuxInt(bmgr,right);
        il = bAig_AuxInt(bmgr,left);
        Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");

        /* fanin already observed */
	if (!redundantClauses && nodeClass[i]>=4) {
	  continue;
	}

	Pdtutil_Assert(redundantClauses||nodeClass[i]==3,"wrong node class");
        S.newVar();
        eqVars[i] = eq01 = S.nVars();
        /* eq01 = (f0==f1) */

	//	Pdtutil_Assert((f0==aa)&&(f1==bb),"aa");

        /* f0 -f1 -eq01 */
        MinisatClause3(S,lits,f0,-f1,-eq01);

        /* -f0 f1 -eq01 */
        MinisatClause3(S,lits,-f0,f1,-eq01);
#if 1
        /* -f0 -f1 eq01 */
        MinisatClause3(S,lits,-f0,-f1,eq01);
        /* f0 f1 eq01 */
        MinisatClause3(S,lits,f0,f1,eq01);
#endif
	if (nodeClass[i]>2) {
          observeLits.push(MinisatLit(-eq01));
	}

	if (!redundantClauses || eqVars[ir]<0 || eqVars[il]<0) continue;
        if (id < 0) {
          /* eqL & eqR => eq01 */
          /* eq01 -eqL -eqR */
          MinisatClause3(S,lits,eq01,-eqVars[il],-eqVars[ir]);
	}
	else {
          Ddi_Bdd_t *wireL=Ddi_BddarrayRead(cutLits,id*2+1);
          bAigEdge_t wireBaig = Ddi_BddToBaig(wireL);
	  int w = aig2CnfId(bmgr,wireBaig);

          /* w & eqL & eqR => eq01 */
          /* eq01 -eqL -eqR -w */
          MinisatClause4(S,lits,eq01,-eqVars[il],-eqVars[ir],w);
	}
      }
    }
    if (maxObserve >= 0 && observeLits.size()>0) {
      useObserveLits=1;
      //      S.addClause(observeLits);
    }
  }

  nAssumps = assumps.size();
  for (i=nAssumps-1; i>=0; i--) {
    assumpsReverse.push(assumps[i]);
  }
  if (observeLits.size() > 0) {
    Pdtutil_Assert(useObserveLits,"wrong observe lits flag");
    S.addClause(observeLits);
  }
  else {
    Pdtutil_Assert(!useObserveLits,"wrong observe lits flag");
  }

  if (ddm->settings.aig.satCompare) {
    /* check data structure */
    int n1, n2;
    for (i=n1=n2=0; i<visitedNodes->num; i++) {
      if (nodeClass[i]==1) n1++;
      if (nodeClass[i]==3) n2++;
    }
    Pdtutil_Assert(n1==nCuts,"wrong node cuts num");
    if (enableObservabilityDC) {
      Pdtutil_Assert(n2==nObserveCuts,"wrong observe node cuts num");
    }
  }


  aig2CnfIdClose(ddm);

  /* make checks with incremental sat */

  for (i=0; i<visitedNodes->num; i++) {
    //    Ddi_Bddarray_t *wireLits = Ddi_BddarrayAlloc(ddm,0);
    int id = cutIndex[i], enableCheck=1;
    bAigEdge_t redConstant = bAig_NULL;
    bAigEdge_t baig1, baig = visitedNodes->nodes[i];
    bAigEdge_t r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
    bAigEdge_t l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if ((bAig_CacheAig(bmgr,r)!=bAig_NULL) ||
        (bAig_CacheAig(bmgr,l)!=bAig_NULL)) {
      /* fanin node observable through ref=1 wire => baig observable */
      if (enCached) enableCheck = 0;
      rrStatsP->nCached++;
      checkedNotRed = 1;
    }

    if (timeLimit >= 0 &&
        ((util_cpu_time () - startTimeTot)/1000.0 > timeLimit)) {
      enableCheck = 0;
    }

    if (enableCheck && id >= 0 && (!bAig_isVarNode(bmgr,baig))) {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
      bAig_Ref(bmgr, baig1);
      if (bAig_NodeIsConstant(baig1)) {
	enableCheck=0;
	redConstant = baig1;
      }
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig1));
    }

    if (enableCheck && id >= 0 && nodeClass[i]==1) {
      Ddi_Bdd_t *cutL=Ddi_BddarrayRead(cutLits,id*2);
      Ddi_Bdd_t *wireL=Ddi_BddarrayRead(cutLits,id*2+1);
      bAigEdge_t cutBaig, wireBaig, fBaig;
      int c;
      Lit saveLit;
      int idAss = nAssumps-id-1;
      long cpuTime=0, startTime=0;

      cutBaig = Ddi_BddToBaig(cutL);
      wireBaig = Ddi_BddToBaig(wireL);

      fBaig = bAig_AuxAig0(bmgr,baig);
      Pdtutil_Assert(fBaig != bAig_NULL,"NULL baig");

      //      c = aig2CnfId(bmgr,cutBaig);
      c = cnfCutIds [i];
      Pdtutil_Assert(c>=0,"wrong cut cnf id");

      saveLit = assumpsReverse[idAss];

      rrStatsP->nChecks++;

      assumpsReverse[idAss] = MinisatLit(c);
      if ((sat = S.okay())) {
	if (!satIncremental) {
       	  S.resetDB();
	}
	if (observeOut >= 0) {
          assumpsReverse.push(MinisatLit(observeOut));
	}
        startTime = util_cpu_time ();
        sat = S.solve(assumpsReverse,time_limit*time_factor);
        cpuTime = util_cpu_time () - startTime;
        if (time_factor>1 && cpuTime/1000.0>time_limit) {
	  time_factor /= 2;
	}
	if (observeOut >= 0) {
          assumpsReverse.pop();
          if (sat && !S.undefined()) {
            assumpsReverse.push(MinisatLit(-observeOut));
	    startTime = util_cpu_time ();
	    sat = S.solve(assumpsReverse,time_limit*time_factor);
	    cpuTime = util_cpu_time () - startTime;
            if (time_factor>1 && cpuTime/1000.0>time_limit) {
	      time_factor /= 2;
	    }
	    assumpsReverse.pop();
	  }
	}

      }
      if (S.undefined()) {
	rrStatsP->nAbort++;
	if (doApproxOnAbort) {
          sat = 0;
	}
	else {
          Ddi_Bdd_t *newf =
            checkRedPartialIntern(fAig,careAig,visitedNodes,i,1,
              time_limit*time_factor);
	  sat = newf==NULL;
	  Ddi_Free(newf);
	  //          sat = 1;
	}
      }
      if (!sat) {
        /* redundancy found ! Replace with 1 constant */
        rrStatsP->nRed++;
	redConstant = bAig_One;
        /* c */
        MinisatClause1(S,lits,c);
	Pdtutil_Assert(enableCheck,"wrong cached enable");
      }
      else {
        assumpsReverse[idAss] = MinisatLit(-c);
        if ((sat = S.okay())) {
	  if (!satIncremental) {
	    S.resetDB();
 	  }
	  if (observeOut >= 0) {
            assumpsReverse.push(MinisatLit(observeOut));
	  }
          startTime = util_cpu_time ();
          sat = S.solve(assumpsReverse,time_limit*time_factor);
          cpuTime = util_cpu_time () - startTime;

	  if (observeOut >= 0) {
            assumpsReverse.pop();
            if (sat && !S.undefined()) {
              assumpsReverse.push(MinisatLit(-observeOut));
	      startTime = util_cpu_time ();
	      sat = S.solve(assumpsReverse,time_limit*time_factor);
	      cpuTime = util_cpu_time () - startTime;
              if (time_factor>1 && cpuTime/1000.0>time_limit) {
	        time_factor /= 2;
	      }
	      assumpsReverse.pop();
	    }
	  }

        }
        if (S.undefined()) {
	  rrStatsP->nAbort++;
	  if (doApproxOnAbort) {
            sat = 0;
    	  }
	  else {
            Ddi_Bdd_t *newf =
              checkRedPartialIntern(fAig,careAig,visitedNodes,i,0,
                time_limit*time_factor);
	    sat = newf==NULL;
	    Ddi_Free(newf);
	    //            sat = 1;
	  }
        }
        if (!sat) {
          /* redundancy found ! Replace with 1 constant */
          rrStatsP->nRed++;
	  redConstant = bAig_Zero;
          /* !c */
          MinisatClause1(S,lits,-c);
  	  Pdtutil_Assert(enableCheck,"wrong cached emable");
        }
	else {
          checkedNotRed = 1;
	  /* resume old assump */
	  //          assumps[id] = saveLit;
          lits.clear();
          /* w */
          lits.push(saveLit);
          S.addClause(lits);
	}
      }

      if (rrStatsP->nChecks%20 == 0) {
        fprintf(dMgrO(ddm),"."); fflush(dMgrO(ddm));
      }
      assumpsReverse.pop();
    }
    else if (id >= 0 && nodeClass[i]==1) {
      /* cached observable point */
      lits.clear();
      /* w */
      lits.push(assumpsReverse[nAssumps-id-1]);
      S.addClause(lits);
      assumpsReverse.pop();
    }

    if (redConstant != bAig_NULL) {
      /* set constant */
      baig1 = redConstant;
    }
    else if (bAig_isVarNode(bmgr,baig)) {
      baig1 = bAig_NonInvertedEdge(baig);
      if (nRef[i]==1 && checkedNotRed) {
	/* node observable through ref=1 wire */
        bAig_CacheAig(bmgr,baig) = bAig_NonInvertedEdge(baig);
      }
    }
    else {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
      if (nRef[i]==1 && !bAig_NodeIsConstant(baig1) && checkedNotRed) {
	/* node observable through ref=1 wire */
        bAig_CacheAig(bmgr,baig) = bAig_NonInvertedEdge(baig);
      }
#if 0
      /* disable this caching */
      bAig_CacheAig(bmgr,baig1) = bAig_NonInvertedEdge(baig1);
      bAig_Ref(bmgr, baig1);
      bAigArrayWriteLast(cachedNodes,baig1);
#endif
    }
    bAig_Ref(bmgr, baig1);
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_AuxAig1(bmgr,baig) = baig1;

  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1;
    bAigEdge_t baig = visitedNodes->nodes[i];

    baig1 = bAig_AuxAig0(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
  }


  rrStatsP->decisions        += S.stats.decisions;
  rrStatsP->conflicts        += S.stats.conflicts;
  rrStatsP->propagations     += S.stats.propagations;
  rrStatsP->learnts_literals += S.stats.learnts_literals;

  Pdtutil_Free(eqVars);
  Pdtutil_Free(nodeClass);
  Pdtutil_Free(cutIndex);
  Pdtutil_Free(cnfCutIds);
  bAigArrayFree(visitedNodes1);
  Ddi_Free(observeSelect);
  Ddi_Free(fAig);
  Ddi_Free(careAig);

}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
AigRedRemovalIncrByRefinementIntern (
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  bAig_array_t *fBaigs,
  bAigEdge_t careBaig,
  int maxCutNum,
  int *enChk,
  int *nRef,
  bAig_array_t *cachedNodes,
  redrem_stats *rrStatsP,
  int *nodeClass,
  float timeLimitSingle,
  float timeLimitTotal,
  int redVal,
  int runMode,
  int *singleDone
)
{
  vec<Lit> lits, observeLits, assumps, prevCex, cex, multiple;
  vec<Lit> assumeRedundancyArray, assumeSingleRedundancyArray;
  int *cutIndex, i, j, k, nRedCand, nCuts, il, ir, id;
  int f, f0, f1, eq01, a, b, c, w, sat, assumeSingleRedundancy;
  int *fwdDisableRed=NULL, *bwdDisableRed=NULL, *redCodeBits=NULL;
  int *flipped=NULL, *redIds=NULL, nMultRedCand;
  int redIndex, *assumpsPos=NULL, *assumpsPosReverse=NULL;
  int incrByRefinement=ddm->settings.aig.satIncrByRefinement;
  int binary=1, redCodeSize, nCurrRedCand, nSingleRed=0;
  int prevCexUsed, checkSingleRed, refinementDone=0, mask, refCnf;
  int redundantClauses=0, fullCheckDone=0, goAhead=1, enComputeNew=1;
  int rCnf, lCnf, fCnf, cCnf, wCnf, lInv, rInv, checkInp, bit;
  Ddi_Bdd_t *cutL, *wireL, *careAig=Ddi_BddMakeFromBaig(ddm,careBaig);
  bAigEdge_t baig, baig1, cutBaig, wireBaig, fBaig, right, left;
  bAig_array_t *visitedNodes1, *inputNodes;
  bAig_Manager_t *bmgr=ddm->aig.mgr;
  Ddi_Var_t *cutV, *wireV;
  Ddi_Bddarray_t *cutLits;
  unsigned long time_limit = ~0;
  char name[10000];
  Lit wireLit;
  Solver S;

  aig2CnfIdInit(ddm);
  assumps.clear();
  observeLits.clear();

  if (timeLimitTotal > 0) {
    time_limit = util_cpu_time() + (unsigned long)(timeLimitTotal*1000);
    if (timeLimitSingle<0 || timeLimitSingle>timeLimitTotal) {
      timeLimitSingle = timeLimitTotal;
    }
  }
  if (0 && runMode!=1) {
    timeLimitSingle = 0.1;
  }

  cutLits = ddm->aig.auxLits;
  Pdtutil_Assert(cutLits!=NULL,"cutlits array required");
  cutIndex = Pdtutil_Alloc(int,visitedNodes->num);
  flipped = Pdtutil_Alloc(int,visitedNodes->num);
  inputNodes = bAigArrayAlloc();
  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
    Pdtutil_Assert(bAig_AuxAig1(bmgr,baig) == bAig_NULL, "NULL baig1 required");
    bAig_AuxAig1(bmgr,baig) = bAig_NonInvertedEdge(baig);
    bAig_Ref(bmgr, baig);
    if (bAig_isVarNode(bmgr, baig)) {
      bAigArrayWriteLast(inputNodes, bAig_NonInvertedEdge(baig));
    }
  }

  /* build modified circuit */
  for (i=nCuts=0; i<visitedNodes->num; i++) {
    cutIndex[i] = -1;
    flipped[i] = 0;
    baig = visitedNodes->nodes[i];
    baig1 = bAig_AuxAig1(bmgr,baig);
    if (bAig_NodeIsConstant(baig1)) {
      continue;
    }

    if (!bAig_isVarNode(bmgr, baig)) {
      /* compute baig1 */
      bAigEdge_t r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig1));
      baig1 = bAig_And(bmgr,right,left);
      l = bAig_NodeReadIndexOfLeftChild(bmgr,baig1);
      r = bAig_NodeReadIndexOfRightChild(bmgr,baig1);
      Pdtutil_Assert((left == l) || (left == r), "wrong node children");
      Pdtutil_Assert((right == l) || (right == r), "wrong node children");
      flipped[i] = (left==r);
    }

    if (enChk[i]) {
      Pdtutil_Assert(nodeClass[i]>5,"wrong node class");
      bAig_Ref(bmgr, baig1);
      bAig_AuxAig0(bmgr,baig) = baig1;

      /* create cut var and wire connection var */
      if (Ddi_BddarrayNum(cutLits)/2 <= nCuts) {
        sprintf(name,"_RED_REM_CUTV_%d",nCuts);
        Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
        Pdtutil_Assert(bAig_VarNodeFromName(bmgr,name)==bAig_NULL,"duplicate baig name");
	cutV = Ddi_VarNew(ddm);
        Ddi_VarAttachName (cutV, name);
        sprintf(name,"_RED_REM_WIREV_%d",nCuts);
        Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
	wireV = Ddi_VarNew(ddm);
        Ddi_VarAttachName (wireV, name);
        cutL = Ddi_BddMakeLiteralAig(cutV,1);
        wireL = Ddi_BddMakeLiteralAig(wireV,1);
	Ddi_BddarrayInsertLast(cutLits,cutL);
	Ddi_BddarrayInsertLast(cutLits,wireL);
	Ddi_Free(cutL);
	Ddi_Free(wireL);
      }
      cutL = Ddi_BddarrayRead(cutLits,nCuts*2);
      cutIndex[i] = nCuts++;
      baig1 = Ddi_BddToBaig(cutL);
    }
    bAig_Ref(bmgr, baig1);
    bAig_AuxAig1(bmgr,baig) = baig1;
  }

  /* generate clauses */
  visitedNodes1 = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,careBaig,visitedNodes1,-1);
  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    baig1 = bAig_AuxAig1(bmgr,baig);
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    postOrderAigVisitIntern(bmgr,baig,visitedNodes1,-1);
    postOrderAigVisitIntern(bmgr,baig1,visitedNodes1,-1);
    if (cutIndex[i] >= 0) {
      baig1 = bAig_AuxAig0(bmgr,baig);
      postOrderAigVisitIntern(bmgr,baig1,visitedNodes1,-1);
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes1);

  for (i=0; i<visitedNodes1->num; i++) {
    baig = visitedNodes1->nodes[i];
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if (!bAig_isVarNode(bmgr,baig)) {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

      /* convert AIG node to cnf clauses */
      /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
      f = aig2CnfId(bmgr,baig);
      a = bAig_NodeIsInverted(right) ? -aig2CnfId(bmgr,right) : aig2CnfId(bmgr,right);
      b = bAig_NodeIsInverted(left) ? -aig2CnfId(bmgr,left) : aig2CnfId(bmgr,left);

      /* f -a -b */
      MinisatClause3(S,lits,f,-a,-b);
      /* -f a */
      MinisatClause2(S,lits,-f,a);
      /* -f b */
      MinisatClause2(S,lits,-f,b);
    } else {
      f = aig2CnfId(bmgr,baig);
    }
  }

  /* care */
  c = bAig_NodeIsInverted(careBaig) ? -aig2CnfId(bmgr,careBaig) : aig2CnfId(bmgr,careBaig);
  MinisatClause1(S,lits,c);

  /* switches */
  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    id = cutIndex[i];
    if (id >= 0) {
      cutL = Ddi_BddarrayRead(cutLits,id*2);
      wireL = Ddi_BddarrayRead(cutLits,id*2+1);

      cutBaig = Ddi_BddToBaig(cutL);
      wireBaig = Ddi_BddToBaig(wireL);
      Pdtutil_Assert(nodeClass[i]>=6,"Wrong node class");
      fBaig = bAig_AuxAig0(bmgr,baig);
      Pdtutil_Assert(fBaig != bAig_NULL,"NULL baig");

      fCnf = aig2CnfId(bmgr,fBaig);
      wCnf = aig2CnfId(bmgr,wireBaig);
      cCnf = aig2CnfId(bmgr,cutBaig);

      /* w => c=f */
      /* f -c -w */
      MinisatClause3(S,lits,fCnf,-cCnf,-wCnf);
      /* -f c -w */
      MinisatClause3(S,lits,-fCnf,cCnf,-wCnf);
      assumps.push(MinisatLit(-wCnf));
      if (incrByRefinement==1 && redVal>=0) {
	/* force constant val with w=0 */
        /* !w => redVal ? c : !c */
        /* w redVal ? c : -c */
	MinisatClause2(S,lits,(redVal?cCnf:-cCnf),wCnf); /* !!!!!!! */
      }

      /* clauses for intermediate classes */
      checkInp = incrByRefinement>2 && !bAig_isVarNode(bmgr,baig);
      if (checkInp) {
	right = bAig_NodeReadIndexOfRightChild(bmgr,fBaig);
	left = bAig_NodeReadIndexOfLeftChild(bmgr,fBaig);
	rCnf = aig2CnfId(bmgr,right);
	lCnf = aig2CnfId(bmgr,left);
	rInv = bAig_NodeIsInverted(right);
	lInv = bAig_NodeIsInverted(left);
	rCnf = rInv ? -rCnf : rCnf;
	lCnf = lInv ? -lCnf : lCnf;
      }
      if (0&&flipped[i]) {
	switch (nodeClass[i]) {
	  case 11: nodeClass[i] = 12; break;
	  case 12: nodeClass[i] = 11; break;
	  case 13: nodeClass[i] = 14; break;
	  case 14: nodeClass[i] = 13; break;
	}
      }
      switch (nodeClass[i]) {
        //case 1: /* not redundant at all */
        //case 2: /* not redundant at all */
        //case 3: /* not redundant at all */
        //case 4: /* not redundant at all */
        case 6: /* full redundant candidate: nothing to do */
	  break;
        case 8:
	  if (checkInp) {
	    /* !lCnf * !rCnf => !cCnf */
	    MinisatClause3(S,lits,lCnf,rCnf,-cCnf);
	  } else {
	    /* !wCnf => !cCnf */
	    MinisatClause2(S,lits,wCnf,-cCnf);
	  }
	  break;
        case 9:
	  if (checkInp) {
	    /* lCnf * rCnf => cCnf */
	    MinisatClause3(S,lits,-lCnf,-rCnf,cCnf);
	  } else {
	    /* !wCnf => cCnf */
	    MinisatClause2(S,lits,wCnf,cCnf);
	  }
	  break;
        case 10:
	  assert(checkInp);
	  /* lCnf * rCnf => cCnf */
	  MinisatClause3(S,lits,-lCnf,-rCnf,cCnf);
	  /* !lCnf * !rCnf => !cCnf */
	  MinisatClause3(S,lits,lCnf,rCnf,-cCnf);
	  break;
        case 11:
	  assert(checkInp);
	  /* lCnf * rCnf => cCnf */
	  MinisatClause3(S,lits,-lCnf,-rCnf,cCnf);
	  /* !rCnf => !cCnf */
	  MinisatClause2(S,lits,rCnf,-cCnf);
	  break;
        case 12:
	  assert(checkInp);
	  /* lCnf * rCnf => cCnf */
	  MinisatClause3(S,lits,-lCnf,-rCnf,cCnf);
	  /* !lCnf => !cCnf */
	  MinisatClause2(S,lits,lCnf,-cCnf);
	  break;
        case 13:
	  assert(checkInp);
	  /* !rCnf => !cCnf */
	  MinisatClause2(S,lits,rCnf,-cCnf);
	  break;
        case 14:
	  assert(checkInp);
	  /* !lCnf => !cCnf */
	  MinisatClause2(S,lits,lCnf,-cCnf);
	  break;
        case 16:
	  assert(checkInp);
	  /* !rCnf => !cCnf */
	  MinisatClause2(S,lits,rCnf,-cCnf);
	  /* !lCnf => !cCnf */
	  MinisatClause2(S,lits,lCnf,-cCnf);
	  break;
        default:
	  /* invalid class */
	  assert(0);
      }
    }
  }

  /* outputs */
  observeLits.clear();
  for (i=0; i<fBaigs->num; i++) {
    baig = fBaigs->nodes[i];
    baig1 = bAig_AuxAig1(bmgr,baig);
    f0 = aig2CnfId(bmgr,bAig_NonInvertedEdge(baig));
    f1 = bAig_NodeIsInverted(baig1) ? -aig2CnfId(bmgr,baig1) : aig2CnfId(bmgr,baig1); /* ??? */
    if (f0 != f1) {
      S.newVar();
      eq01 = S.nVars();
      /* !eq01 => (f0!=f1) */
      /* -f0 -f1 eq01 */
      MinisatClause3(S,lits,-f0,-f1,eq01);
      /* f0 f1 eq01 */
      MinisatClause3(S,lits,f0,f1,eq01);
      observeLits.push(MinisatLit(-eq01));
    }
  }
  S.addClause(observeLits);

  if (ddm->settings.aig.satCompare) {
    /* check data structure */
    int n1, n2;
    for (i=n1=n2=0; i<visitedNodes->num; i++) {
      if (nodeClass[i]>=6) n1++;
    }
    Pdtutil_Assert(n1==nCuts,"wrong node cuts num");
  }

  /* make checks with incremental sat */
  S.newVar();
  assumeSingleRedundancy = S.nVars();
  assumeSingleRedundancyArray.clear();
  assumeSingleRedundancyArray.push(MinisatLit(assumeSingleRedundancy));
  assumeRedundancyArray.clear();

  if (runMode == 0) {
    /* assume single redundancy filter */
    fprintf(dMgrO(ddm),"SINGLE RED: ");
    MinisatClause1(S,lits,assumeSingleRedundancy);
    assumeSingleRedundancyArray.clear();
    checkSingleRed = 1;
    enComputeNew = 0;
    *singleDone = 0;
  } else if (runMode == 1) {
    /* disable single redundancy filter */
    fprintf(dMgrO(ddm),"MULTIPLE RED: ");
    MinisatClause1(S,lits,-assumeSingleRedundancy);
    assumeSingleRedundancyArray.clear();
    checkSingleRed = 0;
    enComputeNew = 1;
    refinementDone = 1;
    *singleDone = 1;
  } else {
    fprintf(dMgrO(ddm),"COMBINED RED: ");
    checkSingleRed = 1;
    enComputeNew = 1;
    *singleDone = 0;
  }

  redIds = Pdtutil_Alloc(int, visitedNodes->num);
  fwdDisableRed = Pdtutil_Alloc(int, visitedNodes->num);
  bwdDisableRed = Pdtutil_Alloc(int, visitedNodes->num);
  nRedCand = 0;
  for (i=j=0; i<visitedNodes->num; i++) {
    id = cutIndex[i];
    baig = visitedNodes->nodes[i];
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if (id>=0) {
      if (!binary) {
	S.newVar();
	fwdDisableRed[j] = S.nVars();
	S.newVar();
	bwdDisableRed[j] = S.nVars();
      }
      redIds[j++] = i;
    }
  }
  nRedCand = j;
  if (checkSingleRed) {
    if (binary) {
      redCodeSize = 1;
      for (j=2; j<nRedCand; j=j<<1) {
	redCodeSize++;
      }
      redCodeBits = Pdtutil_Alloc(int, redCodeSize);
      for (j=0; j<redCodeSize; j++) {
	S.newVar();
	redCodeBits[j] = S.nVars();
      }
    }

    for (j=0; j<nRedCand; j++) {
      i = redIds[j];
      id = cutIndex[i];
      wireLit = assumps[id];
      wCnf = var(wireLit)+1;
      baig = visitedNodes->nodes[i];
      refCnf = aig2CnfId(bmgr,baig);
      if (incrByRefinement==1 && redVal>=0) {
	/* force constant val on ref circuit with w=0 */
	/* !wCnf => !assumeSingleRedundancy + redVal ? !refCnf : refCnf */
	MinisatClause3(S,lits,wCnf, -assumeSingleRedundancy,(redVal?-refCnf:refCnf));
      }

      if (binary) {
	for (k=0, mask=1; k<redCodeSize; k++) {
	  bit = (j&mask) ? redCodeBits[k] : -redCodeBits[k];
	  /* !wCnf => !assumeSingleRedundancy + bit */
	  MinisatClause3(S,lits,wCnf,-assumeSingleRedundancy,bit);
	  mask = mask<<1;
	}
      } else {
	/* fwd[i] => wCnf */
	MinisatClause3(S,lits,-fwdDisableRed[j],wCnf,-assumeSingleRedundancy);
	/* bwd[i] => wCnf */
	MinisatClause3(S,lits,-bwdDisableRed[j],wCnf,-assumeSingleRedundancy);
	/* fwd[i] => fwd[i+1] */
	/* !wCnf  => fwd[i+1] */
	if (j<nRedCand-1) {
	  MinisatClause3(S,lits,-fwdDisableRed[j],fwdDisableRed[j+1],-assumeSingleRedundancy);
	  MinisatClause3(S,lits,wCnf,fwdDisableRed[j+1],-assumeSingleRedundancy);
	}
	/* bwd[i] => bwd[i-1] */
	/* !wCnf  => bwd[i-1] */
	if (j > 0) {
	  MinisatClause3(S,lits,-bwdDisableRed[j],bwdDisableRed[j-1],-assumeSingleRedundancy);
	  MinisatClause3(S,lits,wCnf,bwdDisableRed[j-1],-assumeSingleRedundancy);
	}
      }
      /* at least one redundancy active */
      assumeRedundancyArray.push(MinisatLit(-wCnf));
    }
    S.addClause(assumeRedundancyArray);
  }

  nMultRedCand = nCurrRedCand = nRedCand;
  prevCexUsed = 0;
  cex.clear();
  prevCex.clear();
  //assumeSingleRedundancyArray.copyTo(prevCex);
  multiple.clear();
  if (!checkSingleRed) {
    assumps.copyTo(multiple);
    assumpsPos = Pdtutil_Alloc(int, nRedCand);
    assumpsPosReverse = Pdtutil_Alloc(int, nRedCand);
    for (i=0; i<nRedCand; i++) {
      assumpsPos[i] = assumpsPosReverse[i] = i;
    }
  }

  do {
    refinementDone = 0;
    rrStatsP->nChecks++;

    /* call SAT solver assuming at list one refinement */
    if ((sat = S.okay())) {
      assumeSingleRedundancyArray.copyTo(prevCex);
      cex.appendTo(prevCex);
      if (!checkSingleRed) {
#if 0
        multiple.clear();
        for (redIndex=0; redIndex<nRedCand; redIndex++) {
          i = redIds[redIndex];
          if (enChk[i]) {
            id = cutIndex[i];
            assert(id >= 0);
            wireL = Ddi_BddarrayRead(cutLits,id*2+1);
            wireBaig = Ddi_BddToBaig(wireL);
            wCnf = aig2CnfId(bmgr,wireBaig);
            multiple.push(MinisatLit(-wCnf));
          }
        }
#endif
        multiple.appendTo(prevCex);
      }
      sat = S.solve(prevCex, timeLimitSingle);
    }

    if (sat) {
      /* a non redundant node has been found: fix it and iterate */
      refinementDone = 1;
      if (binary && checkSingleRed) {
	redIndex = 0;
        for (k=0, mask=1; k<redCodeSize; k++) {
	  if (S.model[redCodeBits[k]-1]==l_True) {
	    redIndex += mask;
	  }
          mask = mask<<1;
        }
	assert(redIndex < nRedCand);
	i = redIds[redIndex];
	id = cutIndex[i];
      } else {
	for (redIndex=0; redIndex<nRedCand; redIndex++) {
	  i = redIds[redIndex];
	  id = cutIndex[i];
	  cutL = Ddi_BddarrayRead(cutLits,id*2);
	  cutBaig = Ddi_BddToBaig(cutL);
	  cCnf = aig2CnfId(bmgr,cutBaig);
	  c = cCnf-1;
	  baig = visitedNodes->nodes[i];
	  Pdtutil_Assert(cutBaig == bAig_AuxAig1(bmgr,baig), "wrong cut");
	  baig = bAig_AuxAig0(bmgr, baig);
	  f = aig2CnfId(bmgr,baig)-1;
	  if (S.model[f] != S.model[c]) {
	    break;
	  }
	}
      }

      wireLit = assumps[id];
      w = var(wireLit);
      wCnf = w+1;
      Pdtutil_Assert(S.model[w]==l_False,"wrong model value");
      if (incrByRefinement==1) {
	Pdtutil_Assert (nodeClass[i]==6,"wrong node class");
	MinisatClause1(S,lits,wCnf);
	nodeClass[i] = 1; /* NOT redundant */
	enChk[i] = 0;
	nCurrRedCand--;
      } else {
	int l, r;
	cutL = Ddi_BddarrayRead(cutLits,id*2);
	cutBaig = Ddi_BddToBaig(cutL);
	cCnf = aig2CnfId(bmgr,cutBaig);
	c = cCnf-1;
	baig = visitedNodes->nodes[i];
	checkInp = incrByRefinement>2 && !bAig_isVarNode(bmgr,baig);
	Pdtutil_Assert(cutBaig == bAig_AuxAig1(bmgr,baig), "wrong cut");
	baig = bAig_AuxAig0(bmgr, baig);
	f = aig2CnfId(bmgr,baig)-1;
	Pdtutil_Assert(S.model[f] != S.model[c], "wrong model value");

	if (checkInp) {
	  right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
	  left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
	  rCnf = aig2CnfId(bmgr,right);
	  lCnf = aig2CnfId(bmgr,left);
	  r=rCnf-1, l=lCnf-1;
	  rInv = bAig_NodeIsInverted(right);
	  lInv = bAig_NodeIsInverted(left);
	  rCnf = rInv ? -rCnf : rCnf;
	  lCnf = lInv ? -lCnf : lCnf;
	}
	switch (nodeClass[i]) {
	  case 6:
	    if (S.model[c] == l_False) {
	      /* difference found with 0 value. Look for 1 */
	      if (checkInp) {
		Pdtutil_Assert(lInv^(S.model[l]==l_True), "wrong model value");
		Pdtutil_Assert(rInv^(S.model[r]==l_True), "wrong model value");
		/* lCnf * rCnf => cCnf */
		MinisatClause3(S,lits,-lCnf,-rCnf,cCnf);
	      } else {
		/* !wCnf => cCnf */
		MinisatClause2(S,lits,wCnf,cCnf);
	      }
	      nodeClass[i] = 9;
	    } else {
	      /* difference found with 1 value. Look for 0 */
	      if (checkInp) {
		Pdtutil_Assert(lInv^(S.model[l]==l_False) || rInv^(S.model[r]==l_False), "wrong model value");
		if (lInv^(S.model[l]==l_True) && rInv^(S.model[r]==l_False)) {
		  /* !rCnf => !cCnf */
		  MinisatClause2(S,lits,rCnf,-cCnf);
		  nodeClass[i] = 13;
		} else if (lInv^(S.model[l]==l_False) && rInv^(S.model[r]==l_True)) {
		  /* !lCnf => !cCnf */
		  MinisatClause2(S,lits,lCnf,-cCnf);
		  nodeClass[i] = 14;
		} else {
		  Pdtutil_Assert(lInv^(S.model[l]==l_False), "wrong model value");
		  Pdtutil_Assert(rInv^(S.model[r]==l_False), "wrong model value");
		  /* !lCnf * !rCnf => !cCnf */
		  MinisatClause3(S,lits,lCnf,rCnf,-cCnf);
		  nodeClass[i] = 8;
		}
	      } else {
	        /* !wCnf => !cCnf */
  	        MinisatClause2(S,lits,wCnf,-cCnf);
		nodeClass[i] = 8;
	      }
	    }
	    break;
	  case 8:
	    if (checkInp) {
	      if (S.model[c] == l_False) {
		Pdtutil_Assert(lInv^(S.model[l]==l_True), "wrong model value");
		Pdtutil_Assert(rInv^(S.model[r]==l_True), "wrong model value");
		/* difference found with 0 value. 1 already found */
                /* Look for red. pi */
	        /* lCnf * rCnf => cCnf */
  	        MinisatClause3(S,lits,-lCnf,-rCnf,cCnf);
		nodeClass[i] = 10;
	      } else {
		Pdtutil_Assert(lInv^(S.model[l]==l_False) || rInv^(S.model[r]==l_False), "wrong model value");
		Pdtutil_Assert(lInv^(S.model[l]==l_True) || rInv^(S.model[r]==l_True), "wrong model value");

	        if (lInv^(S.model[l]==l_True)) {
		  Pdtutil_Assert(rInv^(S.model[r]==l_False), "wrong model value");
	          /* difference found with 1 on left PI. Look for right */
	          /* !rCnf => !cCnf */
	          MinisatClause2(S,lits,rCnf,-cCnf);
	          nodeClass[i] = 13;
	        } else {
		  Pdtutil_Assert(lInv^(S.model[l]==l_False), "wrong model value");
		  Pdtutil_Assert(rInv^(S.model[r]==l_True), "wrong model value");
	          /* difference found with 1 on right PI. Look for left */
	          /* !lCnf => !cCnf */
	          MinisatClause2(S,lits,lCnf,-cCnf);
	          nodeClass[i] = 14;
	        }
	      }
	    } else {
	      MinisatClause1(S,lits,wCnf);
	      nodeClass[i] = 1; /* NOT redundant */
	      enChk[i] = 0;
	      nCurrRedCand--;
	    }
	    break;
	  case 9:
	    Pdtutil_Assert(S.model[c]==l_True, "wrong model value");
	    if (checkInp) {
	      Pdtutil_Assert(lInv^(S.model[l]==l_False) || rInv^(S.model[r]==l_False), "wrong model value");
	      /* difference found with 1 value. 0 already found */
	      /* Look for red. pi */
	      if (lInv^(S.model[l]==l_False) && rInv^(S.model[r]==l_False)) {
		/* !lCnf * !rCnf => !cCnf */
		MinisatClause3(S,lits,lCnf,rCnf,-cCnf);
		nodeClass[i] = 10;
	      } else if (lInv^(S.model[l]==l_True)) {
		Pdtutil_Assert(rInv^(S.model[r]==l_False), "wrong model value");
		/* !rCnf => !cCnf */
		MinisatClause2(S,lits,rCnf,-cCnf);
		nodeClass[i] = 11;
	      } else {
		Pdtutil_Assert(lInv^(S.model[l]==l_False), "wrong model value");
		Pdtutil_Assert(rInv^(S.model[r]==l_True), "wrong model value");
		/* !lCnf => !cCnf */
		MinisatClause2(S,lits,lCnf,-cCnf);
		nodeClass[i] = 12;
	      }
	    } else {
	      MinisatClause1(S,lits,wCnf);
	      nodeClass[i] = 1; /* NOT redundant */
	      enChk[i] = 0;
	      nCurrRedCand--;
	    }
	    break;
	  case 10:
	    Pdtutil_Assert(S.model[c] == l_True, "wrong model value");
	    Pdtutil_Assert(lInv^(S.model[l]==l_False) || rInv^(S.model[r]==l_False), "wrong model value");
	    Pdtutil_Assert(lInv^(S.model[l]==l_True) || rInv^(S.model[r]==l_True), "wrong model value");
	    if (lInv^(S.model[l]==l_True)) {
	      Pdtutil_Assert(rInv^(S.model[r]==l_False), "wrong model value");
	      /* difference found with 1 on left PI. Look for right */
	      /* !rCnf => !cCnf */
	      MinisatClause2(S,lits,rCnf,-cCnf);
	      nodeClass[i] = 11;
	    }
	    else {
	      Pdtutil_Assert(lInv^(S.model[l]==l_False), "wrong model value");
	      Pdtutil_Assert(rInv^(S.model[r]==l_True), "wrong model value");
	      /* difference found with 1 on right PI. Look for left */
	      /* !lCnf => !cCnf */
	      MinisatClause2(S,lits,lCnf,-cCnf);
	      nodeClass[i] = 12;
	    }
	    break;
	  case 11:
	  case 12:
	    Pdtutil_Assert (S.model[c] == l_True, "wrong model value");
	  case 16:
	    MinisatClause1(S,lits,wCnf);
            nodeClass[i] = 1; /* NOT redundant */
	    enChk[i] = 0;
	    nCurrRedCand--;
	    break;
	  case 13:
	    if (S.model[c] == l_False) {
	      Pdtutil_Assert(rInv^(S.model[r]==l_True), "wrong model value");
	      Pdtutil_Assert(lInv^(S.model[l]==l_True), "wrong model value");
	      /* difference found with 0 value. 1 already found */
              /* Look for red. pi */
	      /* lCnf * rCnf => cCnf */
  	      MinisatClause3(S,lits,-lCnf,-rCnf,cCnf);
	      nodeClass[i] = 11;
	    } else {
	      Pdtutil_Assert(S.model[c]==l_True, "wrong model value");
	      Pdtutil_Assert(rInv^(S.model[r]==l_True), "wrong model value");
	      Pdtutil_Assert(lInv^(S.model[l]==l_False), "wrong model value");
	      /* !lCnf => !cCnf */
  	      MinisatClause2(S,lits,lCnf,-cCnf);
	      nodeClass[i] = 16;
	    }
	    break;
	  case 14:
	    if (S.model[c] == l_False) {
	      Pdtutil_Assert(rInv^(S.model[r]==l_True), "wrong model value");
	      Pdtutil_Assert(lInv^(S.model[l]==l_True), "wrong model value");
	      /* difference found with 0 value. 1 already found */
              /* Look for red. pi */
	      /* lCnf * rCnf => cCnf */
  	      MinisatClause3(S,lits,-lCnf,-rCnf,cCnf);
	      nodeClass[i] = 12;
	    } else {
	      Pdtutil_Assert(S.model[c]==l_True, "wrong model value");
	      Pdtutil_Assert(lInv^(S.model[l]==l_True), "wrong model value");
	      Pdtutil_Assert(rInv^(S.model[r]==l_False), "wrong model value");
	      /* !rCnf => !cCnf */
  	      MinisatClause2(S,lits,rCnf,-cCnf);
	      nodeClass[i] = 16;
	    }
	    break;
	  default:
            Pdtutil_Assert (0,"wrong node class");
	} // end switch
      } //end if (incrByRefinement != 1)

      if (!checkSingleRed && nCurrRedCand<nMultRedCand) {
#if 0
	for (j=0; j<=nCurrRedCand; j++) {
	  assert(assumpsPosReverse[j] >= 0);
	  assert(assumpsPosReverse[j] < nRedCand);
	  assert(assumpsPos[assumpsPosReverse[j]] >= 0);
	  assert(assumpsPos[assumpsPosReverse[j]] <= nCurrRedCand);
	  assert(assumpsPos[assumpsPosReverse[j]] == j);
	}
	for (j=0; j<nRedCand; j++) {
	  if (assumpsPos[j] >= 0) {
	    assert(assumpsPos[j] <= nCurrRedCand);
	    assert(assumpsPosReverse[assumpsPos[j]] >= 0);
	    assert(assumpsPosReverse[assumpsPos[j]] < nRedCand);
	    assert(assumpsPosReverse[assumpsPos[j]] == j);
	  }
	}
#endif
	/* remove wire from multiple assumptions */
	nMultRedCand = nCurrRedCand;

        assert(assumpsPos[id] >= 0);
        assert(assumps[id] == multiple[assumpsPos[id]]);
	multiple.remove(assumpsPos[id]);
	assumpsPosReverse[assumpsPos[id]] = assumpsPosReverse[nCurrRedCand];
	assumpsPos[assumpsPosReverse[nCurrRedCand]] = assumpsPos[id];
	assumpsPos[id] = -1;
#if 0
	for (j=0; j<nCurrRedCand; j++) {
	  assert(assumpsPosReverse[j] >= 0);
	  assert(assumpsPosReverse[j] < nRedCand);
	  assert(assumpsPos[assumpsPosReverse[j]] >= 0);
	  assert(assumpsPos[assumpsPosReverse[j]] <= nCurrRedCand);
	  assert(assumpsPos[assumpsPosReverse[j]] == j);
	}
	for (j=0; j<nRedCand; j++) {
	  if (assumpsPos[j] >= 0) {
	    assert(assumpsPos[j] <= nCurrRedCand);
	    assert(assumpsPosReverse[assumpsPos[j]] >= 0);
	    assert(assumpsPosReverse[assumpsPos[j]] < nRedCand);
	    assert(assumpsPosReverse[assumpsPos[j]] == j);
	  }
	}
#endif
      }

      if (!prevCexUsed) {
	prevCexUsed = 1;
	cex.clear();
	for (i=0; i<inputNodes->num; i++) {
	  baig = inputNodes->nodes[i];

	  //assert(bAig_isVarNode(bmgr,baig));
	  int piCnf = aig2CnfId(bmgr,baig);
	  int pi = piCnf-1;
	  if (S.model[pi]==l_False) {
	    piCnf = -piCnf;
	  }
	  //prevCex.push(MinisatLit(piCnf));
	  cex.push(MinisatLit(piCnf));
	}
      } else {
	rrStatsP->nCached++;
      }
    } else { // that is, unsat or undefined
      cex.clear();
      if (prevCexUsed) {
	refinementDone = 1;
	prevCexUsed = 0;
	//cex.clear();
	prevCex.clear();
	//assumeSingleRedundancyArray.copyTo(prevCex);
      } else if (S.undefined()) {
	goAhead = 0;
	printf("(%d -> %d)\n", nCuts, nCurrRedCand);
      } else if (checkSingleRed) {
	nSingleRed = nCurrRedCand;
	checkSingleRed = 0;
	//cex.clear();
        prevCex.clear();
	assumeSingleRedundancyArray.clear();
        refinementDone = 1;
	*singleDone = 1;
	if (runMode == 0) {
	  fprintf(dMgrO(ddm),"%d -> %d\n", nCuts, nCurrRedCand);
	  goAhead = 0;
	} else {
	  goAhead = (nCurrRedCand>0);
	  if (goAhead) {
	    assumpsPos = Pdtutil_Alloc(int, nRedCand);
	    assumpsPosReverse = Pdtutil_Alloc(int, nRedCand);
	    for (j=0; j<nRedCand; j++) {
	      assumpsPos[j] = assumpsPosReverse[j] = -1;
	    }
	    for (redIndex=0; redIndex<nRedCand; redIndex++) {
	      i = redIds[redIndex];
	      id = cutIndex[i];
	      assert(id == redIndex);
	      assert(id>=0 && id<nRedCand);
	      if (enChk[i]) {
		wireLit = assumps[id];
		assumpsPos[id] = multiple.size();
		assumpsPosReverse[multiple.size()] = id;
		multiple.push(wireLit);
	      } else {
		assumpsPos[id] = -1;
	      }
	    }
	    nMultRedCand = nCurrRedCand;
	  } else {
	    fprintf(dMgrO(ddm),"%d -> 0\n", nCuts);
	  }
	}
      } else {
        /* no refinement possible with SAT */
	assert(runMode > 0);
	fullCheckDone = 1;
	goAhead = 0;
	if (runMode == 1) {
	  fprintf(dMgrO(ddm),"%d -> %d\n", nCuts, nCurrRedCand);
	} else {
	  fprintf(dMgrO(ddm),"%d -> %d -> %d\n", nCuts, nSingleRed, nCurrRedCand);
	}
      }
    }

    if (util_cpu_time() > time_limit) {
      if (goAhead) {
	printf("(%d -> %d)\n", nCuts, nCurrRedCand);
      }
      goAhead = 0;
    }
  } while (refinementDone && goAhead);

  aig2CnfIdClose(ddm);
  for (i=0; enComputeNew && i<visitedNodes->num; i++) {
    //    Ddi_Bddarray_t *wireLits = Ddi_BddarrayAlloc(ddm,0);
    int id = cutIndex[i], enableCheck=1;
    bAigEdge_t redConstant = bAig_NULL;
    baig = visitedNodes->nodes[i];
    bAigEdge_t r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
    bAigEdge_t l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
    int localRedVal = redVal;

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (id >= 0 && (!bAig_isVarNode(bmgr,baig))) {
      /* compute baig1 */
      r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
      bAig_Ref(bmgr, baig1);
      if (bAig_NodeIsConstant(baig1)) {
	redConstant = baig1;
      }
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig1));
    }

    /* nxr added */
    if (!fullCheckDone) {
      nodeClass[i] = 1;
    }

    if (nodeClass[i] == 8 || nodeClass[i] == 9) {
      localRedVal = nodeClass[i]-8;
      nodeClass[i] = 6;
    }
    if (nodeClass[i] == 13 || nodeClass[i] == 14 || nodeClass[i] == 16) {
      localRedVal = 0;
      nodeClass[i] = 6;
    }

    if (nodeClass[i] == 6) {
      /* redundant node */
      nodeClass[i] = 1;
      redConstant = localRedVal ? bAig_One : bAig_Zero;
      rrStatsP->nRed++;
    }

    if (redConstant != bAig_NULL) {
      /* set constant */
      baig1 = redConstant;
    } else if (bAig_isVarNode(bmgr,baig)) {
      baig1 = bAig_NonInvertedEdge(baig);
    } else {
      /* compute baig1 */
      r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);

      if (nodeClass[i] == 10 || nodeClass[i] == 11) {
        /* left child is stuck-at-1: node = right */
        nodeClass[i] = 1;
        baig1 = flipped[i] ? left : right;
      } else if (nodeClass[i] == 12) {
        /* right child is stuck-at-1: node = left */
        nodeClass[i] = 1;
        baig1 = flipped[i] ? right : left;
      } else {
	baig1 = bAig_And(bmgr,right,left);
      }
    }
    bAig_Ref(bmgr, baig1);
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_AuxAig1(bmgr,baig) = baig1;
  }

  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];

    baig1 = bAig_AuxAig0(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
  }
  if (!enComputeNew) {
    for (i=0; i<visitedNodes->num; i++) {
      baig = visitedNodes->nodes[i];
      baig1 = bAig_AuxAig1(bmgr,baig);
      if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
        bAig_RecursiveDeref(bmgr,baig1);
      }

      bAig_AuxAig1(bmgr,baig) = bAig_NULL;
    }

    for (i=0; i<visitedNodes->num; i++) {
      //baig = visitedNodes->nodes[i];
      //bAig_AuxInt(bmgr,baig) = -1;
      //bAig_CacheAig(bmgr,baig) = bAig_NULL;
      if (flipped[i]) {
	switch (nodeClass[i]) {
	  case 11: nodeClass[i] = 12; break;
	  case 12: nodeClass[i] = 11; break;
	  case 13: nodeClass[i] = 14; break;
	  case 14: nodeClass[i] = 13; break;
	}
      }
    }
  }

  rrStatsP->decisions        += S.stats.decisions;
  rrStatsP->conflicts        += S.stats.conflicts;
  rrStatsP->propagations     += S.stats.propagations;
  rrStatsP->learnts_literals += S.stats.learnts_literals;

  Pdtutil_Free(redIds);
  Pdtutil_Free(redCodeBits);
  Pdtutil_Free(fwdDisableRed);
  Pdtutil_Free(bwdDisableRed);
  Pdtutil_Free(cutIndex);
  Pdtutil_Free(flipped);
  Pdtutil_Free(assumpsPos);
  Pdtutil_Free(assumpsPosReverse);
  bAigArrayFree(visitedNodes1);
  bAigArrayFree(inputNodes);
  Ddi_Free(careAig);
}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
AigArrayRedRemovalIncrementalIntern (
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  bAig_array_t *fBaigs,
  bAigEdge_t careBaig,
  int maxCutNum,
  int maxObserve,
  int *enChk,
  int *nRef,
  bAig_array_t *cachedNodes,
  redrem_stats *rrStatsP,
  float timeLimit
)
{
  Solver    S;
  vec<Lit> lits, observeLits;
  vec<Lit> assumps, assumpsReverse;
  Ddi_Bddarray_t *cutLits;
  int *cutIndex, i, nCuts;
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes1;
  int f, a, b, c, aa, bb, sat;
  bAigEdge_t newfBaig, fBaig;
  int redundantClauses = 0;
  int *eqVars=NULL;
  int *nodeClass=NULL;
  unsigned char *observed=NULL;
  int nAssumps;
  double time_limit=-1.0;
  int time_factor = 8;
  int satIncremental = ddm->settings.aig.satIncremental;
  int nOut = fBaigs->num;

  aig2CnfIdInit(ddm);
  assumps.clear();
  assumpsReverse.clear();


  if (ddm->settings.aig.satTimeout) {
    time_limit = 1.0;
    if (ddm->settings.aig.satTimeout>1) {
      time_limit /= 5;
      if (ddm->settings.aig.satTimeout>2) {
        time_limit /= 5;
      }
    }
  }

  cutLits = ddm->aig.auxLits;
  Pdtutil_Assert(cutLits!=NULL,"cutlits array required");

  cutIndex = Pdtutil_Alloc(int,visitedNodes->num);
  observed = Pdtutil_Alloc(unsigned char,visitedNodes->num);
  eqVars = Pdtutil_Alloc(int,visitedNodes->num);
  nodeClass = Pdtutil_Alloc(int,visitedNodes->num);

  //  maxObserve = visitedNodes->num-100;
  if (maxObserve >= visitedNodes->num) {
    maxObserve = -1;
  }
  //  maxObserve = -1;

  for (i=nCuts=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1;
    bAigEdge_t baig = visitedNodes->nodes[i];
    cutIndex[i] = -1;
    int enableCheck = enChk[i];

    baig1 = bAig_AuxAig1(bmgr,baig);
    nodeClass[i]=0; /* default class */
    observed[i]=0; /* not observed by default */

    if (bAig_NodeIsConstant(baig1)) {
      continue;
    }

    if (!bAig_isVarNode(bmgr,baig)) {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig1));
      baig1 = bAig_And(bmgr,right,left);
    }

    if (enableCheck) {
      Ddi_Var_t *cutV, *wireV;
      Ddi_Bdd_t *cutL, *wireL;

      nodeClass[i]=1; /* red candidate class */

      bAig_Ref(bmgr, baig1);
      bAig_AuxAig0(bmgr,baig) = baig1;

      /* create cut var and wire connection var */
      if (Ddi_BddarrayNum(cutLits)/2 <= nCuts) {
	char name[10000];
        sprintf(name,"_RED_REM_CUTV_%d",nCuts);
        Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
        Pdtutil_Assert(bAig_VarNodeFromName(bmgr,name)==bAig_NULL,
          "duplicate baig name");
	cutV = Ddi_VarNew(ddm);
        Ddi_VarAttachName (cutV, name);
        sprintf(name,"_RED_REM_WIREV_%d",nCuts);
        Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
	wireV = Ddi_VarNew(ddm);
        Ddi_VarAttachName (wireV, name);
        cutL = Ddi_BddMakeLiteralAig(cutV,1);
        wireL = Ddi_BddMakeLiteralAig(wireV,1);
	Ddi_BddarrayInsertLast(cutLits,cutL);
	Ddi_BddarrayInsertLast(cutLits,wireL);
	Ddi_Free(cutL);
	Ddi_Free(wireL);
      }
      cutL=Ddi_BddarrayRead(cutLits,nCuts*2);

      cutIndex[i] = nCuts++;

      baig1 = Ddi_BddToBaig(cutL);

    }
    else {
      nodeClass[i]=2; /* out of red candidate class */
      if ((maxObserve >= 0) && (i>=maxObserve)
        && !bAig_isVarNode(bmgr,baig)) {
        bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
        bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
        int ir = bAig_AuxInt(bmgr,right);
        int il = bAig_AuxInt(bmgr,left);
	if (nodeClass[ir] <= 2 || nodeClass[il] <= 2) {
          nodeClass[i]=3; /* observability frontier class */
	}
	else {
          nodeClass[i]=4; /* ignore class: FO of observability frontier */
	}
      }
    }

    bAig_Ref(bmgr, baig1);
    bAig_AuxAig1(bmgr,baig) = baig1;

  }

  /* generate clauses */
  visitedNodes1 = bAigArrayAlloc();

  postOrderAigVisitIntern(bmgr,careBaig,visitedNodes1,-1);
  //    done within next loop !
  //    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes1,-1);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAigEdge_t baig1 = bAig_AuxAig1(bmgr,baig);
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if ((maxObserve < 0) || (nodeClass[i]<4)) {
      postOrderAigVisitIntern(bmgr,baig,visitedNodes1,-1);
      postOrderAigVisitIntern(bmgr,baig1,visitedNodes1,-1);
      if (cutIndex[i] >= 0) {
        baig1 = bAig_AuxAig0(bmgr,baig);
        postOrderAigVisitIntern(bmgr,baig1,visitedNodes1,-1);
      }
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes1);

  for (i=0; i<visitedNodes1->num; i++) {
    int fCnf;
    bAigEdge_t baig = visitedNodes1->nodes[i];
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (!bAig_isVarNode(bmgr,baig)) {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      /* convert AIG node to cnf clauses */
      /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
      f = aig2CnfId(bmgr,baig);
      a = bAig_NodeIsInverted(right) ? -aig2CnfId(bmgr,right) :
                                        aig2CnfId(bmgr,right);
      b = bAig_NodeIsInverted(left) ? -aig2CnfId(bmgr,left) :
                                       aig2CnfId(bmgr,left);

      /* f -a -b */
      MinisatClause3(S,lits,f,-a,-b);
      /* -f a */
      MinisatClause2(S,lits,-f,a);
      /* -f b */
      MinisatClause2(S,lits,-f,b);
    }

    fCnf = aig2CnfId(bmgr,baig);

  }

  /* care */

  c = bAig_NodeIsInverted(careBaig) ? -aig2CnfId(bmgr,careBaig) :
                                       aig2CnfId(bmgr,careBaig);
  while (abs(c) > S.nVars()) S.newVar();

  MinisatClause1(S,lits,c);

  if (maxObserve < 0 && nOut == 1) {

    fBaig = fBaigs->nodes[0];
    newfBaig = bAig_AuxAig1(bmgr,fBaig);
    /* fBaig != newfBaig */
    aa=a = aig2CnfId(bmgr,bAig_NonInvertedEdge(fBaig));
    bb=b = bAig_NodeIsInverted(newfBaig) ? -aig2CnfId(bmgr,newfBaig) :
                                         aig2CnfId(bmgr,newfBaig);

    while (abs(a) > S.nVars() || abs(b) > S.nVars()) S.newVar();

    MinisatClause2(S,lits,a,b);
    MinisatClause2(S,lits,-a,-b);
  }
  else if (maxObserve<0) {
    observeLits.clear();
    for (i=0; i<nOut; i++) {
      fBaig = fBaigs->nodes[i];
      observed[bAig_AuxInt(bmgr,fBaig)] = 1;
    }
  }
  else {
    observeLits.clear();
  }

  for (i=0; i<visitedNodes->num; i++) {
    //    Ddi_Bddarray_t *wireLits = Ddi_BddarrayAlloc(ddm,0);
    bAigEdge_t baig = visitedNodes->nodes[i];
    int id = cutIndex[i];
    if (id >= 0) {
      Ddi_Bdd_t *cutL=Ddi_BddarrayRead(cutLits,id*2);
      Ddi_Bdd_t *wireL=Ddi_BddarrayRead(cutLits,id*2+1);
      bAigEdge_t cutBaig, wireBaig, fBaig;
      int c, w, f;
      cutBaig = Ddi_BddToBaig(cutL);
      wireBaig = Ddi_BddToBaig(wireL);

      fBaig = bAig_AuxAig0(bmgr,baig);
      Pdtutil_Assert(fBaig != bAig_NULL,"NULL baig");

      f = aig2CnfId(bmgr,fBaig);
      w = aig2CnfId(bmgr,wireBaig);
      c = aig2CnfId(bmgr,cutBaig);

      /* f -c -w */
      MinisatClause3(S,lits,f,-c,-w);
      /* -f c -w */
      MinisatClause3(S,lits,-f,c,-w);
#if 0
      /* -f -c w */
      MinisatClause3(S,lits,-f,-c,w);
      /* f c w */
      MinisatClause3(S,lits,f,c,w);
#endif

#if 0
      /* w */
      MinisatClause1(S,lits,w);
#else
      {
        Lit l = MinisatLit(w);
        assumps.push(l);
      }
#endif

    }
  }

  /* redundant vars/clauses here */
  if (redundantClauses || maxObserve>=0 || nOut>1) {
    for (i=0; i<visitedNodes->num; i++) {
      int ir, il;
      int id = cutIndex[i];
      bAigEdge_t baig1, right, left;
      bAigEdge_t baig = visitedNodes->nodes[i];
      int f0, f1, eq01;
      eqVars[i] = -1;
      if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
        continue;
      }
      baig1 = bAig_AuxAig1(bmgr,baig);
      if (bAig_NodeIsConstant(baig1) || bAig_isVarNode(bmgr,baig1)) {
        continue;
      }
      f0 = aig2CnfId(bmgr,bAig_NonInvertedEdge(baig));
      f1 = bAig_NodeIsInverted(baig1) ? -aig2CnfId(bmgr,baig1) :
                                         aig2CnfId(bmgr,baig1);

      if ((redundantClauses || i>maxObserve || observed[i]) && (f0!=f1)) {
        right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
        left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
        ir = bAig_AuxInt(bmgr,right);
        il = bAig_AuxInt(bmgr,left);
        Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");

        /* fanin already observed */
	if (!redundantClauses && nodeClass[i]>=4) {
	  continue;
	}

        S.newVar();
        eqVars[i] = eq01 = S.nVars();
        /* eq01 = (f0==f1) */

	//	Pdtutil_Assert((f0==aa)&&(f1==bb),"aa");

        /* f0 -f1 -eq01 */
        MinisatClause3(S,lits,f0,-f1,-eq01);

        /* -f0 f1 -eq01 */
        MinisatClause3(S,lits,-f0,f1,-eq01);
#if 1
        /* -f0 -f1 eq01 */
        MinisatClause3(S,lits,-f0,-f1,eq01);
        /* f0 f1 eq01 */
        MinisatClause3(S,lits,f0,f1,eq01);
#endif
	if (maxObserve >= 0 && i > maxObserve) {
          observeLits.push(MinisatLit(-eq01));
	}

	if (!redundantClauses || eqVars[ir]<0 || eqVars[il]<0) continue;
        if (id < 0) {
          /* eqL & eqR => eq01 */
          /* eq01 -eqL -eqR */
          MinisatClause3(S,lits,eq01,-eqVars[il],-eqVars[ir]);
	}
	else {
          Ddi_Bdd_t *wireL=Ddi_BddarrayRead(cutLits,id*2+1);
          bAigEdge_t wireBaig = Ddi_BddToBaig(wireL);
	  int w = aig2CnfId(bmgr,wireBaig);

          /* w & eqL & eqR => eq01 */
          /* eq01 -eqL -eqR -w */
          MinisatClause4(S,lits,eq01,-eqVars[il],-eqVars[ir],w);
	}
      }
    }
    if (maxObserve >= 0 && observeLits.size()>0) {
      S.addClause(observeLits);
    }
  }

  nAssumps = assumps.size();
  for (i=nAssumps-1; i>=0; i--) {
    assumpsReverse.push(assumps[i]);
  }

  /* make checks with incremental sat */

  for (i=0; i<visitedNodes->num; i++) {
    //    Ddi_Bddarray_t *wireLits = Ddi_BddarrayAlloc(ddm,0);
    int id = cutIndex[i], enableCheck=1;
    bAigEdge_t redConstant = bAig_NULL;
    bAigEdge_t baig1, baig = visitedNodes->nodes[i];
    bAigEdge_t r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
    bAigEdge_t l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if ((bAig_CacheAig(bmgr,r)!=bAig_NULL) ||
        (bAig_CacheAig(bmgr,l)!=bAig_NULL)) {
      /* fanin node observable through ref=1 wire => baig observable */
      //if (enCached) enableCheck = 0;
      rrStatsP->nCached++;
    }

    if (enableCheck && id >= 0 && (!bAig_isVarNode(bmgr,baig))) {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
      bAig_Ref(bmgr, baig1);
      if (bAig_NodeIsConstant(baig1)) {
	enableCheck=0;
      }
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig1));
    }

    if (enableCheck && id >= 0) {
      Ddi_Bdd_t *cutL=Ddi_BddarrayRead(cutLits,id*2);
      Ddi_Bdd_t *wireL=Ddi_BddarrayRead(cutLits,id*2+1);
      bAigEdge_t cutBaig, wireBaig, fBaig;
      int c;
      Lit saveLit;
      int idAss = nAssumps-id-1;
      long cpuTime=0, startTime=0;

      cutBaig = Ddi_BddToBaig(cutL);
      wireBaig = Ddi_BddToBaig(wireL);

      fBaig = bAig_AuxAig0(bmgr,baig);
      Pdtutil_Assert(fBaig != bAig_NULL,"NULL baig");

      c = aig2CnfId(bmgr,cutBaig);

      saveLit = assumpsReverse[idAss];

      rrStatsP->nChecks++;

      assumpsReverse[idAss] = MinisatLit(c);
      if ((sat = S.okay())) {
	if (!satIncremental) {
       	  S.resetDB();
	}
        startTime = util_cpu_time ();
        sat = S.solve(assumpsReverse,time_limit*time_factor);
        cpuTime = util_cpu_time () - startTime;
        if (time_factor>1 && cpuTime/1000.0>time_limit) {
	  time_factor /= 2;
	}
      }
      if (S.undefined()) {
	rrStatsP->nAbort++;
        sat = 1;
      }
      if (!sat) {
        /* redundancy found ! Replace with 1 constant */
	redConstant = bAig_One;
        /* c */
        MinisatClause1(S,lits,c);
	Pdtutil_Assert(enableCheck,"wrong cached emable");
      }
      else {
        assumpsReverse[idAss] = MinisatLit(-c);
        if ((sat = S.okay())) {
	  if (!satIncremental) {
	    S.resetDB();
 	  }
          startTime = util_cpu_time ();
          sat = S.solve(assumpsReverse,time_limit*time_factor);
          cpuTime = util_cpu_time () - startTime;
        }
        if (S.undefined()) {
	  rrStatsP->nAbort++;
          sat = 1;
        }
        if (!sat) {
          /* redundancy found ! Replace with 1 constant */
	  redConstant = bAig_Zero;
          /* !c */
          MinisatClause1(S,lits,-c);
  	  Pdtutil_Assert(enableCheck,"wrong cached emable");
        }
	else {
	  /* resume old assump */
	  //          assumps[id] = saveLit;
          lits.clear();
          /* w */
          lits.push(saveLit);
          S.addClause(lits);
	}
      }

      if (rrStatsP->nChecks%20 == 0) {
        fprintf(dMgrO(ddm),"."); fflush(dMgrO(ddm));
      }

      assumpsReverse.pop();
    }
    else if (id >= 0) {
      /* cached observable point */
      lits.clear();
      /* w */
      lits.push(assumpsReverse[nAssumps-id-1]);
      S.addClause(lits);
      assumpsReverse.pop();
    }

    if (redConstant != bAig_NULL) {
      /* set constant */
      baig1 = redConstant;
    }
    else if (bAig_isVarNode(bmgr,baig)) {
      baig1 = bAig_NonInvertedEdge(baig);
      if (nRef[i]==1) {
	/* node observable through ref=1 wire */
        bAig_CacheAig(bmgr,baig) = bAig_NonInvertedEdge(baig);
      }
    }
    else {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
      if (nRef[i]==1 && !bAig_NodeIsConstant(baig1)) {
	/* node observable through ref=1 wire */
        bAig_CacheAig(bmgr,baig) = bAig_NonInvertedEdge(baig);
      }
#if 0
      /* disable this caching */
      bAig_CacheAig(bmgr,baig1) = bAig_NonInvertedEdge(baig1);
      bAig_Ref(bmgr, baig1);
      bAigArrayWriteLast(cachedNodes,baig1);
#endif
    }
    bAig_Ref(bmgr, baig1);
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_AuxAig1(bmgr,baig) = baig1;

  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1;
    bAigEdge_t baig = visitedNodes->nodes[i];

    baig1 = bAig_AuxAig0(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
  }

  aig2CnfIdClose(ddm);


  rrStatsP->decisions        += S.stats.decisions;
  rrStatsP->conflicts        += S.stats.conflicts;
  rrStatsP->propagations     += S.stats.propagations;
  rrStatsP->learnts_literals += S.stats.learnts_literals;

  Pdtutil_Free(observed);
  Pdtutil_Free(eqVars);
  Pdtutil_Free(nodeClass);
  Pdtutil_Free(cutIndex);
  bAigArrayFree(visitedNodes1);

}


/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
AigOptOrIncrementalAcc (
  Ddi_Mgr_t *ddm,
  bAig_array_t *refNodes,
  bAig_array_t *nodes0,
  bAig_array_t *nodes1,
  bAigEdge_t careBaig,
  int maxCutNum,
  int maxObserve,
  bAig_array_t *cachedNodes,
  float totTimeLimit
)
{
  int nVars;
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig, *fAig;
  bAigEdge_t fBaig, cof1, cof0;
  //int extRef = Ddi_MgrReadExtRef(ddm);
  int i, j, nCuts;
  int *nRef;
  int *enChk;
  int cutBlockSize = /* maxCutNum */ -1 /* just one block */;
  redrem_stats rrStats = {0,0,0,0,0,0,0};
  int nNodes = refNodes->num;
  int rootCompl = bAig_NodeIsInverted(refNodes->nodes[nNodes-1]);
  int approxResult = 0;
  int enDominators = 1;

  Pdtutil_Assert(nodes0->num==nNodes,"AIG nodes array of different size");
  Pdtutil_Assert(nodes1->num==nNodes,"AIG nodes array of different size");

  if (bAig_NodeIsConstant(refNodes->nodes[nNodes-1])) return 0;
  if (bAig_NodeIsConstant(nodes0->nodes[nNodes-1])) return 0;
  if (bAig_NodeIsConstant(nodes1->nodes[nNodes-1])) return 0;

  if (ddm->aig.auxLits == NULL) {
    ddm->aig.auxLits = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Lock(ddm->aig.auxLits);
  }
  if (ddm->aig.auxLits2 == NULL) {
    ddm->aig.auxLits2 = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Lock(ddm->aig.auxLits2);
  }

  bmgr = ddm->aig.mgr;

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"OrOpt(%d) -> ", nNodes); fflush(dMgrO(ddm));
  }

  nVars = Ddi_MgrReadNumVars(ddm);

  enChk = Pdtutil_Alloc(int,nNodes);
  if (enDominators) {
    int nDom = 0;
    int *dominators = Pdtutil_Alloc(int,refNodes->num);
    maxCutNum = -1;
    dom_stats(ddm->aig.mgr, refNodes, dominators, NULL, 2);

    for (j=0; j<refNodes->num; j++) {
      enChk[j] = 0;
    }
    for (j=0; j<refNodes->num; j++) {
      bAigEdge_t baig = refNodes->nodes[j];
      if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
      /* NOT YET IMPLEMENTED CUT ON VAR ! as it is the cofactoring var */
	continue;
      }
      Pdtutil_Assert(dominators[j]<refNodes->num,"Wrong dominator");
      if (dominators[j]>=0)
	//        enChk[j] = 1;
        enChk[dominators[j]] = 1;
    }
    for (j=0; j<refNodes->num; j++) {
      if (enChk[j]) nDom++;
    }
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"\nEQ dominators enable %d/%d cuts\n", nDom, refNodes->num);
    }
    Pdtutil_Free(dominators);
  }


  nRef = Pdtutil_Alloc(int,nNodes);
  //  fprintf(dMgrO(ddm),"\n");
  for (i=0; i<refNodes->num; i++) {
    bAigEdge_t baig;
    int ir, il;
    baig = refNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
    nRef[i] = 0;
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      ir = rightChildAuxInt(bmgr,baig);
      il = leftChildAuxInt(bmgr,baig);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      nRef[ir]++; nRef[il]++;
#if 0
      fprintf(dMgrO(ddm),"%3d = %s%3d & %s%3d\n", i,
        bAig_NodeIsInverted(bAig_NodeReadIndexOfRightChild(bmgr,baig))?"-":" ",
	      ir,
        bAig_NodeIsInverted(bAig_NodeReadIndexOfLeftChild(bmgr,baig))?"-":" ",
              il);
#endif
    }
#if 0
    else if (bAig_NodeIsConstant(baig)) {
      fprintf(dMgrO(ddm),"%s\n",baig==bAig_Zero?"Zero":"One");
    }
    else {
      fprintf(dMgrO(ddm),"%3d (%s)\n", i, bAig_NodeReadName(bmgr,baig));
    }
#endif
  }


  if (!enDominators)
  for (j=nCuts=0; j<nNodes; j++) {
    bAigEdge_t baig = refNodes->nodes[j];
    enChk[j] = 0;
    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
      /* NOT YET IMPLEMENTED CUT ON VAR ! as it is the cofactoring var */
      continue;
    }
    if (maxCutNum>=0 && nCuts>=maxCutNum) {
      continue;
    }
    if (j<nNodes-1 && (j<cutBlockSize || cutBlockSize<0)){
      enChk[j] = 1;
      nCuts++;
    }
  }

  cof0 = nodes0->nodes[nNodes-1];
  cof1 = nodes1->nodes[nNodes-1];
  if (rootCompl) {
    cof0 = bAig_Not(cof0);
    cof1 = bAig_Not(cof1);
  }

  fBaig = bAig_Or(bmgr,cof1,cof0);
  fAig = Ddi_BddMakeFromBaig(ddm,fBaig);

  approxResult = AigOptOrIncrementalIntern (
     ddm,refNodes,nodes0,nodes1,careBaig,
     maxCutNum,maxObserve,enChk,nRef,cachedNodes,&rrStats,totTimeLimit
  );

  /* recompute aig */

  /* intermediate results */
  cof0 = nodes0->nodes[nNodes-1];
  cof1 = nodes1->nodes[nNodes-1];
  if (rootCompl) {
    cof0 = bAig_Not(cof0);
    cof1 = bAig_Not(cof1);
  }

  fBaig = bAig_Or(bmgr,cof1,cof0);
  newfAig = Ddi_BddMakeFromBaig(ddm,fBaig);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"<%d>(chk/cach/abo:%d/%d/%d)\n",
	    Ddi_BddSize(newfAig),
	    rrStats.nChecks, rrStats.nCached, rrStats.nAbort);

    fprintf(dMgrO(ddm),"d:%ld-c:%ld,p:%ld,l:%ld\n",
	    rrStats.decisions,rrStats.conflicts,
	    rrStats.propagations,rrStats.learnts_literals);

    fflush(dMgrO(ddm));
  }

  /* free temp nodes */

  for (i=0; i<refNodes->num; i++) {
    bAigEdge_t baig = refNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
    bAig_CacheAig(bmgr,baig) = bAig_NULL;
  }

  Pdtutil_Free(nRef);

  Pdtutil_Free(enChk);

  Ddi_Free(fAig);
  Ddi_Free(newfAig);
  return approxResult;

}

/**Function********************************************************************
  Synopsis    [Constant redundancy removal]
  Description [Constant redundancy removal]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
AigOptOrIncrementalIntern (
  Ddi_Mgr_t *ddm,
  bAig_array_t *refNodes,
  bAig_array_t *nodes0,
  bAig_array_t *nodes1,
  bAigEdge_t careBaig,
  int maxCutNum,
  int maxObserve,
  int *enChk,
  int *nRef,
  bAig_array_t *cachedNodes,
  redrem_stats *rrStatsP,
  float totTimeLimit
)
{
  Solver    S;
  vec<Lit> lits, observeLits;
  vec<Lit> assumps, assumpsReverse;
  Ddi_Bddarray_t *cutLits;
  int *cutIndex[2], i, j, nCuts, nNodes=refNodes->num;
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes1;
  int f, a, b, c;
  bAigEdge_t *opt[2], *cutAig[2];
  int *eqVars=NULL;
  int *nodeClass=NULL;
  int nAssumps;
  int chkConstRed=0;
  double time_limit=-1.0;
  int time_factor = 8;
  int satIncremental = ddm->settings.aig.satIncremental;
  int rootCompl = bAig_NodeIsInverted(refNodes->nodes[nNodes-1]);
  int approxResult = 0;
  int enableApprox = 0;
  long cpuTime=0, startTime=0;

  aig2CnfIdInit(ddm);
  assumps.clear();
  assumpsReverse.clear();

  startTime = util_cpu_time ();
  if (ddm->settings.aig.satTimeout) {
    time_limit = 1.0;
    if (ddm->settings.aig.satTimeout>1) {
      time_limit /= 5;
      if (ddm->settings.aig.satTimeout>2) {
        time_limit /= 5;
      }
    }
  }

  cutLits = ddm->aig.auxLits;
  Pdtutil_Assert(cutLits!=NULL,"cutlits array required");

  opt[0] = Pdtutil_Alloc(bAigEdge_t,nNodes);
  opt[1] = Pdtutil_Alloc(bAigEdge_t,nNodes);
  cutAig[0] = Pdtutil_Alloc(bAigEdge_t,nNodes);
  cutAig[1] = Pdtutil_Alloc(bAigEdge_t,nNodes);
  cutIndex[0] = Pdtutil_Alloc(int,nNodes);
  cutIndex[1] = Pdtutil_Alloc(int,nNodes);
  eqVars = Pdtutil_Alloc(int,nNodes);
  nodeClass = Pdtutil_Alloc(int,nNodes);

  if (maxObserve >= nNodes) {
    maxObserve = -1;
  }

  for (i=nCuts=0; i<nNodes; i++) {
    bAigEdge_t aig[2];
    bAigEdge_t ref = refNodes->nodes[i];
    int enableCheck = enChk[i];

    cutIndex[0][i] = cutIndex[1][i] = -1;

    opt[0][i] = aig[0] = nodes0->nodes[i];
    opt[1][i] = aig[1] = nodes1->nodes[i];
    bAig_Ref(bmgr, aig[0]);
    bAig_Ref(bmgr, aig[1]);
    cutAig[0][i] = cutAig[1][i] = bAig_NULL;

    nodeClass[i]=0; /* default class */

    if (bAig_NodeIsConstant(ref)||bAig_isVarNode(bmgr,ref)) {
      continue;
    }
    if (aig[0]==aig[1]) {
      enChk[i] = 0;
      continue;
    }

    for (j=0; j<2; j++) {
      /* constants and variables can be replaced for merge */
      if (1||!(bAig_NodeIsConstant(aig[j])||bAig_isVarNode(bmgr,aig[j]))) {
      /* compute opt aig[j] */
        bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,ref);
        bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,ref);
        int ir = rightChildAuxInt(bmgr,ref);
        int il = leftChildAuxInt(bmgr,ref);
        right = bAig_NodeIsInverted(r) ? bAig_Not(opt[j][ir]) : opt[j][ir];
        left  = bAig_NodeIsInverted(l) ? bAig_Not(opt[j][il]) : opt[j][il];
        bAig_RecursiveDeref(bmgr,aig[j]);
        opt[j][i] = aig[j] = bAig_And(bmgr,right,left);
        bAig_Ref(bmgr, aig[j]);
      }
    }

    if (enableCheck) {
      Ddi_Var_t *cutV, *wireV;
      Ddi_Bdd_t *cutL, *wireL;

      nodeClass[i]=1; /* red candidate class */

      for (j=0; j<2; j++) {

	cutAig[j][i] = aig[j];

        /* create cut var and wire connection var */
        if (Ddi_BddarrayNum(cutLits)/2 <= nCuts) {
  	  char name[10000];
          sprintf(name,"_RED_REM_CUTV_%d",nCuts);
          Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
          Pdtutil_Assert(bAig_VarNodeFromName(bmgr,name)==bAig_NULL,
            "duplicate baig name");
	  cutV = Ddi_VarNew(ddm);
          Ddi_VarAttachName (cutV, name);
          sprintf(name,"_RED_REM_WIREV_%d",nCuts);
          Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
	  wireV = Ddi_VarNew(ddm);
          Ddi_VarAttachName (wireV, name);
          cutL = Ddi_BddMakeLiteralAig(cutV,1);
          wireL = Ddi_BddMakeLiteralAig(wireV,1);
	  Ddi_BddarrayInsertLast(cutLits,cutL);
	  Ddi_BddarrayInsertLast(cutLits,wireL);
	  Ddi_Free(cutL);
	  Ddi_Free(wireL);
        }
        cutL=Ddi_BddarrayRead(cutLits,nCuts*2);
        cutIndex[j][i] = nCuts++;
        opt[j][i] = aig[j] = Ddi_BddToBaig(cutL);
        bAig_Ref(bmgr, aig[j]);
      }
    }
    else {
      nodeClass[i]=2; /* out of red candidate class */
      if ((maxObserve >= 0) && (i>=maxObserve)
        && !bAig_isVarNode(bmgr,ref)) {
        int ir = rightChildAuxInt(bmgr,ref);
        int il = leftChildAuxInt(bmgr,ref);
	if (nodeClass[ir] <= 2 || nodeClass[il] <= 2) {
          nodeClass[i]=3; /* observability frontier class */
	}
	else {
          nodeClass[i]=4; /* ignore class: FO of observability frontier */
	}
      }
    }

  }

#if 0
  fprintf(dMgrO(ddm),"\nOPT[0]\n");
  for (i=0; i<nNodes; i++) fprintf(dMgrO(ddm),"%d) %d\n",i, opt[0][i]);
  fprintf(dMgrO(ddm),"\nOPT[1]\n");
  for (i=0; i<nNodes; i++) fprintf(dMgrO(ddm),"%d) %d\n",i, opt[1][i]);
  fprintf(dMgrO(ddm),"\nCUTAIG[0]\n");
  for (i=0; i<nNodes; i++) fprintf(dMgrO(ddm),"%d) %d\n",i, cutAig[0][i]);
  fprintf(dMgrO(ddm),"\nCUTAIG[1]\n");
  for (i=0; i<nNodes; i++) fprintf(dMgrO(ddm),"%d) %d\n",i, cutAig[1][i]);
#endif

  /* generate clauses */

  visitedNodes1 = bAigArrayAlloc();

  postOrderAigVisitIntern(bmgr,careBaig,visitedNodes1,-1);

  /* original nodes */
  for (i=0; i<nNodes; i++) {
    bAigEdge_t ref = refNodes->nodes[i];
    bAigEdge_t aig[2];
    aig[0] = nodes0->nodes[i];
    aig[1] = nodes1->nodes[i];
    if (bAig_NodeIsConstant(ref)) {
      continue;
    }
    if ((maxObserve < 0) || (nodeClass[i]<4)) {
      for (j=0; j<2; j++) {
        postOrderAigVisitIntern(bmgr,aig[j],visitedNodes1,-1);
        postOrderAigVisitIntern(bmgr,opt[j][i],visitedNodes1,-1);
        if (cutIndex[j][i] >= 0) {
	  Pdtutil_Assert(cutAig[j][i]!=bAig_NULL,"missing cut aig");
          postOrderAigVisitIntern(bmgr,cutAig[j][i],visitedNodes1,-1);
	}
      }
    }
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes1);

  /* zero constant */
  f = aig2CnfId(bmgr,bAig_Zero);
  MinisatClause1(S,lits,-f);

  for (i=0; i<visitedNodes1->num; i++) {
    int fCnf;
    bAigEdge_t baig = visitedNodes1->nodes[i];
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (!bAig_isVarNode(bmgr,baig)) {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      /* convert AIG node to cnf clauses */
      /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
      f = aig2CnfId(bmgr,baig);
      a = aig2CnfIdSigned(bmgr,right);
      b = aig2CnfIdSigned(bmgr,left);
      /* f -a -b */
      MinisatClause3(S,lits,f,-a,-b);
      /* -f a */
      MinisatClause2(S,lits,-f,a);
      /* -f b */
      MinisatClause2(S,lits,-f,b);
    }

    fCnf = aig2CnfId(bmgr,baig);

  }

  /* care */

  c = aig2CnfIdSigned(bmgr,careBaig);
  MinisatClause1(S,lits,c);

  if (maxObserve < 0) {
    /* full observation */
    int r0,r1,n0,n1;
    bAigEdge_t ref0 = nodes0->nodes[nNodes-1];
    bAigEdge_t ref1 = nodes1->nodes[nNodes-1];
    bAigEdge_t new0 = opt[0][nNodes-1];
    bAigEdge_t new1 = opt[1][nNodes-1];

    /* ref0|ref1 != new0|new1 */

    r0 = aig2CnfIdSigned(bmgr,ref0);
    r1 = aig2CnfIdSigned(bmgr,ref1);
    n0 = aig2CnfIdSigned(bmgr,new0);
    n1 = aig2CnfIdSigned(bmgr,new1);

    /* take care of root node complementation */
    if (rootCompl) {
      r0 = -r0; r1 = -r1; n0 = -n0; n1 = -n1;
    }

    /* n0 n1 r0 r1 */
    MinisatClause4(S,lits,n0,n1,r0,r1);
    /* -n0 -r0 */
    MinisatClause2(S,lits,-n0,-r0);
    /* -n0 -r1 */
    MinisatClause2(S,lits,-n0,-r1);
    /* -n1 -r0 */
    MinisatClause2(S,lits,-n1,-r0);
    /* -n1 -r1 */
    MinisatClause2(S,lits,-n1,-r1);
  }
  else {
    observeLits.clear();
  }

  /* write muxes */
  for (i=0; i<nNodes; i++) {

    if (!enChk[i]) continue;

    for (j=0; j<2; j++) {
      int id = cutIndex[j][i];
      if (id >= 0) {
        /* cut node */
        Ddi_Bdd_t *cutL=Ddi_BddarrayRead(cutLits,id*2);
        Ddi_Bdd_t *wireL=Ddi_BddarrayRead(cutLits,id*2+1);
        bAigEdge_t cutBaig, wireBaig, fBaig;
        int c, w, f;
        cutBaig = Ddi_BddToBaig(cutL);
        wireBaig = Ddi_BddToBaig(wireL);

        fBaig = cutAig[j][i];
        Pdtutil_Assert(fBaig != bAig_NULL,"NULL baig");

        f = aig2CnfIdSigned(bmgr,fBaig);
        w = aig2CnfId(bmgr,wireBaig);
        c = aig2CnfId(bmgr,cutBaig);

        /* f -c -w */
        MinisatClause3(S,lits,f,-c,-w);
        /* -f c -w */
        MinisatClause3(S,lits,-f,c,-w);
        {
          Lit l = MinisatLit(w);
          assumps.push(l);
        }
      }
    }
  }

  /* observation fromtier */
  if (maxObserve>=0) {
    Pdtutil_Assert(0,"not yet implemented: observation frontier");
  }

  nAssumps = assumps.size();
  for (i=nAssumps-1; i>=0; i--) {
    assumpsReverse.push(assumps[i]);
  }

  /* make checks with incremental sat */

  for (i=0; i<nNodes; i++) {
    bAigEdge_t aig[2];
    bAigEdge_t ref = refNodes->nodes[i];
    int enableCheck = enChk[i];
    bAigEdge_t r = bAig_NodeReadIndexOfRightChild(bmgr,ref);
    bAigEdge_t l = bAig_NodeReadIndexOfLeftChild(bmgr,ref);
    bAigEdge_t newNode = bAig_NULL;

    aig[0] = opt[0][i];
    aig[1] = opt[1][i];

    if (bAig_NodeIsConstant(ref)||bAig_isVarNode(bmgr,ref)) {
      continue;
    }

    if (aig[0]==aig[1]) {
      continue;
    }

    /*recompute node to consider fanin optimizations */
    if (!bAig_isVarNode(bmgr,ref)) {
      for (j=0; j<2; j++) {
        if (1||!(bAig_NodeIsConstant(aig[j])||bAig_isVarNode(bmgr,aig[j]))) {
          /* compute opt aig[j] */
          bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,ref);
          bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,ref);
          int ir = rightChildAuxInt(bmgr,ref);
          int il = leftChildAuxInt(bmgr,ref);
          Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
          right = bAig_NodeIsInverted(r) ? bAig_Not(opt[j][ir]) : opt[j][ir];
          left  = bAig_NodeIsInverted(l) ? bAig_Not(opt[j][il]) : opt[j][il];
          bAig_RecursiveDeref(bmgr,opt[j][i]);
          opt[j][i] = aig[j] = bAig_And(bmgr,right,left);
          bAig_Ref(bmgr, aig[j]);
        }
      }
    }

    enableCheck = enableCheck && (cutIndex[0][i]>=0 && cutIndex[1][i]>=0);
    if (totTimeLimit >= 0)
      enableCheck &= ((util_cpu_time () - startTime)/1000.0 < totTimeLimit);

    if (0&&((bAig_CacheAig(bmgr,r)!=bAig_NULL) ||
	    (bAig_CacheAig(bmgr,l)!=bAig_NULL))) {
      /* fanin node observable through ref=1 wire => baig observable */
      if (enableCheck) {
	assumpsReverse.pop();
	assumpsReverse.pop();
      }
      enableCheck = 0;
      rrStatsP->nCached++;
    }

    if (enableCheck) {
      int id[2];
      id[0] = cutIndex[0][i]; id[1] = cutIndex[1][i];
      if (id[0] >= 0 && id[1]>=0) {
        /* cut node */
        Ddi_Bdd_t *cutL[2];
        Ddi_Bdd_t *wireL[2];
        bAigEdge_t cutBaig[2], wireBaig[2], fBaig[2];
        int c[2], w[2], f[2];
	int k;
        Lit saveLit[2];
        int idAss[2],refAss;
        long cpuTime=0, startTime=0;
	int sat[4], satCompactResult;
	static char chkPhase[4][4] = {
          {-1,-1,-1,1},
          {-1,-1,1,-1},
          {1,1,-1,1},
          {1,1,1,-1}
	};

        for (j=0; j<2; j++) {
          cutL[j]=Ddi_BddarrayRead(cutLits,id[j]*2);
          wireL[j]=Ddi_BddarrayRead(cutLits,id[j]*2+1);
          cutBaig[j] = Ddi_BddToBaig(cutL[j]);
          wireBaig[j] = Ddi_BddToBaig(wireL[j]);
          fBaig[j] = cutAig[j][i];
          Pdtutil_Assert(fBaig[j] != bAig_NULL,"NULL baig");
	  /* cut/mux variables */
          c[j] = aig2CnfId(bmgr,cutBaig[j]);
          f[j] = aig2CnfIdSigned(bmgr,fBaig[j]);
          w[j] = aig2CnfId(bmgr,wireBaig[j]);
	  /* save wire assertions: w0=w1 = 1*/
          idAss[j] = nAssumps-id[j]-1;
          saveLit[j] = assumpsReverse[idAss[j]];
	}

	Pdtutil_Assert(idAss[0]>=assumpsReverse.size()-2,"wrong assum. order");
	Pdtutil_Assert(idAss[1]>=assumpsReverse.size()-2,"wrong assum. order");
	refAss = assumpsReverse.size()-2;

        if (aig[0]==aig[1]) {
	  /* already merged due to fanin optimizations */
          /* remove wire assumptions: set as clauses */
          /* w */
          lits.clear();
          lits.push(saveLit[0]);
          S.addClause(lits);
          lits.clear();
          lits.push(saveLit[1]);
          S.addClause(lits);
 	  assumpsReverse.pop();
	  assumpsReverse.pop();
	  continue;
        }

        rrStatsP->nChecks++;

	/* make SAT checks */
	/* w[j] are free */
	/* test c0c1f0f1=0001,0010,1101,1110 */

	assumpsReverse.push();
	assumpsReverse.push();

	satCompactResult = 0;
	for (k=0;k<4;k++) {
 	  for (j=0;j<2;j++) {
  	    assumpsReverse[refAss+j]=MinisatLit(chkPhase[k][j]*c[j]);
  	    assumpsReverse[refAss+2+j]=MinisatLit(chkPhase[k][2+j]*f[j]);
	  }
          if ((sat[k] = S.okay())) {
            if (!satIncremental) {
              S.resetDB();
            }
            startTime = util_cpu_time ();
            sat[k] = S.solve(assumpsReverse,time_limit*time_factor);
            cpuTime = util_cpu_time () - startTime;
            if (time_factor>1 && cpuTime/1000.0>time_limit) {
              time_factor /= 2;
            }
	  }
          if (S.undefined()) {
            rrStatsP->nAbort++;
	    if (enableApprox) {
	      approxResult = 1;
              sat[k] = 0;
	    }
	    else {
              sat[k] = 1;
	    }
          }
	  satCompactResult = satCompactResult<<1 | sat[k];
	}

	assumpsReverse.pop();
	assumpsReverse.pop();
	assumpsReverse.pop();
	assumpsReverse.pop();

	//         if (satCompactResult==0) {
	//	  satCompactResult = 3;
	//         }

        /* ANALYZE SAT results */
	switch (satCompactResult) {
	  case 5:
	  case 7:
	  case 10:
	  case 11:
	  case 13:
	  case 14:
	  case 15:
	    /* no transformation allowed */
            /* w */
            lits.clear();
            lits.push(saveLit[0]);
            S.addClause(lits);
            lits.clear();
            lits.push(saveLit[1]);
            S.addClause(lits);
#if 0
   	    for (j=0;j<2;j++) {
              bAig_Ref(bmgr, cutAig[j][i]);
              bAig_RecursiveDeref(bmgr,opt[j][i]);
              opt[j][i] = cutAig[j][i];
	    }
 #endif
            if (nRef[i]==1 && !bAig_NodeIsConstant(ref)) {
  	      /* node observable through ref=1 wire */
              bAig_CacheAig(bmgr,ref) = bAig_NonInvertedEdge(ref);
            }
	    break;
	  case 0:
	    /* all transformations allowed */

	    if (chkConstRed) {
	    /* check for constant redundancy */
	    Pdtutil_Assert(refAss == assumpsReverse.size(),
              "invalid ass. num");
   	    assumpsReverse.push();
	    assumpsReverse.push();

	    /* check for 0 redundancy */
   	    for (j=0;j<2;j++) {
  	      assumpsReverse[refAss+j]=MinisatLit(-c[j]);
	    }
            if ((sat[0] = S.okay())) {
              if (!satIncremental) {
                S.resetDB();
              }
              sat[0] = S.solve(assumpsReverse,time_limit*time_factor);
	    }
            if (S.undefined()) {
	      if (enableApprox) {
	        approxResult = 1;
                sat[0] = 0;
	      }
	      else {
                sat[0] = 1;
	      }
              rrStatsP->nAbort++;
            }
   	    assumpsReverse.pop();
	    assumpsReverse.pop();

	    if (!sat[0]) {
	      /* redundant ! */
	      newNode = bAig_Zero;
              MinisatClause1(S,lits,-c[0]);
              MinisatClause1(S,lits,-c[1]);
	      break;
	    }

	    /* check for 1 redundancy */
   	    for (j=0;j<2;j++) {
  	      assumpsReverse[refAss+j]=MinisatLit(c[j]);
	    }
            if ((sat[0] = S.okay())) {
              if (!satIncremental) {
                S.resetDB();
              }
              sat[0] = S.solve(assumpsReverse,time_limit*time_factor);
	    }
            if (S.undefined()) {
	      if (enableApprox) {
	        approxResult = 1;
                sat[0] = 0;
	      }
	      else {
                sat[0] = 1;
	      }
              rrStatsP->nAbort++;
            }
   	    assumpsReverse.pop();
	    assumpsReverse.pop();

	    if (!sat[0]) {
	      /* redundant ! */
	      newNode = bAig_One;
              MinisatClause1(S,lits,c[0]);
              MinisatClause1(S,lits,c[1]);
	      break;
	    }
	    }

	    /* not redundant ! merge */
	    newNode = opt[0][i];
	    /* w0 */
            MinisatClause1(S,lits,w[0]);
	    /* c0 = c1 */
            MinisatClause2(S,lits,-c[0],c[1]);
            MinisatClause2(S,lits,c[0],-c[1]);
	    break;

	  case 3:
	    /* AND: f0&f1 -> c0,c1 possible */
	    newNode = bAig_And(bmgr,opt[0][i],opt[1][i]);
	    /* AND: c0 = f0&f1 */
            /* c0 -f0 -f1 */
            MinisatClause3(S,lits,c[0],-f[0],-f[1]);
            /* -c0 f0 */
            MinisatClause2(S,lits,-c[0],f[0]);
            /* -c0 f1 */
            MinisatClause2(S,lits,-c[0],f[1]);
	    /* c0 = c1 */
            MinisatClause2(S,lits,-c[0],c[1]);
            MinisatClause2(S,lits,c[0],-c[1]);
	    break;

	  case 12:
	    /* OR: f0|f1 -> c0,c1 possible */
	    newNode = bAig_Or(bmgr,opt[0][i],opt[1][i]);
	    /* OR: c0 = f0&f1 */
            /* -c0 f0 f1 */
            MinisatClause3(S,lits,-c[0],f[0],f[1]);
            /* c0 -f0 */
            MinisatClause2(S,lits,c[0],-f[0]);
            /* c0 -f1 */
            MinisatClause2(S,lits,c[0],-f[1]);
	    /* c0 = c1 */
            MinisatClause2(S,lits,-c[0],c[1]);
            MinisatClause2(S,lits,c[0],-c[1]);
	    break;

	  case 2:
	  case 4:
	  case 6:
	    /* f0 -> c0,c1 possible */
	    newNode = opt[0][i];
	    /* w0 */
            MinisatClause1(S,lits,w[0]);
	    /* c0 = c1 */
            MinisatClause2(S,lits,-c[0],c[1]);
            MinisatClause2(S,lits,c[0],-c[1]);
	    break;

	  case 1:
	  case 8:
	  case 9:
	    /* f1 -> c0,c1 possible */
	    newNode = opt[1][i];
	    /* w1 */
            MinisatClause1(S,lits,w[1]);
	    /* c0 = c1 */
            MinisatClause2(S,lits,-c[0],c[1]);
            MinisatClause2(S,lits,c[0],-c[1]);
	    break;
	}
      }

    }

    if (newNode != bAig_NULL) {
      bAig_Ref(bmgr, newNode);
      bAig_Ref(bmgr, newNode);
      bAig_RecursiveDeref(bmgr,opt[0][i]);
      bAig_RecursiveDeref(bmgr,opt[1][i]);
      opt[0][i] = opt[1][i] = newNode;
    }

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
      if (rrStatsP->nChecks%20 == 0) {
	fprintf(dMgrO(ddm),"."); fflush(dMgrO(ddm));
      }
    }
  }

  for (i=0; i<nNodes; i++) {
    for (j=0;j<2;j++) {
      if (cutAig[j][i] != bAig_NULL) {
        bAig_RecursiveDeref(bmgr,cutAig[j][i]);
      }
    }
    bAig_RecursiveDeref(bmgr,nodes0->nodes[i]);
    bAig_RecursiveDeref(bmgr,nodes1->nodes[i]);
    nodes0->nodes[i] = opt[0][i];
    nodes1->nodes[i] = opt[1][i];
  }

  aig2CnfIdClose(ddm);

  rrStatsP->decisions        += S.stats.decisions;
  rrStatsP->conflicts        += S.stats.conflicts;
  rrStatsP->propagations     += S.stats.propagations;
  rrStatsP->learnts_literals += S.stats.learnts_literals;

  Pdtutil_Free(opt[0]);
  Pdtutil_Free(opt[1]);
  Pdtutil_Free(cutAig[0]);
  Pdtutil_Free(cutAig[1]);
  Pdtutil_Free(eqVars);
  Pdtutil_Free(nodeClass);
  Pdtutil_Free(cutIndex[0]);
  Pdtutil_Free(cutIndex[1]);
  bAigArrayFree(visitedNodes1);

  return approxResult;

}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
AigOptByBddWithThresh(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *constr,
  int th,
  float timeLimit,
  int sizeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *f1, *f1Cuts;
  Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Bddarray_t *auxLits = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm,0);
  int checkResult = 0, size, size0, nA, optEval=0;
  bAigEdge_t nodeIndex;
  Ddi_Bdd_t *constrainCare = NULL;
  int abort = 0;

#if 0
  Ddi_Bdd_t *tmpF1 /*, tmpF0 = Ddi_BddMakeMono(f)*/;
#endif
  if (constr!=NULL) constrainCare=Ddi_BddDup(constr);

  size = Ddi_BddSize(f);
  if (0&&size > 20000) {
    Ddi_Varset_t *supp = Ddi_BddSupp(f);
    optEval = Ddi_VarsetNum(supp)>50;
  }
  if (optEval) {
    int i, iMin, s, sMin, sTot;
    Ddi_Bdd_t *p_i, *partFAnd = Ddi_AigPartitionTop(f,0);
    Ddi_Bddarray_t *partArray = Ddi_BddarrayMakeFromBddPart(partFAnd);
    //	Ddi_Bdd_t *partFOr = Ddi_AigPartitionTop(f,1);
    Ddi_Bddarray_t *partArray2 = Ddi_AigarrayOptByBdd(partArray,
                                                      auxF,auxV,500000,0,-1,-1);
    sTot = Ddi_BddSize(f);
    Ddi_Free(partArray);
    Ddi_Free(partFAnd);
    f1Cuts = Ddi_BddMakePartConjFromArray(partArray2);
    Ddi_BddSetPartConj(f1Cuts);
    Ddi_Free(partArray2);

  }
  else {
    nodeIndex = Ddi_BddToBaig(f);

    f1Cuts = aig2BddInternWithCuts(ddm,
      nodeIndex,th,auxV,auxF,auxLits,constrainCare,1,timeLimit,sizeLimit,0);
  }
#if 0
  Ddi_MgrReduceHeap (ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);
#endif

  nA = Ddi_BddarrayNum(auxF);

  abort = f1Cuts==NULL;

  if (1/*Check size*/ && f1Cuts != NULL) {
    int i;
    for (i=0; i<Ddi_BddarrayNum(auxF); i++) {
      Ddi_BddSetAig(Ddi_BddarrayRead(auxF,i));
    }
    Ddi_BddSetAig(f1Cuts);
  }

  if (Ddi_BddarrayNum(auxF)>0 && f1Cuts!=NULL) {
#if 0
  do {
    f0 = f1Cuts;
    f1Cuts = Ddi_BddCompose(f0,auxV,auxF);
    again = !Ddi_BddEqual(f0,f1Cuts);
    Ddi_Free(f0);
  } while (again);
#else
 {
   Ddi_Bddarray_t *b,*a = Ddi_BddarrayAlloc(ddm,1);
   Ddi_BddarrayWrite(a,0,f1Cuts);
   Ddi_Free(f1Cuts);
   b = Ddi_AigarrayCompose (a,auxV,auxF);
   f1Cuts = Ddi_BddarrayExtract(b,0);
   Ddi_Free(a);
   Ddi_Free(b);
 }
#endif
  }

  if (0) {
    fprintf(dMgrO(ddm),"(cut: %d[%d])\n",Ddi_BddSize(f1Cuts), Ddi_BddarrayNum(auxF));
    fflush(dMgrO(ddm));
  }

#if 0
  if (f1Cuts!=NULL)
  {
    Ddi_Bdd_t *tmpF0 = Ddi_BddMakeMono(f);

    auxF = Ddi_BddarrayAlloc(ddm,0);
    auxV = Ddi_VararrayAlloc(ddm,0);
    f1 = aig2BddInternWithCuts(ddm,nodeIndex,-1,auxV,auxF,-1.0,0);
    tmpF1 = Ddi_BddMakeMono(f1Cuts);
    Pdtutil_Assert(Ddi_BddEqual(f1,tmpF1),"Mismatching BDDs");
    Ddi_Free(tmpF0);
    Ddi_Free(tmpF1);
    Ddi_Free(f1);
    Ddi_Free(auxF);
    Ddi_Free(auxV);
  }
#endif

  if (f1Cuts!=NULL) {
#if 1
    f1 = Ddi_BddDup(f1Cuts);
#endif

    if (constrainCare != NULL) {
      Ddi_BddSetAig(constrainCare);
      Ddi_BddAndAcc(f1,constrainCare);
      Ddi_Free(constrainCare);
    }

    if (checkResult) {
      Ddi_Bdd_t *tmp = Ddi_BddXor(f1,f);
      Pdtutil_Assert(!Ddi_AigSat(tmp),"Wrong BDD OPT");
      Ddi_Free(tmp);
    }

    if (!Ddi_AigSat(f1)) {
      fprintf(dMgrO(ddm),"ZERO\n");
    }

    if ((size0=Ddi_BddSize(f))*1.0 > (size=Ddi_BddSize(f1))) {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
        fprintf(dMgrO(ddm),"AIGBDDOPT: %d -> %d(Cuts:%d)\n",
	  Ddi_BddSize(f), Ddi_BddSize(f1), Ddi_BddSize(f1Cuts));
      }
      DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)f1);
    }
    else {
      size = size0;
    }
    Ddi_Free(f1);
  }
  else {
    size = Ddi_BddSize(f);
  }


  Ddi_Free(f1Cuts);
  Ddi_Free(auxF);
  Ddi_Free(auxV);
  Ddi_Free(auxLits);

  return abort?-1:size;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigMgrCheck (
  Ddi_Bddarray_t *aigRoots
)
{
  int i, nUnref=0, nFreeLost=0, nFree0=0, nVisited=0, nConst=0, nVar=0,
  nRoots = Ddi_BddarrayNum(aigRoots);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(aigRoots);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int nFree = bmgr->freeNum;

  if (nRoots<1) {
    return 0;
  }

  bAig_array_t *visitedNodes = bAigArrayAlloc();

  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(aigRoots,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  }

  for (i=0; i<bmgr->nodesArraySize; i+=4) {
    if (!(nodeVisited(bmgr,i)>=4) && (refCount(bmgr,i)>0)) {
      nUnref++;
    }
    if (refCount(bmgr,i)<0) {
      nFree++;
    }
    if (refCount(bmgr,i)==0) {
      if (bAig_NodeIsConstant(i)) {
	nConst++;
      }
      else if (bAig_isVarNode(bmgr,i)) {
	nVar++;
      }
      else {
	nFreeLost++;
      }
    }
    if (nodeVisited(bmgr,i)>=4) {
      nVisited++;
    }
  }

  Pdtutil_Assert(nUnref == 0,"unref nodes in AIG mgr check");
  Pdtutil_Assert(nFreeLost == 0,"unref nodes in AIG mgr check");
  Pdtutil_Assert(nVisited == visitedNodes->num,
    "wrong visited count in AIG mgr check");
  //  Pdtutil_Assert(nVisited+nFree-nFree0 == bmgr->nodesArraySize/4,
  //    "wrong node count in AIG mgr check");

  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  bAigArrayFree(visitedNodes);

  return (nUnref==0);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigMgrGarbageCollect (
  Ddi_Bddarray_t *refRoots
)
{
  int i, nDeref=0,
  nRoots = Ddi_BddarrayNum(refRoots);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(refRoots);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;

  if (nRoots<1) {
    return 0;
  }

  bAig_array_t *visitedNodes = bAigArrayAlloc();

  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(refRoots,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  }

  if (1)
  for (i=0; i<bmgr->nodesArraySize; i+=4) {
    if (!(nodeVisited(bmgr,i)>=4) && (refCount(bmgr,i)>0)) {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,i);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,i);
      if (bAig_NodeIsConstant(i)||bAig_isVarNode(bmgr,i)) continue;
      bAig_RecursiveDeref(bmgr, right);
      bAig_RecursiveDeref(bmgr, left);
    }
  }

  for (i=0; i<bmgr->nodesArraySize; i+=4) {
    if (!(nodeVisited(bmgr,i)>=4) && (refCount(bmgr,i)>0)) {
      while (refCount(bmgr,i)>0) {
	bAig_RecursiveDeref(bmgr, i);
	nDeref++;
      }
    }
  }


  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  bAigArrayFree(visitedNodes);

  return (nDeref);
}

#if 0
/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigMgrDefrag (
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(refRoots);
)
{
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int i, j, nFreeLost=0, nVar=0, nAnd=0, newSize, oldSize;
  Ddi_Generic_t *curr;

  for (i=j=4; i<bmgr->nodesArraySize; i+=4) {
    Pdtutil_Assert(bAig_AuxAig0(bmgr,i)==bAig_NULL,"null aig0 needed");
    if (refCount(bmgr,i)<0) continue;
    if (refCount(bmgr,i)==0) {
      Pdtutil_Assert (!bAig_NodeIsConstant(i),"wrong constant baig");
      if (bAig_isVarNode(bmgr,i)) {
	char *name = bAig_NodeReadName(bmgr,i);
	nVar++;
	bAig_AuxAig0(bmgr,i)=j;
	bAig_AuxRef(bmgr,i) = 0;
	j += 4;
	bAig_AuxPtrNum(bmgr,i) = name;
      }
      else {
	nFreeLost++;
      }
    }
    else {
      char *name = bAig_NodeReadName(bmgr,i);
      Pdtutil_Free(name);
      nAnd++;
      bAig_AuxAig0(bmgr,i)=j;
      bAig_AuxRef(bmgr,i) = refCount(bmgr,i);
      j += 4;
    }
  }

  newSize=j;

  for (i=0; i<bAig_HashTableSize; i++)
    bmgr->HashTable[i]= bAig_NULL;

  st_free_table(bmgr->SymbolTable);
  bmgr->SymbolTable = st_init_table(strcmp,st_strhash);

  oldSize = bmgr->nodesArraySize;
  bmgr->nodesArraySize = 4;

  for (i=4; i<oldSize; i+=4) {
    bAigEdge_t baig, right, left;
    if (refCount(bmgr,i)<0) continue;

    if (baig==bAig_NULL) continue;

    if (bAig_isVarNode(bmgr,i)) {
      char *name = bAig_AuxPtrNum(bmgr,i);
      baig = bAig_CreateVarNode(bmgr,name);
      bAig_AuxPtrNum(bmgr,i) = NULL;
    }
    else {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,i);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,i);

      right = bAig_AuxAig0(bmgr,right);
      left = bAig_AuxAig0(bmgr,left);

      baig = bAigCreateAndNode(bmgr,left,right);
    }

    Pdtutil_Assert(baig == bAig_AuxAig0(bmgr,i),"error in baig re-mapping");

  }

  Pdtutil_Assert(newSize == bmgr->nodesArraySize,
		 "old/new baig sizes do not match");

  curr = ddm->nodeList;
  while (curr!=NULL) {
    if (curr->common.status != Ddi_Free_c) {
      if (curr->common.code == Ddi_Bdd_Aig_c) {
	bAigEdge_t oldBaig = f->data.aig->aigNode;
	bAigEdge_t oldBaig = f->data.aig->aigNode;

        Ddi_BddarrayInsertLast(aigRoots,(Ddi_Bdd_t *)curr);
      }
    }
  }

  return (nDeref);
}
#endif

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigCubeExistAcc (
  Ddi_Bdd_t *cubeAig,
  Ddi_Varset_t *smooth
)
{
  Ddi_Bdd_t *newCube = Ddi_AigCubeExist(cubeAig,smooth);
  Ddi_DataCopy(cubeAig,newCube);
  Ddi_Free(newCube);
  return (cubeAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigCubeExistProjectAcc (
  Ddi_Bdd_t *cubeAig,
  Ddi_Varset_t *proj
)
{
  Ddi_Bdd_t *newCube = Ddi_AigCubeExistProject(cubeAig,proj);
  Ddi_DataCopy(cubeAig,newCube);
  Ddi_Free(newCube);
  return (cubeAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigCubeExist (
  Ddi_Bdd_t *cubeAig,
  Ddi_Varset_t *smooth
)
{
  int n, i;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cubeAig);
  Ddi_Bdd_t *newAig, *cubePart = Ddi_AigPartitionTop(cubeAig,0);
  Ddi_Vararray_t *vars;
  Ddi_Bddarray_t *subst;
  int chkFree = 0;

  //  Pdtutil_Assert(Ddi_BddIsCube(cubeBdd),"CUBE required");
  n = Ddi_BddPartNum(cubePart);
  vars = Ddi_VararrayMakeFromVarset(smooth,1);
  newAig = Ddi_BddMakeConstAig(ddm,1);
  Ddi_BddSetPartConj(newAig);
  for (i=0; i<Ddi_VararrayNum(vars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vars,i);
    Pdtutil_Assert(Ddi_VarReadMark(v) == 0,"0 var mark required");
    Ddi_VarWriteMark(v,1);
  }
  for (i=0; i<n; i++) {
    Ddi_Bdd_t *p_i = Ddi_BddPartRead(cubePart,i);
    Ddi_Var_t *v_i = Ddi_BddTopVar(p_i);
    Pdtutil_Assert(Ddi_BddSize(p_i)==1,"not a cube");
    if (Ddi_VarReadMark(v_i) == 0) {
      Ddi_BddPartInsertLast(newAig,p_i);
    }
  }
  for (i=0; i<Ddi_VararrayNum(vars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vars,i);
    Ddi_VarWriteMark(v,0);
  }
  Ddi_Free(vars);
  Ddi_Free(cubePart);
  Ddi_BddSetAig(newAig);

  return(newAig);

}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigCubeExistProject (
  Ddi_Bdd_t *cubeAig,
  Ddi_Varset_t *proj
)
{
  int n, i;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cubeAig);
  Ddi_Bdd_t *newAig, *cubePart = Ddi_AigPartitionTop(cubeAig,0);
  Ddi_Vararray_t *vars;
  Ddi_Bddarray_t *subst;
  int chkFree = 0;

  //  Pdtutil_Assert(Ddi_BddIsCube(cubeBdd),"CUBE required");
  n = Ddi_BddPartNum(cubePart);
  vars = Ddi_VararrayMakeFromVarset(proj,1);
  newAig = Ddi_BddMakeConstAig(ddm,1);
  Ddi_BddSetPartConj(newAig);
  for (i=0; i<Ddi_VararrayNum(vars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vars,i);
    Pdtutil_Assert(Ddi_VarReadMark(v) == 0,"0 var mark required");
    Ddi_VarWriteMark(v,1);
  }
  for (i=0; i<n; i++) {
    Ddi_Bdd_t *p_i = Ddi_BddPartRead(cubePart,i);
    Ddi_Var_t *v_i = Ddi_BddTopVar(p_i);
    Pdtutil_Assert(Ddi_BddSize(p_i)==1,"not a cube");
    if (Ddi_VarReadMark(v_i) == 1) {
      Ddi_BddPartInsertLast(newAig,p_i);
    }
  }
  for (i=0; i<Ddi_VararrayNum(vars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vars,i);
    Ddi_VarWriteMark(v,0);
  }
  Ddi_Free(vars);
  Ddi_Free(cubePart);
  Ddi_BddSetAig(newAig);

  return(newAig);

}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigNnfSubsetWithCubeAcc(
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *cubeAig
)
{
  int n, i;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Bdd_t *zeroAig, *cubePart = Ddi_AigPartitionTop(cubeAig,0);
  Ddi_Bddarray_t *subst;
  int chkFree = 0;
  Ddi_Vararray_t *vars;
  Ddi_Bdd_t *fAigNnf;
  Ddi_Vararray_t *nnfV = Ddi_BddSuppVararray(cubeAig);
  Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV = Ddi_VararrayAlloc(ddm,0);

  fAigNnf = Ddi_AigNnf(fAig, nnfV, NULL, rV, aV, NULL);
  zeroAig = Ddi_BddMakeConstAig(ddm,0);

  //  Pdtutil_Assert(Ddi_BddIsCube(cubeBdd),"CUBE required");
  n = Ddi_BddPartNum(cubePart);
  Pdtutil_Assert(n==Ddi_VararrayNum(nnfV),"nnf var # mismatch");
  Pdtutil_Assert(n==Ddi_VararrayNum(rV),"nnf var # mismatch");
  Pdtutil_Assert(n==Ddi_VararrayNum(aV),"nnf var # mismatch");
  vars = Ddi_VararrayAlloc (ddm,n);
  subst = Ddi_BddarrayAlloc(ddm,n);

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *p_i = Ddi_BddPartRead(cubePart,i);
    Ddi_Var_t *v_i = Ddi_BddTopVar(p_i);
    int isCompl = Ddi_BddIsComplement(p_i);
    Pdtutil_Assert(Ddi_BddSize(p_i)==1,"not a cube");
    Ddi_VarWriteMark(v_i,isCompl);
  }

  for (i=0; i<n; i++) {
    Ddi_Var_t *rv_i = Ddi_VararrayRead(rV,i);
    Ddi_Var_t *av_i = Ddi_VararrayRead(aV,i);
    int isCompl = Ddi_VarReadMark(rv_i);
    Ddi_BddarrayWrite(subst,i,zeroAig);
    Ddi_VararrayWrite(vars,i,isCompl?rv_i:av_i);
  }

  Ddi_VararrayWriteMark (nnfV, 0);

  DdiAigComposeAcc (fAigNnf,vars,subst);
  Ddi_BddAigFromNnfAcc(fAigNnf,rV);

  Ddi_Free(nnfV);
  Ddi_Free(vars);
  Ddi_Free(subst);
  Ddi_Free(cubePart);
  Ddi_Free(zeroAig);

  Ddi_DataCopy(fAig,fAigNnf);

  Ddi_Free(fAigNnf);

  return(fAig);

}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigAndCubeAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *cubeAig
)
{
  int n, i;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Bdd_t *constAig, *cubePart = Ddi_AigPartitionTop(cubeAig,0);
  Ddi_Vararray_t *vars;
  Ddi_Bddarray_t *subst;
  int chkFree = 0;

  //  Pdtutil_Assert(Ddi_BddIsCube(cubeBdd),"CUBE required");
  n = Ddi_BddPartNum(cubePart);
  vars = Ddi_VararrayAlloc (ddm,n);
  subst = Ddi_BddarrayAlloc(ddm,n);
  for (i=0; i<n; i++) {
    Ddi_Bdd_t *p_i = Ddi_BddPartRead(cubePart,i);
    Ddi_Var_t *v_i = Ddi_BddTopVar(p_i);
    Pdtutil_Assert(Ddi_BddSize(p_i)==1,"not a cube");
    constAig = Ddi_BddMakeConstAig(ddm,!Ddi_BddIsComplement(p_i));
    Ddi_BddarrayWrite(subst,i,constAig);
    Ddi_VararrayWrite(vars,i,v_i);
    Ddi_Free(constAig);
  }
  Ddi_BddComposeAcc(fAig,vars,subst);
  //  DdiAigComposeAcc (fAig,vars,subst);
  Ddi_Free(vars);
  Ddi_Free(subst);
  Ddi_Free(cubePart);

  Ddi_BddAndAcc(fAig,cubeAig);

  return(fAig);

}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigConstrainCubeAcc (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *cubeAig
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *fA;
  Ddi_Bdd_t *cubeBdd = NULL;
  Ddi_Varset_t *supp;
  Ddi_Bdd_t *myCube = NULL;

  if (Ddi_BddReadComposeF(f)!=NULL) {
    Ddi_AigConstrainCubeAcc (Ddi_BddReadComposeF(f),cubeAig);
    Ddi_AigarrayConstrainCubeAcc(Ddi_BddReadComposeSubst(f),cubeAig);
    if (Ddi_BddReadComposeConstr(f)!=NULL) {
      Ddi_AigConstrainCubeAcc(Ddi_BddReadComposeConstr(f),cubeAig);
    }
    if (Ddi_BddReadComposeCone(f)!=NULL) {
      Ddi_AigConstrainCubeAcc(Ddi_BddReadComposeCone(f),cubeAig);
    }
  }

  if (Ddi_BddIsPartConj(f) || Ddi_BddIsPartDisj(f)) {
    int i;
    Ddi_Bddarray_t *fA = Ddi_BddarrayMakeFromBddPart(f);
    Ddi_AigarrayConstrainCubeAcc(fA,cubeAig);
    for (i=0; i<Ddi_BddPartNum(f); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(fA,i);
      Ddi_BddPartWrite(f,i,f_i);
    }
    Ddi_Free(fA);
    return(f);
  }

  if (Ddi_BddIsPartConj(cubeAig)) {
    myCube = Ddi_BddDup(cubeAig);
  }
  else {
    Ddi_Bdd_t *cP = Ddi_AigPartitionTop(cubeAig,0);
    int i, nc=0;
    myCube = Ddi_BddMakeConstAig(ddm,1);
    for (i=0; i<Ddi_BddPartNum(cP); i++) {
      Ddi_Bdd_t *c_i = Ddi_BddPartRead(cP,i);
      if (Ddi_BddSize(c_i) == 1) {
	Ddi_BddAndAcc(myCube,c_i);
	nc++;
      }
    }
    Ddi_Free(cP);
  }

  fA = Ddi_BddarrayAlloc(ddm,1);
  Ddi_BddarrayWrite(fA,0,f);
  Ddi_AigarrayConstrainCubeAcc(fA,myCube);
  DdiGenericDataCopy((Ddi_Generic_t *)f,
    (Ddi_Generic_t *)Ddi_BddarrayRead(fA,0));
  Ddi_Free(fA);
  Ddi_Free(myCube);
  return (f);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayConstrainCubeAcc (
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *cubeAig
)
{
  int n, i;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  Ddi_Bdd_t *constAig, *cubePart;
  Ddi_Varset_t *supp;
  Ddi_Vararray_t *vars;
  Ddi_Bddarray_t *subst;

  Pdtutil_Assert(Ddi_BddIsAig(cubeAig)||Ddi_BddIsPartConj(cubeAig),
		 "Aig or conj- part cube required");

  if (Ddi_BddIsPartConj(cubeAig)) {
    cubePart = Ddi_BddDup(cubeAig);
  }
  else {
    Ddi_Bdd_t *cP = Ddi_AigPartitionTop(cubeAig,0);
    int i, nc=0;
    cubePart = Ddi_BddMakePartConjVoid(ddm);
    for (i=0; i<Ddi_BddPartNum(cP); i++) {
      Ddi_Bdd_t *c_i = Ddi_BddPartRead(cP,i);
      if (Ddi_BddSize(c_i) == 1) {
	Ddi_BddPartInsertLast(cubePart,c_i);
	nc++;
      }
    }
    Ddi_Free(cP);
  }

  n = Ddi_BddPartNum(cubePart);
  vars = Ddi_VararrayAlloc(ddm,n);
  subst = Ddi_BddarrayAlloc(ddm,n);
  for (i=0; i<n; i++) {
    Ddi_Bdd_t *p = Ddi_BddPartRead(cubePart,i);
    Ddi_Var_t *v = Ddi_VarFromBaig(ddm,Ddi_BddToBaig(p));

    if (Ddi_BddIsComplement(p))
      constAig = Ddi_BddMakeConstAig(ddm,0);
    else
      constAig = Ddi_BddMakeConstAig(ddm,1);

    Ddi_VararrayWrite(vars,i,v);
    Ddi_BddarrayWrite(subst,i,constAig);
    Ddi_Free(constAig);
  }
  Ddi_AigarrayComposeNoMultipleAcc (fA,vars,subst);
  Ddi_Free(cubePart);
  Ddi_Free(vars);
  Ddi_Free(subst);
  return(fA);

}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Pdtutil_Array_t *
Ddi_AigCubeMakeIntegerArrayFromBdd (
  Ddi_Bdd_t *cubeAig,
  Ddi_Vararray_t *vars
)
{
  int n, i, nVars = Ddi_VararrayNum(vars);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cubeAig);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *cubePart;
  Pdtutil_Array_t *cubeArray;

  Ddi_Bdd_t *myCube = Ddi_BddMakeAig(cubeAig);

  cubePart = Ddi_AigPartitionTop(myCube,0);
  Ddi_Free(myCube);

  Pdtutil_Assert(Ddi_BddIsCube(cubePart),"CUBE required");

  n = Ddi_BddPartNum(cubePart);

  cubeArray = Pdtutil_IntegerArrayAlloc(nVars);

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *p = Ddi_BddPartRead(cubePart,i);
    bAigEdge_t baig = Ddi_BddToBaig(p);
    int val = (Ddi_BddIsComplement(p)) ? 0 : 1;

    Pdtutil_Assert(bAig_AuxInt(bmgr,baig)==-1,"invalid aux int found");
    bAig_AuxInt(bmgr,baig) = val;
  }
  for (i=0; i<nVars; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vars,i);
    bAigEdge_t baig = Ddi_VarToBaig(v);
    int val = bAig_AuxInt(bmgr,baig);
    if (val < 0) val=2; /* don't care */
    Pdtutil_Assert(val>=-1 && val<=2,"wrong ternary value");
    Pdtutil_IntegerArrayInsertLast(cubeArray,val);
  }
  for (i=0; i<n; i++) {
    Ddi_Bdd_t *p = Ddi_BddPartRead(cubePart,i);
    bAigEdge_t baig = Ddi_BddToBaig(p);
    bAig_AuxInt(bmgr,baig) = -1;
  }
  Ddi_Free(cubePart);

  return(cubeArray);

}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigCubeMakeBddFromIntegerArray (
  Pdtutil_Array_t *cubeArray,
  Ddi_Vararray_t *vars
)
{
  int n=Pdtutil_IntegerArrayNum(cubeArray), i, nVars = Ddi_VararrayNum(vars);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(vars);
  Ddi_Bdd_t *cubeAig;

  Pdtutil_Assert(n==nVars,"array sizes mismatch");

  cubeAig = Ddi_BddMakeConstAig(ddm,1);

  for (i=0; i<n; i++) {
    int val = Pdtutil_IntegerArrayRead(cubeArray,i);
    if (val != 2) {
      /* skip don't care */
      Ddi_Var_t *v = Ddi_VararrayRead(vars,i);
      Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, val);
      Ddi_BddAndAcc(cubeAig,lit);
      Ddi_Free(lit);
    }
  }

  return(cubeAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigConstrainImplAcc (
  Ddi_Bdd_t *f,
  Ddi_Bddarray_t *implArray
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int i, j;
  Ddi_Vararray_t *vars;
  Ddi_Bddarray_t *subst;

  if (implArray == NULL || Ddi_BddarrayNum(implArray) == 0) {
    return f;
  }

  for (i=0; i<Ddi_BddarrayNum(implArray); i++) {
    Ddi_Bdd_t *newF;
    Ddi_Bdd_t *p = Ddi_BddarrayRead(implArray,i);
    Ddi_Bdd_t *lit0 = Ddi_BddPartRead(p,0);
    Ddi_Bdd_t *lit1 = Ddi_BddNot(lit0);
    Ddi_Bdd_t *implCube = Ddi_BddPartRead(p,1);
    Ddi_Bdd_t *implPart = Ddi_BddMakePartConjFromCube(implCube);
    subst = Ddi_BddarrayAlloc(ddm,0);
    vars = Ddi_VararrayAlloc(ddm,0);

    for (j=0; j<Ddi_BddPartNum(implPart); j++) {
      Ddi_Bdd_t *l = Ddi_BddPartRead(implPart,j);
      Ddi_Bdd_t *sBdd;
      bAigEdge_t lBaig = Ddi_BddToBaig(l);
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,lBaig);

      if (bAig_NodeIsInverted(lBaig)) {
	/* lit1 => l(zero): subst with lit0&&!l */
	sBdd = Ddi_BddDiff(lit0,l);
      }
      else {
	sBdd = Ddi_BddOr(l,lit1);
      }
      Ddi_VararrayInsertLast(vars,v);
      Ddi_BddarrayInsertLast(subst,sBdd);
      Ddi_Free(sBdd);
    }

    DdiAigComposeAcc (f,vars,subst);

    Ddi_Free(vars);
    Ddi_Free(subst);
    Ddi_Free(implPart);
    Ddi_Free(lit1);
  }

  return (f);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigConstrainOptAcc (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *c,
  Ddi_Varset_t *filterVars,
  Ddi_Varset_t *implyVars,
  Ddi_Bdd_t *pivotCube,
  int optVal
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *newf;
  Ddi_Varset_t *supp;
  Ddi_Vararray_t *vA;
  Ddi_Bddarray_t *substArray;
  Ddi_Bdd_t *cBar, *savePivot=NULL, *tmp, *implyConstrain=NULL;
  int *pivotArray=NULL;
  int i, n, freePivot=0;
  int checkResult = 0;

  if (c==NULL || Ddi_BddIsOne(c) || Ddi_BddIsConstant(f)) {
    return (f);
  }
  if (Ddi_BddIsZero(c)) {
    newf = Ddi_BddMakeConstAig(ddm,1);
    Ddi_DataCopy(f,newf);
    Ddi_Free(newf);
    return (f);
  }

  if (optVal==2) {
    Ddi_Bdd_t *cP = Ddi_AigPartitionTop(c,0);
    if (Ddi_BddPartNum(cP) == 1) {
      Ddi_Free(cP);
      return Ddi_BddAndAcc (f,c);
    }
    else {
      int i, nc=0;
      Ddi_Bdd_t *myCube = Ddi_BddMakeConstAig(ddm,1);
      for (i=0; i<Ddi_BddPartNum(cP); i++) {
        Ddi_Bdd_t *c_i = Ddi_BddPartRead(cP,i);
        if (Ddi_BddSize(c_i) == 1) {
          Ddi_BddAndAcc(myCube,c_i);
          nc++;
        }
      }
      Ddi_BddAndAcc(f,c);
      if (nc > 0) {
        Ddi_AigAndCubeAcc(f,myCube);
      }
      Ddi_Free(myCube);
      Ddi_Free(cP);
      return (f);
    }
  }

  if (optVal > 0) {
    supp = Ddi_BddSupp(f);
  }
  else {
    supp = Ddi_BddSupp(c);
  }
  if (filterVars != NULL) {
    Ddi_VarsetIntersectAcc(supp,filterVars);
    if (Ddi_VarsetIsVoid(supp)) {
      Ddi_Free(supp);
      return Ddi_BddAndAcc (f,c);
    }
  }
  vA = Ddi_VararrayMakeFromVarset(supp,1);
  n = Ddi_VararrayNum(vA);
  Ddi_Free(supp);

  pivotArray = Pdtutil_Alloc(int, n);
  for (i=0; i<n; i++) {
    pivotArray[i]=0;
  }

  tmp = Ddi_BddMakeConstAig(ddm,1);
  if (implyVars!=NULL) {
    implyConstrain = Ddi_BddMakeConstAig(ddm,1);
  }

  if (optVal == 5) {
    Ddi_Bdd_t *myOne = Ddi_BddMakeConst(ddm,1);
    Ddi_Bdd_t *cBdd = Ddi_AigPartitionTop(c,0);
    for (i=0; i<Ddi_BddPartNum(cBdd); i++) {
      Ddi_Bdd_t *p_i = Ddi_BddPartRead(cBdd,i);
      if (Ddi_BddSize(p_i)<2000) {
	Ddi_BddSetMono(p_i);
      }
      else {
	Ddi_DataCopy(p_i,myOne);
      }
    }
    Ddi_Free(myOne);
    substArray = Ddi_BddarrayMakeLiterals(vA, 1);
    for (i=0; i<Ddi_BddarrayNum(substArray); i++) {
      Ddi_Bdd_t *s_i = Ddi_BddarrayRead(substArray,i);
      Ddi_BddConstrainAcc(s_i,cBdd);
      Ddi_BddSetAig(s_i);
    }
    Ddi_Free(cBdd);
  }
  else if (optVal == 4) {
    Ddi_Bdd_t *cBdd = Ddi_BddMakeMono(c);
    substArray = Ddi_BddarrayMakeLiterals(vA, 1);
    for (i=0; i<Ddi_BddarrayNum(substArray); i++) {
      Ddi_Bdd_t *s_i = Ddi_BddarrayRead(substArray,i);
      Ddi_BddConstrainAcc(s_i,cBdd);
      Ddi_BddSetAig(s_i);
    }
    Ddi_Free(cBdd);
  }
  else {

  substArray = Ddi_BddarrayAlloc(ddm,n);

  if (pivotCube == NULL) {
    if (optVal != 3) {
      pivotCube = Ddi_AigSatWithCex(c);
    }
    else {
      /* look for a point where f=0. Wrong as not all variables are
       considered */
      Ddi_BddNotAcc(f);
      pivotCube = Ddi_AigSatWithCex(f);
      Ddi_BddNotAcc(f);
    }
    Pdtutil_Assert(pivotCube!=NULL,"constrain is zero");
    savePivot = Ddi_BddDup(pivotCube);

    freePivot=1;
  }
  if (pivotCube != NULL) {
    Ddi_Bdd_t *myPivot = Ddi_AigPartitionTop(pivotCube,0);
    Pdtutil_Assert(Ddi_BddIsCube(myPivot),"CUBE required");
    Pdtutil_Assert(optVal!=3 || n==Ddi_BddPartNum(myPivot),"wrong pivot cube");
    for (i=0; i<n; i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
      int j;
      for (j=0; j<Ddi_BddPartNum(myPivot); j++) {
	Ddi_Bdd_t *litj = Ddi_BddPartRead(myPivot,j);
	if (Ddi_BddTopVar(litj)==v) { /* @@@@@@ */
	  pivotArray[i] = !Ddi_BddIsComplement(litj);
	  Ddi_BddAndAcc(tmp,litj);
	  break;
	}
      }
      if (optVal == 3 && j>=n) {
      for (j=0; j<n; j++) {
	Ddi_Bdd_t *litj = Ddi_BddPartRead(myPivot,j);
	printf("%s\n", Ddi_VarName(Ddi_BddTopVar(litj)));
      }
      Pdtutil_Assert(j<n,"pivot variable not found");
      }
    }
    Ddi_Free(myPivot);
  }

  Pdtutil_Assert(optVal!=3 || Ddi_BddEqualSat(savePivot,tmp),
    "problem in pivot encoding");

  cBar = Ddi_BddNot(c);
  for (i=0; i<n; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Bdd_t *subst = Ddi_BddMakeLiteralAig(v, 1);
    //    fprintf(dMgrO(ddm),"VAR: %s\n", Ddi_VarName(v));
    if (implyVars!=NULL && Ddi_VarInVarset(implyVars,v)) {
      if (pivotArray[i])
        Ddi_BddAndAcc(implyConstrain,subst);
      else
        Ddi_BddDiffAcc(implyConstrain,subst);
      pivotArray[i] += 2;
    }
    switch (pivotArray[i]) {
    case 0:
      Ddi_BddAndAcc(subst,c);
      break;
    case 1:
      Ddi_BddOrAcc(subst,cBar);
      break;
    case 2:
    case 3:
      /* skip implyVars */
      break;
    }
    Ddi_BddarrayWrite(substArray,i,subst);
    Ddi_Free(subst);
  }
  if (implyVars!=NULL) {
    Ddi_BddOrAcc(implyConstrain,c);
  }
  Ddi_Free(cBar);

  }

  newf = Ddi_BddDup(f);
  DdiAigComposeAcc (newf,vA,substArray);

  if (implyVars!=NULL) {
    Ddi_BddAndAcc(newf,implyConstrain);
  }

  if (0 && checkResult && filterVars!=NULL) {
    Ddi_Bdd_t *a0 = Ddi_BddExist(f,filterVars);
    Ddi_Bdd_t *a1 = Ddi_BddAnd(f,c);
    Ddi_BddExistAcc(a1,filterVars);
    Ddi_BddXorAcc(a0,a1);
    Ddi_Free(a1);
    Pdtutil_Assert(!Ddi_AigSat(a0),"error in constrain opt");
    Ddi_Free(a0);
  }
  else if (checkResult && optVal == 3) {
    Ddi_Bdd_t *f1 = Ddi_BddAnd(f,c);
    Ddi_BddXorAcc(f1,newf);
    if (Ddi_AigSat(f1)) {
      pivotCube = Ddi_AigSatWithCex(f1);
      fprintf(dMgrO(ddm),"cex in constr %d\n", Ddi_AigSatAnd(pivotCube,c,NULL));
    }
    Pdtutil_Assert(!Ddi_AigSat(f1),"error in constrain opt");
    Ddi_Free(f1);
  }

  Ddi_DataCopy (f,newf);
  Ddi_Free(newf);
  //  Ddi_BddAndAcc (f,c);

  if (freePivot) {
    Ddi_Free(pivotCube);
    Ddi_Free(savePivot);
  }
  Pdtutil_Free(pivotArray);
  Ddi_Free(substArray);
  Ddi_Free(vA);
  Ddi_Free(tmp);
  Ddi_Free(implyConstrain);

  return (f);
}

/**Function********************************************************************
  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByBddSweepTop(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  int maxMerge
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int j, size1, size=Ddi_BddSize(f), bddMergeTh = 250;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);

  for (j=1; j<=maxMerge; j++) {
    int mySize0 = j==1 ? Ddi_BddSize(f) : size;
    Ddi_AigOptByFoCntWithCare(f, care, 100, -1, -1, 10, size/3, 3,
			bddMergeTh, 5+(j)%2, 1, NULL);
    size1 = size = Ddi_BddSize(f);
    if (verbosity >= Pdtutil_VerbLevelDevMin_c) {
      printf("AIG OPT: merged SIZE[%d]: %d (tot aig: %d)\n",
	     j, size1, Ddi_MgrReadAigNodesNum(ddm));
    }
    if (size > mySize0 * 0.95) break;
    bddMergeTh *=2;
  }
}


/**Function********************************************************************
  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByFoCntTop(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  int enBddOpt
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int en = ddm->settings.aig.enBddFoConOpt;
  int i, size0, size1, size;
  int maxIter = 4, maxMerge = 3;
  Ddi_Varset_t *supp = Ddi_BddSupp(f);
  int nv = Ddi_VarsetNum(supp);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int enFoCntOpt = 1;
  int mRecur = 6;
  int mRecurCut = 20;

  Ddi_Free(supp);

  if (enBddOpt || care!=NULL) maxMerge = 2;
  if (enBddOpt<0) {
    mRecur = -1;
    enFoCntOpt = 0;
    maxMerge = 0;
    enBddOpt = 0;
    verbosity = (Pdtutil_VerbLevel_e)((int)verbosity - 1);
  }
  ddm->settings.aig.enBddFoConOpt = 0;

  {
    Pdtutil_VerbLevel_e myVerbosity = Ddi_MgrReadVerbosity (ddm);
    Ddi_MgrSetVerbosity(ddm,Pdtutil_VerbLevelUsrMin_c);
    Ddi_AigStructRedRemAcc (f,NULL);
    Ddi_MgrSetVerbosity(ddm,myVerbosity);
  }

  size0 = size = Ddi_BddSize(f);
  if (size0 < 100000) maxIter=2;
  if (size0 < 50000) maxIter=1;
  if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
    printf("AIG OPT (tot aig: %d): |%d| -> ",
	   Ddi_MgrReadAigNodesNum(ddm), size0); fflush(stdout);
  }

  for (i=0; i<maxIter; i++) {
    int j, bddMergeTh = 250;
    int myMaxMerge = maxMerge;
    int bddSizeTh = enBddOpt>0 ? enBddOpt : (i<4 ? 0 : 50000);
    int iteStrategy = i<2 ? /*i+1*/ 1 : 4;
    int optByFoCnt=enFoCntOpt;
    if (i>0) {
      size0 = size = Ddi_BddSize(f);
      maxMerge = i==1 ? 1 : 0;
    }
    Ddi_AigOptByFoCnt(f, 100, -1, mRecur, 10, size/3, 3, 1, 0, i%2?1:-1, NULL);
    size1 = size = Ddi_BddSize(f);
    if (verbosity >= Pdtutil_VerbLevelDevMin_c) {
      printf("AIG OPT: intermediate SIZE1[%d]: %d (tot aig: %d)\n",
	     i, size1, Ddi_MgrReadAigNodesNum(ddm));
    }
    if (maxIter > 1) {
      Ddi_AigOptByFoCnt(f, 100, -1, mRecur, 10, size/3, 3, 1, 0, 0, NULL);
      size1 = size = Ddi_BddSize(f);
      if (verbosity >= Pdtutil_VerbLevelDevMin_c) {
	printf("AIG OPT: intermediate SIZE2[%d]: %d (tot aig: %d)\n",
	       i, size1, Ddi_MgrReadAigNodesNum(ddm));
      }
    }
    for (j=1; j<=myMaxMerge; j++) {
      int mySize0 = j==1 ? Ddi_BddSize(f) : size;
      Ddi_AigOptByFoCntWithCare(f, care, 100, -1, mRecur, 10, size/3, 3,
			bddMergeTh, 5+(i+j)%2, 1, NULL);
      size1 = size = Ddi_BddSize(f);
      if (verbosity >= Pdtutil_VerbLevelDevMin_c) {
	printf("AIG OPT: merged SIZE[%d]: %d (tot aig: %d)\n",
	       i, size1, Ddi_MgrReadAigNodesNum(ddm));
      }
      if (size < mySize0 * 0.9) {
	ddiAbcOptAcc (f,-1);
	size = Ddi_BddSize(f);
	if (size < size1*0.9 && j==myMaxMerge) myMaxMerge++;
	size1 = size;
      }

      if (size > mySize0 * 0.95) break;

      bddMergeTh *=2;
    }
    if (size1 < 0.7*size0 && nv<=40 && enBddOpt) {
      Ddi_AigOptByBdd(f,30.0 * size1/50000,500000);
      if (Ddi_BddSize(f)<size1) {
	optByFoCnt=0;
      }
    }
    if (optByFoCnt) {
      //	  Ddi_AigSift(f,NULL);
      Ddi_AigOptByFoCnt(f, 100,-1,mRecur,mRecurCut,size/3,3,
		      bddSizeTh,iteStrategy, 1, NULL);
    }
    size1 = size = Ddi_BddSize(f);
    if (verbosity >= Pdtutil_VerbLevelDevMin_c) {
      printf("AIG OPT: intermediate SIZE3[%d]: %d (tot aig: %d)\n",
	     i, size1, Ddi_MgrReadAigNodesNum(ddm));
    }
    if (size1 * 1.1 > size0) break;
    if (size1 < size0 * 0.1) break;
  }

  if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
    printf("|%d| (tot aig: %d)\n", size1, Ddi_MgrReadAigNodesNum(ddm));
  }

  ddm->settings.aig.enBddFoConOpt = en;

  return size1;
}

/**Function********************************************************************
  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByFoCnt(
  Ddi_Bdd_t *f,
  int minFo,
  int maxFo,
  int maxRecur,
  int maxRecurCut,
  int maxSize,
  int doKernelExtr,
  int enBddOpt,
  int strategy,
  int balance,
  int *auxvCntP
)
{
  return Ddi_AigOptByFoCntWithCare(f,NULL,minFo,maxFo,
				   maxRecur,maxRecurCut,maxSize,doKernelExtr,
				   enBddOpt,strategy,balance,auxvCntP);
}

/**Function********************************************************************
  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByFoCntWithCare(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  int minFo,
  int maxFo,
  int maxRecur,
  int maxRecurCut,
  int maxSize,
  int doKernelExtr,
  int enBddOpt,
  int strategy,
  int balance,
  int *auxvCntP
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *resBdd0=NULL, *resBdd1=NULL, *resBdd=NULL, *cutBdd=NULL;
  bAigEdge_t left, right, baig;
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  int i, nNodes, *lastRef, *nRef, *nRefPlus, *nRef0, *nRef1, *isCut, size0;
  int *cutLdr, *cutSize, *cutFiNum, **cutFi, *cutImply,
    **maskedFi, *irA, *ilA, *workA, *zeroRed;
  int nVisited=0, *visited=NULL;
  bAigEdge_t nodeIndex = Ddi_BddToBaig(f);
  int maxFoFound = -1, maxFoId = -1, maxFoVal=0;
  int checkRes=0;
  int useRefPlus = 0, again, nCutLdr, doIte=1;
  int **foIds, *currPin;
  int totAlloc=0;
  int nCutMerge1=0, nCutMerge=0;
  int filterNeg=0;
  int cutSizeTh=1000, maxCutSize=0;
  int nAux=0, useAuxVars=1, auxVarUsed=0;
  Ddi_Var_t *myAuxV=NULL;
  int internPiNum=0, externPiNum=0, nRedFound=0,
    nRedSame=0, nRedRed=0, nRedOr=0;
  int constCutNum=0, constCutNum0=0, constCutNum1=0, constCutSubst=0;
  int *eqNode=NULL;
  int doBddMerge = 0;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  Ddi_Bdd_t *careBdd=NULL;
  int doStructRedRem=0;
  //  int useCutImpl=!doKernelExtr;
  int useCutImpl=0;

  if (useAuxVars && auxvCntP==NULL) {
    auxvCntP = &nAux;
  }

  size0 = Ddi_BddSize(f);

  if ((strategy > 0 && strategy < 5) && (maxRecur <=0 || maxRecurCut <=0 ||
			 (maxSize > 0 && Ddi_BddSize(f)<maxSize))) {
    if ((size0 > 1000) ) {
      if (size0 < 10000 ) {
	ddiAbcOptAcc (f,-1);
      }
      else if (size0 < 100000) {
	Ddi_NnfClustSimplifyAcc(f,1);
      }
      else {
	Ddi_AigOptByFoCnt(f,minFo,maxFo,maxRecur-1,maxRecurCut,maxSize,
			  doKernelExtr, enBddOpt, 0, balance, auxvCntP);
      }
      if (enBddOpt) {
	if (enBddOpt==1 || (Ddi_BddSize(f)<enBddOpt)) {
	  Ddi_AigOptByBddWithCare(f,care,200.0,-1);
	}
      }
    }
    return enBddOpt;
  }

  cutSizeTh = size0/10;

  if (strategy == 0) {
    doIte=0;
    filterNeg = 1;
    if (balance != 0) {
      useRefPlus = 4;
    }
  }
  else if (strategy == 1) {
    useRefPlus = strategy-1;
    //    useRefPlus = 2;
    filterNeg = 0;
  }
  else if (strategy < 5) {
    //    useRefPlus = strategy-1;
    useRefPlus = strategy;
    //    filterNeg = strategy > 2;
  }
  else if (strategy >= 5) {
    /* do BDD merge */
    doIte=0;
    filterNeg = 0;
    doBddMerge = 1;
    if (cutSizeTh > 100) {
      cutSizeTh = 100;
    }
  }

  if (doBddMerge && care!=NULL) {
    int j;
    careBdd = Ddi_AigPartitionTop(care,0);
    for (j=Ddi_BddPartNum(careBdd)-1; j>=0; j--) {
      Ddi_Bdd_t *p_j = Ddi_BddPartRead(careBdd,j);
      if (Ddi_BddSize(p_j) > 1000) {
	Ddi_BddPartRemove(careBdd,j);
      }
      else {
	Ddi_BddSetMono(p_j);
      }
    }
  }

  visitedNodes = bAigArrayAlloc();

  postOrderAigVisitIntern(manager,bAig_Zero,visitedNodes,-1);

  if (1 && strategy>=5 && strategy%2==0) {
    postOrderAigVisitInternReversed(manager,nodeIndex,visitedNodes,-1);
  }
  else {
    postOrderAigVisitIntern(manager,nodeIndex,visitedNodes,-1);
  }
  postOrderAigClearVisitedIntern(manager,visitedNodes);
  //if (strategy<5)

  bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,-1);

  nNodes = visitedNodes->num;

  lastRef = Pdtutil_Alloc(int,visitedNodes->num);
  nRef = Pdtutil_Alloc(int,visitedNodes->num);
  nRefPlus = Pdtutil_Alloc(int,visitedNodes->num);
  nRef0 = Pdtutil_Alloc(int,visitedNodes->num);
  nRef1 = Pdtutil_Alloc(int,visitedNodes->num);
  isCut = Pdtutil_Alloc(int,visitedNodes->num);
  cutLdr = Pdtutil_Alloc(int,visitedNodes->num);
  cutSize = Pdtutil_Alloc(int,visitedNodes->num);
  cutFiNum = Pdtutil_Alloc(int,visitedNodes->num);
  cutImply = Pdtutil_Alloc(int,visitedNodes->num);
  cutFi = Pdtutil_Alloc(int *,visitedNodes->num);
  maskedFi = Pdtutil_Alloc(int *,visitedNodes->num);
  foIds = Pdtutil_Alloc(int *,visitedNodes->num);
  currPin = Pdtutil_Alloc(int,visitedNodes->num);
  irA = Pdtutil_Alloc(int,visitedNodes->num);
  ilA = Pdtutil_Alloc(int,visitedNodes->num);
  workA = Pdtutil_Alloc(int,visitedNodes->num);
  zeroRed = Pdtutil_Alloc(int,visitedNodes->num);
  visited = Pdtutil_Alloc(int,visitedNodes->num);

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = i;
    lastRef[i] = 0;
    workA[i] = 0;
    nRef[i] = nRef0[i] = nRef1[i] = 0;
    nRefPlus[i] = 0;
    isCut[i] = -1;
    cutLdr[i] = i;
    cutSize[i] = 1;
    cutFiNum[i] = 0;
    cutImply[i] = 0;
    zeroRed[i] = 0;
    cutFi[i] = maskedFi[i] = NULL;
    currPin[i] = 0;
    irA[i] = ilA[i] = 0;
    foIds[i]=NULL;
    if (!bAig_NodeIsConstant(baig) && bAig_isVarNode(manager,baig)) {
      cutImply[i] = 1;
    }
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
      int cutImplR, cutImplL;
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      irA[i] = ir+1;
      cutImplR = cutImply[ir];
      cutImplL = cutImply[il];
      if (!bAig_isVarNode(manager,right) && bAig_NodeIsInverted(right)) {
	cutImplR = cutImplL = 0;
	irA[i] *= -1;
      }
      ilA[i] = il+1;
      if (!bAig_isVarNode(manager,left) && bAig_NodeIsInverted(left)) {
	cutImplR = cutImplL = 0;
	ilA[i] *= -1;
      }
      if (cutImplR && cutImplL) {
	cutImply[i] = cutImplR + cutImplL;
      }
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      lastRef[ir] = lastRef[il] = i;
      nRef[ir]++; nRef[il]++;
      if (bAig_NodeIsInverted(right)) {
	nRef0[ir]++;
      }
      else {
	nRef1[ir]++;
      }
      if (bAig_NodeIsInverted(left)) {
	nRef0[il]++;
      }
      else {
	nRef1[il]++;
      }
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il, myRef = nRef[i];
    baig = visitedNodes->nodes[i];
    if (nRef[i]>=0) {
      totAlloc+=nRef[i];
      foIds[i]=Pdtutil_Alloc(int,nRef[i]);
    }
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      nRefPlus[ir]+=myRef; nRefPlus[il]+=myRef;
      Pdtutil_Assert(currPin[ir]<nRef[ir],"wrong fo pin id");
      foIds[ir][currPin[ir]++] = bAig_NodeIsInverted(right) ? -i : i;
      Pdtutil_Assert(currPin[il]<nRef[il],"wrong fo pin id");
      foIds[il][currPin[il]++] = bAig_NodeIsInverted(left) ? -i : i;
    }
  }

  /* gen cut-based fanout-free regions */
  do {
    again = 0;
    for (i=visitedNodes->num-1; i>=0; i--) {
      int ir, il, myRef = nRef[i], ilr[2], neg[2];
      int myCutLdr = cutLdr[i];
      Pdtutil_Assert(myCutLdr>=i,"wrong cut leader");
      Pdtutil_Assert(nRef[i]==currPin[i],"wrong fanout info");
      baig = visitedNodes->nodes[i];
      if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
	int k;
	right = bAig_NodeReadIndexOfRightChild(manager,baig);
	left = bAig_NodeReadIndexOfLeftChild(manager,baig);
	ir = bAig_AuxInt(manager,right);
	il = bAig_AuxInt(manager,left);
	Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
	ilr[0] = il; ilr[1] = ir;
	neg[0] = filterNeg && bAig_NodeIsInverted(left);
	neg[1] = filterNeg && bAig_NodeIsInverted(right);
	for (k=0; k<2; k++) {
	  int jj=ilr[k];
	  if (neg[k]) {
	    /* inverted - do nothing */
	    Pdtutil_Assert(filterNeg,"error in neg edge usage");
	  }
	  else if (nRef[jj] == 1 && cutLdr[jj] != myCutLdr) {
	    Pdtutil_Assert(cutLdr[jj]<myCutLdr,"wrong cut leader");
	    if (cutSizeTh<=0 || cutSize[myCutLdr]<cutSizeTh) {
	      cutLdr[jj] = myCutLdr;
	      cutSize[myCutLdr]++;
	      nCutMerge1++;
	      nCutMerge++;
	      again = 1;
	    }
	  }
	  else if (nRef[jj] > 1 && cutLdr[jj] != myCutLdr) {
	    int ii, okMerge=1;
	    for (ii=0; ii<nRef[jj]; ii++) {
	      int fo_i = filterNeg ? foIds[jj][ii] : abs(foIds[jj][ii]);
	      Pdtutil_Assert(abs(fo_i)>jj,"wrong fo info");
	      if (fo_i < 0 || fo_i != i && cutLdr[fo_i]!=myCutLdr) {
		okMerge = 0;
		break;
	      }
	    }
	    if ((okMerge) && (cutSizeTh<=0 || cutSize[myCutLdr]<cutSizeTh)) {
	      cutLdr[jj] = myCutLdr;
	      cutSize[myCutLdr]++;
	      nCutMerge++;
	      again = 1;
	    }
	  }
	}
      }
    }
  } while (again);

  for (i=nCutLdr=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    if (cutLdr[i]==i) {
      nCutLdr++;
      if (i<visitedNodes->num-1 && (cutSize[i] > maxCutSize)) {
	maxCutSize = cutSize[i];
      }
    }
    if (bAig_isVarNode(manager,baig)) {
      /* internal PI to cut region */
      if (cutLdr[i]!=i) {
	cutFiNum[cutLdr[i]]++;
	internPiNum++;
      }
    }
    else {
      int ir, il;
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      Pdtutil_Assert(ir<i && il<i,"Invalid aux int");
      if (cutLdr[ir]!=cutLdr[i]) {
	Pdtutil_Assert(cutLdr[ir]==ir,"wrong cut PI");
	/* external PI to cut region */
	externPiNum++;
	cutFiNum[cutLdr[i]]++;
      }
      if (cutLdr[il]!=cutLdr[i]) {
	Pdtutil_Assert(cutLdr[il]==il,"wrong cut PI");
	/* external PI to cut region */
	externPiNum++;
	cutFiNum[cutLdr[i]]++;
      }
    }
#if 0
    else if (0) {
      if (bAig_isVarNode(manager,baig)) {
	printf("PI[%d] in cut of size %d\n", i, cutSize[cutLdr[i]]);
      }
    }
#endif
  }

  if (filterNeg) {
    for (i=visitedNodes->num-1; i>=0; i--) {
      int ir, il, cL, myCutNum = cutFiNum[i];
      baig = visitedNodes->nodes[i];
      currPin[i]=0;
      if (cutLdr[i]==i && myCutNum>0) {
	int ii;
	cutFi[i]=Pdtutil_Alloc(int,myCutNum);
	maskedFi[i]=Pdtutil_Alloc(int,myCutNum);
	for (ii=0; ii<myCutNum; ii++) maskedFi[i][ii]=0;
      }
      if (bAig_isVarNode(manager,baig)) {
	if (cutLdr[i]!=i) {
	  /* internal PI to cut region */
	  cL = cutLdr[i];
	  cutFi[cL][currPin[cL]++] = i+1;
	}
      }
      else {
	int ir, il;
	right = bAig_NodeReadIndexOfRightChild(manager,baig);
	left = bAig_NodeReadIndexOfLeftChild(manager,baig);
	ir = bAig_AuxInt(manager,right);
	il = bAig_AuxInt(manager,left);
	Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
	Pdtutil_Assert(ir<i && il<i,"Invalid aux int");
	if (cutLdr[ir]!=cutLdr[i]) {
	  Pdtutil_Assert(cutLdr[ir]==ir,"wrong cut PI");
	  /* external PI to cut region */
	  cL = cutLdr[i];
	  cutFi[cL][currPin[cL]++] = bAig_NodeIsInverted(right) ? -(ir+1): ir+1;
	}
	if (cutLdr[il]!=cutLdr[i]) {
	  Pdtutil_Assert(cutLdr[il]==il,"wrong cut PI");
	  /* external PI to cut region */
	  cL = cutLdr[i];
	  cutFi[cL][currPin[cL]++] = bAig_NodeIsInverted(left) ? -(il+1): il+1;
	}
      }

    }
  }


  if (useRefPlus == 4) {
    maxFoId=0;
  }
  else if (useRefPlus == 1) {
    for (i=0; i<visitedNodes->num; i++) {
      int sav = nRef[i];
      nRef[i] = nRefPlus[i];
      nRefPlus[i] = sav;
    }
  }
  else if (useRefPlus == 2) {
    for (i=0; i<visitedNodes->num; i++) {
      int ii, n0=0, n1=1;
      nRefPlus[i] = nRef[i];
      if (cutLdr[i]==i) {
	for (ii=0; ii<nRef[i]; ii++) {
	  int fo_i = abs(foIds[i][ii]);
	  if (isCut[cutLdr[fo_i]]!=i) {
	    int neg_i = foIds[i][ii]<0;
	    int foCutSize_i = cutSize[cutLdr[fo_i]];
	    isCut[cutLdr[fo_i]] = i;
	    if (neg_i) {
	      n0 += foCutSize_i;
	    }
	    else {
	      n1 += foCutSize_i;
	    }
	  }
	}
	nRef[i] = cutSize[i];
      }
      else {
	nRef[i] = 0;
      }
      nRef[i] += n0>n1 ? n0: n1;
    }
  }
  else if (useRefPlus == 3) {
    for (i=0; i<visitedNodes->num; i++) {
      int j;
      nRef[i] = 0;
      nRefPlus[i] = nRef[i];
      if (cutLdr[i]==i) {
	int myCutNum = cutFiNum[i];
	int *cutPins = cutFi[i];
	if (cutPins != NULL) {
	  for (j=0; j<myCutNum; j++) {
	    int isNeg = cutPins[j]<0;
	    int j1 = abs(cutPins[j])-1;
	    nRef[j1] += myCutNum;
	  }
	}
      }
    }
  }


  if (filterNeg) {
    for (i=0; i<visitedNodes->num; i++) {
      int ir, il, cL, myCutNum = cutFiNum[i];
      if (cutLdr[i]==i && myCutNum>2) {
	int *cutPins = cutFi[i];
	int j0, j1, x;
	for (j1=1; j1<myCutNum; j1++) {
	  x = cutPins[j1];
	  for (j0=j1-1; j0>=0; j0--) {
	    int okSort = balance>=0&&(nRef[abs(cutPins[j0])-1]>=nRef[abs(x)-1]);
	    okSort |= balance==-1&&(nRef[abs(cutPins[j0])-1]<nRef[abs(x)-1]);
	    if (okSort) {
	      break;
	    }
	    else {
	      cutPins[j0+1] = cutPins[j0];
	    }
	  }
	  cutPins[j0+1] = x;
	}
      }
    }

    for (i=0; i<visitedNodes->num; i++) {
      int ir, il, myCutNum = cutFiNum[i];
      int *cutPins = cutFi[i];
      bAigEdge_t baig0, baig1;
      baig = visitedNodes->nodes[i];

      if (cutPins != NULL) {
	int j, j0, j1, sav;
	bAigEdge_t rBaig, opBaig, newrBaig;
	int isZeroRed = 0;
	Pdtutil_Assert(cutLdr[i]==i,"wrong cut pin list");
	for (j=0; j<myCutNum; j++) {
	  int isNeg = cutPins[j]<0;
	  j1 = abs(cutPins[j])-1;
	  workA[j1] = isNeg ? -1 : 1;
	}
	for (j=0; !isZeroRed && (j<myCutNum); j++) {
	  int *cutPins0, isAndPin;
	  j1 = abs(cutPins[j])-1;
	  sav = workA[j1];
	  workA[j1] = 0;
	  cutPins0 = cutFi[j1];
	  isAndPin =  cutPins[j]>0;
	  if (cutPins0!=NULL && !zeroRed[j1]) {
	    /* just consider same phase=AND */
	    int jj, myCutNum0 = cutFiNum[j1];
#if 0
	    if (foOptPropImpl(j1,workA,zeroRed,visited,&nVisited,
			      cutFi,cutFiNum,cutPins0,myCutNum0,&nRedSame,
			      &nRedRed,&nRedOr,&nRedFound,isAndPin)) {
	      isZeroRed = 1;
	      break;
	    }
#else
	    for (jj=0; jj<myCutNum0; jj++) {
	      j0 = abs(cutPins0[jj])-1;
	      if (workA[j0] != 0) {
		int samePhase = (workA[j0]>0 && cutPins0[jj]>0);
		samePhase |= (workA[j0]<0 && cutPins0[jj]<0);
		nRedFound++;
		if (isAndPin && samePhase) {
		  nRedSame++;
		  if (abs(workA[j0])==1) {
		    workA[j0] *= 2;
		  }
		}
		else if (isAndPin) {
		  nRedRed++;
      		  isZeroRed = 1;
      		  break;
		}
		else if (myCutNum0==2) {
		  nRedOr++;
      		  break;
		}
	      }
	    }
#endif
	  }
	  workA[j1] = sav;
	  if (isZeroRed) {
	    zeroRed[i] = 1;
	  }
	}
	for (j=0; j<nVisited; j++) {
	  zeroRed[visited[j]] = 0;
	}
	nVisited=0;
	for (j=0; j<myCutNum; j++) {
	  int isNeg = cutPins[j]<0;
	  j1 = abs(cutPins[j])-1;
	  if (abs(workA[j1]) > 1) {
	    maskedFi[i][j]=1;
	  }
	  workA[j1] = 0;
	}
      }
    }
  }


  if (verbosity > Pdtutil_VerbLevelDevMax_c) {
    printf("# cut ldr: %d/%d - avg cut size: %f\n", nCutLdr, visitedNodes->num,
	 ((float)visitedNodes->num)/nCutLdr);
    printf("# cut merge: %d (%d+%d) - max cut size: %d\n",
	 nCutMerge, nCutMerge1, nCutMerge-nCutMerge1, maxCutSize);
    printf("# intern PI: %d - extern PI: %d\n",
	 internPiNum, externPiNum);
    printf("# cut redundancies: %d - same: %d, zero: %d, or: %d\n",
	 nRedFound, nRedSame++, nRedRed, nRedOr);
  }

  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxAig0(manager,baig)==bAig_NULL,"wrong auxaig0");
    Pdtutil_Assert(bAig_AuxAig1(manager,baig)==bAig_NULL,"wrong auxaig1");
    if (minFo>=0 && nRef[i] < minFo) continue;
    if (maxFo>=0 && nRef[i] > maxFo) continue;
    if (useCutImpl) {
      if (maxFoId < 0 ||
	(((cutImply[i] > cutImply[maxFoId]) && 4*nRef[i] > nRef[maxFoId]) ||
	((cutImply[i] == cutImply[maxFoId]) && nRef[i] > nRef[maxFoId])
	 ) && nRef0[i]>nRef[maxFoId]/10 &&
	  nRef1[i]>nRef[maxFoId]/10) {
	maxFoId = i;
      }
    }
    else {
      int myFo = nRef[i];
      if (0 && (nRef0[i] < 0.001*nRef1[i] || nRef1[i] < 0.001*nRef0[i])) {
	myFo *= 4;
      }
      if (maxFoId < 0 || myFo>maxFoVal) {
	maxFoId = i;
	maxFoVal = nRef[maxFoId];
	if (0 && (nRef0[maxFoId] < 0.001*nRef1[maxFoId] ||
		  nRef1[maxFoId] < 0.001*nRef0[maxFoId])) {
	  maxFoVal *= 4;
	}
      }
    }
  }

  if (doBddMerge) {
    int *enCutVar = Pdtutil_Alloc(int, visitedNodes->num);
    int th = 100;
    if (enBddOpt > 1) {
      th = enBddOpt;
    }
    for (i=0; i<visitedNodes->num; i++) {
      enCutVar[i] = cutLdr[i]==i;
    }
    eqNode = aigNetlistBddMerge(ddm,visitedNodes,careBdd,enCutVar,nRef,th);
    maxFoId = -1;

    Pdtutil_Free(enCutVar);
  }

  Ddi_Free(careBdd);

  if (0 && doBddMerge && eqNode!=NULL) {
    int tmpSize;
    int *eqSize = Pdtutil_Alloc(int, visitedNodes->num);
    int *eqCnt = Pdtutil_Alloc(int, visitedNodes->num);

    for (i=0; i<visitedNodes->num; i++) {

      eqCnt[i] = 0;
      if (eqNode[i]==(i+1)) {
      }
      else {
	int iLdr = abs(eqNode[i])-1;
	eqCnt[iLdr]++;
      }
    }
    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig0, baig1, baigBdd;

      eqSize[i] = -1;
      if (eqNode[i]==(i+1) && eqCnt[i]>2) {
	bAigEdge_t baig = bAig_NonInvertedEdge(visitedNodes->nodes[i]);
	int size0 = bAig_NodeCount(manager,baig);
	if (size0<200) {
	  Ddi_Bdd_t *bdd = Ddi_BddMakeFromBaig(ddm,baig);
	  //	  Ddi_BddSetMono(bdd);
	  //	  Ddi_BddSetAig(bdd);
	  if (Ddi_BddSize(bdd)<size0) {
	    Pdtutil_Assert(bAig_AuxAig0(manager,baig) == bAig_NULL,
			   "non null aig0");
	    Pdtutil_Assert(bAig_AuxAig1(manager,baig) == bAig_NULL,
			   "non null aig1");
	    baig0 = baig1 = Ddi_BddToBaig(bdd);
	    bAig_Ref(manager, baig0); bAig_Ref(manager, baig1);
	    bAig_AuxAig0(manager,baig) = baig0;
	    bAig_AuxAig1(manager,baig) = baig1;
	  }
	  Ddi_Free(bdd);
	}
      }
    }

    for (i=0; 0 && (i<visitedNodes->num); i++) {

      eqSize[i] = -1;
      if (eqNode[i]==(i+1)) {
	/* leader */
	Pdtutil_Assert(bAig_AuxAig0(manager,baig) == bAig_NULL,"non null aig0");
	Pdtutil_Assert(bAig_AuxAig1(manager,baig) == bAig_NULL,"non null aig1");
      }
      else {
	int iLdr = abs(eqNode[i])-1;
	/* do MERGE !!! */
	bAigEdge_t baig0, baig1;
	bAigEdge_t baigLdr = visitedNodes->nodes[iLdr];
	if (eqSize[iLdr]<0) {
	  baig0 = baig1 = bAig_NonInvertedEdge(baigLdr);
	  bAig_Ref(manager, baig0); bAig_Ref(manager, baig1);
	  bAig_AuxAig0(manager,baigLdr) = baig0;
	  bAig_AuxAig1(manager,baigLdr) = baig1;
	  eqSize[iLdr] = bAig_NodeCount(manager,baigLdr);
	}
	else {
	  bAigEdge_t baig = visitedNodes->nodes[i];
	  tmpSize = bAig_NodeCount(manager,baig);
	  if (tmpSize < eqSize[iLdr]) {
	    eqSize[iLdr] = tmpSize;
	    baig0 = baig1 = bAig_NonInvertedEdge(baig);
	    bAig_Ref(manager, baig0); bAig_Ref(manager, baig1);
	    if (eqNode[i]<0) {
	      baig0 = bAig_Not(baig0);
	      baig1 = bAig_Not(baig1);
	    }
	    bAig_RecursiveDeref(manager,bAig_AuxAig0(manager,baigLdr));
	    bAig_RecursiveDeref(manager,bAig_AuxAig1(manager,baigLdr));
	    bAig_AuxAig0(manager,baigLdr) = baig0;
	    bAig_AuxAig1(manager,baigLdr) = baig1;
	  }
	}
      }
    }
    Pdtutil_Free(eqCnt);
    Pdtutil_Free(eqSize);
  }

  if (doBddMerge || maxFoId >= 0) {

    int sizec, sizer0, sizer1, sizer01;
    int doRecur = 0;
    int doJoin = 0;
    bAigEdge_t muxControl = bAig_NULL;

    if (verbosity > Pdtutil_VerbLevelDevMed_c) {
      fprintf(dMgrO(ddm),
	      "AigOptByFoCnt tot aig nodes before AIG processing: %d\n",
	      Ddi_MgrReadAigNodesNum(ddm));
    }

    for (i=0; i<visitedNodes->num; i++) {
      int ir, il, myCutNum = cutFiNum[i];
      int *cutPins = cutFi[i];
      bAigEdge_t baig0, baig1;
      baig = visitedNodes->nodes[i];

      if (eqNode!=NULL && eqNode[i]!=(i+1)) {
	/* do MERGE !!! */
	bAigEdge_t baigLdr = visitedNodes->nodes[abs(eqNode[i])-1];
	baig0 = bAig_AuxAig0(manager,baigLdr);
	baig1 = bAig_AuxAig1(manager,baigLdr);
	if (eqNode[i]<0) {
	  baig0 = bAig_Not(baig0);
	  baig1 = bAig_Not(baig1);
	}
	bAig_Ref(manager, baig0); bAig_Ref(manager, baig1);
      }
      else if (zeroRed[i]) {
	baig0 = baig1= bAig_Zero;
	bAig_Ref(manager, baig0); bAig_Ref(manager, baig1);
      }
      else if (cutPins != NULL) {
	int j, j0, j1;
	bAigEdge_t rBaig, opBaig, newrBaig;
	int nTerms=0, termSize=0;

	right = bAig_NodeReadIndexOfRightChild(manager,baig);
	left = bAig_NodeReadIndexOfLeftChild(manager,baig);
	ir = bAig_AuxInt(manager,right);
	il = bAig_AuxInt(manager,left);

	Pdtutil_Assert(cutLdr[i]==i,"wrong cut pin list");
	rBaig = bAig_One;
	bAig_Ref(manager, rBaig);

	for (j=0; j<myCutNum; j++) {
	  int isNeg = cutPins[j]<0;
	  if (maskedFi[i][j]) {
	    continue;
	  }
	  j1 = abs(cutPins[j])-1;
	  opBaig = bAig_AuxAig0(manager,visitedNodes->nodes[j1]);
	  Pdtutil_Assert(opBaig!=bAig_NULL,"NULL cut baig");
	  if (isNeg) opBaig = bAig_Not(opBaig);
	  newrBaig = bAig_And(manager,rBaig,opBaig);
	  bAig_Ref(manager, newrBaig);
	  bAig_RecursiveDeref(manager,rBaig);
	  rBaig = newrBaig;
	  if (balance==0 && myCutNum>=4) {
	    if (++termSize>1) {
	      cutPins[nTerms++]=newrBaig;
	      rBaig = bAig_One;
	      bAig_Ref(manager, rBaig);
	      termSize=0;
	    }
	  }
	}
	if (balance==0 && myCutNum>=4) {
	  if (termSize>0) {
	    cutPins[nTerms++]=rBaig;
	  }
	  while (nTerms>1) {
	    int nT = nTerms;
	    nTerms = 0;
	    for (j=0; j+1<nT; j+=2) {
	      newrBaig = bAig_And(manager,cutPins[j],cutPins[j+1]);
	      bAig_Ref(manager, newrBaig);
	      bAig_RecursiveDeref(manager,cutPins[j]);
	      bAig_RecursiveDeref(manager,cutPins[j+1]);
	      cutPins[nTerms++] = newrBaig;
	    }
	    if (j<nT) {
	      Pdtutil_Assert(j==nT-1,"wrong couple of ids");
	      cutPins[nTerms++] = cutPins[j];
	    }
	  }
	  rBaig = cutPins[0];
	}

	baig1 = baig0 = rBaig;
        bAig_Ref(manager, baig1);

	if (0&&checkRes) {
	  Ddi_Bdd_t *myBdd = Ddi_BddMakeFromBaig(ddm,baig1);
	  Ddi_Bdd_t *refBdd = Ddi_BddMakeFromBaig(ddm,
						  bAig_NonInvertedEdge(baig));
	  Ddi_Bdd_t *chk = Ddi_BddXor(myBdd,refBdd);
	  Pdtutil_Assert(!Ddi_AigSat(chk),"error");
	  Ddi_Free(chk);
	  Ddi_Free(myBdd);
	  Ddi_Free(refBdd);
	}
      }
      else if (i<maxFoId) {
	baig0 = baig1 = bAig_NonInvertedEdge(baig);
	bAig_Ref(manager, baig0); bAig_Ref(manager, baig1);
      }
      else if (i==maxFoId) {
	/* aux var HERE */
	if (!doIte) {
	  baig0 = baig1 = bAig_NonInvertedEdge(baig);
	  //	  bAig_Ref(manager, baig0); bAig_Ref(manager, baig1);
	}
	else if (useAuxVars && cutLdr[i]==i && cutSize[i]>50) {
	  char name[10000];
	  Ddi_Var_t *aV;

	  Pdtutil_Assert(auxvCntP!=NULL,"NULL auxvCntP");
	  sprintf(name,"_AUXV_PART_%d", (*auxvCntP)++);
	  aV = Ddi_VarFromName(ddm,name);
	  if (aV == NULL) {
	    aV = Ddi_VarNew(ddm);
	    Ddi_VarAttachName (aV, name);
	  }
	  auxVarUsed = 1;
	  myAuxV = aV;
	  //	  Ddi_VararrayInsertLast(cutFVars,aV);
	  //	  Ddi_BddarrayInsertLast(cutFSubst,p_j);
          baig0 = baig1 = Ddi_VarBaigId(aV);
	}
	else {
	  baig0 = bAig_Zero;
	  baig1 = bAig_One;
	  muxControl = bAig_NonInvertedEdge(baig);
	}
	//	baig0 = baig1 = bAig_NonInvertedEdge(baig);
	bAig_Ref(manager, baig0); bAig_Ref(manager, baig1);
      }
      else if (bAig_NodeIsConstant(baig) || bAig_isVarNode(manager,baig)) {
	baig0 = baig1 = bAig_NonInvertedEdge(baig);
	bAig_Ref(manager, baig0); bAig_Ref(manager, baig1);
      }
      else {
	bAigEdge_t right0, right1, left0, left1;
	int constNum=0;
	right = bAig_NodeReadIndexOfRightChild(manager,baig);
	left = bAig_NodeReadIndexOfLeftChild(manager,baig);
	ir = bAig_AuxInt(manager,right);
	il = bAig_AuxInt(manager,left);
	Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
	right0 = bAig_AuxAig0(manager,right);
	right1 = bAig_AuxAig1(manager,right);
	left0 = bAig_AuxAig0(manager,left);
	left1 = bAig_AuxAig1(manager,left);
	if (bAig_NodeIsInverted(right)) {
	  right0 = bAig_Not(right0);
	  right1 = bAig_Not(right1);
	}
	if (bAig_NodeIsInverted(left)) {
	  left0 = bAig_Not(left0);
	  left1 = bAig_Not(left1);
	}
	baig0 = bAig_And(manager,right0,left0);
	bAig_Ref(manager, baig0);
	baig1 = bAig_And(manager,right1,left1);
	bAig_Ref(manager, baig1);
	if (( (bAig_NodeIsConstant(right0) && !bAig_NodeIsConstant(left0)) ||
	      (!bAig_NodeIsConstant(right0) && bAig_NodeIsConstant(left0))) &&
	    !bAig_NodeIsConstant(baig0)) {
	  constCutNum0++;
	  constNum++;
	}
	if (( (bAig_NodeIsConstant(right1) && !bAig_NodeIsConstant(left1)) ||
	      (!bAig_NodeIsConstant(right1) && bAig_NodeIsConstant(left1))) &&
	    !bAig_NodeIsConstant(baig1)) {
	  constCutNum1++;
	  constNum++;
	}
	if (constNum==2) {
	  constCutNum++;
	}
	if (0 && constNum>0 && nRefPlus[i]>20 && muxControl != bAig_NULL) {
	  bAigEdge_t iteBaig = bAig_Or(manager,
           bAig_And(manager, muxControl, baig1),
	   bAig_And(manager, bAig_Not(muxControl),baig0));
	  bAig_Ref(manager, iteBaig); bAig_Ref(manager, iteBaig);
	  bAig_RecursiveDeref(manager,baig1);
	  bAig_RecursiveDeref(manager,baig0);
	  baig0 = baig1 = iteBaig;
	  constCutSubst++;
	}
      }

      if (bAig_AuxAig0(manager,baig)!=bAig_NULL) {
	Pdtutil_Assert(doBddMerge,"merge mode required");
	if (bAig_NodeCount(manager,bAig_AuxAig0(manager,baig)) <
	    bAig_NodeCount(manager,baig0)) {
	  bAig_RecursiveDeref(manager,baig1);
	  bAig_RecursiveDeref(manager,baig0);
	  baig0 = bAig_AuxAig0(manager,baig);
	  baig1 = bAig_AuxAig1(manager,baig);
	}
	else {
	  bAig_RecursiveDeref(manager,bAig_AuxAig0(manager,baig));
	  bAig_RecursiveDeref(manager,bAig_AuxAig1(manager,baig));
	}
	bAig_AuxAig0(manager,baig) = bAig_NULL;
	bAig_AuxAig1(manager,baig) = bAig_NULL;
      }

      Pdtutil_Assert(bAig_AuxAig0(manager,baig)==bAig_NULL,"null aig0 needed");
      Pdtutil_Assert(bAig_AuxAig1(manager,baig)==bAig_NULL,"null aig1 needed");
      bAig_AuxAig0(manager,baig) = baig0;
      bAig_AuxAig1(manager,baig) = baig1;

    }

    baig = bAig_AuxAig1(manager,visitedNodes->nodes[nNodes-1]);
    resBdd1 = Ddi_BddMakeFromBaig(ddm,baig);
    if (auxVarUsed) {
      resBdd0 = Ddi_BddMakeConstAig(ddm,1);
    }
    else {
      baig = bAig_AuxAig0(manager,visitedNodes->nodes[nNodes-1]);
      resBdd0 = Ddi_BddMakeFromBaig(ddm,baig);
    }

    if (verbosity > Pdtutil_VerbLevelDevMed_c) {
      fprintf(dMgrO(ddm),
	      "AigOptByFoCnt tot aig nodes after AIG processing: %d\n",
	      Ddi_MgrReadAigNodesNum(ddm));
    }

    if (!doBddMerge) {
      baig = bAig_NonInvertedEdge(visitedNodes->nodes[maxFoId]);
      cutBdd = Ddi_BddMakeFromBaig(ddm,baig);
      if (doIte && useCutImpl && cutImply[maxFoId]>1) {
	Ddi_Bdd_t *cex = Ddi_AigSatWithCex(cutBdd);
	if (cex!=NULL) {
	  Ddi_BddNotAcc(cex);
	  Pdtutil_Assert(!Ddi_AigSatAnd(cutBdd,cex,0),"not implied cube");
	  Ddi_BddNotAcc(cex);
	  Ddi_AigConstrainCubeAcc(resBdd1,cex);
	  Ddi_Free(cex);
	}
      }
    }
    else {
      cutBdd = NULL;
    }

    if (Ddi_BddIsComplement(f)) {
      Ddi_BddNotAcc(resBdd0);
      Ddi_BddNotAcc(resBdd1);
    }


    for (i=0; i<visitedNodes->num; i++) { /* upper */
      baig = visitedNodes->nodes[i];
      bAig_RecursiveDeref(manager,bAig_AuxAig0(manager,baig));
      bAig_RecursiveDeref(manager,bAig_AuxAig1(manager,baig));
      bAig_AuxAig0(manager,baig) = bAig_NULL;
      bAig_AuxAig1(manager,baig) = bAig_NULL;
      bAig_AuxInt(manager,baig) = -1;
    }

    bAigArrayFree(visitedNodes);


    if (0) {
      int nImply=0;
      for (i=0; i<visitedNodes->num; i++) {
	baig = visitedNodes->nodes[i];
	Pdtutil_Assert(bAig_AuxAig0(manager,baig)==bAig_NULL,"wronf auxaig0");
	Pdtutil_Assert(bAig_AuxAig1(manager,baig)==bAig_NULL,"wronf auxaig1");
	if (cutImply[i] > 2 && nRef[i]>10) {
	  Ddi_Bdd_t *f = Ddi_BddMakeFromBaig(ddm,baig);
	  if (Ddi_BddIsComplement(f)) Ddi_BddNotAcc(f);
	  nImply++;
	  DdiLogBdd(f,0);
	  Ddi_Free(f);
	}
      }
      printf("N imply: %d\n", nImply);
    }

    if (!doBddMerge) {
      Ddi_Bddarray_t *r01 = Ddi_BddarrayAlloc(ddm,2);

      if (doIte && doStructRedRem) {
	Pdtutil_VerbLevel_e myVerbosity = Ddi_MgrReadVerbosity (ddm);
	Ddi_MgrSetVerbosity(ddm,Pdtutil_VerbLevelUsrMin_c);
	Ddi_Bdd_t *c = Ddi_AigStructRedRem (resBdd0,NULL);
	Ddi_DataCopy(resBdd0,c); Ddi_Free(c);
	c = Ddi_AigStructRedRem (resBdd1,NULL);
	Ddi_DataCopy(resBdd1,c); Ddi_Free(c);
	Ddi_MgrSetVerbosity(ddm,myVerbosity);
      }

      Ddi_BddarrayWrite(r01,0,resBdd0);
      Ddi_BddarrayWrite(r01,1,resBdd1);
      //      Ddi_BddarrayWrite(r01,2,cutBdd);

      sizer01 = Ddi_BddarraySize(r01);
      Ddi_Free(r01);

      if ((!doIte)&&checkRes && (Ddi_BddSize(resBdd1) < 100000)) {
	Ddi_Bdd_t *d = Ddi_BddIte(cutBdd,resBdd1,resBdd0);
	Ddi_BddXorAcc(d,f);
	Pdtutil_Assert(!Ddi_AigSat(d),"error");
	Ddi_Free(d);
      }

      maxFoFound = nRef[maxFoId];

      sizec = Ddi_BddSize(cutBdd);
      sizer0 = auxVarUsed ? 0 : Ddi_BddSize(resBdd0);
      sizer1 = Ddi_BddSize(resBdd1);

      if (((sizec+sizer0+sizer1)*1.05 < size0) && size0 > 50000) {
	doRecur = 1; //maxRecur++;maxRecur++;
      }

    }


    if (doIte) {

      float maxGrow = 1.2;
      if (!enBddOpt) {
	maxGrow = 1.05;
	if (size0>1000000) maxGrow = 1.01;
      }

      if (verbosity > Pdtutil_VerbLevelDevMin_c) {
	if ((constCutNum+constCutSubst)>0) {
	  printf("# const cut num: %d(%d,%d/s:%d) - ITE(%d,%d,%d)\n",
		 constCutNum, constCutNum0, constCutNum1, constCutSubst,
		 sizec,sizer0,sizer1);
	}
      }

    if (doKernelExtr) {
      if (sizer0+sizer1 > maxGrow*size0) {
	doRecur = 0;
      }
      else if (sizec<size0 && 4*sizer0 < sizec && doKernelExtr*sizer1 < sizec ||
          sizer0 < size0 && 4*sizec < sizer0 && doKernelExtr*sizer1 < sizer0 ||
          sizer1 < size0 && 4*sizec < sizer1 && doKernelExtr*sizer0 < sizer1) {
	doRecur = 1;
      }
      doKernelExtr--;
    }
    else if (sizec+sizer0+sizer1 < maxGrow*size0) {
      doRecur = 1;
    }
    else {
      if (maxRecur>1 && !(enBddOpt==1)) {
	doRecur=0;
        --maxRecur;
      }
      else if (sizer01+sizec < maxGrow*size0) {
	doRecur = --maxRecur > 0;
	doJoin = 1;
      }
      else {
	doRecur = 0;
      }
    }

    if (doRecur) {
      int myMaxSize, swapCof=0;
      int okSplit = 0, myMaxRecur = maxRecur-1;
      int sizeF = Ddi_BddSize(f);
      Ddi_Bdd_t *myOne = Ddi_BddMakeConst(ddm,1);

      if (sizer0+sizer1+sizec < size0) {
	myMaxRecur++;
	okSplit = 1;
	if (doKernelExtr) doKernelExtr++;
	Ddi_DataCopy(f,myOne);
      }

      if (sizer0>sizer1) {
	Ddi_Bdd_t *t = resBdd0; resBdd0 = resBdd1; resBdd1 = t;
	int s = sizer0; sizer0 = sizer1; sizer1 = s;
	Ddi_BddNotAcc(cutBdd);
	swapCof=1;
      }
      if (doIte && doStructRedRem && swapCof) {
	fprintf(dMgrO(ddm),
	  "AigOptByFoCnt (bdd sweep resbdd1) (tot aig: %d): %d\n",
		Ddi_MgrReadAigNodesNum(ddm), sizer1);
	Ddi_AigOptByFoCntWithCare(resBdd1,cutBdd, 100, -1, 5, 10,
			Ddi_BddSize(resBdd1)/3, 3,
			250, 5, 1, NULL);
	sizer1 = Ddi_BddSize(resBdd1);
	fprintf(dMgrO(ddm),
	  "AigOptByFoCnt (bdd sweep done) (tot aig: %d): %d\n",
		Ddi_MgrReadAigNodesNum(ddm), sizer1);
      }

      if (verbosity > Pdtutil_VerbLevelUsrMax_c) {
	if (0 && (sizec<=3)) {
	  DdiLogBdd(cutBdd,0);
	}
	fprintf(dMgrO(ddm),
	  "AigOptByFoCnt (pre) (tot aig: %d): (%d=%d,%d,%d) -> \n",
		Ddi_MgrReadAigNodesNum(ddm), size0, sizec, sizer0, sizer1);
      }
      enBddOpt =
	Ddi_AigOptByFoCnt(cutBdd,minFo,maxFo,myMaxRecur,maxRecurCut,maxSize,
			  doKernelExtr, enBddOpt, strategy, balance, auxvCntP);
      sizec = Ddi_BddSize(cutBdd);
      if (sizer0+sizer1+sizec < size0 && !okSplit) {
	myMaxRecur++;
	okSplit = 1;
	if (doKernelExtr) doKernelExtr++;
	Ddi_DataCopy(f,myOne);
      }
      if (!auxVarUsed) {
	myMaxSize = maxSize;
	if (sizer0 < sizer1 && sizer0< maxSize && sizer0 > 0.15 * sizer1) {
	  myMaxSize = sizer0 * 0.5;
	}
	enBddOpt =
	  Ddi_AigOptByFoCnt(resBdd0,minFo,maxFo,myMaxRecur,maxRecurCut,
			    myMaxSize,doKernelExtr,
			    enBddOpt, strategy, balance, auxvCntP);
      }
      sizer0 = auxVarUsed ? 0 : Ddi_BddSize(resBdd0);
      if (sizer0+sizer1+sizec < size0 && !okSplit) {
	myMaxRecur++;
	okSplit = 1;
	if (doKernelExtr) doKernelExtr++;
	Ddi_DataCopy(f,myOne);
      }
      myMaxSize = maxSize;
      if (sizer1 < sizer0 && sizer1 < maxSize && sizer1 > 0.15 * sizer0) {
	myMaxSize = sizer1 * 0.5;
      }

      if (0 && doIte && swapCof && doStructRedRem && size0>100000) {
	int j;
	Ddi_Bdd_t *cutPart = Ddi_AigPartitionTop(cutBdd,1);
	Ddi_Bdd_t *resBdd1Part = Ddi_BddMakePartDisjVoid(ddm);

	for (j=Ddi_BddPartNum(cutPart)-1;j>=0;j--) {
	  Ddi_Bdd_t *lit = Ddi_BddPartRead(cutPart,j);
	  Ddi_Bdd_t *litN = Ddi_BddNot(lit);
	  if (!Ddi_AigSatAnd(resBdd1,lit,NULL)) {
	    Ddi_AigAndCubeAcc(resBdd1,litN);
	    Ddi_BddPartRemove(cutPart,j);
	  }
	  Ddi_Free(litN);
	}
	for (j=0;j<Ddi_BddPartNum(cutPart);j++) {
	  Ddi_Bdd_t *lit = Ddi_BddPartRead(cutPart,j);
	  Ddi_Bdd_t *p_j = Ddi_BddDup(resBdd1);
	  Ddi_AigAndCubeAcc(p_j,lit);
	  Ddi_BddPartInsertLast(resBdd1Part,p_j);
	  Ddi_Free(p_j);
	}
	Ddi_Free(cutPart);
	if (Ddi_BddPartNum(resBdd1Part)>1) {
	  Ddi_DataCopy(resBdd1,resBdd1Part);
	}
      }

      if (Ddi_BddIsPartDisj(resBdd1)) {
	int j;
	for (j=0; j<Ddi_BddPartNum(resBdd1); j++) {
	  Ddi_Bdd_t *r_j = Ddi_BddPartRead(resBdd1,j);
          enBddOpt =
    	    Ddi_AigOptByFoCnt(r_j,minFo,maxFo,myMaxRecur,maxRecurCut,
              myMaxSize,doKernelExtr, enBddOpt, strategy, balance, auxvCntP);
	}
	Ddi_BddSetAig(resBdd1);
      }
      else {
        enBddOpt =
  	  Ddi_AigOptByFoCnt(resBdd1,minFo,maxFo,myMaxRecur,maxRecurCut,
            myMaxSize,doKernelExtr, enBddOpt, strategy, balance, auxvCntP);
      }

      if (verbosity > Pdtutil_VerbLevelDevMin_c) {
	fprintf(dMgrO(ddm),"AigOptByFoCnt (mid): (%d=%d,%d,%d) -> ", size0,
        sizec, sizer0, sizer1);
      }
      sizer1 = Ddi_BddSize(resBdd1);
      if (verbosity > Pdtutil_VerbLevelDevMin_c) {
	fprintf(dMgrO(ddm),"(%d,%d,%d)\n", sizec, sizer0, sizer1);
      }
      if (auxVarUsed) {
	Ddi_Vararray_t *vA = Ddi_VararrayAlloc(ddm,1);
	Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,1);
	Ddi_VararrayWrite(vA,0,myAuxV);
	Ddi_BddarrayWrite(fA,0,cutBdd);
	resBdd =  Ddi_BddCompose(resBdd1,vA,fA);
	Ddi_Free(vA);
	Ddi_Free(fA);
      }
      else {
	resBdd = Ddi_BddIte(cutBdd,resBdd1,resBdd0);
      }
      if (Ddi_BddSize(resBdd) < 20000) {
	ddiAbcOptAcc (resBdd,-1);
      }
      else if (0) {
	Ddi_AigOptByFoCnt(resBdd,minFo,maxFo,maxRecur-1,maxRecurCut,maxSize,
			  doKernelExtr, enBddOpt, 0, !balance, auxvCntP);
      }
      if (enBddOpt) {
        int size0 = Ddi_BddSize(resBdd);
	if (enBddOpt==1 || (size0 < enBddOpt)) {
	  Ddi_AigOptByBdd(resBdd,200.0,500000);
	  if (size0 > 50000 && Ddi_BddSize(resBdd) > 0.9*size0) {
	    /* disable BDD opt */
	    enBddOpt = 0;
	  }
	}
      }

      if (verbosity > Pdtutil_VerbLevelUsrMax_c) {
	fprintf(dMgrO(ddm),"AigOptByFoCnt (tot): %d -> %d (tot aig: %d)\n",
		size0, Ddi_BddSize(resBdd), Ddi_MgrReadAigNodesNum(ddm));
      }
      if (okSplit || (Ddi_BddSize(resBdd) < sizeF)) {
	if (checkRes) {
	  Ddi_Bdd_t *d = Ddi_BddXor(resBdd,f);
	  Pdtutil_Assert(!Ddi_AigSat(d),"error");
	  Ddi_Free(d);
	}

	Ddi_DataCopy(f,resBdd);
      }
      if (verbosity > Pdtutil_VerbLevelUsrMax_c) {
	fprintf(dMgrO(ddm),"AigOptByFoCnt (tot+): (tot aig: %d)\n",
		Ddi_MgrReadAigNodesNum(ddm));
      }

      Ddi_Free(myOne);
      Ddi_Free(cutBdd);
      Ddi_Free(resBdd0);
      Ddi_Free(resBdd1);
      Ddi_Free(resBdd);
    }
    else {
      int recurIncr = 0; // doJoin ? 2 : 0; does not converge
      Ddi_Bdd_t *ff = doJoin ?
	Ddi_BddIte(cutBdd,resBdd1,resBdd0) : Ddi_BddDup(f);
      Ddi_Free(cutBdd);
      Ddi_Free(resBdd0);
      Ddi_Free(resBdd1);
      Ddi_Free(resBdd);
      if (doJoin) {
	Ddi_AigOptByFoCnt(ff, 100, -1, 1, 10, size0/3, 3, 1, 0, -1, NULL);
	Ddi_AigOptByFoCnt(ff, 100, -1, 1, 10, size0/3, 3, 250, 5, -1, NULL);
	//	Ddi_AigOptByFoCntTop(ff,NULL,0);
	if (Ddi_BddSize(ff)<size0) {
	  Ddi_DataCopy(f,ff);
	}
      }
      Ddi_Free(ff);
      enBddOpt =
	Ddi_AigOptByFoCnt(f,minFo,maxFoFound-1,maxRecur+recurIncr,
	   maxRecurCut-1+recurIncr,maxSize,
	   doKernelExtr, enBddOpt, strategy, balance, auxvCntP);
    }
    }
    else {
      Ddi_DataCopy(f,resBdd1);
      Ddi_Free(cutBdd);
      Ddi_Free(resBdd0);
      Ddi_Free(resBdd1);
    }
  }
  else {
    for (i=0; i<visitedNodes->num; i++) {
      baig = visitedNodes->nodes[i];
      bAig_AuxInt(manager,baig) = -1;
    }
    bAigArrayFree(visitedNodes);
  }

  for (i=0; i<nNodes; i++) {
    if (cutFi[i]!=NULL) {
      Pdtutil_Assert(maskedFi[i]!=NULL,"missing masked fi array");
      Pdtutil_Free(cutFi[i]);
      Pdtutil_Free(maskedFi[i]);
    }
    if (foIds[i]!=NULL) {
      Pdtutil_Free(foIds[i]);
    }
  }
  Pdtutil_Free(maskedFi);
  Pdtutil_Free(cutFi);
  Pdtutil_Free(foIds);
  Pdtutil_Free(currPin);
  Pdtutil_Free(irA);
  Pdtutil_Free(ilA);

  Pdtutil_Free(lastRef);
  Pdtutil_Free(nRefPlus);
  Pdtutil_Free(nRef);
  Pdtutil_Free(nRef0);
  Pdtutil_Free(nRef1);
  Pdtutil_Free(isCut);
  Pdtutil_Free(cutLdr);
  Pdtutil_Free(cutSize);
  Pdtutil_Free(cutFiNum);
  Pdtutil_Free(cutImply);
  Pdtutil_Free(workA);
  Pdtutil_Free(zeroRed);
  Pdtutil_Free(visited);

  if (eqNode!=NULL) {
    Pdtutil_Free(eqNode);
  }

  return (enBddOpt);

}

/**Function********************************************************************
  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigFilterStructMonotone(
  Ddi_Bdd_t *f,
  Ddi_Varset_t *keepVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAigEdge_t left, right, baig;
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  int i, nNodes, *ref0, *ref1, *flow, *lev, *fo, *reparCode, size0;
  int **foIds, *currPin;
  bAigEdge_t nodeIndex = Ddi_BddToBaig(f);
  Ddi_Vararray_t *vA;
  int nMono=0, nMonoVars=0, nMonoLevel=0, nMonoFlow=0, nFlow=0;
  int chkRes=0;
  int levelMax = 2;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int printFo=0;
  int nReparamI=0, nReparamL=0;
  int enPiQuant=1;
  int enRepar=1;
  int enRepar1=1;
  static int nFreeReparVars=0;

  size0 = Ddi_BddSize(f);

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(manager,nodeIndex,visitedNodes,-1);

  postOrderAigClearVisitedIntern(manager,visitedNodes);

  nNodes = visitedNodes->num;

  reparCode = Pdtutil_Alloc(int,visitedNodes->num);
  ref0 = Pdtutil_Alloc(int,visitedNodes->num);
  ref1 = Pdtutil_Alloc(int,visitedNodes->num);
  flow = Pdtutil_Alloc(int,visitedNodes->num);
  lev = Pdtutil_Alloc(int,visitedNodes->num);
  fo = Pdtutil_Alloc(int,visitedNodes->num);
  foIds = Pdtutil_Alloc(int *,visitedNodes->num);
  currPin = Pdtutil_Alloc(int,visitedNodes->num);

  if (keepVars==NULL) {
    vA = Ddi_VararrayAlloc(ddm,0);
  }
  else {
    vA = Ddi_VararrayMakeFromVarset(keepVars,1);
  }

  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = i;
    reparCode[i] = ref0[i] = ref1[i] = flow[i] =
      lev[i] = fo[i] = currPin[i] = 0;
    foIds[i]=NULL;
  }
  if (Ddi_BddIsComplement(f)) {
    ref0[nNodes-1]=1;
  }
  else {
    ref1[nNodes-1]=1;
  }

  for (i=visitedNodes->num-1; i>=0; i--) {
    baig = visitedNodes->nodes[i];
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
      int ir, il;
      int inv, invR, invL;
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      if (ref0[i] && ref1[i]) {
        ref0[ir] = ref1[ir] = ref0[il] = ref1[il] = 1;
        continue;
      }
      invR = bAig_NodeIsInverted(right);
      invL = bAig_NodeIsInverted(left);
      Pdtutil_Assert(ref0[i] != ref1[i],"missing ref");
      inv = ref0[i];

      if (inv) {
        invR = !invR; invL = !invL;
      }
      ref0[ir] |= invR;
      ref1[ir] |= !invR;
      ref0[il] |= invL;
      ref1[il] |= !invL;
    }
  }

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    int id = bAig_AuxInt(manager,varIndex);
    if (id>=0) {
      /* set ref 0 and 1 so that var is not considered as monotone */
      ref0[id] = ref1[id] = 1;
      flow[id] = 1;
      lev[id] = 1000;
    }
  }

  if (Ddi_VararrayNum(vA) > 0) {
    for (i=0; i<visitedNodes->num; i++) {
      baig = visitedNodes->nodes[i];
      if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
        int ir, il;
        int inv, invR, invL;
        right = bAig_NodeReadIndexOfRightChild(manager,baig);
        left = bAig_NodeReadIndexOfLeftChild(manager,baig);
        ir = bAig_AuxInt(manager,right);
        il = bAig_AuxInt(manager,left);
        flow[i] = flow[ir] || flow[il];
        lev[i] = (lev[ir]>lev[il] ? lev[ir] : lev[il]) + 1;
	fo[ir]++; fo[il]++;
      }
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    int ir=-1, il=-1;
    foIds[i]=Pdtutil_Alloc(int,fo[i]);
    baig = visitedNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxAig1(manager,baig)==bAig_NULL,"wrong auxaig0");
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      foIds[ir][currPin[ir]++] = bAig_NodeIsInverted(right) ? -(i+1) : i+1;
      foIds[il][currPin[il]++] = bAig_NodeIsInverted(left) ? -(i+1) : i+1;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    int ir=-1, il=-1;
    baig = visitedNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxAig1(manager,baig)==bAig_NULL,"wrong auxaig0");
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
    }
    else if (printFo &&
	     !bAig_NodeIsConstant(baig) && bAig_isVarNode(manager,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      printf("V: %s: FO -> %d\n", Ddi_VarName(v), fo[i]);
    }
    if (!bAig_NodeIsConstant(baig) && bAig_isVarNode(manager,baig)) {
      if (fo[i]==2) {
	Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	int fo0 = foIds[i][0], fo1 = foIds[i][1];
	fo0 = abs(fo0)-1; fo1 = abs(fo1)-1;
	if (fo[fo0]==1 && fo[fo1]==1 &&
	    abs(foIds[fo0][0])==abs(foIds[fo1][0])) {
	  if (printFo) printf("reparam of %s possible\n", Ddi_VarName(v));
	  if (Ddi_VarInVarset(keepVars,v)) {
	    int rId = abs(foIds[fo0][0])-1;
            if (ref0[rId]!=ref1[rId]) {
	      reparCode[rId] = 3;
	      nReparamL++;
	    }
	  }
	  else {
	    int rId = abs(foIds[fo0][0])-1;
            if (ref0[rId]!=ref1[rId]) {
	      reparCode[rId] = 2;
	      nReparamI++;
	      /* ref1 (and) -> univ Q - ref0 (or) -> exist Q */
	      reparCode[i] = ref1[rId] ? 10 : -10;
	    }
	  }
	}
      }
    }
    if (ref0[i]!=ref1[i]) {
      nMono++;
      if (flow[i]) {
        nMonoFlow++;
      }
      if (!bAig_NodeIsConstant(baig) && bAig_isVarNode(manager,baig)) {
        nMonoVars++;
	if (printFo) printf("MONO V\n");
      }
      else if (lev[i]<=levelMax) {
	if (lev[i]==1) {
	  if (fo[ir]==1) {
	    int isCompl = foIds[ir][0]<0;
	    if (ref0[i]) isCompl = !isCompl;
	    reparCode[ir] = isCompl ? -1 : 1;
	  }
	  if (fo[il]==1) {
	    int isCompl = foIds[il][0]<0;
	    if (ref0[i]) isCompl = !isCompl;
	    reparCode[il] = isCompl ? -1 : 1;
	  }
	}
	else if (0 && (reparCode[i] == 0)){
	  reparCode[i] = 3;
	}
	nMonoLevel++;
      }
    }
    if (flow[i]) {
      nFlow++;
    }
  }

  if (nFlow > 0) {
    if (verbosity >= Pdtutil_VerbLevelDevMin_c) {
      printf("# structural flow: %d/%d - REPAR L:%d I:%d\n",
	     nFlow, nNodes, nReparamL, nReparamI);
      printf("# structural monotone flow/noflow/vars/level(%d): %d/%d/%d/%d\n",
             levelMax, nMonoFlow, nMono-nMonoFlow, nMonoVars, nMonoLevel);
    }
  }

  if (1 || nMonoVars > 0) {

    Ddi_Bdd_t *resBdd;
    Ddi_Bdd_t *myConstr = Ddi_BddMakeConstAig(ddm,1);

    if (verbosity >= Pdtutil_VerbLevelDevMin_c) {
      printf("# structural monotone vars / gates: %d / %d\n", nMonoVars, nMono);
    }

    for (i=0; i<visitedNodes->num; i++) {
      int ir, il;
      bAigEdge_t baig1;
      baig = visitedNodes->nodes[i];

      if (bAig_NodeIsConstant(baig)) {
	baig1 = bAig_NonInvertedEdge(baig);
	bAig_Ref(manager, baig1);
      }
      else if (bAig_isVarNode(manager,baig)) {
	baig1 = bAig_NonInvertedEdge(baig);
        if (enPiQuant&&ref0[i]!=ref1[i]) {
          baig1 = ref1[i] ? bAig_One : bAig_Zero;
        }
	bAig_Ref(manager, baig1);
      }
      else {
	bAigEdge_t right1, left1;
	right = bAig_NodeReadIndexOfRightChild(manager,baig);
	left = bAig_NodeReadIndexOfLeftChild(manager,baig);
	ir = bAig_AuxInt(manager,right);
	il = bAig_AuxInt(manager,left);
	Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
	right1 = bAig_AuxAig1(manager,right);
	left1 = bAig_AuxAig1(manager,left);
	if (bAig_NodeIsInverted(right)) {
	  right1 = bAig_Not(right1);
	}
	if (bAig_NodeIsInverted(left)) {
	  left1 = bAig_Not(left1);
	}
	if (reparCode[i]==2 && enRepar) {
	  bAigEdge_t rr, rl, lr, ll, tmp, common;
	  int irr, irl, ilr, ill;
	  rr = bAig_NodeReadIndexOfRightChild(manager,right);
	  rl = bAig_NodeReadIndexOfLeftChild(manager,right);
	  lr = bAig_NodeReadIndexOfRightChild(manager,left);
	  ll = bAig_NodeReadIndexOfLeftChild(manager,left);
	  if (bAig_NodeIsInverted(right) && bAig_NodeIsInverted(left)) {
	    rr = bAig_Not(rr); rl = bAig_Not(rl);
	    lr = bAig_Not(lr); ll = bAig_Not(ll);
	    if (rr == bAig_Not(lr)) {}
	    else if (rr == bAig_Not(ll)) {tmp=ll; ll=lr; lr=tmp;}
	    else if (rl == bAig_Not(lr)) {tmp=rl; rl=rr; rr=tmp;}
	    else if (rl == bAig_Not(ll)) {
	      tmp=rl; rl=rr; rr=tmp;
	      tmp=ll; ll=lr; lr=tmp;
	    }
	    else {
	      Pdtutil_Assert(0,"error detecting mux");
	    }
	    irr = bAig_AuxInt(manager,rr);
	    if (abs(reparCode[irr])<10) {
	      /* mux is a xnor: wrong pi chosen, take other */
	      tmp=rl; rl=rr; rr=tmp;
	      tmp=ll; ll=lr; lr=tmp;
	      irr = bAig_AuxInt(manager,rr);
	      Pdtutil_Assert(abs(reparCode[irr])==10,"error detecting mux");
	    }
	    if (1 && (rl == bAig_Not(ll))) {
	      //	      enRepar--;
	      right1 = left1 = bAig_One;
	      if (reparCode[irr]<0) {
		/* monotone at 0 - take univ quantif... */
		right1 = bAig_Not(right1);
		left1 = bAig_Not(left1);
	      }
	    }
	    else if (1) {
	      /* take free var */
	      Ddi_Bdd_t *constr = NULL;
	      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,rr);
	      Ddi_Bdd_t *c0 = Ddi_BddMakeFromBaig(ddm,baig);
	      Ddi_Bdd_t *c1 = Ddi_BddMakeFromBaig(ddm,baig);
	      Ddi_Bdd_t *vLit = Ddi_BddMakeLiteralAig(v,1);
	      Ddi_BddCofactorAcc(c0,v,0);
	      Ddi_BddCofactorAcc(c1,v,1);
	      right1 = left1 = bAig_AuxAig1(manager,rr);
	      if (reparCode[irr]<0) {
		/* monotone at 0 - take univ quantif... */
		/* !vLit -> !constr */
		constr = Ddi_BddAnd(c0,c1);
		Ddi_BddNotAcc(constr);
		Ddi_BddOrAcc(constr,vLit);
	      }
	      else {
		/* vLit -> constr */
		constr = Ddi_BddOr(c0,c1);
		Ddi_BddNotAcc(vLit);
		Ddi_BddOrAcc(constr,vLit);
	      }
	      Ddi_Free(c0);
	      Ddi_Free(c1);
	      Ddi_Free(vLit);
	      Ddi_BddAndAcc(myConstr,constr);
	      Ddi_Free(constr);
	    }
	  }
	}
	else if (reparCode[i]==3 && enRepar1) {
	  /* take free var */
	  int monotoneOne = ref1[i];
	  Ddi_Bdd_t *vLit;
	  Ddi_Bdd_t *constr = Ddi_BddMakeFromBaig(ddm,
						  bAig_NonInvertedEdge(baig));
	  Ddi_Var_t *v = NULL;
	  char name[10000];
	  bAigEdge_t vBaig;
	  sprintf(name,"_REPAR_AUXV__%d", nFreeReparVars++);
	  v = Ddi_VarNewBaig(ddm,name);
	  vLit = Ddi_BddMakeLiteralAig(v,1);
	  vBaig = Ddi_VarToBaig(v);
	  right1 = left1 = vBaig;
	  //	  enRepar1=0;
	  if (!monotoneOne) {
	    /* monotone at 0 - take univ quantif... */
	    /* !vLit -> !constr */
	    Ddi_BddNotAcc(constr);
	    Ddi_BddOrAcc(constr,vLit);
	  }
	  else {
	    /* vLit -> constr */
	    Ddi_BddNotAcc(vLit);
	    Ddi_BddOrAcc(constr,vLit);
	  }
	  Ddi_Free(vLit);
	  Ddi_BddAndAcc(myConstr,constr);
	  Ddi_Free(constr);
	}

	baig1 = bAig_And(manager,right1,left1);
	bAig_Ref(manager, baig1);
      }

      bAig_AuxAig1(manager,baig) = baig1;
    }

    baig = bAig_AuxAig1(manager,visitedNodes->nodes[nNodes-1]);
    resBdd = Ddi_BddMakeFromBaig(ddm,baig);
    if (Ddi_BddIsComplement(f)) {
      Ddi_BddNotAcc(resBdd);
    }

    if (myConstr!=NULL && !Ddi_BddIsOne(myConstr)) {
      Ddi_BddAndAcc(resBdd,myConstr);
    }

    if (chkRes==2) {
      if (!Ddi_BddIncluded(resBdd,f)) {
	Ddi_BddDiffAcc(resBdd,f);
	Ddi_Bdd_t *cex = Ddi_AigSatWithCex(resBdd);
	Ddi_Free(cex);
      }
      Pdtutil_Assert(Ddi_BddIncluded(resBdd,f),
		     "error in struct monotonicity");
    }
    else if (chkRes==1) {
      Pdtutil_Assert(Ddi_BddIncluded(f,resBdd),
		     "error in struct monotonicity");
    }

    if (verbosity >= Pdtutil_VerbLevelDevMin_c) {
      printf("# structural monotone size %d -> %d\n", Ddi_BddSize(f),
             Ddi_BddSize(resBdd));
    }

    Ddi_DataCopy (f,resBdd);
    Ddi_Free(myConstr);
    Ddi_Free(resBdd);
  }

  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_RecursiveDeref(manager,bAig_AuxAig1(manager,baig));
    bAig_AuxAig1(manager,baig) = bAig_NULL;
    bAig_AuxInt(manager,baig) = -1;
    if (foIds[i]!=NULL) {
      Pdtutil_Free(foIds[i]);
    }
  }

  bAigArrayFree(visitedNodes);

  Ddi_Free(vA);

  Pdtutil_Free(currPin);
  Pdtutil_Free(foIds);
  Pdtutil_Free(fo);
  Pdtutil_Free(lev);
  Pdtutil_Free(flow);
  Pdtutil_Free(ref0);
  Pdtutil_Free(ref1);
  Pdtutil_Free(reparCode);

  return (nMonoVars);

}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByMinCut(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *projectVars,
  int optLevel,
  int topDecomp,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int i, n;
  Ddi_Varset_t *supp;
  Ddi_Vararray_t *vA;
  float cutRatio;
  Ddi_Bdd_t *newF;
  float lazyRate = Ddi_MgrReadAigLazyRate (ddm);

  if (lazyRate <= 1.1) {
    Ddi_MgrSetOption(ddm,Pdt_DdiLazyRate_c,fnum,1.1);
  }

  supp = Ddi_BddSupp(f);

  Ddi_VarsetDiffAcc(supp,projectVars);
  n = Ddi_VarsetNum(supp);

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  AigVararraySortByFlow(vA,f);

  newF = Ddi_AigPartitionTop(f,0);

  do {
    int refSizeTot, refSize;
    Ddi_Varset_t *currSupp = Ddi_BddSupp(newF);

    refSizeTot = refSize = Ddi_BddSize(newF);
    cutRatio = ((float)800) / refSize;
    for (i=0; i<n; i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
      if (Ddi_VarInVarset(currSupp,v)) {
        //      FindMinCut(f,v,supp,-1,4,0,1);
        if (FindMinCut(newF,care,v,supp,-1,50,0,0,cutRatio) != NULL) {
	  Ddi_Free(currSupp); /* f changed: recompute curr supp */
          currSupp = Ddi_BddSupp(newF);
	}
      }
    }
    Ddi_Free(currSupp);
  } while (0);

  Ddi_Free(supp);

  Ddi_BddSetAig(newF);

  DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)newF);
  Ddi_Free(newF);

  Ddi_MgrSetOption(ddm,Pdt_DdiLazyRate_c,fnum,lazyRate);

  return 1;
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptCustom(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  int optLevel,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int sizeNew, size, wSize;
  Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *totCare = Ddi_BddDup(myCare);

  if (care!=NULL) {
    Ddi_BddAndAcc(totCare,care);
  }

  sizeNew = size;
  wSize = 10000;
  Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
  Ddi_MgrSetSiftThresh (ddm, 10000);
  {
    int aol = Ddi_MgrReadAigAbcOptLevel (ddm);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,1);

    ddiAbcOptAcc (f,-1);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,aol);
  }
  {
    int i, iMin, s, sMin, sTot;
    Ddi_Bdd_t *p_i, *partFAnd = Ddi_AigPartitionTop(f,0);
    Ddi_Bddarray_t *implied = Ddi_BddarrayAlloc(ddm,0);
    //	Ddi_Bdd_t *partFOr = Ddi_AigPartitionTop(f,1);
    sTot = Ddi_BddSize(f);
    while (1) {
      Ddi_Bdd_t *pDup=NULL;
      iMin = -1;
      for (i=0; i<Ddi_BddPartNum(partFAnd); i++) {
        p_i = Ddi_BddPartRead(partFAnd,i);
        s = Ddi_BddSize(p_i);
        if (iMin<0 || s<sMin) {
          iMin = i; sMin = s;
        }
      }
      p_i = Ddi_BddPartExtract(partFAnd,iMin);
      pDup = Ddi_BddDup(p_i);
      s = Ddi_BddSize(p_i);
      if (s>sTot*0.05) {
        Ddi_Free(p_i);
        break;
      }
      Ddi_AigConstrainOptAcc(p_i,myCare,NULL,NULL,NULL,1);
      //          Ddi_AigOptByCut(p_i,myCare,wSize,30,-1);

      if (1||(s<50000)) {
        Ddi_AigOptByBdd(p_i,-1,-1);
	if (Ddi_BddSize(p_i)>Ddi_BddSize(pDup)) {
	  Ddi_DataCopy(p_i,pDup);
	}
      }
      if (Ddi_BddIsOne(p_i)) {
	Ddi_BddarrayInsertLast(implied,pDup);
      }
      else {
	Ddi_BddarrayInsertLast(implied,pDup);
	Ddi_BddarrayInsertLast(implied,p_i);
        Ddi_BddAndAcc(myCare,p_i);
        if (Ddi_BddSize(myCare)<50000) {
          Ddi_AigOptByBdd(myCare,-1,-1);
        }
      }
      Ddi_Free(pDup);
      if (0)
      {
        Ddi_Varset_t *vs = Ddi_BddSupp(p_i);
        Ddi_Vararray_t *va = Ddi_VararrayMakeFromVarset(vs, 1);
        int i;
        Ddi_BddSetMono(p_i);
        fprintf(dMgrO(ddm),"SIZE P: %d\n", Ddi_BddSize(p_i));
        for (i=0; i<Ddi_VararrayNum(va); i++) {
          Ddi_Var_t *v = Ddi_VararrayRead(va,i);
          Ddi_Bdd_t *cof = Ddi_BddMakeLiteral(v,1);
          Ddi_BddConstrainAcc(cof,p_i);
          fprintf(dMgrO(ddm),"SIZE c[%d]: %d\n", i, Ddi_BddSize(cof));
          Ddi_Free(cof);
        }
        Ddi_Free(va);
        Ddi_Free(vs);
      }
      Ddi_Free(p_i);

      //	Ddi_Free(partFOr);
    }
    if (0 && Ddi_BddarrayNum(implied)>0) {
      int mySize;
      fprintf(dMgrO(ddm),"%d implied aigs\n", Ddi_BddarrayNum(implied));
      Ddi_BddSetAig(partFAnd);
      mySize = Ddi_BddSize(partFAnd);
      Ddi_AigOptByImpl(partFAnd,implied,1,-1);
      fprintf(dMgrO(ddm),"implied opt: %d->%d\n\n", mySize, Ddi_BddSize(partFAnd));
    }
    Ddi_BddAndAcc(totCare,myCare);
    Ddi_Free(partFAnd);
    Ddi_Free(implied);
  }

  sizeNew = Ddi_BddSize(f);
  Ddi_AigConstrainOptAcc(f,totCare,NULL,NULL,NULL,1);
  do {
    Ddi_Bdd_t *f2 = Ddi_BddDup(f);

    size = sizeNew;
    Ddi_AigOptByCut(f,totCare,wSize,3,-1);
    sizeNew = Ddi_BddSize(f);
    wSize *= 1.2;
    Ddi_BddXorAcc(f2,f);
    Pdtutil_Assert(1||!Ddi_AigSatAnd(f2,totCare,NULL),"Wrong cut opt");
    Ddi_Free(f2);
  } while (sizeNew < size && wSize < 50000);


  Ddi_AigOptByBdd(f,-1,-1);
  Ddi_BddAndAcc(f,myCare);
  Ddi_AigOptByBdd(f,-1,-1);

  Ddi_Free(myCare);
  Ddi_Free(totCare);

  return 1;
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByPart(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  int optLevel,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *fPart = Ddi_AigPartitionTop(f,0);

  bAig_array_t *visitedNodes, *impliedNodes;

  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int size=Ddi_BddSize(f),iMin,i,j,n = Ddi_BddPartNum(fPart);

  int *s = Pdtutil_Alloc(int, n);
  int firstBigSize = -1;
  int sharedCutNum = 0;
  int useCutVars = 0;

  Ddi_Bddarray_t *orComponent = Ddi_BddarrayAlloc(ddm,n);
  Ddi_Bdd_t *zero = Ddi_BddMakeConstAig(ddm,0);
  Ddi_Bdd_t *constraint = Ddi_BddMakeConstAig(ddm,1);

  Ddi_Bddarray_t *cutFSubst = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Vararray_t *cutFVars = Ddi_VararrayAlloc(ddm,0);
  int *auxvId = Pdtutil_Alloc(int, n);


  for (i=0;i<n; i++) {
    s[i] = Ddi_BddSize(Ddi_BddPartRead(fPart,i));
    auxvId[i] = -1;
    Ddi_BddarrayWrite(orComponent,i,zero);
  }

  for (i=0;i<n; i++) {
    iMin=i;
    for (j=i+1;j<n;j++) {
      if (s[j]<s[iMin]) {
  	iMin = j;
      }
    }
    if (iMin!=i) {
      int t = s[i]; s[i]=s[iMin]; s[iMin]=t;
      Ddi_Bdd_t *p_i = Ddi_BddDup(Ddi_BddPartRead(fPart,i));
      Ddi_BddPartWrite(fPart,i,Ddi_BddPartRead(fPart,iMin));
      Ddi_BddPartWrite(fPart,iMin,p_i);
      Ddi_Free(p_i);
    }
  }
  for (i=0;i<n; i++) {
    fprintf(dMgrO(ddm),"s[%d]=%d\n", i, s[i]);
  }

  if (optLevel>3) {
    for (i=0; i<n; i++) {
      Ddi_Bdd_t *fAig = Ddi_BddPartRead(fPart,i);
      fprintf(dMgrO(ddm),"PART opt by BDD[%d] = %d\n", i, Ddi_BddSize(fAig));
      Ddi_AigOptByBdd (fAig,timeLimit,-1);
    }
  }
  else if (optLevel==3) {
    for (i=0; i<n; i++) {
      Ddi_Bdd_t *fAig = Ddi_BddPartRead(fPart,i);
      Ddi_BddNotAcc(fAig);
      Ddi_AigOptByPart(fAig, NULL, 1, -1.0);
      Ddi_BddNotAcc(fAig);
    }
  }

  visitedNodes = bAigArrayAlloc();
  impliedNodes = bAigArrayAlloc();

  for (i=n-1; i>=0; i--) {
    bAigEdge_t baig, fBaig;
    Ddi_Bdd_t *fAig = Ddi_BddPartRead(fPart,i);
    int n1, n0 = visitedNodes->num;
    if (Ddi_BddIsOne(fAig)) {
      continue;
    }
    fBaig = Ddi_BddToBaig(fAig);
    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
    n1 = visitedNodes->num;
    for (j=n0; j<n1; j++) {
      baig = visitedNodes->nodes[j];
      Pdtutil_Assert(bAig_AuxInt(bmgr,baig) == -1,"aux int field is not clean");
      bAig_AuxInt(bmgr,baig) = j;
      if (firstBigSize > 0) {
	bAigEdge_t r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
	bAigEdge_t l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
	int ir, il;
	ir = rightChildAuxInt(bmgr,baig);
	il = leftChildAuxInt(bmgr,baig);
	if (ir < firstBigSize && !nodeAuxChar(bmgr,r) &&
	    !bAig_isVarNode(bmgr,r)) {
	  /* shared node */
	  sharedCutNum++;
	  nodeAuxChar(bmgr,r) = 1;
	}
	if (il < firstBigSize && !nodeAuxChar(bmgr,l) &&
	    !bAig_isVarNode(bmgr,l)) {
	  /* shared node */
	  sharedCutNum++;
	  nodeAuxChar(bmgr,l) = 1;
	}
      }
    }
    if (n1==n0) {
      fprintf(dMgrO(ddm),"implied node[%d]: %d\n", i, s[i]);
      bAigArrayWriteLast(impliedNodes,fBaig);
    }
    else {
      if (n1-n0 < 10) {
        fprintf(dMgrO(ddm),"partially shared[%d]: %d(%d)\n", i, s[i], n1-n0);
        //      bAigArrayWriteLast(impliedNodes,fBaig);
        fprintf(dMgrO(ddm),"Sharing cut num %d\n", sharedCutNum);
      }
      else {
        fprintf(dMgrO(ddm),"    new node[%d]: %d\n", i, s[i]);
        firstBigSize = n1;
        fprintf(dMgrO(ddm),"Sharing cut num %d\n", sharedCutNum);
      }
    }
  }
  postOrderAigClearVisitedIntern(bmgr, visitedNodes);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig;
    baig = visitedNodes->nodes[i];
    assert(bAig_AuxAig0(bmgr, baig) == bAig_NULL);
    assert(bAig_AuxAig1(bmgr, baig) == bAig_NULL);
  }

  for (i=0; i<impliedNodes->num; i++) {
    bAigEdge_t baig;
    baig = impliedNodes->nodes[i];
    if (bAig_NodeIsInverted(baig)) {
      bAig_AuxAig1(bmgr, baig) = bAig_Zero;
    }
    else {
      bAig_AuxAig1(bmgr, baig) = bAig_One;
    }
  }


  for (i=n-2; i>=0; i--) {
    bAigEdge_t baig, fBaig0, fBaig;
    Ddi_Bdd_t *fAig = Ddi_BddPartRead(fPart,i);
    Ddi_Bdd_t *fAig0 = Ddi_BddPartRead(fPart,i+1);
    int n1, n0;

    fBaig = Ddi_BddToBaig(fAig);
    fBaig0 = Ddi_BddToBaig(fAig0);

    n1 = bAig_AuxInt(bmgr,fBaig);
    n0 = bAig_AuxInt(bmgr,fBaig0);

    if (n1>n0 && ((n1-n0) < 20)) {
      Ddi_Bdd_t *fOr_i = Ddi_AigPartitionTop(fAig,1);
      int j, jMax, jCnt, size_i = Ddi_BddSize(fAig);
      for (j=jCnt=0; j<Ddi_BddPartNum(fOr_i); j++) {
	Ddi_Bdd_t *p_j = Ddi_BddPartRead(fOr_i,j);
	if (Ddi_BddSize(p_j) > 10) {
	  jCnt++;
	  jMax = j;
	}
      }
      if (optLevel > 1 && jCnt == 1) {
	Ddi_Bdd_t *p_j = Ddi_BddPartExtract(fOr_i,jMax);
	bAigEdge_t baig_j = Ddi_BddToBaig(p_j);
	if (bAig_AuxInt(bmgr,baig_j) < n0 &&
            bAig_AuxAig1(bmgr,baig_j) != bAig_Zero &&
            bAig_AuxAig1(bmgr,baig_j) != bAig_One) {
	  bAigEdge_t baig1,baigRef,baigOr;
	  int inv = bAig_NodeIsInverted(baig_j);

	  fprintf(dMgrO(ddm),"Implied part found: %d\n", i);
	  Ddi_BddSetAig(fOr_i);

	  Ddi_BddarrayWrite(orComponent,i,fOr_i);
	  Ddi_BddPartWrite(fPart,i,p_j);

	  Ddi_BddNotAcc(fOr_i);
          baigRef = bAig_AuxAig1(bmgr,baig_j);
       	  baigOr = Ddi_BddToBaig(fOr_i);
	  // baigOr = bAig_Zero;
	  if (baigRef == bAig_NULL) {
	    if (useCutVars) {
	      char name[10000];
	      Ddi_Var_t *aV;
	      auxvId[i] = Ddi_VararrayNum(cutFVars);
	      sprintf(name,"_AUXV_PART_%d", auxvId[i]);
	      aV = Ddi_VarFromName(ddm,name);
	      if (aV == NULL) {
	        aV = Ddi_VarNew(ddm);
	        Ddi_VarAttachName (aV, name);
	      }
	      Ddi_VararrayInsertLast(cutFVars,aV);
	      Ddi_BddarrayInsertLast(cutFSubst,p_j);
	      baigRef = Ddi_VarBaigId(aV);
	    }
	    else {
      	      baigRef = bAig_Zero;
	      // baigRef = baig_j;
	    }
	    bAig_Ref(bmgr, baigRef);
	  }
	  else {
	    if (inv) {
	      baigRef = bAig_Not(baigRef);
	    }
	  }

	  if (useCutVars) {
	    baig1 = baigRef;
	  }
	  else {
	    baig1 = bAig_Or(bmgr,baigRef,baigOr);
	  }
	  bAig_Ref(bmgr, baig1);
	  bAig_RecursiveDeref(bmgr,baigRef);

	  if (inv) {
	    baig1 = bAig_Not(baig1);
	  }
          bAig_AuxAig1(bmgr,baig_j) = baig1;

	}
	Ddi_Free(p_j);
      }
      Ddi_Free(fOr_i);
    }
  }



  /* recompute f */

  for (i=0; i<visitedNodes->num; i++) {
    int inverted;
    bAigEdge_t baig1,baig = visitedNodes->nodes[i];

    baig1 = bAig_NonInvertedEdge(baig);
    if (!bAig_isVarNode(bmgr,baig) &&
             !bAig_NodeIsConstant(baig)) {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                               bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                               bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
    }
    bAig_Ref(bmgr, baig1);
    if (bAig_AuxAig1(bmgr,baig) != bAig_NULL) {
      bAig_AuxAig0(bmgr,baig) = baig1;
      if (!bAig_NodeIsConstant(bAig_AuxAig1(bmgr,baig))) {
	/* or redundancy */
        bAigEdge_t baigOr, baigTot;
	baigOr = bAig_AuxAig1(bmgr,baig);
	baigTot = bAig_Or(bmgr,baig1,baigOr);
	bAig_Ref(bmgr, baigTot);
	bAig_RecursiveDeref(bmgr,baigOr);
	bAig_AuxAig1(bmgr,baig) = baigTot;
      }
    }
    else {
      bAig_AuxAig1(bmgr,baig) = baig1;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    if (nodeAuxChar(bmgr,baig)) {
      //      sharedCutNum++;
    }
    nodeAuxChar(bmgr,baig) = 0;
    bAig_AuxInt(bmgr,baig) = -1;
  }

  fprintf(dMgrO(ddm),"TOTAL Sharing cut num %d\n", sharedCutNum);

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *newfAig, *newfAig1=NULL, *fAig = Ddi_BddPartRead(fPart,i);
    bAigEdge_t baig, baig1, fBaig;
    if (Ddi_BddIsConstant(fAig)) {
      continue;
    }
    fBaig = Ddi_BddToBaig(fAig);
    baig = bAig_AuxAig0(bmgr,fBaig);
    baig1 = bAig_AuxAig1(bmgr,fBaig);
    if (baig==bAig_NULL) {
      baig = bAig_AuxAig1(bmgr,fBaig);
    }
    if (bAig_NodeIsInverted(fBaig)) {
      baig = bAig_Not(baig);
      baig1 = bAig_Not(baig1);
    }
    newfAig = Ddi_BddMakeFromBaig(ddm, baig);
    newfAig1 = Ddi_BddMakeFromBaig(ddm, baig1);
    if (!Ddi_BddIsZero(Ddi_BddarrayRead(orComponent,i))) {
      Ddi_Bdd_t *auxF=NULL;
      fprintf(dMgrO(ddm),"I= %d - newf=%d,  orC=%d\n",i, Ddi_BddSize(newfAig),
	      Ddi_BddSize(Ddi_BddarrayRead(orComponent,i)));
      if (useCutVars) {
        auxF = newfAig;
	newfAig=Ddi_BddDup(newfAig1);
      }
      Ddi_BddOrAcc(newfAig,Ddi_BddarrayRead(orComponent,i));
      if (useCutVars && auxvId[i] >= 0) {
	int j = Ddi_VararrayNum(cutFVars)-1;
	Ddi_Bdd_t *auxLit;
	Pdtutil_Assert(j==auxvId[i],"wrong cutf selection");
	auxLit = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(cutFVars,j),1);
	Ddi_BddXnorAcc(auxF,auxLit);
	Ddi_BddarrayRemove(cutFSubst,j);
	Ddi_VararrayRemove(cutFVars,j);

#if 1
	Ddi_BddAndAcc(constraint,newfAig);
	Ddi_Free(newfAig);
	newfAig = Ddi_BddDup(auxF);
#else
	Ddi_BddAndAcc(newfAig,auxF);
	Ddi_Free(auxLit);
#endif
      }
      Ddi_Free(auxF);
    }

    Ddi_BddPartWrite(fPart, i, newfAig);
    Ddi_Free(newfAig);
    Ddi_Free(newfAig1);
  }

  Pdtutil_Assert(Ddi_VararrayNum(cutFVars)==0,"wrong cut var num");

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1, baig = visitedNodes->nodes[i];

    baig1 = bAig_AuxAig1(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
    baig1 = bAig_AuxAig0(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
  }

  bAigArrayFree(visitedNodes);
  bAigArrayFree(impliedNodes);

  size = Ddi_BddSize(f);
  Ddi_BddSetAig(fPart);
  if (!Ddi_BddIsOne(constraint)) {
    Ddi_AigConstrainOptAcc(fPart,constraint,NULL,NULL,NULL,3);
  }
  fprintf(dMgrO(ddm),"Partitioned opt itp size %d -> %d\n", size, Ddi_BddSize(fPart));

  Ddi_DataCopy(f,fPart);

  Ddi_Free(cutFVars);
  Ddi_Free(cutFSubst);
  Ddi_Free(fPart);
  Pdtutil_Free(s);
  Pdtutil_Free(auxvId);
  Ddi_Free(orComponent);
  Ddi_Free(zero);
  Ddi_Free(constraint);

}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByImpl(
  Ddi_Bdd_t *f,
  Ddi_Bddarray_t *implied,
  int optLevel,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *newF;
  bAig_array_t *visitedNodes, *impliedNodes;

  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int size=Ddi_BddSize(f),iMin,i,j,n;
  bAigEdge_t fBaig;

  visitedNodes = bAigArrayAlloc();

  fBaig = Ddi_BddToBaig(f);
  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr, visitedNodes);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig;
    baig = visitedNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxAig0(bmgr, baig) == bAig_NULL,"wrong aig0 field");
    Pdtutil_Assert(bAig_AuxAig1(bmgr, baig) == bAig_NULL,"wrong aig1 field");
    Pdtutil_Assert(bAig_AuxInt(bmgr, baig) == -1,"wrong auxint field");
    bAig_AuxInt(bmgr, baig) = i;
  }

  for (i=0; i<Ddi_BddarrayNum(implied); i++) {
    Ddi_Bdd_t *im_i = Ddi_BddarrayRead(implied,i);
    bAigEdge_t baig_i;
    if (Ddi_BddIsOne(im_i)) {
      continue;
    }
    baig_i = Ddi_BddToBaig(im_i);
    if (bAig_AuxInt(bmgr, baig_i)>=0) {
      bAigEdge_t baigConst = bAig_One;
      if (Ddi_BddIsComplement(im_i)) {
	baigConst = bAig_Zero;
      }
      bAig_Ref(bmgr, baigConst);
      bAig_AuxAig1(bmgr,baig_i) = baigConst;
    }
  }

  /* recompute f */

  for (i=0; i<visitedNodes->num; i++) {
    int inverted;
    bAigEdge_t baig1,baig = visitedNodes->nodes[i];

    baig1 = bAig_NonInvertedEdge(baig);
    if (!bAig_isVarNode(bmgr,baig) &&
             !bAig_NodeIsConstant(baig)) {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                               bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                               bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
    }
    bAig_Ref(bmgr, baig1);
    if (bAig_AuxAig1(bmgr,baig) != bAig_NULL) {
      bAig_AuxAig0(bmgr,baig) = baig1;
    }
    else {
      bAig_AuxAig1(bmgr,baig) = baig1;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
  }

  fBaig = visitedNodes->nodes[visitedNodes->num-1];
  newF = Ddi_BddMakeFromBaig(ddm,fBaig);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1, baig = visitedNodes->nodes[i];

    baig1 = bAig_AuxAig1(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
    baig1 = bAig_AuxAig0(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
  }

  bAigArrayFree(visitedNodes);

  size = Ddi_BddSize(f);

  fprintf(dMgrO(ddm),"Implied opt itp size %d -> %d\n", size, Ddi_BddSize(newF));

  Ddi_DataCopy(f,newF);

  Ddi_Free(newF);

}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByCut(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  int cutNum,
  int optLevel,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int i, n, size, size0, nCut;
  Ddi_Varset_t *supp;
  Ddi_Vararray_t *vA;
  Ddi_Bdd_t *newF;
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  bAigEdge_t fNewBaig, fBaig = Ddi_BddToBaig(f);
  int *lastRef, *cutIndex, *covered, *cutEqIndex, *complEq;
  Ddi_Bddarray_t *cutF = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Bddarray_t *bddCutF = NULL;
  Ddi_Bddarray_t *cutFSubst = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Vararray_t *cutFVars = Ddi_VararrayAlloc(ddm,0);
  int optByBdds=0, nCovered=0, useAigCutVars=1, computeImpl=0;
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bddarray_t *implSubst = NULL;
  int nImpl=0;
  int beforeCut=0, isVar=0, isCut=0;

  size0 = Ddi_BddSize(f);
  if (cutNum>=size0) return 0;
  if ((optLevel<=0)||(size0<40000)) {
    //	  Ddi_AigOptByBdd(f,timeLimit);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,3);
    ddiAbcOptAcc (f,100.0);
    return 0;
  }

  optLevel--;

  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);

  postOrderAigClearVisitedIntern(bmgr,visitedNodes);

  lastRef = Pdtutil_Alloc(int,visitedNodes->num);
  cutIndex = Pdtutil_Alloc(int,visitedNodes->num);
  covered = Pdtutil_Alloc(int,visitedNodes->num);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
    cutIndex[i] = -1;
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      int ir = rightChildAuxInt(bmgr,baig);
      int il = leftChildAuxInt(bmgr,baig);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      lastRef[ir] = lastRef[il] = i;
    }
  }


  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    bAigEdge_t baig = visitedNodes->nodes[i];
    if (i<cutNum) {
      covered[i]=1;
    }
    else {
      covered[i]=0;
      if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
        int ir = rightChildAuxInt(bmgr,baig);
        int il = leftChildAuxInt(bmgr,baig);
        covered[i] = covered[ir] || covered[il];
      }
    }
    if ((!covered[i] || i<cutNum && lastRef[i]>=cutNum)
      && !bAig_isVarNode(bmgr,baig)) {
      /* node before cut referenced outside cut */
      Ddi_Bdd_t *f_i = Ddi_BddMakeFromBaig(ddm,bAig_NonInvertedEdge(baig));
      cutIndex[i] = Ddi_BddarrayNum(cutF);
      Ddi_BddarrayInsertLast(cutF,f_i);
      Ddi_Free(f_i);
    }
    nCovered += covered[i];
  }

  fprintf(dMgrO(ddm),"covered: %d/%d\n", nCovered, size0);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
  }

  nCut=Ddi_BddarrayNum(cutF);

  if (optLevel >= 0 && !optByBdds)

  Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRemPeriod_c,inum,1);

  cutEqIndex = Pdtutil_Alloc(int,nCut);
  complEq = Pdtutil_Alloc(int,nCut);


  Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
  Ddi_MgrSetSiftThresh (ddm, 10000);

  if (optByBdds)
  {
    Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm,0);

    Ddi_Bddarray_t *newCutF = Ddi_AigarrayOptByBdd(cutF,auxF,auxV,50000,0,-1,-1);
    int replace;

    for (i=0; i<Ddi_BddarrayNum(auxF); i++) {
      Ddi_BddSetAig(Ddi_BddarrayRead(auxF,i));
    }
    for (i=0; i<Ddi_BddarrayNum(newCutF); i++) {
      Ddi_BddSetMono(Ddi_BddarrayRead(newCutF,i));
    }
    Ddi_BddSetMono(care);
    for (i=0; i<Ddi_BddarrayNum(newCutF); i++) {
      Ddi_BddRestrictAcc(Ddi_BddarrayRead(newCutF,i),care);
    }

    for (i=0; i<Ddi_BddarrayNum(newCutF); i++) {
      Ddi_BddSetAig(Ddi_BddarrayRead(newCutF,i));
    }

    if (Ddi_BddarrayNum(auxF)>0) {
      Ddi_AigarrayComposeAcc(newCutF,auxV,auxF);
    }


    replace = (size=Ddi_BddarraySize(newCutF)) < Ddi_BddarraySize(cutF);
    if (replace) {
     fprintf(dMgrO(ddm),"OPT by CUT BDD optimization: %d->%d\n",
       Ddi_BddarraySize(cutF), size);
     DdiGenericDataCopy((Ddi_Generic_t *)cutF,(Ddi_Generic_t *)newCutF);
     Ddi_Free(newCutF);
    }
    else {
      bddCutF = newCutF;
    }
    Ddi_Free(auxF);
    Ddi_Free(auxV);
  }


  //  DdiAigArrayRedRemovalAcc (cutF,myOne,-1,200.0);
  {
    int t=0,j,l;

    for(j=0;j<nCut;j++) {
      int equal = 0, localImpl=0;
      Ddi_Bdd_t *f_j = Ddi_BddarrayRead(cutF,j);
      bAigEdge_t b_j = Ddi_BddToBaig(f_j);
      if (bddCutF != NULL) {
        b_j = Ddi_BddToBaig(Ddi_BddarrayRead(bddCutF,j));
      }
      cutEqIndex[j]=-1;
      complEq[j]=0;
      for (l=0; l<j; l++) {
	Ddi_Bdd_t *f_l = Ddi_BddarrayRead(cutF,l);
	bAigEdge_t b_l = Ddi_BddToBaig(f_l);
	if (bddCutF != NULL) {
	  b_l = Ddi_BddToBaig(Ddi_BddarrayRead(bddCutF,l));
	}
	if (b_j == b_l) {
	  equal=2;
	  break;
	}
	else if (b_j == bAig_Not(b_l)) {
	  equal=1;
	  break;
	}
      }
      if (equal) {
	Pdtutil_Assert(complEq[l]==0,"invalid complementation for eq");
	cutEqIndex[j]=cutEqIndex[l];
	complEq[j]=equal%2;
      }
      else {
	char name[10000];
	Ddi_Var_t *aV;
	sprintf(name,"_AUXV_%d_%d", optLevel, Ddi_VararrayNum(cutFVars));
	aV = Ddi_VarFromName(ddm,name);
	if (aV == NULL) {
	  if (useAigCutVars)
  	    aV = Ddi_VarNewBaig(ddm,name);
	  else {
  	    aV = Ddi_VarNew(ddm);
	    Ddi_VarAttachName (aV, name);
	  }
	}
	cutEqIndex[j]=Ddi_VararrayNum(cutFVars);
	Ddi_VararrayInsertLast(cutFVars,aV);
	Ddi_BddarrayInsertLast(cutFSubst,f_j);
	t++;
      }
    }
    implSubst = Ddi_BddarrayMakeLiteralsAig(cutFVars, 1);
    for(j=0;computeImpl&&/*nImpl<100&&*/j<Ddi_VararrayNum(cutFVars);j++) {
      int equal = 0, localImpl=0;
      Ddi_Bdd_t *f_j = Ddi_BddarrayRead(cutFSubst,j);
      Ddi_Bdd_t *f_j2 = Ddi_BddarrayRead(implSubst,j);
      for (l=0; l<j; l++) {
	Ddi_Var_t *v_l = Ddi_VararrayRead(cutFVars,l);
	Ddi_Bdd_t *f_l = Ddi_BddarrayRead(cutFSubst,l);
	if (1 && localImpl<4 && Ddi_BddIncluded(f_j,f_l)){
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v_l,1);
	  Ddi_BddAndAcc(f_j2,lit);
	  Ddi_Free(lit);
	  nImpl++; localImpl++;
	}
	else if (localImpl<4 && Ddi_BddIncluded(f_l,f_j)){
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v_l,1);
	  Ddi_BddOrAcc(f_j2,lit);
	  Ddi_Free(lit);
	  nImpl++; localImpl++;
	}
      }
    }
    fprintf(dMgrO(ddm),"cut of %d/%d nodes\n", t, nCut);

    fprintf(dMgrO(ddm),"# implications: %d\n", nImpl);
  }

  if (0)
  {
    int j;
    Ddi_Bdd_t *rel = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Bdd_t *impl;
    Ddi_Bddarray_t *implArray = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Varset_t *vars = Ddi_VarsetMakeFromArray(cutFVars);

    for(j=0;j<Ddi_VararrayNum(cutFVars);j++) {
      Ddi_Var_t *v = Ddi_VararrayRead(cutFVars,j);
      Ddi_Bdd_t *f_j = Ddi_BddMakeLiteralAig(v,1);
      Ddi_BddXnorAcc(f_j,Ddi_BddarrayRead(cutFSubst,j));
      Ddi_BddAndAcc(rel,f_j);
      Ddi_Free(f_j);
    }
    impl = DdiAigImplicationsAcc(rel,NULL,NULL,vars,implArray);
    Ddi_Free(rel);
    Ddi_Free(impl);
    Ddi_Free(vars);
    Ddi_Free(implArray);

  }


  /* recompute f */


  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1,baig = visitedNodes->nodes[i];

    baig = bAig_NonInvertedEdge(baig);

    bAig_AuxInt(bmgr,baig) = i;

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (i<cutNum && cutIndex[i]<0) {
      beforeCut++;
      baig1 = baig;
    }
    else if (cutIndex[i]>=0) {
      int l = cutEqIndex[cutIndex[i]];
      Ddi_Var_t *v_l = Ddi_VararrayRead(cutFVars,l);
      //      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(cutF,l);
      Pdtutil_Assert(l>=0&&l<nCut,"error in indirect index");
      //      baig1 = Ddi_BddToBaig(f_i);
      baig1 = Ddi_VarToBaig(v_l);
      if (complEq[cutIndex[i]]) baig1 = bAig_Not(baig1);
      isCut++;
    }
    else if (bAig_isVarNode(bmgr,baig)) {
      isVar++;
      baig1 = bAig_NonInvertedEdge(baig);
    }
    else if (!bAig_isVarNode(bmgr,baig)) {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
    }

    bAig_Ref(bmgr, baig1);
    bAig_AuxAig1(bmgr,baig) = baig1;
  }

  fprintf(dMgrO(ddm),"before cut %d, isvar: %d, isCut %d\n", beforeCut, isVar, isCut);

  fNewBaig = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
               bAig_AuxAig1(bmgr,fBaig);
  newF = Ddi_BddMakeFromBaig(ddm,fNewBaig);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1;
    bAigEdge_t baig = visitedNodes->nodes[i];

    baig1 = bAig_AuxAig1(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
    bAig_AuxInt(bmgr,baig) = -1;
  }

  Pdtutil_Free(lastRef);
  Pdtutil_Free(complEq);
  Pdtutil_Free(cutEqIndex);
  Pdtutil_Free(cutIndex);
  Pdtutil_Free(covered);
  Ddi_Free(cutF);
  Ddi_Free(myOne);


  if (nImpl > 0) {
    Ddi_Bdd_t *chk;
    Ddi_BddComposeAcc(newF,cutFVars,implSubst);

    chk = Ddi_BddDup(newF);
    Ddi_BddComposeAcc(chk,cutFVars,cutFSubst);
    Ddi_BddXorAcc(chk,f);
    if (care!=NULL) {
      Ddi_BddAndAcc(chk,care);
    }
    Pdtutil_Assert(1||!Ddi_AigSat(chk),"Wrong impl compose");
    Ddi_Free(chk);
  }
  Ddi_Free(implSubst);

  Ddi_BddSetAig(newF);

  ddiAbcOptAcc (newF,100.0);
  Ddi_AigOptByCut(newF,care,cutNum,optLevel,-1);

  Ddi_BddComposeAcc(newF,cutFVars,cutFSubst);
  Ddi_Free(cutFSubst);
  Ddi_Free(cutFVars);

  if ((size=Ddi_BddSize(newF)) < size0) {
    fprintf(dMgrO(ddm),"OPT by CUT optimization: %d->%d\n", size0, size);
    DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)newF);
  }
  Ddi_Free(newF);
  Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,3);
  ddiAbcOptAcc (f,100.0);


  return 1;
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSplitByCut(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  Ddi_Vararray_t *initVars,
  Ddi_Bddarray_t *cutFSubst,
  Ddi_Vararray_t *cutFVars,
  float cutRatio
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int i, n, size, size0, nCut;
  Ddi_Varset_t *supp;
  Ddi_Vararray_t *vA;
  Ddi_Bdd_t *newF;
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  bAigEdge_t fNewBaig, fBaig = Ddi_BddToBaig(f);
  int *lastRef, *cutIndex, *covered, *cutEqIndex, *complEq;
  Ddi_Bddarray_t *cutF = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Bddarray_t *bddCutF = NULL;
  int optByBdds=0, nCovered=0, useAigCutVars=1;
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bddarray_t *implSubst = NULL;
  int beforeCut=0, isVar=0, isCut=0;
  int cutNum;

  size0 = Ddi_BddSize(f);
  cutNum = cutRatio*size0;

  if (cutNum>=size0) return 0;

  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);

  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  DdiAigArraySortByLevelWithFlowStart(ddm,visitedNodes,initVars);

  lastRef = Pdtutil_Alloc(int,visitedNodes->num);
  cutIndex = Pdtutil_Alloc(int,visitedNodes->num);
  covered = Pdtutil_Alloc(int,visitedNodes->num);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
    cutIndex[i] = -1;
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      int ir = rightChildAuxInt(bmgr,baig);
      int il = leftChildAuxInt(bmgr,baig);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      lastRef[ir] = lastRef[il] = i;
    }
  }


  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    bAigEdge_t baig = visitedNodes->nodes[i];
    if (i<cutNum) {
      covered[i]=1;
    }
    else {
      covered[i]=0;
      if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
        int ir = rightChildAuxInt(bmgr,baig);
        int il = leftChildAuxInt(bmgr,baig);
        covered[i] = covered[ir] || covered[il];
      }
    }
    if ((!covered[i] || i<cutNum && lastRef[i]>=cutNum)
      && !bAig_isVarNode(bmgr,baig)) {
      /* node before cut referenced outside cut */
      Ddi_Bdd_t *f_i = Ddi_BddMakeFromBaig(ddm,bAig_NonInvertedEdge(baig));
      cutIndex[i] = Ddi_BddarrayNum(cutF);
      Ddi_BddarrayInsertLast(cutF,f_i);
      Ddi_Free(f_i);
    }
    nCovered += covered[i];
  }

  fprintf(dMgrO(ddm),"covered: %d/%d\n", nCovered, size0);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
  }

  nCut=Ddi_BddarrayNum(cutF);

  cutEqIndex = Pdtutil_Alloc(int,nCut);
  complEq = Pdtutil_Alloc(int,nCut);

  Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
  Ddi_MgrSetSiftThresh (ddm, 10000);

  {
    int t=0,j,l;

    for(j=0;j<nCut;j++) {
      int equal = 0, localImpl=0;
      Ddi_Bdd_t *f_j = Ddi_BddarrayRead(cutF,j);
      bAigEdge_t b_j = Ddi_BddToBaig(f_j);
      if (bddCutF != NULL) {
        b_j = Ddi_BddToBaig(Ddi_BddarrayRead(bddCutF,j));
      }
      cutEqIndex[j]=-1;
      complEq[j]=0;
      for (l=0; l<j; l++) {
	Ddi_Bdd_t *f_l = Ddi_BddarrayRead(cutF,l);
	bAigEdge_t b_l = Ddi_BddToBaig(f_l);
	if (bddCutF != NULL) {
	  b_l = Ddi_BddToBaig(Ddi_BddarrayRead(bddCutF,l));
	}
	if (b_j == b_l) {
	  equal=2;
	  break;
	}
	else if (b_j == bAig_Not(b_l)) {
	  equal=1;
	  break;
	}
      }
      if (equal) {
	Pdtutil_Assert(complEq[l]==0,"invalid complementation for eq");
	cutEqIndex[j]=cutEqIndex[l];
	complEq[j]=equal%2;
      }
      else {
	char name[10000];
	Ddi_Var_t *aV;
	sprintf(name,"_AUXV_CUT_%d", Ddi_VararrayNum(cutFVars));
	aV = Ddi_VarFromName(ddm,name);
	if (aV == NULL) {
	  if (useAigCutVars)
  	    aV = Ddi_VarNewBaig(ddm,name);
	  else {
  	    aV = Ddi_VarNew(ddm);
	    Ddi_VarAttachName (aV, name);
	  }
	}
	cutEqIndex[j]=Ddi_VararrayNum(cutFVars);
	Ddi_VararrayInsertLast(cutFVars,aV);
	Ddi_BddarrayInsertLast(cutFSubst,f_j);
	t++;
      }
    }
    fprintf(dMgrO(ddm),"cut of %d/%d nodes\n", t, nCut);
  }

  /* recompute f */

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1,baig = visitedNodes->nodes[i];

    baig = bAig_NonInvertedEdge(baig);

    bAig_AuxInt(bmgr,baig) = i;

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (i<cutNum && cutIndex[i]<0) {
      beforeCut++;
      baig1 = baig;
    }
    else if (cutIndex[i]>=0) {
      int l = cutEqIndex[cutIndex[i]];
      Ddi_Var_t *v_l = Ddi_VararrayRead(cutFVars,l);
      //      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(cutF,l);
      Pdtutil_Assert(l>=0&&l<nCut,"error in indirect index");
      //      baig1 = Ddi_BddToBaig(f_i);
      baig1 = Ddi_VarToBaig(v_l);
      if (complEq[cutIndex[i]]) baig1 = bAig_Not(baig1);
      isCut++;
    }
    else if (bAig_isVarNode(bmgr,baig)) {
      isVar++;
      baig1 = bAig_NonInvertedEdge(baig);
    }
    else if (!bAig_isVarNode(bmgr,baig)) {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
    }

    bAig_Ref(bmgr, baig1);
    bAig_AuxAig1(bmgr,baig) = baig1;
  }

  fprintf(dMgrO(ddm),"before cut %d, isvar: %d, isCut %d\n",
          beforeCut, isVar, isCut);

  fNewBaig = bAig_NodeIsInverted(fBaig) ?
    bAig_Not(bAig_AuxAig1(bmgr,fBaig)) :
    bAig_AuxAig1(bmgr,fBaig);
  newF = Ddi_BddMakeFromBaig(ddm,fNewBaig);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig1;
    bAigEdge_t baig = visitedNodes->nodes[i];

    baig1 = bAig_AuxAig1(bmgr,baig);
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,baig1);
    }
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
    bAig_AuxInt(bmgr,baig) = -1;
  }

  Pdtutil_Free(lastRef);
  Pdtutil_Free(complEq);
  Pdtutil_Free(cutEqIndex);
  Pdtutil_Free(cutIndex);
  Pdtutil_Free(covered);
  Ddi_Free(cutF);
  Ddi_Free(myOne);

  Ddi_BddSetAig(newF);

  //  Ddi_BddComposeAcc(newF,cutFVars,cutFSubst);

  return newF;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigExistProjectAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *projectVars,
  Ddi_Bdd_t *care,
  int partial,
  int nosat,
  float timeLimit
)
{
  Ddi_Varset_t *smooth = Ddi_BddSupp(fAig);
  if (Ddi_VarsetIsArray(projectVars)) {
    Ddi_VarsetSetArray(smooth);
  }
  Ddi_VarsetDiffAcc(smooth,projectVars);
  if (partial) {

  }
  Ddi_AigExistAcc (fAig,smooth,care,partial,nosat,timeLimit);
  Ddi_Free(smooth);
  return fAig;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigExistProjectOverAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *projectVars,
  Ddi_Bdd_t *care
)
{
  Ddi_Varset_t *smooth = Ddi_BddSupp(fAig);
  Ddi_VarsetDiffAcc(smooth,projectVars);
  DdiAigExistOverAcc (fAig,smooth,care);
  //  DdiAigExistOverPartialAcc (fAig,smooth,care,Ddi_BddSize(fAig)/2);
  Ddi_Free(smooth);
  return fAig;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigExistProjectItpAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *projectVars,
  Ddi_Bdd_t *care,
  int maxIter
)
{
  Ddi_Varset_t *smooth;
  Ddi_AigExistProjectAcc(fAig, projectVars,
                         NULL, 3, 1, 10);
  smooth = Ddi_BddSupp(fAig);
  Ddi_VarsetDiffAcc(smooth,projectVars);
  DdiAigExistItpAcc (fAig,smooth,care,maxIter);
  Ddi_Free(smooth);
  return fAig;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigExistProjectSkolemAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *projectVars,
  Ddi_Bdd_t *care
)
{
  Ddi_Varset_t *smooth;
  Ddi_AigExistProjectAcc(fAig, projectVars,
                         NULL, 3, 1, 10);
  smooth = Ddi_BddSupp(fAig);
  Ddi_VarsetDiffAcc(smooth,projectVars);
  DdiAigExistSkolemAcc (fAig,smooth,care);
  Ddi_Free(smooth);
  return fAig;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigExistProjectAllSolutionAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *projectVars,
  Ddi_Bdd_t *care,
  int maxIter
)
{
  Ddi_Bdd_t *res;
  Ddi_Varset_t *smooth = Ddi_BddSupp(fAig);
  if (Ddi_VarsetIsArray(projectVars)) {
    Ddi_VarsetSetArray(smooth);
  }
  else if (Ddi_VarsetIsArray(smooth)) {
    Ddi_VarsetSetArray(projectVars);
  }
  Ddi_VarsetDiffAcc(smooth,projectVars);
  res = Ddi_AigExistAllSolutionAcc(fAig,smooth,care,NULL,maxIter);
  Ddi_Free(smooth);
  return(res);
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigExistAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *smooth,
  Ddi_Bdd_t *care,
  int partial,
  int nosat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);

  //  DdiAigTernaryReductionAcc (fAig,smooth,NULL,care);

  //  Ddi_AigExistSubsetAcc (fAig,smooth,care,NULL,-1,timeLimit);

  if (0 && partial == 0) {
    Ddi_Bdd_t *subsetAig = Ddi_BddDup(fAig);
    Ddi_Bdd_t *myCare;
    int rrl = Ddi_MgrReadAigRedRemLevel(ddm);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,0);
    DdiAigExistAccWithPart(subsetAig,smooth,care,NULL,1,nosat,2,-2,timeLimit);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl);
    fprintf(dMgrO(ddm),"Loose monotonicity subset: %d\n", Ddi_BddSize(subsetAig));
    DdiAigExistAccWithPart(subsetAig,smooth,care,NULL,partial,
      nosat,1,0,timeLimit);
    fprintf(dMgrO(ddm),"Loose monotonicity subsetExist: %d\n", Ddi_BddSize(subsetAig));
    myCare = Ddi_BddNot(subsetAig);
    if (care != NULL) {
      Ddi_BddAndAcc(myCare,care);
    }
    DdiAigExistAccWithPart(fAig,smooth,myCare,NULL,partial,
      nosat,1,0,timeLimit);
    Ddi_BddOrAcc(fAig,subsetAig);
    Ddi_Free(myCare);
    Ddi_Free(subsetAig);
    DdiAigRedRemovalAcc (fAig,care,-1,timeLimit);
    fprintf(dMgrO(ddm),"Loose monotonicity final Exist: %d\n", Ddi_BddSize(fAig));
    return fAig;
  }
  return DdiAigExistAccWithPart(fAig,smooth,care,NULL,partial,nosat,1,0,timeLimit);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigComposeExistAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Vararray_t *vars,
  Ddi_Bddarray_t *funcs,
  Ddi_Varset_t *smooth,
  int minGroup,
  Ddi_Bdd_t *care,
  int partial,
  int nosat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm,1);
  Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm,1);
  Ddi_Vararray_t *deferV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bddarray_t *deferF = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Bddarray_t *funcsDup = Ddi_BddarrayDup(funcs);

  int i, n;

  Ddi_Varset_t *suppF = Ddi_BddSupp(fAig);
  Ddi_Varset_t *vSet = Ddi_VarsetMakeFromArray(vars);


  Ddi_VarsetIntersectAcc(suppF,vSet);

  n = Ddi_VararrayNum(vars);

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f_i = Ddi_BddarrayExtract(funcsDup,0);
    Ddi_Var_t *v_i = Ddi_VararrayRead(vars,i);
    if (Ddi_VarInVarset(suppF,v_i)) {
      Ddi_Varset_t *supp_i = Ddi_BddSupp(f_i);
      Ddi_VarsetIntersectAcc(supp_i,smooth);
      if (!Ddi_VarsetIsVoid(supp_i)) {
        Ddi_Varset_t *suppFuncs = Ddi_BddarraySupp(funcsDup);
        Ddi_Varset_t *localSmooth;
        int nv;
        Ddi_VararrayWrite(auxV,0,v_i);
        Ddi_BddarrayWrite(auxF,0,f_i);
        DdiAigComposeAcc (fAig,auxV,auxF);
        localSmooth = Ddi_BddSupp(fAig);
        Ddi_VarsetIntersectAcc(localSmooth,smooth);
        Ddi_VarsetDiffAcc(localSmooth,suppFuncs);
        if ((nv=Ddi_VarsetNum(localSmooth)) >= minGroup) {
          fprintf(dMgrO(ddm),"COMPOSEexist: quantifying %d variables\n", nv);
          Ddi_AigExistAcc (fAig,localSmooth,care,partial,nosat,timeLimit);
        }
        Ddi_Free(suppFuncs);
        Ddi_Free(localSmooth);
      }
      else {
        Ddi_VararrayInsertLast(deferV,v_i);
        Ddi_BddarrayInsertLast(deferF,f_i);
      }
      Ddi_Free(supp_i);
    }
    Ddi_Free(f_i);
  }

  Ddi_AigExistAcc (fAig,smooth,care,partial,nosat,timeLimit);
  if (Ddi_BddarrayNum(deferF) > 0) {
    DdiAigComposeAcc (fAig,deferV,deferF);
  }

  Ddi_Free(vSet);
  Ddi_Free(suppF);
  Ddi_Free(funcsDup);
  Ddi_Free(deferV);
  Ddi_Free(deferF);
  Ddi_Free(auxV);
  Ddi_Free(auxF);
  return fAig;

}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigExistSubsetAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *smooth,
  Ddi_Bdd_t *care,
  Ddi_Bdd_t *pivotCube,
  int subsetLevel,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Bdd_t *ret;
  float lazyRate = Ddi_MgrReadAigLazyRate (ddm);

  if (Ddi_VarsetNum(smooth)==0) {
    return (fAig);
  }

  if (lazyRate <= 1.0) {
    Ddi_MgrSetOption(ddm,Pdt_DdiLazyRate_c,fnum,1.1);
  }

  DdiAigTernaryReductionAcc (fAig,smooth,NULL,care);
#if 0
  {
    Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(smooth,1);
    int j, size0 = Ddi_BddSize(fAig);
    for (j=0;j<Ddi_VararrayNum(vA); j++) {
      Ddi_Varset_t *sm = Ddi_VarsetMakeFromVar(Ddi_VararrayRead(vA,j));
      ret = Ddi_BddNot(fAig);
      DdiAigExistOverAcc (ret,sm,care);
      Ddi_BddNotAcc(ret);
      if (Ddi_BddSize(ret) > size0/10) {
	Ddi_DataCopy(fAig,ret);
      }
      Ddi_Free(ret);
      Ddi_Free(sm);
    }
  }
#endif
  ret = fAig;

  {
    Ddi_Varset_t *supp = Ddi_BddSupp(ret);
    if (Ddi_VarsetIsArray(smooth)) {
        Ddi_VarsetSetArray(supp);
    }
    Ddi_VarsetIntersectAcc(supp,smooth);
    if (!Ddi_VarsetIsVoid(supp)) {
      ret = DdiAigExistAccWithPart(fAig,smooth,care,pivotCube,-3,0,1,
          subsetLevel,timeLimit);
    }
    Ddi_Free(supp);
  }

  Ddi_MgrSetOption(ddm,Pdt_DdiLazyRate_c,fnum,lazyRate);

  {
    Ddi_Varset_t *supp = Ddi_BddSupp(ret);
    if (Ddi_VarsetIsArray(smooth)) {
      Ddi_VarsetSetArray(supp);
    }
    else if (Ddi_VarsetIsArray(supp)) {
      Ddi_VarsetSetArray(smooth);
    }

    Ddi_VarsetIntersectAcc(supp,smooth);
    Pdtutil_Assert(subsetLevel==-1||Ddi_VarsetIsVoid(supp),
      "non smoothed vars in subsetting");
    Ddi_Free(supp);
  }


  return ret;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistAccWithPart (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *smooth,
  Ddi_Bdd_t *care,
  Ddi_Bdd_t *pivotCube,
  int partial,
  int nosat,
  int enPart,
  int enSubset,
  float timeLimit
)
{
  int n, i, nVars, nAigVars;
  Ddi_Bdd_t *newfAig;
  Ddi_Vararray_t *vA;
  Ddi_Varset_t *supp, *project=NULL;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_AigSignatureArray_t *varSigs;
  Ddi_AigSignature_t careSig;
  int initSize, partialDone, totPartialDone=0,
      enableOver=0, refSize, refSizeTot, size_i;
  Ddi_Bdd_t *fPart = Ddi_AigMakePartDisj(fAig);
  int *pivotArray=NULL;
  int tl = ddm->settings.aig.satTimeout;
  long startTime, cpuTime=0;
  int maxIter = ddm->settings.aig.maxAllSolutionIter;

  int constrRandSig = 1;
  int varSortByFlow = 1;

  enPart = 0;

  if (enPart && Ddi_BddPartNum(fPart) > 1) {
    Ddi_Bdd_t *myCare = Ddi_BddDup(care);
    newfAig = Ddi_BddMakeConstAig(ddm,0);
    fprintf(dMgrO(ddm),"PART smoothing: %d part\n", Ddi_BddPartNum(fPart));
    for (i=Ddi_BddPartNum(fPart)-1; i>=0; i--) {
      Ddi_Bdd_t *p = Ddi_BddPartRead(fPart,i);
      fprintf(dMgrO(ddm),"PART %d\n", i);
      //      DdiAigRedRemovalAcc (p,myCare,-1);
      DdiAigExistAccWithPart(p,smooth,myCare,NULL,partial,nosat,0,0,timeLimit);
      Ddi_BddOrAcc(newfAig,p);
      //      Ddi_BddDiffAcc(myCare,p);
    }
    DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);
    Ddi_Free(newfAig);
    Ddi_Free(myCare);
    Ddi_Free(fPart);
    return(fAig);
  }
  else {
    Ddi_Free(fPart);
  }

  //  Disabled by refinement Monotone Exist (ternary reduction
  DdiAigExistEqIncrementalAcc (fAig,smooth,care,timeLimit/5,NULL);

  if (0) /* disabled core manipulation */
  {
    Ddi_Bdd_t *auxCore, *coreAig = Ddi_BddMakeConstAig(ddm,1);
    int size0;
    {
      int rrl = Ddi_MgrReadAigRedRemLevel(ddm);
      Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl+1);
      DdiAigRedRemovalAcc (fAig,care,-1,timeLimit);
      Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl);
    }
    size0 = Ddi_BddSize(fAig);
    DdiAigExistEqIncrementalAcc (fAig,smooth,care,timeLimit,coreAig);
    auxCore = Ddi_BddNot(coreAig);
    if (care != NULL)
      Ddi_BddAndAcc(auxCore,care);

    {
      int rrl = Ddi_MgrReadAigRedRemLevel(ddm);
      Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl+1);
      DdiAigRedRemovalAcc (fAig,auxCore,-1,timeLimit*4);
      Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl);
    }
    fprintf(dMgrO(ddm),"initial size: %d -> core: %d -> newf: %d\n", size0,
	   Ddi_BddSize(coreAig), Ddi_BddSize(fAig));
    DdiAigExistEqIncrementalAcc (fAig,smooth,care,timeLimit,NULL);
    DdiAigExistEqIncrementalAcc (coreAig,smooth,care,timeLimit,NULL);
    Ddi_BddOrAcc(fAig,coreAig);
    fprintf(dMgrO(ddm),"final core+f size: %d\n", Ddi_BddSize(fAig));
    Ddi_Free(coreAig);
    Ddi_Free(auxCore);
  }



  startTime = util_cpu_time();

  supp = Ddi_BddSupp(fAig);
  initSize = Ddi_VarsetNum(supp);
  if (Ddi_VarsetIsArray(smooth)) {
    Ddi_VarsetSetArray(supp);
  }
  else if (Ddi_VarsetIsArray(supp)) {
    Ddi_VarsetSetArray(smooth);
  }
  project = Ddi_VarsetDiff(supp,smooth);
  Ddi_VarsetIntersectAcc(supp,smooth);

  /* the length of the two arrays must be the same */
  n = Ddi_VarsetNum(supp);

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_Free(supp);
  newfAig = Ddi_BddDup(fAig);
  if (ddm->settings.verbosity >= Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"smoothing %d vars. Size = %d\n", n,
	    Ddi_BddSize(newfAig));
  }
  if (varSortByFlow)
    AigVararraySortByFlow(vA,fAig);
  else
    AigVararraySortByFanout(vA,fAig);

  if (partial > 2 && tl <= 0) {
    ddm->settings.aig.satTimeout = 1;
  }

  if (0&&(Ddi_MgrReadAigAbcOptLevel(ddm)>0)) {

  }

  nVars = Ddi_MgrReadNumVars(ddm);
  nAigVars=Ddi_MgrReadNumAigVars(ddm);
  varSigs = DdiAigSignatureArrayAlloc(nVars+nAigVars);

  DdiSetSignaturesRandom(varSigs,nVars+nAigVars);

#if 0
  /* marco */
  if (constrRandSig && care != NULL) {
    Ddi_Bddarray_t *cubes = Ddi_BddarrayAlloc(ddm, 0);
    int np = 8 * sizeof(unsigned long) * DDI_AIG_SIGNATURE_SLOTS;
    Ddi_Varset_t *care_vs = Ddi_BddSupp(care);
    Ddi_Varset_t *fAig_vs = Ddi_BddSupp(fAig);
    Ddi_Varset_t *un_vs = Ddi_VarsetUnion(care_vs, fAig_vs);
    Ddi_Varset_t *alpha_vs = Ddi_VarsetIntersect(un_vs, smooth);
    Ddi_Vararray_t *alpha_va = Ddi_VararrayMakeFromVarset(alpha_vs, 1);
    Ddi_Varset_t *beta_vs = Ddi_VarsetDiff(un_vs, smooth);
    Ddi_Vararray_t *beta_va = Ddi_VararrayMakeFromVarset(beta_vs, 1);
    /* scoring array creation */
    int alpha_va_num = Ddi_VararrayNum(alpha_va);
    Pdtutil_Array_t *betas = Pdtutil_IntegerArrayAlloc(1);

    Ddi_GenConstrRandSimulSignatures(alpha_va,
				     Ddi_VararrayNum(beta_va) ? beta_va : NULL,
				     0,
				     care,
				     0,
				     np,
				     1000   /* 1 s */,
				     cubes,
				     betas);

    int cubes_num = Ddi_BddarrayNum(cubes);

    Pdtutil_Assert(np >= cubes_num, "Wrong num of cubes");
    /* storing cubes */
    for (int i=0; i<cubes_num; i++) {
      Ddi_Bdd_t *cube = Ddi_BddarrayRead(cubes, i);
      Ddi_BddSetMono(cube);
      UpdateVarSignature(varSigs, cube);
    }

    int betas_num = Pdtutil_IntegerArrayNum(betas);
    int ***alpha_va_scores = Pdtutil_Alloc(int **, betas_num);

    /* scoring array init */
    for (int i=0; i<betas_num; i++) {
      alpha_va_scores[i] = Pdtutil_Alloc(int *, alpha_va_num);

      for (int j=0 ; j<alpha_va_num; j++) {
	alpha_va_scores[i][j] = Pdtutil_Alloc(int, 4);
	memset(alpha_va_scores[i][j], 0, 4 * sizeof(int));
      }
    }

    /* evaluation */
    Ddi_EvalConstrRandSimulSignatures(alpha_va,
				      Ddi_VararrayNum(beta_va) ? beta_va : NULL,
				      betas,
				      fAig,
				      varSigs,
				      alpha_va_scores,
				      cubes_num);

    /* scores are available from here on */

    /* freeing stuff */
    int count = 0;
    for (int i=0; i<betas_num; i++) {
      fprintf(dMgrO(ddm),"Current beta index: %d -> %d signatures\n", i, Pdtutil_IntegerArrayRead(betas, i));
      count += Pdtutil_IntegerArrayRead(betas, i);
      for (int j=0; j<alpha_va_num; j++) {
	/* debug */
	printf("Variable %s partial scores: (A + LA -> %d + %d / M + LM -> %d + %d)\n",
	       Ddi_VarName(Ddi_VararrayRead(alpha_va, j)), alpha_va_scores[i][j][0],
	       alpha_va_scores[i][j][2], alpha_va_scores[i][j][1], alpha_va_scores[i][j][3]);
	int m_count = alpha_va_scores[i][j][1] + alpha_va_scores[i][j][2] + alpha_va_scores[i][j][3];
	int a_count = alpha_va_scores[i][j][0] + alpha_va_scores[i][j][2] + alpha_va_scores[i][j][3];
	printf("Variable %s total score: %d/%d [%s]\n", Ddi_VarName(Ddi_VararrayRead(alpha_va, j)),
	       a_count, m_count, m_count > a_count ? "1" : (m_count < a_count ? "0" : "-"));
	/* debug */
	Pdtutil_Free(alpha_va_scores[i][j]);
      }
      Pdtutil_Free(alpha_va_scores[i]);
    }
    Pdtutil_Free(alpha_va_scores);
    fprintf(dMgrO(ddm),"Total number of patterns: %d\n", count);

    Pdtutil_IntegerArrayFree(betas);
    Ddi_Free(cubes);
    Ddi_Free(beta_va);
    Ddi_Free(beta_vs);
    Ddi_Free(alpha_va);
    Ddi_Free(alpha_vs);
    Ddi_Free(un_vs);
    Ddi_Free(fAig_vs);
    Ddi_Free(care_vs);
  }
  /* marco */
#endif

  /* compute care signature */
  if (care==NULL) {
    DdiSetSignatureConstant(&careSig,1);
  }
  else {
    bAig_array_t *careNodes = bAigArrayAlloc();
    bAigEdge_t careBaig = Ddi_BddToBaig(care);
    Ddi_AigSignatureArray_t *auxSig;
    int i,cover = 0;
    unsigned int j;
    postOrderAigVisitIntern(ddm->aig.mgr,careBaig,careNodes,-1);
    postOrderAigClearVisitedIntern(ddm->aig.mgr,careNodes);
    auxSig = DdiAigEvalSignature(ddm,careNodes,bAig_NULL,0,varSigs);
    careSig = auxSig->sArray[careNodes->num-1];
    DdiAigSignatureArrayFree(auxSig);
    bAigArrayFree(careNodes);
    if (bAig_NodeIsInverted(careBaig)) {
      DdiComplementSignature(&careSig);
    }
    for (i=0;i<DDI_AIG_SIGNATURE_SLOTS;i++) {
      unsigned long mask = 1;
      for (j=0;j<sizeof(unsigned long)*8;j++) {
	if (careSig.s[i] & mask) {
  	  cover++;
	}
	mask = mask << 1;
      }
    }
    fprintf(dMgrO(ddm),"random sig in CARE %d/%d (%g)\n",cover,
      sizeof(unsigned long)*8*DDI_AIG_SIGNATURE_SLOTS,
      ((float)cover)/(sizeof(unsigned long)*8*DDI_AIG_SIGNATURE_SLOTS));
  }

  if (nosat < 2) {

    /* disabled ! DOne in   DdiAigExistEqIncrementalAcc */
  for (i=0;0 && i<n;i++) {
    Ddi_Bdd_t *f0Bdd=0;
    Ddi_Bdd_t *f_0, *f_1;
    int j= /* n-1- */ i;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    Ddi_Vararray_t *vSubst = Ddi_VararrayAlloc(ddm,1);
    Ddi_Bddarray_t *constSubst = Ddi_BddarrayAlloc(ddm,1);
    Ddi_VararrayWrite(vSubst,0,v);

    if (ddm->settings.aig.bddCompare) {
      f0Bdd = Ddi_BddMakeMono(newfAig);
      f_0 = Ddi_BddCofactor(f0Bdd,v,0);
      f_1 = Ddi_BddCofactor(f0Bdd,v,1);
      Ddi_Free(f0Bdd);
      f0Bdd=Ddi_BddOr(f_0,f_1);
      Ddi_Free(f_0);
      Ddi_Free(f_1);
    }
    if (DdiAigExistEqVarAcc(newfAig,v,care,varSigs,&careSig) != NULL) {
    if (ddm->settings.aig.bddCompare) {
      Ddi_Bdd_t *aux;
      Ddi_Bdd_t *f1Bdd = Ddi_BddMakeMono(newfAig);
      if (care!=NULL) {
	Ddi_Bdd_t *careBdd =Ddi_BddMakeMono(care);
	Ddi_BddConstrainAcc(f0Bdd,careBdd);
	Ddi_BddConstrainAcc(f1Bdd,careBdd);
      }
      Pdtutil_Assert(Ddi_BddEqual(f0Bdd,f1Bdd),"Wrong AIG exist");
      aux = Ddi_AigMakeFromBdd(f1Bdd);
      if (Ddi_BddSize(aux) < Ddi_BddSize(newfAig)) {
	printf(" BDD:%d->%d ",Ddi_BddSize(newfAig), Ddi_BddSize(aux));
	Ddi_Free(newfAig);
	newfAig = aux;
      }
      else {
	Ddi_Free(aux);
      }

      Ddi_Free(f1Bdd);
      Ddi_Free(f0Bdd);
    }
    }

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"sm %s (%d/%d)-> %d\n", Ddi_VarName(v), i, n, Ddi_BddSize(newfAig));
    }
    Ddi_Free(vSubst);
    Ddi_Free(constSubst);

    if (partial < 3 && timeLimit >= 0 &&
        (util_cpu_time () - startTime)/1000.0 > timeLimit) {
      break;
    }

  }

  }

  if (Ddi_BddSize(newfAig) < 2000)
  {
    int rrl = Ddi_MgrReadAigRedRemLevel(ddm);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl+1);
    DdiAigRedRemovalAcc (newfAig,care,-1,timeLimit/5);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl);
  }


  supp = Ddi_BddSupp(newfAig);
  if (Ddi_VarsetIsArray(smooth)) {
    Ddi_VarsetSetArray(supp);
  }
  else if (Ddi_VarsetIsArray(supp)) {
    Ddi_VarsetSetArray(smooth);
  }
  Ddi_VarsetIntersectAcc(supp,smooth);

  /* the length of the two arrays must be the same */
  n = Ddi_VarsetNum(supp);

  Ddi_Free(vA);
  vA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_Free(supp);
  refSizeTot = refSize = Ddi_BddSize(newfAig);

  if (varSortByFlow)
    AigVararraySortByFlow(vA,newfAig);
  else
    AigVararraySortByFanout(vA,newfAig);

  if (enSubset && pivotCube != NULL) {
    Ddi_Bdd_t *myPivot = Ddi_BddMakeMono(pivotCube);
    pivotArray = Pdtutil_Alloc(int, n);
    for (i=0; i<n; i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
      Ddi_Bdd_t *lit = Ddi_BddMakeLiteral(v,1);
      if (Ddi_BddIncluded(myPivot,lit)) {
	pivotArray[i] = 1;
      }
      else {
	Ddi_BddNotAcc(lit);
        if (Ddi_BddIncluded(myPivot,lit)) {
	  pivotArray[i] = 0;
        }
	else {
	  Pdtutil_Assert(0,"wrong veriable setting in pivotArray");
	}
      }
      Ddi_Free(lit);
    }
    Ddi_Free(myPivot);
  }

  if ((1||!partial) && nosat < 3) {

  for (i=0;i<n;i++) {
    Ddi_Bdd_t *f0Bdd=0, *fSave;
    Ddi_Bdd_t *f_0, *f_1;
    int j= /* n-1- */ i;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    Ddi_Vararray_t *vSubst = Ddi_VararrayAlloc(ddm,1);
    Ddi_Bddarray_t *constSubst = Ddi_BddarrayAlloc(ddm,1);
    Ddi_VararrayWrite(vSubst,0,v);

    partialDone = 0;

#if 0
    /* zero cofactor by 0 constant compose */
    constAig = Ddi_BddMakeConstAig(ddm,0);
    Ddi_BddarrayWrite(constSubst,0,constAig);
    f_0 = Ddi_BddCompose(newfAig,vSubst,constSubst);
    /* zero cofactor by 1 constant compose */
    constAig = Ddi_BddMakeConstAig(ddm,1);
    Ddi_BddarrayWrite(constSubst,0,constAig);
    f_1 = Ddi_BddCompose(newfAig,vSubst,constSubst);

    if (0)
    {
      Ddi_Bdd_t *f1Bdd = Ddi_BddMakeMono(newfAig);
      Ddi_Bdd_t *f_00 = Ddi_BddMakeMono(f_0);
      Ddi_Bdd_t *f_10 = Ddi_BddMakeMono(f_1);
      Ddi_BddCofactorAcc(f0Bdd,v,0);
      Ddi_BddCofactorAcc(f1Bdd,v,1);
      Pdtutil_Assert(Ddi_BddEqual(f0Bdd,f_00),"Wrong AIG exist");
      Pdtutil_Assert(Ddi_BddEqual(f1Bdd,f_10),"Wrong AIG exist");
    }


    Ddi_Free(newfAig);

    newfAig = Ddi_BddOr(f_0,f_1);

    Ddi_Free(constAig);
    Ddi_Free(f_0);
    Ddi_Free(f_1);

#else
    if (ddm->settings.aig.bddCompare) {
      f0Bdd = Ddi_BddMakeMono(newfAig);
      f_0 = Ddi_BddCofactor(f0Bdd,v,0);
      f_1 = Ddi_BddCofactor(f0Bdd,v,1);
      Ddi_Free(f0Bdd);
      f0Bdd=Ddi_BddOr(f_0,f_1);
      Ddi_Free(f_0);
      Ddi_Free(f_1);
    }
    else if (ddm->settings.aig.satCompare) {
      f0Bdd = Ddi_BddDup(newfAig);
      f_0 = Ddi_BddCofactor(f0Bdd,v,0);
      f_1 = Ddi_BddCofactor(f0Bdd,v,1);
      Ddi_Free(f0Bdd);
      f0Bdd=Ddi_BddOr(f_0,f_1);
      Ddi_Free(f_0);
      Ddi_Free(f_1);
    }

    if (!partial || timeLimit < 0 ||
         (util_cpu_time () - startTime)/1000.0 < timeLimit) {

      fSave = Ddi_BddDup(newfAig);

      DdiAigExistVarAcc(newfAig,v,NULL,care,nosat,varSigs,&careSig,partial,
		      (timeLimit-(util_cpu_time()-startTime)/1000.0)/2);
    if (partial) {
      Ddi_Bdd_t *myCare;
      Ddi_Varset_t *mySupp;
      float lazyRate = Ddi_MgrReadAigLazyRate (ddm);
      int enableOpt = partial < 3 ||
	(Ddi_BddSize(newfAig) < (1+2*(lazyRate-1))*refSize);
      if (care == NULL) {
        myCare = Ddi_BddMakeConstAig(ddm,1);
      }
      else {
	myCare = Ddi_BddDup(care);
      }
      if (nosat > 2)  {
        Ddi_AigOptByBddPartial(newfAig,myCare,timeLimit/5);
      }
      mySupp = Ddi_BddSupp(newfAig);
      if ((nosat >= 2) && ( 0.8*initSize > Ddi_VarsetNum(mySupp)))  {
   	Ddi_Free(newfAig);
	newfAig = fSave;
	fSave = NULL;
	partialDone = totPartialDone = 1;
      }
      else {
      size_i = Ddi_BddSize(fSave);
      if (partial == 1 || (enableOpt) &&
          (Ddi_BddSize(newfAig)< (1+5*(lazyRate-1))*refSize)) {
        if (partial < 3 && lazyRate>=1.0) {
          if (Ddi_BddSize(newfAig)> lazyRate * refSize) {
            if (Ddi_BddSize(newfAig)< (1+5*(lazyRate-1))*refSize) {
              Ddi_AigOptByBddPartial(newfAig,myCare,timeLimit/5);
	    }
          }
        }
        if (lazyRate>=1.0 &&
          (Ddi_BddSize(newfAig)>(1+1*(lazyRate-1))* refSize)) {
          DdiAigRedRemovalAcc (newfAig,myCare,-1,timeLimit/5);
        }
        if (Ddi_MgrReadAigAbcOptLevel(ddm)>1 &&
            Ddi_BddSize(newfAig) > refSize) {
          ddiAbcOptAcc (newfAig,timeLimit/10);
        }
      }
      if (Ddi_BddSize(newfAig) < refSize) {
        refSize = Ddi_BddSize(newfAig);
      }
      if (lazyRate>=1.0 &&
          (Ddi_BddSize(newfAig)>(1+1*(lazyRate-1))* refSize)) {
	int j, initSize=-1;
	for (j=i+1; 0 && j<Ddi_VararrayNum(vA); j++) {
	  Ddi_Var_t *v2 = Ddi_VararrayRead(vA,j);
  	  Ddi_Free(newfAig);
	  newfAig = Ddi_BddDup(fSave);

          DdiAigExistVarAcc(newfAig,v,v2,care,nosat,varSigs,&careSig,partial,
		      (timeLimit-(util_cpu_time()-startTime)/1000.0)/2);
	  if (initSize<0) {
	    initSize=Ddi_BddSize(newfAig);
	  }
	  else if (Ddi_BddSize(newfAig)!=initSize) {
	    fprintf(dMgrO(ddm),"SINGLE size found: %d (v:%s-%s)\n", Ddi_BddSize(newfAig),
		   Ddi_VarName(v),Ddi_VarName(v2));
	  }
	}
        Ddi_Free(newfAig);
	newfAig = fSave;
	fSave = NULL;
	partialDone = totPartialDone = 1;
      }
      else {
	Ddi_Free(fSave);
      }
      }
      Ddi_Free(myCare);
      Ddi_Free(mySupp);
    }
    else if (Ddi_BddSize(newfAig)> 1.2 * Ddi_BddSize(fSave)) {
      Ddi_Bdd_t *myCare;
      if (care == NULL) {
        myCare = Ddi_BddMakeConstAig(ddm,1);
      }
      else {
	myCare = Ddi_BddDup(care);
      }
#if 1
      Ddi_AigOptByBddPartial(newfAig,myCare,timeLimit/5);
      DdiAigRedRemovalAcc (newfAig,myCare,1000,timeLimit/5);
#endif
      if (0)
      {
	Ddi_Varset_t *vSet = Ddi_VarsetMakeFromVar(v);
	Ddi_Bdd_t *over;
        Ddi_AigOptByBddPartial(fSave,myCare,timeLimit/5);
	over = Ddi_BddDup(fSave);
        DdiAigExistOverAcc (over,vSet,myCare);
        fprintf(dMgrO(ddm),"approx: %d\n", Ddi_BddSize(over));
        DdiAigRedRemovalAcc (fSave,over,-1,-1.0);
        fprintf(dMgrO(ddm),"f|over: %d\n", Ddi_BddSize(fSave));
        DdiAigExistVarAcc(fSave,v,NULL,
          myCare,nosat,varSigs,&careSig,partial,-1.0);
        DdiAigRedRemovalAcc (fSave,over,-1,-1.0);
	//        Ddi_AigExistAcc (fSave,vSet,myCare,0,0);
	Ddi_BddAndAcc(fSave,over);
	Ddi_Free(over);
	Ddi_Free(vSet);
        if (Ddi_BddSize(newfAig)>Ddi_BddSize(fSave)) {
          fprintf(dMgrO(ddm),"red: %d->%d\n", Ddi_BddSize(newfAig), Ddi_BddSize(fSave));
	  Ddi_Free(newfAig);
	  newfAig = fSave;
	  fSave = NULL;
        }
      }
      Ddi_Free(myCare);
    }
    else if (Ddi_BddSize(newfAig)> Ddi_BddSize(fSave)) {
      Ddi_Bdd_t *myCare;
      if (1&&(Ddi_MgrReadAigAbcOptLevel(ddm)>0)) {
        ddiAbcOptAcc (newfAig,timeLimit/10);
      }
      if (care == NULL) {
        myCare = Ddi_BddMakeConstAig(ddm,1);
      }
      else {
	myCare = Ddi_BddDup(care);
      }
      DdiAigRedRemovalAcc (newfAig,myCare,1000,timeLimit/5);
      Ddi_Free(myCare);
    }
    Ddi_Free(fSave);

    if (ddm->settings.aig.bddCompare) {
      Ddi_Bdd_t *aux;
      Ddi_Bdd_t *f1Bdd = Ddi_BddMakeMono(newfAig);
      if (care!=NULL) {
	Ddi_Bdd_t *careBdd =Ddi_BddMakeMono(care);
	Ddi_BddAndAcc(f0Bdd,careBdd);
	Ddi_BddAndAcc(f1Bdd,careBdd);
      }
      Pdtutil_Assert(Ddi_BddEqual(f0Bdd,f1Bdd),"Wrong AIG exist");
      aux = Ddi_AigMakeFromBdd(f1Bdd);
      if (0&&Ddi_BddSize(aux) < Ddi_BddSize(newfAig)) {
	printf(" BDD:%d->%d ",Ddi_BddSize(newfAig), Ddi_BddSize(aux));
	Ddi_Free(newfAig);
	newfAig = aux;
      }
      else {
	Ddi_Free(aux);
      }

      Ddi_Free(f1Bdd);
      Ddi_Free(f0Bdd);
    }
    else if (ddm->settings.aig.satCompare && !partialDone) {
      Ddi_Bdd_t *diff = Ddi_BddXor(newfAig,f0Bdd);
      if (care!=NULL) {
        Ddi_BddAndAcc(diff,care);
      }
      Pdtutil_Assert(!Ddi_AigSat(diff),"AIG EXIST");
      Ddi_Free(diff);
      Ddi_Free(f0Bdd);
    }
    else if (0 && ddm->settings.aig.satCompare && partialDone) {
      Ddi_Bdd_t *diff = Ddi_BddXor(fAig,f0Bdd);
      if (care!=NULL) {
        Ddi_BddAndAcc(diff,care);
      }
      Pdtutil_Assert(!Ddi_AigSat(diff),"AIG EXIST (partial)");
      Ddi_Free(diff);
      Ddi_Free(f0Bdd);
    }
    Ddi_Free(f0Bdd);


#endif

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"sm %s (%d/%d)-> %d\n", Ddi_VarName(v), i, n, Ddi_BddSize(newfAig));
    }
#if 0
    Ddi_AigOptByBdd(newfAig,-1.0);
#endif
    if (1&&ddm->settings.aig.enMetaOpt) {
      ddm->settings.aig.enMetaOpt = 0;
      Ddi_AigOptByMeta(newfAig,care);
      ddm->settings.aig.enMetaOpt = 1;
    }

    if (partialDone && (enableOver > 0)) {
      Ddi_Bdd_t *over = Ddi_BddDup(newfAig);
      enableOver--;
      fprintf(dMgrO(ddm),"exOver %d -> ", Ddi_BddSize(newfAig));fflush(dMgrO(ddm));
      DdiAigExistVarOverAcc (over,v,care);
      fprintf(dMgrO(ddm),"%d\n", Ddi_BddSize(over));
      DdiAigRedRemovalAcc (newfAig,over,-1,-1.0);
      DdiAigExistVarAcc(newfAig,
	v,NULL,care,nosat,varSigs,&careSig,partial,timeLimit/5);
      Ddi_BddAndAcc(newfAig,over);
    }

    }
    else {
      partialDone = totPartialDone = 1;
    }

    Ddi_Free(vSubst);
    Ddi_Free(constSubst);

    if (partialDone && (enSubset)) {
      if (enSubset > 0) {
        int mySize;
        DdiAigCofactorAcc (newfAig,v,pivotArray[j]);
        fprintf(dMgrO(ddm),"subset -> %d\n", mySize=Ddi_BddSize(newfAig));fflush(dMgrO(ddm));
        if (mySize < (refSizeTot*3)/4) {
	  refSizeTot = mySize;
	  if (timeLimit > 0) {
  	    timeLimit = timeLimit*1.3;
	  }
        }
      }
      else {
	int included;
	Ddi_Bdd_t *cof0 = Ddi_BddDup(newfAig);
	Ddi_Bdd_t *cof1 = Ddi_BddDup(newfAig);
        DdiAigCofactorAcc (cof0,v,0);
        DdiAigCofactorAcc (cof1,v,1);
        included = Ddi_AigCheckFixPoint (cof0,cof1,NULL,project,maxIter);
	if (included == 1 || included < 0 && enSubset < -1) {
	  /* cof1 < cof0: take cof0 */
          DdiGenericDataCopy((Ddi_Generic_t *)newfAig,(Ddi_Generic_t *)cof0);
	  fprintf(dMgrO(ddm),"Lazy monotonicity found%s", included<0?" (subset)":"");
	  fprintf(dMgrO(ddm)," -> %d\n", Ddi_BddSize(newfAig));
	}
	else {
          included = Ddi_AigCheckFixPoint (cof1,cof0,NULL,project,100);
  	  if (included == 1 || included < 0 && enSubset < -1) {
	    /* cof0 < cof1: take cof1 */
            DdiGenericDataCopy((Ddi_Generic_t *)newfAig,(Ddi_Generic_t *)cof1);
  	    fprintf(dMgrO(ddm),"Lazy monotonicity found%s", included<0?" (subset)":"");
  	    fprintf(dMgrO(ddm)," -> %d\n", Ddi_BddSize(newfAig));
	  }
	  else if (enSubset < -1) {
	    /* no monotonicity: take larger cofactor
               (heuristically covering more space) */
	    if (Ddi_BddSize(cof0)>Ddi_BddSize(cof1)) {
	      Ddi_DataCopy(newfAig,cof0);
	    }
	    else {
	      Ddi_DataCopy(newfAig,cof1);
	    }
	  }
	}
	Ddi_Free(cof0);
	Ddi_Free(cof1);
      }
    }

  }
  }

  Ddi_Free(project);

  if (0&&/*!doingMinCut  &&*/ totPartialDone) {

    float cutRatio;

    supp = Ddi_BddSupp(newfAig);
    Ddi_VarsetIntersectAcc(supp,smooth);
    n = Ddi_VarsetNum(supp);

    Ddi_Free(vA);
    vA = Ddi_VararrayMakeFromVarset(supp,1);
    refSizeTot = refSize = Ddi_BddSize(newfAig);
    cutRatio = ((float)800) / refSize;

    for (i=0; i<n; i++) {
      Ddi_Varset_t *currSupp = Ddi_BddSupp(newfAig);
      Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
      if (Ddi_VarInVarset(currSupp,v)) {
        FindMinCut(newfAig,NULL,v,supp,1,50,0,0,cutRatio);
        //      FindMinCut(newfAig,v,supp,-1,4,0,1);
      }
      Ddi_Free(currSupp);
    }
    Ddi_Free(supp);
  }

  if (0)
  {
    Ddi_Bdd_t *fBdd = Ddi_BddMakeMono(fAig);
    Ddi_Bdd_t *newfBdd = Ddi_BddMakeMono(newfAig);
    Ddi_BddExistAcc(fBdd,smooth);
    Pdtutil_Assert(Ddi_BddEqual(fBdd,newfBdd),"Wrong AIG exist");
    Ddi_Free(newfBdd);
    Ddi_Free(fBdd);
  }

#if 0
  Ddi_AigOptByBdd(newfAig,-1.0);
#endif

  //  Ddi_AigOptByInterpolantAcc(fAig,newfAig,care);

  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);

  DdiAigSignatureArrayFree(varSigs);
  Ddi_Free(newfAig);
  Ddi_Free(vA);
  Pdtutil_Free(pivotArray);

  if (0)
    {
      Ddi_Varset_t *s = Ddi_BddSupp(fAig);
      fprintf(dMgrO(ddm),"{%d}", Ddi_VarsetNum(s));
      Ddi_VarsetPrint(s,0,0,dMgrO(ddm));
      Ddi_Free(s);
    }

  if (partial > 2 && tl <= 0) {
    ddm->settings.aig.satTimeout = tl;
  }

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistEqIncrementalAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *smooth,
  Ddi_Bdd_t *care,
  float timeLimit,
  Ddi_Bdd_t *fAigCore
)
{
  int n, i, nVars;
  Ddi_Bdd_t *newfAig, *newfAigDup;
  Ddi_Vararray_t *vA, *vAuxA;
  Ddi_Bddarray_t *vALits;
  Ddi_Varset_t *supp, *recursiveSmooth=NULL;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int initSize, refSize, size_i;
  int tl = ddm->settings.aig.satTimeout;
  long startTime, cpuTime=0;
  Solver    S;
  vec<Lit> lits, observeLits;
  vec<Lit> assumps;
  double time_limit=timeLimit/20;
  Ddi_Bdd_t *cofactorCube;
  int enableSat = 1;
  int mySatCompare = 1;
  int *decisions[2];
  int maxNumVar = 1000;

  int varSortByFlow = 1;

  startTime = util_cpu_time();

  newfAig = Ddi_BddDup(fAig);

  if (0&&(Ddi_MgrReadAigAbcOptLevel(ddm)>0)) {
    ddiAbcOptAcc (newfAig,timeLimit/10);
  }

  supp = Ddi_BddSupp(newfAig);
  initSize = Ddi_VarsetNum(supp);
  if (Ddi_VarsetIsArray(smooth)) {
    Ddi_VarsetSetArray(supp);
  }
  else if (Ddi_VarsetIsArray(supp)) {
    Ddi_VarsetSetArray(smooth);
  }
  Ddi_VarsetIntersectAcc(supp,smooth);

  /* the length of the two arrays must be the same */
  n = Ddi_VarsetNum(supp);

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_Free(supp);
  if (Ddi_VararrayNum(vA) > maxNumVar) {
    Ddi_Vararray_t *newvA = Ddi_VararrayAlloc(ddm,maxNumVar);
    for (i=0; i<maxNumVar; i++) {
      Ddi_VararrayWrite(newvA,i,Ddi_VararrayRead(vA,i));
    }
    recursiveSmooth = Ddi_VarsetMakeArrayVoid(ddm);
    for (; i<Ddi_VararrayNum(vA); i++) {
      Ddi_VarsetAddAcc(recursiveSmooth,Ddi_VararrayRead(vA,i));
    }
    Ddi_Free(vA);
    vA = newvA;
    n = Ddi_VararrayNum(vA);
  }

  if (ddm->settings.verbosity >= Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"smoothing %d vars. Size = %d\n",
	    n, Ddi_BddSize(newfAig));
  }
  if (varSortByFlow)
    AigVararraySortByFlow(vA,newfAig);
  else
    AigVararraySortByFanout(vA,newfAig);

  vAuxA = Ddi_VararrayAlloc(ddm,n);
  vALits = Ddi_BddarrayAlloc(ddm,n);

  nVars = Ddi_MgrReadNumVars(ddm);

  for (i=0;i<n;i++) {
    char name[10000];
    Ddi_Var_t *vAux, *v = Ddi_VararrayRead(vA,i);
    Ddi_Bdd_t *lit;
    sprintf(name,"PDTRAV_AIG_EXIST_DUMMY_VAR_%d",i);
    if ((vAux = Ddi_VarFromName(ddm,name))==NULL) {
      vAux = Ddi_VarNew(ddm);
      Ddi_VarAttachName (vAux, name);
    }
    lit = Ddi_BddMakeLiteralAig(vAux, 1);
    Ddi_VararrayWrite(vAuxA,i,vAux);
    Ddi_BddarrayWrite(vALits,i,lit);
    Ddi_Free(lit);
  }

  newfAigDup = Ddi_BddCompose(newfAig,vA,vALits);
  Ddi_BddNotAcc(newfAigDup);

  aig2CnfIdInit(ddm);

    /* fAig => fAigDup: !(!fAigDup & fAig) */

  MinisatClauses(S,newfAig,care,NULL,0);
  MinisatClauses(S,newfAigDup,NULL,NULL,0);

  assumps.clear();

  decisions[0]=Pdtutil_Alloc(int,n);
  decisions[1]=Pdtutil_Alloc(int,n);

  for (i=n-1; i>=0; i--) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Var_t *vAux = Ddi_VararrayRead(vAuxA,i);

    bAigEdge_t vIndex = Ddi_VarToBaig(v);
    bAigEdge_t vAuxIndex = Ddi_VarToBaig(vAux);

    int vCnf = aig2CnfId(bmgr,vIndex);
    int vAuxCnf = aig2CnfId(bmgr,vAuxIndex);

    /* generate comparison clauses */
    /* new var representing comparison (Xor) */
    int vXor = aig2CnfNewIdIntern(ddm);

    /* v=>(a==b) --> (!v+a+|b)(!v+!b+a) */

    /* -vXor vCnf -vAuxCnf */
    MinisatClause3(S,lits,-vXor,vCnf,-vAuxCnf);
    /* -vXor -vCnf vAuxCnf */
    MinisatClause3(S,lits,-vXor,-vCnf,vAuxCnf);

    assumps.push(MinisatLit(vXor));
    decisions[0][i] = decisions[1][i] = -1;
  }

  cofactorCube = Ddi_BddMakeConstAig(ddm,1);

  if (ddm->settings.verbosity >= Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"\n");
  }
  for (i=0;i<n && enableSat;i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Var_t *vAux = Ddi_VararrayRead(vAuxA,i);
    bAigEdge_t vIndex = Ddi_VarToBaig(v);
    bAigEdge_t vAuxIndex = Ddi_VarToBaig(vAux);
    int vCnf = aig2CnfId(bmgr,vIndex);
    int vAuxCnf = aig2CnfId(bmgr,vAuxIndex);

    int j = assumps.size()-1;
    Lit saveLit = assumps[j];
    int sat;
    int nSatDecisions;

    assumps.pop();

    /* take cofactors: v=1, vAux=0 */
    assumps.push(MinisatLit(vCnf));
    assumps.push(MinisatLit(-vAuxCnf));

    if ((sat = S.okay())) {
      nSatDecisions = S.stats.decisions;
      sat = S.solve(assumps,time_limit);
      decisions[0][i] = S.stats.decisions - nSatDecisions;
      cpuTime = util_cpu_time () - startTime;
      if (timeLimit>=0 && cpuTime/1000.0>timeLimit) {
	enableSat = 0;
      }
      if (S.undefined()) {
        sat = 1;
      }
      if (!sat) {
        /* implication found ! force constant value */
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, 0);
        MinisatClause1(S,lits,-vCnf);
        MinisatClause1(S,lits,-vAuxCnf);
	if (ddm->settings.verbosity >= Pdtutil_VerbLevelDevMax_c) {
	  fprintf(dMgrO(ddm),"-"); fflush(dMgrO(ddm));
	}
	Ddi_BddAndAcc(cofactorCube,lit);
	Ddi_Free(lit);
        decisions[0][i] = decisions[1][i] = -1;
      }
      else {
	/* check reverse cofactors: v=0, vAux=1 */
        assumps[j] = MinisatLit(-vCnf);
        assumps[j+1] = MinisatLit(vAuxCnf);

        nSatDecisions = S.stats.decisions;
        sat = S.solve(assumps,time_limit);
        decisions[1][i] = S.stats.decisions - nSatDecisions;
        cpuTime = util_cpu_time () - startTime;
        if (timeLimit>=0 && cpuTime/1000.0>timeLimit) {
          enableSat = 0;
        }
        if (S.undefined()) {
          sat = 1;
        }
        if (!sat) {
          /* implication found ! force constant value */
          Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, 1);
          MinisatClause1(S,lits,vCnf);
          MinisatClause1(S,lits,vAuxCnf);
	  if (ddm->settings.verbosity >= Pdtutil_VerbLevelDevMax_c) {
	    fprintf(dMgrO(ddm),"-"); fflush(dMgrO(ddm));
	  }
  	  Ddi_BddAndAcc(cofactorCube,lit);
	  Ddi_Free(lit);
          decisions[0][i] = decisions[1][i] = -1;
        }
	else {
	  /* resume old assump as clause */
          lits.clear();
          lits.push(saveLit);
          S.addClause(lits);
	  if (ddm->settings.verbosity >= Pdtutil_VerbLevelDevMax_c) {
	    fprintf(dMgrO(ddm),"="); fflush(dMgrO(ddm));
	  }
	}
      }

    }
    assumps.pop();
    assumps.pop();
  }
  if (ddm->settings.verbosity >= Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"\n");
  }
  aig2CnfIdClose(ddm);

  Ddi_AigConstrainCubeAcc(newfAig,cofactorCube);

  if (fAigCore != NULL) {
    int size1, size0 = Ddi_BddSize(newfAig);
    int iMax, dMax;
    DdiGenericDataCopy((Ddi_Generic_t *)fAigCore,(Ddi_Generic_t *)newfAig);

    do {
      Ddi_Bdd_t *saveAig = Ddi_BddDup(fAigCore);
      Ddi_Var_t *v;
      iMax = -1;
      for (i=0; i<2*n; i++) {
        if (decisions[i%2][i/2] >= 0) {
	  /*
          fprintf(dMgrO(ddm),"%s < decisions: %d %d\n", Ddi_VarName(v),
	     decisions[0][i], decisions[1][i]);
	  */
          if (iMax<0 || decisions[i%2][i/2] > decisions[iMax%2][iMax/2]) {
	    iMax = i;
	  }
	}
      }
      if (iMax < 0) break;
      v = Ddi_VararrayRead(vA,iMax/2);
      DdiAigCofactorAcc (fAigCore,v,(iMax%2));
      decisions[0][iMax/2] = decisions[1][iMax/2] = -1;
      size1 = Ddi_BddSize(fAigCore);
      if (size1*4 < size0) {
	/* Undo: too much size reduction */
        DdiGenericDataCopy((Ddi_Generic_t *)fAigCore,(Ddi_Generic_t *)saveAig);
      }
      else {
        fprintf(dMgrO(ddm),"cofactoring %s=%d -> %d\n", Ddi_VarName(v),(iMax%2), size1);
	//	break;
      }
    } while (size1 > size0*3/4);
  }

  Ddi_Free(cofactorCube);
  Ddi_Free(newfAigDup);
  Ddi_Free(vA);
  Ddi_Free(vAuxA);
  Ddi_Free(vALits);
  Ddi_Free(supp);

  Pdtutil_Free(decisions[0]);
  Pdtutil_Free(decisions[1]);

  refSize = Ddi_BddSize(newfAig);

  if (0&&mySatCompare) {
    /* wrong check. should be with Exist */
    Ddi_Bdd_t *diff = Ddi_BddXor(newfAig,fAig);
    if (care!=NULL) {
      Ddi_BddAndAcc(diff,care);
    }
    Pdtutil_Assert(!Ddi_AigSat(diff),"WRONG INCREMENTAL AIG EXIST");
    Ddi_Free(diff);
  }

#if 0
  Ddi_AigOptByBdd(newfAig,-1.0);
#endif

  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);

  Ddi_Free(newfAig);

  if (recursiveSmooth != NULL) {
    if (timeLimit > 0) {
      cpuTime = util_cpu_time () - startTime;
      timeLimit -= cpuTime/1000.0;
      if (timeLimit < 0) {
	timeLimit = 0.0;
      }
    }
    DdiAigExistEqIncrementalAcc (fAig,recursiveSmooth,care,timeLimit,fAigCore);
    Ddi_Free(recursiveSmooth);
  }

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigExistAllSolutionAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *smooth,
  Ddi_Bdd_t *care,
  Ddi_Bdd_t *window,
  int maxIter
)
{
  int n, i, step;
  Ddi_Bdd_t *newfAig, *dupfAig, *over=NULL, *myCare;
  Ddi_Vararray_t *vA;
  Ddi_Varset_t *supp;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);

#if 0
  Ddi_Bdd_t *refBdd1, *refBdd0 = Ddi_BddMakeMono(fAig);
  Ddi_BddExistAcc(refBdd0,smooth);
  myCare = Ddi_BddMakeConstAig(ddm,1);
#else
  if (care==NULL) {
    myCare = Ddi_BddMakeConstAig(ddm,1);
  }
  else {
    myCare = Ddi_BddDup(care);
  }
#endif

  supp = Ddi_BddSupp(fAig);
  if (Ddi_VarsetIsArray(smooth)) {
    Ddi_VarsetSetArray(supp);
  }
  else if (Ddi_VarsetIsArray(supp)) {
    Ddi_VarsetSetArray(smooth);
  }

  Ddi_VarsetIntersectAcc(supp,smooth);

  /* the length of the two arrays must be the same */
  n = Ddi_VarsetNum(supp);

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Pdtutil_Assert(Ddi_VarReadMark(v) == 0,"0 var mark required");
    Ddi_VarWriteMark(v,1);
  }

  dupfAig = Ddi_BddDup(fAig);
  newfAig = Ddi_BddMakeConstAig(ddm,0);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"ALL SOLUTION Exist %d vars. Size = %d\n",
	    n, Ddi_BddSize(fAig));
  }

  if (0) {
    over = Ddi_BddDup(fAig);
    DdiAigExistOverAcc (over,smooth,care);
    fprintf(dMgrO(ddm),"approx: %d\n", Ddi_BddSize(over));
    DdiAigRedRemovalAcc (fAig,over,-1,-1.0);
  }

  if (0) {
    Ddi_BddNotAcc(fAig);
    DdiAigExistOverAcc (fAig,smooth,care);
    Ddi_BddNotAcc(fAig);
    fprintf(dMgrO(ddm),"approx: %d\n", Ddi_BddSize(fAig));
    return(fAig);
  }

  //  DdiAigRedRemovalAcc (dupfAig,myCare,-1);

  for (step=0; maxIter <= 0 || step<maxIter ; step++) {
    Ddi_Bdd_t *part, *cexAig;
    Ddi_Varset_t *cexSupp;
    Ddi_Bdd_t *fAndCare;
    //    Ddi_AigExistAcc(dupfAig,smooth,myCare,1,0);

    fAndCare = Ddi_BddDup(dupfAig);
    //    Ddi_AigConstrainOptAcc(fAndCare,myCare,NULL,NULL,NULL,1);
    Ddi_BddAndAcc(fAndCare,myCare);
    cexAig = Ddi_AigSatWithCex(fAndCare);
    Ddi_Free(fAndCare);
    if (cexAig == NULL) {
      break;
    }
    if (0&&step>1) {
      Ddi_AigExistAcc(dupfAig,smooth,care,1,1,-1.0);
    }
    if (maxIter>0 && step>=maxIter) {
      Ddi_AigExistAcc(dupfAig,smooth,myCare,0,0,-1.0);
    }

    {
      Ddi_Bdd_t *partCex = Ddi_AigPartitionTop(cexAig,0);
      Ddi_Bdd_t *newCex = Ddi_BddMakeConstAig(ddm,1);
      int i, nn;
      for  (i=nn=0; i<Ddi_BddPartNum(partCex); i++) {
	Ddi_Bdd_t *lit = Ddi_BddPartRead(partCex,i);
	Ddi_Var_t *v_i = Ddi_BddTopVar(lit);
	if (Ddi_VarReadMark(v_i) != 0) {
	  // Ddi_VarInVarset(supp,Ddi_BddTopVar(lit))
	  Ddi_BddAndAcc(newCex,lit);
	  nn++;
	}
      }
      if (nn<n) {
	Ddi_Varset_t *s = Ddi_BddSupp(newCex);
	Ddi_Varset_t *s0 = Ddi_VarsetDiff(supp,s);
	Ddi_Vararray_t *vA0 = Ddi_VararrayMakeFromVarset(s0,1);
	Ddi_Free(s);
	Ddi_Free(s0);
	for (i=0; i<Ddi_VararrayNum(vA0); i++) {
	  Ddi_Var_t *v = Ddi_VararrayRead(vA0,i);
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,0);
	  Ddi_BddAndAcc(newCex,lit);
	  Ddi_Free(lit);
	}
	Ddi_Free(vA0);
      }
      Ddi_Free(partCex);
      Ddi_DataCopy(cexAig,newCex);
      Ddi_Free(newCex);
    }
    //Ddi_BddSetMono(cexAig);
    //    Ddi_BddExistProjectAcc(cexAig,supp);
    //    cexSupp = Ddi_BddSupp(cexAig);
    //Ddi_Free(cexSupp);
    //Ddi_BddSetAig(cexAig);
    part = Ddi_BddDup(dupfAig);
    Ddi_AigConstrainCubeAcc(part,cexAig);

    if (window != NULL) {
      Ddi_BddOrAcc(window,cexAig);
    }

    Ddi_Free(cexAig);

    //    DdiAigRedRemovalAcc (part,myCare,-1);

    Ddi_BddOrAcc(newfAig,part);
    Ddi_BddDiffAcc(myCare,part);

    //    DdiAigRedRemovalAcc (dupfAig,myCare,-1);

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMax_c) {
      fprintf(dMgrO(ddm),
	      "ALL SOLUTION Exist iteration %d: to:%d - leftover: %d(%d)\n",
      step, Ddi_BddSize(newfAig), Ddi_BddSize(dupfAig), Ddi_BddSize(part));
    }
    Ddi_Free(part);
  }

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_VarWriteMark(v,0);
  }

  Ddi_Free(dupfAig);
  Ddi_Free(supp);
  DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig);
  Ddi_Free(newfAig);

#if 0
  refBdd1 = Ddi_BddMakeMono(fAig);
  Pdtutil_Assert(Ddi_BddEqual(refBdd0,refBdd1),"Wrong all sol. exist");
  Ddi_Free(refBdd0);
  Ddi_Free(refBdd1);
#endif

  Ddi_Free(myCare);

  if (over != NULL) {
    Ddi_BddAndAcc(fAig,over);
    Ddi_Free(over);
  }
  Ddi_Free(vA);

  if (maxIter > 0 && step >= maxIter) {
    return (NULL);
  }
  else {
    return(fAig);
  }
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigProjectAllSolutionImgAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *projVars,
  Ddi_Bdd_t *care,
  int maxIter,
  int apprLevel
)
{
  int n, i, j, step, nPVars, bddSize;
  Ddi_Bdd_t *cexAig, *newfAig, *tmpAig, *over=NULL, *myCare;
  Ddi_Vararray_t *vA;
  Ddi_Varset_t *supp;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int *nextStateVars;
  int ret;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int timeLimit=-1;

  Solver    S, S2;
  vec<Lit> blocking;
  vec<Lit> assumps;

  if (Ddi_BddIsConstant(fAig)) {
    return (fAig);
  }

  if (care!=NULL) {
    myCare = Ddi_BddDup(care);
  }
  else {
    myCare = Ddi_BddMakeConstAig(ddm,1);
  }

  supp = Ddi_BddSupp(fAig);
  Ddi_VarsetIntersectAcc(supp,projVars);

  n = Ddi_VarsetNum(supp);

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  nPVars = Ddi_VararrayNum(vA);

  if (0 && n > 10) {
    int nPart = n/4;
    int setRef = 1;
    Ddi_Varset_t *refSupp = Ddi_VarsetVoid(ddm);
    for (j=0; j<4&&j<n; j++) {
      Ddi_VarsetAddAcc(refSupp,Ddi_VararrayRead(vA,j));
    }
    newfAig = Ddi_BddMakeConstAig(ddm,1);
    for (i=1; i<=nPart; i++) {
      Ddi_Varset_t *supp_i = Ddi_VarsetVoid(ddm);
      Ddi_Bdd_t *part_i = Ddi_BddDup(fAig);
      for (j=0; j<4; j++) {
	int l = i*4+j;
	if (l<n) {
	  Ddi_VarsetAddAcc(supp_i,Ddi_VararrayRead(vA,l));
	}
      }
      Ddi_VarsetUnionAcc(supp_i,refSupp);
      Ddi_AigProjectAllSolutionImgAcc (part_i,supp_i,care,maxIter,apprLevel);
      if (setRef) {
	if (Ddi_BddSize(part_i) > 1) {
	  Ddi_VarsetDiffAcc(supp_i,refSupp);
	  Ddi_Free(refSupp);
	  refSupp = Ddi_VarsetDup(supp_i);
	  setRef = 0;
	}
      }
      Ddi_BddAndAcc(newfAig,part_i);
      Ddi_Free(part_i);
      Ddi_Free(supp_i);
    }
    step = i;
    Ddi_Free(refSupp);
  }
  else {

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"ALL SOLUTION IMG/Exist %d vars. Size = %d\n",
	    n, Ddi_BddSize(fAig));
  }
  aig2CnfIdInit(ddm);

  blocking.clear();
  assumps.clear();

  MinisatClauses(S,fAig,myCare,NULL,0);

  nextStateVars = Pdtutil_Alloc(int, nPVars);

  for (i=j=0; i<S.nVars(); i++) {
    int vCnf = i+1;
    bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
    if (!bAig_NodeIsConstant(baig)&&bAig_isVarNode(bmgr,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      if (Ddi_VarInVarset(supp,v)) {
	//	printf("%s\n",Ddi_VarName(v));
      }
    }
  }
  for (j=0; j<nPVars; j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t baig = Ddi_VarToBaig(v);
    int vCnf = aig2CnfId(bmgr,baig);
    nextStateVars[j] = vCnf-1;
  }

  Pdtutil_Assert(j==nPVars,"N state vars does not match");

  if (verbosity >= Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"img SAT: "); fflush(dMgrO(ddm));
  }

  /* a BDD ! */
  newfAig = Ddi_BddMakeConst(ddm,0);
  tmpAig = Ddi_BddMakeConst(ddm,0);

  for (step=0; (1); step++) {

    int sat;
    /* simple check */

    if (verbosity >= Pdtutil_VerbLevelDevMax_c) {
      fprintf(dMgrO(ddm),"."); fflush(dMgrO(ddm));
    }

    if (1&&(maxIter>0)&&(step >= maxIter)) {
      ret = -1;
      break;
    }

    sat = S.okay();
    if (sat) {
      sat = S.solve(assumps,timeLimit);
    }

    if (S.undefined()) {
      ret = -1;
      break;
    }

    if (!sat) {
      /* no new img cube found: exit */
      ret = 0;
      break;
    }
    else {
      vec<Lit> prevCex;

      blocking.clear();

      /* a BDD ! */
      cexAig = Ddi_BddMakeConst(ddm,1);

      prevCex.clear();
      /* decreasing to follow reverse var ord */
      for (i=nPVars-1; i>=0; i--) {
	int k = nextStateVars[i];
        if (S.model[k] != l_Undef) {
          int vCnf = k+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          int w = aig2CnfId(bmgr,baig);
          Lit l = MinisatLit(w);

          Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteral(v, 1);

          if (S.model[k]!=l_True) {
	    w = -w;
   	      Ddi_BddNotAcc(lit);
	    //	    	    fprintf(dMgrO(ddm),"0");
          }
	  else {
	    //	    	    fprintf(dMgrO(ddm),"1");
	  }
          blocking.push(MinisatLit(-w));
	  prevCex.push(MinisatLit(w));

	  Ddi_BddAndAcc(cexAig,lit);
	  Ddi_Free(lit);
        }

      }

      Ddi_BddOrAcc(tmpAig,cexAig);
      if (step%10==0) {
	Ddi_BddOrAcc(newfAig,tmpAig);
	Ddi_Free(tmpAig);
	tmpAig = Ddi_BddMakeConst(ddm,0);
      }
      Ddi_Free(cexAig);
      S.addClause(blocking);

    }
  }

  Ddi_BddOrAcc(newfAig,tmpAig);
  Ddi_Free(tmpAig);

  aig2CnfIdClose(ddm);

  Pdtutil_Free(nextStateVars);

  }

  bddSize = Ddi_BddSize(newfAig);
  Ddi_Free(myCare);

  Ddi_Free(supp);
  Ddi_Free(vA);
  Ddi_BddSetAig(newfAig);
  Ddi_DataCopy(fAig,newfAig);
  Ddi_Free(newfAig);

  fprintf(dMgrO(ddm),"ALL SOLUTION IMG/Exist %d steps. BddSize = %d - AigSize = %d\n",
    step, bddSize, Ddi_BddSize(fAig));


  if (maxIter > 0 && step >= maxIter) {
    return (NULL);
  }
  else {
    return(fAig);
  }
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigProjectRefineOutImgAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *projVars,
  Ddi_Bdd_t *care,
  int maxIter,
  int apprLevel
)
{
  int n, i, j, step, nPVars, bddSize;
  Ddi_Bdd_t *cexAig, *newfAig, *tmpAig, *over=NULL, *myCare;
  Ddi_Vararray_t *vA;
  Ddi_Varset_t *supp;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int *nextStateVars;
  int ret, nOverCubes=0;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int timeLimit=100;
  Lit assumeF;
  int *varauxids = Ddi_MgrReadVarauxids(ddm);
  Ddi_Bdd_t *resOver=NULL;
  Ddi_Bdd_t *oldF=NULL, *fBdd=NULL, *careBdd=NULL;
  int checkRes = 0;
  Solver    S, S2;

  static int nCalls = 0;

  vec<Lit> blocking;
  vec<Lit> assumps;

  nCalls++;

  if (Ddi_BddIsConstant(fAig)) {
    return (fAig);
  }

  if (checkRes) {
    oldF = Ddi_BddDup(fAig);
    //    fBdd = Ddi_BddMakeMono(fAig);
    //    careBdd = Ddi_BddMakeMono(care);
  }


  myCare = Ddi_BddDup(care);

  resOver = Ddi_BddMakeConst(ddm,1);

  supp = Ddi_BddSupp(fAig);
  Ddi_VarsetIntersectAcc(supp,projVars);

  n = Ddi_VarsetNum(supp);

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  nPVars = Ddi_VararrayNum(vA);


  fprintf(dMgrO(ddm),"REFINE OUT IMG/Exist %d vars. Size = %d\n", n, Ddi_BddSize(fAig));

  aig2CnfIdInit(ddm);

  blocking.clear();
  assumps.clear();

  MinisatClauses(S,fAig,myCare,NULL,1);

  {
    bAigEdge_t baig = Ddi_BddToBaig(fAig);
    int fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
      aig2CnfId(ddm->aig.mgr,baig);

    assumeF = MinisatLit(fCnf);

  }

  nextStateVars = Pdtutil_Alloc(int, nPVars);

  for (i=j=0; i<S.nVars(); i++) {
    int vCnf = i+1;
    bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
    if (!bAig_NodeIsConstant(baig)&&bAig_isVarNode(bmgr,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      if (Ddi_VarInVarset(supp,v)) {
	//	printf("%s\n",Ddi_VarName(v));
      }
    }
  }

  Pdtutil_Assert(varauxids!=NULL, "null varauxids array in dd manager");

  for (j=0; j<nPVars; j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t baig = Ddi_VarToBaig(v);
    int index = Ddi_VarIndex(v);
    int vCnf = aig2CnfId(bmgr,baig);
    nextStateVars[j] = vCnf-1;

    Pdtutil_Assert(varauxids[index]>=-1, "wrong varauxid");

    varauxids[index]+=4;
    varauxids[index] = -varauxids[index];
  }

  Pdtutil_Assert(j==nPVars,"N state vars does not match");

  if (verbosity >= Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"img SAT: "); fflush(dMgrO(ddm));
  }

  /* a BDD ! */
  newfAig = Ddi_BddMakeConst(ddm,0);
  tmpAig = Ddi_BddMakeConst(ddm,0);
  assumps.push(assumeF);


  for (step=0; (1); step++) {

    int sat;
    /* simple check */

    if (verbosity >= Pdtutil_VerbLevelDevMax_c) {
      fprintf(dMgrO(ddm),"."); fflush(dMgrO(ddm));
    }

    if (1&&(maxIter>0)&&((step >= maxIter) || (nOverCubes > 2*maxIter))) {
      ret = -1;
      break;
    }

    sat = S.okay();
    if (sat) {
      sat = S.solve(assumps,timeLimit);
    }

    if (S.undefined()) {
      ret = -1;
      break;
    }

    if (!sat) {
      /* no new img cube found: exit */
      ret = 0;
      break;
    }
    else {
      vec<Lit> prevCex;

      blocking.clear();

      /* a BDD ! */
      cexAig = Ddi_BddMakeConst(ddm,1);

      prevCex.clear();
      /* decreasing to follow reverse var ord */
      for (i=nPVars-1; i>=0; i--) {
	int k = nextStateVars[i];
        if (S.model[k] != l_Undef) {
          int vCnf = k+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          int w = aig2CnfId(bmgr,baig);
          Lit l = MinisatLit(w);

          Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteral(v, 1);

          if (S.model[k]!=l_True) {
	    w = -w;
   	      Ddi_BddNotAcc(lit);
	    //	    	    fprintf(dMgrO(ddm),"0");
          }
	  else {
	    //	    	    fprintf(dMgrO(ddm),"1");
	  }
          blocking.push(MinisatLit(-w));
	  prevCex.push(MinisatLit(w));

	  Ddi_BddAndAcc(cexAig,lit);
	  Ddi_Free(lit);
        }

      }

      Ddi_BddOrAcc(tmpAig,cexAig);
      if (step%10==0) {
	Ddi_BddOrAcc(newfAig,tmpAig);
	Ddi_Free(tmpAig);
	tmpAig = Ddi_BddMakeConst(ddm,0);
      }
      S.addClause(blocking);

      if (apprLevel > 0 && nPVars > 1) {
	vec<Lit> tryCex;
	int window=nPVars/20;
	tryCex.clear();
	if (window<=0) window = 1;
	for (i=nPVars-1; i>=window; i-=window) {
	  int j;
	  for (j=0; j<nPVars; j++) {
	    if (j<i-window || j>=i) {
	      tryCex.push(prevCex[j]);
	    }
	  }
	  tryCex.push(~assumeF);
	  sat = S.okay();
	  if (sat) {
	    sat = S.solve(tryCex,timeLimit);
	  }
	  tryCex.pop();

	  if (sat) {
	    /* cex in care */
	    for (j=i-window; j<=i; j++) {
	      int vSat = var(prevCex[j]);
	      if (S.model[vSat]==l_True) {
		tryCex.push(Lit(vSat));
	      }
	      else {
		tryCex.push(~Lit(vSat));
	      }
	    }
	    tryCex.push(assumeF);
	    sat = S.okay();
	    if (sat) {
	      sat = S.solve(tryCex,timeLimit);
	    }

	    if (S.undefined() || !sat) {
	      int k;
	      Ddi_Bdd_t *overAig = Ddi_BddMakeConst(ddm,0);
	      vec<Lit> blockingOver;

	      //	      fprintf(dMgrO(ddm),"UNSAT at distance %d\n", nPVars-i);
	      blockingOver.clear();

	      for (k=0; k<S.conflict.size(); k++) {
		Lit kLit = S.conflict[k];
		int vSat = var(kLit);
		if (vSat != var(assumeF)) {
		  /* conflict has complemented var w.r.t. assump */
		  int signSat = sign(kLit);
		  int vCnf = vSat+1;

		  bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
		  Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
		  int index = Ddi_VarIndex(v);

		  if (varauxids[index]<-1) {
		    /* project variable */
		    /* sign==1 => complemented var, set negative lit ! */
		    Ddi_Bdd_t *lit = Ddi_BddMakeLiteral(v,!signSat);
		    Ddi_BddOrAcc(overAig,lit);
		    Ddi_Free(lit);
		    blockingOver.push(kLit);
		  }
		}
	      }
	      nOverCubes++;
	      if (0 && checkRes) {
		Ddi_Bdd_t *outCube = Ddi_BddNot(overAig);
		Ddi_Bdd_t *inters = Ddi_BddAnd(outCube,fBdd);
		Ddi_BddDiffAcc(inters,tmpAig);
		Ddi_BddDiffAcc(inters,newfAig);
		Pdtutil_Assert(Ddi_BddIncluded(outCube,careBdd),
			       "cube not in care");
		Pdtutil_Assert(Ddi_BddIsZero(inters),"cube in F");
		Ddi_Free(inters);
		Ddi_Free(outCube);
	      }
	      Ddi_BddAndAcc(resOver,overAig);
	      Ddi_Free(overAig);
	      S.addClause(blockingOver);
	    }
	  }
	}
      }
      Ddi_Free(cexAig);
    }
  }

  Ddi_BddOrAcc(newfAig,tmpAig);
  Ddi_Free(tmpAig);

  aig2CnfIdClose(ddm);

  Pdtutil_Free(nextStateVars);

  for (j=0; j<nPVars; j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    int index = Ddi_VarIndex(v);

    Pdtutil_Assert(varauxids[index]<0, "wrong varauxid");

    varauxids[index] = -varauxids[index];
    varauxids[index] -= 4;
  }

  bddSize = Ddi_BddSize(newfAig);
  Ddi_Free(myCare);

  Ddi_Free(supp);
  Ddi_Free(vA);
  Ddi_BddSetAig(newfAig);

  if (1&&(maxIter>0)&&((step >= maxIter) || (nOverCubes > 2*maxIter))) {

    if (Ddi_BddSize(resOver) > 1000) {
      int siftTh = Ddi_MgrReadSiftThresh(ddm);
      Ddi_MgrReduceHeap (ddm,
	Ddi_ReorderingMethodString2Enum((char *)"sift"), 0);
      Ddi_MgrSetSiftThresh (ddm, siftTh);
    }
    Ddi_BddSetAig(resOver);
    Ddi_DataCopy(fAig,resOver);
    Ddi_BddOrAcc(fAig,newfAig);
  }
  else {
    Ddi_DataCopy(fAig,newfAig);
  }
  Ddi_Free(newfAig);
  Ddi_Free(resOver);

  fprintf(dMgrO(ddm),"REFINE OUT IMG %d/%d cubes/steps. BddSize = %d - AigSize = %d\n",
	 nOverCubes, step, bddSize, Ddi_BddSize(fAig));

  if (checkRes) {
    Ddi_BddDiffAcc(oldF,fAig);
    if (care!=NULL)
      Ddi_BddAndAcc(oldF,care);
    Pdtutil_Assert(!Ddi_AigSat(oldF),"wrong overapprimg result");
    Ddi_Free(oldF);
    Ddi_Free(fBdd);
    Ddi_Free(careBdd);
  }

  return(fAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigProjectSatTernaryImgAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Varset_t *projVars,
  Ddi_Varset_t *satVars,
  Ddi_Bdd_t *care,
  int maxIter,
  int apprLevel
)
{
  int n, nSat, i, j, step, nBaseVars, bddSize;
  Ddi_Bdd_t *cexAig, *newfAig, *over=NULL, *myCare;
  Ddi_Vararray_t *vA;
  Ddi_Varset_t *supp, *mySatVars=NULL;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  int *baseVars;
  int ret;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int timeLimit=100;
  Ddi_Varset_t *myTernaryVars = NULL;

  Solver    S, S2;
  vec<Lit> blocking;
  vec<Lit> assumps;

  if (Ddi_BddIsConstant(fAig)) {
    return (fAig);
  }

  myCare = Ddi_BddDup(care);

  supp = Ddi_BddSupp(fAig);
  Ddi_VarsetDiffAcc(supp,projVars);
  n = Ddi_VarsetNum(supp);

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  nBaseVars = Ddi_VararrayNum(vA);

  if (satVars != NULL) {
    mySatVars = Ddi_VarsetDup(satVars);
    if (Ddi_VarsetIsArray(supp)) {
    Ddi_VarsetSetArray(mySatVars);
  }

    Ddi_VarsetIntersectAcc(mySatVars,supp);
  }
  else {
    mySatVars = Ddi_VarsetVoid(ddm);
  }

  nSat = Ddi_VarsetNum(mySatVars);

  if (0&&nSat>20) {
    int i;
    Ddi_Vararray_t *vAsat = Ddi_VararrayMakeFromVarset(mySatVars,1);
    for (i=nSat-1; i>=20; i--) {
      Ddi_Var_t *v = Ddi_VararrayExtract(vAsat,i);
    }
    Ddi_Free(mySatVars);
    mySatVars = Ddi_VarsetMakeFromArray(vAsat);
    Ddi_Free(vAsat);
  }

  myTernaryVars = Ddi_VarsetDiff(supp,mySatVars);

  if (mySatVars!=NULL) {
    if (Ddi_VarsetNum(myTernaryVars) == 0) {
      Ddi_Free(myTernaryVars);
    }
  }

  fprintf(dMgrO(ddm),"SAT+TERNARY IMG/Exist %d vars. Size = %d\n", n, Ddi_BddSize(fAig));

  aig2CnfIdInit(ddm);

  blocking.clear();
  assumps.clear();

  MinisatClauses(S,fAig,myCare,NULL,0);

  baseVars = Pdtutil_Alloc(int, nBaseVars);

  for (j=0; j<nBaseVars; j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t baig = Ddi_VarToBaig(v);
    int vCnf = aig2CnfId(bmgr,baig);
    baseVars[j] = vCnf-1;
  }

  Pdtutil_Assert(j==nBaseVars,"N state vars does not match");

  if (verbosity >= Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"img SAT+TERNARY: "); fflush(dMgrO(ddm));
  }

  /* a BDD ! */
  newfAig = Ddi_BddMakeConstAig(ddm,0);

  for (step=0; (1); step++) {

    int sat;
    /* simple check */

    if (verbosity >= Pdtutil_VerbLevelDevMax_c) {
      fprintf(dMgrO(ddm),"."); fflush(dMgrO(ddm));
    }

    if (1&&(maxIter>0)&&(step >= maxIter)) {
      ret = -1;
      break;
    }

    sat = S.okay();
    if (sat) {
      sat = S.solve(assumps,timeLimit);
    }

    if (S.undefined()) {
      ret = -1;
      break;
    }

    if (!sat) {
      /* no new img cube found: exit */
      ret = 0;
      break;
    }
    else {
      Ddi_Bdd_t *tmpAig;
      vec<Lit> prevCex;

      blocking.clear();

      /* a BDD ! */
      cexAig = Ddi_BddMakeConst(ddm,1);

      prevCex.clear();
      /* decreasing to follow reverse var ord */
      for (i=nBaseVars-1; i>=0; i--) {
	int k = baseVars[i];
        if (S.model[k] != l_Undef) {
          int vCnf = k+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          int w = aig2CnfId(bmgr,baig);
          Lit l = MinisatLit(w);

          Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteral(v, 1);

          if (S.model[k]!=l_True) {
	    w = -w;
   	      Ddi_BddNotAcc(lit);
	    //	    	    fprintf(dMgrO(ddm),"0");
          }
	  else {
	    //	    	    fprintf(dMgrO(ddm),"1");
	  }
          blocking.push(MinisatLit(-w));
	  prevCex.push(MinisatLit(w));

	  Ddi_BddAndAcc(cexAig,lit);
	  Ddi_Free(lit);
        }

      }

      tmpAig = Ddi_BddDup(fAig);

      if (myTernaryVars != NULL) {
	Ddi_Bdd_t *cexAig2 = Ddi_BddDup(cexAig);
	Ddi_BddExistAcc(cexAig2, myTernaryVars);
	Ddi_BddSetAig(cexAig2);
	Ddi_AigConstrainCubeAcc(tmpAig,cexAig2);
	Ddi_Free(cexAig2);
	Ddi_AigExistProjectOverAcc (tmpAig,projVars,NULL);
      }

      Ddi_BddSetAig(cexAig);
      Ddi_AigConstrainCubeAcc(tmpAig,cexAig);

      //      fprintf(dMgrO(ddm),"SAT-TERNARY IMG/Exist %d step. AigSize = %d\n",
      //	     step, Ddi_BddSize(tmpAig));

      Ddi_BddOrAcc(newfAig,tmpAig);

      Ddi_BddNotAcc(tmpAig);
      MinisatClauses(S,tmpAig,NULL,NULL,0);

      Ddi_Free(tmpAig);
      Ddi_Free(cexAig);
      S.addClause(blocking);

    }
  }

  aig2CnfIdClose(ddm);

  Pdtutil_Free(baseVars);

  bddSize = Ddi_BddSize(newfAig);
  Ddi_Free(myCare);

  if (0&&Ddi_BddSize(newfAig) > 1000) {
    int siftTh = Ddi_MgrReadSiftThresh(ddm);
    Ddi_MgrReduceHeap (ddm,
	Ddi_ReorderingMethodString2Enum((char *)"sift"), 0);
    Ddi_MgrSetSiftThresh (ddm, siftTh);
  }

  Ddi_Free(mySatVars);
  Ddi_Free(myTernaryVars);
  Ddi_Free(supp);
  Ddi_Free(vA);
  Ddi_BddSetAig(newfAig);
  Ddi_DataCopy(fAig,newfAig);
  Ddi_Free(newfAig);

  fprintf(dMgrO(ddm),"SAT-TERNARY IMG/Exist %d steps. BddSize = %d - AigSize = %d\n",
    step, bddSize, Ddi_BddSize(fAig));


  if (maxIter > 0 && step >= maxIter) {
    return (NULL);
  }
  else {
    return(fAig);
  }
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigArrayExistPartialAcc (
  Ddi_Bddarray_t *fAigArray,
  Ddi_Varset_t *smooth,
  Ddi_Bdd_t *care
)
{
  int n, i, nVars;
  Ddi_Bddarray_t *newfAigArray;
  Ddi_Vararray_t *vA;
  Ddi_Varset_t *supp;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigArray);
  Ddi_AigSignatureArray_t *varSigs;
  Ddi_AigSignature_t careSig;

  supp = Ddi_BddarraySupp(fAigArray);
  Ddi_VarsetIntersectAcc(supp,smooth);

  /* the length of the two arrays must be the same */
  n = Ddi_VarsetNum(supp);

  vA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_Free(supp);
  newfAigArray = Ddi_BddarrayDup(fAigArray);
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMax_c) {
    fprintf(dMgrO(ddm),"smoothing %d vars. Size = %d\n",
	  n, Ddi_BddarraySize(newfAigArray));
  }
  nVars = Ddi_MgrReadNumVars(ddm);
  varSigs = DdiAigSignatureArrayAlloc(nVars);
  DdiSetSignaturesRandom(varSigs,nVars);
  /* compute care signature */
  if (care==NULL) {
    DdiSetSignatureConstant(&careSig,1);
  }
  else {
    bAig_array_t *careNodes = bAigArrayAlloc();
    bAigEdge_t careBaig = Ddi_BddToBaig(care);
    Ddi_AigSignatureArray_t *auxSig;
    int i,cover = 0;
    unsigned int j;
    postOrderAigVisitIntern(ddm->aig.mgr,careBaig,careNodes,-1);
    postOrderAigClearVisitedIntern(ddm->aig.mgr,careNodes);
    auxSig = DdiAigEvalSignature(ddm,careNodes,bAig_NULL,0,varSigs);
    careSig = auxSig->sArray[careNodes->num-1];
    DdiAigSignatureArrayFree(auxSig);
    bAigArrayFree(careNodes);
    if (bAig_NodeIsInverted(careBaig)) {
      DdiComplementSignature(&careSig);
    }
    for (i=0;i<DDI_AIG_SIGNATURE_SLOTS;i++) {
      unsigned long mask = 1;
      for (j=0;j<sizeof(unsigned long)*8;j++) {
	if (careSig.s[i] & mask) {
  	  cover++;
	}
	mask = mask << 1;
      }
    }
    fprintf(dMgrO(ddm),"random sig in CARE %d/%d (%g)\n",cover,
      sizeof(unsigned long)*8*DDI_AIG_SIGNATURE_SLOTS,
      ((float)cover)/(sizeof(unsigned long)*8*DDI_AIG_SIGNATURE_SLOTS));
  }

  for (i=0;i<n;i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,n-1-i);
    Ddi_Vararray_t *vSubst = Ddi_VararrayAlloc(ddm,1);
    Ddi_Bddarray_t *constSubst = Ddi_BddarrayAlloc(ddm,1);
    Ddi_VararrayWrite(vSubst,0,v);

    DdiAigArrayExistEqVarAcc(newfAigArray,v,care,varSigs,&careSig);

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"sm %s -> %d\n", Ddi_VarName(v), Ddi_BddarraySize(newfAigArray));
    }
    Ddi_Free(vSubst);
    Ddi_Free(constSubst);
  }

  Ddi_Free(vA);

  for (i=0; i<Ddi_BddarrayNum(newfAigArray); i++) {
    Ddi_BddarrayWrite(fAigArray,i,Ddi_BddarrayRead(newfAigArray,i));
  }
  DdiAigSignatureArrayFree(varSigs);
  Ddi_Free(newfAigArray);
  Ddi_Free(vA);

}


/**Function********************************************************************
  Synopsis    [Return true if Aig is constant]
  Description [Return true if Aig is constant. Phase = 1 for one, 0 for
    zero constant.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigIsConst (
  Ddi_Bdd_t *fAig,
  int phase
)
{  if (phase == 0) {
    return(Ddi_BddToBaig(fAig)==bAig_Zero);
  }
  else {
    return(Ddi_BddToBaig(fAig)==bAig_One);
  }
}

/**Function********************************************************************
  Synopsis    [Return true if Aig is constant]
  Description [Return true if Aig is constant. Phase = 1 for one, 0 for
    zero constant.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigIsConstSat (
  Ddi_Bdd_t *fAig,
  int phase
)
{
  if (phase == 0) {
    return(!Ddi_AigSat(fAig));
  }
  else {
    Ddi_Bdd_t *fNeg = Ddi_BddNot(fAig);
    int res = Ddi_AigSat(fAig);
    Ddi_Free(fNeg);
    return(res);
  }
}

/**Function********************************************************************
  Synopsis    [Return true if Aig is constant]
  Description [Return true if Aig is constant. Phase = 1 for one, 0 for
    zero constant.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigIsInverted (
  Ddi_Bdd_t *fAig
)
{
  return aigIsInv(fAig);
}


/* marco */
Ddi_Map_t *
Ddi_MapAlloc (
  size_t init_size
)
{
  Ddi_Map_t *map;

  DdiMapAlloc(map, init_size);
  DdiMapInitArray(map);

  return map;
}

void Ddi_MapSet(
  Ddi_Map_t *map
)
{

}

void
Ddi_MapFree(
  Ddi_Map_t *map
)
{
  Ddi_MapFree(map);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAig2CnfIdInit(
  Ddi_Mgr_t *ddm
)
{
  return aig2CnfIdInit(ddm);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAig2CnfIdClose(
  Ddi_Mgr_t *ddm
)
{
  if (ddm->cnf.cnf2aigOpen)
    return aig2CnfIdClose(ddm);
  else return -1;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAig2CnfIdIsOpen(
  Ddi_Mgr_t *ddm
)
{
  return (ddm->cnf.cnf2aigOpen);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAig2CnfIdCloseNoCheck(
  Ddi_Mgr_t *ddm
)
{
  if (ddm->cnf.cnf2aigOpen) {
    return aig2CnfIdClose(ddm);
  }
  return 0;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAig2CnfId(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex
)
{
  return aig2CnfIdIntern(manager,nodeIndex);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAig2CnfIdSigned(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex
)
{
  return bAig_NodeIsInverted(nodeIndex) ? -aig2CnfIdIntern(manager,nodeIndex) :
    aig2CnfIdIntern(manager,nodeIndex);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAig2CnfNewId(
  Ddi_Mgr_t *ddm
)
{
  return aig2CnfNewIdIntern(ddm);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
unsigned char
DdiCnfReadActive(
  Ddi_Mgr_t *ddm,
  int i
)
{
  return cnfReadActive(ddm,i);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiCnfSetActive(
  Ddi_Mgr_t *ddm,
  int i,
  int val
)
{
  cnfSetActive(ddm,i,val);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiPostOrderAigVisitIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  bAig_array_t *visitedNodes,
  int maxDepth
)
{
  return postOrderAigVisitIntern(manager,nodeIndex,visitedNodes,maxDepth);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiPostOrderAigVisitInternWithCnfActive(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  bAig_array_t *visitedNodes
)
{
  return postOrderAigVisitIntern(manager,nodeIndex,visitedNodes,-1000);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_PostOrderAigVisitIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  bAig_array_t *visitedNodes,
  int maxDepth
)
{
  return postOrderAigVisitIntern(manager,nodeIndex,visitedNodes,maxDepth);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_PostOrderBddAigVisitIntern(
  Ddi_Bdd_t *fAig,
  bAig_array_t *visitedNodes,
  int maxDepth
)
{
  return postOrderBddAigVisitIntern(fAig,visitedNodes,0,maxDepth);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiPostOrderAigClearVisitedIntern(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes
)
{
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_PostOrderAigClearVisitedIntern(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes
)
{
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
}

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**Function*******************************************************************
  Synopsis    [Allocates Ddi_Signature_t data structure]
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Signature_t *
DdiSignatureAlloc (
  Ddi_Vararray_t *vars
)
{
  Ddi_Signature_t *s = Pdtutil_Alloc(Ddi_Signature_t, 1);
  s->vars = Ddi_VararrayDup(vars);
  s->sign = Pdtutil_Alloc(unsigned int, DdiSignaturePatternSize(s));
  memset(s->sign, 0, sizeof(unsigned int) * DdiSignaturePatternSize(s));

  return s;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Vararray_t *
DdiSignatureVars(
  Ddi_Signature_t *s
)
{
  return s->vars;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Signature_t *
DdiSignatureDup(
  Ddi_Signature_t *s
)
{
  Ddi_Signature_t *new_s = DdiSignatureAlloc(s->vars);
  memcpy((void *) new_s->sign,
	 (void *) s->sign,
	 DdiSignaturePatternSize(s) * sizeof(unsigned int));
  return new_s;
}

int DdiSignatureEqual(
  Ddi_Signature_t *s1,
  Ddi_Signature_t *s2
 )
{
  Ddi_Varset_t *v1 = Ddi_VarsetMakeFromArray(s1->vars);
  Ddi_Varset_t *v2 = Ddi_VarsetMakeFromArray(s2->vars);
  int psize = DdiSignaturePatternSize(s1);
  int res = 1;

  if (!Ddi_VarsetEqual(v1, v2)) {
    res = 0;
  } else {
    for (int i=0; i<psize; i++) {
      if (s1->sign[i] != s2->sign[i]) {
	res = 0;
	break;
      }
    }
  }

  Ddi_Free(v1);
  Ddi_Free(v2);

  return res;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiSignatureSize(
  Ddi_Signature_t *s
)
{
  return Ddi_VararrayNum(s->vars);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiSignaturePatternSize(
  Ddi_Signature_t *s
)
{
  int size = DdiSignatureSize(s);

  return ((size % (8 * sizeof(unsigned int))) ?
    ((size / (8 * sizeof(unsigned int))) + 1) : (size / (8 * sizeof(unsigned int))));
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiSignatureRandom(
  Ddi_Signature_t *s,
  Solver *S
)
{
  int size = DdiSignatureSize(s);
  int patternSize = DdiSignaturePatternSize(s);
  int res = 0;

  if (size <= 0) {
    res = 1;
    s->sign[0] = 0;
  } else if (size == 1) { /* the only acceptable value */
    res = s->sign[0] = 1;
  } else { /* result may be zero */
    // patternSize is the integer array size
    /* p_n .... p_0 */
    for (int i=patternSize - 1; i>=0; i--) {
      /* last pattern */
      if (i == 0) {
	int exp = size - 8 * (patternSize - 1) * sizeof(int);

	if (exp <= (8 * sizeof(char))) {
	  s->sign[i] = rand() % ((int) pow(2, exp));
	} else {
	  s->sign[i] = 0;
	  int rem, div;

	  rem = exp % (8 * sizeof(char));
	  div = exp / (8 * sizeof(char));

	  for (int j=0; j<div; j+=sizeof(char)) {
	    s->sign[i] += (rand() % ((int) pow(2, 8 * sizeof(char)))) << (8 * j * sizeof(char));
	  }
	  if (rem) {
	    s->sign[i] += (rand() % ((int) pow(2, rem))) << (8 * div * sizeof(char));
	  }
	}
      } else {
	s->sign[i] = 0;
	for (int j=0; j<sizeof(int); j+=sizeof(char)) {
	  s->sign[i] += (rand() % ((int) pow(2, 8 * sizeof(char)))) << (8 * j * sizeof(char));
	}
      }

      res = (res || s->sign[i] != 0);
    }
  }

  if (S && res) {
    vec<Lit> assumps;
    int psize = DdiSignaturePatternSize(s);
    int vasize = Ddi_VararrayNum(s->vars);
    for (int i = (vasize - 1); i >= 0; i--) {
      int h = (vasize - i - 1) / (8 * sizeof(unsigned int));
      int k = (vasize - i - 1) % (8 * sizeof(unsigned int));

      res = s->sign[psize - h - 1] & (1 << k);
      assumps.push(res ? Lit(i) : ~Lit(i));
    }

    res = S->solve(assumps);
  }

  return res;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiSignatureInitFromCube(
  Ddi_Signature_t *s,
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  DdManager *mgrCU = Ddi_MgrReadMgrCU(ddm);
  DdNode *f_cu = Ddi_BddToCU(f);
  int n = Ddi_MgrReadNumVars(ddm);
  int *cube = Pdtutil_Alloc(int, n);
  unsigned long val[2];
  int i, j, k;
  int psize = DdiSignaturePatternSize(s);

  Cudd_BddToCubeArray(mgrCU, f_cu, cube);

  for (i=0; i<n; i++) {
    j = i / (8 * sizeof(unsigned int));
    k = i % (8 * sizeof(unsigned int));
    switch (cube[i]) {
    case 0:
      s->sign[psize - j - 1] &= ~(1 << k);
      break;
    case 1:
      s->sign[psize - j - 1] |= (1 << k);
      break;
    case 2:
      break;
    default:
      break;
    }
  }

  Pdtutil_Free(cube);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiSignatureFree(
  Ddi_Signature_t *s
)
{
  Ddi_Free(s->vars);
  Pdtutil_Free(s->sign);
  Pdtutil_Free(s);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
unsigned int
DdiSignatureRead(
  Ddi_Signature_t *s,
  int idx
)
{
  Pdtutil_Assert(idx < (DdiSignaturePatternSize(s)), "signature index is not valid");
  return s->sign[idx];
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiSignaturePrint(
  Ddi_Signature_t *s,
  FILE *fp,
  int nCols
)
{
  int patternSize = DdiSignaturePatternSize(s);
  int cols = 0;

  for (int i=0; i<patternSize; i++) {
    fprintf(fp,"[%02d] = %08x ", patternSize - i - 1, s->sign[i]);
    cols++;
    if ((cols % nCols) == 0 && cols > 0) {
      fprintf(fp,"\n");
    }
  }
  fprintf(fp,"\n");
}

/* Signaturearray functions */

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Signature_t *
DdiSignaturearrayRemove (
  Ddi_Signaturearray_t *sa,
  int idx
)
{
  Ddi_Signature_t *s;
  int num = DdiSignaturearrayNum(sa);

  Pdtutil_Assert(idx < num, "signature array index is not valid");
  s = DdiSignaturearrayRead(sa, idx);
  if (idx < (num - 1)) { /* not last element */
    /* compacting array, shifting left <- ... */
    memcpy((void *) sa->signs[idx],
	   (void *) sa->signs[idx+1],
	   (num - idx - 1) * sizeof(Ddi_Signaturearray_t *) );
  }
  sa->signs[num - 1] = NULL;

  return s;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Signaturearray_t *
DdiSignaturearrayAlloc(
  int size
)
{
  Ddi_Signaturearray_t *sa = Pdtutil_Alloc(Ddi_Signaturearray_t, 1);
  sa->signs = Pdtutil_Alloc(Ddi_Signature_t *, size);
  sa->size = size;
  sa->num = 0;
  sa->S = new Solver();

  return sa;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Signature_t *
DdiSignaturearrayRead(
  Ddi_Signaturearray_t *sa,
  int idx
)
{
  Pdtutil_Assert(idx < DdiSignaturearrayNum(sa), "signature array index is not valid");

  return sa->signs[idx];
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void DdiSignaturearrayInsert(
  Ddi_Signaturearray_t *sa,
  int idx,
  Ddi_Signature_t *s)
{
  int num = DdiSignaturearrayNum(sa);
  Ddi_Signature_t **tmp_signs;
  int new_size = DdiSignaturearraySize(sa) ? 2 * DdiSignaturearraySize(sa) : 1;

  Pdtutil_Assert(idx < num, "signature array index is not valid");

  if (num > 0) {
    Ddi_Signature_t *sa0 = DdiSignaturearrayRead(sa, 0);
    Ddi_Varset_t *vs_sa0 = Ddi_VarsetMakeFromArray(sa0->vars);
    Ddi_Varset_t *vs_s = Ddi_VarsetMakeFromArray(s->vars);

    Pdtutil_Assert(Ddi_VarsetEqual(vs_sa0, vs_s), "Cannot insert a new signature with different support");
    Ddi_Free(vs_sa0);
    Ddi_Free(vs_s);
  } else {
    Pdtutil_Assert(sa->S->nVars() == 0, "Initial SAT instance should have 0 variables");

    for (int i=0; i<Ddi_VararrayNum(s->vars); i++) {
      sa->S->newVar();
    }
  }

  if (DdiSignaturearrayNum(sa) == DdiSignaturearraySize(sa)) {
    sa->signs = Pdtutil_Realloc(Ddi_Signature_t *,
		    sa->signs,
		    new_size);
    DdiSignaturearraySize(sa) = new_size;
  }
  /* leaves a hole in idx */
  tmp_signs = Pdtutil_Alloc(Ddi_Signature_t *, num - idx);
  /* shifting array to right -> */
  memcpy((void *) tmp_signs,
	 (void *) sa->signs[idx],
	 (num - idx) * sizeof(Ddi_Signature_t *));
  memcpy((void *) sa->signs[idx+1],
	 (void *) tmp_signs,
	 (num - idx) * sizeof(Ddi_Signature_t *));
  Pdtutil_Free(tmp_signs);
  /* replacing at location idx */
  sa->signs[idx] = DdiSignatureDup(s);

  /* adding to SAT database */
  vec<Lit> clause;
  int psize = DdiSignaturePatternSize(s);
  int vasize = Ddi_VararrayNum(s->vars);
  int res;
  clause.clear();
  for (int i = (vasize - 1); i >= 0; i--) {
    int h = (vasize - i - 1) / (8 * sizeof(unsigned int));
    int k = (vasize - i - 1) % (8 * sizeof(unsigned int));

    res = s->sign[psize - h - 1] & (1 << k);
    clause.push(res ? ~Lit(i) : Lit(i));
  }
  sa->S->addClause(clause);
  Pdtutil_Assert(sa->S->okay(), "SAT database is not consistent");

  DdiSignaturearrayNum(sa)++;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void DdiSignaturearrayInsertLast(
  Ddi_Signaturearray_t *sa,
  Ddi_Signature_t *s
)
{
  int num = DdiSignaturearrayNum(sa);
  int idx;
  int new_size = DdiSignaturearraySize(sa) ? 2 * DdiSignaturearraySize(sa) : 1;

  if (num > 0) {
    Ddi_Signature_t *sa0 = DdiSignaturearrayRead(sa, 0);
    Ddi_Varset_t *vs_sa0 = Ddi_VarsetMakeFromArray(sa0->vars);
    Ddi_Varset_t *vs_s = Ddi_VarsetMakeFromArray(s->vars);

    Pdtutil_Assert(Ddi_VarsetEqual(vs_sa0, vs_s), "Cannot insert a new signature with different support");
    Ddi_Free(vs_sa0);
    Ddi_Free(vs_s);
  } else {
    Pdtutil_Assert(sa->S->nVars() == 0, "Initial SAT instance should have 0 variables");

    for (int i=0; i<Ddi_VararrayNum(s->vars); i++) {
      sa->S->newVar();
    }
  }

  if (DdiSignaturearrayNum(sa) == DdiSignaturearraySize(sa)) {
    sa->signs = Pdtutil_Realloc(Ddi_Signature_t *,
		    sa->signs,
		    new_size);
    DdiSignaturearraySize(sa) = new_size;
    idx = DdiSignaturearrayNum(sa);
  } else {
    idx = DdiSignaturearrayNum(sa);
  }
  sa->signs[idx] = DdiSignatureDup(s);

  /* adding to SAT database */
  vec<Lit> clause;

  int psize = DdiSignaturePatternSize(s);
  int vasize = Ddi_VararrayNum(s->vars);
  int res;

  if (vasize > 0) {
    clause.clear();
    for (int i = (vasize - 1); i >= 0; i--) {
      int h = (vasize - i - 1) / (8 * sizeof(unsigned int));
      int k = (vasize - i - 1) % (8 * sizeof(unsigned int));

      res = s->sign[psize - h - 1] & (1 << k);
      clause.push(res ? ~Lit(i) : Lit(i));
    }
    sa->S->addClause(clause);
  }
  Pdtutil_Assert(sa->S->okay(), "SAT database is not consistent");

  DdiSignaturearrayNum(sa)++;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void DdiSignaturearrayFree(
  Ddi_Signaturearray_t *sa
)
{
  for (int i=0; i<DdiSignaturearrayNum(sa); i++) {
    DdiSignatureFree(sa->signs[i]);
  }
  delete sa->S;
  Pdtutil_Free(sa);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void DdiSignaturearrayPrint(
  Ddi_Signaturearray_t *sa,
  FILE *fp,
  int nCols
)
{
  for (int i=0; i<DdiSignaturearrayNum(sa); i++) {
    DdiSignaturePrint(sa->signs[i], fp, nCols);
  }
}

/**Function*******************************************************************
  Synopsis    [Bdd xor-ing function]
  Description [bddXor should be a BddMakeConstAig() initialized bdd]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiSignatureComposeBddXorAcc(
  Ddi_Bdd_t *bddXor,          /* initialized to BddMakeConstAig() */
  Ddi_Varset_t *care_vs,      /* dont care vars                   */
  Ddi_Signature_t *s          /* input pattern                    */
)
{
  int patternSize = DdiSignaturePatternSize(s);
  Ddi_Vararray_t *support = DdiSignatureVars(s);

  /* p_n .... p_0 -> MSB first */
  for (int i=patternSize - 1; i>=0; i--) {
    unsigned int tmp = DdiSignatureRead(s, i), j = 0;

    while (tmp) {
      unsigned int res = tmp & 0x1;
      int idx = 8 * sizeof(unsigned int) * (patternSize - i - 1) + j;
      Ddi_Var_t *var = Ddi_VararrayRead(support, idx);

      if (res && (!care_vs || !Ddi_VarInVarset(care_vs, var))) {
	Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(var, 1);
	Ddi_BddXorAcc(bddXor, lit);
	Ddi_Free(lit);
      }
      tmp = tmp >> 1;
      j++;
    }
  }
}



/**Function*******************************************************************
  Synopsis    [Bdd xor-ing function]
  Description [bddXor should be a BddMakeConstAig() initialized bdd]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiSignatureComposeBddAndAcc(
  Ddi_Bdd_t *bddAnd,          /* initialized to BddMakeConstAig() */
  Ddi_Signature_t *s          /* input pattern                    */
)
{
  int patternSize = DdiSignaturePatternSize(s);
  Ddi_Vararray_t *support = DdiSignatureVars(s);

  /* p_n .... p_0 -> MSB first */
  for (int i=patternSize - 1; i>=0; i--) {
    unsigned int tmp = DdiSignatureRead(s, i);

    for (int j=0; j < (8 * sizeof(unsigned int)); j++) {
      unsigned int res = tmp & 0x1;
      int idx = 8 * sizeof(unsigned int) * (patternSize - i - 1) + j;

      if (idx < DdiSignatureSize(s)) {
	Ddi_Var_t *var = Ddi_VararrayRead(support, idx);
	Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(var, res ? 1 : 0);
	Ddi_BddAndAcc(bddAnd, lit);
	Ddi_Free(lit);
      }

      tmp = tmp >> 1;
    }
  }
}



/**Function*******************************************************************
  Synopsis    [Evaluates signatures, scoring them]
  Description [Evaluates signatures, scoring them in monotonic/antimonotonic,
               loosely monotonic/antimonotonic]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void Ddi_EvalConstrRandSimulSignatures(
  Ddi_Vararray_t *alpha_va,          /* array of variables to be quantified     */
  Ddi_Vararray_t *beta_va,           /* array of variables not to be quantified */
  Pdtutil_Array_t *betas,
  Ddi_Bdd_t *care,                   /* care set                                */
  Ddi_AigSignatureArray_t *varSigs,  /* input's signature array                 */
  int ***alpha_va_scores,             /* output matrix[un_va_num][4] of integers */
  int rand_gen_num)                  /* effective number of randomly gen patt   */
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(care);
  bAig_array_t *careNodes = bAigArrayAlloc();
  bAigEdge_t careBaig = Ddi_BddToBaig(care);
  int alpha_va_num = Ddi_VararrayNum(alpha_va);
  long startTime = util_cpu_time();
  int betas_num = Pdtutil_IntegerArrayNum(betas);
  int betas_idx = 0;
  int rand_gen_count = 0;
  int curr_beta = 0;

  fprintf(dMgrO(ddm),"*** Evaluation of random signatures begins ***\n");

  /* visiting care nodes */
  postOrderAigVisitIntern(ddm->aig.mgr, careBaig, careNodes, -1);
  postOrderAigClearVisitedIntern(ddm->aig.mgr, careNodes);

  /* for all variables, we flip one variable of the input pattern,
     then we parallel simulate all the patterns */
  for (int i=0; i<alpha_va_num; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(alpha_va, i);
    bAigEdge_t baigV = Ddi_VarBaigId(v);

    Ddi_AigSignatureArray_t *sa0 = DdiAigEvalSignature(ddm, careNodes, baigV, 0, varSigs);
    /* this is the last node signature (x_i = 0 cofactor) */
    Ddi_AigSignature_t s0 = sa0->sArray[careNodes->num-1];
    Ddi_AigSignatureArray_t *sa1 = DdiAigEvalSignature(ddm, careNodes, baigV, 1, varSigs);
    /* this is the last node signature (x_i = 1 cofactor) */
    Ddi_AigSignature_t s1 = sa1->sArray[careNodes->num-1];

    betas_idx = 0; rand_gen_count = 0;
    /* monotonicity scoring here */
    for (int j=0; j<DDI_AIG_SIGNATURE_SLOTS; j++) { // rand_gen_num is the real number of cubes in care
      unsigned long mask = 1;
      for (int h=0; h < sizeof(unsigned long)*8; h++) {
	if (rand_gen_count < rand_gen_num) {
	  if (rand_gen_count == 0 || curr_beta == 0) {
	    curr_beta = Pdtutil_IntegerArrayRead(betas, betas_idx++);
	  }

	  if (betas_idx <= betas_num) {
	    if ((s0.s[j] & mask) && !(s1.s[j] & mask)) { /* (0->1 && 1->0) strictly anti-monotone */
	      alpha_va_scores[betas_idx-1][i][0]++;
	    } else if (!(s0.s[j] & mask) && (s1.s[j] & mask)) { /* (0->0 && 1->1) strictly monotone */
	      alpha_va_scores[betas_idx-1][i][1]++;
	    } else if (!(s0.s[j] & mask) && !(s1.s[j] & mask)) { /* (0->0 && 1->0) loosely anti-monotone */
	      alpha_va_scores[betas_idx-1][i][2]++;
	    } else { /* (0->1 && 1->1) loosely monotone */
	      alpha_va_scores[betas_idx-1][i][3]++;
	    }
	  }
	  curr_beta--;
	}
	mask = mask << 1;
	rand_gen_count++;
      }
    }

    DdiAigSignatureArrayFree(sa0);
    DdiAigSignatureArrayFree(sa1);
  }

  fprintf(dMgrO(ddm),"Total time: %7.3lf s\n",
	   ((double) (util_cpu_time() - startTime)) / 1000);
  fprintf(dMgrO(ddm),"***  Evaluation of random signatures ends  ***\n");

  bAigArrayFree(careNodes);
}

/**Function*******************************************************************
  Synopsis    [Generates constrained random simulation input patterns]
  Description [Generates constrained random simulation input patterns for
               "nodes". Nodes should be bdd_aig initialized]
  SideEffects []
  SeeAlso     []
******************************************************************************/
float
Ddi_GenConstrRandSimulSignatures (
  Ddi_Vararray_t *alpha_va,     /* array of variables to be assigned        */
  Ddi_Vararray_t *beta_va,      /* beta variables to be randomly fixed      */
  int beta_va_var,              /* beta variance                            */
  Ddi_Bdd_t *constr,            /* external constraint                      */
  int minCubesNum,              /* minimum number of cubes                  */
  int maxCubesNum,              /* desired number of cubes                  */
  long timeLimit,               /* overall time limit in ms                 */
  Ddi_Bddarray_t *cubes,        /* output                                   */
  Pdtutil_Array_t *betas        /* number of signatures per beta            */
)
{
  Pdtutil_Assert(alpha_va || beta_va, "Both variable array cannot be NULL");

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(constr);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Varset_t *alpha_vs = Ddi_VarsetMakeFromArray(alpha_va);
  Ddi_Varset_t *beta_vs;
  Ddi_Varset_t *un_vs;
  Ddi_Vararray_t *un_va;
  long startTime = util_cpu_time(), currTime;
  int nSat = 0, nUnsat = 0;
  int signsLimitReached;
  int maxCubesNumReached;
  int minCubesNumReached;
  int timeLimitReached;
  int satTime = 0, unsatTime = 0, tmpStartTime, tmpStopTime;
  int cubesPerSign = 0;
  int beta_var = 0;
  int unsat = 0;
  int alpha_va_num = Ddi_VararrayNum(alpha_va);
  int beta_va_num = 0;
  int un_va_num = 0;
  int beta_first_sat = 1;
  int verbose = 0;
  int endSpace = 0;
  unsigned long totConfl=0, totVars=0, totDec=0, totProp=0;
  float solverSatRatio;
  int nSupp = alpha_va==NULL ? 1 : Ddi_VararrayNum(alpha_va);

  Pdtutil_Assert(minCubesNum <= maxCubesNum, "Sanity check failed, minCubesNum cannot be greater than maxCubesNum");

  Pdtutil_Assert(minCubesNum <= maxCubesNum, "Sanity check failed, minCubesNum cannot be greater than maxCubesNum");

  /* Starts here */
  if (verbose) {
    fprintf(dMgrO(ddm),"*** Generation of random signatures begins ***\n");
  }
  //srand((unsigned int) startTime);

  /* alpha_va is the quantifiable part
     beta_va is the fixed part */
  Ddi_Signaturearray_t *w = DdiSignaturearrayAlloc(0);
  Ddi_Signaturearray_t *b = DdiSignaturearrayAlloc(0);
  Ddi_Signature_t *w_curr;
  Ddi_Signature_t *b_curr;
  if (beta_va) {
    beta_vs = Ddi_VarsetMakeFromArray(beta_va);
    beta_va_num = Ddi_VararrayNum(beta_va);
    un_vs = Ddi_VarsetUnion(alpha_vs, beta_vs);
  } else {
    beta_vs = NULL;
    beta_va_num = 0;
    un_vs = Ddi_VarsetDup(alpha_vs);
  }
  un_va = Ddi_VararrayMakeFromVarset(un_vs, 1);
  un_va_num = alpha_va_num + beta_va_num;

  /* Stats */
  if (verbose) {
    fprintf(dMgrO(ddm),"Alpha support size: %d\n", alpha_va_num);
    fprintf(dMgrO(ddm),"Beta support size: %d\n", beta_va_num);
  }

  unsigned int signs_bits = 0;
  int res;
  /* xor function creation */
  Ddi_Bdd_t *bddXor;
  Ddi_Bdd_t *bddAnd = NULL;

  Solver S;
  int *cnfModelVars = Pdtutil_Alloc(int, un_va_num);
  int cnfModelVarsNum = 0, oldCnfModelVarsNum = 0;

  /* support variables creations */
  w_curr = DdiSignatureAlloc(un_va);
  /* pattern generation loop */
  do {
    res = DdiSignatureRandom(w_curr, NULL);
  } while (!res);
  /* xor composition */
  bddXor = Ddi_BddMakeConstAig(ddm, 1);
  DdiSignatureComposeBddXorAcc(bddXor, Ddi_VararrayNum(alpha_va) > 0 ? beta_vs : NULL, w_curr);
  /* we initialize the queue with rnum here */
  DdiSignaturearrayInsertLast(w, w_curr);
  DdiSignatureFree(w_curr);

  if (!Ddi_AigSatAnd(constr, bddXor, NULL)) {
    Ddi_BddNotAcc(bddXor);
  }

  /* SAT initialization */
  aig2CnfIdInit(ddm);
  MinisatClauses(S, constr, NULL, NULL, 0);
  int cnfXor = MinisatClauses(S, bddXor, NULL, NULL, 1);

  int cnfAnd;
  /* beta generation */
  if (beta_va && Ddi_VararrayNum(alpha_va) > 0) {
    b_curr = DdiSignatureAlloc(beta_va);
    DdiSignatureRandom(b_curr, NULL);
    /* and composition */
    bddAnd = Ddi_BddMakeConstAig(ddm, 1);
    DdiSignatureComposeBddAndAcc(bddAnd, b_curr);
    /* cnf and clause creation */
    cnfAnd = MinisatClauses(S, bddAnd, NULL, NULL, 1);
    DdiSignaturearrayInsertLast(b, b_curr);
    DdiSignatureFree(b_curr);
  }

  totVars = S.nVars();

  /* solver loop */
  do {
    currTime = util_cpu_time();

    /* the solver starts working here */
    double limit;
    int sat;

    limit = ((double) (timeLimit - (currTime - startTime)/1000)) / 10 / (maxCubesNum - Ddi_BddarrayNum(cubes));

    if (beta_va && Ddi_VararrayNum(alpha_va) > 0) {
      limit = limit / DdiSignaturearrayNum(b) / un_va_num;
    }

    if (limit>0.0 || (minCubesNum > 0 &&
                      Ddi_BddarrayNum(cubes) < minCubesNum)) {
      if (((nSat + nUnsat) % 16)==0 && verbose) {
	printf(".");
      }

      /* single assumption */
      vec<Lit> cAssumps;

      /* fresh new vars, in case */
      cAssumps.push(MinisatLit(cnfXor));

      /* beta assumption */
      if (beta_va && Ddi_VararrayNum(alpha_va) > 0) {
	cAssumps.push(MinisatLit(cnfAnd));
      }

      if (limit < 0.1) limit = 0.1;

      /* eventually, sat check */
      tmpStartTime = util_cpu_time();
      sat = S.solve(cAssumps, minCubesNum > 0 ? limit : -1.0) && !S.undefined();
      beta_var++;
      unsat = !sat;
      tmpStopTime = util_cpu_time();

      totDec += S.stats.decisions;
      totConfl += S.stats.conflicts;
      totProp += S.stats.propagations;

      if (nSat == 0) {
	cnfModelVarsNum = 0;
	/* satisfiable model analysis */
	for (int i=0; i<S.nVars(); i++) { // only support vars
	  bAigEdge_t baig = ddm->cnf.cnf2aig[i+1];
	  if (bAig_isVarNode(bmgr,baig)&&!bAig_NodeIsConstant(baig)) {
	    Ddi_Var_t *v_i = Ddi_VarFromBaig(ddm, baig);
	    if (v_i) {
	      cnfModelVars[cnfModelVarsNum++] = i;
	    }
	  }
	}
      }

      /* num of signatures limit bits limit */
      if (((DdiSignaturearrayNum(w) + 1) >> signs_bits) == 2) {
	signs_bits++;
      }
    } else {
      sat = 0;
      tmpStartTime = tmpStopTime = 0;
    }

    nUnsat++;
    if (sat && cubesPerSign <= un_va_num) { /* sat */
      //      Ddi_Bdd_t *cex = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_Bdd_t *cex = Ddi_BddMakePartConjVoid(ddm);
      int cexHasAigVars=0;
      vec<Lit> blockCl;

      /* stats collection */
      nSat++; nUnsat--; cubesPerSign++; satTime += (tmpStopTime - tmpStartTime);

      /* model result retrieval */
      for (int i=0; i<cnfModelVarsNum; i++) {
	int j = cnfModelVars[i];
	bAigEdge_t baig = ddm->cnf.cnf2aig[j+1];
	Ddi_Var_t *v_j = Ddi_VarFromBaig(ddm,baig);
        if (Ddi_VarIsAig(v_j)) cexHasAigVars=1;
	if (S.model[j] == l_False) {
	  Ddi_Bdd_t *zero = Ddi_BddMakeLiteralAig(v_j, 0);
	  Ddi_BddPartInsertLast(cex,zero);
	  //	  Ddi_BddAndAcc(cex, zero);
	  Ddi_Free(zero);
	  blockCl.push(Lit(j));
	} else if (S.model[j] == l_True) {
	  Ddi_Bdd_t *one = Ddi_BddMakeLiteralAig(v_j, 1);
	  Ddi_BddPartInsertLast(cex,one);
	  //	  Ddi_BddAndAcc(cex, one);
	  Ddi_Free(one);
	  blockCl.push(~Lit(j));
	}
      }
      if (!cexHasAigVars) {
        if (Ddi_BddPartNum(cex)==0) {
          Ddi_Free(cex);
          cex = Ddi_BddMakeConstAig(ddm, 1);
        }
        Ddi_BddSetMono(cex);
      }
      S.addClause(blockCl);

      endSpace = !S.solve();

/*       /\* sanity check *\/ */
/*       Ddi_Bdd_t *bddConstrMono = Ddi_BddMakeMono(constr); */
/*       Ddi_Bdd_t *cexMono = Ddi_BddMakeMono(cex); */
/*       Ddi_Bdd_t *bddXorMono = Ddi_BddMakeMono(bddXor); */
/*       Ddi_Bdd_t *bddAndMono; */
/*       if (beta_va && Ddi_VararrayNum(alpha_va) > 0) { */
/*         bddAndMono = Ddi_BddMakeMono(bddAnd); */
/*       } */

/*       Ddi_Bdd_t *notZero = Ddi_BddAnd(bddXorMono, bddConstrMono); */
/*       if (beta_va && Ddi_VararrayNum(alpha_va) > 0) { */
/* 	Ddi_BddAndAcc(notZero, bddAndMono); */
/*       } */
/*       Ddi_BddAndAcc(notZero, cexMono); */
/*       Pdtutil_Assert(!Ddi_BddIsZero(notZero), "Sanity check failed, cube is not valid with the current constraint"); */
/*       if (beta_va && Ddi_VararrayNum(alpha_va) > 0) { */
/* 	Ddi_Free(bddAndMono); */
/*       } */
/*       Ddi_Free(notZero); */
/*       Ddi_Free(bddXorMono); */
/*       Ddi_Free(cexMono); */
/*       Ddi_Free(bddConstrMono); */
/*       /\* sanity check *\/ */

      /* saving cube */
      Ddi_BddarrayInsertLast(cubes, cex);
      Ddi_Free(cex);

      /* signatures per beta count */
      if (beta_va && beta_first_sat) { // we add a new signatures per beta counter
	beta_first_sat = 0;
	Pdtutil_IntegerArrayInsertLast(betas, 1);
      } else if (beta_va && !beta_first_sat) { // we update the current signatures per beta counter
	int curr_betas_num = Pdtutil_IntegerArrayNum(betas);
	int curr_beta = Pdtutil_IntegerArrayRead(betas, curr_betas_num - 1);
	Pdtutil_IntegerArrayWrite(betas, curr_betas_num - 1, ++curr_beta);
      }
    } else if (signs_bits < un_va_num) { /* time out or unsat, next pattern selected */
      cubesPerSign = 0; unsatTime += (tmpStopTime - tmpStartTime);

      /* pattern generation loop */
      w_curr = DdiSignatureAlloc(un_va);
      do {
	res = DdiSignatureRandom(w_curr, w->S);
      } while (res == 0);
      /* xor regeneration */
      Ddi_Free(bddXor);
      bddXor = Ddi_BddMakeConstAig(ddm, 1);
      DdiSignatureComposeBddXorAcc(bddXor, Ddi_VararrayNum(alpha_va) > 0 ? beta_vs : NULL, w_curr);
      Ddi_BddSetAig(bddXor);

      /* cnf xor clause creation */
      cnfXor = MinisatClauses(S, bddXor, NULL, NULL, 1);

      DdiSignaturearrayInsertLast(w, w_curr);
      DdiSignatureFree(w_curr);
    } else {
      unsatTime += (tmpStopTime - tmpStartTime);
    }

    if (beta_va && Ddi_VararrayNum(alpha_va) > 0) {
      /* beta updating policy */
      if (((beta_va_var > 0 && beta_var >= beta_va_var) ||
	  (beta_va_var <= 0 && beta_var >=/*(8 * sizeof(unsigned long) *
					    DDI_AIG_SIGNATURE_SLOTS / beta_va_num)*/ 64)) ||
	  unsat) {
	beta_var = 0;
	beta_first_sat = 1;
	b_curr = DdiSignatureAlloc(beta_va);
	DdiSignatureRandom(b_curr, NULL);
	Ddi_Free(bddAnd);
	bddAnd = Ddi_BddMakeConstAig(ddm, 1);
	DdiSignatureComposeBddAndAcc(bddAnd, b_curr);
	/* cnf and clause creation */
	cnfAnd = MinisatClauses(S, bddAnd, NULL, NULL, 1);
	DdiSignaturearrayInsertLast(b, b_curr);
	DdiSignatureFree(b_curr);
      }
    }

    if (unsat) {
      cnfModelVarsNum = 0;
      /* satisfiable model analysis */
      for (int i=0; i<S.nVars(); i++) { // only support vars
	bAigEdge_t baig = ddm->cnf.cnf2aig[i+1];
	if (bAig_isVarNode(bmgr,baig)&&!bAig_NodeIsConstant(baig)) {
	  Ddi_Var_t *v_i = Ddi_VarFromBaig(ddm,baig);
	  if (v_i) {
	    cnfModelVars[cnfModelVarsNum++] = i;
	  }
	}
      }
    }

    /* checks */
    signsLimitReached =  (signs_bits >= un_va_num) && !sat;
    minCubesNumReached = (Ddi_BddarrayNum(cubes) >= minCubesNum);
    maxCubesNumReached = (Ddi_BddarrayNum(cubes) >= maxCubesNum);
    timeLimitReached = ((currTime - startTime) >= timeLimit);
    /* checks */
  } while (!endSpace &&
           ((!signsLimitReached && !maxCubesNumReached && !timeLimitReached) ||
            (!signsLimitReached && !maxCubesNumReached && minCubesNum > 0 &&
             !minCubesNumReached)));

  if (verbose) {
  fprintf(dMgrO(ddm),"\n");
  fprintf(dMgrO(ddm),"Exit conditions state: signsLimitReached %d, minCubesNumReached: %d, maxCubesNumReached: %d, timeLimitReached: %d\n",
		 signsLimitReached, minCubesNumReached, maxCubesNumReached, timeLimitReached);

  /* debug */
  fprintf(dMgrO(ddm),"Number of uniformly generated signatures/seeds/betas: %d/%d/%d\n",
	 Ddi_BddarrayNum(cubes), DdiSignaturearrayNum(w), DdiSignaturearrayNum(b));
  fprintf(dMgrO(ddm),"Number of SAT solver variables/clauses (w array): %d/%d:\n",
	 w->S->nVars(), w->S->nClauses());
  fprintf(dMgrO(ddm),"Number of SAT solver variables/clauses (b array): %d/%d:\n",
	 b->S->nVars(), b->S->nClauses());
  fprintf(dMgrO(ddm),"Number of accepted betas: %lu\n", Pdtutil_IntegerArrayNum(betas));
  fprintf(dMgrO(ddm),"Number of sat/unsat calls: %d (%7.3lf s)/%d (%7.3lf s)\n",
	 nSat, ((double) satTime) / 1000, nUnsat, ((double) unsatTime) / 1000);
  fprintf(dMgrO(ddm),"Total time: %7.3lf s\n",
	 ((double) (util_cpu_time() - startTime)) / 1000);
  /* debug */

  fprintf(dMgrO(ddm),"***  Generation of random signatures ends  ***\n");
  }

  /* solver stuff */
  aig2CnfIdClose(ddm);
  Pdtutil_Free(cnfModelVars);

  /* signature stuff */
  DdiSignaturearrayFree(w);
  DdiSignaturearrayFree(b);

  /* bdd stuff */
  Ddi_Free(bddXor);
  Ddi_Free(un_vs);
  Ddi_Free(un_va);
  if (beta_va) {
    Ddi_Free(bddAnd);
    Ddi_Free(beta_vs);
  }
  Ddi_Free(alpha_vs);

  solverSatRatio = (((float) totConfl) / (totDec+totProp))*totVars;
  while (solverSatRatio >= 1) {
    solverSatRatio /=2;
  }
  //  solverSatRatio = (((float) totConfl) / (totDec+nSupp))*nSupp;
  //  solverSatRatio = (((float) totConfl) / (totDec+totProp))*nSupp;

  Pdtutil_Assert(solverSatRatio<=1,"wrong solver sat ratio");

  solverSatRatio = 1 - solverSatRatio;

  if (nUnsat==0) return solverSatRatio;
  else return (solverSatRatio*((float) nSat)/(nSat+nUnsat));

}
/* marco */

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayComposeAcc (
  Ddi_Bddarray_t *fArrayAig,
  Ddi_Vararray_t *vA,
  Ddi_Bddarray_t *gA
)
{
  Ddi_Bddarray_t *newf = Ddi_AigarrayCompose (fArrayAig,vA,gA);
  DdiGenericDataCopy((Ddi_Generic_t *)fArrayAig,(Ddi_Generic_t *)newf);
  Ddi_Free(newf);
  return(fArrayAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayCompose (
  Ddi_Bddarray_t *fArrayAig,
  Ddi_Vararray_t *vA,
  Ddi_Bddarray_t *gA
)
{
  int n, m, j;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fArrayAig);
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig;
  Ddi_Bddarray_t *newfArrayAig;

  m = Ddi_BddarrayNum(fArrayAig);
  /* the length of the two arrays must be the same */
  n = Ddi_VararrayNum(vA);
  Pdtutil_Assert(n==Ddi_BddarrayNum(gA),
    "different length of var/func arrays in compose");
  bmgr = Ddi_ReadMgr(vA)->aig.mgr;
  newfArrayAig = Ddi_BddarrayAlloc(ddm,m);

  for (j=0;j<m;j++) {
    Pdtutil_Assert(Ddi_BddIsAig(Ddi_BddarrayRead(fArrayAig,j)),
      "AIG required by compose");
  }
  for (j=0;j<n;j++) {
    Pdtutil_Assert(Ddi_BddIsAig(Ddi_BddarrayRead(gA,j)),
      "AIG required by compose");
  }

  for (j=0;j<n;j++) {
    bAigEdge_t bIndex;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t varIndex =
      Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in compose");
    bIndex = Ddi_BddToBaig(Ddi_BddarrayRead(gA,j));

    bAig_AuxPtrNum(bmgr,varIndex) = bIndex;
    bAig_Ref(bmgr,bIndex);
    nodeSetVisited(bmgr,varIndex);
  }

  for (j=0;j<m;j++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fArrayAig,j);
    newfAig = Ddi_BddMakeFromBaig(ddm,composeIntern(bmgr,Ddi_BddToBaig(f),1));
    Ddi_BddarrayWrite(newfArrayAig,j,newfAig);
    Ddi_Free(newfAig);
  }

  for (j=0;j<m;j++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fArrayAig,j);
    composeClearVisitedIntern(bmgr,Ddi_BddToBaig(f),1);
  }

#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  for (j=0;j<n;j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t varIndex =
      Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in compose");

    if (bAig_AuxPtr(bmgr,varIndex) != NULL) {
      bAig_RecursiveDeref(bmgr,bAig_AuxPtrNum(bmgr,varIndex));
      bAig_AuxPtr(bmgr,varIndex) = NULL;
    }
    if (nodeVisited(bmgr,varIndex)) {
      nodeClearVisited(bmgr,varIndex);
    }
  }
#endif

  return(newfArrayAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Varset_t *
Ddi_AigCoi (
  Ddi_Bdd_t *fAig,
  Ddi_Vararray_t *vA,
  Ddi_Bddarray_t *gA
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Varset_t *coi;
  Ddi_Bddarray_t *fArrayAig;

  if (Ddi_BddIsPartConj(fAig) || Ddi_BddIsPartDisj(fAig)) {
    fArrayAig = Ddi_BddarrayMakeFromBddPart(fAig);
  }
  else {
    fArrayAig = Ddi_BddarrayAlloc(ddm,1);
    Ddi_BddarrayWrite(fArrayAig,0,fAig);
  }

  coi = Ddi_AigarrayCoi(fArrayAig,vA,gA);
  Ddi_Free(fArrayAig);

  return coi;
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Varset_t *
Ddi_AigarrayCoi (
  Ddi_Bddarray_t *fArrayAig,
  Ddi_Vararray_t *vA,
  Ddi_Bddarray_t *gA
)
{
  int n, m, j;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fArrayAig);
  bAig_Manager_t  *bmgr;
  Ddi_Varset_t *coi;
  Ddi_Varset_t *vAset=NULL;
  Ddi_Vararray_t *vAord=NULL;

  Ddi_Free(vAset);

  m = Ddi_BddarrayNum(fArrayAig);
  /* the length of the two arrays must be the same */
  n = Ddi_VararrayNum(vA);
  Pdtutil_Assert(n==Ddi_BddarrayNum(gA),
    "different length of var/func arrays in compose");
  bmgr = Ddi_ReadMgr(vA)->aig.mgr;
  coi = Ddi_VarsetMakeArrayVoid(ddm);;

  for (j=0;j<m;j++) {
    Pdtutil_Assert(Ddi_BddIsAig(Ddi_BddarrayRead(fArrayAig,j)),
      "AIG required by compose");
  }
  for (j=0;j<n;j++) {
    Pdtutil_Assert(Ddi_BddIsAig(Ddi_BddarrayRead(gA,j)),
      "AIG required by compose");
  }

  Ddi_MgrSiftSuspend(ddm);

  for (j=0;j<n;j++) {
    bAigEdge_t bIndex;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t varIndex =
      Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in compose");
    bIndex = Ddi_BddToBaig(Ddi_BddarrayRead(gA,j));

    bAig_AuxPtrNum(bmgr,varIndex) = bIndex;
    bAig_Ref(bmgr,bIndex);
  }

  for (j=0;j<m;j++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fArrayAig,j);
    coiIntern(bmgr,Ddi_BddToBaig(f));
  }

  vAset = Ddi_VarsetMakeFromArray(vA);
  vAord = Ddi_VararrayMakeFromVarset(vAset,0); // sorted by ord
  Ddi_Free(vAset);

  Pdtutil_Assert(Ddi_VararrayNum(vAord)==n,"wrong var array num");

  //  for (j=n-1;j>=0;j--) {
  for (j=0;j<n;j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vAord,j);
    bAigEdge_t varIndex =
      Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in compose");

    if (nodeVisited(bmgr,varIndex)) {
      Ddi_VarsetAddAcc(coi,v);
    }
  }
  Ddi_Free(vAord);

  for (j=0;j<m;j++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fArrayAig,j);
    composeClearVisitedIntern(bmgr,Ddi_BddToBaig(f),1);
  }

  Ddi_MgrSiftResume(ddm);

  for (j=0;j<n;j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t varIndex =
      Ddi_VarToBaig(v);

    bAig_RecursiveDeref(bmgr,bAig_AuxPtrNum(bmgr,varIndex));
    bAig_AuxPtr(bmgr,varIndex) = NULL;
  }


  return(coi);
}


/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayComposeNoMultipleAcc (
  Ddi_Bddarray_t *fArrayAig,
  Ddi_Vararray_t *vA,
  Ddi_Bddarray_t *gA
)
{
  Ddi_Bddarray_t *newf = Ddi_AigarrayComposeNoMultiple (fArrayAig,vA,gA);
  DdiGenericDataCopy((Ddi_Generic_t *)fArrayAig,(Ddi_Generic_t *)newf);
  Ddi_Free(newf);
  return(fArrayAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayComposeNoMultiple (
  Ddi_Bddarray_t *fArrayAig,
  Ddi_Vararray_t *vA,
  Ddi_Bddarray_t *gA
)
{
  int n, m, j;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fArrayAig);
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig;
  Ddi_Bddarray_t *newfArrayAig;
  int freeG = 0;

  m = Ddi_BddarrayNum(fArrayAig);
  /* the length of the two arrays must be the same */
  n = Ddi_VararrayNum(vA);
  Pdtutil_Assert(n==Ddi_BddarrayNum(gA),
    "different length of var/func arrays in compose");
  bmgr = Ddi_ReadMgr(vA)->aig.mgr;
  newfArrayAig = Ddi_BddarrayAlloc(ddm,m);

  for (j=0;j<m;j++) {
    Pdtutil_Assert(Ddi_BddIsAig(Ddi_BddarrayRead(fArrayAig,j)),
      "AIG required by compose");
  }
  for (j=0;j<n;j++) {
    if (!Ddi_BddIsAig(Ddi_BddarrayRead(gA,j))) {
      if (!freeG) {
	freeG = 1;
	gA = Ddi_BddarrayDup(gA);
      }
      Ddi_BddSetAig(Ddi_BddarrayRead(gA,j));
    }
    Pdtutil_Assert(Ddi_BddIsAig(Ddi_BddarrayRead(gA,j)),
      "AIG required by compose");
  }

  for (j=0;j<n;j++) {
    bAigEdge_t bIndex;
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t varIndex =
      Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in compose");
    bIndex = Ddi_BddToBaig(Ddi_BddarrayRead(gA,j));

    bAig_AuxPtrNum(bmgr,varIndex) = bIndex;
    bAig_Ref(bmgr,bIndex);
    Pdtutil_Assert(nodeVisited(bmgr,varIndex)==0,"wrong visited flag");
    nodeSetVisited(bmgr,varIndex);
  }

  for (j=0;j<m;j++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fArrayAig,j);
    newfAig = Ddi_BddMakeFromBaig(ddm,composeIntern(bmgr,Ddi_BddToBaig(f),0));
    Ddi_BddarrayWrite(newfArrayAig,j,newfAig);
    Ddi_Free(newfAig);
  }

  for (j=0;j<m;j++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fArrayAig,j);
    composeClearVisitedIntern(bmgr,Ddi_BddToBaig(f),1);
  }

#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  for (j=0;j<n;j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
    bAigEdge_t varIndex =
      Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in compose");

    if (bAig_AuxPtr(bmgr,varIndex) != NULL) {
      bAig_RecursiveDeref(bmgr,bAig_AuxPtrNum(bmgr,varIndex));
      bAig_AuxPtr(bmgr,varIndex) = NULL;
    }
    if (nodeVisited(bmgr,varIndex)) {
      nodeClearVisited(bmgr,varIndex);
    }
  }
#endif

  if (freeG) {
    Ddi_Free(gA);
  }

  return(newfArrayAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigComposeFunc (
  Ddi_Bdd_t *fAig,
  Ddi_Bddarray_t *oldA,
  Ddi_Bddarray_t *newA
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,1);
  Ddi_BddarrayWrite(fA,0,fAig);
  Ddi_AigarrayComposeFuncAcc (fA,oldA,newA);
  Ddi_Bdd_t *newf = Ddi_BddDup(Ddi_BddarrayRead (fA,0));
  Ddi_Free(fA);
  return(newf);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayComposeFuncAcc (
  Ddi_Bddarray_t *fArrayAig,
  Ddi_Bddarray_t *oldA,
  Ddi_Bddarray_t *newA
)
{
  Ddi_Bddarray_t *newf = Ddi_AigarrayComposeFunc (fArrayAig,oldA,newA);
  DdiGenericDataCopy((Ddi_Generic_t *)fArrayAig,(Ddi_Generic_t *)newf);
  Ddi_Free(newf);
  return(fArrayAig);
}

/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayComposeFunc (
  Ddi_Bddarray_t *fArrayAig,
 Ddi_Bddarray_t *oldA,
  Ddi_Bddarray_t *newA
)
{
  int n, m, j;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fArrayAig);
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig;
  Ddi_Bddarray_t *newfArrayAig;
  int freeG = 0;

  m = Ddi_BddarrayNum(fArrayAig);
  /* the length of the two arrays must be the same */
  n = Ddi_BddarrayNum(oldA);
  Pdtutil_Assert(n==Ddi_BddarrayNum(newA),
    "different length of var/func arrays in compose");
  bmgr = Ddi_ReadMgr(oldA)->aig.mgr;
  newfArrayAig = Ddi_BddarrayAlloc(ddm,m);

  for (j=0;j<m;j++) {
    Pdtutil_Assert(Ddi_BddIsAig(Ddi_BddarrayRead(fArrayAig,j)),
      "AIG required by compose");
  }
  for (j=0;j<n;j++) {
    if (!Ddi_BddIsAig(Ddi_BddarrayRead(newA,j))) {
      if (!freeG) {
	freeG = 1;
	newA = Ddi_BddarrayDup(newA);
      }
      Ddi_BddSetAig(Ddi_BddarrayRead(newA,j));
    }
    Pdtutil_Assert(Ddi_BddIsAig(Ddi_BddarrayRead(newA,j)),
      "AIG required by compose");
  }

  for (j=0;j<n;j++) {
    bAigEdge_t bIndex;
    Ddi_Bdd_t *old_j = Ddi_BddarrayRead(oldA,j);
    bAigEdge_t baig =
      Ddi_BddToBaig(old_j);
    Pdtutil_Assert(baig != bAig_NULL,"NULL variable in compose");
    bIndex = Ddi_BddToBaig(Ddi_BddarrayRead(newA,j));

    bAig_AuxPtrNum(bmgr,baig) = bIndex;
    bAig_Ref(bmgr,bIndex);
    Pdtutil_Assert(nodeVisited(bmgr,baig)==0,"wrong visited flag");
    nodeSetVisited(bmgr,baig);
  }

  for (j=0;j<m;j++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fArrayAig,j);
    newfAig = Ddi_BddMakeFromBaig(ddm,composeIntern(bmgr,Ddi_BddToBaig(f),0));
    Ddi_BddarrayWrite(newfArrayAig,j,newfAig);
    Ddi_Free(newfAig);
  }

  for (j=0;j<m;j++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fArrayAig,j);
    composeClearVisitedIntern(bmgr,Ddi_BddToBaig(f),1);
  }

#if 1
  /* this extra free is for variables out of function support,
     that are not cleared by ...ClearVisitedIntern... */
  for (j=0;j<n;j++) {
    Ddi_Bdd_t *old_j = Ddi_BddarrayRead(oldA,j);
    bAigEdge_t baig =
      Ddi_BddToBaig(old_j);
    Pdtutil_Assert(baig != bAig_NULL,"NULL variable in compose");

    if (bAig_AuxPtr(bmgr,baig) != NULL) {
      bAig_RecursiveDeref(bmgr,bAig_AuxPtrNum(bmgr,baig));
      bAig_AuxPtr(bmgr,baig) = NULL;
    }
    if (nodeVisited(bmgr,baig)) {
      nodeClearVisited(bmgr,baig);
    }
  }
#endif

  if (freeG) {
    Ddi_Free(newA);
  }

  return(newfArrayAig);
}


/**Function********************************************************************
  Synopsis    [Return true if Aig handling active (Ddi_AigInit done)]
  Description [Return true if Aig handling active (Ddi_AigInit done)]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigActive (
  Ddi_Mgr_t *ddm
)
{
  return (ddm->aig.mgr != NULL);
}

/**Function********************************************************************
  Synopsis    [Initialize Aig handling in DDI manager]
  Description [Initialize Aig handling in DDI manager]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigInit (
  Ddi_Mgr_t *ddm,
  int maxSize
)
{
  if (ddm->aig.mgr==NULL) {
    ddm->aig.mgr = bAig_initAig (maxSize);
    ddm->aig.mgr->owner = ddm;
  }
  return;
}

/**Function********************************************************************
  Synopsis    [Close Aig handling in DDI manager]
  Description [Close Aig handling in DDI manager. This enables further
    opening of Aig management with fresh new data]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigQuit (
  Ddi_Mgr_t *ddm
)
{
  if (ddm->aig.mgr != NULL) {
    if (ddm->aig.auxLits != NULL) {
      Ddi_Unlock(ddm->aig.auxLits);
      Ddi_Free(ddm->aig.auxLits);
    }
    if (ddm->aig.auxLits2 != NULL) {
      Ddi_Unlock(ddm->aig.auxLits2);
      Ddi_Free(ddm->aig.auxLits2);
    }
    if (ddm->aig.actVars != NULL) {
      Ddi_Unlock(ddm->aig.actVars);
      Ddi_Free(ddm->aig.actVars);
    }
    bAig_quit(ddm->aig.mgr);
    ddm->aig.mgr = NULL;
  }

  Pdtutil_Free(ddm->cnf.cnf2aig);
  ddm->cnf.cnf2aig=NULL;
  ddm->cnf.cnf2aigSize=0;

}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigMakePartDisj(
  Ddi_Bdd_t *f
)
{
  Ddi_Bdd_t *fDup = Ddi_BddDup(f);
  Ddi_AigSetPartDisj(fDup);
  return (fDup);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigSetPartDisj(
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAigEdge_t fBaig = Ddi_BddToBaig(f);
  int doRet;

  doRet = bAig_isVarNode(bmgr,fBaig) || bAig_NodeIsConstant(fBaig);
  Ddi_BddSetPartDisj(f);

  if (doRet) {
    return;
  }

  if (bAig_NodeIsInverted(fBaig)) {
    Ddi_Bdd_t *p0, *p1, *tmp;
    bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,fBaig);
    bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,fBaig);
    p0 = Ddi_BddMakeFromBaig(ddm,right);
    p1 = Ddi_BddMakeFromBaig(ddm,left);
    Ddi_BddNotAcc(p0);
    Ddi_BddNotAcc(p1);
    Ddi_AigSetPartDisj(p0);
    Ddi_AigSetPartDisj(p1);
    tmp = Ddi_BddPartExtract(f,0);
    Ddi_Free(tmp);
    Ddi_BddPartInsertLast(f,p0);
    Ddi_BddPartInsertLast(f,p1);
    Ddi_BddSetFlattened(f);
    Ddi_Free(p0);
    Ddi_Free(p1);
  }
  else {
    Ddi_Bdd_t *p0, *p1, *tmp;
    bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,fBaig);
    bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,fBaig);
    p0 = Ddi_BddMakeFromBaig(ddm,right);
    p1 = Ddi_BddMakeFromBaig(ddm,left);
    tmp = Ddi_BddPartExtract(f,0);
    Ddi_Free(tmp);

    tmp = Ddi_BddAnd(p0,p1);
    Ddi_BddPartInsertLast(f,tmp);
    Ddi_Free(tmp);

    Ddi_BddNotAcc(p0);

    tmp = Ddi_BddAnd(p0,p1);
    Ddi_BddPartInsertLast(f,tmp);
    Ddi_Free(tmp);

    Ddi_BddNotAcc(p1);

    tmp = Ddi_BddAnd(p0,p1);
    Ddi_BddPartInsertLast(f,tmp);
    Ddi_Free(tmp);

    Ddi_BddNotAcc(p0);

    tmp = Ddi_BddAnd(p0,p1);
    Ddi_BddPartInsertLast(f,tmp);
    Ddi_Free(tmp);

    Ddi_BddSetFlattened(f);
    Ddi_Free(p0);
    Ddi_Free(p1);
  }

}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_BddMakeFromAig(
  Ddi_Bdd_t *f
)
{
#if 0
  Ddi_Bdd_t *res = aig2BddIntern(Ddi_ReadMgr(f),f->data.aig->aigNode);
  Ddi_Bdd_t *res1 = aig2BddIntern0(Ddi_ReadMgr(f),f->data.aig->aigNode);
  Pdtutil_Assert(Ddi_BddEqual(res,res1),"AIG->BDD problem");
  Ddi_Free(res1);
  aig2BddClearVisitedIntern(Ddi_ReadMgr(f)->aig.mgr,f->data.aig->aigNode);
#else
#if 1
  Ddi_Bdd_t *res = aig2BddIntern(Ddi_ReadMgr(f),f->data.aig->aigNode);
#else
  Ddi_Bdd_t *res = aig2BddIntern0(Ddi_ReadMgr(f),f->data.aig->aigNode);
  aig2BddClearVisitedIntern(Ddi_ReadMgr(f)->aig.mgr,f->data.aig->aigNode);
#endif
#endif
  return(res);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_BddMakeFromAigWithAbort(
  Ddi_Bdd_t *f,
  int th
)
{
  Ddi_Bdd_t *res = aig2BddInternWithAbort(Ddi_ReadMgr(f),
    f->data.aig->aigNode, th);
  return(res);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigCnfStore(
  Ddi_Bdd_t *f,
  char *filename                 /* IN: file name */,
  FILE *fp                       /* IN: pointer to the store file */
)
{
  int flagFile, clauseN, varMax, fCnf;
  bAigEdge_t baig;
  fpos_t posFile;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);

  fp = Pdtutil_FileOpen (fp, filename, "w", &flagFile);
  fgetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", 0, 0);
  clauseN = 1;
  varMax = -1;


  aig2CnfIdInit(ddm);
  aig2CnfClauses(f,fp,&clauseN, &varMax);
  aig2CnfIdClose(ddm);

  fsetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", varMax, clauseN);
  Pdtutil_FileClose (fp, &flagFile);
  return fCnf;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigCnfStore0(
  Ddi_Bdd_t *f,
  char *filename                 /* IN: file name */,
  FILE *fp                       /* IN: pointer to the store file */
)
{
  int flagFile, clauseN, varMax, fCnf;
  bAigEdge_t baig;
  fpos_t posFile;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);

  fp = Pdtutil_FileOpen (fp, filename, "w", &flagFile);
  fgetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", 0, 0);
  clauseN = 1;
  varMax = -1;

  baig = f->data.aig->aigNode;
  aig2CnfIdInit(ddm);
  fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                      aig2CnfId(ddm->aig.mgr,baig);
  fprintf(fp, "%d 0\n", fCnf);

  aig2CnfIntern(ddm,baig,fp,&clauseN, &varMax);
  fsetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", varMax, clauseN);
  Pdtutil_FileClose (fp, &flagFile);
  return fCnf;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigTrCnfStore(
  Ddi_Bdd_t *tr,
  Ddi_Vararray_t *psVars,
  Ddi_Vararray_t *nsVars,
  Ddi_Vararray_t *piVars,
  char *filename
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(tr);
  bAig_Manager_t *aigMgr = ddm->aig.mgr;
  Ddi_Var_t *v;
  bAigEdge_t baig;
  int i, lit;
  FILE *fp;

  aig2CnfIdInit(ddm);
  lit = Ddi_AigCnfStore(tr, filename, NULL);

  fp = fopen(filename, "a");
  fprintf(fp, "c h = %d\n", lit);
  /* present state */
  for (i=0; i<Ddi_VararrayNum(psVars); i++) {
     v = Ddi_VararrayRead(psVars, i);
     baig = Ddi_VarToBaig(v);
     lit = aig2CnfId(aigMgr, baig);
     fprintf(fp, "c x%d = %d\n", i, lit);
  }
  /* next state */
  for (i=0; i<Ddi_VararrayNum(nsVars); i++) {
     v = Ddi_VararrayRead(nsVars, i);
     baig = Ddi_VarToBaig(v);
     lit = aig2CnfId(aigMgr, baig);
     fprintf(fp, "c y%d = %d\n", i, lit);
  }
  /* inputs */
  for (i=0; i<Ddi_VararrayNum(piVars); i++) {
     v = Ddi_VararrayRead(piVars, i);
     baig = Ddi_VarToBaig(v);
     lit = aig2CnfId(aigMgr, baig);
     fprintf(fp, "c w%d = %d\n", i, lit);
  }
  aig2CnfIdClose(ddm);
  fclose(fp);

  return 0;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigQbfAndSolve(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g,
  Ddi_Vararray_t *forallVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *aigMgr = ddm->aig.mgr;
  Ddi_Vararray_t *qbfVars, *suppVars;
  Ddi_Bddarray_t *qbfBdds, *suppBdds;
  Ddi_Varset_t *supp, *qbfSupp;
  Ddi_Var_t *v;
  Ddi_Bdd_t *h, *gqbf, *varBdd;
  bAigEdge_t baig;
  int i, flag, numVars=0, varNum, clauseNum;
  int *forallIds, lit, ret;
  FILE *fp=NULL;

  Pdtutil_Assert ((!Ddi_VararrayNum(forallVars)) || (!DdiAigIsConst(g, 1)),
		  "Invalid QBF check");
  if (DdiAigIsConst(f, 0) || DdiAigIsConst(g, 0)) {
     return 0;
  }
  if (Ddi_VararrayNum(forallVars) == 0) {
     /* simple SAT check */
     h = Ddi_BddAnd(f, g);
     ret = Ddi_AigSat(h);
     Ddi_Free(h);
     return ret;
  }

  /* replace forall vars */
  qbfVars = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(forallVars));
  for (i=0; i<Ddi_VararrayNum(forallVars); i++) {
     v = newQbfVar(ddm, i);
     Ddi_VararrayWrite(qbfVars, i, v);
  }
  qbfBdds = Ddi_BddarrayMakeLiteralsAig(qbfVars, 1);
  gqbf = Ddi_BddCompose(g, forallVars, qbfBdds);
  //Ddi_Free(qbfBdds);

  fp = Pdtutil_FileOpen(fp, (char *)"clauses.qdimacs", "w", &flag);
  varNum = clauseNum = 0;
  aig2CnfIdInit(ddm);

  /* dump f */
  if (!DdiAigIsConst(f, 1)) {
     baig = f->data.aig->aigNode;
     lit = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                        aig2CnfId(ddm->aig.mgr,baig);
     fprintf(fp, "%d 0\n", lit);
     clauseNum++;

     aig2CnfIntern(ddm, baig, fp, &clauseNum, &varNum);
     numVars = varNum;
  }
  /* dump g */
  baig = gqbf->data.aig->aigNode;
  lit = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                     aig2CnfId(ddm->aig.mgr,baig);
  fprintf(fp, "%d 0\n", lit);
  clauseNum++;

  aig2CnfIntern(ddm, baig, fp, &clauseNum, &varNum);
  Pdtutil_FileClose(fp, &flag);
  fp = NULL;

  /* get forall ids */
  forallIds = Pdtutil_Alloc(int, varNum+1);
  for (i=0; i<=varNum; i++) {
     forallIds[i] = 0;
  }
  for (i=0; i<Ddi_BddarrayNum(qbfBdds); i++) {
     varBdd = Ddi_BddarrayRead(qbfBdds, i);
     baig = varBdd->data.aig->aigNode;
     lit = aig2CnfId(ddm->aig.mgr, baig);
     forallIds[lit] = 1;
  }

  /* dump header */
  fp = Pdtutil_FileOpen(fp, (char *)"header.qdimacs", "w", &flag);
  fprintf(fp, "p cnf %d %d\n", varNum, clauseNum);

  /* external exist vars */
  fprintf(fp, "e ");
  if (numVars == 0) {
     supp = DdiAigSupp(gqbf);
     qbfSupp = Ddi_VarsetMakeFromArray(qbfVars);
     Ddi_VarsetDiffAcc(supp, qbfSupp);
     Ddi_Free(qbfSupp);
     suppVars = Ddi_VararrayMakeFromVarset(supp, 1);
     Ddi_Free(supp);
     Pdtutil_Assert(Ddi_VararrayNum(suppVars), "Empty exist support!");
     suppBdds = Ddi_BddarrayMakeLiteralsAig(suppVars, 1);
     Ddi_Free(suppVars);
     for (i=1; i<=Ddi_BddarrayNum(suppBdds); i++) {
	varBdd = Ddi_BddarrayRead(suppBdds, i);
	baig = varBdd->data.aig->aigNode;
	lit = aig2CnfId(ddm->aig.mgr, baig);
	fprintf(fp, "%d ", lit);
     }
     Ddi_Free(suppBdds);
  } else {
     for (i=1; i<=numVars; i++) {
	fprintf(fp, "%d ", i);
     }
  }
  fprintf(fp, "0\n");

  /* forall vars */
  fprintf(fp, "a ");
  for (i=0; i<Ddi_BddarrayNum(qbfBdds); i++) {
     varBdd = Ddi_BddarrayRead(qbfBdds, i);
     baig = varBdd->data.aig->aigNode;
     lit = aig2CnfId(ddm->aig.mgr, baig);
     fprintf(fp, "%d ", lit);
  }
  fprintf(fp, "0\n");

  /* internal exist vars */
  fprintf(fp, "e ");
  for (i=numVars+1; i<=varNum; i++) {
     if (forallIds[i] == 0)
	fprintf(fp, "%d ", i);
  }
  fprintf(fp, "0\n");

  Pdtutil_FileClose(fp, &flag);
  fp = NULL;
  aig2CnfClearVisitedIntern(aigMgr, gqbf->data.aig->aigNode);
  if (!DdiAigIsConst(f, 1)) {
     aig2CnfClearVisitedIntern(aigMgr, f->data.aig->aigNode);
  }
  aig2CnfIdClose(ddm);
  Pdtutil_Free(forallIds);
  Ddi_Free(gqbf);
  Ddi_Free(qbfVars);
  Ddi_Free(qbfBdds);

  /* merge files and run solver */
  system("cat header.qdimacs clauses.qdimacs > e.qdimacs");
  system("rm -f header.qdimacs clauses.qdimacs");

  /* parse result and return */
  ret = system("skizzo e.qdimacs");
  system("rm -f e.qdimacs");

  ret = WEXITSTATUS(ret);
  if (ret == 10) //sat
    return 1;

  if (ret == 20) //unsat
    return 0;

  return -1; //error
}

/**Function********************************************************************
  Synopsis    [FSM store]
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/

void
Ddi_AigFsmStore(
  Ddi_Vararray_t *pi,
  Ddi_Vararray_t *ps,
  Ddi_Vararray_t *ns,
  Ddi_Bdd_t *s0,
  Ddi_Bddarray_t *delta,
  Ddi_Bddarray_t *lambda,
  char *filename                 /* IN: file name */,
  FILE *fp                       /* IN: pointer to the store file */,
  Pdtutil_AigDump_e format
  )
{
  Ddi_Bddarray_t *tmparray;
  Ddi_Varset_t *pivars, *psvars, *nsvars, *tmpvars1;
  Ddi_Var_t *var1;
  Ddi_Bdd_t *tmpbdd;
  int i, flagFile, value;
  char name[PDTUTIL_MAX_STR_LEN];
  char *name1;
  bAigEdge_t baig;
  Ddi_Mgr_t *ddMgr = Ddi_ReadMgr (pi);
  bAig_Manager_t *manager = ddMgr->aig.mgr;

  pivars = Ddi_VarsetMakeFromArray (pi);
  psvars = Ddi_VarsetMakeFromArray (ps);
  nsvars = Ddi_VarsetMakeFromArray (ns);

  fp = Pdtutil_FileOpen (fp, filename, "w", &flagFile);
  //fp = dMgrO(ddm);

  /*-------------------------------- Header ---------------------------------*/

  switch (format) {
    case Pdtutil_Aig2BenchName_c:
      break;
    case Pdtutil_Aig2BenchId_c:
      break;
    case Pdtutil_Aig2Blif_c:
      fprintf(fp, ".model FSM_FROM_AIG\n");
      break;
    case Pdtutil_Aig2Slif_c:
      fprintf(fp, ".model FSM_FROM_AIG ;\n");
      break;
    default:
      Pdtutil_Assert (0, "Invalid Net format for AIG store");
  }

  /*---------------------------- Input Variables -----------------------------*/

  tmpvars1 = Ddi_VarsetDup (pivars);
  while ( !Ddi_VarsetIsVoid (tmpvars1) ) {
    var1 = Ddi_VarsetTop (tmpvars1);
    name1 = Ddi_VarName (var1);
    fprintf(fp, ".inputs %s\n", name1);
    Ddi_VarsetNextAcc (tmpvars1);
  }
  Ddi_Free(tmpvars1);

  /*-------------------------------- Outputs --------------------------------*/

  for (i=0; i<Ddi_BddarrayNum (lambda); i++) {
    tmpbdd = Ddi_BddarrayRead (lambda, i);
    name1 = Ddi_ReadName (tmpbdd);
    if (name1 == NULL) {
      sprintf(name, "_AIG_OUTPUT_%d", i);
    } else {
      strcpy (name, name1);
    }
    baig = tmpbdd->data.aig->aigNode;

    switch (format) {
      case Pdtutil_Aig2Blif_c:
        fprintf(fp,".outputs OUT_%s\n", name);
        break;
      case Pdtutil_Aig2BenchName_c:
        fprintf(fp,"OUTPUT(%s)\n", name);
        break;
      case Pdtutil_Aig2BenchId_c:
        fprintf(fp,"OUTPUT(%s)\n", name);
        break;
      case Pdtutil_Aig2Slif_c:
        fprintf(fp,".outputs %s\n", name);
        break;
      default:
        Pdtutil_Assert (0, "Invalid Net format for AIG store.");
        break;
    }
  }

  /*-------------------------------- Latches --------------------------------*/

  //Init state
  //Ddi_AigNetStore (s0, "s0", NULL, format);

  i = 0;
  tmpvars1 = Ddi_VarsetDup (psvars);
  //tmpvars2 = Ddi_VarsetDup (nsvars);
  while ( !Ddi_VarsetIsVoid (tmpvars1) ) {
    var1 = Ddi_VarsetTop (tmpvars1);
    name1 = Ddi_VarName (var1);

    tmpbdd = Ddi_BddarrayRead (delta, i);
    baig = tmpbdd->data.aig->aigNode;
    i++;

    if (Ddi_BddIsZero (Ddi_BddCofactor (s0, var1, 1))) {
      value = 0;
    } else {
      value = 1;
    }

    fprintf(fp, ".latch %s$NS %s %d\n", name1, name1, value);

    Ddi_VarsetNextAcc (tmpvars1);
  }
  Ddi_Free (tmpvars1);

  /*--------------------------- Buffer for Outputs ---------------------------*/

  //fprintf(fp, "\nBuffer for outputs\n");
  for (i=0; i<Ddi_BddarrayNum (lambda); i++) {
    tmpbdd = Ddi_BddarrayRead (lambda, i);
    name1 = Ddi_ReadName (tmpbdd);
    if (name1 == NULL) {
      sprintf(name, "_AIG_OUTPUT_%d", i);
    } else {
      strcpy (name, name1);
    }
    baig = tmpbdd->data.aig->aigNode;

    switch (format) {
      case Pdtutil_Aig2Blif_c:
        if (bAig_NodeIsConstant(baig)) {
          fprintf(fp,".names OUT_%s\n%d\n", name,bAig_NodeIsInverted (baig));
        }
        else {
          fprintf(fp,".names %s OUT_%s\n%d 1\n",
	    bAig_NodeReadName(manager,baig), name,
            bAig_NodeIsInverted(baig)?0:1);
        }
        break;
      case Pdtutil_Aig2BenchName_c:
        fprintf(fp,"%s = %s(%s)\n",
	  name, bAig_NodeIsInverted(baig)?"NOT":"BUFF",
          bAig_NodeReadName(manager,baig));
        break;
      case Pdtutil_Aig2BenchId_c:
        fprintf(fp," = %s(NODE_%d)\n",
	  bAig_NodeIsInverted(baig)?"NOT":"BUFF",
          bAig_NonInvertedEdge(baig));
        break;
      case Pdtutil_Aig2Slif_c:
        fprintf(fp,"%s = %s%s\n",
	  name, bAig_NodeReadName(manager,baig),
          bAig_NodeIsInverted(baig)?"'":"");
        break;
      default:
        Pdtutil_Assert (0, "Invalid Net format for AIG store.");
        break;
    }
  }

  /*-------------------------- Internal Nodes -------------------------------*/

  //fprintf(fp, "\nDeltas & lambdas\n");
  tmparray = Ddi_BddarrayDup (delta);
  Ddi_BddarrayAppend (tmparray, lambda);

  for (i=0; i<Ddi_BddarrayNum(tmparray); i++) {
    tmpbdd = Ddi_BddarrayRead (tmparray, i);
    baig = tmpbdd->data.aig->aigNode;

    /* Buffer for latches */
    if (i<Ddi_BddarrayNum (delta)) {

      if (bAig_NodeIsConstant(baig)) {
        fprintf(fp,".names %s$NS\n%d\n",
  	  Ddi_VarName(Ddi_VararrayRead(ps,i)),
          bAig_NodeIsInverted (baig));
      }
      else {
        fprintf(fp,".names %s %s$NS\n%d 1\n",
          bAig_NodeReadName (manager, baig),
  	  Ddi_VarName(Ddi_VararrayRead(ps,i)),
          bAig_NodeIsInverted (baig) ? 0 : 1);
      }

    }

    nodeNetStoreInternNoPI (manager, baig, fp, format);
  }

  for (i=0; i<Ddi_BddarrayNum (tmparray); i++) {
    tmpbdd = Ddi_BddarrayRead (tmparray, i);
    baig = tmpbdd->data.aig->aigNode;
    nodeNetStoreClearIntern (manager, baig, fp, format);
  }

  /*--------------------------------- Tail ----------------------------------*/

  switch(format) {
    case Pdtutil_Aig2BenchName_c:
      break;
    case Pdtutil_Aig2BenchId_c:
      break;
    case Pdtutil_Aig2Blif_c:
      fprintf(fp, ".end\n");
      break;
    case Pdtutil_Aig2Slif_c:
      fprintf(fp, ".endmodel FSM_FROM_AIG ;\n");
      break;
    default:
      Pdtutil_Assert (0, "Invalid Net format for AIG store.");
      break;
  }

  Pdtutil_FileClose (fp, &flagFile);

  //  exit (1);

#if 0
  char *name;
  bAigEdge_t baig;
  //  Ddi_Bddarray_t *fA = delta;
  Ddi_Bddarray_t *fA = lambda;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t *manager = ddm->aig.mgr;
  Ddi_Bdd_t *lit;
#endif

  return;
}

/**Function********************************************************************
  Synopsis    [Aig store. Internal recursion: phase 1]
  Description [
    Aig store. Internal recursion: phase 1.
    For format see Pdtutil_AigDump_e
    ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigNetStore(
  Ddi_Bdd_t *f,
  char *filename                 /* IN: file name */,
  FILE *fp                       /* IN: pointer to the store file */,
  Pdtutil_AigDump_e format
  )
{
  int flagFile;
  bAigEdge_t baig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *manager = ddm->aig.mgr;

  {
    Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,1);
    Ddi_BddarrayWrite(fA,0,f);
    Ddi_AigarrayNetStore(fA,filename,fp,format);
    Ddi_Free(fA);
    return NULL;
  }

  /* old part. Now disabled */

  fp = Pdtutil_FileOpen (fp, filename, "w", &flagFile);

  baig = f->data.aig->aigNode;

  /* header */
  switch (format) {
    case Pdtutil_Aig2Verilog_c:
      fprintf(fp, "module AIG_%s ", bAig_NodeReadName (manager, baig));
      break;
    case Pdtutil_Aig2BenchName_c:
    case Pdtutil_Aig2BenchId_c:
    case Pdtutil_Aig2BenchLocalId_c:
      break;
    case Pdtutil_Aig2Blif_c:
      fprintf(fp, ".model AIG_%s\n", bAig_NodeReadName (manager, baig));
      break;
    case Pdtutil_Aig2Slif_c:
      fprintf(fp, ".model AIG_%s ;\n", bAig_NodeReadName (manager, baig));
      break;
    default:
      Pdtutil_Assert (0, "Invalid Net format for AIG store");
  }

  /* inputs */
  nodeNetStoreIntern (manager, baig, fp, format);

  /* outputs */
  switch (format) {
    case Pdtutil_Aig2Blif_c:
      fprintf(fp,".outputs %s%s\n",
        bAig_NodeIsInverted(baig) ? "_NOT_" : "",
	bAig_NodeReadName(manager,baig));
      if (bAig_NodeIsInverted(baig)) {
        fprintf(fp,".names %s _NOT_%s\n0 1\n",
	  bAig_NodeReadName(manager,baig), bAig_NodeReadName(manager,baig));
      }
      break;
    case Pdtutil_Aig2BenchId_c:
      fprintf(fp,"OUTPUT(%sNODE_%d)\n",
        bAig_NodeIsInverted(baig) ? "_NOT_" : "",
        bAig_NonInvertedEdge(baig));
      break;
    case Pdtutil_Aig2BenchLocalId_c:
      fprintf(fp,"OUTPUT(%sNODE_%d)\n",
        bAig_NodeIsInverted(baig) ? "_NOT_" : "",
        bAig_NonInvertedEdge(baig));
      break;
    case Pdtutil_Aig2BenchName_c:
      fprintf(fp,"OUTPUT(%s%s)\n",
        bAig_NodeIsInverted(baig) ? "_NOT_" : "",
	bAig_NodeReadName(manager,baig));
      break;
    case Pdtutil_Aig2Slif_c:
      fprintf(fp,".outputs %s%s ;\n",
        bAig_NodeIsInverted(baig) ? "_NOT_" : "",
	bAig_NodeReadName(manager,baig));
      if (bAig_NodeIsInverted(baig)) {
        fprintf(fp,"_NOT_%s = %s' ;\n",
  	  bAig_NodeReadName(manager,baig), bAig_NodeReadName(manager,baig));
      }
      break;
    default:
      Pdtutil_Assert (0, "Invalid Net format for AIG store.");
      break;
  }

  nodeNetStoreClearIntern (manager, baig, fp, format);

  /* tail */
  switch(format) {
    case Pdtutil_Aig2BenchName_c:
      break;
    case Pdtutil_Aig2BenchId_c:
      break;
    case Pdtutil_Aig2Blif_c:
      fprintf(fp, ".end\n");
      break;
    case Pdtutil_Aig2Slif_c:
      fprintf(fp, ".endmodel %s ;\n", bAig_NodeReadName (manager, baig));
      break;
    default:
      Pdtutil_Assert (0, "Invalid Net format for AIG store.");
      break;
  }

  Pdtutil_FileClose (fp, &flagFile);
  return NULL;
}

/**Function********************************************************************
  Synopsis    [Aig store. Internal recursion: phase 1]
  Description [
    Aig store. Internal recursion: phase 1.
    For format see Pdtutil_AigDump_e
    ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigarrayNetStore(
  Ddi_Bddarray_t *fA,
  char *filename                 /* IN: file name */,
  FILE *fp                       /* IN: pointer to the store file */,
  Pdtutil_AigDump_e format
  )
{
  int flagFile, i, j, nRoots = Ddi_BddarrayNum(fA);
  char *name;
  bAigEdge_t baig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  bAig_array_t *nodesWithNot = bAigArrayAlloc();
  char rName[200], lName[200];

  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    postOrderAigVisitIntern(manager,fBaig,visitedNodes,-1);
  }
  postOrderAigClearVisitedIntern(manager,visitedNodes);

  fp = Pdtutil_FileOpen (fp, filename, "w", &flagFile);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig;
    bAigEdge_t right, left;


    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = i;
    nodeAuxChar(manager,baig) = 0; /* node referenced as inverted */

    if (bAig_isVarNode(manager,baig) || bAig_NodeIsConstant(baig)) {
      continue;
    }
    right = rightChild(manager,baig);
    left = leftChild(manager,baig);

    if (bAig_NodeIsInverted(right)) nodeAuxChar(manager,right) = 1;
    if (bAig_NodeIsInverted(left))  nodeAuxChar(manager,left) = 1;

  }
  for (i=j=0; i<visitedNodes->num; i++,j++) {
    bAigEdge_t baig;

    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = j;
    /* check if node is referred to as complemented */
    if (nodeAuxChar(manager,baig)) j++;
  }

  name = Ddi_ReadName(fA);
  if (name==NULL) {
    name = (char *)"AIG_ARRAY";
  }
  /* header */
  switch (format) {
    case Pdtutil_Aig2Verilog_c:
      fprintf(fp, "module AIG_%s (", name);
      break;
    case Pdtutil_Aig2BenchName_c:
      break;
    case Pdtutil_Aig2BenchId_c:
    case Pdtutil_Aig2BenchLocalId_c:
      break;
    case Pdtutil_Aig2Blif_c:
      fprintf(fp, ".model AIG_%s\n", name);
      break;
    case Pdtutil_Aig2Slif_c:
      fprintf(fp, ".model AIG_%s ;\n", name);
      break;
    default:
      Pdtutil_Assert (0, "Invalid Net format for AIG store");
  }

  if (format == Pdtutil_Aig2Verilog_c) {
    int inputFound = 0;
    /* inputs */
    for (i=0; i<visitedNodes->num; i++) {
      baig = visitedNodes->nodes[i];
      if (bAig_isVarNode(manager,baig)) {
        fprintf(fp,"%s NODE_%d", (i==0 ? "" : ",\n"),
          bAig_NonInvertedEdge(baig));
        inputFound = 1;
      }
    }
    Pdtutil_Assert(inputFound, "no inputs found in verilog store");
    /* outputs */
    for (i=0; i<Ddi_BddarrayNum(fA); i++) {
      fprintf(fp,",\n _AIG_OUTPUT_%d", i);
    }
    fprintf(fp," );\n");
  }

  /* inputs */
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    char c;
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (bAig_isVarNode(manager,baig)) {
      switch(format) {
        case Pdtutil_Aig2Verilog_c:
          fprintf(fp,"%s NODE_%d", (i==0 ? "input" : ",\n"),
            bAig_NonInvertedEdge(baig));
          break;
        case Pdtutil_Aig2BenchId_c:
          fprintf(fp,"INPUT(NODE_%d)\n", bAig_NonInvertedEdge(baig));
          break;
        case Pdtutil_Aig2BenchLocalId_c:
        case Pdtutil_Aig2BenchName_c:
          fprintf(fp,"INPUT(%s)\n", bAig_NodeReadName(manager,baig));
          break;
        case Pdtutil_Aig2Blif_c:
          fprintf(fp,".inputs %s\n", bAig_NodeReadName(manager,baig));
          break;
        case Pdtutil_Aig2Slif_c:
          fprintf(fp,".inputs %s ;\n", bAig_NodeReadName(manager,baig));
          break;
        default:
          Pdtutil_Assert (0, "Invalid Net format for AIG store.");
          break;
      }
    }

  }

  if (format == Pdtutil_Aig2Verilog_c) {
    fprintf(fp,";\n");
    /* outputs */
    for (i=0; i<Ddi_BddarrayNum(fA); i++) {
      Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
      baig = f->data.aig->aigNode;
      fprintf(fp,"%s _AIG_OUTPUT_%d", (i==0 ? "output" : ",\n"), i);
    }
    fprintf(fp,";\n");
  }

  /* outputs */
  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    int isConst;
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
    baig = f->data.aig->aigNode;
    isConst = bAig_NodeIsConstant(baig);
    switch (format) {
      case Pdtutil_Aig2Verilog_c:
      fprintf(fp,
       "%s_GATE _AIG_OUTPUT_%d ( .I1(NODE_%d) , .O(_AIG_OUTPUT_%d) ) ;\n",
	      bAig_NodeIsInverted(baig)?"INV":"BUF",
              i,
	      bAig_NonInvertedEdge(baig),
              i);
          break;
      case Pdtutil_Aig2Blif_c:
        fprintf(fp,".outputs _AIG_OUTPUT_%d\n", i);
        fprintf(fp,".names %s _AIG_OUTPUT_%d\n%d 1\n",
	  bAig_NodeIsConstant(baig)?"vdd":bAig_NodeReadName(manager,baig),
	  bAig_NodeReadName(manager,baig),
		i, (bAig_NodeIsInverted(baig)^isConst)?0:1);
        break;
      case Pdtutil_Aig2BenchName_c:
        fprintf(fp,"OUTPUT(_AIG_OUTPUT_%d)\n", i);
        fprintf(fp,"_AIG_OUTPUT_%d = %s(%s)\n",
		i, (bAig_NodeIsInverted(baig)^isConst)?"NOT":"BUFF",
	     isConst?"vdd":bAig_NodeReadName(manager,baig));
        break;
      case Pdtutil_Aig2BenchLocalId_c:
      case Pdtutil_Aig2BenchId_c:
        fprintf(fp,"OUTPUT(_AIG_OUTPUT_%d)\n", i);
        break;
      case Pdtutil_Aig2Slif_c:
        fprintf(fp,".outputs _AIG_OUTPUT_%d\n", i);
        fprintf(fp,"_AIG_OUTPUT_%d = %s%s\n",
	  i, bAig_NodeReadName(manager,baig),
          bAig_NodeIsInverted(baig)?"'":"");
        break;
      default:
        Pdtutil_Assert (0, "Invalid Net format for AIG store.");
        break;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    int id;
    bAigEdge_t nodeIndex, right, left;

    nodeIndex = visitedNodes->nodes[i];
    if (!bAig_isVarNode(manager,nodeIndex) && !bAig_NodeIsConstant(nodeIndex)) {

    right = rightChild(manager,nodeIndex);
    left = leftChild(manager,nodeIndex);
    switch(format) {
      case Pdtutil_Aig2Verilog_c:
      fprintf(fp,
       "AND%s%s_GATE NODE_%d ( .I1(NODE_%d) , .I2(NODE_%d) , .O(NODE_%d) );\n",
          bAig_NodeIsInverted(right) ? "1" : "0",
          bAig_NodeIsInverted(left) ? "1" : "0",
	  bAig_NonInvertedEdge(nodeIndex),
	  bAig_NonInvertedEdge(right),
	  bAig_NonInvertedEdge(left),
          bAig_NonInvertedEdge(nodeIndex));
        break;
      case Pdtutil_Aig2BenchId_c:
        fprintf(fp,"NODE_%d = AND ( %sNODE_%d , %sNODE_%d )\n",
	  bAig_NonInvertedEdge(nodeIndex),
          bAig_NodeIsInverted(right) ? "_NOT_" : "",
	  bAig_NonInvertedEdge(right),
          bAig_NodeIsInverted(left) ? "_NOT_" : "",
	  bAig_NonInvertedEdge(left));
        break;
      case Pdtutil_Aig2BenchLocalId_c:
        if (bAig_isVarNode(manager,right) && !bAig_NodeIsInverted(right)) {
	  strcpy(rName,bAig_NodeReadName(manager,right));
	}
	else {
          sprintf(rName,"n%d", bAig_NodeIsInverted(right) ?
		  bAig_AuxInt(manager,right)+1 : bAig_AuxInt(manager,right));
	}
        if (bAig_isVarNode(manager,left) && !bAig_NodeIsInverted(left)) {
	  strcpy(lName,bAig_NodeReadName(manager,left));
	}
	else {
          sprintf(lName,"n%d", bAig_NodeIsInverted(left) ?
		  bAig_AuxInt(manager,left)+1 : bAig_AuxInt(manager,left));
	}

        fprintf(fp,"n%d = AND ( %s , %s )\n",
		bAig_AuxInt(manager,nodeIndex), rName, lName);
        break;
      case Pdtutil_Aig2BenchName_c:
        fprintf(fp,"%s = AND ( %s%s , %s%s )\n",
	  bAig_NodeReadName(manager,nodeIndex),
          bAig_NodeIsInverted(right) ? "_NOT_" : "",
	  bAig_NodeReadName(manager,right),
          bAig_NodeIsInverted(left) ? "_NOT_" : "",
	  bAig_NodeReadName(manager,left));
        break;
      case Pdtutil_Aig2Blif_c:
        fprintf(fp,".names %s %s %s\n",
	  bAig_NodeReadName(manager,right),
	  bAig_NodeReadName(manager,left),
	  bAig_NodeReadName(manager,nodeIndex));
        fprintf(fp,"%d%d 1\n",
          !bAig_NodeIsInverted(right),!bAig_NodeIsInverted(left));
        break;
      case Pdtutil_Aig2Slif_c:
        fprintf(fp,"%s = ", bAig_NodeReadName (manager, nodeIndex));
        fprintf(fp,"%s", bAig_NodeReadName(manager,right));
        if (bAig_NodeIsInverted (right))
          fprintf(fp, "' ");
        else
          fprintf(fp, " ");
        fprintf(fp,"%s", bAig_NodeReadName(manager,left));
        if (bAig_NodeIsInverted (left))
          fprintf(fp, "'");
        fprintf(fp, ";\n");
        break;
      default:
        Pdtutil_Assert(0,"Invalid Net format for AIG store");
        break;
    }
    }

    id = bAig_AuxInt(manager,nodeIndex);

    if (nodeAuxChar(manager,nodeIndex) == 1) {
      /* node used as inverted */
      switch(format) {
        case Pdtutil_Aig2BenchId_c:
          fprintf(fp,"_NOT_NODE_%d = NOT ( NODE_%d )\n",
  	    bAig_NonInvertedEdge(nodeIndex),
	    bAig_NonInvertedEdge(nodeIndex));
          break;
        case Pdtutil_Aig2BenchLocalId_c:
          if (bAig_isVarNode(manager,nodeIndex)) {
	    strcpy(rName,bAig_NodeReadName(manager,nodeIndex));
	  }
	  else {
            sprintf(rName,"n%d", id);
 	  }
          fprintf(fp,"n%d = NOT ( %s )\n",id+1,rName);
          break;
        case Pdtutil_Aig2BenchName_c:
          fprintf(fp,"_NOT_%s = NOT ( %s )\n",
	    bAig_NodeReadName(manager,nodeIndex),
	    bAig_NodeReadName(manager,nodeIndex));
          break;
        case Pdtutil_Aig2Blif_c:
          break;
        case Pdtutil_Aig2Slif_c:
          break;
        default:
          Pdtutil_Assert(0,"Invalid Net format for AIG store");
          break;
      }
    }

  }

  /* outputs */
  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
    baig = f->data.aig->aigNode;
    switch (format) {
      case Pdtutil_Aig2Verilog_c:
      case Pdtutil_Aig2Blif_c:
      case Pdtutil_Aig2BenchName_c:
      case Pdtutil_Aig2Slif_c:
	break;
      case Pdtutil_Aig2BenchLocalId_c:
        if (bAig_NodeIsConstant(baig)) {
	  strcpy(rName,"vcc");
	}
        else if (bAig_isVarNode(manager,baig)) {
	  strcpy(rName,bAig_NodeReadName(manager,baig));
	}
	else {
          sprintf(rName,"n%d", bAig_AuxInt(manager,baig));
	}
        fprintf(fp,"_AIG_OUTPUT_%d = %s(%s)\n",
		i, bAig_NodeIsInverted(baig)?"NOT":"BUFF",rName);
        break;
      case Pdtutil_Aig2BenchId_c:
        fprintf(fp,"_AIG_OUTPUT_%d = %s(NODE_%d)\n",
	  i, bAig_NodeIsInverted(baig)?"NOT":"BUFF",
          bAig_NonInvertedEdge(baig));
        break;
      default:
        Pdtutil_Assert (0, "Invalid Net format for AIG store.");
        break;
    }
  }

  /* tail */
  switch(format) {
    case Pdtutil_Aig2Verilog_c:
      fprintf(fp, "endmodule\n");
      break;
    case Pdtutil_Aig2BenchName_c:
      break;
    case Pdtutil_Aig2BenchLocalId_c:
      break;
    case Pdtutil_Aig2BenchId_c:
      break;
    case Pdtutil_Aig2Blif_c:
      fprintf(fp, ".end\n");
      break;
    case Pdtutil_Aig2Slif_c:
      fprintf(fp, ".endmodel %s ;\n", name);
      break;
    default:
      Pdtutil_Assert (0, "Invalid Net format for AIG store.");
      break;
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig;
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = -1;
    nodeAuxChar(manager,baig) = 0;
  }

  bAigArrayFree(visitedNodes);
  Pdtutil_FileClose (fp, &flagFile);
  return NULL;
}

/**Function********************************************************************
  Synopsis    [Aig store. Internal recursion: phase 1]
  Description [
    Aig store. Internal recursion: phase 1.
    For format see Pdtutil_AigDump_e
    ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigNetLoadBench(
  Ddi_Mgr_t *ddm,
  char *filename                 /* IN: file name */,
  FILE *fp                       /* IN: pointer to the load file */
)
{
  Ddi_Bdd_t *f;
  Ddi_Bddarray_t *fA = Ddi_AigarrayNetLoadBench(ddm, filename, fp);
  Pdtutil_Assert(fA!=NULL,"error reading bench file");
  Pdtutil_Assert(Ddi_BddarrayNum(fA)==1,"wrong #outputs in bench file");
  f = Ddi_BddarrayExtract(fA,0);
  Ddi_Free(fA);
  return f;
}

#define searchOutputAig(node,name) {\
if ((node) == bAig_NULL) {	    \
  int ii;\
  /* look for PO */ \
  for (ii=0; ii<nRoots; ii++) {\
    if (rootNames[ii] != NULL && strcmp(name,rootNames[ii])==0) {\
      currPo = ii;\
      node = Ddi_BddToBaig(Ddi_BddarrayRead(fA,currPo));	\
      break;\
    }\
  }\
}\
}

/**Function********************************************************************
  Synopsis    [Aig store. Internal recursion: phase 1]
  Description [
    Aig store. Internal recursion: phase 1.
    For format see Pdtutil_AigDump_e
    ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayNetLoadBench(
  Ddi_Mgr_t *ddm,
  char *filename                 /* IN: file name */,
  FILE *fp                       /* IN: pointer to the load file */
)
{
  int flagFile, i, nRoots=0;
  char *name;
  bAigEdge_t baig;
  bAig_Manager_t *manager = ddm->aig.mgr;
  Ddi_Bddarray_t *fA;

  char buf [200];
  char tmpStr[100],i0Str[100],i1Str[100],oStr[100],poName[100],piName[100];
  int j, i0Int,i1Int,oInt, currPo;
  int nMax, size0;
  bAigEdge_t *aigNodes, outNode, oAig, i0Aig, i1Aig;
  char **rootNames;
  Ddi_Bdd_t *newAig;


  /* Read Back BENCH */

  fp = Pdtutil_FileOpen (NULL, filename, "r", &flagFile);
  if (fp == NULL) {
    return NULL;
  }

  for (nMax=0; fgets(buf,199,fp)!=NULL; nMax++) {
    //printf("%s",buf);
    if (strstr(buf,"OUTPUT(")!=NULL) {
      nRoots++;
    }
  }

  fA = Ddi_BddarrayAlloc(ddm,nRoots);
  rootNames = Pdtutil_Alloc(char*, nRoots);

  rewind(fp);
  aigNodes = Pdtutil_Alloc(bAigEdge_t, nMax);
  for (i=0; i<nMax; i++) aigNodes[i] = bAig_NULL;
  for (i=0; i<nRoots; i++) rootNames[i] = NULL;

  outNode = bAig_NULL;
  currPo = 0;

  while (fgets(buf,199,fp)!=NULL) {
    //    fprintf(dMgrO(ddm),"%s",buf);
    int n=strlen(buf);
    for (i=j=1; i<n; i++) {
      if (buf[i]==' ') {
	if (buf[i-1]=='(' || buf[i-1]==')') continue;
	if (buf[i+1]=='(' || buf[i+1]==')') continue;
	if (buf[i+1]==',') continue;
      }
      buf[j++]=buf[i];
    }
    buf[j]='\0';
    if (strstr(buf,"ENDBENCH")!=NULL) {
      /* END file */
      break;
    }
    if (strstr(buf,"INPUT(")!=NULL) {
      /* input */
      Ddi_Var_t *v;
      sscanf (buf, "%s", tmpStr);
      tmpStr[strlen(tmpStr)-1]='\0';
      sscanf (tmpStr, "INPUT(%s", piName);
      v = Ddi_VarFromName(ddm, piName);
      if (v == NULL) {
        v = Ddi_VarNew(ddm);
        Ddi_VarAttachName(v, piName);
      }
      if (piName[0]=='n' && isdigit(piName[1])) {
	oAig = Ddi_VarToBaig(v);
        sscanf(piName,"n%d",&oInt);
	bAig_Ref(manager, oAig);
	aigNodes[oInt] = oAig;
      }
    }
    else if (strstr(buf,"OUTPUT(")!=NULL) {
      /* output */
      sscanf (buf, "%s", tmpStr);
      tmpStr[strlen(tmpStr)-1]='\0';
      sscanf (tmpStr, "OUTPUT(%s", poName);
      Pdtutil_Assert(currPo<nRoots,"too many outputs in bench file");
      rootNames[currPo++] = Pdtutil_StrDup(poName);
    }
    else if (strstr(buf,"= vdd")!=NULL) {
      /* one */
      oInt = -1;
      sscanf (buf, "%s%*s", oStr);
      oAig = bAig_One;
      bAig_Ref(manager, oAig);
      if (oStr[0]=='n') {
        sscanf(oStr,"n%d",&oInt);
	aigNodes[oInt] = oAig;
      }
      else {
        newAig = Ddi_BddMakeFromBaig(ddm,oAig);
	for (currPo=0; strcmp(oStr,rootNames[currPo])!=0; currPo++) {
	  Pdtutil_Assert(currPo<nRoots-1,"PO name not found");
	}
	Ddi_BddarrayWrite(fA,currPo,newAig);
	bAig_RecursiveDeref(manager,oAig);
	Ddi_Free(newAig);
      }
    }
    else if (strstr(buf,"= NOT(")!=NULL) {
      /* not */
      sscanf (buf, "%s%*s%s", oStr,tmpStr);
      tmpStr[strlen(tmpStr)-1]='\0';
      sscanf (tmpStr, "NOT(%s", i0Str);
      oInt = i0Int = i1Int = -1;
      if (strcmp(i0Str, "vdd")==0) {
	i0Aig = bAig_One;
      }
      else if (strcmp(i0Str, "vcc")==0) {
	i0Aig = bAig_Zero;
      }
      else if (i0Str[0]=='n') {
        sscanf(i0Str,"n%d",&i0Int);
	i0Aig = aigNodes[i0Int];
      }
      else {
        i0Aig = bAig_VarNodeFromName(manager,i0Str);
	searchOutputAig(i0Aig,i0Str);
      }
      Pdtutil_Assert(i0Aig!=bAig_NULL,
		     "NULL Aig");
      oAig = bAig_Not(i0Aig);
      bAig_Ref(manager, oAig);
      if (oStr[0]=='n') {
        sscanf(oStr,"n%d",&oInt);
	aigNodes[oInt] = oAig;
      }
      else {
        newAig = Ddi_BddMakeFromBaig(ddm,oAig);
	for (currPo=0; strcmp(oStr,rootNames[currPo])!=0; currPo++) {
	  Pdtutil_Assert(currPo<nRoots,"PO name not found");
	}
	Ddi_BddarrayWrite(fA,currPo,newAig);
	bAig_RecursiveDeref(manager,oAig);
	Ddi_Free(newAig);
      }
    }
    else if (strstr(buf,"= BUFF(")!=NULL) {
      /* not */
      sscanf (buf, "%s%*s%s", oStr, tmpStr);
      tmpStr[strlen(tmpStr)-1]='\0';
      sscanf (tmpStr, "BUFF(%s", i0Str);
      oInt = i0Int = i1Int = -1;
      if (strcmp(i0Str, "vdd")==0) {
	i0Aig = bAig_One;
      }
      else if (strcmp(i0Str, "vcc")==0) {
	i0Aig = bAig_Zero;
      }
      else if (i0Str[0]=='n') {
        sscanf(i0Str,"n%d",&i0Int);
	i0Aig = aigNodes[i0Int];
      }
      else {
        i0Aig = bAig_VarNodeFromName(manager,i0Str);
	searchOutputAig(i0Aig,i0Str);
      }
      Pdtutil_Assert(i0Aig!=bAig_NULL,
		     "NULL Aig");
      oAig = i0Aig;
      bAig_Ref(manager, oAig);
      if (oStr[0]=='n') {
        sscanf(oStr,"n%d",&oInt);
	aigNodes[oInt] = oAig;
      }
      else {
        newAig = Ddi_BddMakeFromBaig(ddm,oAig);
	for (currPo=0; strcmp(oStr,rootNames[currPo])!=0; currPo++) {
	  Pdtutil_Assert(currPo<nRoots-1,"PO name not found");
	}
	Ddi_BddarrayWrite(fA,currPo,newAig);
	bAig_RecursiveDeref(manager,oAig);
	Ddi_Free(newAig);
      }
      Pdtutil_Assert((oInt>=0||(strcmp(oStr,rootNames[currPo])==0)),
        "invalid output in BENCH");
    }
    else if (strstr(buf,"= AND(")!=NULL) {
      /* and */
      int isIntern, k;
      sscanf (buf, "%s%*s%s%s", oStr,tmpStr,i1Str);
      tmpStr[strlen(tmpStr)-1]='\0';
      i1Str[strlen(i1Str)-1]='\0';
      sscanf (tmpStr, "AND(%s", i0Str);
      oInt = i0Int = i1Int = -1;
      isIntern = i0Str[0]=='n';
      if (isIntern) {
        for (k=1; isdigit(i0Str[k]); k++);
	isIntern = i0Str[k]=='\0';
      }
      if (isIntern) {
        sscanf(i0Str,"n%d",&i0Int);
	i0Aig = aigNodes[i0Int];
      }
      else {
        i0Aig = bAig_VarNodeFromName(manager,i0Str);
	searchOutputAig(i0Aig,i0Str);
      }

      isIntern = i1Str[0]=='n';
      if (isIntern) {
        for (k=1; isdigit(i1Str[k]); k++);
	isIntern = i1Str[k]=='\0';
      }
      if (isIntern) {
        sscanf(i1Str,"n%d",&i0Int);
	i1Aig = aigNodes[i0Int];
      }
      else {
        i1Aig = bAig_VarNodeFromName(manager,i1Str);
	searchOutputAig(i1Aig,i1Str);
      }
      Pdtutil_Assert(i0Aig!=bAig_NULL && i1Aig!=bAig_NULL,
		     "NULL Aigs");
      oAig = bAig_And(manager,i0Aig,i1Aig);
      bAig_Ref(manager, oAig);

      isIntern = oStr[0]=='n';
      if (isIntern) {
        for (k=1; isdigit(oStr[k]); k++);
	isIntern = oStr[k]=='\0';
      }
      if (isIntern) {
        sscanf(oStr,"n%d",&oInt);
	aigNodes[oInt] = oAig;
      }
      else {
        newAig = Ddi_BddMakeFromBaig(ddm,oAig);
	for (currPo=0; strcmp(oStr,rootNames[currPo])!=0; currPo++) {
	  Pdtutil_Assert(currPo<nRoots,"PO name not found");
	}
	Ddi_BddarrayWrite(fA,currPo,newAig);
	bAig_RecursiveDeref(manager,oAig);
	Ddi_Free(newAig);
      }
    }
    else if (strstr(buf,"= OR(")!=NULL) {
      /* or */
      int isIntern, k;
      sscanf (buf, "%s%*s%s%s", oStr,tmpStr,i1Str);
      tmpStr[strlen(tmpStr)-1]='\0';
      i1Str[strlen(i1Str)-1]='\0';
      sscanf (tmpStr, "OR(%s", i0Str);
      oInt = i0Int = i1Int = -1;
      isIntern = i0Str[0]=='n';
      if (isIntern) {
        for (k=1; isdigit(i0Str[k]); k++);
	isIntern = i0Str[k]=='\0';
      }
      if (isIntern) {
        sscanf(i0Str,"n%d",&i0Int);
	i0Aig = aigNodes[i0Int];
      }
      else {
        i0Aig = bAig_VarNodeFromName(manager,i0Str);
	searchOutputAig(i0Aig,i0Str);
      }

      isIntern = i1Str[0]=='n';
      if (isIntern) {
        for (k=1; isdigit(i1Str[k]); k++);
	isIntern = i1Str[k]=='\0';
      }
      if (isIntern) {
        sscanf(i1Str,"n%d",&i0Int);
	i1Aig = aigNodes[i0Int];
      }
      else {
        i1Aig = bAig_VarNodeFromName(manager,i1Str);
	searchOutputAig(i1Aig,i1Str);
      }
      Pdtutil_Assert(i0Aig!=bAig_NULL && i1Aig!=bAig_NULL,
		     "NULL Aigs");
      oAig = bAig_Or(manager,i0Aig,i1Aig);
      bAig_Ref(manager, oAig);

      isIntern = oStr[0]=='n';
      if (isIntern) {
        for (k=1; isdigit(oStr[k]); k++);
	isIntern = oStr[k]=='\0';
      }
      if (isIntern) {
        sscanf(oStr,"n%d",&oInt);
	aigNodes[oInt] = oAig;
      }
      else {
        newAig = Ddi_BddMakeFromBaig(ddm,oAig);
	for (currPo=0; strcmp(oStr,rootNames[currPo])!=0; currPo++) {
	  Pdtutil_Assert(currPo<nRoots,"PO name not found");
	}
	Ddi_BddarrayWrite(fA,currPo,newAig);
	bAig_RecursiveDeref(manager,oAig);
	Ddi_Free(newAig);
      }
    }

  }

  for (currPo=0; currPo<nRoots; currPo++) {
    if (Ddi_BddarrayRead(fA,currPo)==NULL) {
      name = rootNames[currPo];
      Pdtutil_Assert(name[0]=='n',"wrong format for po name");
      /* output not found by name. Look for id */
      sscanf(name,"n%d",&oInt);
      oAig = aigNodes[oInt];
      newAig = Ddi_BddMakeFromBaig(ddm,oAig);
      Ddi_BddarrayWrite(fA,currPo,newAig);
      Ddi_Free(newAig);
    }
    Pdtutil_Free(rootNames[currPo]);
  }
  Pdtutil_Free(rootNames);

  for (i=0; i<nMax; i++) {
    if (aigNodes[i] != bAig_NULL) {
      bAig_RecursiveDeref(manager,aigNodes[i]);
    }
  }
  Pdtutil_Free(aigNodes);

  Pdtutil_FileClose (fp, &flagFile);

  return fA;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigMakeFromBdd(
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAigEdge_t baig;

  baig = bAig_bddtobAig(ddm->aig.mgr,Ddi_MgrReadMgrCU(ddm),
			Ddi_BddToCU(f),Ddi_MgrReadVarnames(ddm),
			Ddi_MgrReadVarIdsFromCudd(ddm)
                        );
  return (Ddi_BddMakeFromBaig(ddm,baig));
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int *
Ddi_AigSatMultiple
(
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *care
)
{
  int i, nc, n = Ddi_BddarrayNum(fA);
  int *satArray = Pdtutil_Alloc(int,n);
  int *compareLit = Pdtutil_Alloc(int,n);
  FILE *fp;
  fpos_t posFile;
  int clauseN, varMax, nCompare;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  bAigEdge_t careBaig = bAig_One;

  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }

  fp = fopen ("satDiffCheck.cnf","w");
  if (fp == NULL) {
    fprintf(dMgrO(ddm),"error parsing sat result\n");
    return NULL;
  }

  fgetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", 0, 0);
  clauseN = 0;
  varMax = -1;
  aig2CnfIdInit(ddm);

  nCompare = 0;
  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
    compareLit[i] = 0;
    if (Ddi_BddIsConstant(f)) {
      satArray[i] = Ddi_BddIsOne(f);
    }
    else {
      bAigEdge_t baig = Ddi_BddToBaig(f);
      int vXor;
      int fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                              aig2CnfId(ddm->aig.mgr,baig);
      vXor = aig2CnfNewIdIntern(ddm);
      if (vXor > varMax) {
        varMax = vXor;
      }
      nCompare++;
      compareLit[i] = vXor;
      /* v=f --> (v+!f)(!v+f) */
      fprintf(fp, "%d %d 0\n", vXor, -fCnf);
      fprintf(fp, "%d %d 0\n", -vXor, fCnf);
      clauseN += 2;
      aig2CnfIntern(ddm,baig,fp,&clauseN, &varMax);
      satArray[i] = -1;
    }
  }

  if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
    int careCnf = bAig_NodeIsInverted(careBaig) ?
        -aig2CnfId(bmgr,careBaig) : aig2CnfId(bmgr,careBaig);
    fprintf(fp, "%d 0\n", careCnf);
    clauseN += 1;
    aig2CnfIntern(ddm,careBaig,fp,&clauseN, &varMax);
  }

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
    if (Ddi_BddIsConstant(f)) {
      satArray[i] = Ddi_BddIsOne(f);
    }
    else {
      bAigEdge_t baig = Ddi_BddToBaig(f);
      aig2CnfClearVisitedIntern(bmgr,baig);
    }
  }
  if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
    aig2CnfClearVisitedIntern(bmgr,careBaig);
  }

  fsetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", varMax, clauseN);
  fclose (fp);

  if (nCompare > 0) {

    fp = fopen ("satDiffCheck.chk","w");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return NULL;
    }
    fprintf(fp,"%d\n",nCompare);
    for (i=0;i<n; i++) {
      if (compareLit[i] != 0) {
        fprintf(fp,"%d\n",compareLit[i]);
        nCompare--;
      }
    }
    Pdtutil_Assert(nCompare==0,"invalid num of compare points");
    fclose(fp);
#if 1
    satDiffSolve((char *)"satDiffCheck");
#endif
#if 1
    system("rm satDiffCheck.cnf");
    system("rm satDiffCheck.chk");
#endif
    fp = fopen ("satDiffCheck.res","r");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return NULL;
    }
    fscanf(fp,"%d",&nc);

    for (i=0;i<nc; i++) {
      int diff;
      if (compareLit[i]!=0) {
        fscanf(fp,"%d",&diff);
        /* -1: sat - >0: unsat(proved) - 0: not checked */
	compareLit[i] = diff ? -1 : 1;
	satArray[i] = diff==1;
      }
    }
    fclose(fp);
    system("rm satDiffCheck.res");

    Pdtutil_Free(compareLit);

  }

  return (satArray);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int *
Ddi_AigSatMultipleMinisat
(
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *care
)
{
  int i, i0, i1, istep=1, n = Ddi_BddarrayNum(fA);
  int *satArray = Pdtutil_Alloc(int,n);
  int *compareLit = Pdtutil_Alloc(int,n);
  int nCompare;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  //bAig_Manager_t  *bmgr = ddm->aig.mgr;

  Solver      S;


  aig2CnfIdInit(ddm);


  nCompare = 0;
  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
    compareLit[i] = 0;
    if (Ddi_BddIsConstant(f)) {
      satArray[i] = Ddi_BddIsOne(f);
    }
    else {
      compareLit[i] = MinisatClauses(S,f,NULL,NULL,1);
      nCompare++;
    }
  }

  if (care != NULL && Ddi_BddIsOne(care)) {
    MinisatClauses(S,care,NULL,NULL,0);
  }

  aig2CnfIdClose(ddm);



  i0 = 0; i1=0;
  while (nCompare > 0) {
    int sat;
    vec<Lit> assumps;

    for (i=i0;i<=i1; i++) {
      if (compareLit[i] != 0) {
        assumps.push(MinisatLit(compareLit[i]));
      }
    }

    if ((sat = S.okay())) {
      sat = S.solve(assumps);
    }

    if (!sat) {
      /* all assumptions unsat */
      for (i=i0;i<=i1; i++) {
        if (compareLit[i] != 0) {
	  compareLit[i] = 0;
          satArray[i] = 0;
          nCompare--;
        }
      }
      istep *= 2;
      i0=i1+1;
      i1 +=istep;
      if (i1>n) i1=n;
      Pdtutil_Assert(i1>=i0,"Wrong i1 in Multiple sat");
      Pdtutil_Assert(i1>=i0 || nCompare==0,"Wrong i1 in Multiple sat");
    }
    else {
      int localUnsat=0;
      /* all assumptions unsat */
      for (i=i0;i<=i1; i++) {
        if (compareLit[i] != 0) {
	  int varMinisat = compareLit[i]-1;
          Pdtutil_Assert(S.model[varMinisat] != l_Undef,
            "undefined var in Minisat cex");
	  if (S.model[varMinisat]==l_True) {
  	    compareLit[i] = 0;
            satArray[i] = 1;
            nCompare --;
	  }
	  else {
	    localUnsat++;
	  }
        }
      }
      while (i0<=i1 && compareLit[i0] == 0) i0++;
      istep /= 2;
      if (istep < localUnsat) istep = localUnsat+1;
      i1 += istep-localUnsat;
      Pdtutil_Assert(i1>=i0,"Wrong i1 in Multiple sat");
      if (i1>n) i1=n;
    }

  }

  return (satArray);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSat
(
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int sat, *cex;
  if (Ddi_BddIsConstant(f)) {
    return(Ddi_BddIsOne(f));
  }
  if (strncmp(ddm->settings.aig.satSolver,"minisat",7)==0)
    return (Ddi_AigSatMinisat(f));
#if 0
  return (Ddi_AigSatBerkmin(f));
#endif
  Ddi_AigCnfStore(f,(char *)"satCheck.cnf",NULL);
  //  aig2CnfClearVisitedIntern(ddm->aig.mgr,f->data.aig->aigNode);
  cex = satSolve((char *)"satCheck", &sat, -1);
  Pdtutil_Free(cex);
  system("rm satCheck.cnf");
  return (sat);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatAnd
(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g,
  Ddi_Bdd_t *care
)
{
  int i, res;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *chk;

  if (g==NULL && care==NULL) return Ddi_AigSat(f);
  if (g==NULL) return Ddi_AigSatAnd(f,care,NULL);

  chk = Ddi_BddMakePartConjVoid(ddm);
  if (Ddi_BddIsPartConj(f)) {
    for (i=0; i<Ddi_BddPartNum(f); i++) {
      Ddi_BddPartInsertLast(chk,Ddi_BddPartRead(f,i));
    }
  }
  else {
    Ddi_BddPartInsertLast(chk,f);
  }
  if (Ddi_BddIsPartConj(g)) {
    for (i=0; i<Ddi_BddPartNum(g); i++) {
      Ddi_BddPartInsertLast(chk,Ddi_BddPartRead(g,i));
    }
  }
  else {
    Ddi_BddPartInsertLast(chk,g);
  }

  if (care != NULL) {
    if (Ddi_BddIsPartConj(care)) {
    for (i=0; i<Ddi_BddPartNum(care); i++) {
      Ddi_BddPartInsertLast(chk,Ddi_BddPartRead(care,i));
    }
    }
    else {
      Ddi_BddPartInsertLast(chk,care);
    }
  }

  res = Ddi_AigSat(chk);
  Ddi_Free(chk);

  return (res);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatAndWithAbort
(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g,
  Ddi_Bdd_t *care,
  int timeLimit
)
{
  int res;
  if (Ddi_BddIsPartConj(f)||Ddi_BddIsPartConj(g)) {
    Ddi_Bdd_t *chk = Ddi_BddDup(f);
    Ddi_BddSetPartConj(chk);
    Ddi_BddPartInsertLast(chk,g);
    if (care != NULL) Ddi_BddPartInsertLast(chk,care);
    Ddi_BddSetFlattened(chk);
    res = Ddi_AigSatWithAbort(chk,timeLimit);
    Ddi_Free(chk);
  }
  else {
    Ddi_Bdd_t *chk = Ddi_BddAnd(f,g);

    if (care != NULL) Ddi_BddAndAcc(chk,care);
    res = Ddi_AigSatWithAbort(chk,timeLimit);
    Ddi_Free(chk);
  }

  return (res);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatAndWithCexAndAbort
(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g,
  Ddi_Bdd_t *care,
  Ddi_Vararray_t *filterVars,
  int timeLimit,
  int *aboP
)
{
  Ddi_Bdd_t *res;
  Ddi_Bdd_t *chk = (g!=NULL)?Ddi_BddAnd(f,g):Ddi_BddDup(f);
  int abo;

  if (aboP==NULL) aboP = &abo;
  if (care != NULL) Ddi_BddAndAcc(chk,care);
  res = Ddi_AigSatWithCexAndAbort(chk,filterVars,timeLimit,aboP);
  Ddi_Free(chk);

  return (res);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatConstrain
(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *constr,
  int timeLimit,
  int *aboP
)
{
  int sat, minSize=2, maxSize=16;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *implAig = NULL;
  Solver      S;
  int constrEnableVar;
  int maxfVar = -1;
  vec<Lit> assumps;

  if (Ddi_BddIsZero(f)) {
    return (0);
  }
  if (Ddi_BddIsOne(f)) {
    return (1);
  }
  
  aig2CnfIdInit(ddm);
  //  MinisatClauses(S,f,constr,NULL,0);

  MinisatClausesWithSuppFlow(NULL,S,NULL,f,NULL,NULL,NULL,NULL,NULL,0,0,0,0);
  maxfVar = S.nVars()-1;
  MinisatClausesWithSuppFlow(NULL,S,NULL,constr,NULL,NULL,NULL,NULL,NULL,1,0,0,0);
  Pdtutil_Assert(Ddi_BddIsAig(constr),"Aig constr needed");
  bAigEdge_t baig = Ddi_BddToBaig(constr);
  int vCnf = aig2CnfIdSigned(bmgr,baig);
  assumps.push(MinisatLit(vCnf));
  constrEnableVar = var(assumps[0]);
    
  if (aboP) *aboP = 0;

  if (!S.okay()) {
    sat = 0;
  }
  else {
    sat = S.solve(assumps,(double)timeLimit);
    sat = S.okay();
  }
  if (S.undefined()) {
    sat = -1;
    if (aboP) *aboP = 1;
  }

  int tryAnd=0;
  if (sat>0 && tryAnd) {
    aig2CnfIdClose(ddm);
    Ddi_BddAndAcc(f,constr);
  }
  else if (sat>0) {
    int i, k;
    int cnt=0;
    implAig = Ddi_BddMakeConstAig(ddm,1);
    Ddi_BddSetPartConj(implAig);

    // assert NON constr (filter out constr dependent learning
    assumps[0] = ~assumps[0];
    S.addClause(assumps);

    for (k=minSize; k<=maxSize; k++) {
      cnt = S.countImplLearnts(k);
      if (cnt>0) {
        printf("found %d implications of size <= %d\n", cnt, k);
      }
    }
    cnt=0;
    for (i=0; i<S.nLearnts(); i++) {
      Clause *cl = S.readLearnt(i);
      if (cl->size()>=minSize && cl->size()<=maxSize) {
        // printf("found learnt[%d] - size: %d\n", i, cl->size());
        int j, active = 1;
        Ddi_Bdd_t *clAig = Ddi_BddMakeConstAig(ddm,0); 
        for (j=0; j<cl->size(); j++) {
          int vSat = var((*cl)[j]);
          //          if (vSat == constrEnableVar) {
          if (vSat > maxfVar) {
            active = 0; break;
          }
          int signSat = sign((*cl)[j]);
          int vCnf = vSat+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          Ddi_Bdd_t *l = Ddi_BddMakeFromBaig(ddm,baig);
          if (signSat) Ddi_BddNotAcc(l);
          Ddi_BddOrAcc(clAig,l); 
          Ddi_Free(l);
        }
        if (active) {
          Ddi_BddPartInsertLast(implAig,clAig);
          cnt++;
        }
        Ddi_Free(clAig);
      }
    }
    aig2CnfIdClose(ddm);
    if (cnt>0) {
      int chkSat = 0;
      int size0 = Ddi_BddSize(f);
      if (chkSat) {
        Ddi_Bdd_t *chk = Ddi_BddAnd(f,constr);
        Pdtutil_Assert(Ddi_BddIncluded(chk,implAig),"wrong impl");
        Ddi_Free(chk);
      }
      Ddi_BddPartInsertLast(implAig,f);
      Ddi_DataCopy(f,implAig);
      //      Ddi_BddSetAig(implAig);
      //      Ddi_BddAndAcc(f,implAig);
      Ddi_AigStructRedRemAcc (f,NULL);
      ddiAbcOptAcc (f,-1.0);
      printf("found %d impl. of size <= %d - size %d -> %d\n",
             cnt, maxSize, size0, Ddi_BddSize(f));
    }

  }
  else {
    aig2CnfIdClose(ddm);
  }
  Ddi_Free(implAig);

  
  return (sat);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatWithCex
(
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *cexAig = NULL;
  int sat, *cex;

  if (Ddi_BddIsZero(f)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(f)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }
  if (strcmp(ddm->settings.aig.satSolver,"minisat")==0)
    return (Ddi_AigSatMinisatWithCex(f));
#if 0
  return (Ddi_AigSatBerkmin(f));
#endif
  Ddi_AigCnfStore(f,(char *)"satCheck.cnf",NULL);
  cex = satSolve((char *)"satCheck", &sat, -1);
  if (sat)
  {
    int i;
    cexAig = Ddi_BddMakeConstAig(ddm,1);
    for (i=0; cex[i]!=0; i++) {
      int vCnf = abs(cex[i]);
      bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
      if (bAig_isVarNode(bmgr,baig)) {
        Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
        if (cex[i] < 0) {
	  Ddi_BddNotAcc(lit);
        }
	Ddi_BddAndAcc(cexAig,lit);
	Ddi_Free(lit);
      }
    }
  }
  Pdtutil_Free(cex);
  aig2CnfClearVisitedIntern(ddm->aig.mgr,f->data.aig->aigNode);
  system("rm satCheck.cnf");
  return (cexAig);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatWithCexAndAbort
(
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *filterVars,
  float timeLimit,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *cexAig = NULL;
  int sat, *cex;

  if (Ddi_BddIsZero(f)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(f)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }
  if (strcmp(ddm->settings.aig.satSolver,"minisat")==0) {
#if 0
    return (Ddi_AigSatMinisatWithCexAndAbort(f,filterVars,timeLimit,
                                             NULL,pAbort));
#else 
    return (Ddi_AigSatMinisat22WithCexAndAbortIncremental(NULL,f,
					      filterVars,0,timeLimit,pAbort));
#endif
  }
  Ddi_AigCnfStore(f,(char *)"satCheck.cnf",NULL);
  cex = satSolve((char *)"satCheck", &sat, -1);
  if (sat)
  {
    int i;
    cexAig = Ddi_BddMakeConstAig(ddm,1);
    for (i=0; cex[i]!=0; i++) {
      int vCnf = abs(cex[i]);
      bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
      if (bAig_isVarNode(bmgr,baig)) {
        Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
        if (cex[i] < 0) {
	  Ddi_BddNotAcc(lit);
        }
	Ddi_BddAndAcc(cexAig,lit);
	Ddi_Free(lit);
      }
    }
  }
  Pdtutil_Free(cex);
  aig2CnfClearVisitedIntern(ddm->aig.mgr,f->data.aig->aigNode);
  system("rm satCheck.cnf");
  return (cexAig);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatBerkmin
(
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int sat, *cex;
  if (Ddi_BddIsConstant(f)) {
    return(Ddi_BddIsOne(f));
  }
  Ddi_AigCnfStore(f,(char *)"satCheck.cnf",NULL);
  aig2CnfClearVisitedIntern(ddm->aig.mgr,f->data.aig->aigNode);
  cex = satSolveBerkmin((char *)"satCheck", &sat, -1);
  Pdtutil_Free(cex);
  system("rm satCheck.cnf");
  return sat;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatMinisat
(
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int sat;
  Solver      S;

  if (Ddi_BddIsConstant(f)) {
    return(Ddi_BddIsOne(f));
  }

  aig2CnfIdInit(ddm);
  MinisatClauses(S,f,NULL,NULL,0);
  aig2CnfIdClose(ddm);

  if (!S.okay()) {
    return 0;
  }

  //<marco> 06/02/2013
  //Inizializzare flag clausole binarie here
  //</marco>

  sat = S.solve();

#if CHECK_AIGCNF_LEVEL
  //  sat = S.okay();
  if (ddm->settings.aig.aigCnfLevel > 0) {
    int sat1;
    int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
    ddm->settings.aig.aigCnfLevel = 0;
    sat1 = Ddi_AigSatMinisat(f);
    ddm->settings.aig.aigCnfLevel = aigCnfLevel;
    Pdtutil_Assert(sat==sat1,"error in sat with aigcnflevel");
  }
#endif

  return sat;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatMinisatWithAbort
(
  Ddi_Bdd_t *f,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int sat;
  Solver S;

  if (Ddi_BddIsConstant(f)) {
    return(Ddi_BddIsOne(f));
  }

  aig2CnfIdInit(ddm);
  MinisatClauses(S,f,NULL,NULL,0);

  if (!S.okay()) {
    aig2CnfIdClose(ddm);
    return 0;
  }

  sat = S.solve((double)timeLimit);
  if (S.undefined()) {
    sat = -1;
  }

  aig2CnfIdClose(ddm);

#if CHECK_AIGCNF_LEVEL
  if (ddm->settings.aig.aigCnfLevel > 0) {
    int sat1;
    int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
    ddm->settings.aig.aigCnfLevel = 0;
    sat1 = Ddi_AigSatMinisat(f);
    ddm->settings.aig.aigCnfLevel = aigCnfLevel;
    Pdtutil_Assert(sat==sat1,"error in sat with aigcnflevel");
  }
#endif

  return sat;
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatWindow
(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  Ddi_Bdd_t *pivotCube,
  Ddi_Varset_t *vars,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *fc = Ddi_BddDup(f);
  Ddi_Bdd_t *cex, *fAig, *cAig;
  Ddi_Bdd_t *wPart, *w;
  int k, sat, maxIter = 20;

  if (care!=NULL) {
    Ddi_BddSetPartConj(fc);
    Ddi_BddPartInsertLast(fc,care);
  }

  if (pivotCube!=NULL) {
    cex = Ddi_BddDup(pivotCube);
  }
  else {
    Ddi_Bdd_t *fAig = Ddi_BddMakeAig(fc);
    Ddi_BddNotAcc(fAig);
    cex = Ddi_AigSatMinisatWithCex(fAig);
    Ddi_Free(fAig);
  }

  if (cex==NULL) {
    Ddi_Free(fc);
    return NULL;
  }

  for (k=sat=0; k<maxIter && !sat; k++) {
    Ddi_Bdd_t *myCex = Ddi_BddDup(cex);
    Ddi_Bdd_t *fAig = Ddi_BddMakeAig(fc);
    sat = Ddi_AigSatMinisatWithAbortAndFinal(fAig,myCex,timeLimit,0);
    if (!sat) {
      Ddi_Varset_t *sm = Ddi_BddSupp(myCex);
      if (Ddi_VarsetNum(sm)>4) {
	k=maxIter;
	Ddi_DataCopy(cex,myCex);
      }
      else {
	Ddi_BddExistAcc(cex,sm);
	Ddi_BddNotAcc(myCex);
	Ddi_BddSetMono(myCex);
	Ddi_BddConstrainAcc(fc,myCex);
      }
    }
    Ddi_Free(myCex);
  }
  Ddi_Free(fc);

  Pdtutil_Assert (!sat,"unsat needed");

  wPart = Ddi_AigPartitionTop(cex,0);
  Ddi_Free(cex);
  w=NULL;
  if (vars!=NULL) {
    for (k=Ddi_BddPartNum(wPart)-1; k>=0; k--) {
      Ddi_Bdd_t *w_i = Ddi_BddPartRead(wPart,k);
      Ddi_Var_t *v_i = Ddi_BddTopVar(w_i);
      if (!Ddi_VarInVarset(vars,v_i)) Ddi_BddPartRemove(wPart,k);
    }
  }
  fAig = Ddi_BddMakeAig(f);
  cAig = care!=NULL ? Ddi_BddMakeAig(care):NULL;
  for (k=Ddi_BddPartNum(wPart)-1; k>=0; k--) {
    Ddi_Bdd_t *myPart = NULL;
    Ddi_BddPartRemove(wPart,k);
    myPart = Ddi_BddPartNum(wPart)>0 ? Ddi_BddDup(wPart) :
      Ddi_BddMakeConstAig(ddm, 1);
    cex = Ddi_AigSatAndWithCexAndAbort(myPart,fAig,cAig,NULL,-1,NULL);
    Ddi_Free(myPart);
    if (cex!=NULL) {
      w = Ddi_BddMakeAig(wPart);
      break;
    }
  }
  if (Ddi_BddPartNum(wPart)==0) {
    w = Ddi_BddMakeConstAig(ddm, 1);
  }
  Ddi_Free(wPart);
  Pdtutil_Assert(w!=NULL,"error finding window");
  if (cex!=NULL) {
    Ddi_DataCopy(pivotCube,cex);
  }
  else {
    Ddi_Free(w);
  }

  return w;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatMinisatWithAbortAndFinal
(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *constrCube,
  float timeLimit,
  int split
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat, constrCubeNum = 0, isCube=1;
  Solver S;
  vec<Lit> assumps;

  if (Ddi_BddIsConstant(f)) {
    return(Ddi_BddIsOne(f));
  }

  isCube = Ddi_BddIsCube(constrCube);

  if (split>0) {
    Ddi_Bdd_t *cubePart = Ddi_AigPartitionTop(constrCube,0);
    Ddi_Bdd_t *res = Ddi_BddMakeConstAig(ddm, 1);
    int i, jj, size = Ddi_BddPartNum(cubePart)/split+1;
    while (split>Ddi_BddPartNum(cubePart)) {
      size/=2;
    }
    for (jj=sat=0; jj<split&&!sat; jj++) {
      Ddi_Bdd_t *myCube = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_Bdd_t *myConstr = Ddi_BddDup(res);
      Ddi_Bdd_t *myF = Ddi_BddDup(f);
      for (i=0; i<Ddi_BddPartNum(cubePart); i++) {
	Ddi_Bdd_t *p = Ddi_BddPartRead(cubePart,i);
	if (i%split == jj) {
	  Ddi_BddAndAcc(myCube,p);
	}
	else if (i%split > jj) {
	  Ddi_BddAndAcc(myConstr,p);
	}
      }
      if (isCube)
	Ddi_AigConstrainCubeAcc(myF,myConstr);
      else 
	Ddi_AigConstrain(myF,myConstr,1);
      sat = Ddi_AigSatMinisatWithAbortAndFinal(myF,myCube,timeLimit,0);
      if (sat==0) {
	Ddi_BddAndAcc(res,myCube);
      }
      Ddi_Free(myF);
      Ddi_Free(myConstr);
      Ddi_Free(myCube);
    }
    if (!sat) {
      Ddi_DataCopy(constrCube,res);
    }
    Ddi_Free(res);
    return sat;
  }

  aig2CnfIdInit(ddm);
  MinisatClauses(S,f,NULL,NULL,0);

  assumps.clear();

  if (constrCube != NULL) {
    isCube = Ddi_BddIsCube(constrCube);
    Ddi_Bdd_t *constrPart = Ddi_AigPartitionTop(constrCube,0);
    int j;
    constrCubeNum = Ddi_BddPartNum(constrPart);
    if (!isCube) {
      MinisatClauses(S,constrPart,NULL,NULL,1);
    }
    for (j=0; j<Ddi_BddPartNum(constrPart); j++) {
      Ddi_Bdd_t *c_j = Ddi_BddPartRead(constrPart,j);
      bAigEdge_t baig = Ddi_BddToBaig(c_j);
      int cCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(bmgr,baig) :
	aig2CnfId(bmgr,baig);
      while (abs(cCnf) > S.nVars()) S.newVar();
      assumps.push(MinisatLit(cCnf));
    }
    Ddi_Free(constrPart);
  }
  if (!S.okay()) {
    aig2CnfIdClose(ddm);
    return 0;
  }

  sat = S.solve(assumps,(double)timeLimit);
  if (S.undefined()) {
    sat = -1;
  }
  else if (!sat && (constrCube != NULL) && isCube) {
    Ddi_Bdd_t *constrFinal = Ddi_BddMakeConstAig(ddm, 1);
    int k;

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMax_c) {
      printf("solver final selected %d/%d vars\n", S.conflict.size(),
	   constrCubeNum);
    }
    int doGen = 1;
    vec<Lit> conflict;
    vec<Lit> conflict2;
    vec<Lit> assumps2;
    vec<Lit> assumps3;
    for (k=0; k<S.conflict.size(); k++) {
      Lit kLit = S.conflict[k];
      conflict.push(kLit);
      assumps2.push(~kLit);
    }
    assert(!S.solve(assumps2,(double)timeLimit));
    for (k=0; k<conflict.size(); k++) {
      Ddi_Bdd_t *lit;
      Lit kLit = conflict[k];
      int vSat = var(kLit);
      int signSat = sign(kLit);
      int vCnf = vSat+1;
      bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];

      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      int useLit = 1;
      if (doGen) {
        assumps2.clear();
        conflict[k] = lit_Undef;
        for (int k1=0; k1<conflict.size(); k1++) {
          if (conflict[k1] != lit_Undef) {
            assumps2.push(~conflict[k1]);              
          }
        }
        int sat2 = S.solve(assumps2,(double)20);
        if (S.undefined() || sat2) {
          // undo remove lit
          conflict[k] = kLit;
          conflict2.push(kLit);
          assumps3.push(~kLit);
        }
        else {
          useLit = 0;
        }
      }
      if (useLit) {
        if (v!=NULL) {
          /* conflict has complemented literals w.r.t. assump !!! */
          lit = Ddi_BddMakeLiteralAig(v,signSat);
          Ddi_BddAndAcc(constrFinal,lit);
          Ddi_Free(lit);
        }
        else {
          Ddi_Bdd_t *e = Ddi_BddMakeFromBaig(ddm,baig);
          Ddi_BddAndAcc(constrFinal,e);
          Ddi_Free(e);
        }
      }
    }
    Ddi_DataCopy(constrCube,constrFinal);
    Ddi_Free(constrFinal);
  }

  aig2CnfIdClose(ddm);

  return sat;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatMinisatWithCex
(
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat;
  Ddi_Bdd_t *cexAig = NULL;
  Solver      S;

  if (Ddi_BddIsZero(f)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(f)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  aig2CnfIdInit(ddm);
  MinisatClauses(S,f,NULL,NULL,0);

  if (!S.okay()) {
    cexAig = NULL;
    sat = 0;
  }
  else {
    S.solve();
    sat = S.okay();
  }

  if (sat)
  {
    int i;
    cexAig = Ddi_BddMakeConstAig(ddm,1);

    for (i=0; i<S.nVars(); i++) {
      if (S.model[i] != l_Undef) {
        int vCnf = i+1;
        bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
        if (bAig_isVarNode(bmgr,baig)) {
          Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
          Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
          if (S.model[i]!=l_True) {
	    Ddi_BddNotAcc(lit);
          }
  	  Ddi_BddAndAcc(cexAig,lit);
	  Ddi_Free(lit);
        }
      }
    }
  }

  aig2CnfIdClose(ddm);
  return (cexAig);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatMinisatWithCexAndAbort
(
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *filterVars,
  float timeLimit,
  char *dumpFilename,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat;
  Ddi_Bdd_t *cexAig = NULL;
  Solver      S;

  if (Ddi_BddIsZero(f)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(f)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  aig2CnfIdInit(ddm);
  MinisatClauses(S,f,NULL,NULL,0);

  if (dumpFilename!=NULL) {
    S.dump(dumpFilename);
  }

  if (pAbort) *pAbort = 0;

  if (!S.okay()) {
    cexAig = NULL;
    sat = 0;
  }
  else {
    //printf("solving CNF instance: v: %d, c: %d\n", S.nVars(), S.nClauses());
    sat = S.solve((double)timeLimit);
    sat = S.okay();
  }
  if (S.undefined()) {
    sat = -1;
    if (pAbort) *pAbort = 1;
  }

  if (sat>0)
  {
    int i;
    cexAig = Ddi_BddMakeConstAig(ddm,1);

    if (filterVars!=NULL) {
      for (i=0; i<Ddi_VararrayNum(filterVars); i++) {
	Ddi_Var_t *v_i = Ddi_VararrayRead(filterVars,i);
	bAigEdge_t varIndex = Ddi_VarToBaig(v_i);
	int vCnf = aig2CnfId(bmgr,varIndex);
	int id = vCnf-1;
	if (S.model[id] != l_Undef) {
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v_i,1);
	  if (S.model[id]!=l_True) {
	    Ddi_BddNotAcc(lit);
	  }
	  Ddi_BddAndAcc(cexAig,lit);
	  Ddi_Free(lit);
	}
      }
    }
    else {
      for (i=0; i<S.nVars(); i++) {
	if (S.model[i] != l_Undef) {
	  int vCnf = i+1;
	  bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	  if (bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
	    Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	    Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
	    if (S.model[i]!=l_True) {
	      Ddi_BddNotAcc(lit);
	    }
	    Ddi_BddAndAcc(cexAig,lit);
	    Ddi_Free(lit);
	  }
	}
      }
    }
  }

  aig2CnfIdClose(ddm);
  return (cexAig);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigIncrSatMinisatWithCexAndAbort
(
  Ddi_Bdd_t *f,
  Ddi_SatSolver_t *incrSat,
  float timeLimit,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat;
  Ddi_Bdd_t *cexAig = NULL;
  Solver      S;

  if (Ddi_BddIsZero(f)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(f)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  aig2CnfIdInit(ddm);
  MinisatClauses(S,f,NULL,NULL,0);

  if (pAbort) *pAbort = 0;

  if (!S.okay()) {
    cexAig = NULL;
    sat = 0;
  }
  else {
    sat = S.solve((double)timeLimit);
    //    sat = S.okay();
  }
  if (S.undefined()) {
    sat = -1;
    if (pAbort) *pAbort = 1;
  }

  if (sat>0)
  {
    int i;
    cexAig = Ddi_BddMakeConstAig(ddm,1);

    for (i=0; i<S.nVars(); i++) {
      if (S.model[i] != l_Undef) {
        int vCnf = i+1;
        bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
        if (bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
          Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
          Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
          if (S.model[i]!=l_True) {
	    Ddi_BddNotAcc(lit);
          }
  	  Ddi_BddAndAcc(cexAig,lit);
	  Ddi_Free(lit);
        }
      }
    }
  }

  aig2CnfIdClose(ddm);
  return (cexAig);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatCircuit
(
  Ddi_Bdd_t *f
)
{
  int sat, *cex;
  if (Ddi_BddIsConstant(f)) {
    return(Ddi_BddIsOne(f));
  }
  Ddi_AigNetStore (f, (char *)"satCheck.bench", NULL, Pdtutil_Aig2BenchName_c);
  cex = satSolveCircuit ((char *)"satCheck", &sat, -1);
  Pdtutil_Free(cex);
  system("rm satCheck.bench");
  return sat;
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatWithAbort
(
  Ddi_Bdd_t *f,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int sat, *cex;
  if (Ddi_BddIsConstant(f)) {
    return(Ddi_BddIsOne(f));
  }

  if (strcmp(ddm->settings.aig.satSolver,"minisat")==0)
    return (Ddi_AigSatMinisatWithAbort(f,timeLimit));

  Ddi_AigCnfStore(f,(char *)"satCheck.cnf",NULL);
  //  aig2CnfClearVisitedIntern(ddm->aig.mgr,f->data.aig->aigNode);
  cex = satSolve((char *)"satCheck", &sat, timeLimit);
  Pdtutil_Free(cex);
  system("rm satCheck.cnf");
  return sat;
}



/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatCircuitWithAbort
(
  Ddi_Bdd_t *f,
  int timeLimit
)
{
  int sat, *cex;
  if (Ddi_BddIsConstant(f)) {
    return(Ddi_BddIsOne(f));
  }
  Ddi_AigNetStore (f, (char *)"satCheck.bench", NULL, Pdtutil_Aig2BenchName_c);
  cex = satSolveCircuit((char *)"satCheck", &sat, timeLimit);
  Pdtutil_Free(cex);
  system("rm satCheck.bench");
  return sat;
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatBerkminWithAbort
(
  Ddi_Bdd_t *f,
  int timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int sat, *cex;
  if (Ddi_BddIsConstant(f)) {
    return(Ddi_BddIsOne(f));
  }
  Ddi_AigCnfStore(f,(char *)"satCheck.cnf",NULL);
  aig2CnfClearVisitedIntern(ddm->aig.mgr,f->data.aig->aigNode);
  cex = satSolveBerkmin((char *)"satCheck", &sat, timeLimit);
  Pdtutil_Free(cex);
  system("rm satCheck.cnf");
  return sat;
}


/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigDiffOptByBdd(
  Ddi_Bdd_t *f,
  Ddi_Var_t *v
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *f1, *f0;
  Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm,0);
  int again;
  bAigEdge_t nodeIndex;

#if 0
  Ddi_Bdd_t *tmpF1, *tmpF0 = Ddi_BddMakeMono(f);
#endif

  nodeIndex = Ddi_BddToBaig(f);

  f1 = aig2BddDiffInternWithCuts(ddm,nodeIndex,-1,auxV,auxF);
  Pdtutil_Assert (f1!=NULL, "NULL OPT BDD");
  Ddi_BddSetAig(f1);

#if 1
  do {
    f0 = f1;
    f1 = Ddi_BddCompose(f0,auxV,auxF);
    again = !Ddi_BddEqual(f0,f1);
    Ddi_Free(f0);
  } while (again);
#if 0
  {
    Ddi_Bdd_t *f_0, *f_1;
  tmpF1 = Ddi_BddMakeMono(f1);
  f_0 = Ddi_BddCofactor(tmpF0,v,0);
  f_1 = Ddi_BddCofactor(tmpF0,v,1);
  Ddi_Free(tmpF0);
  tmpF0=Ddi_BddOr(f_0,f_1);
  Ddi_Free(f_0);
  Ddi_Free(f_1);
  Pdtutil_Assert(Ddi_BddEqual(tmpF0,tmpF1),"Mismatching BDDs");
  Ddi_Free(tmpF1);
  Ddi_Free(tmpF0);
  }
#endif
#endif

  Ddi_Free(auxF);
  Ddi_Free(auxV);

  if (1&&Ddi_BddSize(f) > Ddi_BddSize(f1)) {
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"AIGBDDOPT: %d -> %d\n",
      Ddi_BddSize(f), Ddi_BddSize(f1)));
    return(f1);
  }
  else {
    Ddi_Free(f1);
    return (NULL);
  }

}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigDomainStats(
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  bAigEdge_t fBaig = Ddi_BddToBaig(f);
  int *doms;

  postOrderAigVisitIntern(bmgr, fBaig, visitedNodes, -1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);

  doms = Pdtutil_Alloc(int, visitedNodes->num);

  dom_stats(bmgr, visitedNodes, doms, NULL, 2);

  bAigArrayFree(visitedNodes);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByInterpolantAcc(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *fPlus,
  Ddi_Bdd_t *care
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Varset_t *s, *common;
  int sat, itpOpt, ret = 0;
  Ddi_Bdd_t *newF;

  Ddi_Bdd_t *A,*B;
  if (Ddi_BddEqual(f,fPlus)) return 0;
  
  A=Ddi_BddDup(f);
  B=Ddi_BddNot(fPlus);
  if (care != NULL) {
    Ddi_BddAndAcc(A,care);
    Ddi_BddAndAcc(B,care);
  }

  s = Ddi_BddSupp(A);
  common = Ddi_BddSupp(B);
  Ddi_VarsetIntersectAcc(common,s);
  Ddi_Free(s);

  
  itpOpt = ddm->settings.aig.itpOpt;
  ddm->settings.aig.itpOpt = 0;
  newF = Ddi_AigSatAndWithInterpolant(A,B,common,NULL,NULL,NULL,
				      NULL,NULL,&sat,0,0,-1.0);
  ddm->settings.aig.itpOpt = itpOpt;
  Pdtutil_Assert(!sat,"invalid overapprox in interpolant OPT");

  {
    int rrl = Ddi_MgrReadAigRedRemLevel(ddm);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,1);
    DdiAigRedRemovalAcc (newF,care,-1,-1.0);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl);
  }

  Pdtutil_Assert(!sat,"Invalid sat in interpolant opt");
  fprintf(dMgrO(ddm),"INTERPOLANT OPT: %d -> %d\n",Ddi_BddSize(f), Ddi_BddSize(newF));
  if (Ddi_BddSize(newF) < Ddi_BddSize(f)) {
    DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)newF);
    fprintf(dMgrO(ddm),"OPT OK!\n");
    ret = 1;
  }
  Ddi_Free(A);
  Ddi_Free(B);
  Ddi_Free(common);
  Ddi_Free(newF);
  return ret;
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByBdd(
  Ddi_Bdd_t *f,
  float timeLimit,
  int sizeLimit
)
{
  return Ddi_AigOptByBddWithCare(f,NULL,timeLimit,sizeLimit);
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigOptByBddWithCare(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  float timeLimit,
  int sizeLimit
)
{
  int i, size0, size1, th=5000;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int abcOpt=Ddi_MgrReadAigAbcOptLevel(ddm);
  float startTime = util_cpu_time();
  Ddi_Varset_t *supp=Ddi_BddSupp(f);
  int suppNum = Ddi_VarsetNum(supp);
  Ddi_Vararray_t *aigVars=NULL, *bddVars=NULL, *suppVars=NULL;
  Ddi_Bddarray_t *bddLits=NULL, *aigLits=NULL;

  //  if (suppNum <= 80) th*=4;
  if (suppNum <= 50) th*=5;

  size0 = Ddi_BddSize(f);

  if (size0 > 30000) th=th*5;
  else if (size0 > 10000) th=th*3;

  if (size0 > 50000 && ddm->settings.aig.enBddFoConOpt) {
    ddm->settings.aig.enBddFoConOpt = 0;
    Ddi_AigOptByFoCntTop(f, NULL, 1);
    ddm->settings.aig.enBddFoConOpt = 1;
  }
  else if (size0 > 2000000) {
    Ddi_Free(supp);
    return -1;
  }

  suppVars = Ddi_VararrayMakeFromVarset(supp,1);
  aigVars = Ddi_VararrayAlloc(ddm,0);
  bddVars = Ddi_VararrayAlloc(ddm,0);
  Ddi_Free(supp);
  for (i=0; i<Ddi_VararrayNum(suppVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(suppVars,i);
    if (Ddi_VarIsAig(v)) {
      Ddi_Var_t *vBdd;
      char name[100];
      sprintf(name,"_AUXV_BDD_%d", Ddi_VararrayNum(aigVars));
      vBdd = Ddi_VarFromName(ddm,name);
      if (vBdd == NULL) {
	vBdd = Ddi_VarNew(ddm);
	Ddi_VarAttachName (vBdd, name);
      }
      Ddi_VararrayInsertLast(aigVars,v);
      Ddi_VararrayInsertLast(bddVars,vBdd);
    }
  }

  Ddi_Free(suppVars);

  if (Ddi_VararrayNum(aigVars)>0) {
    aigLits = Ddi_BddarrayMakeLiteralsAig(aigVars, 1);
    bddLits = Ddi_BddarrayMakeLiteralsAig(bddVars, 1);
    Ddi_BddComposeAcc(f,aigVars,bddLits);
  }

#if 1
  do {
    //int nm3=n_merge_3, nm2=n_merge_2;
    size0 = Ddi_BddSize(f);
    size1 = AigOptByBddWithThresh(f,care,th,timeLimit,sizeLimit);
    if (size1<0) break; /* abort */
    th = th*2;
    //printf("NM: %d(%d)\n", n_merge_3-nm3, n_merge_2-nm2);
    if (abcOpt && size1>5000 /* && size1<100000 */) {
      ddiAbcOptAcc (f,timeLimit/5);
      size1 = Ddi_BddSize(f);
    }
    if (timeLimit >= 0 &&
        (util_cpu_time () - startTime) > timeLimit*1000) break;

  } while (size1 < (size0*90)/100 && th < 5000);
#else
  size1 = AigOptByBddWithThresh(f,care,-1,timeLimit,sizeLimit);
#endif

  if (Ddi_VararrayNum(aigVars)>0) {
    Ddi_BddComposeAcc(f,bddVars,aigLits);
  }
  Ddi_Free(aigVars);
  Ddi_Free(bddVars);
  Ddi_Free(aigLits);
  Ddi_Free(bddLits);

  return size1;
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayOptByBdd(
  Ddi_Bddarray_t *fA,
  Ddi_Bddarray_t *auxF,
  Ddi_Vararray_t *auxV,
  int th,
  int makeBddVars,
  float timeLimit,
  int sizeLimit
)
{
  int i;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_array_t *nodeRoots;
  Ddi_Bddarray_t *bddRoots;
  int abort=0;
  Ddi_Bddarray_t *auxLits = NULL;
  Ddi_Vararray_t *aigVars=NULL, *bddVars=NULL, *suppVars=NULL;
  Ddi_Bddarray_t *bddLits=NULL, *aigLits=NULL;
  Ddi_Varset_t *supp=NULL;

  if (th >= 0 && Ddi_BddarraySize(fA) > 100000) return (NULL);

  supp=Ddi_BddarraySupp(fA);
  suppVars = Ddi_VararrayMakeFromVarset(supp,1);
  aigVars = Ddi_VararrayAlloc(ddm,0);
  bddVars = Ddi_VararrayAlloc(ddm,0);
  Ddi_Free(supp);
  for (i=0; i<Ddi_VararrayNum(suppVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(suppVars,i);
    if (Ddi_VarIsAig(v)) {
      Ddi_Var_t *vBdd;
      char name[100];
      sprintf(name,"_AUXV_BDD_%d", Ddi_VararrayNum(aigVars));
      vBdd = Ddi_VarFromName(ddm,name);
      if (vBdd == NULL) {
	vBdd = Ddi_VarNew(ddm);
	Ddi_VarAttachName (vBdd, name);
      }
      Ddi_VararrayInsertLast(aigVars,v);
      Ddi_VararrayInsertLast(bddVars,vBdd);
    }
  }

  if (Ddi_VararrayNum(aigVars)>0) {
    aigLits = Ddi_BddarrayMakeLiteralsAig(aigVars, 1);
    bddLits = Ddi_BddarrayMakeLiteralsAig(bddVars, 1);
    Ddi_AigarrayComposeAcc(fA,aigVars,bddLits);
  }

  nodeRoots = bAigArrayAlloc();

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    bAigEdge_t nodeIndex = Ddi_BddToBaig(Ddi_BddarrayRead(fA,i));
    bAigArrayWriteLast(nodeRoots,nodeIndex);
  }

  auxLits = Ddi_BddarrayAlloc(ddm,0);

  bddRoots = aigarray2BddInternWithCuts(ddm,nodeRoots,th,
    auxV,auxF,auxLits,NULL,/*enPartial*/0,timeLimit,sizeLimit,0);

  if (bddRoots==NULL) {
    abort = 1;
  }
  else {
    for (i=0; i<Ddi_BddarrayNum(bddRoots); i++) {
      if (Ddi_BddarrayRead(bddRoots,i)==NULL) {
	abort = 1;
      }
    }
  }
  bAigArrayFree(nodeRoots);
  Ddi_Free(auxLits);

  if (abort) Ddi_Free(bddRoots);
  else {
    if (Ddi_VararrayNum(aigVars)>0) {
      int i;
      for (i=0; i<Ddi_BddarrayNum(bddRoots); i++) {
	Ddi_BddSetAig(Ddi_BddarrayRead(bddRoots,i));
      }
      if (!makeBddVars)
        Ddi_AigarrayComposeAcc(bddRoots,bddVars,aigLits);
    }
  }

  if (Ddi_VararrayNum(aigVars)>0) {
    Ddi_AigarrayComposeAcc(fA,bddVars,aigLits);
  }

  Ddi_Free(suppVars);
  Ddi_Free(aigVars);
  Ddi_Free(bddVars);
  Ddi_Free(aigLits);
  Ddi_Free(bddLits);

  return (bddRoots);

}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigOptByBddRelation(
  Ddi_Bdd_t *f,
  int th,
  int nFactors,
  Ddi_Varset_t *projectVars,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *f1, *f1Cuts;
  Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Bddarray_t *auxLits = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Varset_t *smoothVars = NULL;
  Ddi_Bddarray_t *newFactors, *factors;

  int checkResult = 0, size, size0, i, selectTh = th/2, icut;
  bAigEdge_t nodeIndex;
  int period, doMinCutOpt=1;
  static int ncall = 0;

  /* try exist + min-cut opt */
  if (doMinCutOpt==1) {
     float lazyRate = Ddi_MgrReadAigLazyRate (ddm);
     Ddi_MgrSetOption(ddm,Pdt_DdiLazyRate_c,fnum,1.1);
     Ddi_AigExistProjectAcc(f,projectVars,NULL,3,0,timeLimit);
     Ddi_MgrSetOption(ddm,Pdt_DdiLazyRate_c,fnum,lazyRate);
     Ddi_Free(auxF);
     Ddi_Free(auxLits);
     Ddi_Free(auxV);
     return 1;
  }
  else if (doMinCutOpt==2) {
    int rrl = Ddi_MgrReadAigRedRemLevel(ddm);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,3);
    DdiAigRedRemovalAcc (f,NULL,1000,50.0);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl);
    return 1;
  }

  nodeIndex = Ddi_BddToBaig(f);

  if (projectVars != NULL) {
    smoothVars = Ddi_BddSupp(f);
    Ddi_VarsetDiffAcc(smoothVars,projectVars);
  }

  f1Cuts = aig2BddInternWithCuts(ddm,
     nodeIndex,th,auxV,auxF,auxLits,NULL,1,timeLimit,-1,0);

  if (1/*Check size*/) {
    int i;
    for (i=0; i<Ddi_BddarrayNum(auxF); i++) {
      Ddi_BddSetAig(Ddi_BddarrayRead(auxF,i));
    }
    Ddi_BddSetAig(f1Cuts);
  }

  if (nFactors>Ddi_BddarrayNum(auxF)) {
    nFactors = Ddi_BddarrayNum(auxF);
  }
  period = Ddi_BddarrayNum(auxF) / nFactors;


  factors = Ddi_BddarrayAlloc(ddm,1);
  Ddi_BddarrayWrite(factors,0,f1Cuts);
  Ddi_Free(f1Cuts);

  icut=0;
  while (icut < nFactors) {
    int i;
    Ddi_Var_t *cutV;
    Ddi_Bdd_t *cutL, *f_i;
    for (i=0; i<Ddi_BddarrayNum(auxF) && icut<nFactors; i++) {
      int size_i = Ddi_BddSize(Ddi_BddarrayRead(auxF,i));
      //      fprintf(dMgrO(ddm),"[%d]",size_i); fflush(dMgrO(ddm));
      if (size_i > selectTh) {
	//      if (i%period == 0) {
	char name[100];
        sprintf(name,"_PDT_BDDRELATION_CUTV_%d_%d",ncall,icut++);
        Pdtutil_Assert(Ddi_VarFromName(ddm,name)==NULL,"Duplicate cut var");
        Pdtutil_Assert(bAig_VarNodeFromName(bmgr,name)==bAig_NULL,
          "duplicate baig name");
	cutV = Ddi_VarNew(ddm);
        Ddi_VarAttachName (cutV, name);
        cutL = Ddi_BddMakeLiteralAig(cutV,1);

	f_i = Ddi_BddXnor(cutL,Ddi_BddarrayRead(auxF,i));
	Ddi_BddarrayInsertLast(factors,f_i);
	Ddi_Free(f_i);

	Ddi_BddarrayWrite(auxF,i,cutL);
	Ddi_Free(cutL);
      }
    }
    selectTh /= 2;
  }

  newFactors = Ddi_AigarrayCompose (factors,auxV,auxF);
  Ddi_Free(factors);

  if (smoothVars != NULL) {
    int nFactors = Ddi_BddarrayNum(newFactors);
    Ddi_Vararray_t *svA = Ddi_VararrayMakeFromVarset(smoothVars,1);
    int nVars = Ddi_MgrReadNumVars(ddm), nSm = Ddi_VarsetNum(smoothVars);
    int *enSmoothFactor = Pdtutil_Alloc(int, nFactors);
    int **enMerge = Pdtutil_Alloc(int *, nFactors);
    Ddi_Varset_t ***mergeVars = Pdtutil_Alloc(Ddi_Varset_t **, nFactors);
    int *factorId = Pdtutil_Alloc(int, 2*nSm);
    int *suppCnt = Pdtutil_Alloc(int, nSm);
    int *varId2i = Pdtutil_Alloc(int, nVars);
    Ddi_Varset_t *mySmooth = Ddi_VarsetVoid(ddm);
    int best_i, best_j, again;
    Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm,1);

    for (i=0; i<nFactors; i++) {
      int j;
      enSmoothFactor[i]=0;
      enMerge[i] = Pdtutil_Alloc(int,nFactors);
      mergeVars[i] = Pdtutil_Alloc(Ddi_Varset_t *,nFactors);
      for (j=0; j<nFactors; j++) {
        enMerge[i][j]=0;
        mergeVars[i][j]=NULL;
      }
    }
    for (i=0; i<nVars; i++) varId2i[i]=-1;
    for (i=0; i<nSm; i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(svA,i);
      int id = Ddi_VarIndex(v);
      Pdtutil_Assert(id>=0 && id<nVars,"Invalid varId");
      varId2i[id] = i;
      suppCnt[i]=0;
      factorId[2*i]=factorId[2*i+1]=-1;
    }

    for (i=0; i<Ddi_BddarrayNum(newFactors); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(newFactors,i);
      Ddi_Varset_t *supp_i = Ddi_BddSupp(f_i);
      Ddi_Vararray_t *siA = Ddi_VararrayMakeFromVarset(supp_i,1);
      int j;
      for (j=0; j<Ddi_VararrayNum(siA); j++) {
	Ddi_Var_t *v = Ddi_VararrayRead(siA,j);
	int id = Ddi_VarIndex(v);
	if (varId2i[id] < 0) continue;
	Pdtutil_Assert(varId2i[id]<nSm,"Invalid varId conversion");
	suppCnt[varId2i[id]]++;
	if (suppCnt[varId2i[id]]==1) {
	  factorId[varId2i[id]*2]=i;
	}
	else if (suppCnt[varId2i[id]]==2) {
	  factorId[varId2i[id]*2+1]=i;
	}
      }
      Ddi_Free(siA);
      Ddi_Free(supp_i);
    }

    for (i=0; i<Ddi_VararrayNum(svA); i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(svA,i);
      int id = Ddi_VarIndex(v);
      if (varId2i[id] < 0) continue;
      if (suppCnt[varId2i[id]] == 1) {
	int nf = factorId[varId2i[id]*2];
	Pdtutil_Assert(nf>=0 && nf<nFactors,"invalid factor id");
        Ddi_VarsetAddAcc(mySmooth,v);
	enSmoothFactor[nf] = 1;
      }
    }

    {
      int rrl = Ddi_MgrReadAigRedRemLevel(ddm);
      Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,0);

      for (i=0; i<Ddi_BddarrayNum(newFactors); i++) {
        Ddi_Bdd_t *f_i = Ddi_BddarrayRead(newFactors,i);
	if (enSmoothFactor[i]) {
          Ddi_AigExistAcc(f_i,mySmooth,NULL,1,0,10.0);
	}
      }

      Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl);
    }
    Ddi_Free(mySmooth);

    for (i=0; i<Ddi_VararrayNum(svA); i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(svA,i);
      int id = Ddi_VarIndex(v);
      if (varId2i[id] < 0) continue;
      if (suppCnt[varId2i[id]] == 2) {
	int nf0 = factorId[varId2i[id]*2];
	int nf1 = factorId[varId2i[id]*2+1];
	Pdtutil_Assert(nf0>=0 && nf0<nFactors,"invalid factor id");
	Pdtutil_Assert(nf1>=0 && nf1<nFactors,"invalid factor id");
	enMerge[nf0][nf1]++;
	enMerge[nf1][nf0]++;
	if (mergeVars[nf0][nf1] == NULL) {
          mergeVars[nf0][nf1] = Ddi_VarsetVoid(ddm);
          mergeVars[nf1][nf0] = Ddi_VarsetVoid(ddm);
	}
        Ddi_VarsetAddAcc(mergeVars[nf0][nf1],v);
        Ddi_VarsetAddAcc(mergeVars[nf1][nf0],v);
      }
    }

    do {
      again = 0;
      best_i = best_j = -1;
      for (i=0; i<nFactors; i++) {
        int j;
        for (j=0; j<nFactors; j++)
          if (enMerge[i][j] > 0) {
  	    if (best_i < 0 || (enMerge[i][j] > enMerge[best_i][best_j])) {
	      best_i=i; best_j=j;
	    }
          }
      }
      if (best_i >= 0) {
        Ddi_Bdd_t *f_i = Ddi_BddarrayRead(newFactors,best_i);
        Ddi_Bdd_t *f_j = Ddi_BddarrayRead(newFactors,best_j);
        Ddi_BddAndAcc(f_i,f_j);
	mySmooth = mergeVars[best_i][best_j];
	if (Ddi_VarsetNum(mySmooth) > 1)
          Ddi_AigExistAcc(f_i,mySmooth,NULL,1,0,30.0);
	else
          Ddi_AigExistAcc(f_i,mySmooth,NULL,2,0,30.0);
        Ddi_BddarrayWrite(newFactors,best_j,myOne);
        for (i=0; i<nFactors; i++) {
  	  enMerge[i][best_i] = 0;
	  enMerge[best_i][i] = 0;
	  enMerge[i][best_j] = 0;
  	  enMerge[best_j][i] = 0;
        }
	again = 1;
      }
    } while (again);


    Pdtutil_Free(enSmoothFactor);
    Pdtutil_Free(factorId);
    Pdtutil_Free(varId2i);
    Pdtutil_Free(suppCnt);
    for (i=0; i<nFactors; i++) {
      int j;
      Pdtutil_Free(enMerge[i]);
      for (j=0; j<nFactors; j++) Ddi_Free(mergeVars[i][j]);
      Pdtutil_Free(mergeVars[i]);
    }
    Pdtutil_Free(enMerge);
    Ddi_Free(svA);
    Ddi_Free(myOne);
  }

  f1Cuts = Ddi_BddDup(Ddi_BddarrayRead(newFactors,0));
  for (i=1; i<Ddi_BddarrayNum(newFactors); i++) {
    Ddi_Bdd_t *f_i = Ddi_BddarrayRead(newFactors,i);
    Ddi_BddAndAcc(f1Cuts,f_i);
  }

  Ddi_Free(newFactors);

  if (Ddi_MgrReadAigAbcOptLevel(ddm)) {
    ddiAbcOptAcc (f1Cuts,-1.0);
  }

#if 1
  f1 = Ddi_BddDup(f1Cuts);
#endif

  if (checkResult) {
      Ddi_Bdd_t *tmp = Ddi_BddXor(f1,f);
      Pdtutil_Assert(!Ddi_AigSat(tmp),"Wrong BDD OPT");
      Ddi_Free(tmp);
  }

  if (1) {
    fprintf(dMgrO(ddm),"AIGBDDRELATION: %d -> %d(Rel:%d)\n",
    Ddi_BddSize(f), Ddi_BddSize(f1), Ddi_BddSize(f1Cuts));
    DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)f1);
  }

  Ddi_Free(f1);
  Ddi_Free(f1Cuts);
  Ddi_Free(auxF);
  Ddi_Free(auxV);
  Ddi_Free(auxLits);

  Ddi_Free(smoothVars);

  ncall++;

  return size;
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
DdiAigExistProjectByBdd(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  int th,
  Ddi_Varset_t *projectVars,
  float timeLimit,
  int auxVarIdStart,
  int overAppr
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *f1Cuts=NULL;;
  Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Bddarray_t *auxLits = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Varset_t *smoothVars = NULL;
  Ddi_Bddarray_t *newFactors, *factors;
  Ddi_Bdd_t *fpart, *fres;
  Ddi_Varset_t *smooth, *smoothAux=NULL;
  Ddi_Bdd_t *constrain;
  int okCare = 0;

  int checkResult = 0, size, size0, i, selectTh = th/2, icut;
  bAigEdge_t nodeIndex;
  int period, nAux;

  int j;
  Ddi_Bdd_t *oneBdd = Ddi_BddMakeConst(ddm,1);
  if (overAppr == 2) {
    if (!ddm->settings.aig.enMetaOpt) {
      Ddi_MetaInit(ddm,Ddi_Meta_Size,0,0,0,0,50);
      ddm->settings.aig.enMetaOpt = 1;
    }
    overAppr = 0;
  }

  fpart = Ddi_AigPartitionTop(f,0);

  for (j=0; j<Ddi_BddPartNum(fpart); j++) {
    int usePart = 1;
    Ddi_Bdd_t *p_j = Ddi_BddPartRead(fpart,j);
    nodeIndex = Ddi_BddToBaig(p_j);
    if (overAppr) {
      Ddi_Varset_t *supp = Ddi_BddSupp(p_j);
      Ddi_VarsetIntersectAcc(supp,projectVars);
      usePart = !Ddi_VarsetIsVoid(supp);
      Ddi_Free(supp);
    }
    if (usePart) {
      f1Cuts = aig2BddInternWithCuts(ddm,
	nodeIndex,th/4,auxV,auxF,auxLits,NULL,0,timeLimit,-1,auxVarIdStart);
      if (f1Cuts==NULL) {
	Ddi_Free(fpart);
	Ddi_Free(smoothAux);
	return NULL;
      }
      else {
        Ddi_BddSetMono(f1Cuts);
        Ddi_BddPartWrite(fpart,j,f1Cuts);
        Ddi_Free(f1Cuts);
        auxVarIdStart = Ddi_VararrayNum(auxV);
      }
    }
    else {
      Ddi_BddPartWrite(fpart,j,oneBdd);
    }

  }
  Ddi_Free(oneBdd);

  nAux = auxV==NULL ? 0 : Ddi_VararrayNum(auxV);
  if (1/*Check size*/) {
    int i;
    for (i=0; i<Ddi_BddarrayNum(auxF); i++) {
      Ddi_Bdd_t *p_i = Ddi_BddarrayRead(auxF,i);
      Ddi_Bdd_t *lit = Ddi_BddMakeLiteral(Ddi_VararrayRead(auxV,i),1);
      Ddi_BddSetMono(p_i);
      Ddi_BddXnorAcc(lit,p_i);
      Ddi_BddPartInsertLast(fpart,lit);
      Ddi_Free(lit);
    }
  }
  if (nAux > 0) {
    smoothAux = Ddi_VarsetMakeFromArray(auxV);
  }

  size0=Ddi_BddSize(f)+1;

  if (Ddi_BddSize(fpart) > 4*size0) {
    int siftTh = Ddi_MgrReadSiftThresh(ddm);
    Ddi_MgrReduceHeap (ddm,
      Ddi_ReorderingMethodString2Enum((char *)"sift"), 0);
    Ddi_MgrSetSiftThresh (ddm, siftTh);
  }

  Ddi_Free(f1Cuts);
  Ddi_Free(auxF);
  Ddi_Free(auxV);
  Ddi_Free(auxLits);

  if (Ddi_BddSize(fpart) > 20*size0) {
    Ddi_Free(fpart);
    Ddi_Free(smoothAux);
    return NULL;
  }

  smooth = Ddi_BddSupp(fpart);
  Ddi_VarsetDiffAcc(smooth,projectVars);

  constrain = NULL;
  if (care != NULL) {
    Ddi_Varset_t *supp = Ddi_BddSupp(care);
    Ddi_VarsetDiffAcc(supp,projectVars);
    if (Ddi_VarsetIsVoid(supp)) {
      Ddi_Bdd_t *myConstrain = Ddi_AigPartitionTop(care,0);
      constrain = Ddi_BddMakeConst(ddm,1);
      Ddi_BddSetPartConj(constrain);
      for (j=0; j<Ddi_BddPartNum(myConstrain); j++) {
        Ddi_Bdd_t *c_j = Ddi_BddPartRead(myConstrain,j);
        c_j = DdiAigExistProjectByBdd(c_j,
	          NULL,4*Ddi_BddSize(c_j),projectVars,timeLimit,
                  0/*nAux*/,0);
	if (c_j != NULL) {
	  Ddi_BddSetMono(c_j);
	  Ddi_BddPartInsertLast(constrain,c_j);
	  okCare = 1;
	}
	Ddi_Free(c_j);
      }
      Ddi_Free(myConstrain);
    }
    Ddi_Free(supp);
  }
  if (constrain == NULL && care != NULL && Ddi_BddSize(care) < 2000) {
    constrain = DdiAigExistProjectByBdd(care,
	          NULL,2*Ddi_BddSize(care),projectVars,timeLimit,
                  0/*nAux*/,0);
    okCare = constrain!=NULL;
    if (constrain != NULL) {
      Ddi_BddSetMono(constrain);
    }
  }
  if (constrain == NULL) {
    constrain = Ddi_BddMakeConst(ddm,1);
  }

  if (nAux > 20) {
    fres = NULL;
  }
  else if (Ddi_BddPartNum(fpart) > 1) {
#if 0
    fres = NULL;
#else
    int sizeThresh = size0*30;
    int dpartTh = Ddi_MgrReadExistDisjPartTh(ddm);
    if (sizeThresh > 300000) sizeThresh = 300000;
    Tr_TrBddSortIwls95(NULL,fpart,smooth,projectVars);
    Ddi_MgrSetExistDisjPartTh(ddm,-1/*sizeThresh*10*/);
    Ddi_BddSetClustered(fpart,sizeThresh/20);
    if (ddm->settings.aig.enMetaOpt) {
      Ddi_Bdd_t *p0 = Ddi_BddPartRead(fpart,0);
      Ddi_BddSetMono(p0);
      Ddi_BddSetMeta(p0);
    }
    fres = Ddi_BddMultiwayRecursiveAndExist(fpart,smooth,constrain,sizeThresh);
    if (Ddi_BddIsMeta(fres)) {
      Ddi_BddSetPartConj(fres);
    }
    while (Ddi_BddIsPartConj(fres) &&
	   Ddi_BddPartNum(fres) < Ddi_BddPartNum(fpart)) {
      int siftTh = Ddi_MgrReadSiftThresh(ddm);
      Ddi_Free(fpart);
      fpart = fres;
      Ddi_MgrReduceHeap (ddm,
        Ddi_ReorderingMethodString2Enum((char *)"sift"), 0);
      Ddi_MgrSetSiftThresh (ddm, siftTh);
      fres = Ddi_BddMultiwayRecursiveAndExist(
        fpart,smooth,constrain,sizeThresh);
    }
    Ddi_MgrSetExistDisjPartTh(ddm,dpartTh);
    if (smoothAux!=NULL) {
      Ddi_Varset_t *supp = Ddi_BddSupp(fres);
      Ddi_VarsetIntersectAcc(supp,smoothAux);
      if (!Ddi_VarsetIsVoid(supp)) {
	if (Ddi_BddPartNum(fres)<4) {
          Ddi_BddExistAcc(fres,supp);
	}
	else {
	  Ddi_Free(fres);
	}
      }
      Ddi_Free(supp);
    }
#endif
  }
  else {
    fres = Ddi_BddExistProject(fpart,projectVars);
  }

  Ddi_Free(smoothAux);
  Ddi_Free(smooth);
  Ddi_Free(fpart);

  if (fres == NULL) {
    Ddi_Free(fpart);
    Ddi_Free(constrain);
    return NULL;
  }

  if (care != NULL && okCare) {
    Ddi_BddRestrictAcc(fres,constrain);
    Ddi_BddSetAig(constrain);
    if (0 && Ddi_BddSize(constrain) < Ddi_BddSize(care)) {
      DdiGenericDataCopy((Ddi_Generic_t *)care,(Ddi_Generic_t *)constrain);
    }
  }

  Ddi_Free(constrain);

  if (Ddi_BddSize(fres) > 4*Ddi_BddSize(f)) {
    int siftTh = Ddi_MgrReadSiftThresh(ddm);
    Ddi_MgrReduceHeap (ddm, Ddi_ReorderingMethodString2Enum((char *)"sift"), 0);
    Ddi_MgrSetSiftThresh (ddm, siftTh);
  }

  Ddi_BddSetAig(fres);

  if (Ddi_BddSize(fres) > 50000) {
    Ddi_Free(fres);
  }
  else if (care != NULL && Ddi_BddSize(fres) > Ddi_BddSize(f)) {
    DdiAigRedRemovalAcc (fres,care,-1,timeLimit);
  }

  return (fres);

}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigOptByBddPartial(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *f1, *f1Cuts, *aux;
  Ddi_Bddarray_t *auxF;
  Ddi_Vararray_t *auxV;
  int i, nAux;
  bAigEdge_t nodeIndex;
#if 0
  Ddi_Bdd_t *tmpF1 /*, tmpF0 = Ddi_BddMakeMono(f)*/;
#endif

  //  Ddi_AigSift(f,care);
  return;

  nodeIndex = Ddi_BddToBaig(f);

  auxF = Ddi_BddarrayAlloc(ddm,0);
  auxV = Ddi_VararrayAlloc(ddm,0);

  f1Cuts = aig2BddGenCutsIntern(ddm,nodeIndex,100000,auxV,auxF);

  aux = Ddi_BddMakeMono(f1Cuts);
  Ddi_BddSetAig(aux);
  if (0.8*Ddi_BddSize(aux) < Ddi_BddSize(f1Cuts)) {
    Ddi_Free(f1Cuts);
    f1Cuts = Ddi_BddDup(aux);
  }
  Ddi_Free(aux);

  nAux = Ddi_BddarrayNum(auxF);

  if (Ddi_BddarrayNum(auxF)>0) {
    Ddi_Bddarray_t *b,*a = Ddi_BddarrayAlloc(ddm,1);
    Ddi_BddarrayWrite(a,0,f1Cuts);
    Ddi_Free(f1Cuts);

    for (i=0; i<Ddi_BddarrayNum(auxF); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(auxF,i);
      aux = Ddi_BddMakeMono(f_i);
      Ddi_BddSetAig(aux);
      if (0.8*Ddi_BddSize(aux) < Ddi_BddSize(f_i)) {
	Ddi_BddarrayWrite(auxF,i,aux);
      }
      Ddi_Free(aux);
    }

    b = Ddi_AigarrayCompose (a,auxV,auxF);
    f1Cuts = Ddi_BddarrayExtract(b,0);
    Ddi_Free(a);
    Ddi_Free(b);

    if (Ddi_MgrReadAigAbcOptLevel(ddm)) {
      ddiAbcOptAcc (f1Cuts,-1.0);
    }

  }

  fprintf(dMgrO(ddm),"cut: %d[%d:%d])\n",Ddi_BddSize(f1Cuts),
    Ddi_BddarrayNum(auxF),Ddi_BddarraySize(auxF));


#if 0
 {
   Ddi_Bdd_t *tmpF0 = Ddi_BddMakeMono(f);

   tmpF1 = Ddi_BddMakeMono(f1Cuts);
   Pdtutil_Assert(Ddi_BddEqual(tmpF0,tmpF1),"Mismatching BDDs");
   Ddi_Free(tmpF0);
   Ddi_Free(tmpF1);
 }
#endif


#if 1
  f1 = Ddi_BddDup(f1Cuts);
#endif

  if (Ddi_BddSize(f)*1.5 > Ddi_BddSize(f1)) {
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"AIGBDDOPT: %d -> %d(Cuts[%d]:%d)\n",
      Ddi_BddSize(f), Ddi_BddSize(f1), nAux, Ddi_BddSize(f1Cuts));
      DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)f1));
  }

  Ddi_Free(f1);
  Ddi_Free(f1Cuts);
  Ddi_Free(auxF);
  Ddi_Free(auxV);

}



/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigSift(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Varset_t *supp;
  Ddi_Vararray_t *vA;
  int i, s, s1;

  static int ncalls=0;
  ncalls++;

  supp = Ddi_BddSupp(f);
  vA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_Free(supp);

  s = Ddi_BddSize(f);

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    int s0, s1;
    //    int initNodes = Ddi_MgrReadAigNodesNum(ddm);
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
    Ddi_Bdd_t *f_0 = Ddi_BddCofactor(f,v,0);
    Ddi_Bdd_t *f_1 = Ddi_BddCofactor(f,v,1);
    Ddi_BddAndAcc(f_1,lit);
    Ddi_BddDiffAcc(f_0,lit);
    s0 = Ddi_BddSize(f_0);
    s1 = Ddi_BddSize(f_1);
    Ddi_BddOrAcc(f_0,f_1);
    if (0&&(Ddi_BddSize(f_0) < s*1.1)) {
      ddiAbcOptAcc (f_0,-1);
    }
    if ((Ddi_BddSize(f_0) <= s*1.1)) {
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c,
	fprintf(dMgrO(ddm),"%d+%d = %d\n",s0,s1,Ddi_BddSize(f_0)));
      DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)f_0);
      s = Ddi_BddSize(f);
    }
    Ddi_Free(lit);
    Ddi_Free(f_0);
    Ddi_Free(f_1);
    //    f_0 = siftVarAcc (f,v,care);

    //    f_1 = Ddi_BddXor(f,f_0);
    //    Ddi_BddAndAcc(f_1,care);
    //    Pdtutil_Assert(!Ddi_AigSat(f_1),"Wrong result of var sift");
    //    Ddi_Free(f_1);

    //    if (Ddi_BddSize(f_0) < s) {
    //      fprintf(dMgrO(ddm),"Sift: %d -> %d\n",s,Ddi_BddSize(f_0));
    //      DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)f_0);
    //      s = Ddi_BddSize(f);
    //    }
    //    Ddi_Free(f_0);
    // Pdtutil_Assert(initNodes == Ddi_MgrReadAigNodesNum(ddm),
    //     "aig nodes leak");
  }
  s1 = Ddi_BddSize(f);
  if (s1<s) {
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
			 fprintf(dMgrO(ddm),"AIGSIFT: size: %d->%d\n", s, s1));
  }

  Ddi_Free(vA);

}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigarraySift(
  Ddi_Bddarray_t *fA
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  Ddi_Varset_t *supp;
  Ddi_Vararray_t *vA;
  int i, j, s, s1, nSingleDep=0, nSingleDep1=0;

  static int ncalls=0;
  ncalls++;

  supp = Ddi_BddarraySupp(fA);
  vA = Ddi_VararrayMakeFromVarset(supp,1);
  Ddi_Free(supp);

  if (0) {
    Ddi_Bdd_t *e0 = Ddi_BddMakeFromBaig(ddm,1192*4);
    Ddi_Bdd_t *e1 = Ddi_BddMakeFromBaig(ddm,1196*4);

    Ddi_Bddarray_t *fA_00 = Ddi_AigarrayConstrain(fA,e0,0);
    Ddi_Bddarray_t *fA_01 = Ddi_AigarrayConstrain(fA,e0,1);
    Ddi_Bddarray_t *fA_10 = Ddi_AigarrayConstrain(fA,e1,0);
    Ddi_Bddarray_t *fA_11 = Ddi_AigarrayConstrain(fA,e1,1);

    printf("enable constr en0: %d, %d\n",
	   Ddi_BddarraySize(fA_00),Ddi_BddarraySize(fA_01));

    printf("enable constr en1: %d, %d\n",
	   Ddi_BddarraySize(fA_10),Ddi_BddarraySize(fA_11));

    Ddi_Free(fA_00);
    Ddi_Free(fA_01);
    Ddi_Free(fA_10);
    Ddi_Free(fA_11);

    Ddi_Free(e0);
    Ddi_Free(e1);
  }

  s = Ddi_BddarraySize(fA);

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    int s0, s1, s01, nDep=0, nDep1=0;
    //    int initNodes = Ddi_MgrReadAigNodesNum(ddm);
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
    Ddi_Bddarray_t *fA_0 = Ddi_BddarrayCofactor(fA,v,0);
    Ddi_Bddarray_t *fA_1 = Ddi_BddarrayCofactor(fA,v,1);
    s0 = Ddi_BddarraySize(fA_0);
    s1 = Ddi_BddarraySize(fA_1);
    for (j=0; j<Ddi_BddarrayNum(fA); j++) {
      Ddi_Bdd_t *f_0 = Ddi_BddarrayRead(fA_0,j);
      Ddi_Bdd_t *f_1 = Ddi_BddarrayRead(fA_1,j);
      if (!Ddi_BddEqual(f_0,f_1)) nDep++;
      //      if (!Ddi_BddEqualSat(f_0,f_1)) nDep1++;
      Ddi_BddAndAcc(f_1,lit);
      Ddi_BddDiffAcc(f_0,lit);
      Ddi_BddOrAcc(f_0,f_1);
    }
    if (nDep==1) nSingleDep++;
    if (nDep==2) nSingleDep1++;
    s01 = Ddi_BddarraySize(fA_0);
    if ((s01 < s)) {
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c,
			   fprintf(dMgrO(ddm),"%d+%d = %d (%s) nDep: %d/%d\n",s0,s1,s01, Ddi_VarName(v), nDep, nDep1));
      DdiGenericDataCopy((Ddi_Generic_t *)fA,(Ddi_Generic_t *)fA_0);
      s = Ddi_BddarraySize(fA);
    }
    else {
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c,
			   fprintf(dMgrO(ddm),"%d+%d = %d (undone) - %s - nDep: %d/%d\n",s0,s1,s01, Ddi_VarName(v), nDep, nDep1));
    }
    Ddi_Free(lit);
    Ddi_Free(fA_0);
    Ddi_Free(fA_1);
    //    f_0 = siftVarAcc (f,v,care);

    //    f_1 = Ddi_BddXor(f,f_0);
    //    Ddi_BddAndAcc(f_1,care);
    //    Pdtutil_Assert(!Ddi_AigSat(f_1),"Wrong result of var sift");
    //    Ddi_Free(f_1);

    //    if (Ddi_BddSize(f_0) < s) {
    //      fprintf(dMgrO(ddm),"Sift: %d -> %d\n",s,Ddi_BddSize(f_0));
    //      DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)f_0);
    //      s = Ddi_BddSize(f);
    //    }
    //    Ddi_Free(f_0);
    // Pdtutil_Assert(initNodes == Ddi_MgrReadAigNodesNum(ddm),
    //     "aig nodes leak");
  }
  Ddi_AigarrayAbcOptAcc(fA,-1.0);
  s1 = Ddi_BddarraySize(fA);
  if (s1<=s) {
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
			 fprintf(dMgrO(ddm),"AIGSIFT: size: %d->%d - nSingleDep: %d - nDoubleDep: %d\n", s, s1,
				 nSingleDep, nSingleDep1));
  }

  Ddi_Free(vA);

}


/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigOptByMeta(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Varset_t *supp = Ddi_BddSupp(f);
  Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(supp,1);
  int i, j, step, n;
  Ddi_Bdd_t *fNew, *fDup = Ddi_BddDup(f);
  Ddi_Bdd_t *over;

  Ddi_VarsetRemoveAcc(supp,Ddi_VarFromName(ddm,(char *)"ck"));

  if (Ddi_BddSize(f) < 100) {
    return;
  }

  n = Ddi_VarsetNum(supp);
  step = n/1;

  fprintf(dMgrO(ddm),"Meta OPT: %d -> ", Ddi_BddSize(fDup)); fflush(dMgrO(ddm));

  fNew = Ddi_BddMakeConstAig(ddm,1);

#if 1

  for (i=0; i<n; i+=step) {
    Ddi_Varset_t *proj = Ddi_VarsetVoid(ddm);
    over = Ddi_BddDup(fDup);
    for (j=i; (j<i+step)&&(j<n); j++) {
      Ddi_Varset_t *sm1 = Ddi_VarsetMakeFromVar(Ddi_VararrayRead(vA,j));
//      Ddi_VarsetAddAcc(proj,Ddi_VararrayRead(vA,j));
      Ddi_Bdd_t *f2 = Ddi_BddDup(over);
      Ddi_AigExistAcc(f2,sm1,care,1/*partial*/,1,-1.0);
      if (Ddi_BddSize(f2) <= Ddi_BddSize(over) && Ddi_BddSize(f2) > 10) {
	Ddi_Free(over);
	over = Ddi_BddDup(f2);
      }
      Ddi_Free(f2);
      Ddi_Free(sm1);
    }
    DdiAigRedRemovalAcc (fDup,over,-1,-1.0);
    Ddi_BddAndAcc(fNew,over);
    fprintf(dMgrO(ddm),"{%d,%d,%d} ", Ddi_BddSize(fNew),
      Ddi_BddSize(over),Ddi_BddSize(fDup));  fflush(dMgrO(ddm));

    Ddi_Free(over);
    Ddi_Free(proj);
  }
  Ddi_BddAndAcc(fNew,fDup);

#else

#if 1
  fNew = Ddi_BddDup(fDup);
  DdiAigRedRemovalAcc (fNew,care,-1);
#else
  over = Ddi_BddDup(fDup);
  Ddi_AigExistAcc(over,supp,care,1/*partial*/,1,1.0);
  DdiAigRedRemovalAcc (fDup,over,-1);
  fNew = Ddi_BddAnd(fDup,over);
#endif
#endif

  fprintf(dMgrO(ddm)," -> %d\n", Ddi_BddSize(fNew));

  //  f0 = Ddi_BddAnd(f,care);
  //Ddi_BddSetMono(f0);
  //DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)fNew);

  //f1 = Ddi_BddAnd(f,care);
  //Ddi_BddSetMono(f1);
  // Pdtutil_Assert(Ddi_BddEqual(f1,f0),"error in Meta opt");
  // Ddi_Free(f0);
  // Ddi_Free(f1);

  Ddi_Free(fDup);
  Ddi_Free(supp);
  Ddi_Free(vA);
}


/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOptByConstrain(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  Ddi_Varset_t *smooth,
  int level
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int i, iMin, s, sMin, sTot;
  Ddi_Bdd_t *fOpt, *fPartAnd = Ddi_AigPartitionTop(f,0);
  Ddi_Bdd_t *constr, *f0;
  int size0 = Ddi_BddSize(f), size1;

  f0 = Ddi_BddDup(f);

  if (Ddi_BddPartNum(fPartAnd) == 1 && level>0) {
    Ddi_Bdd_t *notF = Ddi_BddNot(f);
    Ddi_Free(fPartAnd);
    Ddi_AigOptByConstrain(notF,care,smooth,level-1);
    Ddi_BddNotAcc(notF);
    Ddi_DataCopy(f,notF);
    if (size0 > (size1 = Ddi_BddSize(f))) {
      fprintf(dMgrO(ddm),"opt by constrain: %d -> %d\n", size0, size1);
    }
    Pdtutil_Assert(1||Ddi_BddEqualSat(f0,f),"wrong opt by constr result");
    Ddi_Free(f0);
    Ddi_Free(notF);
    return(f);
  }

  if (level > 0 && Ddi_BddPartNum(fPartAnd) < 8) {
    for (i=0; i<Ddi_BddPartNum(fPartAnd); i++) {
      Ddi_AigOptByConstrain(Ddi_BddPartRead(fPartAnd,i),care,smooth,level-2);
    }
  }

  sTot = Ddi_BddSize(f);
  constr = Ddi_BddMakeConstAig(ddm, 1);
  while (Ddi_BddPartNum(fPartAnd)>1) {
    Ddi_Bdd_t *p_i;
    iMin = -1;
    for (i=0; i<Ddi_BddPartNum(fPartAnd); i++) {
      p_i = Ddi_BddPartRead(fPartAnd,i);
      s = Ddi_BddSize(p_i);
      if (iMin<0 || s<sMin) {
	iMin = i; sMin = s;
      }
    }
    p_i = Ddi_BddPartRead(fPartAnd,iMin);
    s = Ddi_BddSize(p_i);
#if 1
    if (s>10 /*sTot*0.2*/) {
      break;
    }
#endif
    p_i = Ddi_BddPartExtract(fPartAnd,iMin);
    if (!Ddi_BddIsOne(p_i)) {
      if (Ddi_BddIsCube(p_i)) {
        Ddi_AigConstrainCubeAcc(fPartAnd,p_i);
        Ddi_AigConstrainCubeAcc(constr,p_i);
      }
      Ddi_BddAndAcc(constr,p_i);
    }
    Ddi_Free(p_i);
  }

  Ddi_BddSetAig(fPartAnd);

  Ddi_AigConstrainOptAcc(fPartAnd,constr,NULL,NULL,NULL,3);

  Ddi_DataCopy(f,fPartAnd);
  Ddi_Free(constr);
  Ddi_Free(fPartAnd);

  Pdtutil_Assert(1||Ddi_BddEqualSat(f0,f),"wrong opt by constr result");
  Ddi_Free(f0);

  if (size0 > (size1 = Ddi_BddSize(f))) {
    fprintf(dMgrO(ddm),"optby constrain: %d -> %d\n", size0, size1);
  }
  return (f);
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigOptTopOr(
  Ddi_Bdd_t *f,
  int neg
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAigEdge_t nodeIndex;
  bAig_array_t *nodes;
  bAig_Manager_t *manager = ddm->aig.mgr;
  nodeIndex = Ddi_BddToBaig(f);

  nodes = bAigArrayAlloc();

  aigOptTopIntern(manager,nodes,nodeIndex,neg,0,-1);
  aigTopOrClearVisitedIntern(manager,nodeIndex);

  bAigArrayFree(nodes);

}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigGates(
  Ddi_Bdd_t *f,
  int includeVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAigEdge_t baig;
  bAig_array_t *nodes;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bddarray_t *retA=Ddi_BddarrayAlloc(ddm,0);
  int i;

  Ddi_PostOrderBddAigVisitIntern(f,nodes,-1);
  postOrderAigClearVisitedIntern(bmgr,nodes);

  for (i=0; i<nodes->num; i++) {
    baig = nodes->nodes[i];
    if (baig==bAig_NULL || bAig_NodeIsConstant(baig)) continue;
    if (!includeVars && bAig_isVarNode(bmgr,baig)) continue;
    Ddi_Bdd_t *p_i = Ddi_BddMakeFromBaig(ddm,baig);
    Ddi_BddarrayInsertLast(retA,p_i);
    Ddi_Free(p_i);
  }

  bAigArrayFree(nodes);
  return retA;
}


/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_FindPropCut(
  Ddi_Bdd_t *prop,
  Ddi_Vararray_t *ps,
  Ddi_Bddarray_t *delta,
  int levels
) {
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(prop);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  Ddi_Bddarray_t *cuts, *cutsTot;
  Ddi_Bdd_t *part = Ddi_AigPartitionTop(prop,1); // OR
  int i;
  int myLevels = 1+2*(levels-1); // sequence is OR-(AND-OR)*

  cuts = Ddi_BddarrayMakeFromBddPart(part);
  cutsTot = Ddi_BddarrayDup(cuts);
  Ddi_Free(part);
  for (i=1; i<myLevels; i++) {
    int j;
    int doOr = (i%2)==0;
    Ddi_Bddarray_t *cutsNew = Ddi_BddarrayAlloc(ddm, 0);;
    for (j=0; j<Ddi_BddarrayNum(cuts); j++) {
      int jj;
      Ddi_Bdd_t *c_j = Ddi_BddDup(Ddi_BddarrayRead(cuts,j));
      Ddi_Bdd_t *c_jp;
      if (Ddi_BddSize(c_j)==1) {
	Ddi_BddComposeAcc(c_j,ps,delta);
      }
      c_jp = Ddi_AigPartitionTop(c_j,doOr); // AND/OR
      for (jj=0; jj<Ddi_BddPartNum(c_jp); jj++) {
	Ddi_Bdd_t *c_j_j = Ddi_BddPartRead(c_jp,jj);
	Ddi_BddarrayInsertLast(cutsNew,c_j_j);
      }
      Ddi_Free(c_j);
      Ddi_Free(c_jp);
    }
    Ddi_Free(cuts);
    cuts = Ddi_BddarrayAlloc(ddm,0);
    // avoid duplicates
    for (j=0; j<Ddi_BddarrayNum(cutsTot); j++) {
      Ddi_Bdd_t *c_j = Ddi_BddarrayRead(cutsTot,j);
      bAigEdge_t baig = Ddi_BddToBaig(c_j);
      Pdtutil_Assert(nodeAuxChar(bmgr,baig)==0,"0 auxchar required");
      nodeAuxChar(bmgr,baig) = 1;
    }
    for (j=0; j<Ddi_BddarrayNum(cutsNew); j++) {
      Ddi_Bdd_t *c_j = Ddi_BddarrayRead(cutsNew,j);
      bAigEdge_t baig = Ddi_BddToBaig(c_j);
      if (nodeAuxChar(bmgr,baig)==0) {
	nodeAuxChar(bmgr,baig) = 1;
	Ddi_BddarrayInsertLast(cutsTot,c_j);
	Ddi_BddarrayInsertLast(cuts,c_j);
      }
    }
    for (j=0; j<Ddi_BddarrayNum(cutsTot); j++) {
      Ddi_Bdd_t *c_j = Ddi_BddarrayRead(cutsTot,j);
      bAigEdge_t baig = Ddi_BddToBaig(c_j);
      Pdtutil_Assert(nodeAuxChar(bmgr,baig)==1,"1 auxchar required");
      nodeAuxChar(bmgr,baig) = 0;
    }
    Ddi_Free(cutsNew);
    //  Ddi_BddarrayAppend(cutsTot,cuts);
  }
  Ddi_Free(cuts);
  return cutsTot;
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigOptTop(
  Ddi_Bdd_t *f,
  int maxDepth,
  int sizeMax
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  int i, nRuns=-1, size0=Ddi_BddSize(f), size1, size2;
  int isOr = aigIsInv(f);
  Ddi_Bdd_t *aux = Ddi_BddMakeConstAig(ddm,!isOr);

  if (sizeMax <= 0) sizeMax = 1;

  do {
    Ddi_Bdd_t *partF = Ddi_AigPartitionTop(f,isOr);
    Ddi_Bdd_t *cube = Ddi_BddMakeConstAig(ddm,!isOr);
    int doConstrain=0;
    size1=Ddi_BddSize(f);
    for (i=0; i<Ddi_BddPartNum(partF); i++) {
      Ddi_Bdd_t *p_i = Ddi_BddPartRead(partF,i);
      if (Ddi_BddSize(p_i) <= sizeMax) {
	if (isOr) {
	  Ddi_BddOrAcc(cube,p_i);
	}
	else {
	  Ddi_BddAndAcc(cube,p_i);
	}
	doConstrain=1;
      }
    }
    if (doConstrain) {
      if (isOr) {
        Ddi_BddNotAcc(cube);
        Ddi_AigConstrainCubeAcc(f,cube);
        Ddi_BddNotAcc(cube);
      }
      else {
        Ddi_AigConstrainCubeAcc(f,cube);
      }
      if (maxDepth > 0) {
        Ddi_Bdd_t *partOpt = Ddi_AigPartitionTop(f,isOr);
	int s0 = Ddi_BddSize(partOpt);
        for (i=0; i<Ddi_BddPartNum(partOpt); i++) {
	  Ddi_Bdd_t *p_i = Ddi_BddPartRead(partOpt,i);
	  if (Ddi_BddSize(p_i) > 100) {
	    Ddi_AigOptTop(p_i,maxDepth-1,sizeMax);
	  }
	}
	if (Ddi_BddSize(partOpt) < s0) {
	  Ddi_BddSetAig(partOpt);
          DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)partOpt);
	}
	Ddi_Free(partOpt);
      }
      if (isOr) {
        Ddi_BddOrAcc(aux,cube);
      }
      else {
        Ddi_BddAndAcc(aux,cube);
      }
    }
    Ddi_Free(cube);
    Ddi_Free(partF);
    size2=Ddi_BddSize(f);
    nRuns++;
  } while (0&&size2 < size1);
  if (isOr) {
    Ddi_BddOrAcc(f,aux);
  }
  else {
    Ddi_BddAndAcc(f,aux);
  }
  Ddi_Free(aux);
  size2=Ddi_BddSize(f);

}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigPartitionTop(
  Ddi_Bdd_t *f,
  int topOr
)
{
  if (Ddi_BddIsPartConj(f)) {
    if (!topOr) return Ddi_BddDup(f);
    else {
      Pdtutil_Assert(0,"this partitioning is not supported");
    }
  }
  else if (Ddi_BddIsPartDisj(f)) {
    if (topOr) return Ddi_BddDup(f);
    else {
      Pdtutil_Assert(0,"this partitioning is not supported");
    }
  }
  return Ddi_AigPartitionTopWithXor(f,topOr,0);
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigRePartitionAcc(
  Ddi_Bdd_t *f,
  int min
)
{
  int isConj = Ddi_BddIsPartConj(f);
  int isDisj = Ddi_BddIsPartConj(f);
  int tryDec = 1;
  int printPartOnly = 1;

  Pdtutil_Assert(isConj||isDisj,"partitioned dd needed");

  if (Ddi_BddPartNum(f)>=min) return f;

  while (tryDec && (Ddi_BddPartNum(f)<min)) {

    int ii, np0=Ddi_BddPartNum(f);
    tryDec = 0;

    for (ii=0; ii<Ddi_BddPartNum(f); ii++) {
      Ddi_Bdd_t *p_ii = Ddi_BddPartRead(f,ii);
      Ddi_Bdd_t *p_ii_Part = Ddi_AigPartitionTop(p_ii, isConj?1:0);
      int np_ii = Ddi_BddPartNum(p_ii_Part);
      int j, j_max=-1, max=1;
      Ddi_Bdd_t *pMaxPart=NULL, *pMax=NULL;

      Ddi_Bdd_t *pPart = Ddi_BddDup(p_ii_Part);

      Ddi_Free(p_ii_Part);

      if (printPartOnly) printf("[%2d]", ii);

      for (j=0; j<np_ii; j++) {
	Ddi_Bdd_t *p_j = Ddi_BddPartRead(pPart,j);
	Ddi_Bdd_t *p_j_Part = Ddi_AigPartitionTop(p_j, isConj?0:1);

	int size = Ddi_BddSize(p_j);
	int np = Ddi_BddPartNum(p_j_Part);
	Ddi_Free(p_j_Part);
	if (/*j==0 ||*/np > max) {
	  j_max = j;
	  max = np;
	}
	if (printPartOnly) {
	  printf(" %s%d", Ddi_BddIsComplement(p_j)?"!":"",
		 Ddi_BddToBaig(p_j)/4);
	  if (Ddi_BddIsLiteralAig(p_j)) {
	    Ddi_Var_t *t = Ddi_BddTopVar(p_j);
	    printf("(%s)", Ddi_VarName(t));
	  }
	}
      }

      if (printPartOnly) {
	printf("\n");
	tryDec=0;
	continue;
      }

      if (j_max<0) {
	Ddi_Free(pPart);
	continue;
	//	break;
      }

      tryDec = 1;

      pMax = Ddi_BddPartExtract(pPart,j_max);
      pMaxPart = Ddi_AigPartitionTop(pMax, isConj?0:1);
      Ddi_Free(pMax);
      Ddi_BddSetAig(pPart);
      for (j=0; j<Ddi_BddPartNum(pMaxPart); j++) {
	Ddi_Bdd_t *p_j = Ddi_BddPartRead(pMaxPart,j);
	if (isConj)
	  Ddi_BddOrAcc(p_j,pPart);
	else
	  Ddi_BddAndAcc(p_j,pPart);
      }
      Ddi_Free(pPart);
      pPart = pMaxPart;
      Ddi_DataCopy(p_ii,pPart);
      Ddi_Free(pPart);

    }
    //    useRplus = 1;
    Ddi_BddSetFlattened(f);
    if (isConj)
      Ddi_BddSetPartConj(f);
    else
      Ddi_BddSetPartDisj(f);
    //    if (Ddi_BddPartNum(pConj)>=np0) tryDec=0;
  }

  return f;
}


/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigPartitionTopWithXor(
  Ddi_Bdd_t *f,
  int topOr,
  int keepXor
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAigEdge_t nodeIndex;
  bAig_array_t *nodes;
  bAig_Manager_t *manager = ddm->aig.mgr;
  Ddi_Bdd_t *bddPart;
  int i, ret;

  nodeIndex = Ddi_BddToBaig(f);

  nodes = bAigArrayAlloc();

  recDepth=0;

  if (1 && !keepXor) {
    if (topOr) {
      ret = aigOptTopInternTopOr(manager,nodes,nodeIndex);
    }
    else {
      ret = aigOptTopInternTopAnd(manager,nodes,nodeIndex);
    }
  }
  else {
    ret = aigOptTopIntern(manager,nodes,nodeIndex,topOr,keepXor,-1);
  }
  aigTopOrClearVisitedIntern(manager,nodeIndex);

  if (topOr) {
    bddPart = Ddi_BddMakePartDisjVoid(ddm);
  }
  else {
    bddPart = Ddi_BddMakePartConjVoid(ddm);
  }

  if (ret<0) {
    Ddi_Bdd_t *constAig = Ddi_BddMakeConstAig(ddm, topOr);
    Ddi_BddPartInsertLast(bddPart,constAig);
    Ddi_Free(constAig);
  }
  else {
    for (i=0; i<nodes->num; i++) {
      Ddi_Bdd_t *p_i = Ddi_BddMakeFromBaig(ddm,nodes->nodes[i]);
      if (!(topOr ? Ddi_BddIsZero(p_i) : Ddi_BddIsOne(p_i))) {
        Ddi_BddPartInsertLast(bddPart,p_i);
      }
      Ddi_Free(p_i);
    }
  }
  bAigArrayFree(nodes);
  return (bddPart);

}


/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigPartitionTopIte(
  Ddi_Bdd_t *f,
  int sizeTh
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAigEdge_t nodeIndex, elseBaig;
  Ddi_Bdd_t *selAig, *thenAig, *elseAig;
  Ddi_Bddarray_t *fItePart;
  int i, ret;

  nodeIndex = Ddi_BddToBaig(f);

  selAig = Ddi_BddMakeConstAig(ddm,1);
  thenAig = Ddi_BddMakeConstAig(ddm,1);


  recDepth=0;

  Ddi_BddSetPartConj(selAig);
  /* make two constant one partitions */
  Ddi_BddPartWrite(selAig,1,Ddi_BddPartRead(selAig,0));

  elseBaig = aigPartitionTopIteIntern(ddm,nodeIndex,
                                      selAig,thenAig,sizeTh);

  elseAig = Ddi_BddMakeFromBaig(ddm, elseBaig);
  bAig_RecursiveDeref(manager,elseBaig);

  //  aigTopOrClearVisitedIntern(manager,nodeIndex);

  if (ret<0) {
    return NULL;
  }

  fItePart = Ddi_BddarrayAlloc(ddm,3);
  Ddi_BddarrayWrite(fItePart,0,selAig); Ddi_Free(selAig);
  Ddi_BddarrayWrite(fItePart,1,thenAig); Ddi_Free(thenAig);
  Ddi_BddarrayWrite(fItePart,2,elseAig); Ddi_Free(elseAig);

  return (fItePart);

}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigPartitionTopXorOrXnor(
  Ddi_Bdd_t *f,
  int doXor
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAigEdge_t nodeIndex, aBaig, bBaig;
  Ddi_Bdd_t *aAig, *bAig;
  Ddi_Bddarray_t *fXorPart;
  int i, ret;

  nodeIndex = Ddi_BddToBaig(f);

  ret = baigSplitXorOrXnor(manager,nodeIndex,&aBaig,&bBaig,doXor);

  if (ret<=0) {
    return NULL;
  }

  aAig = Ddi_BddMakeFromBaig(ddm, aBaig);
  bAig = Ddi_BddMakeFromBaig(ddm, bBaig);

  fXorPart = Ddi_BddarrayAlloc(ddm,2);
  Ddi_BddarrayWrite(fXorPart,0,aAig); Ddi_Free(aAig);
  Ddi_BddarrayWrite(fXorPart,1,bAig); Ddi_Free(bAig);

  return (fXorPart);
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int *
Ddi_AigProveLemmas(
  Ddi_Bdd_t *f,
  Ddi_Bddarray_t *lemmas,
  Ddi_Bddarray_t *assumptions
)
{
  int i, nc, n = Ddi_BddarrayNum(lemmas);
  int *resArray = Pdtutil_Alloc(int,n);
  int *checkArray = Pdtutil_Alloc(int,n);
  FILE *fp;
  fpos_t posFile;
  int clauseN, varMax, nCompare;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(lemmas);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;

  fp = fopen ("satLemmasCheck.cnf","w");
  if (fp == NULL) {
    fprintf(dMgrO(ddm),"error parsing sat result\n");
    return NULL;
  }

  fgetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", 0, 0);
  clauseN = 0;
  varMax = -1;
  aig2CnfIdInit(ddm);

  nCompare = 0;
  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(lemmas,i);
    checkArray[i] = 0;
    if (Ddi_BddIsConstant(f)) {
      resArray[i] = Ddi_BddIsOne(f);
    }
    else {
      bAigEdge_t baig = Ddi_BddToBaig(f);
      int vXor;
      int fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                              aig2CnfId(ddm->aig.mgr,baig);
      vXor = aig2CnfNewIdIntern(ddm);
      if (vXor > varMax) {
        varMax = vXor;
      }
      nCompare++;
      checkArray[i] = vXor;
      /* v!=f --> (v+f)(!v+!f) */
      fprintf(fp, "%d %d 0\n", vXor, fCnf);
      fprintf(fp, "%d %d 0\n", -vXor, -fCnf);
      clauseN += 2;
      aig2CnfIntern(ddm,baig,fp,&clauseN, &varMax);
      resArray[i] = -1;
    }
  }

  if (assumptions != NULL) {
    for (i=0; i<Ddi_BddarrayNum(assumptions); i++) {
      bAigEdge_t baig = Ddi_BddToBaig(Ddi_BddarrayRead(assumptions,i));
      int careCnf = bAig_NodeIsInverted(baig) ?
          -aig2CnfId(bmgr,baig) : aig2CnfId(bmgr,baig);
      fprintf(fp, "%d 0\n", careCnf);
      clauseN += 1;
      aig2CnfIntern(ddm,baig,fp,&clauseN, &varMax);
    }
  }
  if (f != NULL) {
    bAigEdge_t baig = Ddi_BddToBaig(f);
    int fCnf = bAig_NodeIsInverted(baig) ?
        -aig2CnfId(bmgr,baig) : aig2CnfId(bmgr,baig);
    fprintf(fp, "%d 0\n", fCnf);
    clauseN += 1;
    aig2CnfIntern(ddm,baig,fp,&clauseN, &varMax);
  }

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(lemmas,i);
    if (Ddi_BddIsConstant(f)) {
      resArray[i] = Ddi_BddIsOne(f);
    }
    else {
      bAigEdge_t baig = Ddi_BddToBaig(f);
      aig2CnfClearVisitedIntern(bmgr,baig);
    }
  }

  if (assumptions != NULL) {
    for (i=0; i<Ddi_BddarrayNum(assumptions); i++) {
      bAigEdge_t baig = Ddi_BddToBaig(Ddi_BddarrayRead(assumptions,i));
      aig2CnfClearVisitedIntern(bmgr,baig);
    }
  }
  if (f != NULL) {
    bAigEdge_t baig = Ddi_BddToBaig(f);
    aig2CnfClearVisitedIntern(bmgr,baig);
  }

  fsetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", varMax, clauseN);
  fclose (fp);

  if (nCompare > 0) {

    fp = fopen ("satLemmasCheck.chk","w");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return NULL;
    }
    fprintf(fp,"%d\n",nCompare);
    for (i=0;i<n; i++) {
      if (checkArray[i] != 0) {
        fprintf(fp,"%d\n",checkArray[i]);
        nCompare--;
      }
    }
    Pdtutil_Assert(nCompare==0,"invalid num of compare points");
    fclose(fp);
#if 1
    satDiffSolve((char *)"satLemmasCheck");
#endif
#if 1
    system("rm satLemmasCheck.cnf");
    system("rm satLemmasCheck.chk");
#endif
    fp = fopen ((char *)"satLemmasCheck.res","r");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return NULL;
    }
    fscanf(fp,"%d",&nc);

    for (i=0;i<n; i++) {
      int sat;
      if (checkArray[i] != 0) {
        fscanf(fp,"%d",&sat);
        /* -1: sat - >0: unsat(proved) - 0: not checked */
	checkArray[i] = sat ? -1 : 1;
	resArray[i] = sat==0;
      }
    }

    fclose(fp);
    system("rm satLemmasCheck.res");

    Pdtutil_Free(checkArray);

  }

  return (resArray);
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int *
Ddi_AigProveLemmasMinisat(
  Ddi_Bdd_t *f,
  Ddi_Bddarray_t *lemmas,
  Ddi_Bddarray_t *assumptions
)
{
  int i, j, n = Ddi_BddarrayNum(lemmas);
  int *resArray = Pdtutil_Alloc(int,n);
  int *checkArray = Pdtutil_Alloc(int,n);
  int clauseN, varMax, nCompare;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(lemmas);
  Solver      S;

  clauseN = 0;
  varMax = -1;
  aig2CnfIdInit(ddm);

#if 0
  if (care != NULL && Ddi_BddIsOne(care)) {
    MinisatClauses(S,care,NULL,NULL,0);
  }
#endif

  nCompare = 0;
  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(lemmas,i);
    checkArray[i] = 0;
    if (Ddi_BddIsConstant(f)) {
      resArray[i] = Ddi_BddIsOne(f);
    }
    else {
      checkArray[i] = MinisatClauses(S,f,NULL,NULL,1);
      while (abs(checkArray[i]) > S.nVars()) S.newVar();
      resArray[i] = -1;
      nCompare++;
    }
  }

  if (assumptions != NULL) {
    for (i=0; i<Ddi_BddarrayNum(assumptions); i++) {
      MinisatClauses(S,Ddi_BddarrayRead(assumptions,i),NULL,NULL,0);
    }
  }
  if (f != NULL) {
    MinisatClauses(S,f,NULL,NULL,0);
  }

  aig2CnfIdClose(ddm);

  if (nCompare > 0) {
    vec<Lit> lits;

    for (i=0;i<n; i++) {
      int sat;
      if (checkArray[i] != 0) {
        vec<Lit> assumps;
        /* check if lemma can be falsified */
        assumps.clear();
        assumps.push(MinisatLit(-checkArray[i]));
        if ((sat = S.okay())) {
          sat = S.solve(assumps);
        }
	resArray[i] = sat==0;
        if (!sat) {
	  /* unsat: add clause */
          MinisatClause1(S,lits,checkArray[i]);
        }
	else {
          for (j=i+1;j<n; j++) {
            if (checkArray[j] != 0) {
  	      int varMinisat = abs(checkArray[j])-1;
  	      int sign = checkArray[j] < 0;
                Pdtutil_Assert(S.model[varMinisat] != l_Undef,
                   "undefined var in Minisat cex");
	      if (S.model[varMinisat]==(sign?l_True:l_False)) {
  	        checkArray[j] = 0;
                resArray[j] = 0;
  	      }
	    }
	  }
	}
      }
    }

    Pdtutil_Free(checkArray);

  }

  return (resArray);
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigComputeInitialLemmas(
  Ddi_Bddarray_t *lemmasSimul,
  Ddi_Bddarray_t *lemmasBase,
  Ddi_Bdd_t *initState,
  int maxLevel
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(lemmasSimul);
  bAig_Manager_t  *bmgr = ddm->aig.mgr;
  Ddi_Bddarray_t *lemmasArray = Ddi_BddarrayAlloc(ddm,0);
  Ddi_AigSignatureArray_t *varSigs, *nodeSigs, *nodeSigsCompl;
  int nVars = Ddi_MgrReadNumVars(ddm);
  Ddi_Bddarray_t *nodesAig;
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  int i,j;
  Ddi_AigSignature_t careSig, oneSig, zeroSig;

  varSigs = DdiAigSignatureArrayAlloc(nVars);
  DdiSetSignaturesRandom(varSigs,nVars);
  if (initState != NULL) {
    DdiUpdateVarSignatureAllBits(varSigs, initState);
  }
  DdiSetSignatureConstant(&careSig,1);
  DdiSetSignatureConstant(&oneSig,1);
  DdiSetSignatureConstant(&zeroSig,0);

  nodesAig = Ddi_AigarrayNodes(lemmasSimul,-1);
  for (i=0; i<Ddi_BddarrayNum(nodesAig); i++) {
    bAigEdge_t baig = Ddi_BddToBaig(Ddi_BddarrayRead(nodesAig,i));
    bAigArrayWriteLast(visitedNodes,baig);
  }
  Ddi_Free(nodesAig);

  nodeSigs = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs);
  nodeSigsCompl = DdiAigSignatureArrayAlloc(visitedNodes->num);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxInt(bmgr,baig) == -1, "wrong auxId field");
    bAig_AuxInt(bmgr,baig) = i;
    nodeSigsCompl->sArray[i] = nodeSigs->sArray[i];
    DdiComplementSignature(&(nodeSigsCompl->sArray[i]));
  }

  for (i=0; i<Ddi_BddarrayNum(lemmasSimul); i++) {
    int nc;
    bAigEdge_t base_i = Ddi_BddToBaig(Ddi_BddarrayRead(lemmasSimul,i));
    int i_sig = bAig_AuxInt(bmgr,base_i);
    Ddi_AigSignature_t iSig = nodeSigs->sArray[i_sig];
    nc = 100000;
    if (bAig_NodeIsInverted(base_i)) {
      iSig = nodeSigsCompl->sArray[i_sig];
    }
    if (DdiEqSignatures(&iSig,&oneSig,&careSig)) {
      Ddi_Bdd_t *lemma = Ddi_BddarrayRead(lemmasBase,i);
      Ddi_BddarrayInsertLast(lemmasArray,lemma);
      nc=-1;
    }
    else if (DdiEqSignatures(&iSig,&zeroSig,&careSig)) {
      Ddi_Bdd_t *lemma = Ddi_BddNot(Ddi_BddarrayRead(lemmasBase,i));
      Ddi_BddarrayInsertLast(lemmasArray,lemma);
      Ddi_Free(lemma);
      nc=-1;
    }

    if (nc>=0)
    for (j=0; j<i; j++) {
      bAigEdge_t base_j = Ddi_BddToBaig(Ddi_BddarrayRead(lemmasSimul,j));
      int j_sig = bAig_AuxInt(bmgr,base_j);
      Ddi_AigSignature_t jSig = nodeSigs->sArray[j_sig];
      Ddi_AigSignature_t jSigCompl = nodeSigsCompl->sArray[j_sig];
      if (bAig_NodeIsInverted(base_j)) {
        jSig = nodeSigsCompl->sArray[j_sig];
        jSigCompl = nodeSigs->sArray[j_sig];
      }
#if 1
      if (DdiEqSignatures(&iSig,&jSig,&careSig)) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(lemmasBase,i);
	Ddi_Bdd_t *f_j = Ddi_BddarrayRead(lemmasBase,j);
	Ddi_Bdd_t *lemma = Ddi_BddXnor(f_i,f_j);
	Ddi_BddarrayInsertLast(lemmasArray,lemma);
	Ddi_Free(lemma);
	if (--nc <= 0)
  	  break;
      }
      else if (DdiEqSignatures(&iSig,&jSigCompl,&careSig)) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(lemmasBase,i);
	Ddi_Bdd_t *f_j = Ddi_BddarrayRead(lemmasBase,j);
	Ddi_Bdd_t *lemma = Ddi_BddXor(f_i,f_j);
	Ddi_BddarrayInsertLast(lemmasArray,lemma);
	Ddi_Free(lemma);
  	if (--nc <= 0)
  	  break;
      }
#endif
#if 0
      if (implySignatures(&iSig,&jSig,&careSig)) {
	Ddi_Bdd_t *f_i = Ddi_BddNot(Ddi_BddarrayRead(lemmasBase,i));
	Ddi_Bdd_t *f_j = Ddi_BddarrayRead(lemmasBase,j);
	Ddi_Bdd_t *lemma = Ddi_BddOr(f_j,f_i);
	Ddi_BddarrayInsertLast(lemmasArray,lemma);
	Ddi_Free(f_i);
	Ddi_Free(lemma);
  	if (--nc <= 0)
  	  break;
      }
      if (implySignatures(&jSig,&iSig,&careSig)) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(lemmasBase,i);
	Ddi_Bdd_t *f_j = Ddi_BddNot(Ddi_BddarrayRead(lemmasBase,j));
	Ddi_Bdd_t *lemma = Ddi_BddOr(f_j,f_i);
	Ddi_BddarrayInsertLast(lemmasArray,lemma);
	Ddi_Free(f_j);
	Ddi_Free(lemma);
  	if (--nc <= 0)
  	  break;
      }
      if (implySignatures(&iSig,&jSigCompl,&careSig)) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(lemmasBase,i);
	Ddi_Bdd_t *f_j = Ddi_BddarrayRead(lemmasBase,j);
	Ddi_Bdd_t *lemma = Ddi_BddAnd(f_j,f_i);
	Ddi_BddNotAcc(lemma);
	Ddi_BddarrayInsertLast(lemmasArray,lemma);
	Ddi_Free(lemma);
  	if (--nc <= 0)
  	  break;
      }
      if (implySignatures(&jSigCompl,&iSig,&careSig)) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(lemmasBase,i);
	Ddi_Bdd_t *f_j = Ddi_BddarrayRead(lemmasBase,j);
	Ddi_Bdd_t *lemma = Ddi_BddOr(f_i,f_j);
	Ddi_BddarrayInsertLast(lemmasArray,lemma);
	Ddi_Free(lemma);
  	if (--nc <= 0)
  	  break;
      }
#endif
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
  }

  DdiAigSignatureArrayFree(varSigs);
  DdiAigSignatureArrayFree(nodeSigs);
  DdiAigSignatureArrayFree(nodeSigsCompl);
  bAigArrayFree(visitedNodes);

  return (lemmasArray);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigConstrainSignatures (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *careAig,
  Ddi_AigSignatureArray_t *varSigs,
  int min_pattern,
  float *pDensity,
  int timeLimit
)
{
  Pdtutil_Array_t *betas = Pdtutil_IntegerArrayAlloc(1);
  int cubes_num, np=8*sizeof(unsigned long)*DDI_AIG_SIGNATURE_SLOTS;
  Ddi_Varset_t *care_vs, *fAig_vs, *un_vs, *alpha_vs, *beta_vs;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(careAig);
  Ddi_Vararray_t *alpha_va, *beta_va;
  Ddi_Bddarray_t *cubes;
  Ddi_Bdd_t *cube;
  float density=0.0;
  int i;

  /* constrain signature in care */
  cubes = Ddi_BddarrayAlloc(ddm, 0);
  care_vs = Ddi_BddSupp(careAig);
  if (fAig) {
    fAig_vs = Ddi_BddSupp(fAig);
  } else {
    fAig_vs = Ddi_VarsetVoid(ddm);
  }
  if (Ddi_VarsetIsArray(care_vs)) {
    Ddi_VarsetSetArray(fAig_vs);
  }
  un_vs = Ddi_VarsetUnion(care_vs, fAig_vs);
  alpha_vs = Ddi_VarsetDup(un_vs);
  alpha_va = Ddi_VararrayMakeFromVarset(alpha_vs, 1);
  beta_vs = Ddi_VarsetVoid(ddm);
  beta_va = Ddi_VararrayMakeFromVarset(beta_vs, 1);
  density = Ddi_GenConstrRandSimulSignatures(alpha_va,
	      Ddi_VararrayNum(beta_va) ? beta_va : NULL,
	      0, careAig, min_pattern, np, timeLimit, cubes, betas);

  if (pDensity != NULL) {
    *pDensity = density;
  }

  cubes_num = Ddi_BddarrayNum(cubes);
  Pdtutil_Assert(np >= cubes_num, "Wrong num of cubes");

  Ddi_MgrSiftSuspend(ddm);

  /* store cubes */
  for (i=0; i<cubes_num; i++) {
    cube = Ddi_BddarrayRead(cubes, i);
    // Ddi_BddSetMono(cube);
    DdiUpdateVarSignature(varSigs, cube);
  }
  Pdtutil_IntegerArrayFree(betas);
  Ddi_Free(cubes);

  Ddi_MgrSiftResume(ddm);

  Ddi_Free(beta_va);
  Ddi_Free(beta_vs);
  Ddi_Free(alpha_va);
  Ddi_Free(alpha_vs);
  Ddi_Free(un_vs);
  Ddi_Free(fAig_vs);
  Ddi_Free(care_vs);
  return cubes_num;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_BddarrayFindMinCut (
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *care,
  Ddi_Vararray_t *initVars,
  Ddi_Vararray_t *lockedVars,
  Ddi_Bddarray_t *substF,
  Ddi_Vararray_t *substV,
  int disablePiFlow,
  int fwdCut
)

{
  if (!disablePiFlow) {
    return FindMinCutArray(fA,care,initVars,substF,substV,-1,-1,0,
             0/*doFullFlow*/,disablePiFlow,fwdCut,0,-1/*cutRatio*/);
  }
  else {
    return FindMinCutArrayBF(fA,care,initVars,lockedVars,substF,substV);
  }
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_BddSplitMinCut (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  Ddi_Vararray_t *initVars,
  Ddi_Bddarray_t *substF,
  Ddi_Vararray_t *substV,
  int disablePiFlow,
  int fwdCut,
  float cutRatio
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *newFA, *fA = Ddi_BddarrayAlloc(ddm, 1);
  Ddi_Bdd_t *newF;

  Ddi_BddarrayWrite(fA,0,f);

  newFA = FindMinCutArray(fA,care,initVars,substF,substV,1,-1,0,
                          0/*doFullFlow*/,disablePiFlow,fwdCut,0,cutRatio);
  newF = Ddi_BddDup(Ddi_BddarrayRead(newFA,0));
  Ddi_Free(newFA);
  return newF;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_BddSplitShortEdges (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  Ddi_Vararray_t *initVars,
  Ddi_Bddarray_t *substF,
  Ddi_Vararray_t *substV,
  float cutRatio
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *newFA, *fA = Ddi_BddarrayAlloc(ddm, 1);
  Ddi_Bdd_t *newF;

  Ddi_BddarrayWrite(fA,0,f);

  newFA = FindMinCutArray(fA,care,initVars,substF,substV,20,-1,0,
                          0/*doFullFlow*/,0,1,2,cutRatio);
  newF = Ddi_BddDup(Ddi_BddarrayRead(newFA,0));
  Ddi_Free(newFA);
  return newF;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_BddarraySplitShortEdges (
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *care,
  Ddi_Vararray_t *initVars,
  Ddi_Bddarray_t *substF,
  Ddi_Vararray_t *substV,
  float cutRatio
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  Ddi_Bddarray_t *newFA;

  newFA = FindMinCutArray(fA,care,initVars,substF,substV,20,-1,0,
                          0/*doFullFlow*/,0,1,2,cutRatio);
  return newFA;
}

/* /\* */
/*   TODO  */
/* *\/ */
/* /\**Function******************************************************************** */
/*    Synopsis    [Constant redundancy removal] */
/*    Description [Constant redundancy removal] */
/*    SideEffects [] */
/*    SeeAlso     [] */
/* ******************************************************************************\/ */
/* Ddi_Bdd_t * */
/* DdiAigRedRemovalAccHeur ( */
/* 			 Ddi_Bdd_t *fAig, */
/* 			 Ddi_Bdd_t *care, */
/* 			 int maxObserve, */
/* 			 float timeLimit, */
/* 			 int eur */
/* 			 ) */
/* { */
/*   int j, nVars; */
/*   bAig_Manager_t  *bmgr; */
/*   Ddi_Bdd_t *newfAig, *cof0Aig, *cof1Aig; */
/*   bAig_array_t *visitedNodes; */
/*   bAigEdge_t fBaig, careBaig, cof1; */
/*   Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig); */
/*   int nChecks, nChecks2, nRed, nRed2; */
/*   int extRef = Ddi_MgrReadExtRef(ddm); */
/*   int i, val, size1, size0 = Ddi_BddSize(fAig); */
/*   Ddi_AigSignatureArray_t *varSigs, *fSig, *fSig1; */
/*   Ddi_AigSignature_t careSig; */
/*   int doMultipleChecks = 0; */
/*   int enaPhase1 = 1; */
/*   int enaPhase2 = 1; */
/*   int enEqCheck = 1; */
/*   float optFactor = 5.0; */
/*   int checkResult = 0; */
/*   int redRem=Ddi_MgrReadAigRedRemLevel(ddm); */
/*   int useObserveDC = 1; */
/*   int maxSize = 1000000; */
/*   long startTimeTot = util_cpu_time(); */
/*   Ddi_Bdd_t *fEur1, *fEur2, *fEur3, *fEur4; */

/*   if (Ddi_BddIsPartConj(fAig)) { */
/*     int i; */
/*     for (i=0; i<Ddi_BddPartNum(fAig); i++) { */
/*       DdiAigRedRemovalAcc (Ddi_BddPartRead(fAig,i),care,maxObserve,timeLimit); */
/*     } */
/*     return(fAig); */
/*   } */

/*   //ddm->settings.aig.satIncrByRefinement = 3; */

/*   if (0) */
/*     { */
/*       Ddi_Bddarray_t *atpgArray = Ddi_BddarrayAlloc(ddm,1); */
/*       Ddi_BddarrayWrite(atpgArray,0,fAig); */

/*       Ddi_AigarrayNetStore(atpgArray, */
/* 			   (char *)"atpgVerilog.v",NULL,Pdtutil_Aig2Verilog_c); */

/*       Ddi_Free(atpgArray); */
/*     } */


/*   if (redRem==1) { */
/*     if (++ddm->settings.aig.redRemCnt >= ddm->settings.aig.redRemMaxCnt) { */
/*       ddm->settings.aig.redRemCnt = 0; */
/*     } */
/*     else { */
/*       redRem = 0; */
/*     } */
/*   } */

/*   bmgr = ddm->aig.mgr; */

/*   if (1) { */
/*     int nRuns=2; */
/*     Ddi_Bdd_t *fDup = Ddi_BddDup(fAig); */
/*     Ddi_Bdd_t *fEurDup = Ddi_BddDup(fAig); */
/*     fEur1 = Ddi_BddDup(fAig); */
/*     fEur2 = Ddi_BddDup(fAig); */
/*     fEur3 = Ddi_BddDup(fAig); */
/*     fEur4 = Ddi_BddDup(fAig); */

/*     do { */
/*       int size2 = -1; */
/*       bAig_array_t *cachedNodes = bAigArrayAlloc(); */
/*       size1 = Ddi_BddSize(fAig); */
/*       if (size1<800) { */
/* 	optFactor = 2.0; */
/*       } */
/*       if (size1<500) { */
/* 	optFactor = 1.0; */
/*       } */
/*       if (size1 > 500 && Ddi_MgrReadAigAbcOptLevel(ddm)>0) { */
/*         ddiAbcOptAcc (fAig,timeLimit/2); */
/* 	size2 = Ddi_BddSize(fAig); */
/*       } */
/*       if (redRem>0 && ((size2 < 0 && size1 < maxSize)  */
/* 		       || ((size2 > (0.9*size1)) && size2 < maxSize))) { */
/* 	if (nRuns > 0) { */
/* 	  int mySize = Ddi_BddSize(fAig); */
/* 	  int doApprOnAbort=0; */
/* 	  Ddi_Bdd_t *saveAig=NULL; */
/* 	  nRuns--; */
/*           int maxCut;  */
/* 	  if (mySize>10000) { */
/* 	    optFactor = mySize/3000;  */
/* 	    useObserveDC = 0; */
/* 	  } */
/* 	  maxCut = (int)(mySize/optFactor); */
/* 	  //	  maxObserve = (int)(maxCut*3); */
/* 	  if (redRem>3) { */
/* 	    doApprOnAbort=1; */
/* 	    saveAig = Ddi_BddDup(fAig); */
/* 	  } */

/* 	  //          DdiAigCheckRedFull(fAig,care); */
/* 	  if (0&&mySize>=5000) { */
/* 	    AigRedRemovalIncrByControlClasses(fAig, care, timeLimit); */
/* 	  } */
/* 	  mySize = Ddi_BddSize(fAig); */
/* 	  if (1||mySize<5000) { */
/* 	    int incrByRef = ddm->settings.aig.satIncrByRefinement; */
/* 	    if (0&&incrByRef>=1) { */
/* 	      ddm->settings.aig.satIncrByRefinement=1; */
/* 	    } */
/* 	    if (ddm->settings.aig.satIncrByRefinement==1) { */
/*               AigRedRemovalIncrementalAcc (fAig,care,maxCut,maxObserve, */
/* 					   cachedNodes,timeLimit,doApprOnAbort,useObserveDC,0); */
/* 	    } */
/*             AigRedRemovalIncrementalAcc (fAig,care,maxCut,maxObserve, */
/* 					 cachedNodes,timeLimit,doApprOnAbort,useObserveDC,1); */
/* 	    ddm->settings.aig.satIncrByRefinement=incrByRef; */
/* 	  } */
/* #if 0 */
/* 	  if(eur==0){ */
/* 	    fprintf(dMgrO(ddm),"\nBdd size before heuristic(0) = %d\n", Ddi_BddSize(fAig)); */
/* 	    stdCpuTime = util_cpu_time (); */
/* 	    AigRedRemovalIncrementalAcc (fAig,care,maxCut,maxObserve,cachedNodes,timeLimit,doApprOnAbort,useObserveDC,1/\*,0*\/); */
/* 	    stdCpuTimeTot += util_cpu_time () - stdCpuTime; */
/* 	    fprintf(dMgrO(ddm),"Bdd size after heuristic(0) = %d\n", Ddi_BddSize(fAig)); */
/* 	    //printf("heuristic(0) [all nodes] partial execution time = %.2f\n", (util_cpu_time () - stdCpuTime) / 1000.0); */
/* 	  }	   */

/* 	  if(eur==1){ */
/* 	    fprintf(dMgrO(ddm),"Bdd size before heuristic(1) = %d\n", Ddi_BddSize(fEur1)); */
/* 	    rndCpuTime = util_cpu_time (); */
/* 	    AigRedRemovalIncrementalAcc (fEur1,care,maxCut,maxObserve,cachedNodes,timeLimit,doApprOnAbort,useObserveDC,1/\*,1*\/); */
/* 	    rndCpuTimeTot += util_cpu_time () - rndCpuTime; */
/* 	    fprintf(dMgrO(ddm),"Bdd size after heuristic(1) = %d\n", Ddi_BddSize(fEur1)); */
/* 	    //printf("heuristic(1) [rnd nodes] partial execution time = %.2f\n", (util_cpu_time () - rndCpuTime) / 1000.0); */
/* 	  }   */

/* 	  if(eur==2){ */
/* 	    fprintf(dMgrO(ddm),"Bdd size before heuristic(2) = %d\n", Ddi_BddSize(fEur2)); */
/* 	    foutCpuTime = util_cpu_time (); */
/* 	    AigRedRemovalIncrementalAcc (fEur2,care,maxCut,maxObserve,cachedNodes,timeLimit,doApprOnAbort,useObserveDC,1/\*,2*\/); */
/* 	    foutCpuTimeTot += util_cpu_time () - foutCpuTime; */
/* 	    fprintf(dMgrO(ddm),"Bdd size after heuristic(2) = %d\n", Ddi_BddSize(fEur2)); */
/* 	    //printf("heuristic(2) [fout count] partial execution time = %.2f\n", (util_cpu_time () - foutCpuTime) / 1000.0); */
/* 	  }	   */

/* 	  if(eur==3){ */
/* 	    fprintf(dMgrO(ddm),"Bdd size before heuristic(3) = %d\n", Ddi_BddSize(fEur3)); */
/* 	    piCpuTime = util_cpu_time (); */
/* 	    AigRedRemovalIncrementalAcc (fEur3,care,maxCut,maxObserve,cachedNodes,timeLimit,doApprOnAbort,useObserveDC,1/\*,3*\/); */
/* 	    piCpuTimeTot += util_cpu_time () - piCpuTime; */
/* 	    fprintf(dMgrO(ddm),"Bdd size after heuristic(3) = %d\n", Ddi_BddSize(fEur3)); */
/* 	    //printf("heuristic(3) [pi + pi fout] partial execution time = %.2f\n", (util_cpu_time () - piCpuTime) / 1000.0); */
/* 	  } */

/* 	  if(eur==4){ */
/* 	    fprintf(dMgrO(ddm),"Bdd size before heuristic(4) = %d\n", Ddi_BddSize(fEur4)); */
/* 	    DomCpuTime = util_cpu_time (); */
/* 	    AigRedRemovalIncrementalAcc (fEur4,care,maxCut,maxObserve,cachedNodes,timeLimit,doApprOnAbort,useObserveDC,1/\*,4*\/); */
/* 	    DomCpuTimeTot += util_cpu_time () - DomCpuTime; */
/* 	    fprintf(dMgrO(ddm),"Bdd size after heuristic(4) = %d\n", Ddi_BddSize(fEur4)); */
/* 	    //printf("heuristic(4) [Dom] partial execution time = %.2f\n", (util_cpu_time () - DomCpuTime) / 1000.0); */
/* 	  } */
/* #endif */
/* 	  if (0 && doApprOnAbort) { */
/* 	    Ddi_Bdd_t *f0 = Ddi_BddDup(saveAig); */
/* 	    Ddi_Bdd_t *f1 = Ddi_BddDup(saveAig); */
/* 	    Ddi_Bdd_t *c0 = Ddi_BddNot(fAig); */
/* 	    Ddi_Bdd_t *c1 = Ddi_BddDup(fAig); */
/* 	    if (care != NULL) { */
/* 	      Ddi_BddAndAcc(c0,care); */
/* 	      Ddi_BddAndAcc(c1,care); */
/* 	    } */
/*             for (i=0; i<cachedNodes->num; i++) { */
/*               bAigEdge_t baig = cachedNodes->nodes[i]; */
/*               bAig_CacheAig(bmgr,baig) = bAig_NULL; */
/*               bAig_RecursiveDeref(bmgr,baig); */
/*             }      */
/*             AigRedRemovalIncrementalAcc (f0,c0, */
/* 										 maxCut,maxObserve,cachedNodes,timeLimit,0,1,0/\*,eur*\/); */
/*             for (i=0; i<cachedNodes->num; i++) { */
/*               bAigEdge_t baig = cachedNodes->nodes[i]; */
/*               bAig_CacheAig(bmgr,baig) = bAig_NULL; */
/*               bAig_RecursiveDeref(bmgr,baig); */
/*             }      */
/*             AigRedRemovalIncrementalAcc (f1,c1, */
/* 										 maxCut,maxObserve,cachedNodes,timeLimit,0,1,0/\*,eur*\/); */
/*             for (i=0; i<cachedNodes->num; i++) { */
/*               bAigEdge_t baig = cachedNodes->nodes[i]; */
/*               bAig_CacheAig(bmgr,baig) = bAig_NULL; */
/*               bAig_RecursiveDeref(bmgr,baig); */
/*             }      */
/* 	    Ddi_BddDiffAcc(f0,saveAig); */
/* 	    Ddi_BddAndAcc(f1,saveAig); */
/* 	    Ddi_BddOrAcc(f0,f1); */
/*             AigRedRemovalIncrementalAcc (f0,care, */
/* 										 maxCut,maxObserve,cachedNodes,timeLimit,0,1,0/\*,eur*\/); */
/*             for (i=0; i<cachedNodes->num; i++) { */
/*               bAigEdge_t baig = cachedNodes->nodes[i]; */
/*               bAig_CacheAig(bmgr,baig) = bAig_NULL; */
/*               bAig_RecursiveDeref(bmgr,baig); */
/*             }      */
/* 	    Ddi_Free(c0); */
/* 	    Ddi_Free(c1); */
/* 	    Ddi_Free(f1); */
/* 	    if (Ddi_BddSize(f0) < Ddi_BddSize(saveAig)) { */
/*               DdiGenericDataCopy((Ddi_Generic_t *)saveAig,(Ddi_Generic_t *)f0); */
/* 	    } */
/* 	    Ddi_Free(f0); */
/*             DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)saveAig); */
/* 	    Ddi_Free(saveAig); */
/* 	  } */
/*    	  if (Ddi_BddSize(fAig)<mySize*0.95) { */
/* 	    nRuns=2; /\* reset runs *\/ */
/* 	  } */
/*           if (timeLimit >= 0 &&  */
/* 	      ((util_cpu_time () - startTimeTot)/1000.0 > 2*timeLimit)) { */
/*             optFactor = 0; */
/*           } */
/* 	} */
/*       } */
/*       for (i=0; i<cachedNodes->num; i++) { */
/*         bAigEdge_t baig = cachedNodes->nodes[i]; */
/*         bAig_CacheAig(bmgr,baig) = bAig_NULL; */
/*         bAig_RecursiveDeref(bmgr,baig); */
/*       }     */
/*       bAigArrayFree(cachedNodes); */
/*       if (Ddi_BddSize(fAig) < 0.95 * size1 && optFactor > 1) { */
/*         optFactor *= 0.5; */
/*       } */

/*     } while (Ddi_BddSize(fAig) < 0.99 * size1 && optFactor > 0); */

/*     return (fAig); */

/*     if (checkResult) { */
/*       Ddi_BddXorAcc(fDup,fAig); */
/*       if (care!=NULL) { */
/* 	Ddi_BddAndAcc(fDup,care); */
/*       } */
/*       Pdtutil_Assert(!Ddi_AigSat(fDup),"Wrong heuristic(0) RED REMOVAL ph 1"); */

/*       Ddi_BddXorAcc(fEur1,fEurDup); */
/*       if (care!=NULL) { */
/* 	Ddi_BddAndAcc(fEur1,care); */
/*       } */
/*       Pdtutil_Assert(!Ddi_AigSat(fEur1),"Wrong heuristic(1) RED REMOVAL ph 1"); */

/*       Ddi_BddXorAcc(fEur2,fEurDup); */
/*       if (care!=NULL) { */
/* 	Ddi_BddAndAcc(fEur2,care); */
/*       } */
/*       Pdtutil_Assert(!Ddi_AigSat(fEur2),"Wrong heuristic(2) RED REMOVAL ph 1"); */

/*       Ddi_BddXorAcc(fEur3,fEurDup); */
/*       if (care!=NULL) { */
/* 	Ddi_BddAndAcc(fEur3,care); */
/*       } */
/*       Pdtutil_Assert(!Ddi_AigSat(fEur3),"Wrong heuristic(3) RED REMOVAL ph 1"); */

/*       Ddi_BddXorAcc(fEur4,fEurDup); */
/*       if (care!=NULL) { */
/* 	Ddi_BddAndAcc(fEur4,care); */
/*       } */
/*       Pdtutil_Assert(!Ddi_AigSat(fEur4),"Wrong heuristic(4) RED REMOVAL ph 1"); */
/*     } */

/*     Ddi_Free(fEur4); */
/*     Ddi_Free(fEur3); */
/*     Ddi_Free(fEur2); */
/*     Ddi_Free(fEur1); */
/*     Ddi_Free(fEurDup); */
/*     Ddi_Free(fDup); */
/*     return (fAig); */
/*   } */

/* #if 1 */
/*   doMultipleChecks = 1; */
/* #endif */

/*   if (Ddi_BddSize(fAig) > 30000) return(fAig); */

/*   enaPhase2 = 1&&(Ddi_BddSize(fAig) < 1000); */

/*   /\* the length of the two arrays must be the same *\/ */

/*   if (Ddi_BddIsConstant(fAig)) { */
/*     return (fAig); */
/*   } */

/*   bmgr = ddm->aig.mgr; */

/*   careBaig = bAig_One; */
/*   if (care != NULL) { */
/*     careBaig = Ddi_BddToBaig(care); */
/*   } */


/*   nVars = Ddi_MgrReadNumVars(ddm); */
/*   varSigs = DdiAigSignatureArrayAlloc(nVars); */
/*   DdiSetSignaturesRandom(varSigs,nVars); */
/*   /\* compute care signature *\/ */
/*   if (care==NULL) { */
/*     DdiSetSignatureConstant(&careSig,1); */
/*     if (Ddi_BddSize(fAig) > 5000) { */
/*       enaPhase2 = enEqCheck = 0; */
/*     } */
/*   } */
/*   else { */
/*     float coverRate; */
/*     bAig_array_t *careNodes = bAigArrayAlloc(); */
/*     bAigEdge_t careBaig = Ddi_BddToBaig(care); */
/*     Ddi_AigSignatureArray_t *auxSig; */
/*     int i,cover = 0; */
/*     unsigned int j; */
/*     postOrderAigVisitIntern(ddm->aig.mgr,careBaig,careNodes,-1); */
/*     postOrderAigClearVisitedIntern(ddm->aig.mgr,careNodes); */
/*     auxSig = DdiAigEvalSignature(ddm,careNodes,bAig_NULL,0,varSigs); */
/*     careSig = auxSig->sArray[careNodes->num-1]; */
/*     DdiAigSignatureArrayFree(auxSig); */
/*     bAigArrayFree(careNodes); */
/*     if (bAig_NodeIsInverted(careBaig)) { */
/*       DdiComplementSignature(&careSig); */
/*     } */
/*     for (i=0;i<DDI_AIG_SIGNATURE_SLOTS;i++) { */
/*       unsigned long mask = 1; */
/*       for (j=0;j<sizeof(unsigned long)*8;j++) { */
/* 	if (careSig.s[i] & mask) { */
/*   	  cover++; */
/* 	} */
/* 	mask = mask << 1; */
/*       } */
/*     } */
/*     coverRate = ((float)cover)/ */
/*       (sizeof(unsigned long)*8*DDI_AIG_SIGNATURE_SLOTS); */
/*     fprintf(dMgrO(ddm),"random sig in CARE %d/%d (%g)\n",cover, */
/* 	    sizeof(unsigned long)*8*DDI_AIG_SIGNATURE_SLOTS,coverRate); */
/*     if (coverRate < 0.30) { */
/*       enaPhase2 = enEqCheck = 0; */
/*     } */
/*     if (Ddi_BddSize(fAig) > 10000) { */
/*       enaPhase2 = enEqCheck = 0; */
/*     } */
/*   } */

/*   fprintf(dMgrO(ddm),"RED REMOVAL: %d -> (%d) ", size0, Ddi_BddSize(fAig));  */
/*   fflush(dMgrO(ddm)); */

/*   fBaig = Ddi_BddToBaig(fAig); */
/*   visitedNodes = bAigArrayAlloc(); */
/*   postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1); */
/*   postOrderAigClearVisitedIntern(bmgr,visitedNodes); */
/*   aigArrayClearAuxAigIntern(bmgr,visitedNodes); */

/*   /\* check redundant variables *\/ */

/*   for (i=0; i<visitedNodes->num; i++) { */
/*     bAigEdge_t baig = visitedNodes->nodes[i]; */
/*     bAig_AuxAig0(bmgr,baig) = bAig_Zero; */
/*     bAig_AuxAig1(bmgr,baig) = bAig_NonInvertedEdge(baig); */
/*     bAig_Ref(bmgr, baig); */
/*   }     */

/*   nChecks = nChecks2 = nRed = nRed2 = 0; */

/*   if (enaPhase1) { */

/*     fSig = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs); */

/*     if (!doMultipleChecks) { */
/*       for (i=0; i<visitedNodes->num; i++) { */
/* 	bAigEdge_t val, baig = visitedNodes->nodes[i]; */
/* 	Ddi_AigSignature_t sConst; */
/* 	int rem = 0; */
/* 	int phase = 0 && !bAig_NodeIsInverted(baig); */
/* 	bAigNodeComputeAuxVal(bmgr,baig,1); */
/* 	val = bAig_AuxAig1(bmgr,baig); */
/* 	if (bAig_NodeIsConstant(val)) { */
/* 	  continue; */
/* 	} */
/* 	DdiSetSignatureConstant(&sConst,phase); */
/* 	if (DdiEqSignatures(&sConst,&fSig->sArray[i],&careSig)) { */
/* 	  Ddi_Bdd_t *checkAig = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig1(bmgr,baig)); */
/* 	  if (care != NULL) { */
/* 	    Ddi_BddAndAcc(checkAig,care); */
/* 	  } */
/* 	  rem = !Ddi_AigSat(checkAig); */
/* 	  Ddi_Free(checkAig); */
/* 	  nChecks++; */
/* 	  if (rem) { */
/* 	    nRed += rem; */
/* 	    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig)); */
/* 	    bAig_AuxAig1(bmgr,baig) = bAig_Zero; */
/* 	    bAig_Ref(bmgr, bAig_Zero); */
/* 	  } */
/* 	} */
/* 	DdiSetSignatureConstant(&sConst,!phase); */
/* 	if (!(rem == 1) &&  */
/* 	    (DdiEqSignatures(&sConst,&fSig->sArray[i],&careSig))) { */
/* 	  Ddi_Bdd_t *checkAig = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig1(bmgr,baig)); */
/* 	  Ddi_BddNotAcc(checkAig); */
/* 	  if (care != NULL) { */
/* 	    Ddi_BddAndAcc(checkAig,care); */
/* 	  } */
/* 	  rem = !Ddi_AigSat(checkAig); */
/* 	  Ddi_Free(checkAig); */
/* 	  nChecks++; */
/* 	  if (rem) { */
/* 	    nRed += rem; */
/* 	    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig)); */
/* 	    bAig_AuxAig1(bmgr,baig) = bAig_One; */
/* 	    bAig_Ref(bmgr, bAig_One); */
/* 	  } */
/* 	} */
/*       } */

/*     } */
/*     else { */

/*       for (i=0; i<visitedNodes->num; i++) { */
/* 	bAigEdge_t val, baig = visitedNodes->nodes[i]; */
/* 	Ddi_AigSignature_t sConst; */
/* 	int phase = 0 && !bAig_NodeIsInverted(baig); */
/* 	val = bAig_AuxAig1(bmgr,baig); */
/* 	if (bAig_NodeIsConstant(val)) { */
/*           continue; */
/* 	} */
/* 	DdiSetSignatureConstant(&sConst,phase); */
/* 	nodeAuxChar(bmgr,baig) = 1; */
/* 	if ((i < 1000) && DdiEqSignatures(&sConst,&fSig->sArray[i],&careSig)) { */
/* 	  nodeAuxChar(bmgr,baig) = 0; */
/* 	  nChecks2++; */
/* 	} */
/*       }       */
/*       nRed2 += AigSatRedCheck(ddm,visitedNodes,careBaig,0); */
/*       for (i=0; i<visitedNodes->num; i++) { */
/* 	bAigEdge_t val, baig = visitedNodes->nodes[i]; */
/* 	Ddi_AigSignature_t sConst; */
/* 	int phase = 1 && !bAig_NodeIsInverted(baig); */
/* 	val = bAig_AuxAig1(bmgr,baig); */
/* 	if (bAig_NodeIsConstant(val)) { */
/* 	  continue; */
/* 	} */
/* 	DdiSetSignatureConstant(&sConst,phase); */
/* 	nodeAuxChar(bmgr,baig) = 1; */
/* 	if ((i < 1000) && DdiEqSignatures(&sConst,&fSig->sArray[i],&careSig)) { */
/* 	  nodeAuxChar(bmgr,baig) = 0; */
/* 	  nChecks2++; */
/* 	} */
/*       } */
/*       nRed2 += AigSatRedCheck(ddm,visitedNodes,careBaig,1); */
/*       for (i=0; i<visitedNodes->num; i++) { */
/* 	bAigEdge_t baig = visitedNodes->nodes[i]; */
/* 	nodeAuxChar(bmgr,baig) = 0; */
/*       } */


/*     } */

/*     DdiAigSignatureArrayFree(fSig); */

/*   }     */

/*   /\* intermediate result *\/ */
/*   cof1 = bAig_AuxAig1(bmgr,fBaig); */
/*   if (bAig_NodeIsInverted(fBaig)) { */
/*     cof1 = bAig_Not(cof1); */
/*   } */
/*   newfAig = Ddi_BddMakeFromBaig(ddm,cof1); */
/*   fBaig = cof1; */

/*   fprintf(dMgrO(ddm)," -> (%d) ", Ddi_BddSize(newfAig));  */
/*   fflush(dMgrO(ddm)); */

/*   for (i=0; i<visitedNodes->num; i++) { */
/*     bAigEdge_t baig = bAig_AuxAig1(bmgr,visitedNodes->nodes[i]); */
/*     if (baig != bAig_NULL && !bAig_NodeIsConstant(baig)) { */
/*       bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig)); */
/*     } */
/*   }     */
/*   aigArrayClearAuxAigIntern(bmgr,visitedNodes); */
/*   bAigArrayFree(visitedNodes); */

/*   if (enEqCheck && !Ddi_BddIsConstant(newfAig)) { */

/*     int n; */
/*     int **compareLitArray; */

/*     visitedNodes = bAigArrayAlloc(); */
/*     postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1); */
/*     postOrderAigClearVisitedIntern(bmgr,visitedNodes); */
/*     aigArrayClearAuxAigIntern(bmgr,visitedNodes); */

/*     for (i=0; i<visitedNodes->num; i++) { */
/*       bAigEdge_t baig = visitedNodes->nodes[i]; */
/*       bAig_AuxAig0(bmgr,baig) = bAig_Zero; */
/*       bAig_AuxAig1(bmgr,baig) = bAig_NonInvertedEdge(baig); */
/*       bAig_Ref(bmgr, baig); */
/*     }       */

/*     bAig_AuxAig1(bmgr,fBaig) = bAig_NonInvertedEdge(fBaig); */

/*     n = visitedNodes->num; */
/*     compareLitArray = Pdtutil_Alloc(int *, n); */

/*     fSig = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs); */

/*     for (i=0; i<visitedNodes->num; i++) { */
/*       compareLitArray[i] = NULL; */
/*     } */
/*     for (i=0; i<visitedNodes->num; i++) { */
/*       bAigEdge_t val_i, val_j, baig_i = visitedNodes->nodes[i]; */
/*       //Ddi_AigSignature_t sConst; */
/*       int size = 0, num = 0; */
/*       //int phase = 0 && !bAig_NodeIsInverted(baig_i); */
/*       val_i = bAig_AuxAig1(bmgr,baig_i); */
/*       if (bAig_NodeIsConstant(val_i)) { */
/*         continue; */
/*       } */
/*       for (j=0; j<i; j++) { */
/*         bAigEdge_t baig_j = visitedNodes->nodes[j]; */
/*         val_j = bAig_AuxAig1(bmgr,baig_j); */
/*         if (bAig_NodeIsConstant(val_j) || (val_i == val_j)) { */
/* 	  continue; */
/* 	} */
/*         if (num < 10 && DdiEqSignatures(&fSig->sArray[i],&fSig->sArray[j],&careSig)) { */
/* 	  nChecks2++; */
/* 	  if (num > size-3) { */
/*             if (size == 0) { */
/* 	      size = 4; */
/* 	      compareLitArray[i] = Pdtutil_Alloc(int,size); */
/* 	    } */
/* 	    else { */
/* 	      size *= 2; */
/* 	      compareLitArray[i] = Pdtutil_Realloc(int, */
/* 						   compareLitArray[i],size); */
/* 	    } */
/*     	  } */
/*     	  compareLitArray[i][num++] = j; */
/*     	  compareLitArray[i][num++] = 1; */
/* 	} */
/*       } */
/*       if (num>0) { */
/*         compareLitArray[i][num] = -1; */
/*       } */
/*     }       */
/*     nRed2 += AigSatRedEqCheck(ddm,visitedNodes,careBaig,compareLitArray,1); */
/*     for (i=0; i<visitedNodes->num; i++) { */
/*       Pdtutil_Free(compareLitArray[i]); */
/*     } */
/*     Pdtutil_Free(compareLitArray); */

/*     /\* intermediate result *\/ */
/*     cof1 = bAig_AuxAig1(bmgr,fBaig); */
/*     if (bAig_NodeIsInverted(fBaig)) { */
/*       cof1 = bAig_Not(cof1); */
/*     } */
/*     Ddi_Free(newfAig); */
/*     newfAig = Ddi_BddMakeFromBaig(ddm,cof1); */
/*     fBaig = cof1; */

/*     fprintf(dMgrO(ddm)," -> <%d> ", Ddi_BddSize(newfAig));  */
/*     fflush(dMgrO(ddm)); */

/*     for (i=0; i<visitedNodes->num; i++) { */
/*       bAigEdge_t baig = bAig_AuxAig1(bmgr,visitedNodes->nodes[i]); */
/*       if (baig != bAig_NULL && !bAig_NodeIsConstant(baig)) { */
/*         bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig)); */
/*       } */
/*     }     */
/*     aigArrayClearAuxAigIntern(bmgr,visitedNodes); */
/*     bAigArrayFree(visitedNodes); */

/*     if (0&&nRed2) { */
/*       Ddi_Bdd_t *tmp = Ddi_BddXor(newfAig,fAig); */
/*       Ddi_BddAndAcc(tmp,care); */
/*       Pdtutil_Assert(!Ddi_AigSat(tmp),"Wrong RED REMOVAL ph 1"); */
/*       Ddi_Free(tmp); */
/*     } */

/*     DdiAigSignatureArrayFree(fSig); */
/*   } */

/*   if (!Ddi_BddIsConstant(newfAig)) { */

/*     visitedNodes = bAigArrayAlloc(); */
/*     postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1); */
/*     postOrderAigClearVisitedIntern(bmgr,visitedNodes); */
/*     aigArrayClearAuxAigIntern(bmgr,visitedNodes); */

/*     bAig_AuxAig1(bmgr,fBaig) = bAig_NonInvertedEdge(fBaig); */
/*     bAig_Ref(bmgr, fBaig); */

/*     for (i=0; i<visitedNodes->num; i++) { */
/*       bAigEdge_t baig = visitedNodes->nodes[i]; */
/*       bAig_AuxAig0(bmgr,baig) = bAig_Zero; */
/*       bAig_AuxAig1(bmgr,baig) = bAig_NonInvertedEdge(baig); */
/*       bAig_Ref(bmgr, baig); */
/*     }     */

/*     if (enaPhase2) { */

/*       for (i=0; i<visitedNodes->num; i++) { */
/* 	bAigEdge_t baig = visitedNodes->nodes[i]; */
/* 	bAig_AuxRef(bmgr,baig) = 0; */

/* 	if (!(bAig_NodeIsConstant(baig))) { */
/* 	  bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig); */
/* 	  bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig); */
/* 	  bAig_AuxRef(bmgr,right)++; */
/* 	  bAig_AuxRef(bmgr,left)++; */
/* 	} */
/*       } */

/*       for (i=0; i<visitedNodes->num; i++) { */
/* 	bAigEdge_t baig = visitedNodes->nodes[i]; */
/* 	int rem = 0, last = visitedNodes->num-1; */

/* #if 1 */
/* 	if (bAig_AuxRef(bmgr,baig) == 1) { */
/* #else */
/* 	  if (!bAig_isVarNode(bmgr,baig)) { */
/* #endif */
/* 	    continue; */
/* 	  } */
/* 	  if (bAig_NodeIsConstant(bAig_AuxAig1(bmgr,baig))) { */
/* 	    continue; */
/* 	  } */

/* 	  fSig = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs); */
/* 	  fSig1 = DdiAigEvalSignature(ddm,visitedNodes,baig,1,varSigs); */

/* 	  rem = 0; */
/* 	  if (0||DdiEqSignatures(&fSig1->sArray[last],&fSig->sArray[last],&careSig)) { */
/* 	    int currSigBit = varSigs->currBit; */
/* 	    rem = existOptMergeIntern(ddm,visitedNodes, */
/* 				      i,-1/\*mergedirection*\/,1,0,careBaig,varSigs); */
/* 	    if (currSigBit != varSigs->currBit) { */
/* 	      DdiSetSignatureBit(&careSig,currSigBit,1); */
/* 	    } */
/* 	    if (rem >= 0) { */
/* 	      nChecks++; */
/* 	      nRed += rem; */
/* 	      /\*        fprintf(dMgrO(ddm),rem ? "-" : "="); fflush(dMgrO(ddm));*\/ */
/* 	    } */
/* 	  } */
/* 	  DdiAigSignatureArrayFree(fSig); */
/* 	  DdiAigSignatureArrayFree(fSig1); */
/* 	  if (!(rem == 1)) { */
/* 	    fSig = DdiAigEvalSignature(ddm,visitedNodes,bAig_NULL,0,varSigs); */
/* 	    fSig1 = DdiAigEvalSignature(ddm,visitedNodes,baig,0,varSigs); */
/* 	    if (0||DdiEqSignatures(&fSig1->sArray[last],&fSig->sArray[last],&careSig)) { */
/* 	      int currSigBit = varSigs->currBit; */
/* 	      rem = existOptMergeIntern(ddm,visitedNodes, */
/* 					i,-1/\*mergedirection*\/,0,0,careBaig,varSigs); */
/* 	      if (currSigBit != varSigs->currBit) { */
/* 		DdiSetSignatureBit(&careSig,currSigBit,1); */
/* 	      } */
/* 	      if (rem >= 0) { */
/* 		nChecks++; */
/* 		nRed += rem; */
/* 		//          fprintf(dMgrO(ddm),rem ? "-" : "="); fflush(dMgrO(ddm)); */
/* 	      } */
/* 	    } */
/* 	    DdiAigSignatureArrayFree(fSig); */
/* 	    DdiAigSignatureArrayFree(fSig1); */
/* 	  } */
/* 	  if (0&&rem == 1) { */
/* 	    Ddi_Bdd_t *tmp; */
/* 	    cof1 = bAig_AuxAig1(bmgr,fBaig); */
/* 	    if (bAig_NodeIsInverted(fBaig)) { */
/* 	      cof1 = bAig_Not(cof1); */
/* 	    } */
/* 	    tmp = Ddi_BddMakeFromBaig(ddm,cof1); */
/* 	    Ddi_BddXorAcc(tmp,fAig); */
/* 	    Ddi_BddAndAcc(tmp,care); */
/* 	    Pdtutil_Assert(!Ddi_AigSat(tmp),"Wrong RED REMOVAL ph 1"); */
/* 	    Ddi_Free(tmp); */
/* 	  } */
/* 	}     */

/*       } */

/*       DdiAigSignatureArrayFree(varSigs); */

/* #if 0 */
/*       /\* recompute *\/ */

/*       for (i=0; i<visitedNodes->num; i++) { */
/* 	bAigNodeComputeAuxVal(bmgr,visitedNodes->nodes[i],1); */
/*       }     */
/* #endif */

/*       cof1 = bAig_AuxAig1(bmgr,fBaig); */

/*       cof1Aig = Ddi_BddMakeFromBaig(ddm,cof1); */

/*       Ddi_Free(newfAig); */
/*       newfAig = Ddi_BddDup(cof1Aig); */
/*       if (bAig_NodeIsInverted(fBaig)) { */
/* 	Ddi_BddNotAcc(newfAig); */
/*       } */

/*       existClearVisitedIntern(bmgr,fBaig); */

/*       Ddi_Free(cof1Aig); */

/*       for (i=0; i<visitedNodes->num; i++) { */
/* 	bAigEdge_t baig = bAig_AuxAig1(bmgr,visitedNodes->nodes[i]); */
/* 	if (baig != bAig_NULL) { */
/* 	  bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig)); */
/* 	} */
/*       }     */
/*       aigArrayClearAuxAigIntern(bmgr,visitedNodes); */
/*       bAigArrayFree(visitedNodes); */

/*       if (0&&!enaPhase2) { */

/* 	cof0Aig = Ddi_BddDup(newfAig); */

/* 	for (val=0; val<2; val++) */
/* 	  { */
/* 	    int k; */
/* 	    Ddi_Varset_t *supp = Ddi_BddSupp(newfAig);  */
/* 	    Ddi_Vararray_t *vAtot = Ddi_VararrayMakeFromVarset(supp,1); */

/* 	    Ddi_Vararray_t *vA = NULL; */

/* 	    for (k=0; k<Ddi_VararrayNum(vAtot); k++) { */
/* 	      Ddi_Var_t *v=Ddi_VararrayRead(vAtot,k); */
/* 	      if (vA == NULL) { */
/* 		vA = Ddi_VararrayAlloc(ddm,0); */
/* 	      } */
/* 	      Ddi_VararrayInsertLast(vA,v); */
/* 	      if (k==(Ddi_VararrayNum(vAtot)-1)) { */
/* 		Ddi_Bddarray_t *checks = Ddi_BddarrayAlloc(ddm,0); */
/* 		int *satArray; */
/* 		int *satArray2; */
/* 		int i; */

/* 		Ddi_Free(supp); */
/* 		for (i=0; i<Ddi_VararrayNum(vA); i++) { */
/* 		  Ddi_Var_t *v = Ddi_VararrayRead(vA,i); */
/* 		  Ddi_Bdd_t *chk = Ddi_BddCofactor(newfAig,v,val); */
/* 		  Ddi_BddXorAcc(chk,newfAig); */
/* 		  Ddi_BddarrayWrite(checks,i,chk); */
/* 		  Ddi_Free(chk); */
/* 		} */
/* 		printf("[%d] ",Ddi_BddarraySize(checks)); fflush(dMgrO(ddm)); */
/* 		satArray = Ddi_AigSatMultiple(checks,care); */
/* 		satArray2 = Ddi_AigSatMultipleMinisat(checks,care); */
/* 		for (i=0; i<Ddi_VararrayNum(vA); i++) { */
/* 		  Pdtutil_Assert(satArray[i]==satArray2[i],"Invalid minisat multiple res"); */
/* 		} */

/* 		for (i=0; i<Ddi_VararrayNum(vA); i++) { */
/* 		  Ddi_Var_t *v = Ddi_VararrayRead(vA,i); */
/* #if 0 */
/* 		  Ddi_Bdd_t *c = Ddi_BddDup(Ddi_BddarrayRead(checks,i)); */
/* 		  if (care != NULL) { */
/* 		    Ddi_BddAndAcc(c,care); */
/* 		  } */
/* 		  Pdtutil_Assert(Ddi_AigSat(c)==satArray[i],"multiple SAT error"); */
/* 		  Ddi_Free(c); */
/* #endif */
/* 		  if (satArray[i]==0) { */
/* 		    Ddi_BddCofactorAcc(newfAig,v,val); */
/* 		  } */
/* 		} */
/* 		Ddi_Free(checks); */
/* 		Pdtutil_Free(satArray); */
/* 		Ddi_Free(vA); */

/* 		if (0) */
/* 		  { */
/* 		    Ddi_Bdd_t *c = Ddi_BddXor(cof0Aig,newfAig); */
/* 		    if (care != NULL) { */
/* 		      Ddi_BddAndAcc(c,care); */
/* 		    } */
/* 		    Pdtutil_Assert(!Ddi_AigSat(c),"multiple SAT opt error"); */
/* 		    Ddi_Free(c); */
/* 		  } */

/* 	      } */
/* 	    } */
/* 	    Ddi_Free(vAtot); */
/* 	  } */

/* 	Ddi_Free(cof0Aig); */

/*       } */

/*     } */


/*     if (bddCompare) { */
/*       Ddi_Bdd_t *tmp = Ddi_BddMakeMono(fAig); */
/*       Ddi_Bdd_t *tmp1 = Ddi_BddMakeMono(newfAig); */
/*       Ddi_Bdd_t *c = Ddi_BddMakeMono(care); */
/*       Ddi_BddAndAcc(tmp,c); */
/*       Ddi_BddAndAcc(tmp1,c); */
/*       Pdtutil_Assert(Ddi_BddEqual(tmp1,tmp), */
/* 		     "Wrong result of AIG RED REM."); */
/*       Ddi_Free(tmp); */
/*       Ddi_Free(tmp1); */
/*       Ddi_Free(c); */
/*     } */
/*     else if (1) { */
/*       Ddi_Bdd_t *f1Bdd = Ddi_BddDup(newfAig); */
/*       Ddi_BddXorAcc(f1Bdd,fAig); */
/*       if (care!=NULL) {  */
/* 	Ddi_BddAndAcc(f1Bdd,care); */
/*       } */
/*       Pdtutil_Assert(!Ddi_AigSat(f1Bdd),"Wrong RED REMOVAL"); */
/*       Ddi_Free(f1Bdd); */
/*     } */



/*     DdiGenericDataCopy((Ddi_Generic_t *)fAig,(Ddi_Generic_t *)newfAig); */
/*     Ddi_Free(newfAig); */
/*     Ddi_MgrCheckExtRef(ddm,extRef); */

/*     fprintf(dMgrO(ddm)," %d (red/checks = (%d+%d)/(%d+%d))\n", */
/* 	    Ddi_BddSize(fAig), nRed, nRed2, nChecks, nChecks2); */

/*     return(fAig); */
/*   } */

/*   /\*Versione locale*\/ */

int
AigCustom910CombinationalCircuit_cleanDV(
  Ddi_Mgr_t *ddm,
  char *filename,
  int method,
  int compl_invarspec,
  int cntReachedOK,
  int ibmFormat
){

  Ddi_Bddarray_t *benchArray;
  Ddi_Bdd_t *f, *care;
  long startTime, endTime;
  int size, sizeNew;
  int wSize;
  int doPart=1;
  int doMonotone = 0;
  int decomp = 0;
  int tryVars = 0;
  int tryPart = 0;
  int tryForall = 1;

  assert(method == 9 || method == 10 || method == 13);

  ddm->settings.aig.satIncrByRefinement = method;
  /* FIXME: seg fualt due to the fake ITP and method == 10
     the solution is to read/load also the second itp file!
   */
  assert( !(method == 10 && ibmFormat == 1));

  if (ibmFormat) {
    Ddi_Bddarray_t *ibmArray = Ddi_AigarrayNetLoadAiger(ddm,NULL,filename);
    int no = Ddi_BddarrayNum(ibmArray);
    Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Bdd_t *b = Ddi_BddarrayExtract(ibmArray,Ddi_BddarrayNum(ibmArray)-1);
    Ddi_Bdd_t *a = Ddi_BddMakePartConjFromArray(ibmArray);
    Ddi_BddSetAig(a);
    Ddi_Free(ibmArray);
    benchArray = Ddi_BddarrayAlloc(ddm, 3);
    Ddi_BddarrayWrite(benchArray,0,myOne); /* fake itp: not to be used */
    Ddi_BddarrayWrite(benchArray,1,a);
    Ddi_BddarrayWrite(benchArray,2,b);

    Ddi_Free(a);
    Ddi_Free(b);
    Ddi_Free(myOne);
  }
  else {
    benchArray = Ddi_AigarrayNetLoadAiger(ddm,NULL,filename);
  }

  assert(benchArray != NULL);


  Ddi_Bdd_t *itp = Ddi_BddDup(Ddi_BddarrayRead(benchArray, (method<=13) ? 0 : 2 ));
  Ddi_Varset_t *suppITP = Ddi_BddSupp(itp);
  char fileOut[1000];
  char *c = NULL;
  Ddi_Bdd_t *myCare = NULL;
  int doItp = 0;
  // int n = Ddi_BddarrayNum(benchArray);
  // Ddi_Bdd_t *a = n>1 ? Ddi_BddarrayRead(benchArray,1) : NULL;
  // Ddi_Bdd_t *b = n>2 ? Ddi_BddarrayRead(benchArray,2) : NULL;
  int enBddOpt;
  int itpCoreTh = ddm->settings.aig.itpAigCore, itpSize;

  if(method == 9 || method == 13){
    doItp = 1;
  }

  printf("Initial AIG size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));

  if (Ddi_BddarrayNum(benchArray)>3) {
    myCare = Ddi_BddDup(Ddi_BddarrayRead(benchArray,3));
  } else {
    myCare = Ddi_BddMakeConstAig(ddm,1);
  }

  if (!doItp) {
    Ddi_AigStructRedRemAcc (itp,NULL);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c, printf("TOT aig after struct rr: %d)\n", Ddi_MgrReadAigNodesNum(ddm)) );
    ddiAbcOptAcc (itp,-1);
    printf("ABC opt size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));
  }
  //  Ddi_AigSift(itp,NULL);

  Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
  Ddi_MgrSetSiftThresh (ddm, 100000);

  if (doItp) {
    int sat;
    Ddi_Bdd_t *A = Ddi_BddarrayRead(benchArray,1);
    Ddi_Bdd_t *B = Ddi_BddarrayRead(benchArray,2);
    Ddi_Varset_t *suppInterpolant;
    Ddi_Varset_t *suppA = Ddi_BddSupp(A);
    Ddi_Varset_t *suppB = Ddi_BddSupp(B);
    Ddi_Varset_t *glob = Ddi_VarsetIntersect(suppA,suppB);
    Ddi_Vararray_t *gv = Ddi_VararrayMakeFromVarset(  suppB , 1);

    Ddi_Bdd_t *interpolant;
    int i, itpPart = 0; //-(method-5);

    for (i=0; i<Ddi_VararrayNum(gv); i++) {
      if (strstr(Ddi_VarName(Ddi_VararrayRead(gv,i)),"$NS")!=NULL)
	Ddi_VarsetAddAcc(glob,Ddi_VararrayRead(gv,i));
    }

    startTime = util_cpu_time();
    printf("\nComputing interpolant!!!\n");
    //      b = Ddi_BddPartRead(bPart,0);
#if 0
    interpolant = Ddi_AigSatAndWithInterpolant(A,B,glob,NULL,myCare,NULL,
					       NULL,NULL,
					       &sat,itpPart,1,-1.0);
#else
    interpolant = Ddi_AigSat22AndWithInterpolant(NULL,A,B,NULL,glob,NULL,NULL,0,myCare,NULL,
                                         &sat,itpPart,1,0,-1.0);
#endif
    endTime = util_cpu_time();
    Pdtutil_Assert(interpolant!=NULL,"non null itp required");
    printf("ITP(%d,%d,%d) -> %d\n", Ddi_BddSize(A),Ddi_BddSize(B),care==NULL?0:Ddi_BddSize(care), Ddi_BddSize(interpolant));
    fprintf(dMgrO(ddm),"Execution time = %s)\n", util_print_time(endTime-startTime));

    Ddi_AigStructRedRemAcc (interpolant,NULL);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c, printf("TOT aig after struct rr: %d)\n", Ddi_MgrReadAigNodesNum(ddm)) );

    ddiAbcOptAcc (interpolant,-1);
    suppInterpolant = Ddi_BddSupp(interpolant);
    printf("ABC opt size: %d - supp: %d\n", Ddi_BddSize(interpolant), Ddi_VarsetNum(suppInterpolant) );
    Ddi_Free(suppInterpolant);

    if (method != 13){

      if( strrchr(filename,'.') !=NULL ){
	strcpy(fileOut,filename);
	c=strrchr(fileOut,'.');
	strcpy(c,"_AIGOUT.aig");
      }else{
	sprintf(fileOut, "%s_AIGOUT.aig", filename);
      }

      FILE* fpt_aigout;
      fpt_aigout=fopen(fileOut, "r");
      if( fpt_aigout!=NULL ){
	c=strrchr(fileOut,'.');
	strcpy(c,"_OPT.aig");
	fclose(fpt_aigout);
      }

      suppInterpolant = Ddi_BddSupp(interpolant);
      printf("Final AIG size: %d - supp: %d\n", Ddi_BddSize(interpolant), Ddi_VarsetNum(suppInterpolant));
      Ddi_Free(suppInterpolant);

      assert(interpolant != NULL);
      Ddi_BddarrayWrite(benchArray,0,interpolant);
      Ddi_AigarrayNetStoreAiger(benchArray, 0, fileOut);

      printf("Final ITP written in %s\n",fileOut);

      Ddi_Free(benchArray);
      Ddi_Free(f);
      Ddi_Free(care);

      Ddi_Free(itp);
      Ddi_Free(suppITP);
      Ddi_Free(myCare);

      Ddi_Free(interpolant);
      Ddi_Free(suppInterpolant);

      Ddi_Free(suppA);
      Ddi_Free(suppB);
      Ddi_Free(glob);
      Ddi_Free(gv);

      return 1;

    }else{

      Ddi_Free(itp);
      itp =  Ddi_BddDup(interpolant);

      Ddi_Free(suppInterpolant);
      Ddi_Free(interpolant);

      Ddi_Free(suppA);
      Ddi_Free(suppB);
      Ddi_Free(glob);
      Ddi_Free(gv);
    }

  }

  Ddi_BddSetAig(itp);

  if (1) {
    Ddi_Varset_t *suppTMP = Ddi_BddSupp(itp);
    enBddOpt = Ddi_VarsetNum(suppTMP) <= Ddi_MgrReadAigBddOptLevel (ddm)*60;
    Ddi_Free(suppTMP);
  }

  int bddDone = 0;
  if (enBddOpt) {
    bddDone = Ddi_AigOptByBdd(itp,-1,500000) > 0;
  }
  if (!bddDone) {
    Ddi_AigOptByFoCntTop(itp, NULL, 0);
  }

  if (tryForall) {
    int again = 1;
    Ddi_Bdd_t *A = Ddi_BddarrayRead(benchArray,1);
    Ddi_Bdd_t *B = Ddi_BddarrayRead(benchArray,2);
    Ddi_Varset_t *suppA = Ddi_BddSupp(A);
    Ddi_Varset_t *suppB = Ddi_BddSupp(B);
    Ddi_Varset_t *glob = Ddi_VarsetIntersect(suppA,suppB);
    Ddi_Varset_t *loc = Ddi_VarsetDiff(suppB,suppA);
    Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(glob,1);
    Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Bdd_t *myItp = Ddi_BddDup(itp);
    Ddi_Free(loc);
    Ddi_Free(glob);
    Ddi_Free(suppA);
    Ddi_Free(suppB);
    int sat = 0;

    Ddi_Bdd_t *myA = Ddi_BddDup(A);
    Ddi_Bdd_t *myB = Ddi_BddDup(B);
    Ddi_Bdd_t *myI = Ddi_BddDup(itp);

    Ddi_Bdd_t *i2 = Ddi_AigSatAndWithInterpolant(myB,myI,glob,NULL,myCare,NULL,
					       NULL,NULL,
					       &sat,0,1,-1.0);


    Ddi_AigOptByMonotoneCoreAcc (myI,i2,NULL,0,-1.0);
    Ddi_Free(i2);
    //    Ddi_AigOptByMonotoneCoreWithForallAcc (myI,myB,NULL,0,-1.0);
      //      Ddi_AigOptByMonotoneCoreAcc (myI,A,NULL,1,-1.0);
    Ddi_BddOrAcc(myItp,myI);
    Ddi_AigOptByMonotoneCoreAcc (myItp,A,NULL,1,-1.0);


    Ddi_Free(myB);
    Ddi_Free(myA);
    Ddi_Free(myI);

    Ddi_Free(vA);
    Ddi_Free(myCare);
    Ddi_DataCopy(itp,myItp);
    Ddi_Free(myItp);
  }

  if (tryPart) {
    int again = 1;
    Ddi_Bdd_t *A = Ddi_BddarrayRead(benchArray,1);
    Ddi_Bdd_t *B = Ddi_BddarrayRead(benchArray,2);
    Ddi_Varset_t *suppA = Ddi_BddSupp(A);
    Ddi_Varset_t *suppB = Ddi_BddSupp(B);
    Ddi_Varset_t *glob = Ddi_VarsetIntersect(suppA,suppB);
    Ddi_Varset_t *loc = Ddi_VarsetDiff(suppB,suppA);
    Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(glob,1);
    Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Bdd_t *myItp = Ddi_BddMakeConstAig(ddm,0);
    Ddi_Free(loc);
    Ddi_Free(glob);
    Ddi_Free(suppA);
    Ddi_Free(suppB);
    while (1) {
      int i, maxp = 10;
      Ddi_Bdd_t *myW =
	Ddi_AigSatAndWithCexAndAbort(A,myCare,NULL,vA,-1.0,NULL);
      if (myW == NULL) {
	break;
      }
      Ddi_Bdd_t *myA = Ddi_BddDup(A);
      Ddi_Bdd_t *myB = Ddi_BddDup(B);
      Ddi_Bdd_t *myI = Ddi_BddDup(itp);
      Ddi_Bdd_t *p = Ddi_AigPartitionTop(myW,0);
      Ddi_Free(myW);
      myW = Ddi_BddMakeConstAig(ddm,1);
      for (i=0; i<Ddi_BddPartNum(p) && i<maxp; i++) {
	Ddi_BddAndAcc(myW,Ddi_BddPartRead(p,i));
      }
      Ddi_Free(p);
      Ddi_AigConstrainCubeAcc(myI,myW);
      Ddi_AigConstrainCubeAcc(myB,myW);
      printf("PartItp: %d -> %d\n", Ddi_BddSize(itp), Ddi_BddSize(myI));
      printf("PartB  : %d -> %d\n", Ddi_BddSize(B), Ddi_BddSize(myB));
      Ddi_AigOptByMonotoneCoreAcc (myI,myB,NULL,0,-1.0);
      //      Ddi_AigOptByMonotoneCoreAcc (myI,A,NULL,1,-1.0);
      Ddi_AigAndCubeAcc(myI,myW);
      Ddi_AigOptByMonotoneCoreAcc (myI,B,NULL,0,-1.0);
      Ddi_BddOrAcc(myItp,myI);
      Ddi_BddDiffAcc(myCare,myI);
      Ddi_Free(myW);
      Ddi_Free(myB);
      Ddi_Free(myA);
      Ddi_Free(myI);
    }
    Ddi_Free(vA);
    Ddi_Free(myCare);
    Ddi_DataCopy(itp,myItp);
    Ddi_Free(myItp);
  }

  if (0 && tryVars) {
    int j;
    Ddi_Vararray_t *vA = Ddi_BddSuppVararray(itp);
    for (j=0; j<Ddi_VararrayNum(vA); j++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
      Ddi_Bdd_t *c0 = Ddi_BddCofactor(itp,v,0);
      int size0 = Ddi_BddSize(c0);
      Ddi_Free(c0);
      Ddi_Bdd_t *c1 = Ddi_BddCofactor(itp,v,1);
      int size1 = Ddi_BddSize(c1);
      Ddi_Free(c1);
      printf("VAR: %40s > c0: %-15d - c1: %-15d\n", Ddi_VarName(v),
	     size0, size1);
    }
    Ddi_Free(vA);
  }

  if (itp != NULL && itpCoreTh>0 && ((itpSize = Ddi_BddSize(itp)) > itpCoreTh)) {
    Ddi_Bdd_t *a = Ddi_BddarrayRead(benchArray,1);
    Ddi_AigOptByMonotoneCoreAcc (itp,a,myCare,1,-1.0);
  }

  if (itp != NULL && itpCoreTh>0 && ((itpSize = Ddi_BddSize(itp)) > itpCoreTh)) {
    Ddi_Bdd_t *b = Ddi_BddarrayRead(benchArray,2);
    Ddi_AigOptByMonotoneCoreAcc (itp,b,myCare,0,-1.0);
  }

  //disabled!! too heavy and useles (at least right now)
  if (0 && (method == 13 )){
    Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
    Ddi_MgrSetSiftThresh (ddm, 100000);
    Ddi_BddSetMono(myCare);
    AigOptByBddWithThresh(itp,myCare,1000000,1000.0,10000000);
    Ddi_AigOptByBddWithCare(itp,myCare,200.0,-1);
    printf("AIG size (after bdd opt): %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));
  }

  Ddi_Free(suppITP);
  suppITP = Ddi_BddSupp(itp);
  printf("Final AIG size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));

  //basic output filename management
  if( strrchr(filename,'.') !=NULL ){
    strcpy(fileOut,filename);
    c=strrchr(fileOut,'.');
    strcpy(c,"_AIGOUT.aig");
  }else{
    sprintf(fileOut, "%s_AIGOUT.aig", filename);
  }

  FILE* fpt_aigout;
  fpt_aigout=fopen(fileOut, "r");
  if( fpt_aigout!=NULL ){
    c=strrchr(fileOut,'.');
    strcpy(c,"_OPT.aig");
    fclose(fpt_aigout);
  }

  Ddi_AigNetStoreAiger(itp,1/*bad*/,fileOut);
  printf("Final AIG written in %s\n",fileOut);

  Ddi_Free(benchArray);
  Ddi_Free(f);
  Ddi_Free(care);

  Ddi_Free(itp);
  Ddi_Free(suppITP);
  Ddi_Free(myCare);

  return 0;
}


#if 1

#define PASINI 0

static Ddi_Bdd_t *
bddCompactByImplCofAcc (
  Ddi_Bdd_t *f,
  int maxRecur
)
{
  int j;
  Ddi_Vararray_t *vA = Ddi_BddSuppVararray(f);
  int sizeMin = Ddi_BddSize(f), jMin = -1;

  if (maxRecur < 0) return f;
  if (sizeMin < 20) return f;

  // find best var
  for (j=0; j<Ddi_VararrayNum(vA); j++) {
    Ddi_Var_t *v_j = Ddi_VararrayRead(vA,j);
    Ddi_Varset_t *sm = Ddi_VarsetMakeFromVar(v_j);
    Ddi_Bdd_t *over = Ddi_BddExist(f,sm);
    if (Ddi_BddSize(over)<sizeMin) {
      sizeMin = Ddi_BddSize(over);
      jMin = j;
    }
    Ddi_Free(over);
  }
  Ddi_Var_t *v_min = Ddi_VararrayRead(vA,jMin);
  Ddi_Bdd_t *c0 = Ddi_BddCofactor(f,v_min,0);
  Ddi_Bdd_t *c1 = Ddi_BddCofactor(f,v_min,1);
  Ddi_Bdd_t *v_lit0 = Ddi_BddMakeLiteral(v_min,0);
  Ddi_Bdd_t *v_lit1 = Ddi_BddMakeLiteral(v_min,1);
  if (Ddi_BddSize(c0) > Ddi_BddSize(c1)) {
    bddCompactByImplCofAcc (c0,maxRecur-1);
    Ddi_BddAndAcc(c1,v_lit1);
    if (!Ddi_BddIsPartDisj(c0)) {
      Ddi_BddSetPartDisj(c0);
      Ddi_BddPartInsertLast(c0,c1);
    }
    Ddi_BddSetPartConj(Ddi_BddPartRead(c0,0));
    Ddi_BddPartInsertLast(Ddi_BddPartRead(c0,0),v_lit0);
    Ddi_BddOrAcc(Ddi_BddPartRead(c0,1),c1);
    Ddi_DataCopy(f,c0);
  }
  else {
    bddCompactByImplCofAcc (c1,maxRecur-1);
    Ddi_BddAndAcc(c0,v_lit0);
    if (!Ddi_BddIsPartDisj(c1)) {
      Ddi_BddSetPartDisj(c1);
      Ddi_BddPartInsertLast(c1,c0);
    }
    Ddi_BddSetPartConj(Ddi_BddPartRead(c1,0));
    Ddi_BddPartInsertLast(Ddi_BddPartRead(c1,0),v_lit1);
    Ddi_BddOrAcc(Ddi_BddPartRead(c1,1),c0);
    Ddi_DataCopy(f,c1);
  }

  //  printf("constrained target[%d] min exist size: %d (%d+%d)\n", 
  //	 i, sizeMin, Ddi_BddSize(c0), Ddi_BddSize(c1));
  Ddi_Free(vA);

  Ddi_Free(v_lit0);
  Ddi_Free(v_lit1);
  Ddi_Free(c0);
  Ddi_Free(c1);
  return f;

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigCustomCombinationalCircuit (
  Ddi_Mgr_t *ddm,
  char *filename,
  int method,
  int compl_invarspec,
  int cntReachedOK
)
{
  Ddi_Bddarray_t *benchArray;
  Ddi_Bdd_t *f, *care;
  long startTime, endTime;
  int size, sizeNew;
  int wSize;
  int doPart=1;
  int doMonotone = 0;
  int decomp = 0;
  int ibmFormat = 0;

#if PASINI
if (method==1)
{
	// PAS - Custom #1 for TEST
	long last = util_cpu_time();
  
  /* ABC - ITP just Balance */
	Ddi_Bddarray_t *benchArray = Ddi_AigarrayNetLoadAiger(ddm,NULL,filename);
	assert(benchArray != NULL);
	Ddi_Bdd_t *itp = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 0));
	Ddi_Varset_t *suppITP = Ddi_BddSupp(itp);
	int n = Ddi_BddarrayNum(benchArray);
	Ddi_Bdd_t *a = NULL;
	Ddi_Bdd_t *b = NULL;
	if (n>1){
	  a = Ddi_BddarrayRead(benchArray,1);
	  b = Ddi_BddarrayRead(benchArray,2);
	}
	int tryExist = 1;
	if (tryExist) {
	  Ddi_Varset_t *suppA = Ddi_BddSupp(a);
	  Ddi_Varset_t *suppB = Ddi_BddSupp(b);
	  Ddi_Varset_t *glob = Ddi_VarsetIntersect(suppA,suppB);
	  DdiAigExistNnfAcc (b,NULL,glob);
	  Ddi_Free(glob);
	  Ddi_Free(suppB);
	  Ddi_Free(suppA);
	  Ddi_AigNetStoreAiger(b,1/*bad*/,"b-exist.aig");

	}


	printf("Initial AIG size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));

	// exit(-1);

	printf("Round 1\n");

  Ddi_AigNetStoreAiger(itp,1/*bad*/,"itp-pdt0.aig");
	Ddi_AigStructRedRemAcc (itp,NULL);
	long rrTime = util_cpu_time();
	fprintf(stdout, "RR_Time: %s\n", util_print_time(rrTime - last));
  last = rrTime;
  Ddi_AigNetStoreAiger(itp,1/*bad*/,"itp-pdt1.aig");
#if 0
	ddiAbcOptAcc (itp,-1);
	ddiAbcOptAcc (itp,-1);
	ddiAbcOptAcc (itp,-1);
#endif
	long abcTime = util_cpu_time();
	printf("ABC opt size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));
	fprintf(stdout, "ABC_Time: %s\n", util_print_time(abcTime - last));
  last = abcTime;

  Ddi_AigNetStoreAiger(itp,1/*bad*/,"itp-pdt2.aig");

	itp = Ddi_NnfClustSimplify(itp, 0);	
  long clustTime = util_cpu_time();
	fprintf(stdout, "Clust_Time: %s\n", util_print_time(clustTime - last));
  last = clustTime;

  Ddi_AigNetStoreAiger(itp,1/*bad*/,"itp-pdt3.aig");

/*
	printf("\nRound 2\n");

	Ddi_AigStructRedRemAcc (itp,NULL);
  rrTime = util_cpu_time();
	fprintf(stdout, "RR_Time: %s\n", util_print_time(rrTime - last));
  last = rrTime;

  ddiAbcOptAcc (itp,-1);
	abcTime = util_cpu_time();
	printf("ABC opt size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));
	fprintf(stdout, "ABC_Time: %s\n", util_print_time(abcTime - last));
  last = abcTime;

	itp = Ddi_NnfClustSimplify(itp, 1);	
  clustTime = util_cpu_time();
	fprintf(stdout, "Clust_Time: %s\n", util_print_time(clustTime - last));
  last = clustTime;
*/

#define GPC_TRY 0

#if !GPC_TRY
        exit(-1);
	assert(a!=NULL && b !=NULL);
#else	

//  exit(-1);
  Ddi_NnfClustSimplifyAcc(itp,0);


  if (1) {
    Ddi_Bdd_t *bPart = Ddi_AigPartitionTop(b,1);
    Ddi_Bdd_t *itp0 = Ddi_BddDup(itp);
    Ddi_Bdd_t *itp1 = Ddi_BddDup(itp);
    if (Ddi_BddPartNum(bPart)==1) {
      int i;
      Ddi_Bdd_t *p0, *p1, *p1Part, *sel, *p10;
      Ddi_Free(bPart);
      bPart = Ddi_AigPartitionTop(b,0); // and
      Ddi_BddPartSortBySizeAcc(bPart, 0);
      p0 = Ddi_BddPartExtract(bPart,0);
      p1 = Ddi_BddMakeAig(bPart);
      Ddi_Free(bPart);
      bPart = Ddi_AigPartitionTop(p0,1);
      p1Part = Ddi_AigPartitionTop(p1,1);
      p10 = Ddi_AigPartitionTop(Ddi_BddPartRead(bPart,0),0);
      sel = Ddi_BddPartRead(p10,1);
      Ddi_Bdd_t *b0 = Ddi_BddAnd(b,sel);
      Ddi_Bdd_t *b1 = Ddi_BddDiff(b,sel);
      Ddi_AigOptByMonotoneCoreAcc (itp0,b0,NULL,0,-1.0);
      Ddi_AigOptByMonotoneCoreAcc (itp1,b1,NULL,0,-1.0);

      Ddi_Free(p1);
    }
    Ddi_BddPartSortBySizeAcc(bPart, 0);
    Ddi_Free(bPart);
  } 
  //  DdiAigRedRemovalOdcAcc (itp,b,Ddi_BddSize(itp)/2,-1.0);

	printf("\nITE simplify with Weakening\n");
	// 	Ddi_NnfIteSimplifyAcc (itp,a,1,NULL);
	      	Ddi_NnfIteSimplifyAcc (itp,a,b,NULL);
		//    	Ddi_NnfIteSimplifyAcc (itp,NULL,NULL,NULL);
#endif
	// Porzione di semplificazione con SAT solver. Due palleggi A-B A-B 
	printf("\nWeakening/Strengthening sequence\nRound 1\n");
	printf("Str with A\n");
	Ddi_AigOptByMonotoneCoreAcc (itp,a,NULL,1,-1.0);
	printf("Weak with B\n");
	if (0) {
	  Ddi_Bdd_t *itp2 = Ddi_BddDup(itp);
	  Ddi_AigOptByMonotoneCoreAcc (itp2,b,NULL,0,-1.0);
	  Ddi_BddAndAcc(itp,itp2);
	  Ddi_Free(itp2);
	}
	Ddi_AigOptByMonotoneCoreAcc (itp,b,NULL,0,-1.0);
  long abTime = util_cpu_time();
	fprintf(stdout, "AB_Time: %s\n", util_print_time(abTime - last));
  last = abTime;

	printf("\nRound 2\nStr with A\n");
	Ddi_AigOptByMonotoneCoreAcc (itp,a,NULL,1,-1.0);
	printf("Weak with B\n");
	Ddi_AigOptByMonotoneCoreAcc (itp,b,NULL,0,-1.0);
  abTime = util_cpu_time();
	fprintf(stdout, "AB_Time: %s\n", util_print_time(abTime - last));
  last = abTime;

  exit(-1);
 }
#endif

  if (method==2){
    Ddi_Var_t *v0 = Ddi_VarNew(ddm);
    Ddi_Var_t *v1 = Ddi_VarNew(ddm);
    Ddi_Var_t *v2 = Ddi_VarNew(ddm);
    Ddi_VarAttachName (v0, "X0");
    Ddi_VarAttachName (v1, "X1");
    Ddi_VarAttachName (v2, "X2");

    Ddi_Bdd_t *l00 = Ddi_BddMakeLiteralAig(v0,0);
    Ddi_Bdd_t *l01 = Ddi_BddMakeLiteralAig(v0,1);
    Ddi_Bdd_t *l10 = Ddi_BddMakeLiteralAig(v1,0);
    Ddi_Bdd_t *l11 = Ddi_BddMakeLiteralAig(v1,1);
    Ddi_Bdd_t *l20 = Ddi_BddMakeLiteralAig(v2,0);
    Ddi_Bdd_t *l21 = Ddi_BddMakeLiteralAig(v2,1);
    Ddi_Bdd_t *A = Ddi_BddAnd(l00,l10);
    Ddi_BddAndAcc(A,l20);
    Ddi_Bdd_t *B = Ddi_BddAnd(l01,l11);
    Ddi_BddOrAcc(B,l21);
    Ddi_Varset_t *suppA = Ddi_BddSupp(A);
    Ddi_Varset_t *suppB = Ddi_BddSupp(B);
    Ddi_Varset_t *glob = Ddi_VarsetIntersect(suppA,suppB);
    Ddi_Bdd_t *itp;
    Ddi_Bdd_t *myCare = NULL;
    int sat, itpPart = 0; //-(method-5);
    itp = Ddi_AigSat22AndWithInterpolant(NULL,A,B,NULL,glob,NULL,NULL,0,myCare,NULL,
                                         &sat,itpPart,1,0,-1.0);
    if (itp!=NULL) {
      if (Ddi_AigSatAnd(itp,B,myCare)) {
	printf("itp-B failure\n");
      }
      Ddi_BddNotAcc(itp);
      if (Ddi_AigSatAnd(itp,A,myCare)) {
	printf("itp-A failure\n");
      }
      exit(0);
    }
  }

  if (method > 20) {
    ibmFormat=1;
    method -= 20;
  }

  if (method == 9 || method == 10 || method == 13){
    return AigCustom910CombinationalCircuit_cleanDV(ddm, filename, method, compl_invarspec, cntReachedOK, ibmFormat);
  }
  //int ibmItp = 1;

  /* fprintf(dMgrO(ddm),"heuristic(0) [all nodes]\n");
  fprintf(dMgrO(ddm),"heuristic(1) [rnd nodes]\n");
  fprintf(dMgrO(ddm),"heuristic(2) [fout count]\n");
  fprintf(dMgrO(ddm),"heuristic(3) [pi + pi fout]\n");
  fprintf(dMgrO(ddm),"heuristic(4) [Dom]\n");*/

  if (method==1)
  {

#if 0
 printf("RAR METHOD TESTING ... Nov 2015\n");
 myLink(NULL);
 exit(-1);
#endif 

/*
    Pdtutil_OptList_t* l;
    l=Pdtutil_OptListCreate(Pdt_OptPdt_c);
    Pdtutil_OptItem_t i1,i2,i3;
    Pdtutil_OptItem_t e1,e2,e3;
    i1.optData.inum=1;
    i2.optData.inum=45;
    i3.optData.inum=3;
    Pdtutil_OptListInsertHead(l,i1);
    Pdtutil_OptListInsertHead(l,i2);
    Pdtutil_OptListInsertTail(l,i3);
    e2=Pdtutil_OptListExtractHead(l);
    e1=Pdtutil_OptListExtractHead(l);
    e3=Pdtutil_OptListExtractHead(l);
    fprintf(stdout,"e1=%d\n",e1.optData.inum);
    fprintf(stdout,"e2=%d\n",e2.optData.inum);
    fprintf(stdout,"e3=%d\n",e3.optData.inum);
    // fprintf(stdout,"e3=%d\n",e3.i);
    Pdtutil_OptListFree(l);
    exit(0);

    Pdtutil_List_t l;
    l=Pdtutil_ListCreate();
    Pdtutil_SetStat_s i1,i2,i3;
    Pdtutil_SetStat_s *e1,*e2,*e3;
    i1.value.intv=1;
    i2.value.intv=2;
    i3.value.intv=3;
    Pdtutil_ListInsertHead(l,&i1);
    Pdtutil_ListInsertHead(l,&i2);
    Pdtutil_ListInsertTail(l,&i3);
    Pdtutil_ListInsertHead(l,&i1);
    Pdtutil_ListInsertHead(l,&i2);
    Pdtutil_ListInsertTail(l,&i3);
    Pdtutil_ListInsertHead(l,&i1);
    Pdtutil_ListInsertHead(l,&i2);
    Pdtutil_ListInsertTail(l,&i3);
    e2=(Pdtutil_SetStat_s*)Pdtutil_ListExtractHead(l);
    e1=(Pdtutil_SetStat_s*)Pdtutil_ListExtractHead(l);
    e3=(Pdtutil_SetStat_s*)Pdtutil_ListExtractHead(l);
    e2=(Pdtutil_SetStat_s*)Pdtutil_ListExtractHead(l);
    e1=(Pdtutil_SetStat_s*)Pdtutil_ListExtractTail(l);
    e3=(Pdtutil_SetStat_s*)Pdtutil_ListExtractHead(l);
    fprintf(stdout,"e1=%d\n",e1->value.intv);
    fprintf(stdout,"e2=%d\n",e2->value.intv);
    fprintf(stdout,"e3=%d\n",e3->value.intv);
    Pdtutil_ListFree(l);
    exit(0);*/

    /* ABC <-> FSM :: June '13*/

    Fsm_Mgr_t *fsmMgr=NULL;
    Fsm_Fsm_t *fsmFsm;

    fsmMgr = Fsm_MgrInit (NULL, NULL);
    Fsm_MgrSetOption(fsmMgr,Pdt_FsmUseAig_c,inum,1);

    Fsm_MgrLoadAiger (&fsmMgr, ddm, filename, NULL, NULL, (Pdtutil_VariableOrderFormat_e)0);
    fsmFsm=Fsm_FsmMakeFromFsmMgr(fsmMgr);
    // Fsm_FsmMiniWriteAiger (fsmFsm,"out.aig");
    Ddi_Bddarray_t *en =
      Ddi_FindIte(Fsm_FsmReadDelta(fsmFsm), Fsm_FsmReadPS(fsmFsm), -1);
    Ddi_Free(en);
    // Ddi_SccMgr_t *sccMgr;
    // sccMgr = Ddi_FsmSccTarjan (Fsm_FsmReadDelta(fsmFsm),Fsm_FsmReadLambda(fsmFsm),Fsm_FsmReadPS(fsmFsm));
    // Ddi_FindSccBridgesNaive(sccMgr, Fsm_FsmReadDelta(fsmFsm),Fsm_FsmReadLambda(fsmFsm),Fsm_FsmReadPS(fsmFsm));
    exit(-1);

    // Fsm_FsmWriteAiger(fsmMgr, "/home/pas/Desktop/fsmMgr_out.aig");
    // Fsm_FsmMiniWriteAiger (fsmFsm,"dumped/pre_scorr_out.aig");
    myLink(Fsm_FsmMakeFromFsmMgr(fsmMgr));
    // fsmFsm=Fsm_FsmMakeFromFsmMgr(fsmMgr);
    // Fsm_FsmMiniWriteAiger (fsmFsm,"dumped/post_scorr_out.aig");

    // Fsm_RetimePeriferalLatches (fsmMgr);
    // fsmFsm=Fsm_FsmMakeFromFsmMgr(fsmMgr);
    // Se si fa il retimePerif  necessario aggiornare i dati in size con il check seguente, senn il dump su file fallisce!!!
    // Fsm_FsmCheckSizeConsistency(fsmFsm);
    // Fsm_Fsm_t *fsmFsm1 = Fsm_FsmDup(fsmFsm);
    // Fsm_Fsm_t *fsmFsm2 = Fsm_FsmDup(fsmFsm);

    // Fsm_FsmWriteInvarspec(fsmFsm, Fsm_MgrReadInvarspecBDD(fsmMgr));
    // Fsm_FsmWriteInvarspec(fsmFsm, Ddi_BddarrayRead(Fsm_MgrReadLambdaBDD(fsmMgr),0));
    // Fsm_FsmFoldProperty(fsmFsm, compl_invarspec, cntReachedOK);
    // Fsm_FsmUnfoldProperty(fsmFsm);
    // Fsm_FsmFoldInit(fsmFsm);
    // Fsm_FsmFoldConstraint(fsmFsm);
    // Fsm_FsmUnfoldConstraint(fsmFsm);


    // Fsm_FsmUnfoldInit(fsmFsm);

    // Fsm_FsmMiniWriteAiger (fsmFsm,"fsmMiniDump.aig");


    Fsm_MgrQuit(fsmMgr);
    // Fsm_FsmFree(fsmFsm);


    return 0;
  }

  if (method >= 20) {
    benchArray = Ddi_AigarrayNetLoadAiger(ddm,NULL,filename);
    Ddi_Bdd_t *f = Ddi_BddDup(Ddi_BddarrayRead(benchArray,0));
    Ddi_Varset_t *supp = Ddi_BddSupp(f);
    printf("initial AIG size: %d - supp vars: %d\n",
           Ddi_BddSize(f), Ddi_VarsetNum(supp));
    Ddi_BddSetMono (f);
    Ddi_Free(supp);
    supp = Ddi_BddSupp(f);
    printf("BDD size: %d - supp vars: %d\n",
           Ddi_BddSize(f), Ddi_VarsetNum(supp));
    Ddi_MgrReduceHeap (ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);
    printf("BDD size after sift: %d\n", Ddi_BddSize(f));
    Ddi_Free(f);
    Ddi_Free(supp);
    exit(0);
  }
  
  ddm->settings.aig.satIncrByRefinement = method;
  if (method == 3 || method >= 9 || method==10) {
#if 0
    f = Ddi_AigNetLoadBench(ddm, filename, NULL);
    benchArray = Ddi_BddarrayAlloc(ddm, 1);
    Ddi_BddarrayWrite(benchArray,0,f);
    Ddi_Free(f);
#else
    // BDD based classification (work with JPMS)
    Ddi_Bddarray_t *testSet1 = NULL, *testSet0=NULL;
    Ddi_Bddarray_t *trainSet=NULL;
    int tryTest=1;
    int isSplit = 1;
    int testRatio = 20;
    int i, nv, train0=0, train1=0;
    int trainIncludeTest = 0;
    char *filenameTest = strstr(filename,"@");

    testSet0 = Ddi_BddarrayAlloc(ddm,0);
    testSet1 = Ddi_BddarrayAlloc(ddm,0);

    if (filenameTest != NULL) {
      *filenameTest = '\0';
      filenameTest++;
      Ddi_Bddarray_t *testArray = 
	Ddi_AigarrayNetLoadAiger(ddm,NULL,filenameTest);
      testRatio = 0;
      int n = Ddi_BddarrayNum(testArray);
      int i;

      for (i=0; i<n; i++) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(testArray,i);
	char *name = Ddi_ReadName(f_i);
	char *select = name+strlen(name)-1;
	while (select!=name && *select!='_') select--;
        if (select==name) continue;
	select--;
        if (*select=='0') {
	  Ddi_BddarrayInsertLast(testSet0,f_i);
	}
	else {
	  Ddi_BddarrayInsertLast(testSet1,f_i);
	}
      }
    }

    benchArray = Ddi_AigarrayNetLoadAiger(ddm,NULL,filename);

    if (isSplit) {
      int n = Ddi_BddarrayNum(benchArray);
      int i, nv;
      Ddi_Bdd_t *f0 = Ddi_BddMakePartDisjVoid(ddm);
      Ddi_Bdd_t *f1 = Ddi_BddMakePartDisjVoid(ddm);

      trainSet = Ddi_BddarrayAlloc(ddm,2);

      for (i=0; i<n; i++) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(benchArray,i);
	char *name = Ddi_ReadName(f_i);
	char *select = name+strlen(name)-1;
	while (select!=name && *select!='_') select--;
        if (select==name) continue;
	select--;
        if (*select=='0') {
	  if (testRatio>0 && (rand()%100 < testRatio)) {
	    Ddi_BddarrayInsertLast(testSet0,f_i);
	    if (trainIncludeTest) Ddi_BddOrAcc(f0,f_i);
	  }
	  else {
	    Ddi_BddPartInsertLast(f0,f_i);
	    train0++;
	  }
	}
	else {
	  if (testRatio>0 && (rand()%100 < testRatio)) {
	    Ddi_BddarrayInsertLast(testSet1,f_i);
	    if (trainIncludeTest) Ddi_BddOrAcc(f1,f_i);
	  }
	  else {
	    Ddi_BddPartInsertLast(f1,f_i);
	    train1++;
	  }
	}
      }
      Ddi_BddarrayWrite(trainSet,0,f0);
      Ddi_BddarrayWrite(trainSet,1,f1);
      Ddi_Free(f0);
      Ddi_Free(f1);

    }
    else {
      trainSet = Ddi_BddarrayDup(benchArray);
    }

    int n0 = Ddi_BddarrayNum(testSet0);
    int n1 = Ddi_BddarrayNum(testSet1);

    printf("training set - 0: %d - 1: %d\n", train0, train1);
    printf("test set - 0: %d - 1: %d\n", n0, n1);

    int trySeqCover = 1;
    int interleavedCof = method>15;
    {
      int n = Ddi_BddarrayNum(trainSet);
      int i, nv, maxCareSize = 0;
      Ddi_Bdd_t *care = Ddi_BddMakeConst(ddm,0);
      //      Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
      //      Ddi_MgrSetSiftThresh (ddm, 10000);

      printf("initial AIG size - 0: %d, 1: %d\n", 
             Ddi_BddSize(Ddi_BddarrayRead(trainSet,0)),
             Ddi_BddSize(Ddi_BddarrayRead(trainSet,1)));
      Ddi_Varset_t *supp = Ddi_BddarraySupp(trainSet);
      nv = Ddi_VarsetNum(supp);
      printf("support vars: %d\n", Ddi_VarsetNum(supp));
      Ddi_Free(supp);

      if (interleavedCof) {
        Ddi_Bdd_t *t0 = Ddi_BddarrayRead(trainSet,0);
        Ddi_Bdd_t *t1 = Ddi_BddarrayRead(trainSet,1);
        int n0 = Ddi_BddPartNum(t0);
        int n1 = Ddi_BddPartNum(t1);
        int nmax = n0<n1?n1:n0;
        int i, cofDone = 0, noCofSteps = 4;
        Ddi_Bdd_t *f0 = Ddi_BddMakeConst(ddm,0);
        Ddi_Bdd_t *f1 = Ddi_BddMakeConst(ddm,0);
        Ddi_Bdd_t *myCare = Ddi_BddMakeConst(ddm,0);
        Ddi_Bdd_t *totTrain = Ddi_BddMakeConst(ddm,0);
        for (i=0; i<nmax; i++) {
          Ddi_Bdd_t *newCare = Ddi_BddDup(myCare);
          if (i<n0) {
            Ddi_Bdd_t *r0_i = Ddi_BddPartRead(t0,i);
            Ddi_BddSetMono(r0_i);
            Ddi_BddOrAcc(f0,r0_i); 
	    if (cofDone)
	      Ddi_BddDiffAcc(f1,r0_i); 
            Ddi_BddOrAcc(newCare,r0_i); 
	    //            Ddi_BddOrAcc(totTrain,r0_i); 
          }
          if (i<n1) {
            Ddi_Bdd_t *r1_i = Ddi_BddPartRead(t1,i);
            Ddi_BddSetMono(r1_i);
            Ddi_BddOrAcc(f1,r1_i); 
	    if (cofDone)
	      Ddi_BddDiffAcc(f0,r1_i); 
            Ddi_BddOrAcc(newCare,r1_i); 
	    //            Ddi_BddOrAcc(totTrain,r1_i); 
          }
	  if (i>=noCofSteps) {
	    Ddi_BddConstrainAcc(f0,newCare);
	    Ddi_BddConstrainAcc(f1,newCare);
	    cofDone = 1;
	  }
	  Ddi_DataCopy(myCare,newCare);
          Ddi_Free(newCare);
	  int careSize = Ddi_BddSize(myCare);
	  if (careSize>maxCareSize) maxCareSize = careSize;
          Ddi_Bdd_t *careForCare = Ddi_BddOr(f0,f1);
          Ddi_Bdd_t *inters = Ddi_BddAnd(f0,f1);
	  //	  Ddi_BddConstrainAcc(inters,totTrain);
	  Pdtutil_Assert(Ddi_BddIsZero(inters),"overlapping partitions");
	  Ddi_Free(inters);
          //          Ddi_BddNotAcc(careForCare);
	  if (cofDone)
	    Ddi_BddConstrainAcc(myCare,careForCare);
          Ddi_Free(careForCare);
	  // printf("interl. iter %d - 0: %d, 1: %d - c: %d\n", i, 
          //       Ddi_BddSize(f0),Ddi_BddSize(f1), Ddi_BddSize(myCare));
        }
        Ddi_Free(myCare);
        Ddi_Free(totTrain);
        Ddi_BddOrAcc(care,f0);
        Ddi_BddOrAcc(care,f1);
        Ddi_BddarrayWrite(trainSet,0,f0);
        Ddi_BddarrayWrite(trainSet,1,f1);
        printf("interl. iter: %d final size - 0: %d, 1: %d - maxCareSize: %d\n", 
	       nmax, Ddi_BddSize(f0),Ddi_BddSize(f1), maxCareSize);
        Ddi_Free(f0);
        Ddi_Free(f1);
      }
      else {
        for (i=0; i<n; i++) {
          Ddi_Bdd_t *f_i = Ddi_BddarrayRead(trainSet,i);
          Ddi_BddSetMono(f_i);
          printf("target[%d]: %d\n", i, Ddi_BddSize(f_i));
          printf("component %d has %d minterms\n", i, 
                 (int)Ddi_BddCountMinterm(f_i, nv));
          Ddi_BddOrAcc(care,f_i);
        }
      }

      Ddi_Bdd_t *f_0 = Ddi_BddarrayRead(trainSet,0);
      Ddi_Bdd_t *f_1 = Ddi_BddarrayRead(trainSet,1);
      Ddi_Bdd_t *cover = NULL;
      Ddi_Bdd_t *coverConstr = NULL;
      Ddi_Bdd_t *coverRestr = NULL;

      if (trySeqCover) {
        int nprimes;
        cover = Ddi_BddCover (f_1, f_0, &nprimes);
        if (cover==NULL) {
          printf("no cover, onset and offset probably overlap\n");
          trySeqCover=0;
        }
        else {
          printf("cover size: %d - n primes: %d\n", Ddi_BddSize(cover), nprimes);
          coverConstr = Ddi_BddConstrain(cover,care);
          printf("coverConstr size: %d\n", Ddi_BddSize(coverConstr));
          coverRestr = Ddi_BddRestrict(cover,care);
          printf("coverRestr size: %d\n", Ddi_BddSize(coverRestr));
        }
      }

      printf("total BDD size of training set - tot: %d\n", Ddi_BddarraySize(trainSet));
      printf("FULL care BDD size: %d\n", Ddi_BddSize(care));
      //Ddi_MgrReduceHeap (ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);
      for (i=0; i<n; i++) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(trainSet,i);
	if (i==0) Ddi_BddNotAcc(f_i);
	//     	Ddi_BddConstrainAcc(f_i,care);
     	Ddi_BddRestrictAcc(f_i,care);
	if (i==0) Ddi_BddNotAcc(f_i);
	printf("constrained target[%d]: %d\n", i, Ddi_BddSize(f_i));
	//	Ddi_BddRestrictAcc(f_i,care);
      }

      if (tryTest) {
	Ddi_Bdd_t *f0 = Ddi_BddarrayRead(trainSet,0);
	Ddi_Bdd_t *f1 = Ddi_BddarrayRead(trainSet,1);
	Ddi_Bdd_t *f0n = Ddi_BddNot(f0);
	Ddi_Bdd_t *f1n = Ddi_BddNot(f1);
	int bad0=0, bad1=0, bad0c=0, bad0cr=0, bad1c=0, bad0cc=0, bad1cc=0, bad1cr=0;
	for (i=0; i<n0; i++) {
	  Ddi_Bdd_t *t_i = Ddi_BddMakeMono(Ddi_BddarrayRead(testSet0,i));
	  int i0 = Ddi_BddIncluded(t_i,f0);
	  int i1 = Ddi_BddIncluded(t_i,f1);
	  //	  int i0n = Ddi_BddIncluded(t_i,f0n);
	  //	  int i1n = Ddi_BddIncluded(t_i,f1n);
	  //	  printf("test0 coverage [%d] %d %d\n", i, i0, i1);
	  if (i1) bad0++;
          if (trySeqCover) {
            int i1c = Ddi_BddIncluded(t_i,cover);
            int i1cc = Ddi_BddIncluded(t_i,coverConstr);
            int i1cr = Ddi_BddIncluded(t_i,coverRestr);
            if (i1c) bad0c++;
            if (i1cc) bad0cc++;
            if (i1cr) bad0cr++;
          }
	}
	for (i=0; i<n1; i++) {
	  Ddi_Bdd_t *t_i = Ddi_BddMakeMono(Ddi_BddarrayRead(testSet1,i));
	  int i0 = Ddi_BddIncluded(t_i,f0);
	  int i1 = Ddi_BddIncluded(t_i,f1);
	  // int i0n = Ddi_BddIncluded(t_i,f0n);
	  // int i1n = Ddi_BddIncluded(t_i,f1n);
	  //	  printf("test1 coverage [%d] %d %d\n", i, i0, i1);
	  if (i0) bad1++;
          if (trySeqCover) {
            Ddi_BddNotAcc(cover);
            Ddi_BddNotAcc(coverConstr);
            Ddi_BddNotAcc(coverRestr);
            int i0c = Ddi_BddIncluded(t_i,cover);
            int i0cc = Ddi_BddIncluded(t_i,coverConstr);
            int i0cr = Ddi_BddIncluded(t_i,coverRestr);
            Ddi_BddNotAcc(cover);
            Ddi_BddNotAcc(coverConstr);
            Ddi_BddNotAcc(coverRestr);
            if (i0c) bad1c++;
            if (i0cc) bad1cc++;
            if (i0cr) bad1cr++;
          }
	}
	printf("test0 summary: %d/%d bad - badc: %d - badcc: %d - badcr: %d\n", 
               bad0, n0, bad0c, bad0cc, bad0cr);
	printf("test1 summary: %d/%d bad - badc: %d - badcc: %d - badcr: %d\n", 
               bad1, n1, bad1c, bad1cc, bad1cr);
	printf("test TOT summary: %d/%d bad - badc: %d - badcc: %d - badcr: %d\n", 
               bad0+bad1, n0+n1, bad0c+bad1c, bad0cc+bad1cc, bad0cr+bad1cr);
      }

      supp = Ddi_BddarraySupp(trainSet);
      printf("support vars: %d\n", Ddi_VarsetNum(supp));

      int tryZdd = 0;
      if (tryZdd) {
	unsigned int nvar         = Ddi_MgrReadNumCuddVars(ddm);
	unsigned int numSlots     = DDI_UNIQUE_SLOTS /*Ddi_MgrReadSlots(dd)*/;
	unsigned int cacheSize    = Ddi_MgrReadCacheSlots(ddm);
	unsigned int maxCacheSize = DDI_MAX_CACHE_SIZE;

	Cudd_ReorderingType dynordMethod;
	int autodyn = Ddi_MgrReadReorderingStatus (ddm, &dynordMethod);
	int i;
	
	Ddi_Mgr_t *ddm2 = Ddi_MgrInit (NULL, NULL, 0/*nvar*/, 
				       numSlots, cacheSize, maxCacheSize,
				       Ddi_MgrReadMemoryLimit (ddm), 
				       Ddi_MgrReadTimeLimit (ddm));
	Ddi_Vararray_t *suppA = Ddi_VararrayMakeFromVarset(supp,1);
	for (i=0; i<Ddi_VararrayNum(suppA); i++) {
	  Ddi_Var_t *v_i = Ddi_VararrayRead(suppA,i);
	  Ddi_Var_t *newv_i = Ddi_VarNewAtLevel(ddm2,i);
	  Ddi_VarAttachName(newv_i, Ddi_VarName(v_i));
	}
	Ddi_Bddarray_t *trainSet2 = Ddi_BddarrayCopy(ddm2,trainSet);
	DdNode **zdds = Pdtutil_Alloc(DdNode *, n);
	for (i=0; i<n; i++) {
	  Ddi_Bdd_t *f_i = Ddi_BddarrayRead(trainSet2,i);
	  DdNode * f_iCu = Ddi_BddToCU(f_i);
	  DdNode * f_iZdd = Cudd_zddPortFromBdd (Ddi_MgrReadMgrCU(ddm2), f_iCu);
	  zdds[i] = f_iZdd;
	  printf("zdd target[%d]: %d\n", i, Cudd_zddDagSize(f_iZdd));
	  Cudd_Ref(f_iZdd);
	}
	Cudd_zddReduceHeap (Ddi_MgrReadMgrCU(ddm2), 
			      Ddi_ReorderingMethodString2Enum("sift"), 0);
	for (i=0; i<n; i++) {
	  DdNode * f_iZdd = zdds[i];
	  printf("zdd after sift target[%d]: %d\n", i, Cudd_zddDagSize(f_iZdd));
	  Cudd_RecursiveDerefZdd (Ddi_MgrReadMgrCU(ddm2), f_iZdd);
	  //	Ddi_BddRestrictAcc(f_i,care);
	}
	Pdtutil_Free(zdds);
	Ddi_Free(trainSet2);
	Ddi_MgrQuit(ddm2);
	Ddi_VararrayPrint(suppA);
      }

#if 0
      for (i=0; i<n; i++) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(trainSet,i);
	int j;
	Ddi_Vararray_t *vA = Ddi_BddSuppVararray(f_i);
	int sizeMin = Ddi_BddSize(f_i), jMin = -1;
	for (j=0; j<Ddi_VararrayNum(vA); j++) {
	  Ddi_Var_t *v_j = Ddi_VararrayRead(vA,j);
	  Ddi_Varset_t *sm = Ddi_VarsetMakeFromVar(v_j);
	  Ddi_Bdd_t *over = Ddi_BddExist(f_i,sm);
	  if (Ddi_BddSize(over)<sizeMin) {
	    sizeMin = Ddi_BddSize(over);
	    jMin = j;
	  }
	  Ddi_Free(over);
	}
	Ddi_Var_t *v_min = Ddi_VararrayRead(vA,jMin);
	Ddi_Bdd_t *c0 = Ddi_BddCofactor(f_i,v_min,0);
	Ddi_Bdd_t *c1 = Ddi_BddCofactor(f_i,v_min,1);
	printf("constrained target[%d] min exist size: %d (%d+%d)\n", 
	       i, sizeMin, Ddi_BddSize(c0), Ddi_BddSize(c1));
	Ddi_Free(vA);
	Ddi_Free(c0);
	Ddi_Free(c1);
	//	Ddi_BddRestrictAcc(f_i,care);
      }
#endif

      Ddi_Free(supp);
      Ddi_Free(care);

      for (i=0; i<n; i++) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(trainSet,i);
	int s0 = Ddi_BddSize(f_i);
	bddCompactByImplCofAcc (f_i,10);
	printf("constrained target[%d] compacted by part: %d->%d\n", 
	       i, s0, Ddi_BddSize(f_i));
      }

#if 0
      Ddi_MgrReduceHeap (ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);
      for (i=0; i<n; i++) {
	Ddi_Bdd_t *f_i = Ddi_BddarrayRead(trainSet,i);
	printf("constrained target[%d] after sift: %d\n", i, Ddi_BddSize(f_i));
	Ddi_BddSetAig(f_i);
	ddiAbcOptAcc (f_i,-1);
	printf("constrained target[%d] after ABC: %d\n", i, Ddi_BddSize(f_i));
      }
      Ddi_AigarrayNetStoreAiger(trainSet, 0, "out.aig");
#endif
      Ddi_Free(cover);
      exit (0);
    }
#endif
  }
  else {
    // method == 2,4,5,...
    benchArray = Ddi_AigarrayNetLoadBench(ddm, filename, NULL);
  }


  if (method == 12) {
    doMonotone = 1;
  }

  if (method >= 9) {
    Ddi_Bdd_t *itp = Ddi_BddDup(Ddi_BddarrayRead(benchArray,method<=14?0:2));
    Ddi_Varset_t *supp = Ddi_BddSupp(itp);
    char fileOut[1000];
    char *c = NULL;
    Ddi_Bdd_t *myCare = NULL;
    int doItp = method==14;
    int n = Ddi_BddarrayNum(benchArray);
    Ddi_Bdd_t *a = n>1?Ddi_BddarrayRead(benchArray,1):NULL;
    Ddi_Bdd_t *b = n>2?Ddi_BddarrayRead(benchArray,2):NULL;
    Ddi_Bdd_t *care = n>2?Ddi_BddarrayRead(benchArray,3):NULL;
    int enBddOpt;
    int itpCoreTh = ddm->settings.aig.itpAigCore, itpSize;

    //    Ddi_Bdd_t *bPart0 = Ddi_AigPartitionTop(b,0);
    //    Ddi_Bdd_t *bPart = Ddi_AigPartitionTop(Ddi_BddPartRead(bPart0,0),1);


    printf("Initial AIG size: %d - supp: %d\n", Ddi_BddSize(itp),
	   Ddi_VarsetNum(supp));

    if (1) {
      Ddi_Bdd_t *itpPlus = Ddi_BddMakeConstAig(ddm,1);
      Ddi_Vararray_t *suppI = Ddi_BddSuppVararray(itp);
      Ddi_Varset_t *itpVars = Ddi_VarsetMakeFromArray(suppI);
      if (0) {
	printf("ITP ref\n");
	int sat;
	Ddi_Bdd_t *itpRef = 
	  Ddi_AigSat22AndWithInterpolant(NULL,a,b,NULL,
				     itpVars, NULL,NULL,0,
					 care,NULL,
					 &sat, 0, 1, 0, -1.0);
	Ddi_Free(itpRef);
      }

      Ddi_Bddarray_t *en = NULL;
      if (0) {
	en = Ddi_FindAigIte(b, 8);
	if (care!=NULL) {
	  Ddi_BddAndAcc(itpPlus,care);
	}
	printf("ITP using %d enables\n", Ddi_BddarrayNum(en));
      }
      int iter=0;

      //      Ddi_Bdd_t *cex = Ddi_AigSatMinisat22WithCexAndAbortIncremental(
      //		       NULL,b, NULL, 0,-1.0, NULL);
      Ddi_AigStructRedRemAcc (itp,NULL);
      Ddi_NnfClustSimplifyAcc(itp, 0);	
      Ddi_AigStructRedRemAcc (itp,NULL);
      Ddi_Bdd_t *cex = NULL;//Ddi_AigSatMinisat22WithCexAndAbortIncremental(
      //     		       NULL,b, NULL, 0,-1.0, NULL);
      Ddi_Free(cex);
      //      Ddi_BddAndAcc(itp,b);

      //      Ddi_AigNnfOptBySatSimplifyAcc (itp,b,care,0);

      if (1) {
	Ddi_IncrSatMgr_t *ddiS = NULL;
	ddiS = Ddi_IncrSatMgrAlloc(NULL, 1/*useMinisat22*/, 0,0);
	aig2CnfIdInit(ddm);
	//	Ddi_AigSatMinisatLoadClausesIncrementalAsserted(ddiS,care);
	Ddi_AigSatMinisatLoadClausesIncremental(ddiS,b,NULL);
	//	Minisat22FreezeAig (ddiS->S22,care);
	Minisat22FreezeVars (ddiS->S22,ddm,NULL);
	Ddi_AigLockTopClauses(ddiS,b);
	Minisat22Eliminate(ddiS->S22);
	aig2CnfIdClose(ddm);

      }

      cex = Ddi_AigSatAndWithCexAndAbort(b,a,care,NULL,-1.0,NULL);
      Ddi_Free(cex);
      cex = Ddi_AigSatMinisat22WithCexAndAbortIncremental(
     		       NULL,itp, NULL, 0,-1.0, NULL);


      while (0) { 
	int sat;     
	Ddi_Bdd_t *cex = 
	  Ddi_AigSatAndWithCexAndAbort(itpPlus,b,care,NULL,-1.0,NULL);
	if (cex==NULL) break;
	printf("ITP iteration  %d\n", iter++);
      

	Ddi_Bdd_t *b2 = Ddi_AigSubsetWithCexOnControl (b,cex,en);
	Ddi_Bdd_t *itp_i = 
	  Ddi_AigSat22AndWithInterpolant(NULL,a,b2,NULL,
				     itpVars, NULL,NULL,0,
				    itpPlus,NULL,
					 &sat, 0, 1, 0, -1.0);
	Ddi_BddAndAcc(itpPlus,itp_i);
	Ddi_Free(itp_i);
	Ddi_Free(cex);
	Ddi_Free(b2);
      }
      Ddi_Free(en);
      Ddi_Free(suppI);
      Ddi_Free(itpPlus);
      exit (0);
    }

    if (1) {
      Ddi_AigStructRedRemAcc (itp,NULL);
      Ddi_NnfClustSimplifyAcc(itp, 0);	
      Ddi_AigStructRedRemAcc (itp,NULL);

      if (1) {
	Ddi_Bdd_t *itp2 = Ddi_ItpWeakenByRefinement (itp,b,care);
	Ddi_AigOptByMonotoneCoreAcc (itp2,a,NULL,1,-1.0);
	Ddi_AigOptByMonotoneCoreAcc (itp2,b,care,0,-1.0);
	Ddi_Free(itp2);
      }
      if (0) {
	int i, n;
	Ddi_Bdd_t *itpPart = Ddi_AigPartitionTop(itp,0);
	Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
        Ddi_BddPartSortBySizeAcc(itpPart, 0);
	n = Ddi_BddPartNum(itpPart);
	for (i=n-1; i>16; i--) {
	  Ddi_Bdd_t *p_i = Ddi_BddPartExtract(itpPart,i);
	  Ddi_BddAndAcc(constr,p_i);
	  Ddi_Free(p_i);
	}
	Ddi_BddSetAig(itpPart);
	Ddi_NnfOdcSimplifyAcc (constr,b,1);
	Ddi_NnfOdcSimplifyAcc (itpPart,constr,1);
	Ddi_Free(constr);
      }
      Ddi_BddNotAcc(itp);
      if (1) {
	Ddi_Vararray_t *suppA = Ddi_BddSuppVararray(itp);
	Ddi_Bdd_t *itpPlus = Ddi_BddDup(itp), *i0, *i1;
	Ddi_Varset_t *sm, *sm1 = Ddi_VarsetVoid(ddm);
	Ddi_Var_t *v = Ddi_VararrayRead(suppA,2); 
	int i, nv = Ddi_VararrayNum(suppA);
	Ddi_VarsetAddAcc(sm1,v);
	for (i=nv-1; i>=3; i--) Ddi_VararrayRemove(suppA,i);
	sm = Ddi_VarsetMakeFromArray(suppA);
	DdiAigExistOverAcc (itpPlus,sm1,NULL);
	i0 = Ddi_BddCofactor(itp,v,0);
	i1 = Ddi_BddCofactor(itp,v,0);
	Ddi_BddOrAcc(i0,i1);
	//	Ddi_BddAndAcc(itp,itpPlus);

	Ddi_AigOptByMonotoneCoreAcc (itp,a,0,0,-1.0);

	Ddi_NnfOdcSimplifyAcc (itp,a,1);
	Ddi_NnfOdcSimplifyAcc (i0,b,1);
	Ddi_NnfOdcSimplifyAcc (itpPlus,b,1);
	Ddi_NnfOdcSimplifyAcc (itp,i0,1);
	Ddi_NnfOdcSimplifyAcc (itp,i0,1);
	Ddi_Free(i0);
	Ddi_Free(i1);
	Ddi_Free(sm1);
	Ddi_Free(sm);
	Ddi_Free(suppA);
      }
      Ddi_BddAndAcc(b,care);
      Ddi_NnfOdcSimplifyAcc (itp,b,1);
      exit (0);
    }

    if (1) {
      int i, nv, nSteps = 4;
      float smoothRatio = 0.5;
      Ddi_AigStructRedRemAcc (itp,NULL);
      Ddi_Vararray_t *suppI = Ddi_BddSuppVararray(itp);
      Ddi_Vararray_t *suppB = Ddi_BddSuppVararray(b);
      Ddi_Vararray_t *common = Ddi_VararrayIntersect(suppI,suppB);
      Ddi_VararrayDiffAcc(suppI,common);
      Ddi_VararrayDiffAcc(suppB,common);
      Ddi_Bdd_t *auxB = Ddi_BddDup(b);
      Ddi_Varset_t *smoothV = Ddi_VarsetVoid(ddm);
      Ddi_Varset_t *commonV = Ddi_VarsetMakeFromArray(common);
      nv = Ddi_VararrayNum(suppB);
      int start =nv*(1-smoothRatio);
      start = 4851;
      for (i=start; i<nv; i++) {
	Ddi_VarsetAddAcc(smoothV,Ddi_VararrayRead(suppB,i));
      }
      Ddi_Bdd_t *preimg, *care;
      care = Ddi_BddMakeConstAig(ddm,1);
      for (i=0; i<nSteps; i++) {
	Ddi_Bdd_t *cex = Ddi_AigSatWithCex(auxB);
	Ddi_Bdd_t *subset = Ddi_BddDup(b);
	Ddi_Bdd_t *preimg = Ddi_BddDup(b);
	Ddi_AigCubeExistAcc (cex,commonV);
	Ddi_AigConstrainCubeAcc(preimg,cex);
	if (0 && Ddi_BddSize(preimg)>100000) {
	  Ddi_Vararray_t *s = Ddi_BddSuppVararray(preimg);
	  int j;
	  Ddi_Bdd_t *aux = Ddi_BddDup(preimg);
	  for (j=0; j<Ddi_VararrayNum(s); j++) {
	    Ddi_Var_t *v = Ddi_VararrayRead(s,j);
	    Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
	    Ddi_Bdd_t *a0 = Ddi_BddCofactor(aux,v,0);
	    Ddi_Bdd_t *a1 = Ddi_BddCofactor(aux,v,1);
	    Ddi_Bdd_t *newA = Ddi_BddIte(lit,a1,a0);
	    Ddi_DataCopy(aux,newA);
	    Ddi_Free(lit);
	  }
	}
	Ddi_AigCubeExistProjectAcc (cex,smoothV);
	Ddi_AigConstrainCubeAcc(subset,cex);
	Ddi_BddOrAcc(care,preimg);
	Ddi_BddDiffAcc(auxB,preimg);
	Ddi_BddDiffAcc(auxB,subset);
	Ddi_Free(subset);
      }
      long startTime, cpuTime;
      startTime = util_cpu_time();

      int sat = Ddi_AigSatAnd(a,b,care);
      cpuTime = util_cpu_time () - startTime;
      fprintf(dMgrO(ddm),"ref time = %s\n", util_print_time (cpuTime));
      startTime = util_cpu_time();
      sat = Ddi_AigSatAnd(a,auxB,care);
      cpuTime = util_cpu_time () - startTime;
      fprintf(dMgrO(ddm),"new time = %s\n", util_print_time (cpuTime));

      Ddi_AigOptByMonotoneCoreAcc (itp,a,0,1,-1.0);
      Ddi_AigOptByMonotoneCoreAcc (itp,b,care,0,-1.0);
      Ddi_AigOptByMonotoneCoreAcc (b,itp,care,0,-1.0);
      Ddi_Free(common);
      Ddi_Free(suppI);
      Ddi_Free(suppB);
      Ddi_Free(smoothV);
      exit (1);
    }
    if (0) {
      int mySat;
      Ddi_Bdd_t *iCore0 = Ddi_AigSatAndWithAigCore (itp,a,b,0,&mySat,-1.0);
      exit(1);
    }

    if (Ddi_BddarrayNum(benchArray)>3) {
      myCare = Ddi_BddDup(Ddi_BddarrayRead(benchArray,3));
    }
    else {
      myCare = Ddi_BddMakeConstAig(ddm,1);
    }
    //    Ddi_Free(myCare);


    if (!doItp) {

      Ddi_AigStructRedRemAcc (itp,NULL);
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
        printf("TOT aig after struct rr: %d)\n", Ddi_MgrReadAigNodesNum(ddm))
      );

      ddiAbcOptAcc (itp,-1);
      printf("ABC opt size: %d - supp: %d\n", Ddi_BddSize(itp),
	   Ddi_VarsetNum(supp));
    }

    if (0) {
      Ddi_Vararray_t *sA = Ddi_BddSuppVararray(itp);
      int j, sizeSh, size0 = Ddi_BddSize(itp);
      for (j=0; j<Ddi_VararrayNum(sA); j++) {
	Ddi_Var_t *v = Ddi_VararrayRead(sA,j);
	Ddi_Bdd_t *c0 = Ddi_BddCofactor(itp,v,0);
	Ddi_Bdd_t *c1 = Ddi_BddCofactor(itp,v,1);
	Ddi_Bddarray_t *shared = Ddi_BddarrayAlloc(ddm,2);
	Ddi_BddarrayWrite(shared,0,c0);
	Ddi_BddarrayWrite(shared,1,c1);
	sizeSh = Ddi_BddarraySize(shared);
	printf("v[%d] c0: %d, c1: %d - sh: %d\n", j,
	       Ddi_BddSize(c0),Ddi_BddSize(c1),sizeSh);
	if (sizeSh<size0) {
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
	  Ddi_Bdd_t *newItp =  Ddi_BddIte(lit,c1,c0);
	  Ddi_DataCopy(itp,newItp);
	  Ddi_Free(newItp);
	  Ddi_Free(lit);
	  //	  size0 = sizeSh;
	  printf("ITE -> %s\n", Ddi_VarName(v));
	}
	Ddi_Free(c0);
	Ddi_Free(c1);
	Ddi_Free(shared);
      }
    }

    if (0&&doPart) {
      int j;
      Ddi_Bdd_t *f1 = Ddi_AigPartitionTop(itp,0);
      Ddi_Bdd_t *f2 = Ddi_AigPartitionTop(itp,1);
      Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
      printf("Itp Part NUM: %d (and) - %d (OR)\n",
	     Ddi_BddPartNum(f1), Ddi_BddPartNum(f2));
      for (j=0; j<Ddi_BddPartNum(f1); j++) {
	int size = Ddi_BddSize(Ddi_BddPartRead(f1,j));
	if (size < 10000) {
	  printf("[%d]<%d>\n", j, size);
	  //DdiLogBdd(Ddi_BddPartRead(f1,j),0);
	  if (size == 1) {
	    Ddi_BddAndAcc(constr,Ddi_BddPartRead(f1,j));
	  }
	  else {
	    Ddi_BddAndAcc(myCare,Ddi_BddPartRead(f1,j));
	  }
      	}
	else {
	  printf("[%d]|%d|\n", j, size);
	}
      }
      if (Ddi_BddSize(constr) > 0) {
	Ddi_AigConstrainCubeAcc(itp,constr);
	printf("itp Constr (%d) -> %d\n", Ddi_BddSize(constr),
	       Ddi_BddSize(itp));
      }
      else {
	doPart = 0;
      }
      Ddi_Free(constr);
      Ddi_Free(f1); Ddi_Free(f2);
      f1 = Ddi_AigPartitionTop(itp,0);
      Ddi_Free(itp);
      itp = f1;
      Ddi_BddPartSortBySizeAcc(itp, 1);
    }

    if (0) {
      Ddi_Bdd_t *c = Ddi_AigStructRedRem (itp,NULL);

      printf("Struct R/R: %d -> %d\n", Ddi_BddSize(itp), Ddi_BddSize(c));
      Ddi_Free(itp);
      itp = c;
    }

    if (0) {
      Ddi_Bdd_t *a = Ddi_BddPartRead(itp,Ddi_BddPartNum(itp)-1);
      Ddi_Bdd_t *b = Ddi_AigPartitionTop(a,1);
      Ddi_BddNotAcc(b);
      Ddi_Bdd_t *c = Ddi_AigStructRedRem (b,NULL);

      printf("Struct R/R: %d -> %d\n", Ddi_BddSize(b), Ddi_BddSize(c));
      Ddi_Bdd_t *d = Ddi_AigStructRedRem (c,NULL);

      printf("Struct R/R: %d -> %d\n", Ddi_BddSize(c), Ddi_BddSize(d));
      Ddi_Free(c);
      Ddi_Free(d);

      if (0) {
	Ddi_Bdd_t *b1 = Ddi_AigPartitionTop(Ddi_BddPartRead(b,0),0);
	Ddi_Bdd_t *d = Ddi_AigStructRedRem (b1,Ddi_BddPartRead(b,1));

	printf("Struct R/R: %d -> %d\n", Ddi_BddSize(b1), Ddi_BddSize(d));
	Ddi_Free(d);
      }
      Ddi_Free(b);
    }

    Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
    Ddi_MgrSetSiftThresh (ddm, 100000);

    if (0&&doMonotone) {
      int bddDone = 0;
      if (enBddOpt) {
	bddDone = Ddi_AigOptByBdd(itp,-1,500000) > 0;
      }
      if (!bddDone) {
	Ddi_AigOptByFoCntTop(itp, NULL, 0);
      }
    }
    if (decomp) {
      Ddi_Bdd_t *partB = Ddi_AigPartitionTop(b,0);
      Ddi_Bdd_t *aa = Ddi_BddDup(a);
      Ddi_BddPartSortBySizeAcc(partB,1); // increasing size
      int j;
      printf("INITIAL PART size: %d\n", Ddi_BddSize(partB));
      for (j=0; j<Ddi_BddPartNum(partB); j++) {
	Ddi_Bdd_t *p_i = Ddi_BddPartRead(partB,j);
	Ddi_AigOptByMonotoneCoreAcc (p_i,aa,myCare,0,-1.0);
	//	Ddi_BddDiffAcc(aa,p_i);
      }
      printf("FINAL PART size: %d\n", Ddi_BddSize(partB));
      Ddi_Free(aa);
      Ddi_Free(partB);
    }
    if (doMonotone) {
      Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
      Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
      Ddi_Vararray_t *aV = Ddi_VararrayAlloc(ddm,0);
      Ddi_Bdd_t *monotoneB = Ddi_AigNnf (b,NULL,constr,rV,aV,NULL);
      Ddi_Vararray_t *suppA;
      Ddi_Varset_t *suppM, *suppRef, *suppAux, *suppCommon;
      Ddi_Bdd_t *cubeConstr;
      Ddi_Bddarray_t *constrA, *rLits, *constrR;
      Ddi_Bdd_t *myCarePlus=Ddi_BddDup(myCare);
      int j, i, mySat;

      printf("Monotone AIG size: %d\n", Ddi_BddSize(monotoneB));

      Ddi_BddSetAig(monotoneB);

      Ddi_BddSetAig(constr);

      Pdtutil_Assert(1 || !Ddi_AigSatAnd(monotoneB,a,constr),
		     "wrong monotone encoding");

      Ddi_BddAndAcc(myCarePlus,constr);

      Ddi_Bdd_t *iCore = Ddi_AigSatAndWithAigCore (monotoneB,
						 a,myCarePlus,1,&mySat,-1.0);

      Ddi_Free(monotoneB);
      Ddi_Free(constr);
      Ddi_Free(iCore);
      Ddi_Free(myCarePlus);
      Ddi_Free(rV);
      Ddi_Free(aV);

      Ddi_Free(constr);
    }

    if (doItp) {

      int sat;
      Ddi_Bdd_t *a = Ddi_BddarrayRead(benchArray,1);
      Ddi_Bdd_t *b = Ddi_BddarrayRead(benchArray,2);
      Ddi_Bdd_t *a1, *a0, *b1, *b0, *fPart, *p0, *bComposed=NULL;

      Ddi_Varset_t *suppA = Ddi_BddSupp(a);
      Ddi_Varset_t *suppB = Ddi_BddSupp(b);
      Ddi_Varset_t *glob = Ddi_VarsetIntersect(suppA,suppB);
      Ddi_Vararray_t *gv = Ddi_VararrayMakeFromVarset(suppB, 1);

      Ddi_Bdd_t *newF, *newF0, *newF1, *interpolant;
      Ddi_Varset_t *g1 = Ddi_VarsetVoid(ddm);
      int i, itpPart = -2; //-(method-5);
      int no = Ddi_BddarrayNum(benchArray);
      if (no>4) {
        int np = (no-5)/2;
        int s = no-(2*np)-1;
        Ddi_Bdd_t *impl = Ddi_BddMakeConstAig(ddm,1);
        while (Ddi_BddSize(Ddi_BddarrayRead(benchArray,s))==1) s--;
        Pdtutil_Assert((no-s)%2 > 0, "error in decomp cone indexes");
        np = (no - s) / 2;
        printf("decomp vars: %d\n", np);
        if (s==3) {
          Ddi_Free(myCare);
          myCare = Ddi_BddMakeConstAig(ddm,1);
        }
        Ddi_Bdd_t *coneTop = Ddi_BddarrayRead(benchArray,s);
        Ddi_Vararray_t *vars = Ddi_VararrayAlloc(ddm,np);
        Ddi_Bddarray_t *subst = Ddi_BddarrayAlloc(ddm,np);
        for (i=0; i<np; i++) {
          Ddi_Bdd_t *lit = Ddi_BddarrayRead(benchArray,s+1+i);
          Ddi_Bdd_t *s_i = Ddi_BddarrayRead(benchArray,s+1+np+i);
          Ddi_Var_t *v = Ddi_BddTopVar(lit);
          Pdtutil_Assert(Ddi_BddSize(lit)==1,"wrong lit");
          Ddi_VararrayWrite(vars,i,v);
          Ddi_BddarrayWrite(subst,i,s_i);
          if (Ddi_BddIsConstant(s_i)) {
            Ddi_Bdd_t *litImpl = Ddi_BddMakeLiteralAig(v,Ddi_BddIsOne(s_i));
            Ddi_BddAndAcc(impl,litImpl);
            Ddi_Free(litImpl);
          }
        }
        //        Ddi_AigConstrainCubeAcc(coneTop,impl);
        Ddi_Vararray_t *newVars =
          Ddi_VararrayMakeNewVars (vars, "PDT_ITP_CUT_", "", 1);
        Ddi_BddSubstVarsAcc(coneTop,vars,newVars);

        Ddi_Free(impl);
        bComposed = Ddi_BddMakeCompose (coneTop,NULL,newVars,subst,
				        NULL,NULL,NULL);
      }

      for (i=0; i<Ddi_VararrayNum(gv); i++) {
	if (strstr(Ddi_VarName(Ddi_VararrayRead(gv,i)),"$NS")!=NULL)
	  Ddi_VarsetAddAcc(glob,Ddi_VararrayRead(gv,i));
      }

      //      	Ddi_AigConstrainOptAcc(a,care,NULL,NULL,NULL,3);
      //	Ddi_AigConstrainOptAcc(b,care,NULL,NULL,NULL,1);
      if (0&&method > 5) {

	method -= 4;
      }
      //      ddm->settings.aig.itpOpt = 0;

      //Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,2);

      //    ddiAbcOptAcc (a,-1);
      //    ddiAbcOptAcc (b,-1);

      //      itpPart = -3;
      //enItpBddOpt=0;

      if (0) {
	int j,l;
	Ddi_Vararray_t *ps, *ns;
	char name[100];
	int res, maxGen=200;
	Ddi_Varset_t *totv = Ddi_VarsetUnion(suppA,suppB);
	Ddi_Vararray_t *tv = Ddi_VararrayMakeFromVarset(glob, 1);

	ps = Ddi_VararrayAlloc(ddm,0);
	ns = Ddi_VararrayAlloc(ddm,0);

	for (j=0; j<Ddi_VararrayNum(tv); j++) {
	  Ddi_Var_t *vp, *v = Ddi_VararrayRead(tv,j);
	  char *n = Ddi_VarName(v);
	  sprintf(name,"%s$PS",n);
	  vp = Ddi_VarFromName(ddm,name);
	  if (vp==NULL) {
	    vp = Ddi_VarNew(ddm);
	    Ddi_VarAttachName (vp, name);
	  }
	  Ddi_VararrayInsertLast(ns,v);
	  Ddi_VararrayInsertLast(ps,vp);
	}

	Ddi_Bdd_t *myCare1 = Ddi_AigInterpolantByGenClauses(b,a,NULL,
			   myCare,
			   ps,ns,NULL,tv,NULL,NULL,NULL,
			   maxGen,0,&res);

	Ddi_BddNotAcc(myCare1);
	Ddi_AigStructRedRemAcc (itp,NULL);
	ddiAbcOptAcc (itp,-1);
	Ddi_AigOptByBddSweepTop(itp,NULL,2);
	Ddi_AigOptByBddSweepTop(itp,myCare1,2);

      }

      startTime = util_cpu_time();
      printf("\nComputing interpolant!!!\n");
      //      b = Ddi_BddPartRead(bPart,0);
      if (bComposed!=NULL) b = bComposed;
      interpolant = Ddi_AigSatAndWithInterpolant(a,b,glob,NULL,myCare,NULL,
						 NULL,NULL,
						 &sat,itpPart,1,-1.0);
      endTime = util_cpu_time();
      Pdtutil_Assert(interpolant!=NULL,"non null itp required");
      printf("ITP(%d,%d,%d) -> %d\n",
             Ddi_BddSize(a),Ddi_BddSize(b),care==NULL?0:Ddi_BddSize(care),
             Ddi_BddSize(interpolant));
      fprintf(dMgrO(ddm),"Execution time = %s)\n",
            util_print_time(endTime-startTime));

      Ddi_AigStructRedRemAcc (interpolant,NULL);
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
        printf("TOT aig after struct rr: %d)\n", Ddi_MgrReadAigNodesNum(ddm))
      );

      ddiAbcOptAcc (itp,-1);
      printf("ABC opt size: %d - supp: %d\n", Ddi_BddSize(itp),
	   Ddi_VarsetNum(supp));

      if( strrchr(filename,'.') !=NULL ){
	strcpy(fileOut,filename);
	c=strrchr(fileOut,'.');
	strcpy(c,"_AIGOUT.aig");
      }else{
	sprintf(fileOut, "%s_ITPOUT.aig", filename);
      }

      Ddi_BddarrayWrite(benchArray,0,interpolant);

      Ddi_AigarrayNetStoreAiger(benchArray, 0, fileOut);
      printf("Final ITP written in %s\n",fileOut);

      exit(1);


    }

    Ddi_BddSetAig(itp);

    if (1) {
      Ddi_Varset_t *supp = Ddi_BddSupp(itp);
      enBddOpt = Ddi_VarsetNum(supp) <= Ddi_MgrReadAigBddOptLevel (ddm)*60;
      Ddi_Free(supp);
    }

    int bddDone = 0;
    if (enBddOpt) {
      bddDone = Ddi_AigOptByBdd(itp,-1,500000) > 0;
    }
    if (!bddDone) {
      Ddi_AigOptByFoCntTop(itp, NULL, 0);
    }

    if (itp != NULL && itpCoreTh>0 &&
      ((itpSize = Ddi_BddSize(itp)) > itpCoreTh)) {
      Ddi_Bdd_t *b = Ddi_BddarrayRead(benchArray,2);
      Ddi_Bdd_t *myB = Ddi_BddDup(b);
      int size=Ddi_BddSize(itp);
      Ddi_Bddarray_t *iteItp = Ddi_AigPartitionTopIte(itp,size/10);
      Ddi_Bdd_t *iteConstr=NULL, *iteElse=NULL, *iteThen;
      if (1&&(iteItp!=NULL)) {
        Ddi_Bdd_t *newItp;

        Ddi_BddSetAig(Ddi_BddarrayRead(iteItp,0));

        iteThen = Ddi_BddDup(Ddi_BddarrayRead(iteItp,1));
        iteConstr = Ddi_BddDup(Ddi_BddarrayRead(iteItp,0));
        iteElse = Ddi_BddDup(Ddi_BddarrayRead(iteItp,2));
        newItp = Ddi_BddIte(iteConstr,iteThen,iteElse);
        Pdtutil_Assert(Ddi_AigEqualSat(newItp,itp),"wrokg ITE decomp");
        Ddi_BddAndAcc(myCare,iteConstr);

        Ddi_AigOptByMonotoneCoreAcc (iteThen,myB,myCare,0,-1.0);

        Ddi_Free(newItp);
      }
      else {
        Ddi_AigOptByMonotoneCoreAcc (itp,b,myCare,0,-1.0);
      }
      Ddi_Free(myB);
      Ddi_Free(iteItp);
      Ddi_Free(iteConstr);
      Ddi_Free(iteThen);
      Ddi_Free(iteElse);
      //      Ddi_AigOptByMonotoneCoreAcc (itp,b,myCare,0,-1.0);
    }

    Ddi_Free(supp);
    supp = Ddi_BddSupp(itp);
    printf("Final AIG size: %d - supp: %d\n", Ddi_BddSize(itp),
	   Ddi_VarsetNum(supp));

    //    Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
    //    Ddi_MgrSetSiftThresh (ddm, 100000);
    //    Ddi_BddSetMono(myCare);
    //    AigOptByBddWithThresh(itp,myCare,1000000,1000.0,10000000);
    //    Ddi_AigOptByBddWithCare(itp,myCare,200.0,-1);
    // printf("Final AIG size (after bdd opt): %d - supp: %d\n",
    // Ddi_BddSize(itp), Ddi_VarsetNum(supp));

    //basic output filename management
    if( strrchr(filename,'.') !=NULL ){
      strcpy(fileOut,filename);
      c=strrchr(fileOut,'.');
      strcpy(c,"_AIGOUT.aig");
    }else{
      sprintf(fileOut, "%s_AIGOUT.aig", filename);
    }

    FILE* fpt_aigout;
    fpt_aigout=fopen(fileOut, "r");
    if( fpt_aigout!=NULL ){
            c=strrchr(fileOut,'.');
	    strcpy(c,"_OPT.aig");
	    fclose(fpt_aigout);
    }

    Ddi_AigNetStoreAiger(itp,1/*bad*/,fileOut);
    printf("Final AIG written in %s\n",fileOut);

    Ddi_Free(benchArray);
    Ddi_Free(supp);
    Ddi_Free(itp);
    Ddi_Free(myCare);
    return 0;
  }


  if (method == 2 || method == 4) {
    int i;
    Ddi_Bddarray_t *newD;
    Ddi_Varset_t *supp = Ddi_BddarraySupp(benchArray);
    Ddi_Vararray_t *retimeCand = Ddi_VararrayMakeFromVarset(supp, 1);
    Ddi_Bddarray_t *substF = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Vararray_t *substV = Ddi_VararrayAlloc(ddm,0);
    int fwdCut = 1;

    Ddi_Free(supp);

    for (i=Ddi_VararrayNum(retimeCand)-1; i>=0; i--) {
      char *name = Ddi_VarName(Ddi_VararrayRead(retimeCand,i));
      if (strstr(name,"l")==NULL) {
	Ddi_VararrayRemove(retimeCand,i);
      }
    }

    newD = Ddi_BddarrayFindMinCut (benchArray, NULL, retimeCand, NULL,
				   substF, substV, method>2, fwdCut);

    Ddi_BddarrayComposeAcc(newD,substV,substF);
    for (i=0; i<Ddi_BddarrayNum(newD); i++) {
      Ddi_Bdd_t *f0 = Ddi_BddarrayRead(benchArray,i);
      Ddi_Bdd_t *f1 = Ddi_BddarrayRead(newD,i);
      Pdtutil_Assert(Ddi_BddEqualSat(f0,f1),"invalid cut");
    }

    Ddi_Free(newD);
    Ddi_Free(retimeCand);
    Ddi_Free(substF);
    Ddi_Free(substV);

    return 0;
  }



  if (method < 4 && benchArray != NULL) {


    f = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 0));

    if (Ddi_BddarrayNum(benchArray)>1) {
      care = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 1));
    }
    else {
      care = Ddi_BddMakeConstAig(ddm,1);
    }
    size = Ddi_BddSize(f);

    if (size>5 && size<5000000) {
      int i, size0, size1;
      fflush(NULL);
      fprintf(dMgrO(ddm),"Initial circuit size = %d (care=%d)\n",
	      size, Ddi_BddSize(care));
      fflush(NULL);

      startTime = util_cpu_time();

      Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
      Ddi_MgrSetSiftThresh (ddm, 100000);

      //Ddi_AigOptTop(f,0,1);
	    //	  DdiAigRedRemovalAcc (f,care,-1,60.0);
	    //          ddiAbcOptAcc (f,-1);

	  //  	  Ddi_AigOptByFoCnt(f, 50, -1, 8, 10, 100000, 4, 1);
      printf("INITIAL SIZE: %d\n", size);

      for (i=0; i<4; i++) {
	int j, bddMergeTh = 250;
	int bddSizeTh = i<1 ? 0 : 50000;
	int iteStrategy = i<3 ? i+1 : 4;
	size0 = size = Ddi_BddSize(f);
	Ddi_AigOptByFoCnt(f, 100, -1, 8, 10, size/3, 3, 1, 0, 1, NULL);
	size1 = size = Ddi_BddSize(f);
        printf("intermediate SIZE1[%d]: %d\n", i, size1);
	Ddi_AigOptByFoCnt(f, 100, -1, 8, 10, size/3, 3, 1, 0, 0, NULL);
	size1 = size = Ddi_BddSize(f);
        printf("intermediate SIZE2[%d]: %d\n", i, size1);
	Ddi_AigOptByFoCnt(f, 100, -1, 8, 10, size/3, 3, 1, 0, -1, NULL);
	size1 = size = Ddi_BddSize(f);
        printf("intermediate SIZE3[%d]: %d\n", i, size1);

	for (j=1; j<=3; j++) {
	  Ddi_AigOptByFoCnt(f, 100, -1, 8, 10, size/3, 3,
			    bddMergeTh, 5+(i+j)%2, 1, NULL);
	  size1 = size = Ddi_BddSize(f);
	  printf("merged SIZE[%d]: %d\n", i, size1);
	  bddMergeTh *=2;
	}
	  //Ddi_AigOptByBdd(f,200.0);
	  //	  Ddi_AigSift(f,NULL);
	Ddi_AigOptByFoCnt(f, 100,-1,8,10,size/3,3,
			  bddSizeTh,iteStrategy, 1, NULL);
	size1 = size = Ddi_BddSize(f);
        printf("intermediate SIZE4[%d]: %d\n", i, size1);
	//if (size1 * 1.1 > size0) break;
      }

      printf("FINAL SIZE: %d\n", size1);
      return 0;
	  // Ddi_AigSift(f,NULL);

      if (doPart==1)
      {
	Ddi_Bdd_t *f2, *f3 = Ddi_AigPartitionTop(f,0);
	int i, l, j, max=0, ns, nsBase;
	Ddi_Bddarray_t *subst;
	Ddi_Varset_t *supp=Ddi_BddSupp(f3);
	Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(supp, 1);
	ns = Ddi_VarsetNum(supp);
	Ddi_Free(supp);
	f2 = Ddi_BddMakePartConjVoid(ddm);
	fprintf(dMgrO(ddm),"\n");
	for (i=Ddi_BddPartNum(f3)-1; i>=0; i--) {
	  Ddi_Bdd_t *f_i = Ddi_BddPartRead(f3,i);
	  Ddi_Varset_t *s = Ddi_BddSupp(f_i);
	  int n=Ddi_VarsetNum(s);
	  if (n<(ns*78/81)) {
	    Ddi_Bdd_t *f_i_bdd;
	    fprintf(dMgrO(ddm),"PART(%d) -> size: %d\n", i, Ddi_BddSize(f_i));
	    //	      f_i_bdd = Ddi_BddMakeMono(f_i);
	    f_i_bdd = Ddi_BddDup(f_i);
	    Ddi_BddPartRemove(f3,i);
	    Ddi_BddPartInsertLast(f2,f_i_bdd);
	    Ddi_Free(f_i_bdd);
	  }
	  else {
	    int j;
	    if (n>max) max=n;
	    for (j=0; j<Ddi_VararrayNum(vA); j++){
	      Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
	      fprintf(dMgrO(ddm),"%c", Ddi_VarInVarset(s,v) ? '*':'.');
	    }
	    fprintf(dMgrO(ddm),"\n");
	    ns += 100;
	  }
	  Ddi_Free(s);
	  //	    Ddi_AigOptByBdd(f_i,200.0);
	  Ddi_BddSetAig(f_i);
	}
	Ddi_Free(vA);
	fprintf(dMgrO(ddm),"MAX supp: %d/%d\n", max, ns);
	supp = Ddi_BddSupp(f3);
	vA = Ddi_VararrayMakeFromVarset(supp, 1);
	subst = Ddi_BddarrayMakeLiterals(vA, 1);

	for (i=0; 0&&(i<Ddi_BddarrayNum(subst)); i++) {
	  Ddi_Bdd_t *s_i = Ddi_BddarrayRead(subst,i);
	  Ddi_BddConstrainAcc(s_i,f2);
	  Ddi_BddSetAig(s_i);
	}
	Ddi_BddSetAig(f3);
	Ddi_BddSetAig(f2);
	//	  Ddi_BddComposeAcc(f3,vA,subst);
	Ddi_AigOptByBdd(f3,200.0,-1);
	Ddi_AigOptByBdd(f2,200.0,-1);

	Ddi_DataCopy(f,f3);
	Ddi_Free(vA);
	Ddi_Free(subst);
	Ddi_Free(supp);
      }
      else if (doPart>1)
      {
	Ddi_Bdd_t *f2, *f3, *constr = Ddi_AigPartitionTop(f,0);
	int i, l, j;
	l = Ddi_BddPartNum(constr)-1;
	f2 = Ddi_BddPartExtract(constr,l);
	Ddi_BddSetAig(constr);

	f3 = Ddi_AigPartitionTop(f2,1);
	for (i=Ddi_BddPartNum(f3)-1; i>=0; i--) {
	  Ddi_Bdd_t *f_i = Ddi_BddPartRead(f3,i);
	  Ddi_Bdd_t *f_i_p = Ddi_AigPartitionTop(f_i,0);
	  for (j=Ddi_BddPartNum(f_i_p)-1; j>=0; j--) {
	    Ddi_Bdd_t *f_i_j = Ddi_BddPartRead(f_i_p,j);
	    Ddi_AigOptByBdd(f_i_j,200.0,-1);
	  }
	  Ddi_BddSetAig(f_i_p);
	  Ddi_DataCopy(f_i,f_i_p);
	  Ddi_Free(f_i_p);
	  Ddi_BddAndAcc(f_i,constr);
	  Ddi_AigOptByBdd(f_i,200.0,-1);
	  Ddi_DataCopy(constr,f_i);

	}

	Ddi_AigOptByBdd(f2,200.0,-1);

      }
      else
      {
	int i;
	Ddi_Bdd_t *f0, *f1;
	Ddi_Varset_t *supp = Ddi_BddSupp(f);
	Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(supp, 1);
	Ddi_Bdd_t *f2 = Ddi_BddMakeConstAig(ddm,0);
	for (i=0; i<Ddi_VararrayNum(vA); i++) {
	  Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
	  int size0, size1;
	  f0 = Ddi_BddCofactor(f,v,0);
	  f1 = Ddi_BddCofactor(f,v,1);
	  Ddi_BddDiffAcc(f0,lit);
	  Ddi_BddAndAcc(f1,lit);
	  size0 = Ddi_BddSize(f0);
	  size1 = Ddi_BddSize(f1);
	  fprintf(dMgrO(ddm),"v: %s - s0: %d, s1: %d\n", Ddi_VarName(v), size0, size1);
	  if (size0*2 < size1) {
	    Ddi_BddOrAcc(f2,f0);
	    Ddi_DataCopy(f,f1);
	  }
	  else if (size1*2 < size0) {
	    Ddi_BddOrAcc(f2,f1);
	    Ddi_DataCopy(f,f0);
	  }
	  Ddi_Free(lit);
	  Ddi_Free(f0);
	  Ddi_Free(f1);
	}
	Ddi_AigOptByBdd(f,200.0,-1);
	Ddi_AigOptByBdd(f2,200.0,-1);
	Ddi_BddOrAcc(f,f2);
      }

    }
  }
  else if (benchArray != NULL) {
    // method = 5, 10, ...
    care = NULL;
    if (Ddi_BddarrayNum(benchArray)>3) {
      care = Ddi_BddarrayRead(benchArray,3);
    }
    {
      int sat;
      Ddi_Bdd_t *a = Ddi_BddarrayRead(benchArray,1);
      Ddi_Bdd_t *b = Ddi_BddarrayRead(benchArray,2);
      Ddi_Bdd_t *a1, *a0, *b1, *b0, *fPart, *p0;

      Ddi_Varset_t *suppA = Ddi_BddSupp(a);
      Ddi_Varset_t *suppB = Ddi_BddSupp(b);
      Ddi_Varset_t *glob = Ddi_VarsetIntersect(suppA,suppB);
      Ddi_Vararray_t *gv = Ddi_VararrayMakeFromVarset(suppB, 1);

      Ddi_Bdd_t *newF, *newF0, *newF1, *interpolant;
      Ddi_Varset_t *g1 = Ddi_VarsetVoid(ddm);
      int i, itpPart = -(method-5);

      for (i=0; i<Ddi_VararrayNum(gv); i++) {
	if (strstr(Ddi_VarName(Ddi_VararrayRead(gv,i)),"$NS")!=NULL)
	  Ddi_VarsetAddAcc(glob,Ddi_VararrayRead(gv,i));
      }

      //      	Ddi_AigConstrainOptAcc(a,care,NULL,NULL,NULL,3);
      //	Ddi_AigConstrainOptAcc(b,care,NULL,NULL,NULL,1);
      if (0&&method > 5) {

	method -= 4;
      }
      //      ddm->settings.aig.itpOpt = 0;

      //Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,2);

      //    ddiAbcOptAcc (a,-1);
      //    ddiAbcOptAcc (b,-1);

      //enItpBddOpt=0;
      startTime = util_cpu_time();
      printf("\nComputing interpolant!!!\n");
      interpolant = Ddi_AigSatAndWithInterpolant(a,b,glob,NULL,care,NULL,
						 NULL,NULL,
						 &sat,itpPart,1,-1.0);
      endTime = util_cpu_time();
      Pdtutil_Assert(interpolant!=NULL,"non null itp required");
      printf("ITP(%d,%d,%d) -> %d\n",
             Ddi_BddSize(a),Ddi_BddSize(b),care==NULL?0:Ddi_BddSize(care),
             Ddi_BddSize(interpolant));
      fprintf(dMgrO(ddm),"Execution time = %s)\n",
            util_print_time(endTime-startTime));

      exit(1);

      if (1)
      {
	Ddi_Bdd_t *pB = Ddi_AigPartitionTop(b,1);

	int i, iMin, s, sMin, sTot;
	Ddi_Bdd_t *p_i, *i2, *b0, *b2 = Ddi_BddMakeConstAig(ddm,0);
	sTot = Ddi_BddSize(b);
	for (i=Ddi_BddPartNum(pB)-1; i>=0; i--) {
	  p_i = Ddi_BddPartRead(pB,i);
	  s = Ddi_BddSize(p_i);
	  if (s<sTot*0.7) {
	    p_i = Ddi_BddPartExtract(pB,i);
	    Ddi_BddOrAcc(b2,p_i);
	    Ddi_Free(p_i);
	  }
	}
	i2 = Ddi_AigSatAndWithInterpolant(a,b2,glob,NULL,NULL,
					  NULL,NULL,NULL,&sat,0,0,-1.0);

	ddiAbcOptAcc (i2,-1);

	  b0 = Ddi_BddDup(b);
          Ddi_AigExistProjectAllSolutionAcc(b0,glob,i2,10);
	  Ddi_BddNotAcc(b0);
	  AigRedRemovalIncrByControlClasses(b, b0, -1);
	  Ddi_BddAndAcc(b,b0);
	  ddiAbcOptAcc (b,-1);
	  Ddi_BddSetAig(pB);
#if 0
	  ddiAbcOptAcc (pB,-1);
	  Ddi_AigConstrainOptAcc(pB,i2,NULL,NULL,NULL,3);
	  ddiAbcOptAcc (pB,-1);
#endif
  	  newF = Ddi_AigSatAndWithInterpolant(a,b,glob,NULL,NULL,NULL,
					      NULL,NULL,&sat,0,0,-1.0);
	  Ddi_BddAndAcc(newF,i2);
	  Ddi_BddDiffAcc(newF,b0);

	  Ddi_Free(b0);

	  Ddi_Free(pB);
	}
	else {
	//	Ddi_Free(cone); cone = Ddi_BddMakeAig(pCone);

	  newF = Ddi_AigSatAndWithInterpolant(a,b,glob,NULL,NULL,NULL,
					      NULL,NULL,&sat,0,0,-1.0);
	}

	ddiAbcOptAcc (newF,-1);

        Ddi_AigOptByPart(newF, NULL, 1, -1.0);
        Ddi_AigOptByPart(newF, NULL, 1, -1.0);
        Ddi_AigOptByPart(newF, NULL, 2, -1.0);

	ddiAbcOptAcc (newF,-1);
      	Ddi_AigOptByBdd (newF,-1.0,-1);
	if (0)
	{
	  Ddi_Varset_t *supp = Ddi_BddSupp(newF);
	  Ddi_Vararray_t *sA = Ddi_VararrayMakeFromVarset(supp,1);
	  int j, k;
	  Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
	  Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm,1);
	  for (j=0; j<Ddi_VararrayNum(sA); j+=10) {
	    Ddi_Bdd_t *myPart = Ddi_BddDup(newF);
	    Ddi_Varset_t *proj = Ddi_VarsetVoid(ddm);
	    for (k=j; k<Ddi_VararrayNum(sA) && k<j+10; k++) {
	      Ddi_VarsetAddAcc(proj,Ddi_VararrayRead(sA,k));
	    }
	    Ddi_AigProjectAllSolutionImgAcc (myPart,proj,myCare,-1,0);
	    Ddi_BddAndAcc(constr,myPart);
	    Ddi_Free(myPart);
	    Ddi_Free(proj);
	  }

	  Ddi_AigConstrainOptAcc(newF,constr,NULL,NULL,NULL,3);
	  ddiAbcOptAcc (newF,-1);

	  Ddi_Free(constr);
	  Ddi_Free(myCare);
	  Ddi_Free(supp);
	}

	Ddi_AigOptCustom(newF,care,1,-1);
	//        Ddi_AigOptByPart(newF, NULL, 3, -1.0);

	if (ddm->settings.aig.partialItp) {
#if 0
	a0 = Ddi_BddAnd(a,newF);
	a1 = Ddi_BddDiff(a,newF);
#else
	a0 = Ddi_BddDup(a);
	a1 = Ddi_BddDup(a);
	b0 = Ddi_BddDup(b);
	b1 = Ddi_BddDup(b);
	//	Ddi_AigConstrainOptAcc(a1,newF,NULL,NULL,NULL,3);
	Ddi_AigConstrainOptAcc(b1,newF,NULL,NULL,NULL,3);
	Ddi_BddAndAcc(a0,newF);
	//Ddi_BddAndAcc(a1,newF);
	//	Ddi_BddAndAcc(b1,newF);
	Ddi_BddNotAcc(newF);
	//	Ddi_AigConstrainOptAcc(a0,p0,NULL,NULL,NULL,3);
	Ddi_AigConstrainOptAcc(b0,newF,NULL,NULL,NULL,3);
	//Ddi_BddAndAcc(a0,newF);
	Ddi_BddAndAcc(a1,newF);
	//	Ddi_BddAndAcc(b0,p0);
	Ddi_BddNotAcc(newF);
#endif
	printf("interpolant size-part: %d\n", Ddi_BddSize(newF));
	ddiAbcOptAcc (a0,-1);
	ddiAbcOptAcc (a1,-1);
	ddiAbcOptAcc (b0,-1);
	ddiAbcOptAcc (b1,-1);

	ddm->settings.aig.itpOpt = 0;
	ddm->settings.aig.partialItp = 0;
	newF0 = Ddi_AigSatAndWithInterpolant(a0,b0,glob,NULL,NULL,NULL,
					     NULL,NULL,&sat,0,0,-1.0);

	ddiAbcOptAcc (newF0,-1);
	printf("interpolant size0: %d\n", Ddi_BddSize(newF0));
        //Ddi_AigConstrainOptAcc(b1,newF0,NULL,NULL,NULL,3);
        ddiAbcOptAcc (b1,-1);
	//	Ddi_AigConstrainOptAcc(a,newF,NULL,NULL,NULL,3);
        // ddiAbcOptAcc (a,-1);
	newF1 = Ddi_AigSatAndWithInterpolant(a1,b1,glob,NULL,NULL,NULL,
					     NULL,NULL,&sat,0,0,-1.0);
	printf("interpolant size0: %d\n", Ddi_BddSize(newF0));
	ddiAbcOptAcc (newF1,-1);
#if 0
	Ddi_BddAndAcc(newF1,newF);
	Ddi_BddDiffAcc(newF0,newF);
#endif
	Ddi_Free(newF);

	newF = Ddi_BddOr(newF0,newF1);
	b0 = Ddi_BddDup(b);
	Ddi_AigConstrainOptAcc(b0,newF,0,0,NULL,3);

	ddiAbcOptAcc (b0,-1);

	newF0 = Ddi_AigSatAndWithInterpolant(a,b0,glob,NULL,NULL,
					     0,0,NULL,&sat,0,0,-1.0);

	Ddi_BddAndAcc(newF,newF0);
	}

	{
	  Ddi_Bdd_t *tmp = Ddi_BddDiff(a,newF);
	  Pdtutil_Assert(!Ddi_AigSat(tmp),"wrong part interpolant");
	  Ddi_Free(tmp);
	  tmp = Ddi_BddAnd(newF,b);
	  Pdtutil_Assert(!Ddi_AigSat(tmp),"wrong part interpolant");
	  Ddi_Free(tmp);
	}

	Ddi_Free(gv);

	Ddi_Free(newF);
	Ddi_Free(suppA);
	Ddi_Free(suppB);
	Ddi_Free(glob);

	//        ddiAbcOptAcc (f,-1);
	//        Ddi_AigOptCustom(f,care,1,-1);
    }

      {
	int sat, n, i;
	Ddi_Varset_t *a, *b, *c, *d;
	Ddi_Bdd_t *cone = f, *pCone;
	Ddi_Bdd_t *tp = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 2));
	Ddi_Bdd_t *tpc = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 3));

      fprintf(dMgrO(ddm),"Initial circuit size = %d/%d/%d/%d)\n",
	     Ddi_BddSize(cone),
	     Ddi_BddSize(care),
	     Ddi_BddSize(tp),
	     Ddi_BddSize(tpc));

      fprintf(dMgrO(ddm),"Initial support size = %d/%d/%d/%d)\n",
	     Ddi_VarsetNum(a=Ddi_BddSupp(cone)),
	     Ddi_VarsetNum(b=Ddi_BddSupp(care)),
	     Ddi_VarsetNum(c=Ddi_BddSupp(tp)),
	     Ddi_VarsetNum(d=Ddi_BddSupp(tpc)));

      fprintf(dMgrO(ddm),"Common support size cone = %d)\n",
	     Ddi_VarsetNum(Ddi_VarsetIntersect(a,d)));
      fprintf(dMgrO(ddm),"Common support size care = %d)\n",
	     Ddi_VarsetNum(Ddi_VarsetIntersect(b,d)));
      fprintf(dMgrO(ddm),"Common support size tp   = %d)\n",
	     Ddi_VarsetNum(Ddi_VarsetIntersect(c,d)));

	Ddi_AigConstrainCubeAcc(cone,tpc);
	//	Ddi_AigConstrainCubeAcc(care,tpc);

	Ddi_Free(a); a=Ddi_BddSupp(cone);
	Ddi_Free(b); b=Ddi_BddSupp(care);

      fprintf(dMgrO(ddm),"Common support size cone = %d)\n",
	     Ddi_VarsetNum(Ddi_VarsetIntersect(a,d)));
      fprintf(dMgrO(ddm),"Common support size care = %d)\n",
	     Ddi_VarsetNum(Ddi_VarsetIntersect(b,d)));
      Ddi_Free(a);
      Ddi_Free(b);
      Ddi_Free(c);
      Ddi_Free(d);


      pCone = Ddi_AigPartitionTop(f,1);
      n = Ddi_BddPartNum(pCone);
      fprintf(dMgrO(ddm),"part num: %d\n", n);
      for (i=0; i<n; i++) {
	printf("%d ", Ddi_BddSize(Ddi_BddPartRead(pCone,i)));
      }
      fprintf(dMgrO(ddm),"\n");

      {
        int i, iMin, s, sMin, sTot;
        Ddi_Bdd_t *p_i, *c2 = Ddi_BddMakeConstAig(ddm,0);
	sTot = Ddi_BddSize(cone);
	while (1) {
	  iMin = -1;
	  for (i=0; i<Ddi_BddPartNum(pCone); i++) {
	    p_i = Ddi_BddPartRead(pCone,i);
	    s = Ddi_BddSize(p_i);
	    if (iMin<0 || s<sMin) {
	      iMin = i; sMin = s;
	    }
	  }
	  p_i = Ddi_BddPartExtract(pCone,iMin);
	  Ddi_BddOrAcc(c2,p_i);
	  fprintf(dMgrO(ddm),"%d) (%d,%d) %d\n", i,
		 Ddi_BddSize(c2),
		 Ddi_BddSize(pCone),
		 Ddi_BddSize(p_i));
	  s = Ddi_BddSize(p_i);
	  if (1 && (s>sTot*0.05)) {
	    Ddi_Free(p_i);
	    break;
	  }
	  Ddi_Free(p_i);
	}
	//	Ddi_Free(cone); cone = Ddi_BddMakeAig(pCone);
	Ddi_Free(pCone);
	Ddi_BddNotAcc(cone);
	//	Pdtutil_Assert(!Ddi_AigSatAnd(cone,c2,0),"ERROR");
	Ddi_BddNotAcc(c2);
        Ddi_AigConstrainOptAcc(cone,c2,NULL,NULL,NULL,1);
	Ddi_BddAndAcc(cone,c2);
	Ddi_BddNotAcc(cone);
	Ddi_Free(c2);
      }

      //      Ddi_BddAndAcc(care,tp);
      //        Ddi_AigConstrainOptAcc(care,tp,NULL,NULL,NULL,1);
        Ddi_AigConstrainOptAcc(cone,care,NULL,NULL,NULL,1);
        Ddi_AigConstrainOptAcc(cone,tp,NULL,NULL,NULL,1);
	if (0)
        {
          int aol = Ddi_MgrReadAigAbcOptLevel (ddm);
          Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,1);

          ddiAbcOptAcc (cone,-1);
          Ddi_MgrSetOption(ddm,Pdt_DdiAigAbcOpt_c,inum,aol);
        }

    startTime = util_cpu_time();

	sat = Ddi_AigSatAnd(cone,care,tp);
	printf("sat: %d\n", sat);

    endTime = util_cpu_time();
    fprintf(dMgrO(ddm),"Execution time1 = %s)\n",
            util_print_time(endTime-startTime));

	Ddi_BddAndAcc(cone,care);
     	Ddi_BddAndAcc(cone,tp);

    startTime = util_cpu_time();

	sat = Ddi_AigSat(cone);
	printf("sat: %d\n", sat);

    endTime = util_cpu_time();
    fprintf(dMgrO(ddm),"Execution time2 = %s)\n",
            util_print_time(endTime-startTime));



    Ddi_Free(f);
    //    Ddi_Free(care);
      }
  }


  Ddi_Free(benchArray);
  return 0;
}
#else

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/

int
Ddi_AigCustCustomCombinationalCircuit (
  Ddi_Mgr_t *ddm,
  char *filename,
  int method
)
{
  Ddi_Bddarray_t *benchArray;
  Ddi_Bdd_t *a, *b, *f, *r;
  Ddi_Vararray_t *aVars, *bVars, *eqVars, *tmp;
  Ddi_Varset_t *supp;
  unsigned char *enAbstr;
  long startTime, endTime;
  int i, j, num;

  Ddi_MgrSetOption(ddm,Pdt_DdiSatTimeout_c,inum,1);
  benchArray = Ddi_AigarrayNetLoadBench(ddm, filename, NULL);
  if (benchArray != NULL) {
    assert(Ddi_BddarrayNum(benchArray) > 2);
    a = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 0));
    b = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 1));
    fprintf(dMgrO(ddm),"A size = %d, B size = %d\n", Ddi_BddSize(a), Ddi_BddSize(b));

    assert((Ddi_BddarrayNum(benchArray)-2) % 3 == 0);
    num = (Ddi_BddarrayNum(benchArray)-2) / 3;
    aVars = Ddi_VararrayAlloc(ddm, 0);
    bVars = Ddi_VararrayAlloc(ddm, 0);
    eqVars = Ddi_VararrayAlloc(ddm, 0);
    enAbstr = Pdtutil_Alloc(unsigned char, num);
    j = 2;
    for (i=0; i<num; i++) {
      f = Ddi_BddarrayRead(benchArray, j++);
      supp = Ddi_BddSupp(f);
      assert(Ddi_VarsetNum(supp) == 1);
      tmp = Ddi_VararrayMakeFromVarset(supp, 1);
      Ddi_Free(supp);
      Ddi_VararrayAppend(aVars, tmp);
      Ddi_Free(tmp);
      enAbstr[i] = 1;
    }
    for (i=0; i<num; i++) {
      f = Ddi_BddarrayRead(benchArray, j++);
      supp = Ddi_BddSupp(f);
      assert(Ddi_VarsetNum(supp) == 1);
      tmp = Ddi_VararrayMakeFromVarset(supp, 1);
      Ddi_Free(supp);
      Ddi_VararrayAppend(bVars, tmp);
      Ddi_Free(tmp);
    }
    for (i=0; i<num; i++) {
      f = Ddi_BddarrayRead(benchArray, j++);
      supp = Ddi_BddSupp(f);
      assert(Ddi_VarsetNum(supp) == 1);
      tmp = Ddi_VararrayMakeFromVarset(supp, 1);
      Ddi_Free(supp);
      Ddi_VararrayAppend(eqVars, tmp);
      Ddi_Free(tmp);
    }

    startTime = util_cpu_time();
    switch (method) {
      case 1:
	r = Ddi_AigAbstrVarsForInterpolant(a, b, aVars, bVars, eqVars, NULL, enAbstr,NULL);
	break;
      default:
	r = Ddi_AigAbstrVarsForInterpolantByRefinement(a, b, aVars, bVars, eqVars, NULL, NULL);
	break;
    }
    endTime = util_cpu_time();
    //printf("result size = %d\n", Ddi_BddSize(r));
    fprintf(dMgrO(ddm),"Execution time = %s)\n",
            util_print_time(endTime-startTime));

    Ddi_Free(a);
    Ddi_Free(b);
    Ddi_Free(aVars);
    Ddi_Free(bVars);
    Ddi_Free(eqVars);
    Pdtutil_Free(enAbstr);
    Ddi_Free(r);
  }
  Ddi_Free(benchArray);
  return 0;
}
#endif

/* #if 0 */
/* /\**Function******************************************************************* */
/*   Synopsis    [] */
/*   Description [] */
/*   SideEffects [] */
/*   SeeAlso     [] */
/* ******************************************************************************\/ */
/* int */
/* Ddi_AigCustomCombinationalCircuit ( */
/*   char *filename, */
/*   float timeLimit */
/* ) */
/* { */
/*   Ddi_Mgr_t *ddm; */
/*   Ddi_Bddarray_t *benchArray=NULL; */
/*   Ddi_Bdd_t *f, *care; */

/*   ddm = Ddi_MgrInit("DDI_manager", NULL, 0, DDI_UNIQUE_SLOTS, */
/* 		    DDI_CACHE_SLOTS*10, 0, -1, -1); */
/*   Ddi_AigInit(ddm,100); */

/* #if 1 */
/*   benchArray = Ddi_AigarrayNetLoadBench(ddm, filename, NULL); */
/*   if (benchArray != NULL) { */
/*     f = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 0)); */
/*     care = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 1)); */

/*     fprintf(dMgrO(ddm),"Combinational circuit size = %d (care=%d)\n", Ddi_BddSize(f), Ddi_BddSize(care)); */
/*     DdiAigRedRemovalAcc(f, care, -1, timeLimit); */
/*     Ddi_Free(f); */
/*     Ddi_Free(care); */
/*   } */
/* #else */
/*   f = Ddi_AigNetLoadBench(ddm, filename, NULL); */
/*
/*   Ddi_Free(f); */
/* #endif */

/*   Ddi_Free(benchArray); */
/*   return 0; */
/* } */
/* #else */
/* /\**Function******************************************************************* */
/*   Synopsis    [] */
/*   Description [] */
/*   SideEffects [] */
/*   SeeAlso     [] */
/* ******************************************************************************\/ */
/* int */
/* Ddi_AigCustomCombinationalCircuit ( */
/*   Ddi_Mgr_t *ddm, */
/*   char *filename, */
/*   int method */
/* ) */
/* { */
/*   Ddi_Bddarray_t *benchArray; */
/*   Ddi_Bdd_t *f, *care; */
/*   long startTime, endTime; */
/*   int size; */

/*   benchArray = Ddi_AigarrayNetLoadBench(ddm, filename, NULL); */
/*   if (benchArray != NULL) { */
/*     f = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 0)); */
/*     //Ddi_AigOptByBdd(f,30); */
/*     //exit (1); */

/*     care = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 1)); */
/*     size = Ddi_BddSize(f); */

/*     if (size>10 && size<10000) { */
/*       fflush(NULL); */
/*       fprintf(dMgrO(ddm),"Initial circuit size = %d (care=%d)\n", size, Ddi_BddSize(care)); */
/*       fflush(NULL); */

/*       switch (method) { */
/*         case 1: */
/* #if 1 */
/*           ddm->settings.aig.satIncrByRefinement = 2; */
/*           startTime = util_cpu_time(); */
/*           AigRedRemovalIncrByControlClasses(f, care, -1); */
/*           ddm->settings.aig.satIncrByRefinement = 3; */
/*           AigRedRemovalIncrByControlClasses(f, care, -1); */
/*           endTime = util_cpu_time(); */
/*           fflush(NULL); */
/*           fprintf(dMgrO(ddm),"Control method circuit size = %d (time = %.2f)\n", Ddi_BddSize(f), (endTime-startTime)/1000.0); */
/*           fflush(NULL); */
/* #endif */
/* #if 0 */
/* 	  Ddi_Free(f); */
/* 	  f = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 0)); */
/*           ddm->settings.aig.satIncrByRefinement = 2; */
/*           startTime = util_cpu_time(); */
/*           AigRedRemovalIncrByControlClasses(f, care, -1); */
/*           ddm->settings.aig.satIncrByRefinement = 4; */
/*           AigRedRemovalIncrByControlClasses(f, care, -1); */
/*           endTime = util_cpu_time(); */
/*           fflush(NULL); */
/*           fprintf(dMgrO(ddm),"Control method circuit size = %d (time = %.2f)\n", Ddi_BddSize(f), (endTime-startTime)/1000.0); */
/*           fflush(NULL); */
/* #endif */
/* #if 0 */
/* 	  Ddi_Free(f); */
/* 	  f = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 0)); */
/*           ddm->settings.aig.satIncrByRefinement = 3; */
/*           startTime = util_cpu_time(); */
/*           AigRedRemovalIncrByControlClasses(f, care, -1); */
/*           endTime = util_cpu_time(); */
/*           fflush(NULL); */
/*           fprintf(dMgrO(ddm),"Control method circuit size = %d (time = %.2f)\n", Ddi_BddSize(f), (endTime-startTime)/1000.0); */
/*           fflush(NULL); */
/* #endif */
/* #if 0 */
/* 	  Ddi_Free(f); */
/* 	  f = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 0)); */
/*           ddm->settings.aig.satIncrByRefinement = 4; */
/*           startTime = util_cpu_time(); */
/*           AigRedRemovalIncrByControlClasses(f, care, -1); */
/*           endTime = util_cpu_time(); */
/*           fflush(NULL); */
/*           fprintf(dMgrO(ddm),"Control method circuit size = %d (time = %.2f)\n", Ddi_BddSize(f), (endTime-startTime)/1000.0); */
/*           fflush(NULL); */
/* #endif */
/* #if 0 */
/* 	  Ddi_Free(f); */
/* 	  f = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 0)); */
/*           ddm->settings.aig.satIncrByRefinement = 5; */
/*           startTime = util_cpu_time(); */
/*           AigRedRemovalIncrByControlClasses(f, care, -1); */
/*           endTime = util_cpu_time(); */
/*           fflush(NULL); */
/*           fprintf(dMgrO(ddm),"Control method circuit size = %d (time = %.2f)\n", Ddi_BddSize(f), (endTime-startTime)/1000.0); */
/*           fflush(NULL); */
/* #endif */
/*           break; */

/*         case 2: */
/*           ddm->settings.aig.satIncrByRefinement = 0; */
/*           startTime = util_cpu_time(); */
/*           DdiAigRedRemovalAcc(f, care, -1, -1); */
/*           endTime = util_cpu_time(); */
/*           fflush(NULL); */
/*           fprintf(dMgrO(ddm),"Old method circuit size = %d (time = %.2f)\n", Ddi_BddSize(f), (endTime-startTime)/1000.0); */
/*           fflush(NULL); */
/*           break; */

/*         case 3: */
/*           ddm->settings.aig.satIncrByRefinement = 1; */
/*           startTime = util_cpu_time(); */
/*           DdiAigRedRemovalAcc(f, care, -1, -1); */
/*           endTime = util_cpu_time(); */
/*           fflush(NULL); */
/*           fprintf(dMgrO(ddm),"New (0/1) method circuit size = %d (time = %.2f)\n", Ddi_BddSize(f), (endTime-startTime)/1000.0); */
/*           fflush(NULL); */
/*           break; */

/*         case 4: */
/*           ddm->settings.aig.satIncrByRefinement = 2; */
/*           startTime = util_cpu_time(); */
/*           DdiAigRedRemovalAcc(f, care, -1, -1); */
/*           endTime = util_cpu_time(); */
/*           fflush(NULL); */
/*           fprintf(dMgrO(ddm),"New (-) method circuit size = %d (time = %.2f)\n", Ddi_BddSize(f), (endTime-startTime)/1000.0); */
/*           fflush(NULL); */
/*           break; */

/*         default: */
/*           fprintf(dMgrO(ddm),"Unknown R/R method!\n"); */
/*       } */
/*     } else { */
/*       fprintf(dMgrO(ddm),"Initial circuit size out of range (%d)\n", size); */
/*     } */
/*     Ddi_Free(f); */
/*     Ddi_Free(care); */
/*   } */

/*   Ddi_Free(benchArray); */
/*   return 0; */
/* } */
/* #endif */




/**Function*******************************************************************
  Synopsis    [] Funcion used for experiment described in TCAD 2018: perform logic synthesis
compaction on a single interpolant (no A or B parts), loaded from an aig file.
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int 
Ddi_AigSingleInterpolantLogicSynthesisCompaction(
  Ddi_Mgr_t *ddm,
  char *filename
)
{
  long last = util_cpu_time();
  
  /* ABC - ITP just Balance */
  Ddi_Bddarray_t *benchArray = Ddi_AigarrayNetLoadAiger(ddm,NULL,filename);
  assert(benchArray != NULL);
  int n = Ddi_BddarrayNum(benchArray);
  assert (n >=1);  
  Ddi_Bdd_t *itp = Ddi_BddDup(Ddi_BddarrayRead(benchArray, 0));
  Ddi_Varset_t *suppITP = Ddi_BddSupp(itp);
  
  printf("Initial AIG size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));
  printf("Round 1\n");

  Ddi_AigNetStoreAiger(itp,1/*bad*/,"itp-pdt0.aig");
  Ddi_AigStructRedRemAcc (itp,NULL);
  long rrTime = util_cpu_time();
  fprintf(stdout, "RR_Time: %s\n", util_print_time(rrTime - last));
  last = rrTime;
  Ddi_AigNetStoreAiger(itp,1/*bad*/,"itp-pdt1.aig");
  ddiAbcOptAcc (itp,-1);
  ddiAbcOptAcc (itp,-1);
  ddiAbcOptAcc (itp,-1);

  long abcTime = util_cpu_time();
  printf("ABC opt size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));
  fprintf(stdout, "ABC_Time: %s\n", util_print_time(abcTime - last));
  last = abcTime;

  Ddi_AigNetStoreAiger(itp,1/*bad*/,"itp-pdt2.aig");

  itp = Ddi_NnfClustSimplify(itp, 0);	
  long clustTime = util_cpu_time();
  fprintf(stdout, "Clust_Time: %s\n", util_print_time(clustTime - last));
  last = clustTime;

  Ddi_AigNetStoreAiger(itp,1/*bad*/,"itp-pdt3.aig");

  Ddi_Free(benchArray); 
  Ddi_Free(suppITP); 
  Ddi_Free(itp); 

  return 0;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
AigArrayRedRemovalIncrByControlClasses (
  Ddi_Bddarray_t *fAigArray,
  Ddi_Bdd_t *careAig,
  int onlyOuts,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigArray);
  bAig_Manager_t *aigMgr = ddm->aig.mgr;
  int i, j, k, lit, lit0, lit1, sign, sign0, sign1, sat, nConst, nEquiv=0;
  int elit, nFalse, nRun=0, doConst=1, doEquiv=ddm->settings.aig.satIncrByRefinement>2;
  int isOut1, isOut2, windowNodes=1000, doWindow=ddm->settings.aig.satIncrByRefinement<=4;
  int nNodes, windowStart, windowEnd, outFound, initSize=Ddi_BddarraySize(fAigArray);
  Ddi_Bddarray_t *redClasses, *reprs, *equals, *fOptArray=NULL;
  Ddi_Bdd_t *redClass, *newClass, *redNode, *one;
  unsigned long time_limit = ~0;
  bAigEdge_t baig, fBaig, *leaders;
  bAig_array_t *visitedNodes;
  vec<Lit> lits, clause, assumps;
  long startTime, endTime;
  Solver S;

  //printf("Controllability RED REM\n");
  startTime = util_cpu_time();
  if (timeLimit > 0) {
    time_limit = startTime + (int)(timeLimit*1000);
  }
  //doEquiv=0;
  //ddm->settings.aig.satIncrByRefinement = 2;

  /* get the initial red candidates by random simulation */
  visitedNodes = bAigArrayAlloc();
  bAigArrayWriteLast(visitedNodes, bAig_One);
  for (i=0; i<Ddi_BddarrayNum(fAigArray); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fAigArray,i);
    if (Ddi_BddIsConstant(fAig)) {
      continue;
    }
    fBaig = Ddi_BddToBaig(fAig);
    postOrderAigVisitIntern(aigMgr,fBaig,visitedNodes,-1);
  }
  postOrderAigClearVisitedIntern(aigMgr, visitedNodes);

  redClasses = AigComputeInitialRedClasses(ddm, fAigArray, visitedNodes, careAig, time_limit);
  if (!redClasses) {
    fprintf(dMgrO(ddm),"Red Control Rem aborted ...\n");
    bAigArrayFree(visitedNodes);
    return;
  }
#if 0
  fprintf(dMgrO(ddm),"Initial classes (%d): ", Ddi_BddarrayNum(redClasses));
  for (i=0; i<Ddi_BddarrayNum(redClasses); i++) {
    fprintf(dMgrO(ddm),"%d ", Ddi_BddPartNum(Ddi_BddarrayRead(redClasses, i)));
  }
  fprintf(dMgrO(ddm),"\n");
#endif

#if 0
  for (i=0; i<visitedNodes->num; i++) {
    assert(bAig_AuxAig1(aigMgr, visitedNodes->nodes[i]) == bAig_NULL);
    bAig_AuxAig1(aigMgr, visitedNodes->nodes[i]) = 0;
  }
#endif

  if (onlyOuts) {
    for (i=0; i<Ddi_BddarrayNum(fAigArray); i++) {
      Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fAigArray,i);
      if (Ddi_BddIsConstant(fAig)) {
	continue;
      }
      fBaig = Ddi_BddToBaig(fAig);
      bAig_AuxInt(aigMgr, fBaig) = 1;
    }
    for (i=Ddi_BddarrayNum(redClasses)-1; i>=0; i--) {
      outFound = 0;
      redClass = Ddi_BddarrayRead(redClasses,i);
      for (j=Ddi_BddPartNum(redClass)-1; j>=0; j--) {
	redNode = Ddi_BddPartRead(redClass, j);
	baig = Ddi_BddToBaig(redNode);
	if (bAig_AuxInt(aigMgr, baig) == 1) {
	  outFound = 1;
	} else {
	  if (onlyOuts > 1) {
	    Ddi_BddPartQuickRemove(redClass, j);
	  }
	}
      }
      if (i && Ddi_BddPartNum(redClass)==0) {
	Ddi_BddarrayQuickRemove(redClasses, i);
      }
    }
    if (onlyOuts > 1) {
      for (i=0; i<Ddi_BddarrayNum(fAigArray); i++) {
	Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fAigArray,i);
	if (Ddi_BddIsConstant(fAig)) {
	  continue;
	}
	fBaig = Ddi_BddToBaig(fAig);
	bAig_AuxInt(aigMgr, fBaig) = -1;
      }
    }
  }

  aig2CnfIdInit(ddm);
  for (i=0; i<Ddi_BddarrayNum(fAigArray); i++) {
    Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fAigArray,i);
    if (Ddi_BddIsConstant(fAig)) {
      continue;
    }
    MinisatClauses(S, fAig, NULL, NULL, 1);
  }
  if (careAig) {
    MinisatClauses(S, careAig, NULL, NULL, 0);
  }

  windowStart = 1;
  doWindow = doWindow && doEquiv && visitedNodes->num>1.5*windowNodes;
  if (doWindow) {
    if (ddm->settings.aig.satIncrByRefinement<4) {
      windowEnd = 1;
    } else {
      nNodes = Ddi_BddPartNum(Ddi_BddarrayRead(redClasses, 0));
      i = 1;
      while (nNodes<windowNodes && i<Ddi_BddarrayNum(redClasses)) {
	nNodes += Ddi_BddPartNum(Ddi_BddarrayRead(redClasses, i++))-1;
      }
      windowEnd = i;
      if (nNodes < windowNodes) {
	windowEnd = visitedNodes->num+1;
      }
    }
  } else {
    windowEnd = visitedNodes->num+1;
  }

  sat = 0;
  doConst = 1;
  do {
    if (!sat) {
      /* generate clauses for initial equivalences */
      for (i=windowStart; i<Ddi_BddarrayNum(redClasses) && i<windowEnd; i++) {
	redClass = Ddi_BddarrayRead(redClasses, i);
	redNode = Ddi_BddPartRead(redClass, 0);
	//assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) == 0);
	lit0 = aigCnfLit(S, redNode);
	for (j=1; j<Ddi_BddPartNum(redClass); j++) {
	  redNode = Ddi_BddPartRead(redClass, j);
	  //assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) == 0);
	  lit1 = aigCnfLit(S, redNode);
	  lit = aig2CnfNewIdIntern(ddm);
	  while (abs(lit) > S.nVars()) S.newVar();

	  /* lit => lit1 != lit2 */
	  MinisatClause3(S, clause, -lit, lit0, lit1);
	  MinisatClause3(S, clause, -lit, -lit0, -lit1);
	  bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) = lit;
	}
      }
    }

    nRun++;
    elit = aig2CnfNewIdIntern(ddm);
    while (abs(elit) > S.nVars()) S.newVar();
    lits.clear();
    lits.push(MinisatLit(-elit));
    assumps.clear();
    assumps.push(MinisatLit(elit));

    /* constants */
    if (doConst) {
      redClass = Ddi_BddarrayRead(redClasses, 0);
      for (j=0; j<Ddi_BddPartNum(redClass); j++) {
	redNode = Ddi_BddPartRead(redClass, j);
	//assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) == 0);
	lit = aigCnfLit(S, redNode);
	lits.push(MinisatLit(-lit));
      }
    }
    /* equivalences */
    for (i=windowStart; i<Ddi_BddarrayNum(redClasses) && i<windowEnd; i++) {
      redClass = Ddi_BddarrayRead(redClasses, i);
      for (j=1; j<Ddi_BddPartNum(redClass); j++) {
	redNode = Ddi_BddPartRead(redClass, j);
	//assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) != 0);
	lit = bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode));
	lits.push(MinisatLit(lit));
      }
    }
    S.addClause(lits);
    lits.clear();

    sat = S.okay();
    if (sat) {
      if (timeLimit > 0) {
	sat = S.solve(assumps, (time_limit-util_cpu_time())/1000.0);
      } else {
	sat = S.solve(assumps);
      }
    }
    lits.push(MinisatLit(-elit));
    S.addClause(lits);
    lits.clear();

    if (S.undefined()) {
      break;
    }
    if (sat) {
      nFalse = 0;
      /* false equivalences */
      for (i=Ddi_BddarrayNum(redClasses)-1; i>=windowStart; i--) {
	isOut1 = isOut2 = onlyOuts!=1;
	newClass = Ddi_BddMakePartConjVoid(ddm);
	redClass = Ddi_BddarrayRead(redClasses, i);
	redNode = Ddi_BddPartRead(redClass, 0);
	lit0 = aigCnfLit(S, redNode);
	sign0 = lit0<0;
	lit0 = abs(lit0)-1;
	for (j=Ddi_BddPartNum(redClass)-1; j>0; j--) {
	  redNode = Ddi_BddPartRead(redClass, j);
	  lit1 = aigCnfLit(S, redNode);
	  sign1 = lit1<0;
	  lit1 = abs(lit1)-1;
	  if ((S.model[lit0]==l_True)^sign0 != (S.model[lit1]==l_True)^sign1) {
	    redNode = Ddi_BddPartQuickExtract(redClass, j);
	    Ddi_BddPartInsertLast(newClass, redNode);
	    if (i < windowEnd) {
	      //assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) != 0);
	      lit = bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode));
	      //bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) = 0;
	      MinisatClause1(S, clause, -lit);
	      nFalse++;
	    }
	    if (bAig_AuxInt(aigMgr, Ddi_BddToBaig(redNode)) == 1) {
	      isOut2 = 1;
	    }
	    Ddi_Free(redNode);
	  } else {
	    if (bAig_AuxInt(aigMgr, Ddi_BddToBaig(redNode)) == 1) {
	      isOut1 = 1;
	    }
	  }
	}
	if (Ddi_BddPartNum(newClass)>1 && isOut2) {
	  Ddi_BddarrayInsertLast(redClasses, newClass);
	  if (!doWindow || windowEnd>visitedNodes->num) {
	    redNode = Ddi_BddPartRead(newClass, 0);
	    //assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) == 0);
	    lit0 = aigCnfLit(S, redNode);
	    for (j=1; j<Ddi_BddPartNum(newClass); j++) {
	      redNode = Ddi_BddPartRead(newClass, j);
	      //assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) == 0);
	      lit1 = aigCnfLit(S, redNode);
	      lit = aig2CnfNewIdIntern(ddm);
	      while (abs(lit) > S.nVars()) S.newVar();

	      MinisatClause3(S, clause, -lit, lit0, lit1);
	      MinisatClause3(S, clause, -lit, -lit0, -lit1);
	      bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) = lit;
	    }
	  }
	}
	Ddi_Free(newClass);
	redNode = Ddi_BddPartRead(redClass, 0);
	if (bAig_AuxInt(aigMgr, Ddi_BddToBaig(redNode)) == 1) {
	  isOut1 = 1;
	}
	if (Ddi_BddPartNum(redClass)<2 || !isOut1) {
	  if (i>=windowEnd || windowEnd>=Ddi_BddarrayNum(redClasses)) {
	    Ddi_BddarrayQuickRemove(redClasses, i);
	  } else {
	    newClass = Ddi_BddarrayRead(redClasses, --windowEnd);
	    if (i!=windowEnd) {
	      Ddi_BddarrayWrite(redClasses, i, newClass);
	      Ddi_BddarrayQuickRemove(redClasses, windowEnd);
	    }
	  }
	}
      }

      /* false constants */
      if (doConst) {
	outFound = onlyOuts!=1;
	newClass = Ddi_BddMakePartConjVoid(ddm);
	redClass = Ddi_BddarrayRead(redClasses, 0);
	for (j=Ddi_BddPartNum(redClass)-1; j>=0; j--) {
	  redNode = Ddi_BddPartRead(redClass, j);
	  lit = aigCnfLit(S, redNode);
	  sign = lit<0;
	  lit = abs(lit)-1;
	  if ((S.model[lit]==l_False) ^ sign) {
	    redNode = Ddi_BddPartQuickExtract(redClass, j);
	    //assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) == 0);
	    Ddi_BddPartInsertLast(newClass, redNode);
	    if (bAig_AuxInt(aigMgr, Ddi_BddToBaig(redNode)) == 1) {
	      outFound = 1;
	    }
	    Ddi_Free(redNode);
	    nFalse++;
	  }
	}
	if (doEquiv && outFound && Ddi_BddPartNum(newClass)>1) {
	  Ddi_BddarrayInsertLast(redClasses, newClass);
	  if (!doWindow || windowEnd>visitedNodes->num) {
	    redNode = Ddi_BddPartRead(newClass, 0);
	    //assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) == 0);
	    lit0 = aigCnfLit(S, redNode);
	    for (j=1; j<Ddi_BddPartNum(newClass); j++) {
	      redNode = Ddi_BddPartRead(newClass, j);
	      //assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) == 0);
	      lit1 = aigCnfLit(S, redNode);
	      lit = aig2CnfNewIdIntern(ddm);
	      while (abs(lit) > S.nVars()) S.newVar();

	      MinisatClause3(S, clause, -lit, lit0, lit1);
	      MinisatClause3(S, clause, -lit, -lit0, -lit1);
	      bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) = lit;
	    }
	  }
	}
	Ddi_Free(newClass);
      }
      assert(nFalse);
#if 0
      fprintf(dMgrO(ddm),"Classes (%d -> %d): ", nRun, Ddi_BddarrayNum(redClasses));
      for (i=0; i<Ddi_BddarrayNum(redClasses); i++) {
	printf("%d ", Ddi_BddPartNum(Ddi_BddarrayRead(redClasses, i)));
      }
      fprintf(dMgrO(ddm),"\n");
#endif
    }
    if (!sat) {
      /* add constant/equivalency constraints permanently */
      if (doConst) {
	redClass = Ddi_BddarrayRead(redClasses, 0);
	for (j=0; j<Ddi_BddPartNum(redClass); j++) {
	  redNode = Ddi_BddPartRead(redClass, j);
	  //assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) == 0);
	  lit = aigCnfLit(S, redNode);
	  lits.push(MinisatLit(lit));
	  S.addClause(lits);
	  lits.clear();
	}
	doConst = 0;
      }
      for (i=windowStart; i<Ddi_BddarrayNum(redClasses) && i<windowEnd; i++) {
	redClass = Ddi_BddarrayRead(redClasses, i);
	redNode = Ddi_BddPartRead(redClass, 0);
	//assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) == 0);
	lit0 = aigCnfLit(S, redNode);
	for (j=1; j<Ddi_BddPartNum(redClass); j++) {
	  redNode = Ddi_BddPartRead(redClass, j);
	  //assert(bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode)) != 0);
	  lit = bAig_AuxAig1(aigMgr, Ddi_BddToBaig(redNode));
	  lits.push(MinisatLit(-lit));
	  S.addClause(lits);
	  lits.clear();

	  lit1 = aigCnfLit(S, redNode);
	  MinisatClause2(S, clause, lit0, -lit1);
	  MinisatClause2(S, clause, -lit0, lit1);
	}
      }
      if (doWindow) {
	i = windowStart = windowEnd;
	nNodes = 0;
	while (nNodes<windowNodes && i<Ddi_BddarrayNum(redClasses)) {
	  nNodes += Ddi_BddPartNum(Ddi_BddarrayRead(redClasses, i++))-1;
	}
	windowEnd = i;
	if (nNodes<windowNodes || i==Ddi_BddarrayNum(redClasses)) {
	  windowEnd = visitedNodes->num+1;
	}
      } else {
	windowStart = visitedNodes->num+1;
      }
    }
  } while (util_cpu_time()<time_limit && (sat || windowStart<Ddi_BddarrayNum(redClasses)));
  //} while (sat && !S.undefined() && util_cpu_time()<time_limit);

  aig2CnfIdClose(ddm);
  for (i=0; i<visitedNodes->num; i++) {
    bAig_AuxAig1(aigMgr, visitedNodes->nodes[i]) = bAig_NULL;
  }

  if ((S.undefined() || util_cpu_time()>time_limit) && doConst) {
    bAigArrayFree(visitedNodes);
    Ddi_Free(redClasses);
    fprintf(dMgrO(ddm),"Red Control Rem aborted ...\n");
    if (onlyOuts == 1) {
      for (i=0; i<Ddi_BddarrayNum(fAigArray); i++) {
	Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fAigArray,i);
	if (Ddi_BddIsConstant(fAig)) {
	  continue;
	}
	fBaig = Ddi_BddToBaig(fAig);
	bAig_AuxInt(aigMgr, fBaig) = -1;
      }
    }
    return;
  }

#if 0
  for (i=0; i<Ddi_BddarrayNum(redClasses); i++) {
    redClass = Ddi_BddarrayRead(redClasses, i);
    for (j=(i>0); j<Ddi_BddPartNum(redClass); j++) {
      Solver newS;
      aig2CnfIdInit(ddm);
      for (k=0; k<Ddi_BddarrayNum(fAigArray); k++) {
	Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fAigArray, k);
	if (Ddi_BddIsConstant(fAig)) {
	  continue;
	}
	MinisatClauses(newS, fAig, NULL, NULL, 1);
      }
      if (careAig) {
	MinisatClauses(newS, careAig, NULL, NULL, 0);
      }
      if (i == 0) {
	redNode = Ddi_BddPartRead(redClass, j);
	lit0 = aigCnfLit(newS, redNode);
	MinisatClause1(newS, clause, -lit0);
      } else {
	redNode = Ddi_BddPartRead(redClass, 0);
	lit0 = aigCnfLit(newS, redNode);
	redNode = Ddi_BddPartRead(redClass, j);
	lit1 = aigCnfLit(newS, redNode);
	MinisatClause2(newS, clause, lit0, lit1);
	MinisatClause2(newS, clause, -lit0, -lit1);
      }
      sat = newS.okay();
      if (sat) {
	sat = newS.solve();
      }
      assert(!sat);
      aig2CnfIdClose(ddm);
    }
  }
#endif

#if 0
  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    assert(bAig_AuxInt(aigMgr, baig) == -1);
    assert(bAig_AuxAig0(aigMgr, baig) == bAig_NULL);
    assert(bAig_AuxAig1(aigMgr, baig) == bAig_NULL);
  }
#endif

  reprs = Ddi_BddarrayAlloc(ddm, 0);
  equals = Ddi_BddarrayAlloc(ddm, 0);
  if (!doConst) {
    one = Ddi_MgrReadOne(ddm);
    redClass = Ddi_BddarrayRead(redClasses, 0);
    nConst = Ddi_BddPartNum(redClass);
    for (j=0; j<Ddi_BddPartNum(redClass); j++) {
      redNode = Ddi_BddPartRead(redClass, j);
      Ddi_BddarrayInsertLast(reprs, one);
      Ddi_BddarrayInsertLast(equals, redNode);
    }
  } else {
    nConst = 0;
  }
  //if (doEquiv && Ddi_BddarrayNum(redClasses)>1) {
  if (doEquiv && windowStart>1) {
    bAigArraySortByLevel(ddm, visitedNodes, bAig_NULL, -1);
    for (i=0; i<visitedNodes->num; i++) {
      bAig_AuxAig1(aigMgr, visitedNodes->nodes[i]) = i;
    }
    leaders = Pdtutil_Alloc(bAigEdge_t, Ddi_BddarrayNum(redClasses));
    for (i=1; i<Ddi_BddarrayNum(redClasses) && i<windowStart; i++) {
      redClass = Ddi_BddarrayRead(redClasses, i);
      redNode = Ddi_BddPartRead(redClass, 0);
      baig = Ddi_BddToBaig(redNode);
      k = bAig_AuxAig1(aigMgr, baig);
      leaders[i] = baig;
      for (j=1; j<Ddi_BddPartNum(redClass); j++) {
	redNode = Ddi_BddPartRead(redClass, j);
	baig = Ddi_BddToBaig(redNode);
	if (bAig_AuxAig1(aigMgr, baig) < k) {
	  k = bAig_AuxAig1(aigMgr, baig);
	  leaders[i] = baig;
	}
      }
    }
    for (i=0; i<visitedNodes->num; i++) {
      bAig_AuxAig1(aigMgr, visitedNodes->nodes[i]) = bAig_NULL;
    }
    for (i=1; i<Ddi_BddarrayNum(redClasses) && i<windowStart; i++) {
      redClass = Ddi_BddarrayRead(redClasses, i);
      nEquiv += Ddi_BddPartNum(redClass)-1;
      one = Ddi_BddMakeFromBaig(ddm, leaders[i]);
      for (j=0; j<Ddi_BddPartNum(redClass); j++) {
	redNode = Ddi_BddPartRead(redClass, j);
	Ddi_BddarrayInsertLast(reprs, one);
	Ddi_BddarrayInsertLast(equals, redNode);
      }
      Ddi_Free(one);
    }
    Pdtutil_Free(leaders);
  }
  Ddi_Free(redClasses);

  if (onlyOuts == 1) {
    for (i=0; i<Ddi_BddarrayNum(fAigArray); i++) {
      Ddi_Bdd_t *fAig = Ddi_BddarrayRead(fAigArray,i);
      if (Ddi_BddIsConstant(fAig)) {
	continue;
      }
      fBaig = Ddi_BddToBaig(fAig);
      bAig_AuxInt(aigMgr, fBaig) = -1;
    }
  }

#if 1
  if (Ddi_BddarrayNum(reprs)) {
    /* GpC */ Ddi_AigarrayOptByEquiv(fAigArray, reprs, equals);
  }
#else
  /* check correctness */
  fOptArray = Ddi_BddarrayDup(fAigArray);
  if (Ddi_BddarrayNum(reprs)) {
    Ddi_AigarrayOptByEquiv(fAigArray, reprs, equals);
  }
  for (i=0; i<Ddi_BddarrayNum(fAigArray); i++) {
    Ddi_Bdd_t *fCheck, *fOpt, *fAig;
    fAig = Ddi_BddarrayRead(fAigArray, i);
    fOpt = Ddi_BddarrayRead(fOptArray, i);
    fCheck = Ddi_BddXor(fOpt, fAig);
    if (careAig) Ddi_BddAndAcc(fCheck, careAig);
    Pdtutil_Assert(!Ddi_AigSat(fCheck), "Wrong RED CONTROL REM!");
    Ddi_Free(fCheck);
  }
#endif

  Ddi_Free(reprs);
  Ddi_Free(equals);
  bAigArrayFree(visitedNodes);
  endTime = util_cpu_time();
  fprintf(dMgrO(ddm),"Red Control Rem: %d -> %d ", initSize, Ddi_BddarraySize(fAigArray));
  fprintf(dMgrO(ddm),"(%d+%d:%d/%s)\n", nConst, nEquiv, nRun,
          util_print_time(endTime-startTime));

  //assert(Ddi_MgrCheckExtRef(ddm, numRef+(lemmaArray!=NULL)));
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
AigArrayRedRemovalIncrByEqClasses (
  Ddi_Bddarray_t *fAigArray,
  Ddi_Bdd_t *careAig,
  Ddi_Bdd_t *miters,
  int maxLevel,
  int filterVars,
  int assumeF,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigArray);
  Fsm_XsimMgr_t *xMgr;
  Ddi_Bddarray_t *newFA;
  Ddi_Vararray_t *maxLevelVars=NULL;
  Ddi_Bdd_t *myCare=NULL;
  int refined;
  int chkRes=0;

  if (careAig!=NULL && filterVars) {
    Ddi_Varset_t *suppF = Ddi_BddarraySupp(fAigArray);
    Ddi_Varset_t *suppC = Ddi_BddSupp(careAig);
    Ddi_VarsetSetArray(suppF);
    Ddi_VarsetSetArray(suppC);
    Ddi_VarsetDiffAcc(suppF,suppC);
    maxLevelVars = Ddi_VararrayMakeFromVarset(suppF,1);
    Ddi_Free(suppC);
    Ddi_Free(suppF);
  }
  xMgr = Fsm_XsimInit(NULL,fAigArray,
                      NULL,NULL,maxLevelVars,10/*opt->ternarySim*/);
  Ddi_Free(maxLevelVars);

  Fsm_XsimSetGateFilter(xMgr,maxLevel);

  if (careAig!=NULL) {
    myCare = Ddi_BddDup(careAig);
    Ddi_BddSetPartConj(myCare);
  }
  else {
    myCare = Ddi_BddMakePartConjVoid(ddm);
  }
  if (assumeF) {
    int i;
    for (i=0;i<Ddi_BddarrayNum(fAigArray);i++) {
      Ddi_BddPartInsertLast(myCare,Ddi_BddarrayRead(fAigArray,i));
    }
  }

  Fsm_XsimSymbolicSimulateAndRefineEqClasses(xMgr,NULL,
					     myCare,maxLevel,&refined);

  newFA = Fsm_XsimSymbolicMergeEq(xMgr,miters,NULL);
  Fsm_XsimQuit(xMgr);

  Ddi_Free(myCare);

  if (chkRes) {
    int j;
    Ddi_Bdd_t *aux0;
    if (careAig!=NULL) {
      aux0 = Ddi_BddMakeAig(careAig);
    }
    else {
      aux0 = Ddi_BddMakeConstAig(ddm, 1);
    }
    if (1 && careAig!=NULL && miters!=NULL) {
      Ddi_Bdd_t *aux1 = Ddi_BddMakeAig(miters);
      Pdtutil_Assert(Ddi_BddIncluded(aux0,aux1),"error generating miters");
      Ddi_Free(aux1);
    }
    for (j=0; j<Ddi_BddarrayNum(fAigArray); j++) {
      Ddi_Bdd_t *f0 = Ddi_BddarrayRead(fAigArray,j);
      Ddi_Bdd_t *f1 = Ddi_BddarrayRead(newFA,j);
      Ddi_Bdd_t *dif = Ddi_BddXor(f0,f1);
      Ddi_BddAndAcc(dif,aux0);
      Pdtutil_Assert(!Ddi_AigSat(dif),"wrong eq opt");
      Ddi_Free(dif);
    }
    Ddi_Free(aux0);
  }

  Ddi_DataCopy(fAigArray,newFA);
  Ddi_Free(newFA);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
AigRedRemovalIncrByControlClasses (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *careAig,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm=Ddi_ReadMgr(fAig);
  Ddi_Bddarray_t *fArray=Ddi_BddarrayAlloc(ddm, 0);
  Ddi_Bdd_t *fOpt;

  Ddi_BddarrayInsertLast(fArray, fAig);
  AigArrayRedRemovalIncrByControlClasses(fArray, careAig, 0, timeLimit);
  fOpt = Ddi_BddarrayExtract(fArray, 0);
  Ddi_Free(fArray);
  Ddi_DataCopy(fAig, fOpt);
  Ddi_Free(fOpt);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
AigRedRemovalIncrByEqClasses (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *careAig,
  Ddi_Bdd_t *miters,
  int maxLevel,
  int filterVars,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm=Ddi_ReadMgr(fAig);
  Ddi_Bddarray_t *fArray=Ddi_BddarrayAlloc(ddm, 0);
  Ddi_Bdd_t *fOpt;

  Ddi_BddarrayInsertLast(fArray, fAig);
  AigArrayRedRemovalIncrByEqClasses(fArray, careAig, miters,
                                    maxLevel, filterVars, 0, timeLimit);
  fOpt = Ddi_BddarrayExtract(fArray, 0);
  Ddi_Free(fArray);
  Ddi_DataCopy(fAig, fOpt);
  Ddi_Free(fOpt);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiAigRedRemovalOdcByEqClasses (
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *careAig,
  int maxLevel,
  int filterVars,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm=Ddi_ReadMgr(fAig);
  Ddi_Bddarray_t *fArray;
  Ddi_Bdd_t *fOpt;
  Ddi_Bdd_t *fPart=Ddi_AigPartitionTop(fAig,0);
  Ddi_Bdd_t *miters=Ddi_BddMakePartConjVoid(ddm);

  fArray = Ddi_BddarrayMakeFromBddPart(fPart);
  AigArrayRedRemovalIncrByEqClasses(fArray, careAig, miters,
                                    maxLevel, filterVars, 1, timeLimit);
  fOpt = Ddi_BddMakePartConjFromArray(fArray);
  Ddi_BddSetAig(fOpt);
  if (Ddi_BddPartNum(miters)>0) {
    Ddi_BddSetAig(miters);
    Ddi_BddAndAcc(fOpt,miters);
    Pdtutil_Assert(Ddi_BddEqualSat(fOpt,fAig),"wrong odc eq redrem");
  }
  Ddi_Free(miters);
  Ddi_Free(fArray);
  Ddi_DataCopy(fAig, fOpt);
  Ddi_Free(miters);
  Ddi_Free(fPart);
  Ddi_Free(fOpt);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
AigComputeInitialRedClasses (
  Ddi_Mgr_t *ddm,
  Ddi_Bddarray_t *fAigarray,
  bAig_array_t *visitedNodes,
  Ddi_Bdd_t *careAig,
  unsigned long time_limit
)
{
  bAig_Manager_t *aigMgr=ddm->aig.mgr;
  bAig_array_t *careNodes=NULL;
  int i, j, k, i_sig, j_sig, k_sig, nNodes, careNum, didSplit;
  int nAigVars=Ddi_MgrReadNumAigVars(ddm), nVars=Ddi_MgrReadNumVars(ddm);
  int simulDepth, noSplitDepth, maxSimulDepth=64, maxNoSplitDepth=4;
  bAigEdge_t careBaig, baig, base_i, base_j, base_k;
  Ddi_AigSignatureArray_t *nodeSigs, *nodeSigsCompl, *varSigs, *careSigs;
  Ddi_AigSignature_t *iSig, *iSigCompl, *jSig, *jSigCompl, *kSig;
  Ddi_AigSignature_t *careSigPtr=NULL;
  Ddi_Bdd_t *redClass, *redNode, *class_i, *class_j, *class_k;
  int classesNum, doEquiv=ddm->settings.aig.satIncrByRefinement>2;
  Ddi_Bddarray_t *redClasses;

  /* prepare the nodes array for simulation */
  assert(visitedNodes->nodes[0] == bAig_One);
  bAig_AuxAig0(aigMgr, bAig_One) = 0;
  for (i=1; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_AuxAig0(aigMgr, baig) = i;
    visitedNodes->nodes[i] = bAig_NonInvertedEdge(baig);
  }

#if 1
  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    assert((bAig_AuxInt(aigMgr, baig) == -1));
    if (bAig_AuxInt(aigMgr, baig) == -1) {
      bAig_AuxInt(aigMgr, baig) = 0;
    } else {
      assert(bAig_AuxInt(aigMgr, baig) == 0);
      memmove(visitedNodes->nodes+i, visitedNodes->nodes+i+1, (visitedNodes->num-i-1)*sizeof(bAigEdge_t));
      visitedNodes->num--;
      i--;
    }
  }
  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(aigMgr, baig) = -1;
  }
#endif

  nNodes = visitedNodes->num;
  if (careAig) {
    careBaig = Ddi_BddToBaig(careAig);
    careNodes = bAigArrayAlloc();
    postOrderAigVisitIntern(aigMgr, careBaig, careNodes, -1);
    postOrderAigClearVisitedIntern(aigMgr, careNodes);
    careNum = careNodes->num;
  }

  /* first simulation step: determine initial red classes */
  //nAigVars = Ddi_MgrReadNumAigVars(ddm);
  varSigs = DdiAigSignatureArrayAlloc(nVars+nAigVars);
  DdiSetSignaturesRandom(varSigs, nVars+nAigVars);
  if (careAig!=NULL && (Ddi_BddSize(careAig) > 1)) {
    /* constrain signature in care */
    int num = DdiAigConstrainSignatures(NULL, careAig, varSigs, 5, NULL, 50);
    if (!num) {
      fprintf(dMgrO(ddm),"Signature constraining failed.\n");
    }
  }

  nodeSigs = DdiAigEvalSignature(ddm, visitedNodes, bAig_NULL, 0, varSigs);
  nodeSigsCompl = DdiAigSignatureArrayAlloc(nNodes);
  for (i=0; i<nNodes; i++) {
    nodeSigsCompl->sArray[i] = nodeSigs->sArray[i];
    DdiComplementSignature(&(nodeSigsCompl->sArray[i]));
  }
  if (careNodes) {
    careSigs = DdiAigEvalSignature(ddm, careNodes, bAig_NULL, 0, varSigs);
    careSigPtr = &careSigs->sArray[careNum-1];
    if (aigIsInv(careAig)) DdiComplementSignature(careSigPtr);
  }

  redClasses = Ddi_BddarrayAlloc(ddm, 0);
  redClass = Ddi_BddMakePartConjVoid(ddm);
  redNode = Ddi_BddMakeFromBaig(ddm, visitedNodes->nodes[0]);
  Ddi_BddPartInsertLast(redClass, redNode);
  Ddi_Free(redNode);
  Ddi_BddarrayInsertLast(redClasses, redClass);
  Ddi_Free(redClass);
  for (i=1; i<nNodes && util_cpu_time()<time_limit; i++) {
    base_i = visitedNodes->nodes[i];
    redNode = Ddi_BddMakeFromBaig(ddm, base_i);
    i_sig = bAig_AuxAig0(aigMgr, base_i);
    iSig = &nodeSigs->sArray[i_sig];
    iSigCompl = &nodeSigsCompl->sArray[i_sig];
    assert(!bAig_NodeIsInverted(base_i));

    for (j=0; j<Ddi_BddarrayNum(redClasses); j++) {
      class_j = Ddi_BddarrayRead(redClasses, j);
      base_j = Ddi_BddToBaig(Ddi_BddPartRead(class_j, 0));
      j_sig = bAig_AuxAig0(aigMgr, base_j);
      jSig = &nodeSigs->sArray[j_sig];
      if (bAig_NodeIsInverted(base_j)) {
	jSig = &nodeSigsCompl->sArray[j_sig];
      }
      if (DdiEqSignatures(iSig, jSig, careSigPtr)) {
	Ddi_BddPartInsertLast(class_j, redNode);
	break;
      }
      if (DdiEqSignatures(iSigCompl, jSig, careSigPtr)) {
	Ddi_BddNotAcc(redNode);
	Ddi_BddPartInsertLast(class_j, redNode);
	break;
      }
    }
    if (doEquiv && j==Ddi_BddarrayNum(redClasses)) {
      /* no equivalences: add new class */
      redClass = Ddi_BddMakePartConjVoid(ddm);
      Ddi_BddPartInsertLast(redClass, redNode);
      Ddi_BddarrayInsertLast(redClasses, redClass);
      Ddi_Free(redClass);
    }
    Ddi_Free(redNode);
  }

  /* further random simulation: refine classes */
  simulDepth = noSplitDepth = 0;
  while (noSplitDepth<maxNoSplitDepth && simulDepth<maxSimulDepth && util_cpu_time()<time_limit) {
    simulDepth++;
    didSplit = 0;
    /* generate new random sigs */
    DdiAigSignatureArrayFree(nodeSigs);
    DdiSetSignaturesRandom(varSigs, nVars);
    if (0 && careAig) {
      /* constrain signature in care */
      int num = DdiAigConstrainSignatures(NULL, careAig, varSigs, 5, NULL, 50);
      if (!num) {
	printf("Signature constraining failed.\n");
      }
    }

    /* simulate */
    nodeSigs = DdiAigEvalSignature(ddm, visitedNodes, bAig_NULL, 0, varSigs);
    if (careNodes) {
      DdiAigSignatureArrayFree(careSigs);
      careSigs = DdiAigEvalSignature(ddm, careNodes, bAig_NULL, 0, varSigs);
      careSigPtr = &careSigs->sArray[careNum-1];
      if (aigIsInv(careAig)) DdiComplementSignature(careSigPtr);
    }
    for (i=0; i<visitedNodes->num; i++) {
      nodeSigsCompl->sArray[i] = nodeSigs->sArray[i];
      DdiComplementSignature(&(nodeSigsCompl->sArray[i]));
    }

    /* refine classes */
    classesNum = Ddi_BddarrayNum(redClasses);
    for (i=classesNum-1; i>=0; i--) {
      class_i = Ddi_BddarrayRead(redClasses, i);
      base_i = Ddi_BddToBaig(Ddi_BddPartRead(class_i, 0));
      i_sig = bAig_AuxAig0(aigMgr, base_i);
      iSig = &nodeSigs->sArray[i_sig];
      iSigCompl = &nodeSigsCompl->sArray[i_sig];
      if (bAig_NodeIsInverted(base_i)) {
	iSig = &nodeSigsCompl->sArray[i_sig];
	iSigCompl = &nodeSigs->sArray[i_sig];
      }
      for (j=Ddi_BddPartNum(class_i)-1; j>0; j--) {
	base_j = Ddi_BddToBaig(Ddi_BddPartRead(class_i, j));
	j_sig = bAig_AuxAig0(aigMgr, base_j);
	jSig = &nodeSigs->sArray[j_sig];
	jSigCompl = &nodeSigsCompl->sArray[j_sig];
	if (bAig_NodeIsInverted(base_j)) {
	  jSig = &nodeSigsCompl->sArray[j_sig];
	  jSigCompl = &nodeSigs->sArray[j_sig];
	}

	if (!DdiEqSignatures(iSig, jSig, careSigPtr)) {
	  didSplit = 1;
	  redNode = Ddi_BddPartQuickExtract(class_i, j);
	  for (k=classesNum; k<Ddi_BddarrayNum(redClasses); k++) {
	    class_k = Ddi_BddarrayRead(redClasses, k);
	    base_k = Ddi_BddToBaig(Ddi_BddPartRead(class_k, 0));
	    k_sig = bAig_AuxAig0(aigMgr, base_k);
	    kSig = &nodeSigs->sArray[k_sig];
	    if (bAig_NodeIsInverted(base_k)) {
	      kSig = &nodeSigsCompl->sArray[k_sig];
	    }
	    if (DdiEqSignatures(jSig, kSig, careSigPtr)) {
	      Ddi_BddPartInsertLast(class_k, redNode);
	      break;
	    }
	  }
	  if (doEquiv && k==Ddi_BddarrayNum(redClasses)) {
	    /* no equivalences: add new class */
	    redClass = Ddi_BddMakePartConjVoid(ddm);
	    Ddi_BddPartInsertLast(redClass, redNode);
	    Ddi_BddarrayInsertLast(redClasses, redClass);
	    Ddi_Free(redClass);
	  }
	  Ddi_Free(redNode);
	}
      }
      classesNum = Ddi_BddarrayNum(redClasses);
    } /* end for i in classes */

    noSplitDepth += !didSplit;
  }

  DdiAigSignatureArrayFree(varSigs);
  DdiAigSignatureArrayFree(nodeSigs);
  DdiAigSignatureArrayFree(nodeSigsCompl);
  if (careNodes) {
    DdiAigSignatureArrayFree(careSigs);
    bAigArrayFree(careNodes);
  }
  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_AuxAig0(aigMgr, baig) = bAig_NULL;
    assert(bAig_AuxAig1(aigMgr, baig) == bAig_NULL);
  }
  if (util_cpu_time() > time_limit) {
    Ddi_Free(redClasses);
    return NULL;
  }

  /* remove constant node / single node classes from candidates array */
  Ddi_BddPartQuickRemove(Ddi_BddarrayRead(redClasses, 0), 0);
  for (i=Ddi_BddarrayNum(redClasses)-1; i>0; i--) {
    redClass = Ddi_BddarrayRead(redClasses, i);
    if (Ddi_BddPartNum(redClass) == 1) {
      Ddi_BddarrayQuickRemove(redClasses, i);
    }
  }

  return redClasses;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatAndFlowAbstraction (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b
)
{
  MinisatClausesWithAbstraction(a,b);
  return NULL;
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigNnfOptBySatSimplify (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  int complement
)
{
  Ddi_Bdd_t *newItp = Ddi_BddDup(itp);
  Ddi_AigNnfOptBySatSimplifyAcc (itp,b,optCare,complement);
  return newItp;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOptByMonotoneCore (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  int complement,
  float timeLimit
)
{
  Ddi_Bdd_t *newItp = Ddi_BddDup(itp);
  Ddi_AigOptByMonotoneCoreAcc (itp,b,optCare,complement,timeLimit);
  return newItp;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOptByMonotoneCoreDualAcc (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(itp);
  Ddi_Bdd_t *care;
  int i, j, max = 4, size0, vMax;
  Ddi_Vararray_t *vSupp = Ddi_BddSuppVararray(itp);
  Ddi_Bdd_t *itpDup = Ddi_BddDup(itp);
  //  Ddi_Bdd_t *itpDup = Ddi_BddMakeConstAig(ddm,0);

  AigVararraySortByFlow(vSupp,itp);

  care = Ddi_BddMakeConstAig(ddm,1);
  if (optCare!=NULL) {
    Ddi_BddAndAcc(care,optCare);
  }

  vMax = Ddi_VararrayNum(vSupp);
  for (i=0; i<max; i++) {
    Ddi_Bddarray_t *lits = NULL;
    Ddi_Bdd_t *itpSub = Ddi_BddDup(itpDup);
    Ddi_Bdd_t *cex =
      Ddi_AigSatAndWithCexAndAbort(itp,care,NULL,vSupp,-1.0,NULL);
    if (cex==NULL) break;
    size0 = Ddi_BddSize(itpDup);
    lits = Ddi_BddarrayMakeLiteralsAig(vSupp, 1);
    Ddi_AigarrayConstrainCubeAcc(lits,cex);
    Ddi_Free(cex);
    for (j=0; j<vMax; j++) {
      Ddi_Var_t *v_j = Ddi_VararrayRead(vSupp,j);
      Ddi_Bdd_t *l_j = Ddi_BddarrayRead(lits,j);
      if (Ddi_BddIsConstant(l_j)) {
	Ddi_Bdd_t *litLit = Ddi_BddMakeLiteralAig(v_j,Ddi_BddIsOne(l_j));
	Ddi_BddCofactorAcc(itpSub,v_j,Ddi_BddIsOne(l_j));
	Ddi_BddAndAcc(itpSub,litLit);
	Ddi_Free(litLit);
      }
      if (Ddi_BddSize(itpSub) < 2*size0/3) break;
    }
    vMax = j;
    Ddi_Free(lits);
    Ddi_AigOptByMonotoneCoreAcc (itpSub,b,optCare,0,timeLimit);
    Ddi_BddOrAcc(itpDup,itpSub);
    Ddi_BddDiffAcc(care,itpSub);
    //    AigRedRemovalIncrByControlClasses(itp, care, 10);

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("Partitioned NNF core opt (part) [%d]: %d\n",
        i, Ddi_BddSize(itpSub));
    }
    Ddi_Free(itpSub);
    Ddi_AigOptByMonotoneCoreAcc (itpDup,a,optCare,1,timeLimit);
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("Partitioned NNF core opt  (tot) [%d]: %d\n",
        i, Ddi_BddSize(itpDup));
    }
    if (Ddi_BddSize(itpDup)>0.95*size0) vMax--;
  }

  if (0 && (i==max)) {
    Ddi_BddOrAcc(itpDup,itp);
    Ddi_AigOptByMonotoneCoreAcc (itpDup,a,optCare,1,timeLimit);
    Ddi_AigOptByMonotoneCoreAcc (itpDup,b,optCare,0,timeLimit);
  }

  Ddi_DataCopy(itp,itpDup);

  Ddi_Free(itpDup);
  Ddi_Free(care);
  Ddi_Free(vSupp);

  return itp;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigNnfOptBySatSimplifyAcc (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  int complement
)
{
  return aigNnfOptBySatSimplifyAcc (itp,b,optCare,NULL,NULL,complement,0);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOptByMonotoneCoreAcc (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  int complement,
  float timeLimit
)
{
  return aigOptByMonotoneCoreAcc (itp,b,optCare,NULL,NULL,NULL,NULL,complement,0,0,timeLimit);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOptByMonotoneCoreWithForallAcc (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  int complement,
  float timeLimit
)
{
  return aigOptByMonotoneCoreAcc (itp,b,optCare,NULL,NULL,NULL,NULL,complement,1,0,timeLimit);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOptByMonotoneCoreByRefinementAcc (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  int complement,
  float timeLimit
)
{
  return aigOptByMonotoneCoreAcc (itp,b,optCare,NULL,NULL,NULL,NULL,complement,0,1,timeLimit);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOptByMonotoneCorePartAcc (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  int complement,
  float timeLimit
)
{
  return aigOptByMonotoneCoreAcc (itp,b,optCare,NULL,NULL,NULL,NULL,complement,0,2,timeLimit);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOptByMonotoneCoreDecompAcc (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  Ddi_Bddarray_t *partitionLits,
  void *coreBClauses,
  void *cnfMappedVars,
  int complement,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(itp);
  Ddi_Bdd_t *itpDup = Ddi_BddDup(itp);
  Ddi_Vararray_t *suppA = Ddi_BddSuppVararray(itpDup);
  int i, k, nv=Ddi_VararrayNum(suppA);
  int *s0, *s1;
  Ddi_Bdd_t *itpMin, *cMin, *itpPart=NULL;
  int chkSat = 0;
  int size0 = Ddi_BddSize(itp);
  int balanced=1;
  int ndecomp = balanced ? 2 : nv/4;
  int doPart = 1;

  if (partitionLits!=NULL) {

    itpPart = Ddi_AigDisjDecompWithVars(itp,partitionLits);
    k = Ddi_BddarrayNum(partitionLits);
  }
  else {

    itpMin = Ddi_BddMakeConstAig(ddm,0);

    if (complement) Ddi_BddNotAcc(itpDup);  
    s0 = Pdtutil_Alloc(int, nv);
    s1 = Pdtutil_Alloc(int, nv);

    for (i=0; i<nv; i++) {
      Ddi_Var_t *v_i = Ddi_VararrayRead(suppA,i);
      Ddi_Bdd_t *c0 = Ddi_BddCofactor(itpDup,v_i,0);
      Ddi_Bdd_t *c1 = Ddi_BddCofactor(itpDup,v_i,1);
      s0[i] = Ddi_BddSize(c0);
      s1[i] = Ddi_BddSize(c1);
      Ddi_Free(c0);
      Ddi_Free(c1);
      float sum = (float)(s0[i]+s1[i]);
      float dif = fabs((float)(s0[i]-s1[i]));
      if (sum/((float)size0) < 1.1) {
	Ddi_Var_t *v_i = Ddi_VararrayRead(suppA,i);
	printf("split %d with %s -> %d + %d | %f\n",
	       size0, Ddi_VarName(v_i), s0[i], s1[i], sum/size0);
      }
      if (dif/((float)size0) < 0.3 && sum/((float)size0) < 1.7) {
	Ddi_Var_t *v_i = Ddi_VararrayRead(suppA,i);
	printf("split %d with %s -> %d + %d | dif: %f\n",
	       size0, Ddi_VarName(v_i), s0[i], s1[i], dif/size0);
      }
    }

    itpPart = Ddi_BddMakePartDisjVoid(ddm);

    if (balanced) {
      Ddi_BddPartInsertLast(itpPart,itpDup);
      Ddi_Free(itpDup);
      for (k=0; k<ndecomp; k++) {
	int imin = -1;
	int c;
	float min, s0f = (float) size0;
	for (i=0; i<nv; i++) {
	  float sum = (float)(s0[i]+s1[i]);
	  float dif = fabs((float)(s0[i]-s1[i]));
	  float sMin = sum+dif;
	  if (s0[i]<=1 || s1[i]<=1) continue; // skip negligible or already used
	  if (imin == -1 || sMin<min) {
	    imin = i;
	    min = sMin;
	  }
	}
	if (imin<0) break;
	Ddi_Var_t *v_i = Ddi_VararrayRead(suppA,imin);
	Ddi_Bdd_t *lit0 = Ddi_BddMakeLiteralAig(v_i,c);
	Ddi_Bdd_t *lit1 = Ddi_BddMakeLiteralAig(v_i,!c);
	s0[imin] = s1[imin] = -1;

	for (i=0; i<Ddi_BddPartNum(itpPart); i++) {
	  Ddi_Bdd_t *part_i = Ddi_BddPartRead(itpPart,i); 
	  Ddi_Bdd_t *c1 = Ddi_BddDup(part_i);
	  Ddi_AigAndCubeAcc(c1,lit1);
	  Ddi_AigAndCubeAcc(part_i,lit0);
	  Ddi_BddSetPartDisj(part_i);
	  Ddi_BddPartInsertLast(part_i,c1);
	  Ddi_Free(c1);
	}
	Ddi_BddSetFlattened(itpPart);

	Ddi_Free(lit0);
	Ddi_Free(lit1);
      }
    }
    else {
      for (k=0; k<ndecomp; k++) {
	int imin = -1;
	int c;
	float min, s0f = (float) size0;
	for (i=0; i<nv; i++) {
	  float sMin0 = ((s0[i]<s1[i]) ? s0[i] : s1[i]) / s0f;
	  float sMin1 = (s0[i] + s1[i]) / s0f;
	  float sMin = sMin0+sMin1;
	  if (s0[i]<=1 || s1[i]<=1) continue; // skip negligible or already used
	  if (imin == -1 || sMin<min) {
	    imin = i;
	    min = sMin;
	  }
	}
	if (imin<0) break;
	c = (s0[imin]<s1[imin]) ? 0 : 1;
	Ddi_Var_t *v_i = Ddi_VararrayRead(suppA,imin);
	Ddi_Bdd_t *lit0 = Ddi_BddMakeLiteralAig(v_i,c);
	Ddi_Bdd_t *lit1 = Ddi_BddMakeLiteralAig(v_i,!c);
	cMin = Ddi_BddDup(itpDup);
	Ddi_AigAndCubeAcc(cMin,lit0);
	Ddi_BddOrAcc(itpMin,cMin);
	Ddi_Free(cMin);
	Ddi_AigAndCubeAcc(itpDup,lit1);
	s0[imin] = s1[imin] = -1;
	Ddi_Free(lit0);
	Ddi_Free(lit1);
	if (Ddi_BddSize(itpMin) > size0*2) break;
	if (Ddi_BddSize(itpDup) < size0/2) break;
      }
      Ddi_AigStructRedRemAcc (itpMin,NULL);
      Ddi_NnfClustSimplifyAcc(itpMin,0);
      Ddi_BddPartInsertLast(itpPart,itpDup);
      Ddi_BddPartInsertLast(itpPart,itpMin);
      Ddi_Free(itpDup);
    }
    Ddi_Free(itpMin);

    Pdtutil_Free(s0);
    Pdtutil_Free(s1);

  }

  printf("DECOMPOSED NNF OPT (%d cofactoring vars): %d -> ",
	 k, Ddi_BddSize(itp));    
  for (i=0; i<Ddi_BddPartNum(itpPart); i++) {
    Ddi_Bdd_t *part_i = Ddi_BddPartRead(itpPart,i); 
    printf("%d ", Ddi_BddSize(part_i));
  }
  printf("\n");

  if (doPart) {
    Ddi_BddPartSortBySizeAcc(itpPart, 0); // decreasing size
    
    for (i=Ddi_BddPartNum(itpPart)-1; i>2; i--) {
      Ddi_Bdd_t *part_i = Ddi_BddPartExtract(itpPart,i);
      Ddi_BddOrAcc(Ddi_BddPartRead(itpPart,2),part_i);
      Ddi_Free(part_i);
    }
    for (i=0; i<Ddi_BddPartNum(itpPart); i++) {
      Ddi_Bdd_t *part_i = Ddi_BddPartRead(itpPart,i);
      aigOptByMonotoneCoreAcc (part_i,b,optCare,
			       (vec<vec<Lit> > *)coreBClauses,
                               NULL,NULL,
			       (bAig_array_t *)cnfMappedVars,
			       complement,0,0,timeLimit);
    }
    Ddi_BddSetAig(itpPart);
  }
  else {
    Ddi_BddSetAig(itpPart);
    aigOptByMonotoneCoreAcc (itpPart,b,optCare,
                             (vec<vec<Lit> > *)coreBClauses,
                             NULL,NULL,
                             (bAig_array_t *)cnfMappedVars,
                             complement,0,0,timeLimit);
  }

  if (chkSat) {
    Pdtutil_Assert(!Ddi_AigSatAnd(itpPart,b,optCare),"wrong decomp nnf core");
  }

  if (complement) Ddi_BddNotAcc(itpPart);  
  Ddi_DataCopy(itp,itpPart);
  Ddi_Free(itpDup);
  return itp;
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigOptByRedRemOdc (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *odc,
  Ddi_Bdd_t *optCare,
  vec<vec<Lit> > *coreClauses,
  bAig_array_t *cnfMappedVars,
  int complement
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;

  int size0 = Ddi_BddSize(f);

  if (size0<100) return f;
  
  if (complement) Ddi_BddNotAcc(f);

  int maxObserve = 0;
  int redVal = 0;
  Ddi_Bdd_t *red, *myCare = Ddi_BddDup(odc);
  Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,1);

  Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV0 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV1 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bdd_t *fNnf = Ddi_AigNnf (f,NULL,constr,rV,aV0,aV1);

  Ddi_BddarrayWrite(fA,0,fNnf);
  Ddi_BddSetAig(constr);
  Ddi_BddAndAcc(myCare,constr);
  Ddi_Free(constr);
  if (optCare!=NULL) {
    Ddi_BddAndAcc(myCare,optCare);
  }

  if (size0>10000) {
    maxObserve = size0/2;
    if (size0>100000) {
      maxObserve /= 2;
    }
  }
  
  int useGateType = 1;
  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(fNnf,rV,aV0,aV1,
     constr,useGateType,2/*levelize*/);

  red = Ddi_AigConstRed (fA, myCare, coreClauses, cnfMappedVars, 
             maxObserve>0?2:1 /* doRedRem */,
                         maxObserve, 0, redVal, nnfCoreMgr, -1.0);

  nnfCoreMgrFree(nnfCoreMgr);

  int nowUseOdcRedRem = 1;
  int doRedRem = 0;
  if (nowUseOdcRedRem) {
    int chk = 0;
    Ddi_Bdd_t *newf = Ddi_BddarrayRead(fA,0);
    if (chk) {
      Pdtutil_Assert(Ddi_BddIncluded(fNnf,newf),
                   "error in NNF const red");
    }
    if (chk)
      Pdtutil_Assert(!Ddi_AigSatAnd(fNnf,odc,myCare),
                   "unsound redrem");
    doRedRem = 0 &&
      (Ddi_BddSize(newf)<Ddi_BddSize(f));
    Ddi_DataCopy(f,newf);
  }
  else if (red!=NULL) {
    Ddi_Bdd_t *newf = Ddi_BddarrayRead(fA,0);
    if (redVal>0) {
      Pdtutil_Assert(Ddi_BddIncluded(f,f),
                     "error in NNF const red");
    }
    Ddi_DataCopy(f,newf);
    if (redVal==0) {
      int j;
      Ddi_BddNotAcc(red);
      for (j=0; j<Ddi_BddPartNum(red); j++) {
        Ddi_Bdd_t *red_j = Ddi_BddPartRead(red,j);
        if (!Ddi_BddEqual(red_j, newf)) {
          Ddi_BddSetAig(red_j);
          Ddi_BddOrAcc(f,red_j);
          doRedRem=1;
        }
      }
    }
    Ddi_Free(red);
  }
  Ddi_Bddarray_t *rLits;
  rLits = Ddi_BddarrayMakeLiteralsAig(rV, 0);
  Ddi_BddComposeAcc(f,aV0,rLits);
  Ddi_Free(rLits);
  rLits = Ddi_BddarrayMakeLiteralsAig(rV, 1);
  Ddi_BddComposeAcc(f,aV1,rLits);
  Ddi_Free(rLits);
  Ddi_Free(aV1);
  Ddi_Free(aV0);
  Ddi_Free(rV);
  Ddi_Free(fNnf);
  
  if (doRedRem) {
    Ddi_AigStructRedRemAcc (f,NULL);
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      int size1 = Ddi_BddSize(f);
      if (size1<size0) {                
        printf("Monotone Core ITP red: %d -> %d\n", size0, size1);
      }
    }
  }

  Ddi_Free(fA);
  Ddi_Free(myCare);

  if (complement) Ddi_BddNotAcc(f);

  return f;
}



/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigOptByMonotoneCoreAcc (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  vec<vec<Lit> > *coreBClauses,
  Ddi_Bdd_t *cnfSharedAigs,
  vec<vec<Lit> > *partitionClauses,
  bAig_array_t *cnfMappedVars,
  int complement,
  int monotoneForall,
  int byRefinementOrPart,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(itp);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV0 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV1 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bdd_t *monotoneItp;

  Ddi_Vararray_t *suppA;
  Ddi_Bddarray_t *constrA, *rLits, *constrR;
  Ddi_Bdd_t *myCarePlus, *iCore, *myItp, *myB;
  int mySat;
  int size0 = Ddi_BddSize(itp);
  int j, i;
  int useMinisat22=ddm->settings.aig.itpDrup>0;
  int useMinisat22byProof = 1;
  int useNnfCoreMgr = 1;
  int tryRedRem = 1;
  int usePart = 0;
  int byRefinement = 0;

  static int ncalls=0;

  if (byRefinementOrPart>1) {
    usePart = 1;
  }
  else if (byRefinementOrPart==1) {
    byRefinement = 1;
    useNnfCoreMgr = 0;
  }


  ncalls++;

  //  aigOptByRedRemOdc (itp,b,optCare,coreBClauses,cnfMappedVars,complement);
  
  myItp = Ddi_BddDup(itp);
  if (complement) Ddi_BddNotAcc(myItp);
  monotoneItp = Ddi_AigNnf (myItp,NULL,constr,rV,aV0,aV1);
  Ddi_Free(myItp);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    printf("Monotone %sAIG size(%d): %d\n",
           complement?"(compl) ":"", size0, Ddi_BddSize(monotoneItp));
  }

  //  Ddi_BddSetAig(monotoneItp);

  Ddi_BddSetAig(constr);

  myCarePlus = Ddi_BddDup(constr);
  if (optCare && (1||coreBClauses==NULL)) {
    if (Ddi_BddIsPartDisj(optCare)) {
      int j;
      Ddi_Bdd_t *carePart = Ddi_BddDup(optCare);
      for (j=0; j<Ddi_BddPartNum(carePart); j++) {
	Ddi_Bdd_t *p_j = Ddi_BddPartRead(carePart,j);
	Ddi_BddAndAcc(p_j,myCarePlus);
      }
      Ddi_DataCopy(myCarePlus,carePart);
      Ddi_Free(carePart);
    }
    else {
      Ddi_BddAndAcc(myCarePlus,optCare);
    }
  }

  myB = Ddi_BddDup(b);
  Ddi_BddSetAig(myB);

  if (monotoneForall) {
    Ddi_Vararray_t *suppA = Ddi_BddSuppVararray(monotoneItp);
    Ddi_Bdd_t *cube = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Bdd_t *lit;
    int max2=5;
    int size = Ddi_BddSize(monotoneItp);
    Ddi_VararrayWriteMark (suppA, 1);
    for (j=0; j<Ddi_VararrayNum(aV0); j++) {
      Ddi_Var_t *aV0_j = Ddi_VararrayRead(aV0,j);
      Ddi_Var_t *aV1_j = Ddi_VararrayRead(aV1,j);
      Ddi_Var_t *rV_j = Ddi_VararrayRead(rV,j);
      if ((Ddi_VarReadMark(aV0_j)==1)&&(Ddi_VarReadMark(aV1_j)==1)) {
	if (max2<0) continue;
	Ddi_Bdd_t *c0 = Ddi_BddCofactor(monotoneItp,aV0_j,0);
	Ddi_Bdd_t *c1 = Ddi_BddCofactor(monotoneItp,aV1_j,0);
	int size0 = Ddi_BddSize(c0);
	int size1 = Ddi_BddSize(c1);
	if (0 && (size0 > size/2 && size1 > size/2)) {
	  Ddi_DataCopy(monotoneItp,c1);
          Ddi_BddCofactorAcc(monotoneItp,aV0_j,0);
	  printf("C1: %s (%d -> %d)\n",Ddi_VarName(rV_j), size, size1);
	  printf("C0: %s (%d -> %d)\n",Ddi_VarName(rV_j), size, size0);
	  size = Ddi_BddSize(monotoneItp);
	  max2--; max2--;
	}
	else if (1 && (size0 < size/2 && size1 > size/2)) {
	  Ddi_DataCopy(monotoneItp,c1);
	  printf("C1: %s (%d -> %d)\n",Ddi_VarName(rV_j), size, size1);
	  size = size1;
	  max2--;
	}
	else if (1 && (size1 < size/2 && size0 > size/2)) {
	  Ddi_DataCopy(monotoneItp,c0);
	  printf("C0: %s (%d -> %d)\n",Ddi_VarName(rV_j), size, size0);
	  size = size0;
	  max2--;
	}
	Ddi_Free(c0);
	Ddi_Free(c1);
	continue;
      }
      else if (Ddi_VarReadMark(aV0_j)==1) {
	// monotone 0 - take complement
	lit = Ddi_BddMakeLiteralAig(aV0_j,0);
      }
      else {
	// monotone 1 - take complement
	lit = Ddi_BddMakeLiteralAig(aV1_j,0);
      }
      Ddi_BddAndAcc(cube,lit);
      Ddi_Free(lit);
    }
    Ddi_VararrayWriteMark (suppA, 0);
    //    Ddi_AigConstrainCubeAcc(myB,cube);
    //    Ddi_AigConstrainCubeAcc(monotoneItp,cube);
    Ddi_Free(suppA);
    Ddi_Free(cube);
  }

  if (1) {
    rLits = Ddi_BddarrayMakeLiteralsAig(rV, 1);
    Ddi_BddComposeAcc(monotoneItp,aV1,rLits);
    Ddi_Free(rLits);
  }

  if (useNnfCoreMgr && byRefinement) {
    nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(monotoneItp,rV,aV0,aV1,constr,0,0);
    nnfCoreMgr->randRefinePeriod = 10;
    iCore = aigSatAndWithAigCoreNnfByRefinement (monotoneItp,
				    myB,optCare,nnfCoreMgr,
                                    coreBClauses,
                                    cnfMappedVars,1,&mySat,-1.0);
    nnfCoreMgrFree(nnfCoreMgr);
  }
  else if (usePart) {
    int i, n = Ddi_VararrayNum(rV);
    float cofactorRate = 0.1;
    Ddi_Bddarray_t *replV1 = Ddi_BddarrayMakeLiteralsAig(rV, 1);
    Ddi_Bddarray_t *replV0 = Ddi_BddarrayMakeLiteralsAig(aV0, 1);
    Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm,0);
    Ddi_Vararray_t *vA = Ddi_VararrayDup(aV0);
    Ddi_VararrayAppend(vA,rV);
    Ddi_Bdd_t *cex =
      Ddi_AigSatAndWithCexAndAbort(monotoneItp,myCarePlus,NULL,vA,-1.0,NULL); 
    Ddi_Bddarray_t *vAlit = Ddi_BddarrayMakeLiteralsAig(vA, 1);
    Ddi_AigarrayConstrainCubeAcc(vAlit,cex);
    for (i=0; i<n; i++) {
      if (Ddi_BddIsZero(Ddi_BddarrayRead(vAlit,i))) {
	if ((float)rand()/((float)RAND_MAX) < cofactorRate) {
	  Ddi_BddarrayWrite(replV0,i,myZero);
	}
      }
      if (Ddi_BddIsZero(Ddi_BddarrayRead(vAlit,i+n))) {
	if ((float)rand()/((float)RAND_MAX) < cofactorRate) {
	  Ddi_BddarrayWrite(replV1,i,myZero);
	}
      }
    }
    Ddi_Free(cex);
    Ddi_Free(vA);
    Ddi_Free(vAlit);
    Ddi_Free(cex);
    Ddi_Bdd_t *p0 = Ddi_BddCompose(monotoneItp,aV0,replV0);
    // Ddi_Bdd_t *p1 = Ddi_BddCompose(monotoneItp,aV1,zeroV);
    Ddi_Bdd_t *p1 = Ddi_BddCompose(monotoneItp,rV,replV1);
    Ddi_Bdd_t *partItp = Ddi_BddDup(p0);
    Ddi_BddSetPartDisj(partItp);
    Ddi_BddPartInsertLast(partItp,p1);
    Ddi_BddPartInsertLast(partItp,monotoneItp);

    iCore = aigSatAndWithAigCoreNnfPart (partItp,myB,myCarePlus,NULL,
				    coreBClauses,cnfMappedVars,1,&mySat,timeLimit/1000.0);
    Ddi_Free(myZero);
    Ddi_Free(replV0);
    Ddi_Free(replV1);
    Ddi_Free(p1);
    Ddi_Free(p0);
    Ddi_Free(partItp);
  }
  else if (useNnfCoreMgr && !useMinisat22) {
    int useGateType = Ddi_BddIsAig(monotoneItp);
    nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(monotoneItp,rV,aV0,aV1,
					     constr,useGateType,2/*levelize*/);
    iCore = aigSatAndWithAigCoreNnf (monotoneItp,myB,myCarePlus,
                  nnfCoreMgr,coreBClauses,cnfSharedAigs,
                  partitionClauses,cnfMappedVars,1,&mySat,-1.0);
    // bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
    nnfCoreMgrFree(nnfCoreMgr);
  }
  else if (byRefinement) {
    iCore = aigSatAndWithAigCoreByRefinement (monotoneItp,myB,myCarePlus,
				    coreBClauses,cnfMappedVars,1,&mySat,-1.0);
  }
  else if (useMinisat22) {
    nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(monotoneItp,rV,aV0,aV1,
					     constr,1,2/*levelize*/);
    if (useMinisat22byProof) 
      iCore = aigSat22AndWithAigCoreByProof (monotoneItp,myB,myCarePlus,nnfCoreMgr,
				    coreBClauses,cnfMappedVars,1,&mySat,timeLimit);
    else
      iCore = aigSat22AndWithAigCore (monotoneItp,myB,optCare,nnfCoreMgr,
				    coreBClauses,cnfMappedVars,1,&mySat,-1.0);
    nnfCoreMgrFree(nnfCoreMgr);
  }
  else {
    iCore = aigSatAndWithAigCore (monotoneItp,myB,myCarePlus,
                                  coreBClauses,cnfSharedAigs,
                                  partitionClauses,cnfMappedVars,
                                  1,&mySat,-1.0);
  }

  Ddi_Free(monotoneItp);
  Ddi_Free(constr);
  Ddi_Free(myB);

  if (!mySat) {
    int chk = useMinisat22 && ddm->settings.aig.itpDrup%2==0;
    rLits = Ddi_BddarrayMakeLiteralsAig(rV, 0);
    Ddi_BddComposeAcc(iCore,aV0,rLits);
    Ddi_Free(rLits);
    rLits = Ddi_BddarrayMakeLiteralsAig(rV, 1);
    Ddi_BddComposeAcc(iCore,aV1,rLits);
    Ddi_Free(rLits);

#if 0
    /* FIXED */
    if (!Ddi_AigSatAnd(iCore,b,optCare) && cnfMappedVars!=NULL) {
      Solver      *S = new Solver();
      int i, sat;
      Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(iCore,b,optCare,
						    NULL,-1.0,NULL);

      aig2CnfIdInit(ddm);
      aig2CnfIdLoad(ddm,cnfMappedVars,0);

      for (i=0; i<=cnfMappedVars->num; i++) {
	S->newVar();
      }
      for (i=0; i<coreBClauses->size(); i++) {
	vec<Lit>& c = (*coreBClauses)[i];
	S->addClause(c);
      }
      MinisatClausesWithSuppFlow(NULL,*S,NULL,iCore,
				 NULL,NULL,NULL,NULL,NULL,0,0,0,0);
      if ((sat = S->okay())) {
	sat = S->solve();
      }
      Pdtutil_Assert(!sat,"error in nnf core");
      Ddi_Free(cex);
      aig2CnfIdClose(ddm);
      delete S;
    }
#endif
    Pdtutil_Assert(!chk||!Ddi_AigSatAnd(iCore,b,optCare),"wrong nnf core");

    if (complement) {
      Ddi_BddNotAcc(iCore);
      Pdtutil_Assert(!chk||Ddi_BddIncluded(iCore,itp),"underappr nnf core");
    }
    else {
      Pdtutil_Assert(!chk||Ddi_BddIncluded(itp,iCore),"underappr nnf core");
    }
    Ddi_DataCopy(itp,iCore);
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("Monotone Core (%s side) ITP opt: %d -> %d\n",
             complement ? "A":"B",
             size0, Ddi_BddSize(itp));
    }
    if (Ddi_BddIsAig(itp))
      Ddi_NnfClustSimplifyAcc(itp,0);
  }

  Ddi_Free(rV);
  Ddi_Free(aV0);
  Ddi_Free(aV1);

  Ddi_Free(myCarePlus);
  Ddi_Free(iCore);


  return mySat ? NULL : itp;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigNnfOptBySatSimplifyAcc (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  vec<vec<Lit> > *coreBClauses,
  bAig_array_t *cnfMappedVars,
  int complement,
  int monotoneForall
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(itp);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV0 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV1 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bdd_t *monotoneItp;

  Ddi_Vararray_t *suppA;
  Ddi_Bddarray_t *constrA, *rLits, *constrR;
  Ddi_Bdd_t *myCarePlus, *iCore, *myItp, *myB;
  int mySat;
  int size0 = Ddi_BddSize(itp);
  int j, i;
  int useNnfCoreMgr = 1;
  int tryRedRem = 0;
  int usePart = 0;
  int byRefinement = 0;

  static int ncalls=0;

  ncalls++;

  myItp = Ddi_BddDup(itp);
  if (complement) Ddi_BddNotAcc(myItp);
  monotoneItp = Ddi_AigNnf (myItp,NULL,constr,rV,aV0,aV1);
  Ddi_Free(myItp);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    printf("NNF %sAIG size(%d): %d\n",
           complement?"(compl) ":"", size0, Ddi_BddSize(monotoneItp));
  }

  //  Ddi_BddSetAig(monotoneItp);

  Ddi_BddSetAig(constr);

  myCarePlus = Ddi_BddDup(constr);
  if (optCare && (1||coreBClauses==NULL)) {
    if (Ddi_BddIsPartDisj(optCare)) {
      int j;
      Ddi_Bdd_t *carePart = Ddi_BddDup(optCare);
      for (j=0; j<Ddi_BddPartNum(carePart); j++) {
	Ddi_Bdd_t *p_j = Ddi_BddPartRead(carePart,j);
	Ddi_BddAndAcc(p_j,myCarePlus);
      }
      Ddi_DataCopy(myCarePlus,carePart);
      Ddi_Free(carePart);
    }
    else {
      Ddi_BddAndAcc(myCarePlus,optCare);
    }
  }

  myB = Ddi_BddDup(b);
  Ddi_BddSetAig(myB);

  if (1) {
    rLits = Ddi_BddarrayMakeLiteralsAig(rV, 1);
    Ddi_BddComposeAcc(monotoneItp,aV1,rLits);
    Ddi_Free(rLits);
  }

  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(monotoneItp,rV,aV0,aV1,
					     constr,1,2/*levelize*/);

  iCore = aigSat22RedBySimplify (monotoneItp,myB,optCare,nnfCoreMgr,
				    coreBClauses,cnfMappedVars,1);
  nnfCoreMgrFree(nnfCoreMgr);

  Ddi_Free(monotoneItp);
  Ddi_Free(constr);
  Ddi_Free(myB);

  if (1) {
    int chk = 0;
    rLits = Ddi_BddarrayMakeLiteralsAig(rV, 0);
    Ddi_BddComposeAcc(iCore,aV0,rLits);
    Ddi_Free(rLits);
    rLits = Ddi_BddarrayMakeLiteralsAig(rV, 1);
    Ddi_BddComposeAcc(iCore,aV1,rLits);
    Ddi_Free(rLits);

    Pdtutil_Assert(!chk||!Ddi_AigSatAnd(iCore,b,optCare),"wrong nnf core");

    if (complement) {
      Ddi_BddNotAcc(iCore);
      Pdtutil_Assert(!chk||Ddi_BddIncluded(iCore,itp),"underappr nnf core");
    }
    else {
      Pdtutil_Assert(!chk||Ddi_BddIncluded(itp,iCore),"underappr nnf core");
    }
    Ddi_DataCopy(itp,iCore);
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("Monotone Core ITP opt: %d -> %d\n", size0, Ddi_BddSize(itp));
    }
    if (Ddi_BddIsAig(itp))
      Ddi_NnfClustSimplifyAcc(itp,0);
  }

  Ddi_Free(rV);
  Ddi_Free(aV0);
  Ddi_Free(aV1);

  Ddi_Free(myCarePlus);
  Ddi_Free(iCore);

  itp;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOptByMonotoneCorePartAcc0 (
  Ddi_Bdd_t *itp,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *fromAndTr,
  Ddi_Bdd_t *prevItp,
  Ddi_Varset_t *vars,
  int maxPart,
  int complement,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(itp);
  Ddi_Bdd_t *iTot = Ddi_BddMakeConstAig(ddm,0);
  Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *wCare = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Varset_t *suppItp = Ddi_BddSupp(itp);
  int nv;
  int j, size0, endPart=0;

  size0 = Ddi_BddSize(itp);

  if (prevItp!=NULL) {
    Ddi_BddOrAcc(iTot,prevItp);
    Ddi_BddDiffAcc(myCare,prevItp);
    Pdtutil_Assert(!Ddi_AigSatAnd(iTot,b,optCare),"wrong prev itp");
  }
  if (optCare != NULL) {
    Ddi_BddAndAcc(myCare,optCare);
  }

  if (vars != NULL) {
    Ddi_VarsetIntersectAcc(suppItp,vars);
  }

  nv = Ddi_VarsetNum(suppItp);

  for (j=endPart=0; !endPart; j++) {
    Ddi_Varset_t *supp;
    Ddi_Bdd_t *i0 = Ddi_BddDup(itp);
    Ddi_Bdd_t *f0 = (fromAndTr==NULL) ? Ddi_BddDup(itp):Ddi_BddDup(fromAndTr);
    Ddi_Bdd_t *itpTmp=NULL;
    int mysat;
    Ddi_Bdd_t *myWindow;
    Ddi_Bdd_t *careCare = Ddi_BddDup(myCare);
    int k, sat1=1, jj=0;

    int minv=1, currv=0, cnt=2*minv;
    Ddi_Varset_t *sm = Ddi_VarsetDup(suppItp);

    if (j>maxPart) {
      Ddi_BddAndAcc(i0,wCare);
      endPart=1;
    }

    //    myWindow = Ddi_BddMakeConstAig(ddm,1);

    if (!endPart) {
#if 1
      myWindow = Ddi_BddMakeConstAig(ddm,1);
      do {
	Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(sm,1);
	Ddi_Bdd_t *myConstr =
	  Ddi_AigSatAndWithCexAndAbort(f0,careCare,NULL,vA,-1.0,NULL);
	Ddi_Free(vA);

	if (myConstr==NULL) {
	  //Pdtutil_Assert(jj==0,"error");
	  break;
	}
	jj++;
	Ddi_Bdd_t *itpPlus1 = Ddi_BddAnd(f0,myCare);
	Ddi_BddAndAcc(itpPlus1,b);
	sat1 = Ddi_AigSatMinisatWithAbortAndFinal (itpPlus1, myConstr, -1, 0);
	Pdtutil_Assert (!sat1,"unsat needed");
	sat1 = Ddi_AigSatMinisatWithAbortAndFinal (itpPlus1, myConstr, -1, 0);
	Pdtutil_Assert (!sat1,"unsat needed");
	Ddi_Varset_t *wSupp = Ddi_BddSupp(myConstr);
	Ddi_BddAndAcc(myWindow,myConstr);
	Ddi_BddAndAcc(careCare,myConstr);
	currv += Ddi_VarsetNum(wSupp);
	Ddi_VarsetDiffAcc(sm,wSupp);
	Ddi_Free(wSupp);

	Ddi_Free(myConstr);
	Ddi_Free(itpPlus1);
	cnt--;
      } while ((currv < minv) && cnt>0);
#else
      myWindow = Ddi_AigSatWindow(f0,careCare,NULL,NULL,-1.0);
#endif

      if (myWindow!=NULL && !Ddi_BddIsOne(myWindow)) {
	Ddi_AigAndCubeAcc(i0,myWindow);

	fprintf(dMgrO(ddm),"FWD partition %d - size: %d (w: %d)\n",
		j, Ddi_BddSize(i0), currv);
      }
      else if (myWindow!=NULL && Ddi_BddIsOne(myWindow)) {
	Ddi_BddAndAcc(i0,wCare);
	endPart=1;
      }
      else {
	endPart=2;
      }
    }
    else {
      fprintf(dMgrO(ddm),"FINAL partition - size: %d\n",
	      j, Ddi_BddSize(i0));
    }

    Ddi_Free(careCare);

    if (endPart<=1) {
      Ddi_AigOptByMonotoneCoreAcc (i0,b,optCare,0,-1.0);

      Ddi_BddOrAcc(iTot,i0);
      Ddi_BddDiffAcc(myCare,i0);
      if (myWindow!=NULL) {
	Ddi_BddDiffAcc(myCare,myWindow);
	Ddi_BddDiffAcc(wCare,myWindow);
      }

      itpTmp = Ddi_BddAnd(itp,myCare);
      sat1 = Ddi_AigSatMinisatWithAbortAndFinal (itpTmp, myWindow, -1, 0);
      Ddi_Free(itpTmp);

      Pdtutil_Assert(!sat1,"UNSAT required for final core");
      Ddi_Free(myWindow);
    }

    Ddi_Free(i0);
    Ddi_Free(f0);
    Ddi_Free(sm);

  }

  Ddi_Free(suppItp);
  Ddi_Free(myCare);
  Ddi_Free(wCare);

  if (iTot!=NULL) {
    int sizep = Ddi_BddSize(iTot);
    if (sizep < size0) {
      Ddi_DataCopy(itp,iTot);
      fprintf(dMgrO(ddm),"TOTAL MONOTONE OPT size: %d -> %d\n",
	      size0, sizep);
    }
    Ddi_Free(iTot);
  }

  return itp;

}




/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatAndWithAigCore (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  return aigSatAndWithAigCore(a,b,optCare,NULL,NULL,NULL,NULL,useMonotone,psat,timeLimit);
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatAndWithAigCoreByRefinement (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  return aigSatAndWithAigCoreByRefinement(a,b,optCare,
                                          NULL,NULL,useMonotone,psat,timeLimit);
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
hintSatPreprocess(
  Ddi_Mgr_t *ddm,
  Solver *S,
  Solver *S2,
  int *cnf2solver,
  Ddi_Bdd_t *partHint
)
{
  vec<vec<Lit> > hintClauses;
  vec<vec<Lit> > hintAssumps;
  vec<Lit> hint;
  long startTime, cpuTime;
  int i, j, i0, nUnsat=0, nUsed=0;
  
  if (ddm->cnf.savedAigNodes==NULL ||
      ddm->cnf.useSavedAigsForSat>1)
    return 0;

  RestoreClausesAsAigs(ddm,hintClauses,partHint);

  
  if (hintClauses.size()==0)
    return 0;

  i0 = hintClauses.size()-5000-1;
  if (i0<0) i0=0;

  for (i=i0; i<hintClauses.size(); i++) {
    hintClauses[i].copyTo(hint);
    hint.clear();
    vec<Lit>& c = hintClauses[i];
    for (j=0; j<c.size(); j++) {
      int vSat = var(c[j]);
      int signLit = sign(c[j]);
      if (vSat>=S->nVars()) continue;
      if (S2!=NULL) {
        Pdtutil_Assert(cnf2solver!=NULL,"cnf2solver missing");
        int vSat2 = cnf2solver[vSat];
        if (vSat2>0 && vSat2<S2->nVars()) {
          // push complement of lit!!!
          hint.push((signLit?Lit(vSat2):~Lit(vSat2)));
        }
      }
      else {
        hint.push((signLit?Lit(vSat):~Lit(vSat)));
      }
    }
    if (1 || hint.size()>4) {
      hintAssumps.push();
      hint.copyTo(hintAssumps.last());
    }
  }

  if (hintAssumps.size()==0)
    return 0;
  
  startTime = util_cpu_time();
  Solver *Srun = S2==NULL? S : S2;
  int hLits=0, lLits=0;
  for (i=0; i<hintAssumps.size(); i++) {
    vec<Lit>& h = hintAssumps[i];
    if (h.size()==0) continue;
    int mySat = Srun->solve(h, -1.0);
    if (!mySat) {
      vec<Lit> newLearnt;
      nUnsat++;
      if (Srun->conflict.size()==0) break; // stop, already unsat
      newLearnt.clear();
      for (int k=0; k<Srun->conflict.size(); k++) {
        newLearnt.push(Srun->conflict[k]);
      }
      if (newLearnt.size()>0) {
        nUsed++;
        Pdtutil_Assert(Srun->proof!=NULL,"missing solver proof");
        hLits += h.size();
        lLits += newLearnt.size();
        //   Srun->addLearntClause(newLearnt);
        for (int k=0; k<newLearnt.size(); k++) {
          newLearnt[k] = ~newLearnt[k];
        }
        mySat = Srun->solve(newLearnt, -1.0);
      }
    }
  }
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),"Hint preprocessing used %d/(unsat: %d/%d) hints (avg learntLits: %f/%f)\n",
            nUsed, nUnsat, hintClauses.size(),
            nUsed?((float)lLits)/nUsed:0,
            nUsed?((float)hLits)/nUsed:0);
    fprintf(dMgrO(ddm),
      "Solver preproc: %ld/%ld/%ld(%ld) dec./prop./confl.(small)\n",
          (int)Srun->stats.decisions, (int)Srun->stats.propagations,
          (int)Srun->stats.conflicts,(int)Srun->stats.smallconflicts);
    fprintf(dMgrO(ddm),"Solver preproc: time = %s\n", util_print_time (cpuTime));
  }
  return nUnsat;
}
 
/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSatAndWithAigCore (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  vec<vec<Lit> > *coreBClauses,
  Ddi_Bdd_t *cnfSharedAigs,
  vec<vec<Lit> > *partitionClauses,
  bAig_array_t *cnfMappedVars,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *aCore=NULL, *b2=NULL;
  Solver      *S;
  vec<Lit> assumps;
  Ddi_Vararray_t *vA=NULL, *vATot;
  int sizeA, sizeB, undefined = 0;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  vec<Var> coreVars;
  vec<vec<Lit> > coreClauses;
  int nACore, nCut=0, nACl;
  long startTime, cpuTime;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, chkRes=0 || 0 && (cnfMappedVars!=NULL), chkSat=0;

  *psat = 0;

  if (coreBClauses==NULL) {
    if (Ddi_BddIsZero(b)) {
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    if (Ddi_BddIsZero(a) || Ddi_BddIsOne(b)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }

    //  Ddi_BddSetAig(a2);
    b2 = Ddi_BddDup(b);
    if (1 && optCare != NULL) {
      Ddi_BddAndAcc(b2,optCare);
    }

    if (Ddi_BddIsZero(b2)) {
      Ddi_Free(b2);
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    sizeA = Ddi_BddSize(a);
    sizeB = Ddi_BddSize(b2);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));
  }
  else {
    if (Ddi_BddIsZero(a)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }
    if (optCare != NULL) {
      b2 = Ddi_BddDup(optCare);
    }
    sizeA = Ddi_BddSize(a);
    sizeB = coreBClauses->size();
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG/CNF CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));
  }

  aig2CnfIdInit(ddm);
  //  aig2CnfIdInitDecr(ddm,3*(sizeA+sizeB)/3);

  S = new Solver();

  S->proof = new Proof();
  S->pdt_opt_one_first = true;
  //  S->minisat20_opt = true;

  if (cnfMappedVars!=NULL) {
    aig2CnfIdLoad(ddm,cnfMappedVars,0);
  }
  if (coreBClauses!=NULL) {
    Pdtutil_Assert(cnfMappedVars!=NULL,"missing cnf var mapping");
    for (i=0; i<=cnfMappedVars->num; i++) {
      S->newVar();
    }
    for (i=0; i<coreBClauses->size(); i++) {
      vec<Lit>& c = (*coreBClauses)[i];
#if 0
      int j;
      for (j=0; j<c.size(); j++) {
        int v = var(c[j]);
	int b = ddm->cnf.cnf2aig[v+1];
	int s = sign(c[j]);
	if (b/4==15953/4) {
	  printf("%s%d \n", s?"-":"", b);
	}
      }
      //      printf("\n");
#endif
      S->addClause(c);
    }
  }

  if (1||ddm->settings.aig.aigCnfLevel != 6) {
    ddm->settings.aig.aigCnfLevel = 1;
  }
  //  MinisatClausesWithSuppFlow(NULL,*S,NULL,a,b2,NULL,&nACl,NULL,&aigCnfMgr,0,0,0);
  MinisatClausesWithSuppFlow(NULL,*S,NULL,a,b2,NULL,&nACl,NULL,NULL,0,0,0,0);
  if (cnfSharedAigs!=NULL) {
    MinisatClausesWithSuppFlow(NULL,*S,NULL,cnfSharedAigs,NULL,NULL,&nACl,NULL,NULL,1,0,0,0); // relational
  }
  ddm->settings.aig.aigCnfLevel = aigCnfLevel;

  assumps.clear();

  startTime = util_cpu_time();

  hintSatPreprocess(ddm,S,NULL,NULL,NULL);
  
  if ((*psat = S->okay())) {
    if (timeLimit >= 0) {
      *psat = S->solve(assumps, timeLimit);
      undefined = S->undefined();
    }
    else {
      *psat = S->solve(assumps, -1.0);
    }
  }
  else {
    //    fprintf(dMgrO(ddm),"UNSAT\n");
  }
  cpuTime = util_cpu_time () - startTime;

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),"Solver stats: %ld/%ld vars/clauses\n",
      S->nVars(), S->nClauses());
    fprintf(dMgrO(ddm),
      "Solver stats: %ld/%ld/%ld(%ld) dec./prop./confl.(small)\n",
      (int)S->stats.decisions, (int)S->stats.propagations,
       (int)S->stats.conflicts,(int)S->stats.smallconflicts);
    fprintf(dMgrO(ddm),"Solver stats: time = %s\n", util_print_time (cpuTime)));

  if (undefined) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"Solver result UNDEFINED\n"));
    *psat = -1;
  }

  if (*psat || undefined) {
    aig2CnfIdClose(ddm);
    Ddi_Free(b2);
    S->deleteProofTemps();
    delete S;
    Ddi_Free(vA);
    if (undefined) *psat = -1;
    return NULL;
  }

  nACore = MinisatCore (*S, ddm, nACl, coreVars, coreClauses, 1);

  if (chkSat) {
    int i;
    Solver      S2;
    while (S2.nVars()<S->nVars()) S2.newVar();
    for (i=0; i<coreClauses.size(); i++) {
      int j;
      vec<Lit>& c = coreClauses[i];
#if 0
      for (j=0; j<c.size(); j++) {
        int v = var(c[j]);
	int b = ddm->cnf.cnf2aig[v+1];
	int s = sign(c[j]);
	if (b/4==15953/4) {
	  printf("%s%d \n", s?"-":"", b);
	}
      }
      //printf("\n");
#endif
      S2.addClause(c);
    }
    int sat = S2.solve(assumps, -1.0);
    Pdtutil_Assert(!sat,"error");
  }

  /* process core vars */
  aCore = MinisatCoreAig(a,b2,coreVars,NULL,cnfMappedVars,
			 &nCut,aigCnfMgr,NULL,useMonotone);

  if (aigCnfMgr!=NULL) {
    aigCnfMgrFree(aigCnfMgr);
  }
  aig2CnfIdClose(ddm);
  S->deleteProofTemps();

  delete S;

  if (0 && coreBClauses!=NULL) {
    Solver      S2;
    aig2CnfIdInit(ddm);
    if (cnfMappedVars!=NULL) {
      aig2CnfIdLoad(ddm,cnfMappedVars,0);
    }
    Pdtutil_Assert(cnfMappedVars!=NULL,"missing cnf var mapping");
    for (i=0; i<=cnfMappedVars->num; i++) {
      S2.newVar();
    }
    for (i=0; i<coreBClauses->size(); i++) {
      vec<Lit>& c = (*coreBClauses)[i];
      S2.addClause(c);
    }
    MinisatClausesWithSuppFlow(NULL,S2,NULL,aCore,b2,NULL,NULL,NULL,NULL,0,0,0,0);
    int sat = S2.solve(assumps, -1.0);
    Pdtutil_Assert(!sat,"error");
    aig2CnfIdClose(ddm);
  }


  Pdtutil_Assert(!chkRes||!Ddi_AigSatAnd(aCore,b,optCare),"error in AIG CORE");

  Ddi_Free(b2);

  return(aCore);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSatAndWithAigCoreNnf (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  nnfCoreMgr_t *nnfCoreMgr,
  vec<vec<Lit> > *coreBClauses,
  Ddi_Bdd_t *cnfSharedAigs,
  vec<vec<Lit> > *partitionClauses,
  bAig_array_t *cnfMappedVars,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  return aigSatAndWithAigCoreNnfIntern (a,b,optCare,cnfSharedAigs,
					nnfCoreMgr,coreBClauses,
                                        partitionClauses,
					cnfMappedVars,NULL,useMonotone,
					psat,timeLimit);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSatAndWithAigCoreNnfPart0 (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  nnfCoreMgr_t *nnfCoreMgr,
  vec<vec<Lit> > *coreBClauses,
  bAig_array_t *cnfMappedVars,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Bdd_t *aPart = Ddi_AigPartitionTop(a,1); // OR
  Ddi_Bdd_t *aCore = NULL;
  int chk=1, np, partDone=0;
  int sRef = Ddi_BddSize(a);

  if ((np=Ddi_BddPartNum(aPart))<=1) {
    aCore = aigSatAndWithAigCoreNnfIntern (a,b,optCare,NULL,
					  nnfCoreMgr,coreBClauses,
                                           NULL,
					  cnfMappedVars,NULL,useMonotone,
					  psat,timeLimit);
  }
  else {
    int i;
    Ddi_Bdd_t *res = NULL;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("partitioned NNF Core: size: %d #part: %d\n", 
	     Ddi_BddSize(aPart), Ddi_BddPartNum(aPart));
    }

    Ddi_BddPartSortBySizeAcc(aPart, 0); // decreasing size
    for (i=Ddi_BddPartNum(aPart)-1; i>=0; i--) {
      int sTot = Ddi_BddSize(aPart);
      Ddi_Bdd_t *myPart = Ddi_BddPartExtract(aPart,i);
      Ddi_Bdd_t *myCore;
      int sPart = Ddi_BddSize(myPart);
      int sShared = Ddi_BddSize(aPart);
      if (i>0 && ((sPart < sRef/2) || (partDone>0) || i==1 && partDone==0)) {
	*psat = 0;
	if (i>0) {
	  Ddi_BddOrAcc(Ddi_BddPartRead(aPart,i-1),myPart);
	}
      }
      else {
	Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("partitioned NNF [%d]: nodes (tot/non-shared: %d/%d\n", 
	       i, sPart,sTot-sShared);
	}
	myCore = aigSatAndWithAigCoreNnfIntern (myPart,b,optCare,
					  NULL/*aPart*/,
					  nnfCoreMgr,coreBClauses,
                                                NULL,
					  cnfMappedVars,NULL,useMonotone,
					  psat,timeLimit);
	partDone++;
	if (!(*psat)) {
	  if (res==NULL) {
	    res = myCore;
	  }
	  else {
	    Ddi_BddOrAcc(res,myCore);
	    Ddi_Free(myCore);
	  }
	}
	else {
	  Pdtutil_Assert(myCore==NULL,"sat with core");
	}
      }
      Ddi_Free(myPart);
      if (*psat) {
	break;
      }
    }
    if (!(*psat)) {
      aCore = aigSatAndWithAigCoreNnfIntern (res,b,optCare,
					  NULL/*aPart*/,
					  nnfCoreMgr,coreBClauses,
                                             NULL,
					  cnfMappedVars,NULL,useMonotone,
					  psat,timeLimit);
    }
    Ddi_Free(res);
  }

  Ddi_Free(aPart);

  if (aCore!=NULL && chk && nnfCoreMgr && !optCare) {
    Pdtutil_Assert(!Ddi_AigSatAnd(aCore,b,nnfCoreMgr->nnfConstr), "invalid part core");
  }
  if (aCore!=NULL && chk && !nnfCoreMgr && optCare) {
    Pdtutil_Assert(!Ddi_AigSatAnd(aCore,b,optCare), "invalid part core");
    if (partDone>1) {
      Ddi_Bdd_t *aCore2 = aigSatAndWithAigCoreNnfIntern (a,b,optCare,NULL,
					  nnfCoreMgr,coreBClauses,
                                          NULL,
					  cnfMappedVars,NULL,useMonotone,
					  psat,timeLimit);
      if (Ddi_BddSize(aCore)<sRef) {
	printf("core PART reduction: %d -> %d[%d] (no part: %d)\n", 
	       sRef, Ddi_BddSize(aCore), partDone, Ddi_BddSize(aCore2));
	if (Ddi_BddSize(aCore2) < Ddi_BddSize(aCore)) {
	  Ddi_DataCopy(aCore,aCore2);
	}
      }
      else {
	printf("core PART no reduction: %d -> %d[%d] (no part: %d)\n", 
	       sRef, Ddi_BddSize(aCore), partDone, Ddi_BddSize(aCore2));
	if (Ddi_BddSize(aCore2) < Ddi_BddSize(aCore)) {
	  Ddi_DataCopy(aCore,aCore2);
	}
      }
      Ddi_Free(aCore2);
    }
  }

  return aCore;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSatAndWithAigCoreNnfPart (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  nnfCoreMgr_t *nnfCoreMgr,
  vec<vec<Lit> > *coreBClauses,
  bAig_array_t *cnfMappedVars,
  int useMonotone,
  int *psat,
  float partLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Bdd_t *aPart=Ddi_BddDup(a);
  Ddi_Bdd_t *aCore = NULL;
  int chk=1, np, partDone=0;
  int sRef = Ddi_BddSize(a);
  float timeLimit = -1.0;

  Pdtutil_Assert(Ddi_BddIsPartDisj(aPart),"part required");

  if ((np=Ddi_BddPartNum(aPart))<=1) {
    aCore = aigSatAndWithAigCoreNnfIntern (a,b,optCare,NULL,
					  nnfCoreMgr,coreBClauses,
                                           NULL,
					  cnfMappedVars,NULL,useMonotone,
					  psat,timeLimit);
  }
  else {
    int i;
    Ddi_Bdd_t *res = NULL;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("partitioned NNF Core: size: %d #part: %d\n", 
	     Ddi_BddSize(aPart), Ddi_BddPartNum(aPart));
    }

    Ddi_BddPartSortBySizeAcc(aPart, 0); // decreasing size
    for (i=Ddi_BddPartNum(aPart)-1; i>=0; i--) {
      int sTot = Ddi_BddSize(aPart);
      Ddi_Bdd_t *myPart = Ddi_BddPartExtract(aPart,i);
      Ddi_Bdd_t *myCore;
      int sPart = Ddi_BddSize(myPart);
      int sShared = Ddi_BddSize(aPart);
      if (i>1) {
	*psat = 0;
	Ddi_BddOrAcc(Ddi_BddPartRead(aPart,i-1),myPart);
      }
      else {
	Ddi_Bdd_t *myCare=optCare;
	Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("partitioned NNF [%d]: nodes (tot/non-shared: %d/%d\n", 
	       i, sPart,sTot-sShared);
	}
	if (i==0) {
	  int pSize = Ddi_BddSize(myPart);
	  myCare=Ddi_BddNot(res);
	  if (optCare!=NULL) {
	    Ddi_BddAndAcc(myCare,optCare);
	  }
	  DdiAigRedRemovalNnfAcc(myPart, myCare, 
				 pSize/20, partLimit, 0);
	}
	myCore = aigSatAndWithAigCoreNnfIntern (myPart,b,myCare,
					  NULL/*aPart*/,
					  nnfCoreMgr,coreBClauses,
                                                NULL,
					  cnfMappedVars,NULL,useMonotone,
					  psat,timeLimit);
	if (i==0)
	  Ddi_Free(myCare);
	partDone++;
	if (!(*psat)) {
	  if (res==NULL) {
	    res = myCore;
	  }
	  else {
	    Ddi_BddOrAcc(res,myCore);
	    Ddi_Free(myCore);
	  }
	}
	else {
	  Pdtutil_Assert(myCore==NULL,"sat with core");
	}
      }
      Ddi_Free(myPart);
      if (*psat) {
	break;
      }
    }
    if (!(*psat)) {
      aCore = aigSatAndWithAigCoreNnfIntern (res,b,optCare,
					  NULL/*aPart*/,
					  nnfCoreMgr,coreBClauses,
                                             NULL,
					  cnfMappedVars,NULL,useMonotone,
					  psat,timeLimit);
    }
    Ddi_Free(res);
  }

  Ddi_Free(aPart);

  if (aCore!=NULL && chk && nnfCoreMgr && !optCare) {
    Pdtutil_Assert(!Ddi_AigSatAnd(aCore,b,nnfCoreMgr->nnfConstr), "invalid part core");
  }
  if (aCore!=NULL && chk && !nnfCoreMgr && optCare) {
    Pdtutil_Assert(!Ddi_AigSatAnd(aCore,b,optCare), "invalid part core");
    if (partDone>1) {
      Ddi_Bdd_t *a2 = Ddi_BddPartRead(a,2);
      Ddi_Bdd_t *aCore2 = aigSatAndWithAigCoreNnfIntern (a2,b,optCare,NULL,
					  nnfCoreMgr,coreBClauses,
                                                         NULL,
					  cnfMappedVars,NULL,useMonotone,
					  psat,timeLimit);
      //      Ddi_Free(a2);
      if (Ddi_BddSize(aCore)<sRef) {
	printf("core PART reduction: %d -> %d[%d] (no part: %d)\n", 
	       sRef, Ddi_BddSize(aCore), partDone, Ddi_BddSize(aCore2));
	if (Ddi_BddSize(aCore2) < Ddi_BddSize(aCore)) {
	  Ddi_DataCopy(aCore,aCore2);
	}
      }
      else {
	printf("core PART no reduction: %d -> %d[%d] (no part: %d)\n", 
	       sRef, Ddi_BddSize(aCore), partDone, Ddi_BddSize(aCore2));
	if (Ddi_BddSize(aCore2) < Ddi_BddSize(aCore)) {
	  Ddi_DataCopy(aCore,aCore2);
	}
      }
      Ddi_Free(aCore2);
    }
  }

  return aCore;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigRefineAigCoreNnfByJustification (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *cex,
  nnfCoreMgr_t *nnfCoreMgr
)
{
#if 1
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *fRef, *cexP = Ddi_AigPartitionTop(cex,0);
  bAigEdge_t baig, baig0;
  int i, n, nRefine = 0, cntCore = 0;
  char *refineGate;
  char *isAnd;

  for (i=0; i<Ddi_BddPartNum(cexP); i++) {
    Ddi_Bdd_t *cex_i = Ddi_BddPartRead(cexP,i);
    Ddi_Var_t *v_i = Ddi_BddTopVar(cex_i);
    baig = Ddi_BddToBaig(cex_i);
    Pdtutil_Assert(bAig_isVarNode(bmgr,baig),"missing literal");
    Pdtutil_Assert(nodeAuxChar(bmgr,baig)==0,"wrong aux char field");
    nodeAuxChar(bmgr,baig) = (char) (Ddi_BddIsComplement(cex_i) ? -1 : 1);
  }
  for (i=0; i<Ddi_VararrayNum(nnfCoreMgr->rV); i++) {
    Ddi_Var_t *r_i = Ddi_VararrayRead(nnfCoreMgr->rV,i);
    Ddi_Var_t *a0_i = Ddi_VararrayRead(nnfCoreMgr->aV0,i);
    Ddi_Var_t *a1_i = Ddi_VararrayRead(nnfCoreMgr->aV1,i);
    bAigEdge_t baig = Ddi_VarToBaig(r_i);
    char val = nodeAuxChar(bmgr,baig);
    if (val==0) {
      val = -1; /* assign 0 to unassigned var */
    }
    baig = Ddi_VarToBaig(a0_i);
    nodeAuxChar(bmgr,baig) = (char) ((val==1) ? -1 : 1);
    bAig_AuxAig0(bmgr,baig) = ((val==1) ? bAig_Zero : bAig_One);
    baig = Ddi_VarToBaig(a1_i);
    nodeAuxChar(bmgr,baig) = (char) val;
    bAig_AuxAig0(bmgr,baig) = ((val==1) ? bAig_One : bAig_Zero);
  }

  /* simulate */

  newAigEvalIntern(ddm,nnfCoreMgr->aNodes);


  n = nnfCoreMgr->aNodes->num;
  refineGate = Pdtutil_Alloc(char, n);
  isAnd = Pdtutil_Alloc(char, n);
  for (i=0; i<n; i++) {
    refineGate[i] = isAnd[i] = (char)0;
    baig = nnfCoreMgr->aNodes->nodes[i];
  }
  bAigArrayAuxIntSetId(bmgr,nnfCoreMgr->aNodes);

  isAnd[n-1] = (char)(!Ddi_BddIsComplement(f));
  for (i=n-1; i>=0; i--) {
    baig = nnfCoreMgr->aNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      if (refineGate[i] && !nnfCoreMgr->isCore[i]) {
	/* do refinement */
	nnfCoreMgr->isCore[i]=1;
	nRefine++;
      }
      continue;
    }
    baig0 = bAig_AuxAig0(bmgr,baig);
    if (!isAnd[i]) baig0 = bAig_Not(baig0);
    if (i==n-1) {
      Pdtutil_Assert(baig0==bAig_Zero,"zero output missing for refinement");
      refineGate[i] = 1;
    }
    if (refineGate[i]) {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      bAigEdge_t rv = bAig_AuxAig0(bmgr,right);
      bAigEdge_t lv = bAig_AuxAig0(bmgr,left);
      int ir = bAig_AuxInt(bmgr,right);
      int il = bAig_AuxInt(bmgr,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      if (!nnfCoreMgr->isCore[i]) {
	/* do refinement */
	nnfCoreMgr->isCore[i]=1;
	nRefine++;
      }
      if (isAnd[i]) {
	isAnd[ir] = (char)(!bAig_NodeIsInverted(right));
	isAnd[il] = (char)(!bAig_NodeIsInverted(left));
	if (!isAnd[ir]) rv = bAig_Not(rv);
	if (!isAnd[il]) lv = bAig_Not(lv);
	/* choose zero child */
#if 1
	if (rv==bAig_Zero) {
	  refineGate[ir] = 1;
	}
	else if (lv==bAig_Zero) {
	  refineGate[il] = 1;
	}
#else
	if (!bAig_isVarNode(bmgr,right) && rv==bAig_Zero) {
	  refineGate[ir] = 1;
	}
	else if (!bAig_isVarNode(bmgr,left) && lv==bAig_Zero) {
	  refineGate[il] = 1;
	}
#endif
      }
      else {
	isAnd[ir] = (char)(bAig_NodeIsInverted(right));
	isAnd[il] = (char)(bAig_NodeIsInverted(left));
	if (!isAnd[ir]) rv = bAig_Not(rv);
	if (!isAnd[il]) lv = bAig_Not(lv);
	/* choose both childdren */
	if (!bAig_isVarNode(bmgr,right)) {
	  Pdtutil_Assert(rv==bAig_Zero,"missing 0 for justify");
	}
	refineGate[ir] = 1;
	if (!bAig_isVarNode(bmgr,left)) {
	  Pdtutil_Assert(lv==bAig_Zero,"missing 0 for justify");
	}
	refineGate[il] = 1;
      }
    }
  }

  for (i=0; i<Ddi_VararrayNum(nnfCoreMgr->rV); i++) {
    Ddi_Var_t *a0_i = Ddi_VararrayRead(nnfCoreMgr->aV0,i);
    Ddi_Var_t *a1_i = Ddi_VararrayRead(nnfCoreMgr->aV1,i);
    baig = Ddi_VarToBaig(a0_i);
    nodeAuxChar(bmgr,baig) = (char) 0;
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
    baig = Ddi_VarToBaig(a1_i);
    nodeAuxChar(bmgr,baig) = (char) 0;
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
  }
  for (i=0; i<Ddi_BddPartNum(cexP); i++) {
    Ddi_Bdd_t *cex_i = Ddi_BddPartRead(cexP,i);
    Ddi_Var_t *v_i = Ddi_BddTopVar(cex_i);
    baig = Ddi_BddToBaig(cex_i);
    nodeAuxChar(bmgr,baig) = 0;
  }
  Ddi_Free(cexP);

  bAigArrayClearFreeAuxAig(bmgr,nnfCoreMgr->aNodes);
  bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);

  Pdtutil_Free(refineGate);
  Pdtutil_Free(isAnd);

  Pdtutil_Assert(nRefine>0,"mising refined gates");

  for (i=n-1; i>=0; i--) {
    if (nnfCoreMgr->isCore[i]) {
      cntCore++;
    }
  }

  /* build refined aig */
  vec<Var> coreVars;
  fRef = MinisatCoreAig(f,NULL,coreVars,NULL,NULL,NULL,NULL,nnfCoreMgr,1);

  return fRef;
#endif
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSatAndWithAigCoreNnfByRefinement (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  nnfCoreMgr_t *nnfCoreMgr,
  vec<vec<Lit> > *coreBClauses,
  bAig_array_t *cnfMappedVars,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Bdd_t *constr0, *constr1;
  Ddi_Bdd_t *aCore;
  Ddi_Bdd_t *core;
  int doRefine = 1, nIter=0;
  Ddi_Varset_t *rVars = Ddi_VarsetMakeFromArray(nnfCoreMgr->rV);
  Ddi_Varset_t *a0Vars = Ddi_VarsetMakeFromArray(nnfCoreMgr->aV0);
  Ddi_Varset_t *a1Vars = Ddi_VarsetMakeFromArray(nnfCoreMgr->aV1);
  Ddi_Bdd_t *totConstr = Ddi_BddDup(nnfCoreMgr->nnfConstr);
  Ddi_Bddarray_t *al;
  long startTime, endTime, auxTime, cexTime;
  Ddi_Varset_t *a01Vars = Ddi_VarsetUnion(a0Vars,a1Vars);
  int i, size0 = Ddi_BddSize(a);
  Ddi_IncrSatMgr_t *ddiS = NULL;
  Ddi_Bddarray_t *savedAigs = Ddi_BddarrayAlloc(ddm,0);
  float rate = 0.9;
  int maxConst = 10, nConst;

  al = Ddi_BddarrayMakeLiteralsAig(nnfCoreMgr->aV0, 0);
  constr0 = Ddi_BddMakeConstAig(ddm,1);
  constr1 = Ddi_BddMakeConstAig(ddm,1);
  for (i=nConst=0; (i<Ddi_BddarrayNum(al) && nConst<maxConst); i++) {
    if ((float)rand()/((float)RAND_MAX) > rate) {
      Ddi_BddAndAcc(constr0,Ddi_BddarrayRead(al,i));
      nConst++;
    }
  }
  Ddi_Free(al);
#if 1
  al = Ddi_BddarrayMakeLiteralsAig(nnfCoreMgr->aV1, 0);
  for (i=nConst=0; (i<Ddi_BddarrayNum(al) && nConst<maxConst); i++) {
    if ((float)rand()/((float)RAND_MAX) > rate) {
      Ddi_BddAndAcc(constr1,Ddi_BddarrayRead(al,i));
      nConst++;
    }
  }
  Ddi_Free(al);
#endif
  Ddi_BddSetAig(constr0);
  Ddi_BddSetAig(constr1);

  if (optCare != NULL) {
    Ddi_BddAndAcc(constr0,optCare);
    Ddi_BddAndAcc(constr1,optCare);
    Ddi_BddAndAcc(totConstr,optCare);
  }

  startTime = util_cpu_time();

  aCore = aigSatAndWithAigCoreNnfIntern (a,b,constr0,NULL,nnfCoreMgr,
					 coreBClauses,NULL,cnfMappedVars,
					 NULL,useMonotone,psat,timeLimit);
  Ddi_Free(aCore);
  aCore = aigSatAndWithAigCoreNnfIntern (a,b,constr1,NULL,nnfCoreMgr,
					 coreBClauses,NULL,cnfMappedVars,
					 NULL,useMonotone,psat,timeLimit);

  Ddi_Free(constr0);
  Ddi_Free(constr1);

  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  Ddi_MgrSetVerbosity(ddm,Pdtutil_VerbLevelUsrMin_c);

  DdiAig2CnfIdInit(ddm);
  ddiS = Ddi_IncrSatMgrAlloc(NULL, 1/*useMinisat22*/, 0,0);

  Ddi_AigSatMinisatLoadClausesIncrementalAsserted(ddiS,b);
  if (optCare!=NULL) {
    Ddi_AigSatMinisatLoadClausesIncrementalAsserted(ddiS,optCare);
  }

  cexTime = 0;
  do {
    auxTime = util_cpu_time();
    AigFromNnfFullAcc(aCore,nnfCoreMgr);
    Ddi_AigSatMinisatLoadClausesIncrementalAsserted(ddiS,aCore);
    Ddi_BddarrayInsertLast(savedAigs,aCore);
    Ddi_Bdd_t *cex = Ddi_AigSatMinisat22WithCexAndAbortIncremental(ddiS,
			 aCore, nnfCoreMgr->rV, 0,-1.0, NULL);
    cexTime += (util_cpu_time() - auxTime);
    doRefine = 0;
    if (cex!=NULL) {
      int i;
      Ddi_BddSetAig(cex);
      //      Ddi_AigCubeExistProjectAcc (cex,rVars); // done on Minisat22
      Ddi_Free(aCore);
      aCore = aigRefineAigCoreNnfByJustification (a,cex,nnfCoreMgr);
      Ddi_Free(cex);
      doRefine = 1;
      nIter++;
    }
  } while (doRefine);

  Ddi_MgrSetVerbosity(ddm,verbosity);
  endTime = util_cpu_time();

  Ddi_IncrSatMgrQuit(ddiS);
  DdiAig2CnfIdCloseNoCheck(ddm);

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),
      "AIG CORE %d/%d REFINED WITH %d ITERATIONS - time: %s (cexT: %s)\n",
	      Ddi_BddSize(aCore), size0,
	      nIter, util_print_time (endTime-startTime),
	      util_print_time (cexTime)));

  Ddi_Free(savedAigs);
  Ddi_Free(a01Vars);
  Ddi_Free(a0Vars);
  Ddi_Free(a1Vars);
  Ddi_Free(rVars);
  Ddi_Free(totConstr);

  return aCore;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSatAndWithAigCoreNnfByRefinement0 (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  nnfCoreMgr_t *nnfCoreMgr,
  vec<vec<Lit> > *coreBClauses,
  bAig_array_t *cnfMappedVars,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Bdd_t *constr0, *constr1;
  Ddi_Bdd_t *aCore;
  Ddi_Bdd_t *core;
  int doRefine = 1, nIter=0;
  Ddi_Varset_t *rVars = Ddi_VarsetMakeFromArray(nnfCoreMgr->rV);
  Ddi_Varset_t *a0Vars = Ddi_VarsetMakeFromArray(nnfCoreMgr->aV0);
  Ddi_Varset_t *a1Vars = Ddi_VarsetMakeFromArray(nnfCoreMgr->aV1);
  Ddi_Bdd_t *totConstr = Ddi_BddDup(nnfCoreMgr->nnfConstr);
  Ddi_Bddarray_t *al;
  long startTime, endTime, auxTime, cexTime;
  Ddi_Varset_t *a01Vars = Ddi_VarsetUnion(a0Vars,a1Vars);
  int i, size0 = Ddi_BddSize(a);

  al = Ddi_BddarrayMakeLiteralsAig(nnfCoreMgr->aV0, 0);
  constr0 = Ddi_BddMakeConstAig(ddm,1);
  for (i=0; i<Ddi_BddarrayNum(al); i++) {
    if ((float)rand()/((float)RAND_MAX) > 0.7) {
      Ddi_BddAndAcc(constr0,Ddi_BddarrayRead(al,i));
    }
  }
  Ddi_Free(al);
  al = Ddi_BddarrayMakeLiteralsAig(nnfCoreMgr->aV1, 0);
  constr1 = Ddi_BddMakeConstAig(ddm,1);
  for (i=0; i<Ddi_BddarrayNum(al); i++) {
    if ((float)rand()/((float)RAND_MAX) > 0.7) {
      Ddi_BddAndAcc(constr1,Ddi_BddarrayRead(al,i));
    }
  }
  Ddi_Free(al);
  Ddi_BddSetAig(constr0);
  Ddi_BddSetAig(constr1);

  if (optCare != NULL) {
    Ddi_BddAndAcc(constr0,optCare);
    Ddi_BddAndAcc(constr1,optCare);
    Ddi_BddAndAcc(totConstr,optCare);
  }

  startTime = util_cpu_time();

  aCore = aigSatAndWithAigCoreNnfIntern (a,b,constr0,NULL,nnfCoreMgr,
					 coreBClauses,NULL,cnfMappedVars,
					 NULL,useMonotone,psat,timeLimit);
  Ddi_Free(aCore);
  aCore = aigSatAndWithAigCoreNnfIntern (a,b,constr1,NULL,nnfCoreMgr,
					 coreBClauses,NULL,cnfMappedVars,
					 NULL,useMonotone,psat,timeLimit);

  Ddi_Free(constr0);
  Ddi_Free(constr1);

  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  Ddi_MgrSetVerbosity(ddm,Pdtutil_VerbLevelUsrMin_c);

  cexTime = 0;
  do {
    auxTime = util_cpu_time();
    Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(aCore,b,totConstr,
						  NULL,-1.0,NULL);
    cexTime += (util_cpu_time() - auxTime);

    doRefine = 0;
    if (cex!=NULL) {
      int i;
      Ddi_Bdd_t *cex0 = Ddi_BddMakeConstAig(ddm,1), *cexP;
      Ddi_BddSetAig(cex);
      //      Ddi_AigCubeExistProjectAcc (cex,rVars);
      Ddi_AigCubeExistProjectAcc (cex,a01Vars);
      cexP = Ddi_AigPartitionTop(cex,0);
      for (i=0; i<Ddi_BddPartNum(cexP); i++) {
	Ddi_Bdd_t *cex_i = Ddi_BddPartRead(cexP,i);
	if (Ddi_BddIsComplement(cex_i)) {
	  Ddi_BddAndAcc(cex0,cex_i);
	}
      }
      Ddi_Free(aCore);
      aCore = aigSatAndWithAigCoreNnfIntern (a,cex,optCare,NULL,nnfCoreMgr,
                                             coreBClauses,NULL,cnfMappedVars,
					 NULL,useMonotone,psat,timeLimit);
      Ddi_Free(cex0);
      Ddi_Free(cexP);
      Ddi_Free(cex);
      doRefine = 1;
      nIter++;
      if (nnfCoreMgr->randRefinePeriod > 0 && 
	  (nIter % (nnfCoreMgr->randRefinePeriod) ==0)) {
	int i;
	for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
	  if (nnfCoreMgr->isCore[i]==0) {
	    if ((float)rand()/((float)RAND_MAX) > 0.5) {
	      nnfCoreMgr->isCore[i]=1;
	    }
	  }
	}
      }
    }
  } while (doRefine);

  Ddi_MgrSetVerbosity(ddm,verbosity);
  endTime = util_cpu_time();

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),
      "AIG CORE %d/%d REFINED WITH %d ITERATIONS - time: %s (cexT: %s)\n",
	      Ddi_BddSize(aCore), size0,
	      nIter, util_print_time (endTime-startTime),
	      util_print_time (cexTime)));

  Ddi_Free(a01Vars);
  Ddi_Free(a0Vars);
  Ddi_Free(a1Vars);
  Ddi_Free(rVars);
  Ddi_Free(totConstr);

  return aCore;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSatAndWithAigCoreNnfIntern (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *shareAig,
  nnfCoreMgr_t *nnfCoreMgr,
  vec<vec<Lit> > *coreBClauses,
  vec<vec<Lit> > *partitionClauses,
  bAig_array_t *cnfMappedVars,
  bAig_array_t *coreGates,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *aCore=NULL, *b2=NULL, *bShare=NULL;
  Solver      *S;
  vec<Lit> assumps;
  Ddi_Vararray_t *vA=NULL, *vATot;
  int sizeA, sizeB, undefined = 0;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  vec<Var> coreVars;
  vec<vec<Lit> > coreClauses;
  int nACore, nCut=0, nACl;
  long startTime, cpuTime;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, chkRes=0 || 0 && (cnfMappedVars!=NULL), chkSat=0;
  int shareVars = 1;
  int genCoreGates = coreGates!=NULL; 
  int genRel = 0;

  static int nCalls = 0;

  nCalls++;

  *psat = 0;

  if (coreBClauses==NULL) {
    if (Ddi_BddIsZero(b)) {
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    if (Ddi_BddIsZero(a) || Ddi_BddIsOne(b)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }

    //  Ddi_BddSetAig(a2);
    b2 = Ddi_BddDup(b);
    bShare = Ddi_BddDup(b);

    if (1 && optCare != NULL) {
      if (Ddi_BddIsPartDisj(optCare)) {
	int j;
	Ddi_Bdd_t *carePart = Ddi_BddDup(optCare);

	genRel = 1;
	Pdtutil_Assert(Ddi_BddIsPartDisj(a),"disj part needed");
	Pdtutil_Assert(Ddi_BddPartNum(a)==Ddi_BddPartNum(carePart),
		       "disj part not aligned");
	for (j=0; j<Ddi_BddPartNum(carePart); j++) {
	  Ddi_Bdd_t *p_j = Ddi_BddPartRead(carePart,j);
	  Ddi_Bdd_t *a_j = Ddi_BddPartRead(a,j);
	  Ddi_BddAndAcc(p_j,a_j);
	}
	Ddi_BddSetAig(carePart);
	Ddi_BddAndAcc(b2,carePart);
	Ddi_Free(carePart);
	Ddi_BddPartInsertLast(optCare,bShare);
	Ddi_DataCopy(bShare,optCare);
      }
      else {
	Ddi_BddAndAcc(b2,optCare);
	Ddi_BddAndAcc(bShare,optCare);
      }
    }

    if (Ddi_BddIsZero(b2)) {
      Ddi_Free(b2);
      Ddi_Free(bShare);
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    sizeA = Ddi_BddSize(a);
    sizeB = Ddi_BddSize(b2);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));
  }
  else {
    if (Ddi_BddIsZero(a)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }
    if (optCare != NULL) {
      if (Ddi_BddIsPartDisj(optCare)) {
	int j;
	Ddi_Bdd_t *carePart = Ddi_BddDup(optCare);
	genRel = 1;
	Pdtutil_Assert(Ddi_BddIsPartDisj(a),"disj part needed");
	Pdtutil_Assert(Ddi_BddPartNum(a)==Ddi_BddPartNum(carePart),
		       "disj part not aligned");
	for (j=0; j<Ddi_BddPartNum(carePart); j++) {
	  Ddi_Bdd_t *p_j = Ddi_BddPartRead(carePart,j);
	  Ddi_Bdd_t *a_j = Ddi_BddPartRead(a,j);
	  Ddi_BddAndAcc(p_j,a_j);
	}
	Ddi_BddSetAig(carePart);
	b2 = Ddi_BddDup(carePart);
	Ddi_Free(carePart);
        if (bShare!=NULL)
          Ddi_BddPartInsertLast(optCare,bShare);
        bShare = Ddi_BddDup(optCare);
      }
      else {
	b2 = Ddi_BddDup(optCare);
	bShare = Ddi_BddDup(optCare);
      }
    }
    sizeA = Ddi_BddSize(a);
    sizeB = coreBClauses->size();
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG/CNF CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));
  }

  aig2CnfIdInit(ddm);
  //  aig2CnfIdInitDecr(ddm,3*(sizeA+sizeB)/3);

  S = new Solver();

  S->proof = new Proof();
  S->pdt_opt_one_first = true;
  //  S->minisat20_opt = true;

  if (cnfMappedVars!=NULL) {
    aig2CnfIdLoad(ddm,cnfMappedVars,0);
  }
  if (coreBClauses!=NULL) {
    Pdtutil_Assert(cnfMappedVars!=NULL,"missing cnf var mapping");
    for (i=0; i<=cnfMappedVars->num; i++) {
      S->newVar();
    }
    for (i=0; i<coreBClauses->size(); i++) {
      vec<Lit>& c = (*coreBClauses)[i];
      S->addClause(c);
    }
  }

  if (1||ddm->settings.aig.aigCnfLevel != 6) {
    ddm->settings.aig.aigCnfLevel = 1;
  }

  if (shareVars && nnfCoreMgr!=NULL) {
    int nv = Ddi_VararrayNum(nnfCoreMgr->rV);
    for (i=0; i<nv; i++) {
      Ddi_Var_t *r_i = Ddi_VararrayRead(nnfCoreMgr->rV,i);
      Ddi_Var_t *a0_i = Ddi_VararrayRead(nnfCoreMgr->aV0,i);
      Ddi_Var_t *a1_i = Ddi_VararrayRead(nnfCoreMgr->aV1,i);
      bAigEdge_t vR = Ddi_VarToBaig(r_i);
      bAigEdge_t vA0 = Ddi_VarToBaig(a0_i);
      bAigEdge_t vA1 = Ddi_VarToBaig(a1_i);
      int rCnf = aig2CnfId(bmgr,vR);
      int a0Cnf = aig2CnfId(bmgr,vA0);
      int a1Cnf = aig2CnfId(bmgr,vA1);
      Pdtutil_Assert(rCnf>0 && a0Cnf>0 && a1Cnf>0, "zero cnfId"); 
      aig2CnfIdWrite(bmgr,vA0,-rCnf);
      aig2CnfIdWrite(bmgr,vA1,rCnf);
    }
  }

  //MinisatClausesWithSuppFlow(NULL,*S,NULL,a,b2,NULL,&nACl,NULL,&aigCnfMgr,0,0,0);
  // cummy pointer just to enable incremental clause loading
  Ddi_IncrSatMgr_t *incrSatDummy = 
    Ddi_IncrSatMgrAlloc(NULL, 0/*useMinisat22*/, 0,0);

  if (partitionClauses!=NULL) {
    genRel = 1;
  }
  MinisatClausesWithSuppFlow(incrSatDummy,
			     *S,NULL,a,b2,NULL,&nACl,NULL,NULL,genRel,0,0,0);
  if (shareAig!=NULL && Ddi_BddIsPartConj(shareAig)) {
    MinisatClausesWithSuppFlow(NULL,*S,NULL,shareAig,NULL,NULL,&nACl,NULL,NULL,1,0,0,0); // relational
  }
  ddm->settings.aig.aigCnfLevel = aigCnfLevel;
  if (!shareVars && nnfCoreMgr!=NULL) {
    int nv = Ddi_VararrayNum(nnfCoreMgr->rV);
    for (i=0; i<nv; i++) {
      Ddi_Var_t *r_i = Ddi_VararrayRead(nnfCoreMgr->rV,i);
      Ddi_Var_t *a0_i = Ddi_VararrayRead(nnfCoreMgr->aV0,i);
      Ddi_Var_t *a1_i = Ddi_VararrayRead(nnfCoreMgr->aV1,i);
      bAigEdge_t vR = Ddi_VarToBaig(r_i);
      bAigEdge_t vA0 = Ddi_VarToBaig(a0_i);
      bAigEdge_t vA1 = Ddi_VarToBaig(a1_i);
      int rCnf = aig2CnfId(bmgr,vR);
      int a0Cnf = aig2CnfId(bmgr,vA0);
      int a1Cnf = aig2CnfId(bmgr,vA1);
      vec<Lit> lits;
      /* r -> !a0 */
      MinisatClause2(*S,lits,-rCnf,-a0Cnf);
      /* !r -> !a1 */
      MinisatClause2(*S,lits,rCnf,-a1Cnf);
    }
  }
  if (partitionClauses!=NULL) {
    int maxp = -1;
    int ii, np=partitionClauses->size();
    if (maxp>0 && np>maxp) np=maxp;
    vec<Lit> disjPartOrClause;
    disjPartOrClause.clear();
    Pdtutil_Assert(Ddi_BddIsPartDisj(a),"disj part required");
    Pdtutil_Assert(Ddi_BddPartNum(a)>=np,"wrong part num");
    for (ii=0; ii<np; ii++) {
      Ddi_Bdd_t *a_i = Ddi_BddPartRead(a,ii);
      Pdtutil_Assert (Ddi_BddIsAig(a_i),"aig needed");
      bAigEdge_t baig = a_i->data.aig->aigNode;
      int fCnf = DdiAig2CnfIdSigned(ddm->aig.mgr,baig);
      vec<Lit> lits;
      S->newVar();
      int dummyCnf = S->nVars(); 
      disjPartOrClause.push(MinisatLit(dummyCnf));
      vec<Lit>& c = (*partitionClauses)[ii];
      // dummyCnf -> fCnf & !c_0 & !c_1 & ....
      // dummyCnf -> fCnf; !dummyCnf | fCnf
      MinisatClause2(*S,lits,-dummyCnf,fCnf);
      int j;
      for (j=0; j<c.size(); j++) {
        int vSat = var(c[j]);
        int cCnf = vSat+1;
	int signSat = sign(c[j]); // 1 means complemented 
        if (signSat) cCnf = -cCnf; // c_i literal
        // dummyCnf -> !cCnf; !dummyCnf | !cCnf
        MinisatClause2(*S,lits,-dummyCnf,-cCnf);
      }
    }
    S->addClause(disjPartOrClause);
  }
  Ddi_IncrSatMgrQuit(incrSatDummy);

  assumps.clear();

  startTime = util_cpu_time();

  hintSatPreprocess(ddm,S,NULL,NULL,NULL);

  if ((*psat = S->okay())) {
    if (timeLimit >= 0) {
      *psat = S->solve(assumps, timeLimit);
      undefined = S->undefined();
    }
    else {
      *psat = S->solve(assumps, -1.0);
    }
  }
  else {
    //    fprintf(dMgrO(ddm),"UNSAT\n");
  }
  cpuTime = util_cpu_time () - startTime;

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),"Solver stats: %ld/%ld vars/clauses\n",
      S->nVars(), S->nClauses());
    fprintf(dMgrO(ddm),
      "Solver stats: %ld/%ld/%ld(%ld) dec./prop./confl.(small)\n",
      (int)S->stats.decisions, (int)S->stats.propagations,
       (int)S->stats.conflicts,(int)S->stats.smallconflicts);
    fprintf(dMgrO(ddm),"Solver stats: time = %s\n", util_print_time (cpuTime)));

  if (undefined) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"Solver result UNDEFINED\n"));
    *psat = -1;
  }

  if (*psat || undefined) {
    aig2CnfIdClose(ddm);
    Ddi_Free(b2);
    Ddi_Free(bShare);
    S->deleteProofTemps();
    delete S;
    Ddi_Free(vA);
    if (undefined) *psat = -1;
    return NULL;
  }

  nACore = MinisatCore (*S, ddm, nACl, coreVars, coreClauses, 1);

  if (chkSat) {
    int i;
    Solver      S2;
    while (S2.nVars()<S->nVars()) S2.newVar();
    for (i=0; i<coreClauses.size(); i++) {
      int j;
      vec<Lit>& c = coreClauses[i];
      S2.addClause(c);
    }
    int sat = S2.solve(assumps, -1.0);
    Pdtutil_Assert(!sat,"error");
  }

  /* process core vars */
  {
    if (genCoreGates) {
      int i;
      bAig_array_t *visitedNodes = bAigArrayAlloc();
      for (i=0; i < coreVars.size(); i++) {
	int vCnf = (coreVars[i]>>2)+1;
	bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	Pdtutil_Assert(bAig_AuxInt(bmgr,baig)<=0,"invalid aux int");
	bAig_AuxInt(bmgr,baig) = 1;
      }
      postOrderBddAigVisitIntern(a, visitedNodes, 0, -1);
      postOrderAigClearVisitedIntern(bmgr,visitedNodes);
      for (i=0; i<visitedNodes->num; i++) {
	bAigEdge_t baig = visitedNodes->nodes[i];
	if (bAig_AuxInt(bmgr,baig)>0) {
	  bAigArrayPush(coreGates,baig);
	}
      }
      for (i=0; i < coreVars.size(); i++) {
	int vCnf = (coreVars[i]>>2)+1;
	bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	Pdtutil_Assert(bAig_AuxInt(bmgr,baig)>0,"invalid aux int");
	bAig_AuxInt(bmgr,baig) = 0;
      }
      bAigArrayFree(visitedNodes);
      aCore=NULL;
      chkRes=0;
    }
    else if (shareAig!=NULL &&!Ddi_BddIsPartConj(shareAig)) {
      Ddi_Bdd_t *bWithShare = Ddi_BddDup(shareAig);
      Pdtutil_Assert(!Ddi_BddIsPartConj(shareAig),"part conj share");
      Ddi_BddSetPartDisj(bWithShare);
      Ddi_BddPartInsertLast(bWithShare,bShare);
      aCore = MinisatCoreAig(a,bWithShare,coreVars,NULL,cnfMappedVars,
			 &nCut,aigCnfMgr,NULL,useMonotone);
      Ddi_Free(bWithShare);
    }
    else {
      //      aCore = MinisatCoreAig(a,NULL,coreVars,cnfMappedVars,
      aCore = MinisatCoreAig(a,bShare,coreVars,NULL,cnfMappedVars,
			 &nCut,aigCnfMgr,nnfCoreMgr,useMonotone);
    }
  }

  if (aigCnfMgr!=NULL) {
    aigCnfMgrFree(aigCnfMgr);
  }
  aig2CnfIdClose(ddm);
  S->deleteProofTemps();

  delete S;

  if (chkRes) {
    Ddi_Bdd_t *constr = Ddi_BddDup(nnfCoreMgr->nnfConstr);
    if (optCare!=NULL) Ddi_BddAndAcc(constr,optCare);
    Pdtutil_Assert(!Ddi_AigSatAnd(aCore,b,constr),"error in AIG CORE");
    Ddi_Free(constr);
  }

  Ddi_Free(bShare);
  Ddi_Free(b2);

  return(aCore);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSatAndWithAigCoreByRefinement (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  vec<vec<Lit> > *coreBClauses,
  bAig_array_t *cnfMappedVars,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *aCore=NULL, *b2=NULL;
  Solver    *SConcr, *SAbstr;
  Ddi_Vararray_t *vA=NULL, *vATot;
  int j, sizeA, sizeB, undefined = 0;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  vec<Var> coreVars;
  vec<vec<Lit> > coreClauses;
  int nACore, nCut=0, nACl;
  long startTime, cpuTimeAbstr=0, cpuTimeConcr=0;
  int i, nRef, nSatAbstr, coreSize=0, chkRes=1, chkSat=0;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int satConcr, satAbstr, doRefine = 0;
  Ddi_Vararray_t *abVarsA;
  Ddi_Varset_t *abVars;
  Ddi_Varset_t *aVars;
  bAig_array_t *sharedVars = bAigArrayAlloc();
  int tryBsplit=coreBClauses==NULL;
  int doProp = 0;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int doCore = 1;
  
  static int nCalls=0;
  nCalls++;

  *psat = 0;

  if (coreBClauses==NULL) {

    if (Ddi_BddIsZero(b)) {
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    if (Ddi_BddIsZero(a) || Ddi_BddIsOne(b)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }

    //  Ddi_BddSetAig(a2);
    b2 = Ddi_BddDup(b);
    if (1 && optCare != NULL) {
      Ddi_BddAndAcc(b2,optCare);
    }

    if (Ddi_BddIsZero(b2)) {
      Ddi_Free(b2);
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    sizeA = Ddi_BddSize(a);
    sizeB = Ddi_BddSize(b2);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));

  }
  else {

    if (Ddi_BddIsZero(a)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }
    if (optCare != NULL) {
      b2 = Ddi_BddDup(optCare);
    }
    sizeA = Ddi_BddSize(a);
    sizeB = coreBClauses->size();
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG/CNF CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));

  }

  aig2CnfIdInit(ddm);
  //  aig2CnfIdInitDecr(ddm,3*(sizeA+sizeB)/3);

  SConcr = new Solver();
  SAbstr = new Solver();
  SConcr->pdt_opt_one_first = true;
  SAbstr->pdt_opt_one_first = true;

  if (cnfMappedVars!=NULL) {
    aig2CnfIdLoad(ddm,cnfMappedVars,0);
  }

  abVars = Ddi_BddSupp(b2);
  aVars = Ddi_BddSupp(a);

  if (coreBClauses!=NULL) {
    Pdtutil_Assert(cnfMappedVars!=NULL,"missing cnf var mapping");
    for (i=0; i<=cnfMappedVars->num; i++) {
      bAigEdge_t baig = cnfMappedVars->nodes[i];
      if (baig!=bAig_NULL && bAig_isVarNode(bmgr,baig)) {
        Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
        Ddi_VarsetAddAcc(abVars,v);
      }
      SConcr->newVar();
      SAbstr->newVar();
    }
    for (i=0; i<coreBClauses->size(); i++) {
      vec<Lit>& c = (*coreBClauses)[i];
      SAbstr->addClause(c);
    }
  }

  Ddi_VarsetIntersectAcc(abVars,aVars);
  abVarsA = Ddi_VararrayMakeFromVarset(abVars,1);
  Ddi_Free(abVars);
  Ddi_Free(aVars);

  for (i=0; i<Ddi_VararrayNum(abVarsA); i++) {
    Ddi_Var_t *v_i = Ddi_VararrayRead(abVarsA,i);
    bAigEdge_t baig = Ddi_VarToBaig(v_i);
    int bCnf = aig2CnfId(bmgr,baig);
    bAigArrayPush(sharedVars,baig);
    coreVars.push(((bCnf-1)<<2));
  }

  Ddi_Free(abVarsA);
  int assumedA = 1; int partialCex=1;
  ddm->settings.aig.aigCnfLevel = 1;
  Ddi_Bdd_t *myb = partialCex?b2:NULL;
  MinisatClausesWithSuppFlow(NULL,*SConcr,NULL,a,myb,NULL,NULL,NULL,&aigCnfMgr,!assumedA,0,1,0); // act lits enabled
  //  MinisatLoadClausesWithActLits(*SConcr,aigCnfMgr);
  if (!doCore) {
    MinisatClausesWithSuppFlow(NULL,*SAbstr,NULL,a,NULL,NULL,NULL,NULL,&aigCnfMgr,!assumedA,0,1,0); // act lits enabled
  }
  MinisatClausesWithSuppFlow(NULL,*SAbstr,NULL,b2,NULL,NULL,NULL,NULL,NULL,0,0,0,0);

  ddm->settings.aig.aigCnfLevel = aigCnfLevel;

  bAig_array_t *totNodes = aigCnfMgr->visitedNodes;
  aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;

  for (i=0; i<totNodes->num; i++) {
    if (aigCnfInfo[i].actVar<0) { // do not abstract
      int actLitCnf = aigCnfInfo[i].actVar;
      int actLitSat = actLitCnf-1;
      bAigEdge_t baig = totNodes->nodes[i];
      if (bAig_isVarNode(bmgr,baig)) continue;
      int baigCnf = aig2CnfId(bmgr,baig);
      coreVars.push(((baigCnf-1)<<2));
      coreSize++;
    }
  }
  //  bAigArrayAuxIntSetId(bmgr,aigCnfMgr->visitedNodes);

  aCore = Ddi_BddMakeConstAig(ddm,1);
  
  vec<bool> conflActLits;
  conflActLits.growTo(SConcr->nVars(),false);
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),"CORE SIZE: ");
  }

  for (doRefine=1,nRef=nSatAbstr=0; doRefine; nRef++) {

    int refined = 0;
    vec<Lit> assumpsAbstr;

    assumpsAbstr.clear();

    startTime = util_cpu_time();
    nSatAbstr++;
    if (doCore && !Ddi_BddIsOne(aCore)) {
      //      Ddi_BddSetPartConj(aCore);
      MinisatClausesWithSuppFlow(NULL,*SAbstr,NULL,aCore,
                       NULL,NULL,NULL,NULL,NULL,0,0,0,0); 
#if 0 // unused as aCore is assumed
      for (int i=0; i<Ddi_BddPartNum(aCore); i++) {
        Ddi_Bdd_t *a_i = Ddi_BddPartRead(aCore,i);
        bAigEdge_t baig = a_i->data.aig->aigNode;
        int fCnf = DdiAig2CnfIdSigned(bmgr,baig);
        assumpsAbstr.push(MinisatLit(fCnf));
      } 
#endif 
    } 

    if ((satAbstr = SAbstr->okay())) {
      satAbstr = SAbstr->solve(assumpsAbstr, timeLimit>=0 ? timeLimit : -1.0);
      undefined = SAbstr->undefined();
    }
    
    cpuTimeAbstr += util_cpu_time () - startTime;

    if (undefined) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c,
        Pdtutil_VerbLevelNone_c,
	fprintf(dMgrO(ddm),"Solver result UNDEFINED\n"));
      *psat = -1;
      doRefine = 0;
      Ddi_Free(aCore);
      aCore = Ddi_BddDup(a);
      break;
    }

    if (!satAbstr) {
      /* UNSAT on abstr MODEL: refined enough */
      *psat = 0;
      doRefine = 0;
    }
    else {

      int checkCex=1;
      Ddi_Bdd_t *cex=NULL;
      /* prepare assume */
      vec<Lit> assumps;

      if (!assumedA) {
        for (int i=0; i<Ddi_BddPartNum(a); i++) {
          Ddi_Bdd_t *a_i = Ddi_BddPartRead(a,i);
          bAigEdge_t baig = a_i->data.aig->aigNode;
          int fCnf = DdiAig2CnfIdSigned(bmgr,baig);
          assumps.push(MinisatLit(fCnf));
        }
      }

      if (checkCex) {
        cex = Ddi_BddMakeConstAig(ddm,1);
      }
      /* extract cex as assumption for other solver */
      for (i=0; i<sharedVars->num; i++) {
        bAigEdge_t baig = sharedVars->nodes[i];
	int litCnf = aig2CnfId(bmgr,baig);
	int solverCnf = litCnf-1;
        if (partialCex && (1 || rand()%10 > 0)) continue;
	if (SAbstr->model[solverCnf] != l_Undef) {
	  Pdtutil_Assert(bAig_isVarNode(bmgr,baig),
                         "var nore required");
          Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
          Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
	  if (SAbstr->model[solverCnf]==l_False) {
            litCnf = -litCnf;
	    Ddi_BddNotAcc(lit);
	  }
          assumps.push(MinisatLit(litCnf));
          if (cex!=NULL)
            Ddi_BddAndAcc(cex,lit);
	  Ddi_Free(lit);
	}
      }
      Ddi_Free(cex);
      for (i=0; i<totNodes->num; i++) {
        if (aigCnfInfo[i].actVar>0) {
          int actLitCnf = aigCnfInfo[i].actVar;
          assumps.push(MinisatLit(actLitCnf));
	}
      }

      startTime = util_cpu_time();
      if ((satConcr = SConcr->okay())) {
	satConcr = SConcr->solve(assumps, timeLimit>=0 ? timeLimit : -1.0);
	undefined = SConcr->undefined();
      }

      cpuTimeConcr += util_cpu_time () - startTime;

      if (undefined) {
	Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c,
			       Pdtutil_VerbLevelNone_c,
			       fprintf(dMgrO(ddm),"Solver result UNDEFINED\n"));
	*psat = -1;
	doRefine = 0;
	break;
      }
      if (satConcr) {
        /* concrete SAT found: stop */
        *psat = 1;
        doRefine = 0;
        Ddi_Free(aCore);
        break;
      }
      else {
        /* UNSAT: refine */
	int saveCoreSize = coreSize;
        aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;

        /* process final clause */
        for (i=0; i<SConcr->conflict.size(); i++) {
          Lit iLit = SConcr->conflict[i];
          int vSat = var(iLit);
          int signSat = sign(iLit);
          int vCnf = vSat+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	  if (!bAig_isVarNode(bmgr,baig)) {
            if (baig==bAig_NULL) {
              Pdtutil_Assert(signSat,"wrong assume for act lit");
              assert(vSat<conflActLits.size());
              conflActLits[vSat]=true;
            }
          }
        }
        for (i=0; i<totNodes->num; i++) {
          if (aigCnfInfo[i].actVar>0) {
            int actLitCnf = aigCnfInfo[i].actVar;
            int actLitSat = actLitCnf-1;
            if (conflActLits[actLitSat]) {
              bAigEdge_t baig = totNodes->nodes[i];
              int baigCnf = aig2CnfId(bmgr,baig);
              vec<Lit> lits;
              assert(actLitSat<SConcr->nVars());
              MinisatClause1(*SConcr,lits,actLitCnf); 
              if (!doCore)
                MinisatClause1(*SAbstr,lits,actLitCnf);
              coreVars.push(((baigCnf-1)<<2));
              aigCnfInfo[i].actVar=-1; // disable actLit
              coreSize++;
              refined = 1;
              conflActLits[actLitSat]=false;
            }
          }
        }
        // now build abstr AIG for a
        if (doCore) {
          Ddi_Free(aCore);
          Ddi_MgrSetVerbosity(ddm,Pdtutil_VerbLevelUsrMin_c);
          aCore = MinisatCoreAig(a,NULL,coreVars,
                                 NULL,NULL,NULL,NULL,NULL,1);
          Ddi_MgrSetVerbosity(ddm,verbosity);
          Ddi_BddSetAig(aCore);
        }
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          fprintf(dMgrO(ddm)," %d", coreSize); fflush(stdout);
        }
      }
    }

  }
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),"\n");
  }

  //  bAigArrayAuxIntClear(bmgr,aigCnfMgr->visitedNodes);

  bAigArrayFree(sharedVars);

  if (!doCore) {
    Ddi_Free(aCore);
    aCore = MinisatCoreAig(a,NULL,coreVars,
                           NULL,NULL,NULL,NULL,NULL,1);
    Ddi_BddSetAig(aCore);
  }
  
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),"#refinement steps: %d(abstr:%d), # core vars: %d\n",
            nRef, nSatAbstr, coreSize);
    fprintf(dMgrO(ddm),"Concr Solver stats: %ld/%ld vars/clauses\n",
      SConcr->nVars(), SConcr->nClauses());
    fprintf(dMgrO(ddm),
      "Concr Solver stats: %ld/%ld/%ld(%ld) dec./prop./confl.(small)\n",
      (int)SConcr->stats.decisions, (int)SConcr->stats.propagations,
       (int)SConcr->stats.conflicts,(int)SConcr->stats.smallconflicts);
    fprintf(dMgrO(ddm),"Solver stats: time = %s\n",
	    util_print_time (cpuTimeConcr));

    fprintf(dMgrO(ddm),"Abstr Solver stats: %ld/%ld vars/clauses\n",
      SAbstr->nVars(), SAbstr->nClauses());
    fprintf(dMgrO(ddm),
      "Abstr Solver stats: %ld/%ld/%ld(%ld) dec./prop./confl.(small)\n",
      (int)SAbstr->stats.decisions, (int)SAbstr->stats.propagations,
       (int)SAbstr->stats.conflicts,(int)SAbstr->stats.smallconflicts);
    fprintf(dMgrO(ddm),"Solver stats: time = %s\n",
	    util_print_time (cpuTimeAbstr));
  }


  aigCnfMgrFree(aigCnfMgr);
  
  aig2CnfIdClose(ddm);
  Pdtutil_Assert(Ddi_BddIncluded(a,aCore),"wrong aCore");

  delete SConcr;
  delete SAbstr;

  Pdtutil_Assert(!chkRes||!Ddi_AigSatAnd(aCore,b,optCare),"error in AIG CORE");

  Ddi_Free(b2);

  return(aCore);
}

#if 0
/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
aigOdcSatSweep (
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *care,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_BddArray_t *fA2=NULL;
  Solver    *S;
  vec<Lit> assumps;
  Ddi_Vararray_t *vA=NULL, *vATot;
  int j, sizeA, sizeB, undefined = 0;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  long startTime, cpuTimeAbstr=0, cpuTimeConcr=0;
  int i, nRef, nSatAbstr, coreSize=0, chkRes=1, chkSat=0;
  aigCnfMgr_t *aigCnfMgr=NULL;

  bAig_array_t *refinementFrontier = bAigArrayAlloc();


  aig2CnfIdInit(ddm);
  //  aig2CnfIdInitDecr(ddm,3*(sizeA+sizeB)/3);

  S = new Solver();
  S->pdt_opt_one_first = true;

  MinisatClausesWithSuppFlow(NULL,*S,NULL,care,NULL,NULL,NULL,NULL,NULL,0,0,0,0);
  // array !!!
  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *f_i = Ddi_Bddarrayread(fA,i);
    MinisatClausesWithSuppFlow(NULL,*S,NULL,f_i,NULL,NULL,NULL,NULL,&aigCnfMgr,1,0,0,0);
  }

  ddm->settings.aig.aigCnfLevel = aigCnfLevel;

  bAigArrayAuxIntSetId(bmgr,aigCnfMgr->visitedNodes);

  for (i=0; i<aigCnfMgr->nNodes; i++) {
    bAigEdge_t baig = aigCnfMgr->visitedNodes->nodes[i];
    int fCnf = DdiAig2CnfIdSigned(bmgr,baig);
    int j = bAig_AuxInt(bmgr,baig);
    Pdtutil_assert(j==i,"wrong aig cnf mgr id");
    /* set output */
    while (abs(fCnf) > SAbstr->nVars()) SAbstr->newVar();
    aigCnfMgr->aigCnfInfo[j].isCutFrontier = 2; // already in core
    if (nodeAuxChar(bmgr,baig)>1) {
      /* in backward flow */
      Pdtutil_Assert(!bAig_isVarNode(bmgr,baig),"gate expected");
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      if ((bAig_isVarNode(bmgr,right) && nodeAuxChar(bmgr,right)==1) ||
	  (bAig_isVarNode(bmgr,left) && nodeAuxChar(bmgr,left)==1) ||
	  (nodeAuxChar(bmgr,right)==3) || (nodeAuxChar(bmgr,left)==3)) {
	/* core var */
	nodeAuxChar(bmgr,baig)=3;
      }
    }
  }
  
  /* get first abstraction: a output */
  for (i=0; i<Ddi_BddPartNum(a); i++) {
    Ddi_Bdd_t *a_i = Ddi_BddPartRead(a,i);
    bAigEdge_t baig = Ddi_BddToBaig(a_i);
    vec<Lit> lits;

    int fCnf = DdiAig2CnfIdSigned(bmgr,baig);
    int j = bAig_AuxInt(bmgr,baig);

    /* set output */
    while (abs(fCnf) > SAbstr->nVars()) SAbstr->newVar();
    aigCnfMgr->aigCnfInfo[j].isCutFrontier = 2; // already in core
    coreSize++;
    MinisatClause1(*SAbstr,lits,fCnf);
    genAigCnfSolverClauses(aigCnfMgr,SAbstr,NULL,NULL,j);
    genAigCnfSolverFrontierVars(aigCnfMgr,j,refinementFrontier);
  }

  if (initialCoreVars!=NULL) {
    for (i=0; i<initialCoreVars->num; i++) {
      bAigEdge_t baig = initialCoreVars->nodes[i];
      int fCnf = DdiAig2CnfId(bmgr,baig);
      int j = bAig_AuxInt(bmgr,baig);
      if (aigCnfMgr->aigCnfInfo[j].isCutFrontier == 2) // already in core
	continue;
      if (bAig_isVarNode(bmgr,baig)) continue;
      /* set output */
      while (abs(fCnf) > SAbstr->nVars()) SAbstr->newVar();
      aigCnfMgr->aigCnfInfo[j].isCutFrontier = 2; // already in core
      coreSize++;
      //      MinisatClause1(*SAbstr,lits,fCnf); DO NOT SET OUTPUT
      genAigCnfSolverClauses(aigCnfMgr,SAbstr,NULL,NULL,j);
      genAigCnfSolverFrontierVars(aigCnfMgr,j,refinementFrontier);
    }
    bAigArrayFree(initialCoreVars);
  }

  for (doRefine=1,nRef=nSatAbstr=0; doRefine; nRef++) {

    int refined = 0;

    assumps.clear();

    if (runSatAbstr) {
      startTime = util_cpu_time();
      nSatAbstr++;

      if ((satAbstr = SAbstr->okay())) {
	satAbstr = SAbstr->solve(assumps, timeLimit>=0 ? timeLimit : -1.0);
	undefined = SAbstr->undefined();
      }

      cpuTimeAbstr += util_cpu_time () - startTime;
    }
    else {
      undefined = 0;
      satAbstr = 1;
    }

    if (undefined) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
			     fprintf(dMgrO(ddm),"Solver result UNDEFINED\n"));
      *psat = -1;
      doRefine = 0;
      break;
    }


    if (!satAbstr) {
      /* UNSAT on abstr MODEL: refined enough */
      *psat = 0;
      doRefine = 0;
    }
    else {

      /* prepare assume */

      bAig_array_t *cexVars = bAigArrayDup(sharedVars);
      bAigArrayAppend(cexVars,refinementFrontier);

      /* extract cex as assumption for other solver */
      for (i=0; i<cexVars->num; i++) {
        bAigEdge_t baig = cexVars->nodes[i];
	int litCnf = aig2CnfId(bmgr,baig);
	int solverCnf = litCnf-1;
	if (SAbstr->model[solverCnf] != l_Undef) {
	  if (SAbstr->model[solverCnf]==l_False) {
            litCnf = -litCnf;
	  }
          assumps.push(MinisatLit(litCnf));
	}
      }

      bAigArrayFree(cexVars);

      startTime = util_cpu_time();

      if ((satConcr = SConcr->okay())) {
	satConcr = SConcr->solve(assumps, timeLimit>=0 ? timeLimit : -1.0);
	undefined = SConcr->undefined();
      }

      cpuTimeConcr += util_cpu_time () - startTime;

      if (undefined) {
	Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c,
			       Pdtutil_VerbLevelNone_c,
			       fprintf(dMgrO(ddm),"Solver result UNDEFINED\n"));
	*psat = -1;
	doRefine = 0;
	break;
      }
      if (satConcr) {
	if (runSatAbstr) {
	  /* concrete SAT found: stop */
	  *psat = 1;
	  doRefine = 0;
	  break;
	}
	else {
	  runSatAbstr=1;
	  continue;
	}
      }
      else {
        /* UNSAT: refine */
	int saveCoreSize = coreSize;
        aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;

        bAig_array_t *oldFrontier = refinementFrontier;
        refinementFrontier = bAigArrayAlloc();

#if 1
        /* process final clause */
        for (i=0; i<SConcr->conflict.size(); i++) {
          Ddi_Bdd_t *lit;
          Lit iLit = SConcr->conflict[i];
          int vSat = var(iLit);
          int signSat = sign(iLit);
          int vCnf = vSat+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          Pdtutil_Assert(nodeAuxChar(bmgr,baig)==0,"wrong aux char field");
          nodeAuxChar(bmgr,baig) = 1; // mark as unsat final
	  if (!bAig_isVarNode(bmgr,baig)) {
	    refined = 1;
	    if (!doProp) {
	      nodeAuxChar(bmgr,baig) = 3;
	    }
	  }
        }

        /* backward structural flow propagation */
	if (doProp) {
        for (i=aigCnfMgr->nNodes-1; i>=0; i--) {
          bAigEdge_t baig = aigCnfMgr->visitedNodes->nodes[i];
          if (nodeAuxChar(bmgr,baig)>=1) {
            /* in core */
            if (!bAig_isVarNode(bmgr,baig)) {
              bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
              bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
              if (!bAig_isVarNode(bmgr,right) && nodeAuxChar(bmgr,right)!=1) {
                /* backward flow */
                nodeAuxChar(bmgr,right)=2;
              }
              if (!bAig_isVarNode(bmgr,left) && nodeAuxChar(bmgr,left)!=1) {
                /* backward flow */
                nodeAuxChar(bmgr,left)=2;
              }
              nodeAuxChar(bmgr,baig)=2;
            }
          }
        }
	//#if 0
        /* forward structural flow propagation */
        for (i=0; i<aigCnfMgr->nNodes; i++) {
          bAigEdge_t baig = aigCnfMgr->visitedNodes->nodes[i];
          if (nodeAuxChar(bmgr,baig)>1) {
            /* in backward flow */
            Pdtutil_Assert(!bAig_isVarNode(bmgr,baig),"gate expected");
            bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
            bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
            if ((bAig_isVarNode(bmgr,right) && nodeAuxChar(bmgr,right)==1) ||
                (bAig_isVarNode(bmgr,left) && nodeAuxChar(bmgr,left)==1) ||
                (nodeAuxChar(bmgr,right)==3) || (nodeAuxChar(bmgr,left)==3)) {
              /* core var */
              nodeAuxChar(bmgr,baig)=3;
            }
          }
        }
	}

	//update refinement frontier
        /* forward structural flow propagation */
        for (i=0; i<aigCnfMgr->nNodes; i++) {
          bAigEdge_t baig = aigCnfMgr->visitedNodes->nodes[i];
          if (nodeAuxChar(bmgr,baig)==3) {
            if (aigCnfInfo[i].isCutFrontier != 2) {
              aigCnfInfo[i].isCutFrontier = 2;
              genAigCnfSolverClauses(aigCnfMgr,SAbstr,NULL,NULL,i);
              genAigCnfSolverFrontierVars(aigCnfMgr,i,refinementFrontier);
              coreSize++;
            }
          }
          nodeAuxChar(bmgr,baig)=0;
        }
#else
        /* process final clause */
        for (i=0; i<SConcr->conflict.size(); i++) {
          Ddi_Bdd_t *lit;
          Lit iLit = SConcr->conflict[i];
          int vSat = var(iLit);
          int signSat = sign(iLit);
          int vCnf = vSat+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          int id = bAig_AuxInt(bmgr,baig);
          Pdtutil_Assert(id>=0 && id<aigCnfMgr->visitedNodes->num,
                       "wrong node id");
          switch (aigCnfInfo[id].isCutFrontier) {
          case 0:
            /* shared var */
            Pdtutil_Assert(bAig_isVarNode(bmgr,baig),"var required");
            break;
          case 1:
            /* cut frontier: refine by adding gate clauses */
            Pdtutil_Assert(!bAig_isVarNode(bmgr,baig),"gate required");
            aigCnfInfo[id].isCutFrontier = 2;
            genAigCnfSolverClauses(aigCnfMgr,SAbstr,NULL,NULL,id);
            genAigCnfSolverFrontierVars(aigCnfMgr,id,refinementFrontier);
            coreSize++;
	    refined = 1;
            break;
          case 2:
            /* core gate: already refined */
	    //  Pdtutil_Assert(0,"core gate not allowed in cut frontier");
            break;
          default:
            Pdtutil_Assert(0,"wrong cut frontier code");
          }
        }
#endif

        for (i=0; i<oldFrontier->num; i++) {
          bAigEdge_t baig = oldFrontier->nodes[i];
          int id = bAig_AuxInt(bmgr,baig);
          if (aigCnfInfo[id].isCutFrontier == 1) {
            bAigArrayPush(refinementFrontier,baig);
          }
        }

        bAigArrayFree(oldFrontier);

	runSatAbstr=!refined;

      }
    }

  }


  bAigArrayAuxIntClear(bmgr,aigCnfMgr->visitedNodes);

  bAigArrayFree(sharedVars);
  bAigArrayFree(refinementFrontier);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),"#refinement steps: %d(abstr:%d), # core vars: %d\n",
            nRef, nSatAbstr, coreSize);
    fprintf(dMgrO(ddm),"Concr Solver stats: %ld/%ld vars/clauses\n",
      SConcr->nVars(), SConcr->nClauses());
    fprintf(dMgrO(ddm),
      "Concr Solver stats: %ld/%ld/%ld(%ld) dec./prop./confl.(small)\n",
      (int)SConcr->stats.decisions, (int)SConcr->stats.propagations,
       (int)SConcr->stats.conflicts,(int)SConcr->stats.smallconflicts);
    fprintf(dMgrO(ddm),"Solver stats: time = %s\n",
	    util_print_time (cpuTimeConcr));

    fprintf(dMgrO(ddm),"Abstr Solver stats: %ld/%ld vars/clauses\n",
      SAbstr->nVars(), SAbstr->nClauses());
    fprintf(dMgrO(ddm),
      "Abstr Solver stats: %ld/%ld/%ld(%ld) dec./prop./confl.(small)\n",
      (int)SAbstr->stats.decisions, (int)SAbstr->stats.propagations,
       (int)SAbstr->stats.conflicts,(int)SAbstr->stats.smallconflicts);
    fprintf(dMgrO(ddm),"Solver stats: time = %s\n",
	    util_print_time (cpuTimeAbstr));
  }

  coreVars.clear();

  for (i=nACore=0; i<aigCnfMgr->nNodes; i++) {
    if (aigCnfMgr->aigCnfInfo[i].isCutFrontier == 2) {
      /* in core */
      bAigEdge_t baig = aigCnfMgr->visitedNodes->nodes[i];
      int vCnf = aig2CnfId(bmgr,baig);
      coreVars.push(((vCnf-1)<<2));
      nACore++;
    }
  }

  aigCnfMgrFree(aigCnfMgr);

  /* process core vars */
  aCore = MinisatCoreAig(a,b2,coreVars,NULL,cnfMappedVars,
			 &nCut,NULL,NULL,useMonotone);

  aig2CnfIdClose(ddm);

  delete SConcr;
  delete SAbstr;


  Pdtutil_Assert(!chkRes||!Ddi_AigSatAnd(aCore,b,optCare),"error in AIG CORE");

  Ddi_Free(b2);

  return(aCore);
}


#endif


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatAndWithInterpolant (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Varset_t *globalVars,
  Ddi_Varset_t *domainVars,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *prevItp, // *itpPlus,
  Ddi_Bdd_t *constrCube,
  Ddi_Bddarray_t *implArray,
  int *psat,
  int itpPart,
  int itpOdc,
  float timeLimit
)
{
  return Ddi_AigSatAndWithInterpolantIncr (
           NULL,
           a, b, globalVars, domainVars, optCare, prevItp,
           constrCube, implArray, psat, itpPart, itpOdc, timeLimit
         );
}
  
/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatAndWithInterpolantIncr (
  Ddi_IncrSatMgr_t *incrSat, 
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Varset_t *globalVars,
  Ddi_Varset_t *domainVars,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *prevItp, // *itpPlus,
  Ddi_Bdd_t *constrCube,
  Ddi_Bddarray_t *implArray,
  int *psat,
  int itpPart,
  int itpOdc,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *interpolant=NULL, *reverseInterpolant=NULL,
    *interpolantOpt;
  Solver      *S = NULL;
  int nACl, i, checkVars = 0, dynAbstr = 0;
  Ddi_Vararray_t *vA, *vATot;
  static int checkInterpolant = 0;
  Ddi_Bdd_t *a2=NULL, *b2=NULL, *b2Part=NULL;
  Ddi_Varset_t *myGlobalVars, *suppB, *suppAB;
  int nSuppVars;
  static int itpStoreId=0, storeItp=0;
  int undefined = 0;
  int optLevel = Ddi_MgrReadAigBddOptLevel (ddm);
  long startTime, cpuTime, itpSatTime=-1;
  int enItpBddOpt = (optLevel > 0);
  int enItpTernary = 0;
  int doSatPart = (itpPart==2), doSatPart2 = (itpPart>2), satPartMaxPart=64;
  float satPartSmoothRatio = 1.0;
  int doSatPart3 = 0;
  int ddmid =  ddm->currNodeId;
  char *splitVarFile = "splitVarFile.txt";
  int itpPartTh = Ddi_MgrReadAigItpPartTh(ddm);
  int itpIteOptTh = ddm->settings.aig.itpIteOptTh;
  int itpStructOdcTh = ddm->settings.aig.itpStructOdcTh;
  int itpStoreTh = ddm->settings.aig.itpStoreTh;
  int constrCubeNum = 0;
  int nActiveVar=0;
  vec<Lit> assumps, assumps2;
  int nAssumpsA;
  //  itpOdc=0;
  int forcePart=0;
  int sizeA, sizeB;
  int computeCore = ddm->settings.aig.itpCore;
  int computeCoreAig = computeCore < 0;
  int itpAbc = Ddi_MgrReadAigItpAbc(ddm);
  Ddi_Bdd_t *bCore = NULL;
  Ddi_Bdd_t *aCore = NULL;
  int coreByRefinement=0, itpCoreTh = ddm->settings.aig.itpAigCore, itpSize;
  int itpTwiceTh = ddm->settings.aig.itpTwice;
  int saveBCore=0, bshared=0;
  int doIncrItp=0;
  int addReverseItp = 0;
  //  Ddi_Bdd_t *prevItp=NULL;
  Ddi_Bdd_t *itpPlus=NULL;
  int forceRevItp = 0 && ddm->settings.aig.itpReverse, tryRevItp=0, partialExistDone=0;
  Ddi_Bddarray_t *partitionLits=NULL, *revPartitionLits=NULL;
  int donePartialExist = 0, donePartialExistB = 0;
  int freeSolver = 1;
  int useCare = ddm->settings.aig.itpUseCare;

  vec<vec<Lit> > coreBClauses;
  vec<vec<Lit> > partitionClauses;

  bAig_array_t *cnfMappedVars=NULL;
  Ddi_Bdd_t *cnfSharedAigs = NULL;
  
  static int nCalls = 0;

  if (itpCoreTh < 0) {
    itpCoreTh *= -1;
    saveBCore = -1;
  }

  if (ddm->settings.aig.itpNoQuantify>0) {
    forceRevItp=1;
    itpCoreTh = -1;
    checkInterpolant = 0;
    //doIncrItp=1;
  }

  if (itpPart==1) {
    itpPart=0;
    if (Ddi_BddSize(a) > itpPartTh) {
      doIncrItp=1;
    }
  }

  nCalls++;

  if (computeCore<0) {
    computeCore = -computeCore;
  }

  if (itpPart<0) {
    forcePart=1;
    itpPart *= -1;
    doSatPart = (itpPart==2);
    doSatPart2 = (itpPart>2);
  }

  int checkBbySat = 0;
  int checkAbySat = 0;
  if (Ddi_BddIsZero(b) || incrSat==NULL && forceRevItp && 
      (checkBbySat && !Ddi_AigSatAnd(b,optCare,NULL))) {
    *psat = 0;
    return (Ddi_BddMakeConstAig(ddm,1));
  }
  if (Ddi_BddIsZero(a) || incrSat==NULL && checkAbySat && !Ddi_AigSat(a)) {
    *psat = 0;
    return (Ddi_BddMakeConstAig(ddm,0));
  }
  if (/*Ddi_BddIsOne(a) &&*/ Ddi_BddIsOne(b)) {
    *psat = 1;
    //    return (Ddi_BddMakeConstAig(ddm,1));
    return (NULL);
  }

  if (0&& (doSatPart || doSatPart2)) {
    FILE *fNames=fopen(splitVarFile,"r");
    if (fNames != NULL) {
      doSatPart3=1;
      doSatPart = doSatPart2 = 0;
      fclose(fNames);
    }
  }
  //  doSatPart = doSatPart2 = doSatPart3 = 0;
  //  doSatPart2 = doSatPart;
  //  doSatPart = 0;

  if (checkVars) {
    bAig_array_t *aNodes, *bNodes;
    int ii,jj;

    aNodes = bAigArrayAlloc();
    bNodes = bAigArrayAlloc();
    postOrderAigVisitIntern(bmgr,Ddi_BddToBaig(a),aNodes,-1);
    postOrderAigClearVisitedIntern(bmgr,aNodes);
    postOrderAigVisitIntern(bmgr,Ddi_BddToBaig(b),bNodes,-1);
    postOrderAigClearVisitedIntern(bmgr,bNodes);

    for (ii=0; ii<aNodes->num; ii++) {
      bAigEdge_t aBaig;
      aBaig = aNodes->nodes[ii];
      for (jj=0; jj<bNodes->num; jj++) {
        bAigEdge_t bBaig;
        bBaig = bNodes->nodes[jj];
        if (bAig_NonInvertedEdge(aBaig) == bAig_NonInvertedEdge(bBaig)) {
	  Ddi_Var_t *v;
	  if (bAig_isVarNode(bmgr,aBaig)) {
            v = Ddi_VarFromBaig(ddm,aBaig);
	    // Pdtutil_Assert(Ddi_VarInVarset(globalVars,v),"Non global var");
	  }
	}
      }

    }

    bAigArrayFree(aNodes);
    bAigArrayFree(bNodes);
  }

  myGlobalVars = Ddi_BddSupp(a); /* @@@ */
  suppAB = Ddi_BddSupp(b);
  Ddi_VarsetSetArray(suppAB);

  if (globalVars==NULL) {
    Ddi_VarsetSetArray(myGlobalVars);
    Ddi_VarsetIntersectAcc(myGlobalVars,suppAB);
  }
  else {
    if (Ddi_VarsetIsArray(globalVars)) {
      Ddi_VarsetSetArray(myGlobalVars);
    }
    Ddi_VarsetIntersectAcc(myGlobalVars,globalVars);
  }
  Ddi_VarsetSetArray(myGlobalVars);

  Ddi_VarsetUnionAcc(suppAB,myGlobalVars);
  vATot = Ddi_VararrayMakeFromVarset(suppAB,1);
  Ddi_Free(suppAB);

#if 0
  suppB = Ddi_BddSupp(b); /* @@@ */
  Ddi_VarsetSetArray(suppB);
  Ddi_VarsetIntersectAcc(myGlobalVars,suppB);
  Ddi_Free(suppB);
#endif
  nSuppVars = Ddi_VarsetNum(myGlobalVars);

  if (nSuppVars==0) {
    Ddi_Free(myGlobalVars);
    Ddi_Free(vATot);
    *psat = Ddi_AigSat(a) && Ddi_AigSat(b);
    if (*psat)
      return (NULL);
    else 
      return (Ddi_BddMakeConstAig(ddm,1));
  }

  vA = Ddi_VararrayMakeFromVarset(myGlobalVars,1);
  Ddi_Free(myGlobalVars);

  //  a2 = Ddi_BddDup(a);
  if (Ddi_BddIsPartConj(a)) {
    a2 = Ddi_BddDup(a);
  }
  else {
    a2 = Ddi_AigPartitionTopWithXor(a,0,1);
  }
  //  Ddi_BddSetAig(a2);
  b2 = Ddi_BddDup(b);
  if (doIncrItp) {
    Ddi_Bdd_t *bWork = Ddi_AigPartitionTop(b,1);
    if (Ddi_BddPartNum(bWork) <= 2) {
      int jj;
      for (jj=0; jj<Ddi_BddPartNum(bWork); jj++) {
        Ddi_Bdd_t *p_j = Ddi_BddPartRead(bWork,jj);
        Ddi_Bdd_t *bConj = Ddi_AigPartitionTop(p_j,0);
        if (Ddi_BddPartNum(bConj) > 1) {
          Ddi_Bddarray_t *b2A = Ddi_BddarrayMakeFromBddPart(bConj);
          Ddi_Bddarray_t *b2As = Ddi_AigarraySortByLevel(b2A);
          int np = Ddi_BddPartNum(bConj);
          Ddi_Bdd_t *p0 = Ddi_BddarrayRead(b2As,np-1);
          Ddi_Bdd_t *newp_j;
          newp_j = Ddi_AigPartitionTop(p0,1);
          if (Ddi_BddPartNum(newp_j) > 1) {
            Ddi_Free(b2Part);
            b2Part = Ddi_BddDup(newp_j);
          }
	  Ddi_Free(newp_j);
	  Ddi_Free(b2A);
	  Ddi_Free(b2As);
        }
        Ddi_Free(bConj);
      }
    }
    Ddi_Free(bWork);
    if (b2Part!=NULL) {
      Ddi_BddSetFlattened(b2Part);
    }
    if (b2Part!=NULL && (Ddi_BddPartNum(b2Part) > 1)) {
      Ddi_Bddarray_t *b2A = Ddi_BddarrayMakeFromBddPart(b2Part);
      Ddi_Bddarray_t *b2As = Ddi_AigarraySortByLevel(b2A);
      Ddi_Free(b2A); Ddi_Free(b2Part);
      b2Part = Ddi_BddMakePartDisjFromArray(b2As);
      Ddi_Free(b2As);
    }
    else {
      Ddi_Free(b2Part);
    }
  }

  if (!Ddi_BddIsPartConj(b2) && optCare != NULL && !Ddi_BddIsOne(optCare)) {
    int doOr=0 && !useCare;

    //    Ddi_AigConstrainOptAcc(b2,optCare,globalVars,NULL,NULL,0);
    if (doOr) {
#if 0
      if (Ddi_BddIsPartConj(a2)) {
        Ddi_BddPartInsertLast(a2,optCare);
      }
      else {
        Ddi_BddAndAcc(a2,optCare);
      }
#endif
      Ddi_BddNotAcc(optCare);
      Ddi_BddOrAcc(b2,optCare);
      Ddi_BddNotAcc(optCare);
    }
    else {
      Ddi_BddAndAcc(a2,optCare);
    }
    if (0 && b2Part!=NULL) {
      int ii;
      for (ii=0; ii<Ddi_BddPartNum(b2Part); ii++) {
        Ddi_Bdd_t *p_i = Ddi_BddPartRead(b2Part,ii);
        Ddi_BddAndAcc(p_i,optCare);
      }
    }
  }
  if (Ddi_BddIsZero(b2)) {
    Ddi_Free(a2); Ddi_Free(b2); Ddi_Free(b2Part);
    Ddi_Free(vA); Ddi_Free(vATot);
    *psat = 0;
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  if (itpAbc) {
    Ddi_Free(vATot);
    Ddi_Free(vA);
    interpolant = Ddi_AbcInterpolant (a2,b2,
                                      globalVars,domainVars,psat,timeLimit);
    undefined = *psat < 0;
  }
  else {

  if (dynAbstr) {
    Ddi_Bdd_t *lit;
    Ddi_Bddarray_t *abstrVarLit;
    Ddi_Vararray_t *vSubst;
    Ddi_Varset_t *aSupp = Ddi_BddSupp(a2);
    Ddi_Vararray_t *aSuppVars;
    int abstrCnt=0, dummyCnt=0, nSuppVars;
    char vName[100];
    Ddi_Var_t *abstrVar=NULL;

    Ddi_VarsetIntersectAcc(aSupp,globalVars);
    aSuppVars = Ddi_VararrayMakeFromVarset(aSupp,1);

    nSuppVars = Ddi_VararrayNum(aSuppVars);

    abstrVarLit = Ddi_BddarrayAlloc(ddm,1);
    vSubst = Ddi_VararrayAlloc(ddm,1);

    for (i=0; i<Ddi_VararrayNum(aSuppVars); i++) {
      Ddi_Bdd_t *aux;
      Ddi_Var_t *v_i = Ddi_VararrayRead(aSuppVars,i);
      Ddi_VararrayWrite(vSubst,0,v_i);


      sprintf(vName,"PDT_INTERPOLANT_DYNABSTR_VAR_%d", abstrCnt);
      abstrVar = Ddi_VarFromName(ddm,vName);
      if (abstrVar==NULL) {
        abstrVar = Ddi_VarNew(ddm);
        Ddi_VarAttachName (abstrVar, vName);
      }

      lit = Ddi_BddMakeLiteralAig(abstrVar,1);
      Ddi_BddarrayWrite(abstrVarLit,0,lit);
      Ddi_Free(lit);

      aux = Ddi_BddCompose(a2,vSubst,abstrVarLit);
      Ddi_BddAndAcc(aux,b);
      if (!Ddi_AigSat(aux)) {
	abstrCnt++;
        Ddi_BddComposeAcc(a2,vSubst,abstrVarLit);
      }
      else {
	dummyCnt++;
      }
      Ddi_Free(aux);
    }

    Ddi_Free(abstrVarLit);
    Ddi_Free(aSupp);
    Ddi_Free(aSuppVars);
    Ddi_Free(vSubst);

    if (abstrCnt > 0) {
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c,
        fprintf(dMgrO(ddm),"Interpolant DYN ABSTR: %d/%d\n",
          abstrCnt, nSuppVars));
    }

  }

  sizeA = Ddi_BddSize(a2);
  sizeB = Ddi_BddSize(b2);

  if (forcePart) {
    if (sizeA+sizeB < itpPartTh) {
      forcePart=0;
    }
  }
  
  if (!forcePart) {

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
                       fprintf(dMgrO(ddm),"ITP (|A|=%d,|B|=%d)\n",sizeA,sizeB));

  int isIncr = 0;
  if (incrSat != NULL) {
    S = incrSat->S;
    freeSolver = 0;
    isIncr = 1;
  }
  if (S==NULL) {
    aig2CnfIdInitDecr(ddm,2*(sizeA+sizeB)/3);
    S = new Solver();

    S->proof = new Proof();
    S->minisat20_opt = true;
  }
  //  S->pdt_opt_one_first = true;
  // S->pdt_opt_neg_first = true;

  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  if (isIncr) {
    // store dumy refs for incr solver (a2, b2 will be released
    Ddi_IncrSatMgrLockAig(incrSat,a2);
    Ddi_IncrSatMgrLockAig(incrSat,b2);
    if (optCare!=NULL) {
      Ddi_IncrSatMgrLockAig(incrSat,optCare);
    }
    // ddm->settings.aig.aigCnfLevel = 1;
  }
  if (computeCoreAig) {
    ddm->settings.aig.aigCnfLevel = 0;
    //    if (aigCnfLevel>4)  ddm->settings.aig.aigCnfLevel = 4;
    MinisatClausesWithSuppFlow(NULL,*S,NULL,a2,b2,globalVars,
                               &nACl,NULL,NULL,isIncr,isIncr,0,1);
    ddm->settings.aig.aigCnfLevel = aigCnfLevel;
  }
  else {
    if (0 && b2Part!=NULL) {
      Pdtutil_Assert(!incrSat,"incr SAT not supported here");
      MinisatClausesWithSuppFlow(NULL,*S,NULL,a2,b2Part,globalVars,&nACl,&bshared,NULL,0,1,0,1);
    }
    else {
      MinisatClausesWithSuppFlow(incrSat,*S,NULL,a2,b2,globalVars,
                           &nACl,&bshared,NULL,isIncr,isIncr,0,1);
    }
  }
  ddm->settings.aig.aigCnfLevel = aigCnfLevel;

  if (0 && useCare && optCare!=NULL&& !Ddi_BddIsConstant(optCare)) {
    int j;
    bAig_array_t *visitedNodes = bAigArrayAlloc();
    postOrderBddAigVisitIntern(optCare, visitedNodes, 0, -1);
    for (j=0; j<visitedNodes->num; j++) {
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (nodeAuxChar(bmgr,baig) == 1) {
	nodeAuxChar(bmgr,baig) = 4;
      }
    }
    postOrderAigClearVisitedIntern(bmgr,visitedNodes);
    bAigArrayFree(visitedNodes);
  }
  
  assumps.clear();
  
  assumps.copyTo(assumps2);
  if (isIncr) {
    MinisatAssume(a2,assumps);
    nAssumpsA = assumps.size();
    MinisatAssume(b2,assumps);
  }

  if (constrCube != NULL) {
    Ddi_Bdd_t *constrPart = Ddi_AigPartitionTop(constrCube,0);
    int j;
    constrCubeNum = Ddi_BddPartNum(constrPart);
    for (j=0; j<Ddi_BddPartNum(constrPart); j++) {
      Ddi_Bdd_t *c_j = Ddi_BddPartRead(constrPart,j);
      bAigEdge_t baig = Ddi_BddToBaig(c_j);
      int cCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(bmgr,baig) :
                                              aig2CnfId(bmgr,baig);
      while (abs(cCnf) > S->nVars()) S->newVar();
      assumps.push(MinisatLit(cCnf));
    }
    Ddi_Free(constrPart);
  }

  if (ddm->settings.aig.satVarActivity < 0) {
    int nCommon=0;
    int act = -ddm->settings.aig.satVarActivity;
    for (i=0; 1&&i<Ddi_VararrayNum(vA); i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
      bAigEdge_t varIndex = Ddi_VarToBaig(v);
      int vCnf = aig2CnfId(bmgr,varIndex);
      S->varBumpActivityExternal(MinisatLit(vCnf),act);
      Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
      nCommon++;
    }
    printf("COMMONVARS: %d\n", nCommon);
    act /= 10;
    for (i=0; 1&&i<Ddi_VararrayNum(vATot); i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vATot,i);
      bAigEdge_t varIndex = Ddi_VarToBaig(v);
      int vCnf = aig2CnfId(bmgr,varIndex);
      S->varBumpActivityExternal(MinisatLit(vCnf),act);
      Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
      nCommon++;
    }
  }

  startTime = util_cpu_time();

  for (i=0; 0&&i<Ddi_VararrayNum(vATot); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vATot,i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    int vCnf = aig2CnfId(bmgr,varIndex);
    double act = v->common.info->var.activity;
    S->varBumpActivityExternal(MinisatLit(vCnf),act);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
  }

  aig2SatActivity(ddm, S);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    printf("ITP time limit: %d\n", (int)timeLimit);
  }

  if ((*psat = S->okay())) {
    vec<vec<Lit> >  prevResolutionClauses;
    vec<Var>  prevCoreVars;
    if (ddm->cnf.useSavedAigsForSat<-1) {
      RestoreClausesAsAigs(ddm,prevResolutionClauses,NULL);
      //      RestoreVarsAsAigs(ddm,a2,prevCoreVars);
    }
    else if (ddm->cnf.useSavedAigsForSat==-1) {
      RestoreVarsAsAigs(ddm,NULL,prevCoreVars);
      //      RestoreVarsAsAigs(ddm,a2,prevCoreVars);
    }
    
    if (0 && b2Part!=NULL) {
      int ii, isSat=0, isUnsat=0;
      int cntUndefLits=0, cntTrueLits=0;
      int np=Ddi_BddPartNum(b2Part);
      vec<Lit> totAssumps;
      vec<Lit> partTargets;
      partTargets.clear();

      for (ii=0; ii<np; ii++) {
        Ddi_Bdd_t *p_i = Ddi_BddPartRead(b2Part,ii);
        bAigEdge_t baig = Ddi_BddToBaig(p_i);
        int cCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(bmgr,baig) :
          aig2CnfId(bmgr,baig);
        partTargets.push(MinisatLit(cCnf));
      }

      undefined = 0;

      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("Incremental ITP with %d B partitions\n", np);
      }
      for (ii=0; 1&&(ii<np); ii++) {
        Ddi_Bdd_t *p_i = Ddi_BddPartRead(b2Part,ii);
        bAigEdge_t baig = Ddi_BddToBaig(p_i);
        int iii;
        int cCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(bmgr,baig) :
          aig2CnfId(bmgr,baig);

#if 1
        for (cntUndefLits=cntTrueLits=iii=0; iii<np; iii++) {
          if (S->value(partTargets[iii]) == l_Undef) cntUndefLits++;
          if (S->value(partTargets[iii]) == l_True) cntTrueLits++;
        }
        if (cntUndefLits==0) {
          break;
        }
#endif

        totAssumps.clear();
        assumps.copyTo(totAssumps);
        totAssumps.push(MinisatLit(cCnf));

        if (!(*psat = S->okay())) {
          break;
        }
        Pdtutil_Assert(S->okay(),"solver is !okay()");
        if (timeLimit >= 0) {
          *psat = S->solve(totAssumps, timeLimit);
          undefined = S->undefined();
        }
        else {
          *psat = S->solve(totAssumps, -1.0);
        }
        if (undefined || *psat) {
          if (*psat) {
            isSat = 1;
          }
          break;
        }
      }
#if 1

      if (!undefined && !isSat) {
        if ((*psat = S->okay())) {
          if (timeLimit >= 0) {
            if (prevResolutionClauses.size()>0) {
              S->storePreviousRes(&prevResolutionClauses);
              *psat = S->solve(assumps, timeLimit);
            }
            else if (prevCoreVars.size()>0) {
              S->storePreviousCoreVars(&prevCoreVars);
              *psat = S->solve(assumps, timeLimit);
            }
            else 
              *psat = S->solve(assumps, timeLimit);
            undefined = S->undefined();
          }
          else {
            *psat = S->solve(assumps, -1.0);
          }
        }
      }
#endif
    }
    else {
      if (timeLimit >= 0) {
        hintSatPreprocess(ddm,S,NULL,NULL,b2Part);
        if (prevResolutionClauses.size()>0) {
          S->storePreviousRes(&prevResolutionClauses);
          *psat = S->solve(assumps, timeLimit);
        }
        else if (prevCoreVars.size()>0) {
          S->storePreviousCoreVars(&prevCoreVars);
          *psat = S->solve(assumps, timeLimit);
        }
        else 
          *psat = S->solve(assumps, timeLimit);
        undefined = S->undefined();
      }
      else {
        *psat = S->solve(assumps, -1.0);
      }
    }
  }
  else {
    // fprintf(dMgrO(ddm),"UNSAT\n");
  }
  cpuTime = itpSatTime = util_cpu_time () - startTime;

  sat2AigActivity(ddm, S);

  for (i=0; 0&&i<Ddi_VararrayNum(vATot); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vATot,i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    int vCnf = aig2CnfId(bmgr,varIndex);
    double act = S->varReadActivityExternal(MinisatLit(vCnf))/1000.0;
    if (1) {
      if (act > 1000) act = 1000;
      v->common.info->var.activity += act;
      v->common.info->var.activity = act;
      //if (v->common.info->var.activity > 1000)
      //  v->common.info->var.activity = 1000;
    }
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
  }

  Ddi_Free(vATot);

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),"Solver stats: %ld/%ld vars/clauses\n",
      S->nVars(), S->nClauses());
    fprintf(dMgrO(ddm),
      "Solver stats: %ld/%ld/%ld(%ld) dec./prop./confl.(small)\n",
      (int)S->stats.decisions, (int)S->stats.propagations,
       (int)S->stats.conflicts,(int)S->stats.smallconflicts);
    fprintf(dMgrO(ddm),
      "Solver stored decisions: %ld\n",
            (int)S->stats.storeddecisions);
    fprintf(dMgrO(ddm),"Solver stats: time = %s\n", util_print_time (cpuTime)));

  if (undefined) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"Solver result UNDEFINED\n"));
    *psat = 0;
  }

  if (*psat || (undefined && !itpPart)) {
    if (freeSolver) {
      aig2CnfIdClose(ddm);
    }
    if (checkInterpolant) {
      if (!freeSolver) {
        Ddi_IncrSatMgrSuspend(incrSat);
      }
#if CHECK_AIGCNF_LEVEL
      if (ddm->settings.aig.aigCnfLevel > 0) {
        int sat1;
        int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
        ddm->settings.aig.aigCnfLevel = 0;
        sat1 = Ddi_AigSatAnd(a2,b2,optCare);
        ddm->settings.aig.aigCnfLevel = aigCnfLevel;
        Pdtutil_Assert(sat1,"error in sat with aigcnflevel");
      }
#endif
      Pdtutil_Assert(Ddi_AigSatAnd(a,b,optCare),"invalid interpolant sat");
      if (!freeSolver) {
        Ddi_IncrSatMgrResume(incrSat);
      }
    }
    
    Ddi_Free(a2);
    Ddi_Free(b2);
    Ddi_Free(b2Part); 
    if (freeSolver) {
     S->deleteProofTemps();
      delete S;
    }
    else {
      S = NULL;
    }
    Ddi_Free(vA);
    if (undefined) *psat = -1;

    return NULL;
  }
#if 0
  printf("VAR ACTIVITIES: ");
  for (i=0; 1&&i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    int vCnf = aig2CnfId(bmgr,varIndex);
    int activity = S->varReadActivityExternal(MinisatLit(vCnf));
    if (activity != 0) {
      nActiveVar++;
      printf("%s: %d - ", Ddi_VarName(v), activity);
    }
  }
  printf("# active: %d\n", nActiveVar);
#endif

  if (constrCube != NULL) {
    Ddi_Bdd_t *constrFinal = Ddi_BddMakeConstAig(ddm, 1);
    int k;

    printf("solver final selected %d/%d vars\n", S->conflict.size(),
	   constrCubeNum);
    for (k=0; k<S->conflict.size(); k++) {
      Ddi_Bdd_t *lit;
      Lit kLit = S->conflict[k];
      int vSat = var(kLit);
      int signSat = sign(kLit);
      int vCnf = vSat+1;
      bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      Pdtutil_Assert(v!=NULL,"NULL var in solver final")
      /* conflict has complemented literals w.r.t. assump !!! */
      lit = Ddi_BddMakeLiteralAig(v,signSat);
      Ddi_BddAndAcc(constrFinal,lit);
      Ddi_Free(lit);
    }
    Ddi_DataCopy(constrCube,constrFinal);
    Ddi_Free(constrFinal);
  }


  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
    nodeAuxChar(bmgr,varIndex) = 3;
  }

  bAig_array_t *extraGlobalNodes = NULL;

  if (0 && ddm->settings.aig.itpNoQuantify>0) {
    bAig_array_t *bNodes;
    int ii;
    //    checkInterpolant = 0;
    bNodes = bAigArrayAlloc();
    extraGlobalNodes = bAigArrayAlloc();
    postOrderAigVisitIntern(bmgr,Ddi_BddToBaig(b2),bNodes,-1);
    postOrderAigClearVisitedIntern(bmgr,bNodes);
    bAigArraySortByLevel(ddm,bNodes,bAig_NULL,-1);
#if 1
    for (ii=0; ii<bNodes->num/3; ii++) {
      bAigEdge_t bBaig = bNodes->nodes[ii];
      nodeAuxChar(bmgr,bBaig) = 3;
      bAigArrayPush(extraGlobalNodes,bBaig);
    }
#else
    for (ii=0; ii<bNodes->num/2; ii++) {
      bAigEdge_t bBaig = bNodes->nodes[ii];
      if (bAig_isVarNode(bmgr,bBaig)) {
        nodeAuxChar(bmgr,bBaig) = 3;
        bAigArrayPush(extraGlobalNodes,bBaig);
      }
    }
#endif
    bAigArrayFree(bNodes);    
  }
  
  if (computeCore && (((int)S->proof->last())<computeCore)){
    computeCore=0;
  }

  if (undefined) {
    interpolant = Ddi_BddMakeConstAig(ddm, 1);
  }
  else if (computeCoreAig && computeCore){
    vec<Var> coreVars;
    vec<vec<Lit> > coreClauses;
    int nACore = MinisatCore (*S, ddm, nACl, coreVars, coreClauses,1);
    int nCut=0;
    /* process core vars */
    bCore = MinisatCoreAig(b2,NULL,coreVars,NULL,NULL,&nCut,NULL,NULL,0);
    aCore = MinisatCoreAig(a2,NULL,coreVars,NULL,NULL,&nCut,NULL,NULL,0);
  }
  else if (computeCore){
    Solver      S2;
    int doResolutionB = !isIncr;
    vec<Var> coreVars;
    vec<vec<Lit> > coreClauses;
    vec<Lit> c2;
    int i,sat,nAClCore,vSat,vSat2,signLit;
    int nACore = MinisatCoreWithResolution (*S, ddm,
           (nACl<0 || isIncr)?a2:NULL,
           nACl, isIncr ? &assumps : NULL, nAssumpsA,
           coreVars, coreClauses,doResolutionB,!isIncr);

    int *cnf2solver;
    S2.proof = new Proof();

    saveBCore = itpCoreTh>0;
    if (saveBCore && bshared) {
      saveBCore = 0;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	fprintf(dMgrO(ddm),
		"A-B shared AIGs: %d. Disabling core clauses usage\n", bshared);
      }
    }

    int storeCore=0;
    if (storeCore) {
      FILE *fp = fopen("core.txt","w");
      fprintf(fp, "%d %d\n", nACore, coreClauses.size());
      for (i=0; i<coreClauses.size(); i++) {
	int j, vCnf;
	vec<Lit>& c = coreClauses[i];
        fprintf(fp, "%d", c.size());
        for (j=0; j<c.size(); j++) {
          vCnf = var(c[j])+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	  fprintf(fp, " %s%d", sign(c[j])?"-":"", baig/4);
        }
        fprintf(fp, "\n");
      }
      fclose (fp);
    }
    int loadCore=0;
    if (loadCore) {
      FILE *fp = fopen("core.txt","r");
      int nc, nl, lit;
      coreClauses.clear();
      fscanf(fp, "%d%d", &nACore, &nc);
      coreClauses.growTo(nc);
      for (i=0; i<coreClauses.size(); i++) {
	int j, vCnf, vSat;
        bAigEdge_t baig;
	vec<Lit>& c = coreClauses[i];
        c.clear();
        fscanf(fp, "%d", &nl);
        for (j=0; j<nl; j++) {
	  fscanf(fp, "%d", &baig);
          if (baig<0) {
            baig = -baig*4;
            vCnf = -aig2CnfId(bmgr,baig);
          }
          else {
            baig=baig*4;
            vCnf = aig2CnfId(bmgr,baig);
          }
          Pdtutil_Assert(vCnf!=0,"error");
          vSat = abs(vCnf)-1;
          while (S->nVars()<=vSat) S->newVar();
          Lit l = MinisatLit(vCnf);
          c.push(l);
        }
      }
      fclose (fp);
    }
    int printCore = 0;
    if (printCore) {

      for (i=0; i<coreClauses.size(); i++) {
	int j, vCnf;
	vec<Lit>& c = coreClauses[i];
	if (i==nACore) {
          printf(" A: --------------------------\n");
        }
        printf("%3d] ", i);
        for (j=0; j<c.size(); j++) {
          int s = sign(c[j]);
	  vSat = var(c[j]);
	  vCnf = vSat+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          int isGlob = nodeAuxChar(bmgr,baig) == 3;
          int isB = nodeAuxChar(bmgr,baig) == 1;
          printf(" %s%d", s?"-":"", baig/4);
          if (isGlob) printf("(G)");
          else if (isB) printf("(B)");
	}
        printf("\n");
      }

    }

    cnf2solver = Pdtutil_Alloc(int,S->nVars());
    ddm->cnf.solver2cnf = Pdtutil_Alloc(int,S->nVars());

    for (i=0; i<S->nVars(); i++) {
      cnf2solver[i] = ddm->cnf.solver2cnf[i] = -1;
    }
    for (i=0; i<coreClauses.size(); i++) {
      int j;
      vec<Lit>& c = coreClauses[i];
      if (i==nACore) {
        nAClCore = S2.proof->last()+1;
      }
      c2.clear();
      for (j=0; j<c.size(); j++) {
        vSat = var(c[j]);
        bAigEdge_t baig = ddm->cnf.cnf2aig[vSat+1];
        int isGlob = nodeAuxChar(bmgr,baig) == 3;
        int isB = nodeAuxChar(bmgr,baig) == 1;
        int isA = nodeAuxChar(bmgr,baig) == 0;
        if (i<nACore) {
          // A clause
          if (isB) {
            nodeAuxChar(bmgr,baig) = 3; // set as global
          }
        }
        else {
          if (isA) {
            nodeAuxChar(bmgr,baig) = 3; // set as global
          }
        }
	signLit = sign(c[j]);
        Pdtutil_Assert(vSat<S->nVars(),"wrong var");
        vSat2 = cnf2solver[vSat];
        if (vSat2<0) {
          double act = S->varReadActivityExternal(Lit(vSat))/1e5;
          vSat2 = cnf2solver[vSat] = S2.nVars();
          ddm->cnf.solver2cnf[vSat2] = vSat;
          S2.newVar();
          S2.varBumpActivityExternal(Lit(vSat2),1);
        }
        Pdtutil_Assert(vSat2<S->nVars(),"wrong var");
        c2.push((signLit?~Lit(vSat2):Lit(vSat2)));
      }
      S2.addClause(c2);
    }

    if (saveBCore>0) {

      vec<char> aVar;

      cnfMappedVars=bAigArrayAlloc();
      cnfSharedAigs = Ddi_BddMakePartConjVoid(ddm);

      aVar.growTo(S->nVars());
      for (i=0; i<S->nVars(); i++) {
        aVar[i] = 0;
      }      
      for (i=0; i<=S->nVars(); i++) {
	bAigArrayWriteLast(cnfMappedVars,bAig_NULL);
      }
      coreBClauses.clear();
      for (i=0; i<coreClauses.size(); i++) {
	int j, vCnf;
	vec<Lit>& c = coreClauses[i];
	if (i>=nACore) {
	  coreBClauses.push();
	  c.copyTo(coreBClauses.last());
	}
	for (j=0; j<c.size(); j++) {
	  vSat = var(c[j]);
	  vCnf = vSat+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	  cnfMappedVars->nodes[vCnf] = baig;
          if (i<nACore) {
            aVar[vSat] = 1;
          }
          else {
            // B var - check if internal AIGnode and shared
            int careVar = nodeAuxChar(bmgr,baig) == 4;
            if ((careVar || aVar[vSat]) &&
                !bAig_isVarNode(bmgr,baig)) {
              Ddi_Bdd_t *shared = Ddi_BddMakeFromBaig(ddm,baig); 
              Ddi_BddPartInsertLast(cnfSharedAigs,shared);
              Ddi_Free(shared);
              aVar[vSat] = 0;
            }
          }
	}
      }
      if (Ddi_BddPartNum(cnfSharedAigs)==0)
        Ddi_Free(cnfSharedAigs);

    }

    startTime = util_cpu_time();

    hintSatPreprocess(ddm,S,&S2,cnf2solver,NULL);

    if (S!=NULL && freeSolver) {
      S->deleteProofTemps();
      delete S;
    }
    S = NULL;
    //    Pdtutil_Assert(S2.okay(),"OK required");

    Pdtutil_Free(cnf2solver);
    
    sat = S2.solve(assumps2, -1.0);

    cpuTime = util_cpu_time () - startTime;
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"Core   stats: %ld/%ld vars/clauses\n",
        S2.nVars(), S2.nClauses());
    fprintf(dMgrO(ddm),
        "Core   stats: %ld/%ld/%ld(%ld) dec./prop./confl.(small)\n",
        (int)S2.stats.decisions, (int)S2.stats.propagations,
         (int)S2.stats.conflicts,(int)S2.stats.smallconflicts);
    fprintf(dMgrO(ddm),"Core   stats: time = %s\n",
            util_print_time (cpuTime)));


    Pdtutil_Assert(!sat,"unsat required");
    Ddi_Free(partitionLits);
    partitionLits = Ddi_BddarrayAlloc(ddm,0);

    if (forceRevItp) {
      interpolant = Ddi_BddMakeConstAig(ddm, 1);
    }
    else {
      MinisatInterpolant (S2, ddm, nAClCore, 0, &interpolant, &interpolantOpt,
			optCare, partitionLits, &partitionClauses,
                        nSuppVars,itpOdc);
    }
    
    if (ddm->stats.aig.itpPartialExist>0) {
      donePartialExist = 1;
      if (ddm->settings.aig.itpTwice>0) {
	donePartialExistB = 1;
	addReverseItp = tryRevItp = 1;
      }
    }
    
    if (forceRevItp) tryRevItp = 1;
    
    if (ddm->cnf.useSavedAigsForSat==1) {
      SaveVarsAsAigs(ddm,coreVars,NULL);
    }
    //    AnalyzeCoreVars(coreVars,b2);

    if (addReverseItp || tryRevItp) {

      Ddi_Free(revPartitionLits);
      revPartitionLits = Ddi_BddarrayAlloc(ddm,0);
      MinisatInterpolant (S2, ddm, nAClCore, 1, &reverseInterpolant, &interpolantOpt,
                          optCare, revPartitionLits, NULL, nSuppVars,itpOdc);

      if (tryRevItp && reverseInterpolant!=NULL) {
        int sizeR = Ddi_BddSize(reverseInterpolant);
        if (forceRevItp || (sizeR < itpSize) || donePartialExistB) {
          Ddi_Bdd_t *tmp = reverseInterpolant;
          if (forceRevItp) itpSize = Ddi_BddSize(interpolant);
          reverseInterpolant = interpolant;
          interpolant = tmp;
          Ddi_BddNotAcc(interpolant);
          Ddi_BddNotAcc(reverseInterpolant);
          Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c,
            printf("Swapping direct/rev ITP: %d/%d)\n", 
                itpSize, sizeR));
         itpSize = sizeR;
        }
      }
      if (!addReverseItp) {
        Ddi_Free(reverseInterpolant);
      }

    }

    Pdtutil_Free(ddm->cnf.solver2cnf);
    ddm->cnf.solver2cnf = NULL;

  }
  else {

    if (saveBCore<0) {

      int i,vSat,vSat2;

      vec<Var> coreVars;
      vec<vec<Lit> > coreClauses;
      vec<char> aVar;

      int nACore = MinisatCoreWithResolution (*S, ddm, NULL, nACl, 
            NULL, 0, coreVars, coreClauses, 1, 0);

      if (ddm->cnf.useSavedAigsForSat==1) {
        SaveVarsAsAigs(ddm,coreVars,NULL);
      }
      
      cnfMappedVars=bAigArrayAlloc();
      cnfSharedAigs = Ddi_BddMakePartConjVoid(ddm);
      for (i=0; i<=S->nVars(); i++) {
	bAigArrayWriteLast(cnfMappedVars,bAig_NULL);
      }
      aVar.growTo(S->nVars());
      for (i=0; i<S->nVars(); i++) {
        aVar[i]=0;
      }      

      coreBClauses.clear();
      for (i=nACore; i<coreClauses.size(); i++) {
	int j, vCnf;
	vec<Lit>& c = coreClauses[i];
	if (i>=nACore) {
	  coreBClauses.push();
	  c.copyTo(coreBClauses.last());
	}
	for (j=0; j<c.size(); j++) {
	  vSat = var(c[j]);
	  vCnf = vSat+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	  cnfMappedVars->nodes[vCnf] = baig;
          if (i<nACore) {
            aVar[vSat] = 1;
          }
          else {
            // B var - check if internal AIGnode and shared
            int careVar = nodeAuxChar(bmgr,baig) == 4;
            if ((careVar || aVar[vSat]) &&
                !bAig_isVarNode(bmgr,baig)) {
              Ddi_Bdd_t *shared = Ddi_BddMakeFromBaig(ddm,baig); 
              Ddi_BddPartInsertLast(cnfSharedAigs,shared);
              Ddi_Free(shared);
            }
          }
	}
      }
      if (Ddi_BddPartNum(cnfSharedAigs)==0)
        Ddi_Free(cnfSharedAigs);

    }

    Ddi_Free(partitionLits);
    partitionLits = Ddi_BddarrayAlloc(ddm,0);
    if (forceRevItp) {
      interpolant = Ddi_BddMakeConstAig(ddm, 1);
      addReverseItp = 1;
    }
    else {
      MinisatInterpolant (*S, ddm, nACl, 0, &interpolant, &interpolantOpt,
                          optCare, partitionLits, NULL, nSuppVars,itpOdc);

      if (interpolant != NULL && itpCoreTh>0 &&
          ((itpSize = Ddi_BddSize(interpolant)) > itpCoreTh)) {
        addReverseItp=0;
        if (itpSize > sizeB) addReverseItp=0;
      }
      else {
        itpSize = Ddi_BddSize(interpolant);
      }
      if (1 && (itpSize<10)) {
        addReverseItp = tryRevItp = 0;
      }

      if (ddm->stats.aig.itpPartialExist>0) {
        donePartialExist = 1;
        if (ddm->settings.aig.itpTwice>0) {
          donePartialExistB = 1;
          addReverseItp = tryRevItp = 1;
        }
      }
    }
    
    if (addReverseItp || tryRevItp) {

      Ddi_Free(revPartitionLits);
      revPartitionLits = Ddi_BddarrayAlloc(ddm,0);
      MinisatInterpolant (*S, ddm, nACl, 1,
                          &reverseInterpolant,
                          &interpolantOpt,
                          optCare, revPartitionLits, NULL,
                          nSuppVars,itpOdc);

      if (tryRevItp && reverseInterpolant!=NULL) {
        int sizeR = Ddi_BddSize(reverseInterpolant);
        if (sizeR < itpSize || donePartialExistB) {
          Ddi_Bdd_t *tmp = reverseInterpolant;
          reverseInterpolant = interpolant;
          interpolant = tmp;
          Ddi_BddNotAcc(interpolant);
          Ddi_BddNotAcc(reverseInterpolant);
          Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c,
            printf("Swapping direct/rev ITP: %d/%d)\n", 
                itpSize, sizeR));
         itpSize = sizeR;
        }
      }
      if (!addReverseItp) {
        Ddi_Free(reverseInterpolant);
      }

    }
  }

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
    nodeAuxChar(bmgr,varIndex) = 0;
  }
  if (extraGlobalNodes!=NULL) {
    int ii;
    for (ii=0; ii<extraGlobalNodes->num; ii++) {
      bAigEdge_t bBaig = extraGlobalNodes->nodes[ii];
      nodeAuxChar(bmgr,bBaig) = 0;
    }
    bAigArrayFree(extraGlobalNodes);
  }
  
  if (incrSat!=NULL) {
    bAig_array_t *bNodes;
    int ii;

    bNodes = bAigArrayAlloc();
    postOrderAigVisitIntern(bmgr,Ddi_BddToBaig(b2),bNodes,-1);
    postOrderAigClearVisitedIntern(bmgr,bNodes);
    for (ii=0; ii<bNodes->num; ii++) {
      bAigEdge_t bBaig = bNodes->nodes[ii];
      nodeAuxChar(bmgr,bBaig) = 0;
    }
    bAigArrayFree(bNodes);
  }
  
  Ddi_Free(vA);

  if (freeSolver) {
    aig2CnfIdClose(ddm);
  }
  if (ddm->cnf.useSavedAigsForSat>0) {
    ddm->cnf.useSavedAigsForSat = 0;
  }

  if (partitionLits!=NULL && Ddi_BddarrayNum(partitionLits)>0) {
#if 1
#if ITP_FRONTIER_COMPOSE
    int j, notok=0, np=Ddi_BddarrayNum(partitionLits);
    Ddi_Bdd_t *itpFrontier = Ddi_BddMakePartDisjFromArray(partitionLits);
    Ddi_Bdd_t *newItp, *topF = Ddi_BddReadComposeF(interpolant);
    Ddi_Bddarray_t *splitU = NULL;
    Ddi_Vararray_t *splitV = NULL;
    Ddi_Bdd_t *auxFpart;
    Pdtutil_Assert(topF!=NULL,"itp composition needed");
    splitU = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(interpolant));
    splitV = Ddi_VararrayDup(Ddi_BddReadComposeVars(interpolant));
    auxFpart = Ddi_BddMakePartDisjFromArray(splitU);
    //    Ddi_BddSetAig(itpFrontier);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c,
			 printf("Optimizing Compose ITP: %d (%d|%d)\n", 
				Ddi_BddSize(interpolant),
				Ddi_BddSize(topF),
				Ddi_BddarraySize(splitU)));
    if (saveBCore) {
      Pdtutil_Assert(cnfMappedVars!=NULL,"cnf mapped needed");

      if (1){
        int custom = 0;
        if (custom) 
        {
          Ddi_Var_t *v = Ddi_VarFromName(ddm,"l176$NS");
          Ddi_Bdd_t *lit = NULL; //Ddi_BddMakeLiteralAig(v,1);
          int ipart = 0;
          Ddi_Bdd_t *p = Ddi_BddDup(Ddi_BddPartRead(auxFpart,ipart));
          vec<vec<Lit> > partC;
          partC.clear();
          partC.push();
          vec<Lit>& c = partitionClauses[ipart];
          c.copyTo(partC[0]);
          Ddi_Free(lit);
          lit = Ddi_BddarrayRead(partitionLits,ipart);
          //          Ddi_BddAndAcc(p,lit);
          Ddi_BddSetPartDisj(p);
          aigOptByMonotoneCoreAcc (p,b,NULL,
                                   &coreBClauses,NULL,&partC,
                                 cnfMappedVars,0,0,0,-1.0);
          Ddi_Free(p);          

        }
        
        if (1)
        aigOptByMonotoneCoreAcc (auxFpart,b,NULL,
                                 &coreBClauses,NULL,
                                 &partitionClauses,
                                 cnfMappedVars,0,0,0,-1.0);
      }
    }
    else {
      if (0 && itpFrontier != NULL && Ddi_BddPartNum(itpFrontier) > 0) {
	int j, sCnt=0, disSat=1;
        Ddi_Bdd_t *a = Ddi_BddDup(auxFpart); 
	for (j=0; j<Ddi_BddPartNum(itpFrontier); j++) {
	  Ddi_Bdd_t *p_j = Ddi_BddPartRead(itpFrontier,j);
	  Ddi_Bdd_t *a_j = Ddi_BddPartRead(a,j);
          if (1&&optCare!=NULL) {
            Ddi_BddAndAcc(p_j,optCare);
          }
	  Ddi_BddAndAcc(a_j,p_j);
          if (!disSat && Ddi_AigSatAnd(a_j,b,optCare)) {
            printf("SAT found\n");
            sCnt++;
          }
	}
	Ddi_BddSetAig(a);
        int sat = Ddi_AigSatAnd(a,b,optCare);
        if (sat) {
          printf("SAT tot found\n");
        }
        Ddi_Free(a);
      }
      if (1)
      Ddi_AigOptByMonotoneCoreAcc (auxFpart,b2,itpFrontier,
					     0,-1.0);
    }
    Ddi_Bddarray_t *auxF = Ddi_BddarrayMakeFromBddPart(auxFpart);
    static int checkRes = 0;
    newItp = Ddi_BddCompose(topF,splitV,auxF);
    if (!Ddi_BddEqual(newItp,interpolant)) {
      Pdtutil_Assert(!checkRes || !Ddi_AigSatAnd(newItp,b,optCare),"wrong compose opt");
      //      printf("problem\n");
    }
    Ddi_Free(itpFrontier);
    Ddi_Free(interpolant);
    interpolant = newItp;

    Ddi_Free(auxF);
    Ddi_Free(auxFpart);
    Ddi_Free(splitU);
    Ddi_Free(splitV);

#else
    int j, notok=0, np=Ddi_BddarrayNum(partitionLits);
    Ddi_Bdd_t *itpFrontier = Ddi_BddMakePartDisjFromArray(partitionLits);
    Ddi_BddSetAig(itpFrontier);
    if (Ddi_AigSatAnd(itpFrontier,b,NULL)) {
      notok = 1;
    }
    Ddi_Free(itpFrontier);
    if (!notok) {
      printf("ITP frontier OK\n");
    }
    else {
      notok = 0;
      for (j=0; j<np; j++) {
	itpFrontier = Ddi_BddarrayRead(partitionLits,j);
	if (Ddi_AigSatAnd(itpFrontier,b,NULL)) {
	  notok++;
	}
      }
      printf("ITP frontier not OK - # %d/%d\n", notok, np);
    }
    //    Ddi_Free(itpFrontier);
#endif
#else
    Ddi_Bdd_t *p0 = Ddi_BddarrayRead(partitionLits,0);
    Ddi_Bdd_t *b0 = Ddi_BddDup(b);
    Ddi_Bdd_t *b1 = Ddi_BddDup(b);
    Ddi_BddAndAcc(b1,p0);
    Ddi_BddDiffAcc(b0,p0);

    Ddi_AigStructRedRemAcc (b0,NULL);
    Ddi_AigStructRedRemAcc (b1,NULL);
    printf("Try part B with proof top var (%d): %d -> (%d,%d)\n",
	   Ddi_BddSize(p0),
	   Ddi_BddSize(b), Ddi_BddSize(b0), Ddi_BddSize(b1)); 

    Ddi_Free(b0);
    Ddi_Free(b1);
#endif
    Ddi_Free(partitionLits);
  }

  if (0 && (reverseInterpolant!=NULL)) {
    printf("checking ITP <-> ITPR: %d - %d\n",
           Ddi_BddSize(interpolant),Ddi_BddSize(reverseInterpolant));
    Pdtutil_Assert(!Ddi_AigSatAnd(interpolant,reverseInterpolant,0),"wrong reverse ITP");
    //    Ddi_Free(reverseInterpolant);
  }

  if (S!=NULL && freeSolver) {
    S->deleteProofTemps();
  }

  }
  else {
    interpolant=NULL;
    Ddi_Free(vATot);
    Ddi_Free(vA);
  }
  if (S!=NULL && freeSolver) {
    delete S;
  }

  if (bCore!=NULL) {
    int myComputeCore = ddm->settings.aig.itpCore;
    ddm->settings.aig.itpCore=0;
    Pdtutil_Assert(interpolant==NULL,"null interpolant required with core");
    //    Pdtutil_Assert(!Ddi_AigSatAnd(aCore,bCore,optCare),"wrong core opt");
    //    ddiAbcOptAcc (bCore,-1);
    //    ddiAbcOptAcc (aCore,-1);
    //    Pdtutil_Assert(!Ddi_AigSatAnd(aCore,bCore,optCare),"wrong core opt");
    interpolant = Ddi_AigSatAndWithInterpolant (aCore,bCore,globalVars,NULL,
		    optCare,NULL,NULL,implArray,psat,0,itpOdc,timeLimit);
    Ddi_Free(aCore);
    Ddi_Free(bCore);
    Pdtutil_Assert(interpolant!=NULL,"interpolant required with core");
    ddm->settings.aig.itpCore = myComputeCore;
  }

  }

#if CHECK_AIGCNF_LEVEL
  if (ddm->settings.aig.aigCnfLevel > 0) {
    int sat1;
    int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
    ddm->settings.aig.aigCnfLevel = 0;
    sat1 = Ddi_AigSatAnd(a2,b2,optCare);
    ddm->settings.aig.aigCnfLevel = aigCnfLevel;
    Pdtutil_Assert(!sat1,"error in sat with aigcnflevel");
  }
#endif

  if (interpolant != NULL && checkInterpolant>1 && !undefined) {
    Ddi_BddSetAig(a);
    Ddi_Bdd_t *tmp = Ddi_BddDiff(a,interpolant);
    if (0 && Ddi_AigSat(tmp)) {
      printf("invalid interpolant (A) - stored");
      ddm->settings.aig.itpStore = Pdtutil_StrDup("itpErr");
      itpStoreTh = -1;
      interpolant = Ddi_BddMakeConstAig(ddm,1);
    }
    else {
      Pdtutil_Assert(!Ddi_AigSatAnd(tmp,optCare,NULL), "invalid interpolant (A)");
      Ddi_Free(tmp);
      Pdtutil_Assert(!Ddi_AigSatAnd(interpolant,b,optCare), "invalid interpolant");
    }
    Ddi_Free(tmp);
  }

  if (0 && interpolant != NULL && implArray != NULL) {
     Ddi_AigConstrainImplAcc (interpolant,implArray);
  }
  
  if (interpolant!=NULL && ddm->settings.aig.itpStore != NULL &&
      Ddi_BddSize(interpolant) > itpStoreTh) {
    Ddi_Bddarray_t *benchArray;
    char filename[100];
    benchArray = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_BddarrayInsertLast(benchArray, interpolant);
    if (Ddi_BddIsPartConj(a)) {
      Ddi_Bdd_t *aAig = Ddi_BddMakeAig(a);
      Ddi_BddarrayInsertLast(benchArray, aAig);
      Ddi_Free(aAig);
    }
    else {
      Ddi_BddarrayInsertLast(benchArray, a);
    }
    Ddi_BddarrayInsertLast(benchArray, b);
#if 1
    if (optCare != NULL && !Ddi_BddIsOne(optCare)) {
      Ddi_BddarrayInsertLast(benchArray, optCare);
    }
    if (prevItp != NULL && !Ddi_BddIsOne(prevItp)) {
      Ddi_BddarrayInsertLast(benchArray, prevItp);
    }
#if 0
    else {
      optCare = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_BddarrayInsertLast(benchArray, optCare);
      Ddi_Free(optCare);
      optCare = NULL;
    }
#endif
#endif
    if (Ddi_BddReadComposeF(b)!=NULL) {
      Ddi_Bddarray_t *litsAndSubst =
        Ddi_BddarrayMakeLiteralsAig(Ddi_BddReadComposeVars(b), 1);
      Ddi_BddarrayInsertLast(benchArray, Ddi_BddReadComposeF(b));
      Ddi_BddarrayAppend(benchArray,litsAndSubst);
      Ddi_BddarrayAppend(benchArray,Ddi_BddReadComposeSubst(b));
      Ddi_Free(litsAndSubst);
    }

    //sprintf(filename, "%s_%d.bench", ddm->settings.aig.itpStore, ++benchCount);
    //Ddi_AigarrayNetStore(benchArray, filename, NULL, Pdtutil_Aig2BenchLocalId_c);

    sprintf(filename, "%s_%03d.aig", ddm->settings.aig.itpStore, ++benchCount);
    Ddi_AigarrayNetStoreAiger(benchArray, 0, filename);
    Ddi_Free(benchArray);
  }

  if (interpolant!=NULL && Ddi_BddSize(interpolant) > itpStructOdcTh ) {
    int iSize, np;
    if (0 && (partitionLits!=NULL)) {
      
      Ddi_Bdd_t *itpPart = Ddi_AigDisjDecompWithVars(interpolant,
						     partitionLits);
      int nv = Ddi_BddarrayNum(partitionLits);
      np = Ddi_BddPartNum(itpPart);
      for (i=0; i<np; i++) {
	int j;
	Ddi_Bdd_t *p_i = Ddi_AigPartitionTop(Ddi_BddPartRead(itpPart,i),0);
	if (Ddi_BddPartNum(p_i) <= nv+1) {
	  for (j=0; j<Ddi_BddPartNum(p_i); j++) {
	    Ddi_Bdd_t *p_i_j = Ddi_BddPartRead(p_i,j);
	    if (Ddi_BddSize(p_i_j)>itpStructOdcTh/np)
	      Ddi_AigStructRedRemAcc (p_i_j,NULL);
	  }
	}
	else {
	  Ddi_BddSetAig(p_i);
	  Ddi_AigStructRedRemAcc (p_i,NULL);
	}
	Ddi_BddPartWrite(itpPart,i,p_i);
	Ddi_Free(p_i);
      }      
      Ddi_BddSetAig(itpPart);
      Ddi_DataCopy(interpolant,itpPart);
      Ddi_Free(itpPart);
    }
    Ddi_AigStructRedRemAcc (interpolant,NULL);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMed_c,
      printf("TOT aig after struct rr: %d)\n", Ddi_MgrReadAigNodesNum(ddm))
    );
    Ddi_AigStructRedRemByOdcChainAcc (interpolant,1);
    Ddi_AigStructRedRemByOdcChainAcc (interpolant,0);
    Ddi_NnfClustSimplifyAcc(interpolant,
                            ddm->settings.aig.itpNoQuantify>0);
    iSize = Ddi_BddSize(interpolant);
    if (0 && itpCoreTh>0 && (iSize > itpCoreTh)) {
      DdiAigRedRemovalAcc(interpolant, optCare, 
			iSize/20, cpuTime*3);
      Pdtutil_Assert(1||!Ddi_AigSatAnd(interpolant, b, optCare), 
		     "error in NNF const reduction"); 
      if (0 && (Ddi_BddSize(interpolant)<iSize*0.95)) {
	/* effect negligible */
	DdiAigRedRemovalAcc(interpolant, optCare, 
			iSize/20, cpuTime*3);
      }
    }
    //    Ddi_NnfIteSimplifyAcc(interpolant);
    //    iSize = Ddi_BddSize(interpolant);
  }

  if (interpolant!=NULL && ddm->settings.aig.itpAbortTh<-1 &&
      Ddi_BddSize(interpolant) > -ddm->settings.aig.itpAbortTh) {
    Ddi_Free(interpolant);
  }

#if 0
  // disabled - option used for partial exist
  if ((itpTwiceTh > 0) && (interpolant != NULL) &&
      (Ddi_BddSize(interpolant) > itpTwiceTh)) {
    int mySat, itpAbortTh = ddm->settings.aig.itpAbortTh;
    int myItpAigCore = ddm->settings.aig.itpAigCore;
    Ddi_Bdd_t *newB = Ddi_BddNot(interpolant);
    Ddi_Free(interpolant);
    ddm->settings.aig.itpTwice = 0;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("ITP twice\n");
    }
    // negative for early check
    ddm->settings.aig.itpAbortTh = -Ddi_BddSize(newB);
    ddm->settings.aig.itpAigCore = 0;
    interpolant = Ddi_AigSatAndWithInterpolant (a,newB,
       NULL,NULL,optCare,NULL,NULL,NULL,&mySat,0,0,2*itpSatTime/1000.0);
    ddm->settings.aig.itpAbortTh = itpAbortTh;
    ddm->settings.aig.itpTwice = itpTwiceTh;
    ddm->settings.aig.itpAigCore = myItpAigCore;
    Pdtutil_Assert(interpolant==NULL||!mySat,"error recomputing itp");
    if ((interpolant==NULL) ||
        (Ddi_BddSize(newB)<Ddi_BddSize(interpolant))) {
      Ddi_Free(interpolant);
      interpolant = Ddi_BddNot(newB);
    }
    else {
      //      itpCoreTh = 0;
    }
    Ddi_Free(newB);
  }
#endif

  if (forcePart || interpolant != NULL)
  {
    int size0, size1, size2, sizeLast, sizeOK;
    Ddi_Varset_t *supp = interpolant != NULL ? Ddi_BddSupp(interpolant) : NULL;
    int bddSizeLimit=500000;
    int sizeTh = (!itpPart || (itpIteOptTh < itpPartTh/2)) ?
      itpIteOptTh : itpPartTh/2;
    //    Pdtutil_Assert(Ddi_AigSat(interpolant),"ZERO interpolant");
    nSuppVars = supp!=NULL ? Ddi_VarsetNum(supp): 0;
    Ddi_Free(supp);

    if (enItpBddOpt) {
      if (nSuppVars > 60*optLevel) enItpBddOpt = 0;
    }

    do {

      int sizeBIG = 100000000;
      int itpSizeOptTh = itpPartTh;
      int abcDone = 0;
      if (!forcePart) {

      if (nSuppVars < 60) {
	itpSizeOptTh /= 2;
      }

      if ((size0=Ddi_BddSize(interpolant)) > 20000 && size0<50000) {
        ddiAbcOptAcc (interpolant,-1);
	abcDone = 1;
	//	Ddi_AigSift(interpolant,optCare);
      }

      size0 = size2 = Ddi_BddSize(interpolant);
      sizeOK = 0;
      sizeOK |= nSuppVars < 30 && Ddi_BddSize(interpolant) < sizeTh*2;
      sizeOK |= nSuppVars < 60 && Ddi_BddSize(interpolant) < sizeTh;
      sizeOK |= nSuppVars < 120 && Ddi_BddSize(interpolant) < sizeTh;
      sizeOK |= Ddi_BddSize(interpolant) < sizeTh;
      sizeOK |= itpPart && (Ddi_BddSize(interpolant) <= itpSizeOptTh);

      }

      if (!forcePart && !undefined && (sizeOK || !itpPart)) {
	int bddDone = 0;
	size1=Ddi_BddSize(interpolant);
	if (0&&Ddi_BddSize(interpolant) < 300000) {
	  Ddi_AigOptTop(interpolant,0,1);
	}
	if ((size1=Ddi_BddSize(interpolant)) > 20000) {
	  abcDone || ddiAbcOptAcc (interpolant,-1);
	  size2=Ddi_BddSize(interpolant);
	  size1=Ddi_BddSize(interpolant);
	}
        Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
  	  fprintf(stdout, "itp opt: %d -> %d\n", size0, size2));

	if (0) {
	  Ddi_Bddarray_t *benchArray;
	  char filename[100];
	  sprintf(filename, "itpOptC%02d.bench", benchCount);
	  fprintf(dMgrO(ddm),"ITP #: %d\n", benchCount++);
	  benchArray = Ddi_BddarrayAlloc(ddm, 0);
	  //	      Ddi_BddarrayInsertLast(benchArray, a);
	  //	      Ddi_BddarrayInsertLast(benchArray, b);
	  Ddi_BddarrayInsertLast(benchArray, interpolant);
	  if (0 && (optCare != NULL)) {
	    Ddi_BddarrayInsertLast(benchArray, optCare);
	  } else {
	    optCare = Ddi_BddMakeConstAig(ddm, 1);
	    Ddi_BddarrayInsertLast(benchArray, optCare);
	    Ddi_Free(optCare);
	    optCare = NULL;
	  }
	  Ddi_AigarrayNetStore(benchArray,
			       filename, NULL, Pdtutil_Aig2BenchLocalId_c);
	  Ddi_Free(benchArray);
	}

	bddDone = 0;
	if (enItpBddOpt) {
	  bddDone = Ddi_AigOptByBdd(interpolant,timeLimit/5,bddSizeLimit) > 0;
	}
	if (!bddDone && !itpPart && size1 > itpIteOptTh &&
                  ddm->settings.aig.enBddFoConOpt) {
	  Ddi_AigOptByFoCntTop(interpolant, NULL, 0);
	}

	size2=Ddi_BddSize(interpolant);
      }

      if (!forcePart && itpPart && size2 > itpSizeOptTh && size2 < 3000000) {
	  int bddDone = 0;
	  fprintf(dMgrO(ddm),"try opt: %d -> %d\n", size0,
            Ddi_BddSize(interpolant));
	  abcDone || DdiAigRedRemovalAcc (interpolant,optCare,-1,60.0);
	  if (enItpBddOpt) {
  	    bddDone = Ddi_AigOptByBdd(interpolant,timeLimit/5,bddSizeLimit)>0;
	  }
	  if (!bddDone && ddm->settings.aig.enBddFoConOpt) {

	    if (0) {
	      Ddi_Bddarray_t *benchArray;
	      char filename[100];
	      sprintf(filename, "itpOptB%s.%02d.bench", ddm->name, benchCount);
	      fprintf(dMgrO(ddm),"ITP #: %d\n", benchCount++);
	      benchArray = Ddi_BddarrayAlloc(ddm, 0);
     	      Ddi_BddarrayInsertLast(benchArray, a);
      	      Ddi_BddarrayInsertLast(benchArray, b);
	      Ddi_BddarrayInsertLast(benchArray, interpolant);
	      if (1 && (optCare != NULL)) {
		Ddi_BddarrayInsertLast(benchArray, optCare);
	      } else {
		optCare = Ddi_BddMakeConstAig(ddm, 1);
		Ddi_BddarrayInsertLast(benchArray, optCare);
		Ddi_Free(optCare);
		optCare = NULL;
	      }
	      Ddi_AigarrayNetStore(benchArray,
                filename, NULL, Pdtutil_Aig2BenchLocalId_c);
	      Ddi_Free(benchArray);
	    }

	    Ddi_AigOptByFoCntTop(interpolant, NULL, 0);
	  }

	  size2=Ddi_BddSize(interpolant);

	  if (0&&size2 > 3*itpSizeOptTh) {
	    Ddi_Bdd_t *a2, *b2, *i0;
	    if (enItpTernary) {
	      Ddi_Varset_t *abstrB = Ddi_BddSupp(b);
	      Ddi_Varset_t *abstrA = Ddi_BddSupp(a);
	      Ddi_Varset_t *smA = Ddi_BddSupp(a);
	      Ddi_Varset_t *suppA = NULL;
	      Ddi_VarsetSetArray(abstrA);
	      Ddi_VarsetSetArray(abstrB);
	      Ddi_VarsetSetArray(smA);
	      Ddi_VarsetDiffAcc(smA,abstrB);
              a2 = DdiAigTernaryInterpolantByGroupsAcc (a,b,abstrA,smA,
		      NULL,optCare,200,2,timeLimit);
	      suppA = Ddi_BddSupp(a2);
	      Ddi_VarsetSetArray(suppA);
	      Ddi_VarsetDiffAcc(abstrB,suppA);
	      Ddi_Free(suppA);
              b2 = DdiAigTernaryInterpolantByGroupsAcc (b,a2,abstrB,abstrB,
		      NULL,optCare,200,2,timeLimit);
	      Ddi_Free(abstrA);
	      Ddi_Free(abstrB);
	      Ddi_Free(smA);
	    }
	    else {
	      a2 = DdiAigFuncDepAcc (a, NULL, globalVars,
	        NULL , NULL, NULL, NULL, NULL , NULL);
	      b2 = Ddi_BddDup(b);
	    }
	    if (!Ddi_AigSatAnd(a2,b2,optCare)) {
	      i0 = Ddi_AigSatAndWithInterpolant (a2,b2,globalVars,NULL,
				   optCare,NULL,NULL,implArray,psat,0,itpOdc,timeLimit);
	      if (Ddi_BddSize(i0)<size2) {
	        Ddi_Free(interpolant);
	        interpolant = i0;
	      }
	      else {
	        Ddi_Free(i0);
	      }
	    }
	    else {
	      Ddi_Bddarray_t *benchArray;
	      char filename[100];
	      sprintf(filename, "itpOptB%02d.bench", benchCount);
	      benchArray = Ddi_BddarrayAlloc(ddm, 0);
	      Ddi_BddarrayInsertLast(benchArray, a);
	      Ddi_BddarrayInsertLast(benchArray, b);
	      if (optCare != NULL) {
		Ddi_BddarrayInsertLast(benchArray, optCare);
	      } else {
		optCare = Ddi_BddMakeConstAig(ddm, 1);
		Ddi_BddarrayInsertLast(benchArray, optCare);
		Ddi_Free(optCare);
		optCare = NULL;
	      }
	      Ddi_AigarrayNetStore(benchArray,
                filename, NULL, Pdtutil_Aig2BenchLocalId_c);
	      Ddi_Free(benchArray);
	    }
	    Ddi_Free(a2);
	    Ddi_Free(b2);
            Ddi_Free(b2Part);
	  }
      }

      if (forcePart) {
	size2 = itpSizeOptTh+1; sizeOK = 0;
      }
      else {
	size2 = Ddi_BddSize(interpolant);
	if (undefined) {
	  size2 = sizeBIG;
	  sizeOK = 0;
	}
      }
      if (doSatPart && itpPart && !sizeOK && size2 > itpSizeOptTh) {
	Ddi_Bdd_t *bb0 = Ddi_BddDup(b);
	Ddi_Bdd_t *iTot = Ddi_BddMakeConstAig(ddm,1);
	Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm,1);
	Ddi_Varset_t *suppB = Ddi_BddSupp(b);
	Ddi_Varset_t *suppA = Ddi_BddSupp(a);
	int j, endPart=0;
	int sizeB = Ddi_BddSize(b);
	int sizep, size0 = (undefined||forcePart) ?
	  sizeBIG : Ddi_BddSize(interpolant);
	int maxi, nv, cexAbstr = 1;
	float smRatio = 0.95, smRatio0 = smRatio;

        Ddi_Bddarray_t *substF = Ddi_BddarrayAlloc(ddm,0);
        Ddi_Vararray_t *substV = Ddi_VararrayAlloc(ddm,0);
        Ddi_Vararray_t *varsA = Ddi_VararrayMakeFromVarset(globalVars,1);
        Ddi_AigStructRedRemAcc (b,NULL);
        Ddi_Bdd_t *bPart = Ddi_AigPartitionTop(b,0);
        Ddi_BddPartSortBySizeAcc(bPart, 0);
        //        b = Ddi_BddPartRead(bPart,0);
#if 0
        Ddi_Bdd_t *splitB = Ddi_BddSplitShortEdges (b,myCare,varsA,
                                                substF,substV,0.5);

        Ddi_Bdd_t *tot = Ddi_BddCompose(splitB,substV,substF);
        Pdtutil_Assert(Ddi_AigEqualSat(tot,b),"error in split");
        Ddi_Free(tot);

        for (j=0; j<3; j++) {
          Ddi_Bddarray_t *substF2 = Ddi_BddarrayAlloc(ddm,0);
          Ddi_Vararray_t *substV2 = Ddi_VararrayAlloc(ddm,0);
          Ddi_Bddarray_t *splitB2 = Ddi_BddarraySplitShortEdges (
                               substF,myCare,varsA,substF2,substV2,0.5);
          Ddi_BddComposeAcc(splitB,substV,splitB2);
          Ddi_Free(substF);
          Ddi_Free(substV);
          substF = substF2;
          substV = substV2;

          Ddi_Bdd_t *tot = Ddi_BddCompose(splitB,substV,substF);
          Pdtutil_Assert(Ddi_AigEqualSat(tot,b),"error in split");
          Ddi_Free(tot);
        }
        //                                        substF,substV,0,1,0.5);
        if (1) {
          int j;
          for (j=0; j<Ddi_BddarrayNum(substF); j++) {
            printf("[%d] - %s -> %d\n", j,
                   Ddi_VarName(Ddi_VararrayRead(substV,j)),
                   Ddi_BddSize(Ddi_BddarrayRead(substF,j)));
          }
        }
        if (1) {
          Ddi_Bddarray_t *substF2 = Ddi_BddarrayAlloc(ddm,0);
          Ddi_Vararray_t *substV2 = Ddi_VararrayAlloc(ddm,0);
          Ddi_Vararray_t *varsA2 = Ddi_VararrayUnion(varsA,substV);
          Ddi_Bdd_t *splitB2 = Ddi_BddSplitMinCut (splitB,myCare,varsA,
                                                substF2,substV2,0,1,0.5);
          Ddi_BddarrayComposeAcc(substF2,substV,substF);
          Ddi_Bdd_t *tot = Ddi_BddCompose(splitB2,substV,substF);
          Ddi_BddComposeAcc(tot,substV2,substF2);
          Pdtutil_Assert(Ddi_AigEqualSat(tot,b),"error in split");
          Ddi_Free(varsA2);
          Ddi_Free(tot);
        }
        Ddi_Free(bPart);

#else
#if 1
        Ddi_Bdd_t *splitB = NULL;
        if (Ddi_BddReadComposeF(b)!=NULL) {
          splitB = Ddi_BddDup(Ddi_BddReadComposeF(b));
          substF = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(b));
          substV = Ddi_VararrayDup(Ddi_BddReadComposeVars(b));
        }
#else
        Ddi_Bdd_t *splitB = Ddi_AigSplitByCut (b,myCare,varsA,
                                             substF,substV,0.5);
#endif
#endif
        Ddi_Bdd_t *splitCare = Ddi_BddMakeConstAig(ddm,1);
        Ddi_Bdd_t *prefixB = Ddi_BddRelMakeFromArray(substF,substV);
        Ddi_Varset_t *splitVars = Ddi_VarsetMakeFromArray(substV);

#if 1
	char **filterVarNames = NULL;
#else
	static char *filterVarNames[] = {
          // "signal0000021C",
	  "signal000001B0_normalized",
	  "signal000004C2_normalized",
	  "signal000004C3_normalized",
	  "signal00000370_normalized",
	  "signal00000439_normalized",
	  "signal00000375_normalized",
	  NULL
	};
#endif

	if (0) {
	  Ddi_VarsetDiffAcc(suppB,suppA);
	  Ddi_VarsetIntersectAcc(suppB,globalVars);
	}
	else {
	  if (filterVarNames==NULL)
	    Ddi_VarsetDiffAcc(suppB,globalVars);
	}

	vA = Ddi_VararrayMakeFromVarset(suppB,1);
	Ddi_Free(suppB);
        Ddi_Free(suppA);

	if (filterVarNames != NULL) {
	  //	  int filterVarLen = strlen(filterVarName);

	  for (j=Ddi_VararrayNum(vA)-1; j>=0; j--) {
	    int found = 0, k;
	    Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
	    for (k=0; filterVarNames[k]!=NULL; k++) {
	      if (strstr(Ddi_VarName(v),filterVarNames[k])!=NULL) {
		found = 1;
		break;
	      }
	    }
	    if (!found) {
	      Ddi_VararrayRemove(vA,j);
	    }
	  }
	}

        nv = Ddi_VararrayNum(vA);
	maxi = satPartSmoothRatio*nv;

	if (optCare != NULL) {
	  Ddi_BddAndAcc(myCare,optCare);
	}


	for (j=endPart=0; !endPart; j++) {
	  Ddi_Varset_t *supp;
	  Ddi_Bdd_t *i0, *bb = Ddi_BddDup(bb0);
	  int eqConstr = 0;
	  int itpPartRecur = 0;
	  int mysat, careHit = 0;
	  Ddi_Bdd_t *wCube=NULL;
	  Ddi_Bdd_t *myWindow = Ddi_BddMakeConstAig(ddm,0);
          Ddi_Bdd_t *careWithPrefix = NULL;

	  if (maxi>nv) maxi = nv;
	  if (j>satPartMaxPart) {
	    endPart = 1;
	    eqConstr = 1;
	    itpPartRecur = 3; /* enable FWD part */
	  }
	  else {
            Ddi_Bdd_t *splitSubst;
	    Ddi_Varset_t *sm = Ddi_VarsetVoid(ddm);
	    Ddi_VarsetSetArray(sm);
	    for (i=0; i<maxi; i++) {
	      int j = nv-i-1;
	      Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
	      Ddi_VarsetAddAcc(sm,v);
	    }
#if 0
            Ddi_Free(bb);
            careWithPrefix = Ddi_BddDup(prefixB);
            Ddi_BddPartInsertLast(careWithPrefix,myCare);
            if (1) {
              Ddi_Bdd_t *itpUp, *itp;
              Ddi_MgrSetAigItpAbc(ddm,1);
              Ddi_Free(careWithPrefix);
              careWithPrefix = Ddi_BddDup(prefixB);
              Ddi_BddPartInsertLast(careWithPrefix,a);
              Ddi_BddAndAcc(splitB,myCare);

              itpUp = Ddi_AigSatAndWithInterpolant (
                   a,b,NULL,NULL,NULL,
	           NULL,NULL,NULL,&mysat,0,0,-1);
              Ddi_MgrSetAigItpAbc(ddm,itpAbc);
              if (itpUp!=NULL) {
                Ddi_BddNotAcc(itpUp);
                Ddi_BddComposeAcc(itpUp,substV,substF);
                itp = Ddi_AigSatAndWithInterpolant (
                   a,itpUp,NULL,NULL,NULL,
	           myCare,NULL,NULL,&mysat,0,0,-1);

                Ddi_Free(itpUp);
                Ddi_Free(splitSubst);
              }
              else {
                careHit=1;
              }
            }
            else do {
              Ddi_Bdd_t *refineCareSplit;
              splitSubst = Ddi_AigSatCore(splitB,splitCare,NULL,
					  splitVars,-1,-1,1,1);
              Ddi_BddSetAig(careWithPrefix);
              Ddi_MgrSetAigItpAbc(ddm,1);
              refineCareSplit = Ddi_AigSatAndWithInterpolant (
                   careWithPrefix,splitSubst,NULL,NULL,NULL,
	           NULL,NULL,NULL,&mysat,0,0,-1);
              Ddi_MgrSetAigItpAbc(ddm,itpAbc);
              if (refineCareSplit!=NULL) {
                Ddi_BddAndAcc(splitCare,refineCareSplit);
                Ddi_Free(refineCareSplit);
                Ddi_Free(splitSubst);
              }
              else {
                careHit=1;
              }
            } while (!careHit);
            Ddi_Free(careWithPrefix);
            Pdtutil_Assert(Ddi_AigSatAnd(splitSubst,splitCare,0),
                           "SAT required");
            bb = Ddi_BddCompose(splitSubst,substV,substF);
            Ddi_Free(myWindow);
            myWindow = Ddi_BddMakeConstAig(ddm,1);
#else
            Ddi_AigExistAllSolutionAcc(bb,sm,myCare,myWindow,1);
#endif
	    Ddi_Free(sm);
	  }
	  if (Ddi_BddIsZero(bb)) {
	    endPart = 1;
	    fprintf(dMgrO(ddm),"partitioned interpolant ended\n");
	  }
	  else {
	    Ddi_Bdd_t *aa = Ddi_BddDup(a);
	    Ddi_Bdd_t *bb1 = Ddi_BddDup(bb);
	    Ddi_Bdd_t *w = NULL;
	    if (filterVarNames != NULL) {
	      w = Ddi_BddExistProject(myWindow,globalVars);
	      Ddi_AigConstrainCubeAcc(aa,w); /* CUBE */
	      Ddi_BddNotAcc(w);
	    }
	    fprintf(dMgrO(ddm),"partition %d - size: %d/%d\n", j,
		    Ddi_BddSize(bb), sizeB);
	    if (!endPart) {
	      Ddi_AigAndCubeAcc(bb1,myWindow);
	    }
	    i0 = Ddi_AigSatAndWithInterpolant (aa,bb1,globalVars,NULL,NULL,
	           /*myCare*/optCare,NULL,implArray,
		   &mysat,itpPartRecur,itpOdc,-1/*timeLimit*/);
	    if (i0==NULL) {
	      //	      maxi /= smRatio0;
	      smRatio = 1.0;
	      if (mysat==1) {
		*psat=1;
		endPart=1;
		Ddi_Free(iTot);
	      }
	      else if (mysat==-1) {
		/* undefined */
		/* speculate UNSAT */
		*psat=-1;
	      }
	    }
	    else {
	      int sat;
	      if (1 && itpCoreTh>0 && (Ddi_BddSize(i0)>itpCoreTh/20)) {
		Ddi_AigOptByMonotoneCoreAcc (i0,aa,optCare,1,-1.0);
	      }
	      if (1 && itpCoreTh>0 && (Ddi_BddSize(i0)>itpCoreTh/5)) {
		Ddi_AigOptByMonotoneCoreAcc (i0,bb1,optCare,0,-1.0);
	      }
	      if (w!=NULL) {
		Ddi_BddOrAcc(i0,w);
	      }
#if 0
	      Ddi_Free(bb);
	      bb = Ddi_BddAnd(b,myCare);
	      Ddi_AigOptByBddSweepTop(bb,i0,2);
	      Ddi_BddAndAcc(bb,i0);
	      sat = Ddi_AigSatMinisatWithAbortAndFinal (bb, myWindow, -1, 0);
	      Pdtutil_Assert(!sat,"UNSAT required for final core");
#endif
	      supp = Ddi_BddSupp(i0);
	      fprintf(dMgrO(ddm),"size: %d - supp: %d\n\n",
		   Ddi_BddSize(i0), Ddi_VarsetNum(supp));
              //              Ddi_VarsetPrint(supp,0,0,stdout);
              //              if (Ddi_BddSize(i0) < 10) {
              //                DdiLogBdd(i0,0);
              //              }
	      Ddi_BddAndAcc(iTot,i0);
	      Ddi_BddAndAcc(myCare,i0);
#if 0
	      Ddi_BddDiffAcc(bb0,myWindow);
#endif
	      Ddi_Free(supp);
	      Ddi_Free(i0);
	      if (mysat==-2) {
		/* underapprox */
		*psat=-2;
	      }
	      if (cexAbstr) {
		Ddi_Varset_t *coreVars = Ddi_BddSupp(myWindow);
		Ddi_Free(vA);
		vA = Ddi_VararrayMakeFromVarset(coreVars,1);
		Ddi_Free(coreVars);
		nv = Ddi_VararrayNum(vA);
		if (nv<maxi) maxi = nv;
	      }
	    }
	    Ddi_Free(bb1);
	    Ddi_Free(aa);
	    Ddi_Free(w);
	    if (!cexAbstr) {
	      maxi *= smRatio;
	    }
	  }
	  Ddi_Free(myWindow);
	  Ddi_Free(bb);
	}

        //        Ddi_BddAndAcc(prefix,myCare);

        Ddi_Free(splitCare);
        Ddi_Free(prefixB);
        Ddi_Free(varsA);
        Ddi_Free(splitB);
        Ddi_Free(substF);
        Ddi_Free(substV);

	Ddi_Free(bb0);
	Ddi_Free(vA);
	Ddi_Free(myCare);

	if (iTot!=NULL) {
	  sizep = Ddi_BddSize(iTot);
	  if (sizep < size0) {
	    if (interpolant==NULL) {
	      interpolant=Ddi_BddDup(iTot);
	    }
	    else {
	      Ddi_DataCopy(interpolant,iTot);
	    }
	  }
	  Ddi_Free(iTot);
	}
	if (interpolant != NULL && checkInterpolant && !undefined) {
	  Ddi_BddSetAig(a2);
	  Ddi_Bdd_t *tmp = Ddi_BddDiff(a2,interpolant);
	  Pdtutil_Assert(!Ddi_AigSat(tmp), "invalid interpolant (A)");
	  Ddi_Free(tmp);
	  tmp = Ddi_BddAnd(interpolant,b2);
	  Pdtutil_Assert(!Ddi_AigSat(tmp), "invalid interpolant");
	  Ddi_Free(tmp);
	}

      }
      else if (doSatPart2 && itpPart && !sizeOK && size2 > itpSizeOptTh) {
	Ddi_Bdd_t *iTot = Ddi_BddMakeConstAig(ddm,0);
	Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm,1);
	Ddi_Varset_t *suppA = Ddi_BddSupp(a);
	int j, endPart=0;
	int sizeA = Ddi_BddSize(a);
	int sizep, size0 = (undefined||(interpolant==NULL)) ?
	  sizeBIG : Ddi_BddSize(interpolant);
	int maxi, nv;
	float smRatio = 0.95, smRatio0 = smRatio, filter=1.0, filter2=1.0;
	Ddi_Bdd_t *aa0 = Ddi_BddMakeAig(a2);
	Ddi_Varset_t *coreVars = Ddi_VarsetVoid(ddm);

	if (0 && prevItp!=NULL) {
	  Ddi_BddOrAcc(iTot,prevItp);
	  Ddi_BddDiffAcc(myCare,prevItp);
	  Pdtutil_Assert(!Ddi_AigSatAnd(iTot,b,optCare),"wrong prev itp");
	}
	if (domainVars != NULL) {
      	  Ddi_VarsetIntersectAcc(suppA,domainVars);
	  //      	  Ddi_VarsetDiffAcc(suppA,domainVars);
	  //      	  Ddi_VarsetDiffAcc(suppA,globalVars);
	  //      	  Ddi_VarsetIntersectAcc(suppA,globalVars);
	}
	else {
	  Ddi_VarsetDiffAcc(suppA,globalVars);
	}
	vA = Ddi_VararrayMakeFromVarset(suppA,1);

        nv = Ddi_VararrayNum(vA);
	maxi = satPartSmoothRatio*nv;

	if (0&&optCare != NULL) {
	  Ddi_BddAndAcc(myCare,optCare);
	}

	for (j=endPart=0; !endPart; j++) {
	  Ddi_Varset_t *supp;
	  Ddi_Bdd_t *i0, *bb = Ddi_BddDup(b);
	  Ddi_Bdd_t *aa = Ddi_BddDup(aa0);
	  int eqConstr = 0;
	  int mysat;
	  Ddi_Bdd_t *myWindow = Ddi_BddMakeConstAig(ddm,0);
	  if (maxi>nv) maxi = nv;
	  if (j>satPartMaxPart) {
	    endPart = 1;
	    //	    eqConstr = 1;
	  }
	  else if (1) {
	    int k, sat1=1, jj=0;
	    int minv=16, currv=0, cnt=2*minv;
	    Ddi_Varset_t *sm = Ddi_VarsetDup(suppA);
	    Ddi_Bdd_t *careCare = Ddi_BddDup(myCare);
	    Ddi_Free(myWindow);
	    myWindow = Ddi_BddMakeConstAig(ddm,1);
	    do {
	      Ddi_Bdd_t *myConstr = NULL;

	      myConstr = Ddi_AigSatAndWithCexAndAbort(aa0,careCare,
						      NULL,NULL,-1.0,NULL);

	      if (myConstr==NULL) {
		if (jj==0) {
		  Ddi_Free(aa);
		  aa = Ddi_BddMakeConstAig(ddm,0);
		}
		else {
		  Pdtutil_Assert(0,"error");
		}
		break;
	      }
	      jj++;
	      Ddi_Bdd_t *wPart0 = Ddi_AigPartitionTop(myConstr,0);
	      Ddi_Bdd_t *wPart = Ddi_BddMakePartConjVoid(ddm);
	      Ddi_Bdd_t *aaPlus = Ddi_BddAnd(aa0,myCare);
	      for (k=0; k<Ddi_BddPartNum(wPart0); k++) {
		Ddi_Bdd_t *w_i = Ddi_BddPartRead(wPart0,k);
		Ddi_Var_t *v_i = Ddi_BddTopVar(w_i);
		if (!Ddi_VarInVarset(sm,v_i)) continue;
		Ddi_BddNotAcc(w_i);
		Ddi_BddPartInsertLast(wPart,w_i);
	      }
	      Ddi_Free(wPart0);
	      Ddi_BddSetAig(wPart);
	      sat1 = Ddi_AigSatMinisatWithAbortAndFinal (aaPlus, wPart, -1, 0);
	      if (!sat1) {
		Ddi_Varset_t *wSupp = Ddi_BddSupp(wPart);
		Ddi_BddExistProjectAcc(myConstr,wSupp);
		Ddi_BddAndAcc(myWindow,myConstr);
		Ddi_BddAndAcc(careCare,myConstr);
		//Pdtutil_Assert(Ddi_AigSatAnd(aa0,careCare,NULL),
		//"sat needed");
		currv += Ddi_VarsetNum(wSupp);
		Ddi_VarsetDiffAcc(sm,wSupp);
		Ddi_Free(wSupp);
	      }
	      Ddi_Free(myConstr);
	      Ddi_Free(aaPlus);
	      Ddi_Free(wPart);
	      cnt--;
	    } while ((currv < minv) && cnt>0);
	    Ddi_Free(careCare);
	    Ddi_Free(sm);
	  }
	  else {
	    Ddi_Varset_t *sm = Ddi_VarsetVoid(ddm);
	    Ddi_VarsetSetArray(sm);
	    for (i=0; i<maxi; i++) {
	      int j = i;
	      Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
	      char *name = Ddi_VarName(v);
	      float r = (float)rand()/((float)RAND_MAX);
	      if (!Ddi_VarInVarset(coreVars,v)) {
		if (r>filter) continue; // filter out var
	      }
	      else {
		if (r>filter2) continue; // filter out var
	      }
	      if (0 && v!=NULL && (strstr(name,"Interpolant")!=NULL)) {
		/* skip PI var */
		continue;
	      }
	      Ddi_VarsetAddAcc(sm,v);
	    }
	    Ddi_AigExistAllSolutionAcc(aa,sm,myCare,myWindow,1);
	    Ddi_Free(sm);
	  }
	  if (Ddi_BddIsZero(aa)) {
	    endPart = 1;
	    fprintf(dMgrO(ddm),"FWD partitioned interpolant ended\n");
	  }
	  else {
	    Ddi_Bdd_t *eq=NULL;
	    Ddi_Bdd_t *aa1 = Ddi_BddDup(aa0);
	    Ddi_Bdd_t *bb1 = Ddi_BddDup(bb);
	    fprintf(dMgrO(ddm),"FWD partition %d - size: %d/%d\n",
               j, Ddi_BddSize(aa), sizeA);
	    if (eqConstr) {
	      eq = DdiAigEquivVarsAcc(aa1,myCare,NULL,globalVars,bb,NULL,NULL);
	    }
	    //	    Ddi_BddAndAcc(aa1,myCare);
	    if (1 && !endPart) {
	      Ddi_AigAndCubeAcc(aa1,myWindow);
	      //	      Ddi_AigAndCubeAcc(bb1,myWindow);
	    }
	    i0 = Ddi_AigSatAndWithInterpolant (aa1,bb,globalVars,NULL,NULL,
		 optCare,NULL,implArray,&mysat,0,itpOdc,-1/*timeLimit*/);
	    if (i0==NULL) {
	      Ddi_Free(iTot);
	      endPart = 1;

      	      maxi /= smRatio0;
	      smRatio = 1.0;
	      if (mysat==-1) {
		/* undefined */
		/* return UNDERAPPROX */
		*psat = -2;
		endPart = 1;
	      }
	    }
	    else {
	      int sat;
	      //	      Ddi_AigAndCubeAcc(i0,myWindow);
	      if (1 && itpCoreTh>0 && (Ddi_BddSize(i0)>itpCoreTh/20)) {
		Ddi_AigOptByMonotoneCoreAcc (i0,aa0,optCare,1,-1.0);
	      }
	      Ddi_Free(aa);
	      aa = Ddi_BddAnd(aa0,myCare);
	      Ddi_BddDiffAcc(aa,i0);
	      sat = Ddi_AigSatMinisatWithAbortAndFinal (aa, myWindow, -1, 0);
	      Pdtutil_Assert(!sat,"UNSAT required for final core");
	      supp = Ddi_BddSupp(i0);
	      fprintf(dMgrO(ddm),"size: %d - supp: %d\n\n",
		   Ddi_BddSize(i0), Ddi_VarsetNum(supp));
	      if (eq!=NULL) {
		Ddi_BddAndAcc(i0,eq);
	      }
	      Ddi_BddOrAcc(iTot,i0);
	      Ddi_BddDiffAcc(myCare,i0);
	      Ddi_BddDiffAcc(aa0,myWindow);
	      Ddi_Free(supp);
	      supp = Ddi_BddSupp(myWindow);
	      Ddi_VarsetUnionAcc(coreVars,supp);
	      Ddi_Free(supp);
	      Ddi_Free(i0);
	    }
	    Ddi_Free(aa1);
	    Ddi_Free(bb1);
	    Ddi_Free(eq);
     	    filter *= smRatio0;
     	    filter *= smRatio0;
     	    filter2 *= smRatio0;
	  }
	  Ddi_Free(myWindow);
	  Ddi_Free(bb);
	  Ddi_Free(aa);
	}

	Ddi_Free(coreVars);
	Ddi_Free(aa0);
	Ddi_Free(vA);
	Ddi_Free(myCare);
	Ddi_Free(suppA);

	if (iTot!=NULL) {
	  sizep = Ddi_BddSize(iTot);
	  if (sizep < size0) {
	    if (interpolant == NULL) {
	      interpolant = Ddi_BddMakeConstAig(ddm,0);
	    }
	    Ddi_DataCopy(interpolant,iTot);
	  }
	  Ddi_Free(iTot);
	}
      }
      else if (doSatPart3 && itpPart && !sizeOK && size2 > itpSizeOptTh) {
	Ddi_Bdd_t *iTot = Ddi_BddMakeConstAig(ddm,0);
	Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm,1);
	int j, jj, mySat, endPart=0;
	int sizeA = Ddi_BddSize(a);
	int sizep, size0 = undefined ? sizeBIG : Ddi_BddSize(interpolant);
	int maxi, nv;
	FILE *fNames=fopen(splitVarFile,"r");
	Ddi_Vararray_t *vA = Ddi_VararrayAlloc(ddm,0);

	if (optCare!=NULL) Ddi_BddAndAcc(myCare,optCare);

	Pdtutil_Assert(fNames!=NULL,"file not open");

	for (jj=0; jj<3; jj++) {
	  char vname[200];
	  Ddi_Var_t *v;
	  fscanf(fNames,"%s",vname);
	  v=Ddi_VarFromName(ddm,vname);
	  Ddi_VararrayWrite(vA,jj,v);
	}
	fclose(fNames);

	for (j=0; j<8; j++) {
	  Ddi_Bdd_t *cube = Ddi_BddMakeConstAig(ddm,1);
	  Ddi_Bdd_t *i0, *bb = Ddi_BddDup(b);
	  Ddi_Bdd_t *aa = Ddi_BddDup(a);

	  for (jj=0; jj<3; jj++) {
	    int ph = (j>>jj)%2;
	    Ddi_Var_t *v=Ddi_VararrayRead(vA,jj);
	    Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,ph);
	    Ddi_BddAndAcc(cube,lit);
	    Ddi_Free(lit);
	  }
#if 1
	  Ddi_AigAndCubeAcc(aa,cube);
#else
	  Ddi_AigConstrainCubeAcc(aa,cube);
	  Ddi_AigConstrainCubeAcc(bb,cube);
#endif

	  i0 = Ddi_AigSatAndWithInterpolant (aa,bb,globalVars,NULL,
		 myCare,NULL,NULL,implArray,&mySat,0,itpOdc,-1/*timeLimit*/);
	  if (i0==NULL) {
	    if (mySat==-1) {
	      /* undefined */
	      /* return UNDERAPPROX */
	      *psat = -2;
	    }
	  }
	  else {
	    supp = Ddi_BddSupp(i0);
	    fprintf(dMgrO(ddm),"size: %d - supp: %d\n\n",
		   Ddi_BddSize(i0), Ddi_VarsetNum(supp));
	    //	    Ddi_BddAndAcc(i0,cube);
	    Ddi_BddOrAcc(iTot,i0);
	    Ddi_BddDiffAcc(myCare,i0);
	    Ddi_BddDiffAcc(myCare,cube);
	    Ddi_Free(supp);
	    Ddi_Free(i0);
	  }
	  Ddi_Free(cube);
	  Ddi_Free(bb);
	  Ddi_Free(aa);
	}

	Ddi_Free(vA);
	Ddi_Free(myCare);

	sizep = Ddi_BddSize(iTot);
	if (sizep < size0) {
	  Ddi_DataCopy(interpolant,iTot);
	}
	Ddi_Free(iTot);

      }
      else if (1 && itpPart && !sizeOK && size2 > itpSizeOptTh) {
	Ddi_Bdd_t *i0, *bb = Ddi_AigPartitionTop(b,1);
	int sizep, size0 = (undefined||forcePart) ? sizeBIG :
	  Ddi_BddSize(interpolant);
	int np = Ddi_BddPartNum(bb);
	Ddi_Varset_t *supp;
	char name[100];
	if (np==1) {
	  Ddi_Bdd_t *bbAnd = Ddi_AigPartitionTop(b,0);
	  if (Ddi_BddPartNum(bbAnd)==2) {
	    Ddi_Bdd_t *b0 = Ddi_BddPartRead(bbAnd,0);
	    Ddi_Bdd_t *b1 = Ddi_BddPartRead(bbAnd,1);
	    if (Ddi_BddSize(b1)==1) {
	      Ddi_Bdd_t *t = b0; b0 = b1; b1 = t;
	    }
	    if (Ddi_BddSize(b0)==1) {
	      int k;
	      Ddi_Free(bb);
	      bb = Ddi_AigPartitionTop(b1,1);
	      np = Ddi_BddPartNum(bb);
	      for (k=0; k<np; k++) {
		Ddi_BddAndAcc(Ddi_BddPartRead(bb,k),b0);
	      }
	    }
	  }
	  Ddi_Free(bbAnd);
	}
	if (np>1) {
	  Ddi_Bdd_t *iTot = Ddi_BddMakeConstAig(ddm,1);
	  int k, max=1;
	  int mysat;
	  int endPart=0;
          Ddi_Bdd_t *myCare = optCare;
	  Ddi_Bdd_t *monoInterpolant = interpolant;
	  fprintf(dMgrO(ddm),
		  "Using partitioned Interpolant: %d * %d -> %d (#p=%d)\n",
		  Ddi_BddSize(a), Ddi_BddSize(b), size0, np);
#if 0
  	  sprintf(name,"itpStore_%d.bench",itpStoreId++);
          Ddi_AigNetStore (interpolant, (char *)name, NULL,
            Pdtutil_Aig2BenchName_c);
#endif
	  *psat = 0;
	  for (k=0; k<10 && !endPart && Ddi_BddPartNum(bb)>1; k++) {
	    int j, maxSize = -1, max_j=0;
	    Ddi_Bdd_t *b0;
	    /* extract largest/smallest part */
	    for (j=0; j<Ddi_BddPartNum(bb); j++) {
	      Ddi_Bdd_t *b_j = Ddi_BddPartRead(bb,j);
	      int size_j = Ddi_BddSize(b_j);
	      if (maxSize == -1 || (size_j > 100 &&
		 (max && (size_j > maxSize) || !max && (size_j < maxSize)))) {
		maxSize = size_j;
		max_j = j;
	      }
	    }
	    b0 = Ddi_BddPartExtract(bb,max_j);
	    if (0)
	      {
		Ddi_Bdd_t *aux = Ddi_BddMakeAig(bb);
		Ddi_BddDiffAcc(b0,aux);
		Ddi_Free(aux);
	      }
	    if (Ddi_AigSatAnd(b0,iTot,myCare)) {
	      fprintf(dMgrO(ddm),"partition %d/%d - ", k, np);
	      i0 = Ddi_AigSatAndWithInterpolant (a,b0,globalVars,NULL,
		   myCare,NULL,NULL,implArray,&mysat,0,itpOdc,-1/*timeLimit*/);
	      if (i0==NULL) {
		if (mysat==1) {
		  *psat=1;
		  endPart=1;
		  Ddi_Free(iTot);
		}
		else if (mysat==-1) {
		  /* undefined */
		  /* speculate UNSAT */
		  *psat=-1;
		}
	      }
	      else {
		supp = Ddi_BddSupp(i0);
		fprintf(dMgrO(ddm),"size: %d - supp: %d\n\n",
			Ddi_BddSize(i0), Ddi_VarsetNum(supp));
		//Ddi_VarsetPrint(supp,NULL,NULL,dMgrO(ddm));
		Ddi_Free(supp);
		Ddi_BddAndAcc(iTot,i0);
		Ddi_Free(i0);
	      }
	    }
	    else {
	      fprintf(dMgrO(ddm),"partition INCLUDED\n");
	      //	      k--;
	    }
	    Ddi_Free(b0);
	  }
	  Ddi_BddSetAig(bb);
	  if (iTot != NULL /*|| Ddi_BddSize(iTot) < 500*/) {
	    Ddi_Bdd_t *myCare = optCare;
	    interpolant = Ddi_AigSatAndWithInterpolant (a,bb,globalVars,NULL,
	      myCare,NULL,NULL,implArray,psat,0,itpOdc,-1/*timeLimit*/);
	    if (interpolant != NULL) {
	      fprintf(dMgrO(ddm),"Residual Interpolant result: %d * %d -> %d\n",
		 Ddi_BddSize(a), Ddi_BddSize(bb),
                 Ddi_BddSize(interpolant));
	      Ddi_BddAndAcc(interpolant,iTot);
	    }
	    else {
	      /* sat */
	      if (mysat==1) {
		*psat=1;
		endPart=1;
		Ddi_Free(iTot);
	      }
	      else if (mysat==-1) {
		/* undefined */
		/* speculate UNSAT */
		*psat=-1;
	      }
	    }
	  }
	  Ddi_Free(iTot);
	  if (interpolant != NULL) {
	    sizep = Ddi_BddSize(interpolant);
	    fprintf(dMgrO(ddm),
		    "Partitioned Interpolant result: %d * %d -> %d(%d)\n",
		 Ddi_BddSize(a), Ddi_BddSize(b),
                 sizep, size0);
	    if (monoInterpolant==NULL) {
	      monoInterpolant = Ddi_BddDup(interpolant);
	    }
	    supp = Ddi_BddSupp(monoInterpolant);
	    fprintf(dMgrO(ddm),"supp i: %d", Ddi_VarsetNum(supp));
	    Ddi_Free(supp);
	    supp = Ddi_BddSupp(interpolant);
	    fprintf(dMgrO(ddm)," - supp p: %d\n", Ddi_VarsetNum(supp));
	    //Ddi_VarsetPrint(supp,NULL,NULL,dMgrO(ddm));
	    Ddi_Free(supp);
	    if (sizep > size0) {
	      Ddi_DataCopy(interpolant,monoInterpolant);
	    }
	    Ddi_Free(monoInterpolant);
	  }
	}
	else {
	  interpolant = Ddi_AigSatAndWithInterpolant (a,b,globalVars,NULL,
	    optCare,NULL,NULL,implArray,psat,0,itpOdc,-1/*timeLimit*/);
	}
	Ddi_Free(bb);
      }
      if (0)  {
	int size2, size1;
	Ddi_Bdd_t *totAig = Ddi_BddMakeConstAig(ddm, 1);
	Ddi_Bdd_t *chk, *overAig = Ddi_BddNot(interpolant);
	Ddi_Varset_t *supp = Ddi_BddSupp(overAig);
        Ddi_Vararray_t *sA = Ddi_VararrayMakeFromVarset(supp,1);
	Ddi_Free(supp);
	for (i=0; i<Ddi_VararrayNum(sA); i++) {
  	  Ddi_Bdd_t *saveOverAig = Ddi_BddDup(overAig);
	  Ddi_Var_t *v = Ddi_VararrayRead(sA,i);
          DdiAigExistVarOverAcc (overAig,v,NULL);
	  size1 = Ddi_BddSize(saveOverAig);
	  size2 = Ddi_BddSize(overAig);
	  fprintf(dMgrO(ddm),"E-ternary (i: %d - v: %s) - size: %d\n",
            i, Ddi_VarName(v), size2);
	  chk = Ddi_BddNot(overAig);
	  if (!Ddi_AigSat(chk) ||
            size2 > size1 || size1-size2 > size1/2) {
	    Ddi_Free(overAig);
	    overAig = Ddi_BddDup(saveOverAig);
	  }
	  Ddi_Free(chk);
	  Ddi_Free(saveOverAig);
	  if (1&&Ddi_BddSize(overAig)<size0/2) {
	    if (enItpBddOpt)
	      Ddi_AigOptByBdd(overAig,timeLimit/5,bddSizeLimit);
	    Ddi_BddAndAcc(totAig,overAig);
	    Ddi_Free(overAig);
	    overAig = Ddi_BddNot(interpolant);
	  }
	}
	if (overAig != NULL) {
	  if (enItpBddOpt)
	    Ddi_AigOptByBdd(overAig,timeLimit/5,bddSizeLimit);
	  Ddi_BddAndAcc(totAig,overAig);
	}
	printf("E-ternary tot - size: %d\n", Ddi_BddSize(totAig));
	Ddi_Free(sA);
	Ddi_Free(totAig);
	Ddi_Free(overAig);
      }
      if (interpolant != NULL) {
	sizeLast = Ddi_BddSize(interpolant);
	// Pdtutil_Assert(Ddi_AigSat(interpolant),"ZERO interpolant");
      }
    } while (interpolant != NULL && !itpPart && sizeLast < size0*0.9);
  }

  if (0 && enItpBddOpt && interpolant != NULL &&
           Ddi_BddSize(interpolant) > 100000) {
#if 0
    int rrp = Ddi_MgrReadAigRedRemMaxCnt (ddm);

    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRemPeriod_c,inum,1);
    DdiAigRedRemovalAcc (interpolant,0,-1,
       60.0*(Ddi_BddSize(interpolant)/50000));
      //    Ddi_AigDomainStats(interpolant);
    Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRemPeriod_c,inum,rrp);
#else
      Ddi_AigOptCustom(interpolant,optCare,1,-1);

#endif
  }

  if (storeItp && interpolant!=NULL) {
    Ddi_Bddarray_t *benchArray;
    char filename[100];
    sprintf(filename, "itpOpt%02d.bench", benchCount);
    benchArray = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_BddarrayInsertLast(benchArray, interpolant);
    if (optCare != NULL) {
      Ddi_BddarrayInsertLast(benchArray, optCare);
    } else {
      optCare = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_BddarrayInsertLast(benchArray, optCare);
      Ddi_Free(optCare);
      optCare = NULL;
    }
    Ddi_AigarrayNetStore(benchArray, filename, NULL, Pdtutil_Aig2BenchLocalId_c);
    Ddi_Free(benchArray);
  }

  if (interpolant != NULL && Ddi_BddIsAig(interpolant)) {
    Ddi_Vararray_t *vA = Ddi_AigDFSOrdVars(interpolant);
    vararray2AigActivity(vA, 1.0);
    Ddi_Free(vA);
  }

  if (interpolant != NULL && checkInterpolant && !undefined) {
    if (!freeSolver) {
      Ddi_IncrSatMgrSuspend(incrSat);
    }
    Ddi_BddSetAig(a);
    Ddi_Bdd_t *tmp = Ddi_BddNot(interpolant);
    Ddi_Bdd_t *itpDup = Ddi_BddDup(interpolant);
    Ddi_BddSetAig(tmp);
    Ddi_BddSetAig(itpDup);
    Ddi_BddAndAcc(tmp,a);
    if (optCare!=NULL) {
      Pdtutil_Assert(!Ddi_AigSatAnd(tmp,optCare,NULL),
		     "invalid interpolant (A)");
    }
    else {
      Pdtutil_Assert(!Ddi_AigSat(tmp), "invalid interpolant (A)");
    }
    Ddi_Free(tmp);
   
    //Pdtutil_Warning(Ddi_AigSatAnd(itpDup,b,optCare),
    //	   "invalid interpolant");
    Pdtutil_Assert(!Ddi_AigSatAnd(itpDup,b,optCare),
    	   "invalid interpolant");
    Ddi_Free(tmp);
    Ddi_Free(itpDup);
    if (!freeSolver) {
      Ddi_IncrSatMgrResume(incrSat);
    }
  }

  int enA = ddm->settings.aig.itpNnfAbstrAB>=2;
  int enB = ddm->settings.aig.itpNnfAbstrAB%2;
  if (interpolant != NULL && itpCoreTh>0 && (enA || enB) &&
      ((itpSize = Ddi_BddSize(interpolant)) > itpCoreTh)) {
    int aFirst = Ddi_BddSize(b) > 4*Ddi_BddSize(a);
    int noRetry=0;
    Ddi_Bdd_t *myA = Ddi_BddDup(a);
    Ddi_Bdd_t *myB = Ddi_BddDup(b);
    Ddi_Bdd_t *myCare = optCare?Ddi_BddDup(optCare):NULL;
    Ddi_Bddarray_t *iteItp = NULL; // Ddi_AigPartitionTopIte(interpolant,1);
    Ddi_Bdd_t *iteConstr=NULL, *iteElse=NULL;

    if (forceRevItp) {
      enB &= ddm->settings.aig.itpReverse==0;
      aFirst = 1;
      noRetry = 1;
    }
    if (iteItp!=NULL) {
      Ddi_Free(interpolant);
      interpolant = Ddi_BddDup(Ddi_BddarrayRead(iteItp,1));
      iteConstr = Ddi_BddDup(Ddi_BddarrayRead(iteItp,0));
      Ddi_Free(iteItp);
      Ddi_AigConstrainCubeAcc(myA,Ddi_BddPartRead(iteConstr,0));
      Ddi_AigConstrainCubeAcc(myB,Ddi_BddPartRead(iteConstr,0));
      if (myCare!=NULL) {
        myCare = Ddi_BddDup(Ddi_BddPartRead(iteConstr,1));
      }
      else {
        Ddi_BddAndAcc(myCare,Ddi_BddPartRead(iteConstr,1));
      }
      Ddi_AigAndCubeAcc(myCare,Ddi_BddPartRead(iteConstr,0));
    }

    if (0&&(!Ddi_BddIsComplement(interpolant))) {
      aFirst = 1;
    }
    if (prevItp!=NULL) {
      aFirst = 1;
    }
    if (0) {
      Ddi_Bdd_t *partAnd = Ddi_AigPartitionTop(interpolant,0);
      if (Ddi_BddPartNum(partAnd)>1) {
	/* and decomp */
	aFirst = 1;
      }
      Ddi_Free(partAnd);
    }
    // Ddi_BddNotAcc(interpolant);
    // Pdtutil_Assert(!Ddi_AigSatAnd(a,interpolant,optCare),"wrong itp");
    // Ddi_BddNotAcc(interpolant);
    Ddi_AigStructRedRemAcc (interpolant,NULL);

    if (reverseInterpolant != NULL) {
      Ddi_AigStructRedRemAcc (reverseInterpolant,NULL);
      ddiAbcOptAcc (reverseInterpolant,-1);
      printf("using reverse ITP <-> ITPR: %d - %d\n",
           Ddi_BddSize(interpolant),Ddi_BddSize(reverseInterpolant));
      Ddi_BddNotAcc(reverseInterpolant);
#if 0
      Ddi_Bdd_t *myA2 = Ddi_BddDup(myA);
      Ddi_AigOptByMonotoneCoreAcc (reverseInterpolant,myA2,
                                   myCare,1,-1.0);
      Ddi_Free(myA2);
      if (Ddi_BddSize(reverseInterpolant)<0.5*Ddi_BddSize(interpolant)) {
        Ddi_DataCopy(interpolant,reverseInterpolant);
      }
      else
#endif
      {
        Ddi_BddNotAcc(reverseInterpolant);
        if (Ddi_AigOptByMonotoneCoreAcc (interpolant,
                                     reverseInterpolant,
					 myCare,0,-1.0) == NULL) {
	  Ddi_Free(reverseInterpolant);
	}
      }
    }

    int tryConstRed = 0;

    if (!freeSolver) {
      Ddi_IncrSatMgrSuspend(incrSat);
    }

    if (tryConstRed) {
      Ddi_Bdd_t *i2 = Ddi_BddDup(interpolant);
      int iSize = Ddi_BddSize(i2);
      DdiAigRedRemovalOdcAcc (i2,myA,iSize/20, cpuTime*3);
      if (Ddi_BddSize(i2)<iSize) {
	Ddi_DataCopy(interpolant,i2);
      }
      Ddi_Free(i2);
    }

    if (aFirst && enA) {
      Ddi_Bdd_t *myA2 = Ddi_BddDup(myA);
      if (prevItp!=NULL) {
	Ddi_BddDiffAcc(myA2,prevItp);
      }
      if (coreByRefinement) {
        Ddi_AigOptByMonotoneCoreByRefinementAcc (interpolant,
          myA2,myCare,1,-1.0);
      }
      Ddi_AigOptByMonotoneCoreAcc (interpolant,myA2,myCare,1,-1.0);
      if (prevItp!=NULL) {
	Ddi_BddOrAcc(interpolant,prevItp);
	Ddi_AigOptByMonotoneCoreAcc (interpolant,myA,myCare,1,-1.0);
      }
      Ddi_Free(myA2);
    }

#if 1
    if (reverseInterpolant!=NULL) {
      Ddi_Free(reverseInterpolant);
    }
    else if (enB) {
      if (coreByRefinement) {
        Ddi_AigOptByMonotoneCoreByRefinementAcc (interpolant,
          myB,itpPlus,0,-1.0);
      }
      if (saveBCore) {
        Pdtutil_Assert(cnfMappedVars!=NULL,"cnf mapped needed");
        if (partitionLits!=NULL && Ddi_BddarrayNum(partitionLits)>0) {
          Ddi_AigOptByMonotoneCoreDecompAcc (interpolant,myB,myCare,
                                             partitionLits,&coreBClauses,cnfMappedVars,0,cpuTime/2);
        }
        else {
          if (1 && cnfSharedAigs != NULL) {
            aigOptByMonotoneCoreAcc (interpolant,myB,itpPlus,
                                     NULL,NULL,
                                     NULL,NULL,0,0,0,-1.0);
          }
          else if (ddm->settings.aig.itpNoQuantify<=0) {
            aigOptByMonotoneCoreAcc (interpolant,myB,itpPlus,
                                     &coreBClauses,cnfSharedAigs,
                                     NULL,cnfMappedVars,0,0,0,-1.0);
          }
        }
      }
      else {
        if (0 && itpSize > itpCoreTh*10) {
          Ddi_AigOptByMonotoneCorePartAcc0 (interpolant,myB,myCare,
                                            NULL,NULL,NULL,8,0,-1.0);
        }
        else {
          if (coreByRefinement) {
            Ddi_AigOptByMonotoneCoreByRefinementAcc (interpolant,
                                                     myB,itpPlus,0,-1.0);
          }
          else {
            int iSize = Ddi_BddSize(interpolant);
            if (0 && (iSize>10000)) {
              printf("DECOMP NNF OPT\n");
              Ddi_AigOptByMonotoneCoreDecompAcc (interpolant,myB,myCare,NULL,NULL,NULL,0,cpuTime/2);
            }
            else {
              int noFull = 0;
              if (0) {
                printf("try part itp\n");
                Ddi_Bdd_t *bPart = Ddi_AigPartitionTop(myB,1);
                if (Ddi_BddPartNum(bPart)>10) {
                  Ddi_BddPartSortBySizeAcc(bPart, 1); // increasing size
                  
                  int j;
                  int np = Ddi_BddPartNum(bPart);
                  Ddi_Bdd_t *itpTot = Ddi_BddMakeConstAig(ddm,1);
                  for (j=np/3; j<np-4; j++) {
                    Ddi_Bdd_t *p = Ddi_BddPartRead(bPart,j);
                    Ddi_Bdd_t *itp2 = Ddi_BddDup(interpolant);
                    Ddi_AigOptByMonotoneCoreAcc (itp2,p,myCare,0,-1.0);
                    Ddi_BddAndAcc(itpTot,itp2);
                    Ddi_AigOptByMonotoneCoreAcc (itpTot,myA,myCare,1,-1.0);
                    if (!Ddi_AigSatAnd(itpTot,myB,myCare)) {
                      printf("part opt [%d/%d] is SOUND (size: %d/%d)\n",
                             j+1, Ddi_BddPartNum(bPart),
                             Ddi_BddSize(p),Ddi_BddSize(myB));
                      noFull = 1;
                      Ddi_DataCopy(interpolant,itpTot);
                      break;
                    }
                    Ddi_Free(itp2);
                  }
                  Ddi_Free(bPart);
                  Ddi_Free(itpTot);
                }
                if (!noFull)
                  printf("part opt failed\n");
              }
              if (!noFull) {
                if (partitionLits!=NULL && Ddi_BddarrayNum(partitionLits)>0) {
                  Ddi_AigOptByMonotoneCoreDecompAcc (interpolant,myB,myCare,
                                                     partitionLits,NULL,NULL,0,cpuTime/2);
                }
                else {
                  Ddi_AigOptByMonotoneCoreAcc (interpolant,myB,myCare,
                                               0,-1.0);
                }
              }
            }
          }
        }
      }
    }
#else
    Ddi_AigOptByMonotoneCorePartAcc (interpolant,myB,myCare,
				     NULL,NULL,NULL,8,0,-1.0);
    Pdtutil_Assert(!Ddi_AigSatAnd(myB,interpolant,myCare),"wrong itp");
    Ddi_BddNotAcc(interpolant);
    Pdtutil_Assert(!Ddi_AigSatAnd(myA,interpolant,myCare),"wrong itp");
    Ddi_BddNotAcc(interpolant);
#endif
    if (!noRetry) {
      if (aFirst) {
        if (enA) {
          Ddi_AigOptByMonotoneCoreAcc (interpolant,myA,myCare,1,-1.0);
          Ddi_AigStructRedRemAcc (interpolant,NULL);
          ddiAbcOptAcc (interpolant,-1);
        }
        if (enB && Ddi_BddSize(interpolant)>itpCoreTh*10) {
          Ddi_AigOptByMonotoneCoreAcc (interpolant,myB,myCare,0,-1.0);
        }
      }
      else {
        if (enA && Ddi_BddSize(interpolant)>itpCoreTh) {
          Ddi_AigOptByMonotoneCoreAcc (interpolant,myA,myCare,1,-1.0);
        }
      }
    }

    if (Ddi_BddSize(interpolant)>itpCoreTh) {
      Ddi_AigOptByFoCntTop(interpolant, NULL, 0);
    }

    if (iteConstr!=NULL) {
      Ddi_Bdd_t *newItp = Ddi_BddIte(iteConstr,interpolant,iteElse);
      Ddi_Free(interpolant);
      interpolant = newItp;
    }

    Ddi_Free(myA);
    Ddi_Free(myB);
    Ddi_Free(myCare);
    Ddi_Free(iteConstr);
    Ddi_Free(iteElse);

    if (!freeSolver) {
      Ddi_IncrSatMgrResume(incrSat);
    }
    
  }

  if (ddm->settings.aig.itpTwice!=0 && donePartialExist>0) {
    Ddi_Bdd_t *auxItp = interpolant;
    int saveThresh = ddm->settings.aig.itpTwice;
    ddm->settings.aig.itpTwice = 0;
    if (donePartialExistB) {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("\nRecomputing interpolant <%d,%d(%d)> after partial exist\n",
	       Ddi_BddSize(a2), Ddi_BddSize(auxItp), Ddi_BddSize(b2));
      }
      Ddi_BddNotAcc(auxItp);
      interpolant = Ddi_AigSatAndWithInterpolant (a2,auxItp,
          globalVars,NULL,
          optCare,NULL,NULL,implArray,psat,0,itpOdc,-1/*timeLimit*/);
    }
    else {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("\nRecomputing interpolant <%d(%d),%d> after partial exist\n",
	       Ddi_BddSize(auxItp), Ddi_BddSize(a2), Ddi_BddSize(b2));
      }
      interpolant = Ddi_AigSatAndWithInterpolant (auxItp,b2,
          globalVars,NULL,
          optCare,NULL,NULL,implArray,psat,0,itpOdc,-1/*timeLimit*/);
    }
    ddm->settings.aig.itpTwice = saveThresh;
    Ddi_Free(auxItp);
  }

  Ddi_Free(reverseInterpolant);
  Ddi_Free(a2);
  Ddi_Free(b2);
  Ddi_Free(b2Part);
  Ddi_Free(partitionLits);
  Ddi_Free(revPartitionLits);

  if (cnfMappedVars!=NULL) bAigArrayFree(cnfMappedVars);
  Ddi_Free(cnfSharedAigs);
  
  //  Ddi_MgrConsistencyCheck (ddm);

  if (interpolant!=NULL && ddm->settings.aig.itpAbortTh>0 &&
      Ddi_BddSize(interpolant) > ddm->settings.aig.itpAbortTh) {
    Ddi_Free(interpolant);
  }

  return(interpolant);
}



/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigSatAndWithInterpolantSequence (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  int *psat,
  int nCuts,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bddarray_t *itpSequence;
  Solver      S;
  int *nAClArray, np, i, j, checkVars = 0, dynAbstr = 0;
  Ddi_Vararray_t *vA;
  int checkInterpolant = 0;
  Ddi_Varsetarray_t *globalVars;
  Ddi_Varset_t *prevSupp;
  Ddi_Bdd_t *a2=NULL, *b2=NULL;
  int nSuppVars;
  static int itpStoreId=0, storeItp=0;
  int undefined = 0;
  int itpSizeOptTh = 30000;
  int optLevel = Ddi_MgrReadAigBddOptLevel (ddm);
  long startTime, cpuTime;
  bAig_array_t *visitedNodes = NULL;
  int itpStructOdcTh = ddm->settings.aig.itpStructOdcTh;

  static int ncalls=0;
  int enItpBddOpt = optLevel > 0;

  ncalls++;

  int ddmid =  ddm->currNodeId;

  Pdtutil_Assert(b!=NULL || Ddi_BddIsPartConj(a),
		 "Conj. part DD required for ITP Seq.");
  /* handle constant cases */
  if (np<=1 && b==NULL && Ddi_BddIsZero(a)) {
    Ddi_Bdd_t *constOne = Ddi_BddMakeConstAig(ddm,1);
    itpSequence = Ddi_BddarrayAlloc(ddm,np-1);
    for (i=0; i<np-1; i++) {
      Ddi_BddarrayWrite(itpSequence,i,constOne);
    }
    Ddi_Free(constOne);
    //    return (Ddi_BddMakeConstAig(ddm,1));
    *psat = 0;
    return itpSequence;
  }
  if (Ddi_BddIsOne(a)) {
    *psat = 1;
    Pdtutil_Assert(0,"UNSUPPORTED ITP SEQ");
    //    return (Ddi_BddMakeConstAig(ddm,1));
    return NULL;
  }
  /* end constant cases */

  b2 = Ddi_BddMakePartConjVoid(ddm);
  if (b!=NULL) {
    int j;
    a2 = Ddi_BddDup(a);
    Pdtutil_Assert(Ddi_BddIsPartConj(b),"part conj needed");
    Ddi_BddSetPartConj(a2);
    for (j=0; j<Ddi_BddPartNum(b); j++) {
      Ddi_BddPartInsertLast(b2,Ddi_BddPartRead(b,j));
    }
  }
  else {
    int j;
    Pdtutil_Assert(Ddi_BddIsPartConj(a),"part conj needed");
    a2 = Ddi_BddMakePartConjVoid(ddm);
    Ddi_BddPartInsertLast(a2,Ddi_BddPartRead(a,0));
    for (j=1; j<Ddi_BddPartNum(a); j++) {
      Ddi_BddPartInsertLast(b2,Ddi_BddPartRead(a,j));
    }
  }
  np = Ddi_BddPartNum(b2);

  if (nCuts > 0 && nCuts < np) {
    int j, jRef = nCuts-1;
    Ddi_Bdd_t *p_ref = Ddi_BddPartRead(b2,jRef);
    for (j=np-1; j>=jRef+1; j--) {
      Ddi_Bdd_t *p_j = Ddi_BddPartExtract(b2,j);
      Ddi_BddAndAcc(p_ref,p_j);
      Ddi_Free(p_j);
    }
    np = nCuts;
  }

  globalVars = Ddi_VarsetarrayAlloc(ddm,nCuts);
  prevSupp = Ddi_BddSupp(a2);

  for (i=0; i<np; i++) {
    Ddi_Bdd_t *f_i = Ddi_BddPartRead(b2,i);
    Ddi_Varset_t *s_i = Ddi_BddSupp(f_i);
    Pdtutil_Assert(prevSupp!=NULL,"NULL support");
    if (Ddi_VarsetIsArray(s_i)) {
      Ddi_VarsetSetArray(prevSupp);
    }
    Ddi_VarsetIntersectAcc(prevSupp,s_i);
    Ddi_VarsetarrayWrite(globalVars,i,prevSupp);
    nSuppVars += Ddi_VarsetNum(prevSupp);
    Ddi_Free(prevSupp);
    prevSupp = s_i;
  }
  Ddi_Free(prevSupp);

  if (nSuppVars==0) {
    Ddi_Free(globalVars);
    //    return (Ddi_BddMakeConstAig(ddm,1));
    Ddi_Free(a2);
    Ddi_Free(b2);
    return NULL;
  }

  fprintf(dMgrO(ddm),"ITPS (|A|=%d)\n", Ddi_BddSize(a));

  aig2CnfIdInit(ddm);

  S.proof = new Proof();

  nAClArray = Pdtutil_Alloc(int, np);

  //  visitedArray = MinisatItpSeqClauses(S,a2,nAClArray);
  MinisatClausesWithSuppFlow(NULL,S,NULL,a2,b2,NULL,nAClArray,
			     NULL,NULL,0,0,0,np);

  startTime = util_cpu_time();

  if ((*psat = S.okay())) {
    if (timeLimit >= 0) {
      vec<Lit> assumps;
      assumps.clear();
      *psat = S.solve(assumps, timeLimit);
      undefined = S.undefined();
    }
    else {
      *psat = S.solve();
    }
  }
  else {
    fprintf(dMgrO(ddm),"TRIVIAL UNSAT\n");
  }

  cpuTime = util_cpu_time () - startTime;

  fprintf(dMgrO(ddm),"Solver stats: %ld dec.\n", S.stats.decisions);
  fprintf(dMgrO(ddm),"Solver stats: %ld prop.\n", S.stats.propagations);
  fprintf(dMgrO(ddm),"Solver stats: %ld confl.\n", S.stats.conflicts);
  fprintf(dMgrO(ddm),"Solver stats: time = %s\n", util_print_time (cpuTime));

  if (undefined) {
    fprintf(dMgrO(ddm),"Solver result UNDEFINED\n");
    *psat = 0;
  }

  if (*psat || undefined) {

    aig2CnfIdClose(ddm);
    S.deleteProofTemps();
    Ddi_Free(a2);
    Ddi_Free(b2);
    Ddi_Free(globalVars);
    return NULL;
  }

  itpSequence = Ddi_BddarrayAlloc(ddm,np);
  visitedNodes = bAigArrayAlloc();
  Ddi_PostOrderBddAigVisitIntern(a2,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);

  for (i=0; i<np; i++) {

    /* loop on interpolant sequence */
    int k;
    int nACl;
    Ddi_Bdd_t *interpolant;
    Ddi_Bdd_t *interpolantOpt;

    bAig_array_t *visitedNodes1 = bAigArrayAlloc();
    bAig_array_t *visitedNodes2 = bAigArrayAlloc();

    for (k=0; k<np; k++) {
      Ddi_Bdd_t *b_k = Ddi_BddPartRead(b2,k);
      if (k<i) {
	Ddi_PostOrderBddAigVisitIntern(b_k,visitedNodes1,-1);
      }
      else {
	Ddi_PostOrderBddAigVisitIntern(b_k,visitedNodes2,-1);
      }
    }
    postOrderAigClearVisitedIntern(bmgr,visitedNodes1);
    postOrderAigClearVisitedIntern(bmgr,visitedNodes2);
    for (k=0; k<visitedNodes->num; k++) {
      /* A node: set auxchar = 0 */
      bAigEdge_t baig = visitedNodes->nodes[k];
      nodeAuxChar(bmgr,baig) = 0;
    }
    for (k=0; k<visitedNodes1->num; k++) {
      /* A node: set auxchar = 0 */
      bAigEdge_t baig = visitedNodes1->nodes[k];
      nodeAuxChar(bmgr,baig) = 0;
    }
    for (k=0; k<visitedNodes2->num; k++) {
      /* A+B or B node: set auxchar = 1 */
      bAigEdge_t baig = visitedNodes2->nodes[k];
      nodeAuxChar(bmgr,baig) = 1;
    }

    nACl = nAClArray[i];

    vA = Ddi_VararrayMakeFromVarset(
	   Ddi_VarsetarrayRead(globalVars,i),1);

    for (k=0; k<Ddi_VararrayNum(vA); k++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA,k);
      bAigEdge_t varIndex = Ddi_VarToBaig(v);
      Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
      nodeAuxChar(bmgr,varIndex) = 3;
    }

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nITP sequence cut %d/%d\n\n", i, np);
    }

    MinisatInterpolant (S, ddm, nACl, 0, &interpolant, &interpolantOpt,
			NULL, NULL, NULL, nSuppVars, 0);

    for (k=0; k<Ddi_VararrayNum(vA); k++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA,k);
      bAigEdge_t varIndex = Ddi_VarToBaig(v);
      Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
      nodeAuxChar(bmgr,varIndex) = 0;
    }

    if (interpolant!=NULL && Ddi_BddSize(interpolant) > itpStructOdcTh ) {
      Ddi_AigStructRedRemAcc (interpolant,NULL);
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMed_c,
       printf("TOT aig after struct rr: %d)\n", Ddi_MgrReadAigNodesNum(ddm))
      );
      Ddi_NnfClustSimplifyAcc(interpolant,0);
    }

    if (Ddi_BddSize(interpolant) > 5000) {
      ddiAbcOptAcc (interpolant,-1);
    }
    Ddi_BddarrayWrite(itpSequence,i,interpolant);

    Ddi_Free(interpolant);
    Ddi_Free(vA);

  }


  bAigArrayFree(visitedNodes);
  visitedNodes = bAigArrayAlloc();
  Ddi_PostOrderBddAigVisitIntern(a2,visitedNodes,-1);
  Ddi_PostOrderBddAigVisitIntern(b2,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);

  for (i=0; i<visitedNodes->num; i++) {
    /* reset */
    bAigEdge_t baig = visitedNodes->nodes[i];
    nodeAuxChar(bmgr,baig) = 0;
  }

  bAigArrayFree(visitedNodes);

  aig2CnfIdClose(ddm);
  S.deleteProofTemps();

  Ddi_Free(a2);
  Ddi_Free(b2);
  Ddi_Free(globalVars);

  return(itpSequence);
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigItpSeqEq(
  Ddi_Bdd_t *a,
  Ddi_Vararray_t *eqVars,
  Ddi_Bddarray_t *eqSubst,
  int bound
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Bddarray_t *itpSequence;
  int np, i, j;
  Ddi_Varsetarray_t *globalVars;
  Ddi_Varset_t *prevSupp;
  int nSuppVars;
  Ddi_Bdd_t *constOne;
  Ddi_Bdd_t *aaAux=NULL;

  Pdtutil_Assert(Ddi_BddIsPartConj(a),"Conj. part DD required for ITP Seq.");
  np = Ddi_BddPartNum(a);

  /* handle constant cases */
  if (Ddi_BddIsZero(a)) {
    Ddi_Bdd_t *constOne = Ddi_BddMakeConstAig(ddm,1);
    itpSequence = Ddi_BddarrayAlloc(ddm,np-1);
    for (i=0; i<np-1; i++) {
      Ddi_BddarrayWrite(itpSequence,i,constOne);
    }
    Ddi_Free(constOne);
    //    return (Ddi_BddMakeConstAig(ddm,1));
    return itpSequence;
  }
  if (Ddi_BddIsOne(a)) {
    Pdtutil_Assert(0,"UNSUPPORTED ITP SEQ");
    //    return (Ddi_BddMakeConstAig(ddm,1));
    return NULL;
  }
  /* end constant cases */

  globalVars = Ddi_VarsetarrayAlloc(ddm,np-1);
  prevSupp = NULL;

  for (i=0; i<np; i++) {
    Ddi_Bdd_t *f_i = Ddi_BddPartRead(a,i);
    Ddi_Varset_t *s_i = Ddi_BddSupp(f_i);
    if (i>0) {
      Pdtutil_Assert(prevSupp!=NULL,"NULL support");
      Ddi_VarsetIntersectAcc(prevSupp,s_i);
      Ddi_VarsetarrayWrite(globalVars,i-1,prevSupp);
      nSuppVars += Ddi_VarsetNum(prevSupp);
    }
    Ddi_Free(prevSupp);
    prevSupp = s_i;
  }
  Ddi_Free(prevSupp);

  if (nSuppVars==0) {
    Ddi_Free(globalVars);
    //    return (Ddi_BddMakeConstAig(ddm,1));
    return NULL;
  }

  fprintf(dMgrO(ddm),"ITPS-EQ (|A|=%d)\n", Ddi_BddSize(a));

  itpSequence = Ddi_BddarrayAlloc(ddm,np-1);
  constOne = Ddi_BddMakeConstAig(ddm,1);

  for (i=0; i<np-1; i++) {
    Ddi_BddarrayWrite(itpSequence,i,constOne);
  }
  Ddi_Free(constOne);

  for (i=0; i<np-1 && (bound<=0 || i<bound); i++) {
    /* loop on interpolant sequence */
    Ddi_Bdd_t *interpolant;
    Ddi_Vararray_t *constrainVars = Ddi_VararrayAlloc(ddm,0);
    Ddi_Bddarray_t *constrainSubstLits = Ddi_BddarrayAlloc(ddm,0);
    Ddi_Varset_t *projVars = Ddi_VarsetarrayRead(globalVars,i);
    Ddi_Bdd_t *aa = Ddi_BddPartRead(a,i);
    Ddi_Bdd_t *bb = Ddi_BddPartRead(a,i+1);
    Ddi_Bdd_t *eq;

    Ddi_Free(aaAux);
    if (aaAux==NULL) {
      aaAux = Ddi_BddDup(aa);
    }
    else {
      Ddi_BddAndAcc(aaAux,aa);
    }

    eq = DdiAigEquivVarsAcc(aaAux,NULL,NULL,projVars,bb,
            constrainVars,constrainSubstLits);

    if (eq!=NULL) {
      Ddi_BddarrayWrite(itpSequence,i,eq);
      Ddi_BddarrayComposeAcc(eqSubst,constrainVars,constrainSubstLits);
      Ddi_BddComposeAcc(aa,constrainVars,constrainSubstLits);
      //      Ddi_BddComposeAcc(aaAux,constrainVars,constrainSubstLits);
      //      Ddi_BddAndAcc(aaAux,eq);
      //      Ddi_BddAndAcc(bb,eq);
      Ddi_VararrayAppend(eqVars,constrainVars);
      Ddi_BddarrayAppend(eqSubst,constrainSubstLits);
    }

    Ddi_Free(constrainVars);
    Ddi_Free(constrainSubstLits);
    Ddi_Free(eq);
  }

  Ddi_Free(aaAux);
  Ddi_Free(globalVars);

  return (itpSequence);

}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *Ddi_AigFunctionalDecomp
(
  Ddi_Bdd_t *a,
  Ddi_Vararray_t *filterVa
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int i;
  Ddi_Varset_t *filterVs;
  Ddi_Bddarray_t *substFunc;

  Ddi_Bdd_t *aPart = Ddi_AigPartitionTop(a,0);

  Ddi_Free(aPart);

}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *AigAbstrVarsForInterpolantPreWindow
(
  Ddi_Bdd_t *a,
  unsigned char *saveEnAbstrIn,
  unsigned char *enAbstrIn,
  unsigned char *doAbstrOut,
  int nVars,
  int startId,
  int wSize,
  Ddi_Vararray_t *aVars,
  Ddi_Vararray_t *bVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int i;
  Ddi_Bddarray_t *abstrVarLit;
  Ddi_Vararray_t *vSubst;
  Ddi_Bdd_t *a2;

  for (i=0; i<nVars; i++) {
    if (!enAbstrIn[i]) continue;
    if (i>=startId && i<(startId+wSize)) continue;
    /* temporarily disable it */
    saveEnAbstrIn[i] = 1;
    enAbstrIn[i] = 0;
  }

  abstrVarLit = Ddi_BddarrayAlloc(ddm,0);
  vSubst = Ddi_VararrayAlloc(ddm,0);
  for (i=nVars-1; i>=0; i--) {
    Ddi_Var_t *aV = Ddi_VararrayRead(aVars,i);
    Ddi_Var_t *bV = Ddi_VararrayRead(bVars,i);
    if (saveEnAbstrIn[i]) {
      Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(bV,1);
      Ddi_BddarrayInsertLast(abstrVarLit,lit);
      Ddi_Free(lit);
      Ddi_VararrayInsertLast(vSubst,aV);
    }
  }
  a2 = Ddi_BddCompose(a,vSubst,abstrVarLit);
  Ddi_Free(abstrVarLit);
  Ddi_Free(vSubst);

  return a2;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *AigAbstrVarsForInterpolantPostWindow
(
  Ddi_Bdd_t *a,
  unsigned char *saveEnAbstrIn,
  unsigned char *enAbstrIn,
  int nVars,
  Ddi_Vararray_t *aVars,
  Ddi_Vararray_t *bVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int i, n;
  Ddi_Bddarray_t *abstrVarLit;
  Ddi_Vararray_t *vSubst;
  Ddi_Bdd_t *a2;


  abstrVarLit = Ddi_BddarrayAlloc(ddm,0);
  vSubst = Ddi_VararrayAlloc(ddm,0);
  for (i=n=0; i<nVars; i++) {
    Ddi_Var_t *aV = Ddi_VararrayRead(aVars,i);
    Ddi_Var_t *bV = Ddi_VararrayRead(bVars,i);
    if (saveEnAbstrIn[i]) {
      Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(aV,1);
      Ddi_BddarrayInsertLast(abstrVarLit,lit);
      Ddi_Free(lit);
      Ddi_VararrayInsertLast(vSubst,bV);
      /* re-enable it */
      enAbstrIn[i] = 1;
      saveEnAbstrIn[i] = 0;
      n++;
    }
  }
  a2 = Ddi_BddCompose(a,vSubst,abstrVarLit);
  Ddi_Free(abstrVarLit);
  Ddi_Free(vSubst);

  return a2;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigAbstrVarsForInterpolantByRefinement (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Vararray_t *aVars,
  Ddi_Vararray_t *bVars,
  Ddi_Vararray_t *auxVars,
  char *wfileName,
  unsigned char *enAbstr
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int nAbstr, nInitAbstr=0, i, j, nEn, nEn0, undefined=0;
  int nVars = Ddi_VararrayNum(aVars);
  unsigned char *saveEnAbstrIn = Pdtutil_Alloc(unsigned char, nVars);
  unsigned char *enAbstrIn = Pdtutil_Alloc(unsigned char, nVars);
  unsigned char *doAbstrOut = Pdtutil_Alloc(unsigned char, nVars);
  Ddi_Bdd_t *a2, *a2b, *a3=NULL;
  int strategy = 0, validated = 0;
  int localUndef;
  Ddi_Bdd_t *constr = NULL;
  int forceValidated=0;

  for (i=0; i<nVars; i++) {
    saveEnAbstrIn[i] = 0;
    enAbstrIn[i] = 1;
    doAbstrOut[i] = 0;
  }

  if (0)
  {
    Ddi_Varset_t *sm = Ddi_BddSupp(a);
    Ddi_Varset_t *aVarsSet = Ddi_VarsetMakeFromArray(aVars);
    Ddi_VarsetDiffAcc(sm,aVarsSet);
    a2b = DdiAigFuncDepAcc (a, NULL, NULL, sm, NULL, NULL, NULL , NULL, NULL);
    a3 = DdiAigFuncDepAcc (a2b, NULL, NULL, aVarsSet,NULL,NULL,NULL,NULL,NULL);
    Ddi_Free(sm);
    Ddi_Free(aVarsSet);
  }
  if (0)
  {
    Ddi_Bdd_t *b0 = Ddi_AigPartitionTop(b,0);
    Ddi_Bdd_t *b1 = Ddi_AigPartitionTop(b,1);
    Ddi_Varset_t *aVarsSet = Ddi_VarsetMakeFromArray(aVars);

    for (i=0; i<Ddi_BddPartNum(b1); i++) {
      Ddi_Bdd_t *p = Ddi_BddPartRead(b1,i);
      Ddi_Bdd_t *p1 = DdiAigFuncDepAcc (p, NULL,
	    aVarsSet, NULL, NULL, NULL, NULL , NULL, NULL);
      Ddi_Free(p1);
    }
    Ddi_Free(aVarsSet);
    Ddi_Free(b0);
    Ddi_Free(b1);

  }

  a2 = AigAbstrVarsForInterpolantByRefinementIntern (a,b,aVars,bVars,
    auxVars,NULL,NULL,enAbstrIn,doAbstrOut,&nAbstr,&nInitAbstr,&localUndef,0,0);

  if (localUndef) {
    fprintf(dMgrO(ddm),"UNDEF single abstr\n");
  }

  if (a2 != NULL) {
    Ddi_Varset_t *smooth = Ddi_VarsetVoid(ddm);
    for (i=0; i<nVars; i++) {
      if (!enAbstrIn[i] && doAbstrOut[i]) {
        Ddi_VarsetAddAcc(smooth,Ddi_VararrayRead(aVars,i));
      }
      //printf(" ea/da[%2d]: %3d %3d\n",  i, enAbstrIn[i], doAbstrOut[i]);
    }
    if (0 && !Ddi_VarsetIsVoid(smooth)) {
      Ddi_Bdd_t *aa = a2;
      a2 = DdiAigFuncDepAcc (aa, NULL, NULL, smooth,
					b, NULL, NULL , NULL, NULL);
      Ddi_Free(aa);
    }
    Ddi_Free(smooth);
  }

  if (strategy==2 && localUndef) {
    int prevEn0=0, maxSize = 50;
    a2b = a2;
    for (i=nEn=0; i<nVars; i++) {
      nEn += enAbstrIn[i];
    }

    while (prevEn0+maxSize < nVars) {

      for (i=prevEn0,j=0; i<nVars; i++) {
        if (!enAbstrIn[i]) continue;
        if (j++==maxSize) {
 	  nEn0 = i;
	  break;
        }
      }

      a2b = AigAbstrVarsForInterpolantPreWindow (a2,
        saveEnAbstrIn,enAbstrIn,doAbstrOut,nVars,prevEn0,nEn0-prevEn0,
           aVars,bVars);

      Ddi_Free(a2);

      prevEn0 = nEn0;

      if (1)
      {
        Ddi_Bdd_t *b2 = Ddi_BddDup(b);
        Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
        Ddi_Varset_t *globalVars = Ddi_VarsetMakeFromArray(bVars);
        Ddi_Bdd_t *aa = DdiAigFuncDepAcc (a2b, NULL, NULL, globalVars,
					b2, constr, NULL , NULL, NULL);
        a2 = AigAbstrVarsForInterpolantByRefinementIntern (aa,b2,aVars,bVars,
          auxVars,NULL,NULL,enAbstrIn,doAbstrOut,&nAbstr,NULL,NULL,0,0);
        Ddi_BddAndAcc(a2,constr);
        Ddi_Free(constr);
        Ddi_Free(aa);
        Ddi_Free(b2);
      }
      else {
        a2 = AigAbstrVarsForInterpolantByRefinementIntern (a2b,b,aVars,bVars,
          auxVars,NULL,NULL,enAbstrIn,doAbstrOut,&nAbstr,NULL,NULL,0,0);
      }


      //    undefined |= localUndef;
      Ddi_Free(a2b);

      a2b = a2;
      a2 = AigAbstrVarsForInterpolantPostWindow (a2b,
         saveEnAbstrIn,enAbstrIn,nVars,aVars,bVars);
      Ddi_Free(a2b);

    }

    a2b = AigAbstrVarsForInterpolantPreWindow (a2,
      saveEnAbstrIn,enAbstrIn,doAbstrOut,nVars,nEn0,nVars-nEn0,aVars,bVars);

    Ddi_Free(a2);

    if (0)
    {
      Ddi_Bdd_t *b2 = Ddi_BddDup(b);
      Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
      Ddi_Varset_t *globalVars = Ddi_VarsetMakeFromArray(bVars);
      Ddi_Bdd_t *aa = DdiAigFuncDepAcc (a2b, NULL, NULL, globalVars,
					b2, constr, NULL , NULL, NULL);
      a2 = AigAbstrVarsForInterpolantByRefinementIntern (aa,b2,aVars,bVars,
        auxVars,NULL,NULL,enAbstrIn,doAbstrOut,&nAbstr,NULL,NULL,0,0);
      Ddi_BddAndAcc(a2,constr);
      Ddi_Free(constr);
      Ddi_Free(aa);
      Ddi_Free(b2);
    }
    else {
      a2 = AigAbstrVarsForInterpolantByRefinementIntern (a2b,b,aVars,bVars,
        auxVars,NULL,NULL,enAbstrIn,doAbstrOut,&nAbstr,NULL,NULL,0,0);
    }


    //    undefined |= localUndef;
    Ddi_Free(a2b);

    a2b = a2;
    a2 = AigAbstrVarsForInterpolantPostWindow (a2b,
       saveEnAbstrIn,enAbstrIn,nVars,aVars,bVars);
    Ddi_Free(a2b);

  }


#if 0
      fprintf(dMgrO(ddm),"\nAbstr m  0: ");
      for (i=0; i<nVars; i++) {
       fprintf(dMgrO(ddm),"%d", enAbstrIn[i]);
      }
      fprintf(dMgrO(ddm),"\n");
#endif

  if (a2 != NULL && strategy == 1) {
    int eT = ddm->settings.aig.satTimeout;
    ddm->settings.aig.satTimeout=-1;
    a3 = Ddi_AigAbstrVarsForInterpolant(a2,b,
       aVars,bVars,auxVars,NULL,enAbstrIn,NULL);
    ddm->settings.aig.satTimeout=eT;
    Ddi_Free(a2);
  }

  nAbstr = 1;
  if (a2!=NULL) {
    Ddi_Bddarray_t *abstrVarLit;
    Ddi_Vararray_t *vSubst;
    int i=0, nIter=0;
    int goAhead = 1, isSat=0;
    int prevEn0=0, maxSize = 50;

    for (i=nEn=0; i<nVars; i++) {
      nEn += enAbstrIn[i];
      if (0 && enAbstrIn[i]) {
	/* to try result of single pass */
	doAbstrOut[i] = 1;
	enAbstrIn[i] = 0;
	goAhead = 0;
      }
    }
    for (nIter=prevEn0=0; goAhead&&nAbstr>0&&nEn>0 && !undefined; nIter++) {

      for (i=nEn=0; i<nVars; i++) {
        nEn += enAbstrIn[i];
      }

      maxSize = nEn/2;
      do {

      for (i=prevEn0,j=0; i<nVars; i++) {
	if (!enAbstrIn[i]) continue;
	if (j++==maxSize) {
	  break;
	}
      }
      nEn0 = i;

      Pdtutil_Assert(nEn0<=nVars,"wrong array bound");
      if (nIter > 0) nEn0=nVars;

      if (nEn0 < nVars && goAhead) {

	printf("\npart abstr section: %d-%d/%d", prevEn0, nEn0, nVars);

        a2b = AigAbstrVarsForInterpolantPreWindow (a2,
          saveEnAbstrIn,enAbstrIn,doAbstrOut,nVars,prevEn0,
          nEn0-prevEn0,aVars,bVars);

        a3 = AigAbstrVarsForInterpolantByRefinementIntern (a2b,b,aVars,bVars,
	  auxVars,NULL,NULL,enAbstrIn,doAbstrOut,&nAbstr,NULL,
          &localUndef,1,nIter%2);
        undefined |= localUndef;

	Ddi_Free(a2b);
	if (a3 == NULL) {
	  goAhead=0;
	  isSat=1;
	}
	else {
          a2b = AigAbstrVarsForInterpolantPostWindow (a3,
            saveEnAbstrIn,enAbstrIn,nVars,aVars,bVars);
          Ddi_Free(a2b);
	}
	Ddi_Free(a3);
      }

      prevEn0 = nEn0;

      } while (0 && prevEn0 < nVars);

      if (0) {

        a2b = AigAbstrVarsForInterpolantPreWindow (a2,
	  saveEnAbstrIn,enAbstrIn,doAbstrOut,
          nVars,nEn0,nVars-nEn0,aVars,bVars);

        if (goAhead) {
          a3 = AigAbstrVarsForInterpolantByRefinementIntern (a2b,b,aVars,bVars,
	    auxVars,NULL,NULL,enAbstrIn,doAbstrOut,&nAbstr,NULL,
            &localUndef,1,nIter%2);
          undefined |= localUndef;
	}

	Ddi_Free(a2b);
        a2b = AigAbstrVarsForInterpolantPostWindow (a3,
           saveEnAbstrIn,enAbstrIn,nVars,aVars,bVars);
        Ddi_Free(a2b);

      }
      else if (goAhead) {
        a3 = AigAbstrVarsForInterpolantByRefinementIntern (a2,b,aVars,bVars,
	  auxVars,NULL,NULL,enAbstrIn,doAbstrOut,&nAbstr,NULL,
          &localUndef,1,nIter%2);
        undefined |= localUndef;
      }
      Ddi_Free(a3);

      for (i=nEn=0; i<nVars; i++) {
	//printf("ea/da[%2d]: %3d %3d\n",  i, enAbstrIn[i], doAbstrOut[i]);
	nEn += enAbstrIn[i];
      }
#if 0
      fprintf(dMgrO(ddm),"\nAbstr m  1: ");
      for (i=0; i<nVars; i++) {
       fprintf(dMgrO(ddm),"%d", doAbstrOut[i]);
      }
      fprintf(dMgrO(ddm),"\n");
#endif
      if (1 && goAhead && !undefined && (nEn>0)) {
	int myInit=0;
	a3 = a2;
        //       Ddi_Free(a2);
        a2 = AigAbstrVarsForInterpolantByRefinementIntern (a3,b,aVars,bVars,
	  auxVars,NULL,NULL,enAbstrIn,doAbstrOut,NULL,&myInit,NULL,0,nIter%2);
	nInitAbstr += myInit;
      }
      Ddi_Free(a3);

      for (i=nEn=0; i<nVars; i++) {
	//printf("ea/da[%2d]: %3d %3d\n",  i, enAbstrIn[i], doAbstrOut[i]);
	nEn += enAbstrIn[i];
      }
#if 0
      fprintf(dMgrO(ddm),"\nAbstr mask: ");
      for (i=0; i<nVars; i++) {
       fprintf(dMgrO(ddm),"%d", doAbstrOut[i]);
      }
      fprintf(dMgrO(ddm),"\n");
      fprintf(dMgrO(ddm),"En    mask: ");
      for (i=0; i<nVars; i++) {
       fprintf(dMgrO(ddm),"%d", enAbstrIn[i]);
      }
      fprintf(dMgrO(ddm),"\n");
#endif
    }

    if (!isSat) {

    abstrVarLit = Ddi_BddarrayAlloc(ddm,0);
    vSubst = Ddi_VararrayAlloc(ddm,0);

    nAbstr = nVars-nInitAbstr;
    for (i=nVars-1; i>=0; i--) {
      Ddi_Var_t *aV = Ddi_VararrayRead(aVars,i);
      Ddi_Var_t *bV = Ddi_VararrayRead(bVars,i);
      if (!doAbstrOut[i]) {
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(bV,1);
        Ddi_BddarrayInsertLast(abstrVarLit,lit);
        Ddi_Free(lit);
        Ddi_VararrayInsertLast(vSubst,aV);
  	//    	printf("%s ",Ddi_VarName(bV));
	nAbstr--;
       }
    }

        /* no refinement possible with SAT */
    fprintf(dMgrO(ddm),"\nDYNABSTR by ref. found %d/%d TOTAL abstractions (%d initial)\n",
	   nAbstr, nVars-nInitAbstr, nInitAbstr); fflush(dMgrO(ddm));

#if 0
    fprintf(dMgrO(ddm),"Abstr mask: ");
    for (i=0; i<nVars; i++) {
      fprintf(dMgrO(ddm),"%d", doAbstrOut[i]);
    }
    fprintf(dMgrO(ddm),"\n");
#endif
    a3 = Ddi_BddCompose(a2,vSubst,abstrVarLit);
    Ddi_Free(abstrVarLit);
    Ddi_Free(vSubst);

    if (undefined) {
      Ddi_Bdd_t *chk, *chk0 = Ddi_BddAnd(a3,b);
      Ddi_Varset_t *abstr = Ddi_VarsetMakeFromArray(bVars);
      Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
#if 0
      chk = DdiAigFuncDepAcc (chk0, NULL, NULL, abstr,
					NULL, constr, NULL , NULL, NULL);
#else
      chk = Ddi_BddDup(chk0);
#endif
      Ddi_BddAndAcc(chk,constr);
      Ddi_Free(constr); Ddi_Free(chk0);
      validated=1;
      if (forceValidated||!Ddi_AigSat(chk)) {
        fprintf(dMgrO(ddm),"validated UNDEFINED dynamic abstraction\n");
      }
      else {
	abstrVarLit = Ddi_BddarrayMakeLiteralsAig(bVars, 1);
        Ddi_Free(a3);
	a3 = Ddi_BddCompose(a,aVars,abstrVarLit);
	Ddi_Free(abstrVarLit);
        if (Ddi_AigSatAnd(a3,b,NULL)) { /*@@@@***/
	  Ddi_Free(a3);
	}
      }
      Ddi_Free(abstr);
      Ddi_Free(chk);
    }

    Ddi_Free(a2);

    //printf("DYNABSTR by refinement found 0/%d TOTAL abstractions\n",
    //   nVars-nInitAbstr); fflush(dMgrO(ddm));

    Pdtutil_Assert(0||validated||a3==NULL||!Ddi_AigSatAnd(a3,b,NULL),
      "Wrong abstraction by ref");

    }

  }

  Pdtutil_Free(saveEnAbstrIn);
  Pdtutil_Free(enAbstrIn);
  Pdtutil_Free(doAbstrOut);

  return a3;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
AigAbstrVarsForInterpolantByRefinementIntern (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Vararray_t *aVars,
  Ddi_Vararray_t *bVars,
  Ddi_Vararray_t *auxVars,
  char *wfileName,
  unsigned char *enAbstr,
  unsigned char *enAbstrIn,
  unsigned char *doAbstrOut,
  int *nAbstrP,
  int *nInitAbstrP,
  int *undefP,
  int phase,
  int up_down
)
{
#if 0
  int i, j;
  int abstrCnt=0;
  Solver    S;
  FILE *fp=NULL;
  int strategy = 0;
  int enableTimeout = ddm->settings.aig.satTimeout;
  long cpuTime, startTime;
  double timeLimit=-1.0;
  int satIncremental = ddm->settings.aig.satIncremental;
  int doAbort = 0;


  Ddi_Bdd_t *newaAig, *newbAig, *cof0Aig, *cof1Aig, *notaAig;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, auxVarIndex, aBaig, bBaig, careBaig, cof0, cof1, f0, f1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  int extRef = Ddi_MgrReadExtRef(ddm);
  Ddi_Vararray_t *vA, *vAuxA;
  Ddi_Bdd_t *prod;
  int checkFunction = 0;
  int doAbstrB = 0;
  Ddi_Bdd_t *myB=NULL;
  int size0 = Ddi_BddSize(a);
  int size0b = b==NULL ? 0 : Ddi_BddSize(b);
  int checkMonotonicity = 0;
  int enMonotonicityCheck = 1 || phase==0;

#endif

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i, j, k;
  Ddi_Bdd_t *lit;

  int myDbg = 0, nCached = 0;

  Ddi_Bdd_t *a2;
  Ddi_Bddarray_t *eqRelArray=NULL;
  int nVars = Ddi_VararrayNum(aVars), nSuppVars;
  unsigned char *doAbstr = Pdtutil_Alloc(unsigned char, nVars);
  double time_limit=-1.0, prev_cex_time_limit=0.1;
  Solver    S;
  vec<Lit> lits, assumeSingleAbstrArray;
  vec<Lit> prevCex;
  int prevCexUsed = 0;
  Ddi_Varset_t *aSupp, *bSupp, *aVarsSet, *bVarsSet;
  int assumeSingleAbstr, *assumeAbstr;
  int redCodeSize, refinementDone, nCurrAbstr, nInitialAbstr;
  int checkSingleAbstr;
  int *redCodeBits=NULL, *redCodeLimit=NULL, *remapVars;
  int mask, nPi, *piCnfIds=NULL, nEnVars;
  Ddi_Vararray_t *piNodes;
  Ddi_Varset_t *piSet;
  int undefinedResult = 0;
  Ddi_Bddarray_t *abstrVarLit;
  Ddi_Vararray_t *vSubst;
  int doEval=1, goAhead=1, refineUndef=0;
  int fastRun = 0;

  Ddi_Varset_t *supp;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);

  long startTimeTot=0;
  int findMultipleByRedCode = 0;
  int forceValidated = 0;

  if (phase >= 4) {
    fastRun = 1;
    phase -= 4;
    prev_cex_time_limit /= 4;
  }

  nCurrAbstr = 0;
  nInitialAbstr = 0;


  startTimeTot = util_cpu_time();

  if (ddm->settings.aig.satTimeout) {
    time_limit = fastRun ? 3.0 : 10.0;
    if (ddm->settings.aig.satTimeout>1) {
      time_limit /= 5;
      if (ddm->settings.aig.satTimeout>2) {
        time_limit /= 5;
      }
    }
  }


  Pdtutil_Assert(nVars==Ddi_VararrayNum(bVars),"Wrong var array size");
  Pdtutil_Assert(nVars==Ddi_VararrayNum(auxVars),"Wrong var array size");

  if (Ddi_BddIsZero(a) || Ddi_BddIsZero(b)) {
    for (i=0; i<nVars; i++) {
      doAbstrOut[i] = 1;
      enAbstrIn[i] = 0;
    }
    if (nInitAbstrP != NULL) {
      *nInitAbstrP = nVars;
    }
    if (nAbstrP != NULL) {
      *nAbstrP = 0;
    }
    return (Ddi_BddDup(a));
  }
  if (Ddi_BddIsOne(a) && Ddi_BddIsOne(b)) {
    return (NULL);
  }

  aSupp = Ddi_BddSupp(a);
  bSupp = Ddi_BddSupp(b);

  aVarsSet = Ddi_VarsetMakeFromArray(aVars);
  bVarsSet = Ddi_VarsetMakeFromArray(bVars);

  piSet = Ddi_VarsetDiff(bSupp,bVarsSet);

  Ddi_VarsetIntersectAcc(aSupp,aVarsSet);
  Ddi_VarsetIntersectAcc(bSupp,bVarsSet);

  Ddi_Free(aVarsSet);
  Ddi_Free(bVarsSet);

  nSuppVars = Ddi_VarsetNum(aSupp);

  aig2CnfIdInit(ddm);

  MinisatClauses(S,a,NULL,NULL,0);
  MinisatClauses(S,b,NULL,NULL,0);

  eqRelArray = Ddi_BddarrayAlloc(ddm,0);

  for (i=0; i<nVars; i++) {
    Ddi_Bdd_t *wire, *eqRel;
    Ddi_Var_t *aV = Ddi_VararrayRead(aVars,i);
    Ddi_Var_t *bV = Ddi_VararrayRead(bVars,i);
    Ddi_Var_t *auxV = Ddi_VararrayRead(auxVars,i);
    if (!enAbstrIn[i]) continue;
    doAbstr[i] = 1;
    if (!(Ddi_VarInVarset(aSupp,aV)&&Ddi_VarInVarset(bSupp,bV))) {
      doAbstrOut[i] = 1;
      enAbstrIn[i] = 0;
      nInitialAbstr++;

      continue;
    }
    doAbstr[i] = 0;
    lit = Ddi_BddMakeLiteralAig(bV,1);
    wire = Ddi_BddMakeLiteralAig(aV,1);
    eqRel = Ddi_BddMakeLiteralAig(auxV,1);
    Ddi_BddXnorAcc(wire,lit);
    Ddi_Free(lit);
    Ddi_BddXnorAcc(eqRel,wire);
    Ddi_Free(wire);
    Ddi_BddarrayInsertLast(eqRelArray,eqRel);
    MinisatClauses(S,eqRel,NULL,NULL,0);
    {
      int id = aig2CnfId(bmgr,Ddi_VarToBaig(auxV));
      id = aig2CnfId(bmgr,Ddi_VarToBaig(aV));
      id = aig2CnfId(bmgr,Ddi_VarToBaig(bV));
    }
    Ddi_Free(eqRel);
  }

  Ddi_Free(eqRelArray);

  nEnVars=0;
  for (i=0; i<nVars; i++) {
    nEnVars += enAbstrIn[i];
  }
  remapVars = Pdtutil_Alloc(int, nEnVars);
  for (i=j=0; i<nVars; i++) {
    if (enAbstrIn[i]) {
      remapVars[j++] = i;
    }
  }
  Pdtutil_Assert(j==nEnVars,"wrong number of enabled vars");

  S.newVar();
  assumeSingleAbstr = S.nVars();
  assumeSingleAbstrArray.clear();
  assumeSingleAbstrArray.push(MinisatLit(assumeSingleAbstr));

  assumeAbstr = Pdtutil_Alloc(int, nVars);

  redCodeSize=1;
  for (j=1; j<nEnVars+1; j = j<<1) {
    redCodeSize++;
  }
  redCodeBits = Pdtutil_Alloc(int, redCodeSize);
  redCodeLimit = Pdtutil_Alloc(int, redCodeSize);
  for (j=0; j<redCodeSize; j++) {
    S.newVar();
    redCodeBits[j] = S.nVars();
    S.newVar();
    redCodeLimit[j] = S.nVars();
  }


  for (i=j=0; i<nVars; i++) {
    int k, vCnf, vAuxCnf, tCnf;
    Ddi_Var_t *aV = Ddi_VararrayRead(aVars,i);
    Ddi_Var_t *bV = Ddi_VararrayRead(bVars,i);
    Ddi_Var_t *auxV = Ddi_VararrayRead(auxVars,i);
    vec<Lit> constrClause;

    int eqId = aig2CnfId(bmgr,Ddi_VarToBaig(auxV));

    if (!enAbstrIn[i]) continue;

    assumeAbstr[i] = -1;

    assumeAbstr[i] = eqId;
    nCurrAbstr++;

    Pdtutil_Assert(remapVars[j]==i,"wrong var remapping");

    if (findMultipleByRedCode) {
      /* redCode[j] => assumeSingleAbstr + !eqId */
      constrClause.clear();
      constrClause.push(MinisatLit(-eqId));
      constrClause.push(MinisatLit(assumeSingleAbstr));
    }
    for (k=0, mask=1; k<redCodeSize; k++) {
      int bit = (j&mask) ? redCodeBits[k] : -redCodeBits[k];
      /* !eqId => !assumeSingleAbstr + bit */
      MinisatClause3(S,lits,eqId,-assumeSingleAbstr,bit);
      if (findMultipleByRedCode) {
	constrClause.push(MinisatLit(-bit));
      }
      mask = mask<<1;
    }
    if (findMultipleByRedCode) {
      S.addClause(constrClause);
    }
    j++; /* remapping index */
  }

  /* redcode upper limit */

#if 1
  for (i=0, mask=1; i<redCodeSize; i++) {
    int bit = ((nEnVars+1)&mask);
      /* redCodeLimit[i] => bit ?
	 (!redCodeBit[i] | redcodeLimit[i-1]) :
	 (!redCodeBit[i] & redcodeLimit[i-1]) */
    if (i==0) {
      /* redCodeLimit[0] => bit & !redCodeBit[0] */
      if (bit) {
        MinisatClause2(S,lits,-redCodeLimit[0],-redCodeBits[0]);
      }
      else {
        MinisatClause1(S,lits,-redCodeLimit[0]);
      }
    }
    else if (bit) {
      MinisatClause3(S,lits,
        -redCodeLimit[i],-redCodeBits[i],redCodeLimit[i-1]);
    }
    else {
      MinisatClause2(S,lits,-redCodeLimit[i],-redCodeBits[i]);
      MinisatClause2(S,lits,-redCodeLimit[i],redCodeLimit[i-1]);
    }
    mask = mask<<1;
  }
  MinisatClause1(S,lits,redCodeLimit[i-1]);
#endif
  prevCexUsed = 0;
  prevCex.clear();

  checkSingleAbstr = 0;
  if (phase != 1) {
    checkSingleAbstr = 1;
    assumeSingleAbstrArray.copyTo(prevCex);
  }

  piNodes = Ddi_VararrayMakeFromVarset(piSet,1);
  Ddi_Free(piSet);
  nPi = Ddi_VararrayNum(piNodes);
  piCnfIds = Pdtutil_Alloc(int,nPi);

  for (i=0; i<nPi; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(piNodes,i);
    bAigEdge_t baig = Ddi_VarToBaig(v);
    piCnfIds[i] = aig2CnfId(bmgr,baig);
  }

  aig2CnfIdClose(ddm);

  do {
    int id;
    int sat;
    refinementDone = 0;

    /* call SAT solver assuming at least one refinement */
    if ((sat = S.okay())) {
      sat = S.solve(prevCex,(prevCexUsed&&refineUndef==0)?prev_cex_time_limit:
                    (checkSingleAbstr?time_limit:(5*time_limit)));
      if (0 && S.undefined()) {
        sat = S.solve(prevCex,(prevCexUsed&&refineUndef==0)?prev_cex_time_limit:
                    (checkSingleAbstr?time_limit:(5*time_limit)));
      }
      sat = sat && !S.undefined();
      if (S.undefined() && !prevCexUsed) {
        undefinedResult = 1;
	if ((phase==0 || phase==2) && refineUndef==0) {
	  refineUndef = 1;
	}
      }
    }

    if (sat) {
      /* a non redundant ternary node has been found: fix it and iterate */
      int k, mask, redIndex=0;
      Lit wireLit;
      int t, eqId;

      if (checkSingleAbstr) {
        if (nCurrAbstr==0) {
	  /* problem is SAT! Disable abstraction */
	  doEval=0;
          break;
	}

        for (k=0, mask=1; k<redCodeSize; k++) {
	  if (S.model[redCodeBits[k]-1]==l_True) {
	    redIndex += mask;
	  }
          mask = mask<<1;
        }
        refinementDone = 1;

        j=redIndex;
        if (j>nEnVars) {
	  /* problem is SAT! Disable abstraction */
	  doEval=0;
          break;
	}
	i = remapVars[j];
	eqId = assumeAbstr[i];

	t = eqId - 1;

        if (i>nVars || doAbstr[i] || eqId<0 || S.model[t]==l_True) {
	  /* problem is SAT! Disable abstraction */
	  doEval=0;
          break;
	}

	//        Pdtutil_Assert(eqId > 0,"enabled eq control required");


        Pdtutil_Assert(S.model[t]==l_False,"missing eq Abstr control set");

        MinisatClause1(S,lits,eqId);
	assumeAbstr[i] = -1; /* disable it !!! */
	doAbstr[i] = 0;

        doAbstrOut[i] = 0;

	nCurrAbstr--;

        if (!prevCexUsed) {
	  prevCexUsed = 1;

	  for (k=0; k<nPi; k++) {
	    int piCnf = piCnfIds[k];
	    int pi = piCnf-1;
            if (S.model[pi]==l_False) {
	      piCnf = -piCnf;
	    }
	    prevCex.push(MinisatLit(piCnf));
	  }
        }
        else {
	  nCached++;
        }

      }
      else {
	int doScan = 1;
        refinementDone = 1;

	if (refineUndef==1) {
	  Pdtutil_Assert(!prevCexUsed,"wrong prevcex handling");
	  prevCexUsed = 1;
	  assumeSingleAbstrArray.copyTo(prevCex);
	  for (k=0; 0&&k<nPi && k<200; k+=2) {
	    int piCnf = piCnfIds[k];
	    int pi = piCnf-1;
            if (S.model[pi]==l_False) {
	      piCnf = -piCnf;
	    }
	    prevCex.push(MinisatLit(piCnf));
	  }
	  refineUndef = 2;
	  checkSingleAbstr = 1;
	}
	else if (findMultipleByRedCode) {

          for (k=0, mask=1; k<redCodeSize; k++) {
	    if (S.model[redCodeBits[k]-1]==l_True) {
	      redIndex += mask;
	    }
            mask = mask<<1;
          }
	  //        refinementDone = 1;

          j=redIndex;

	  if (j<nEnVars) {
	    doScan = 0;

	    //            Pdtutil_Assert (j<nEnVars,"invalid counter value");
	    i = remapVars[j];

	    eqId = assumeAbstr[i];
	    Pdtutil_Assert (eqId > 0,"invalid redcode");

	    Pdtutil_Assert(enAbstrIn[i] && !doAbstr[i], "wrong redcode");

	    t = eqId - 1;
	    Pdtutil_Assert (S.model[t]==l_False, "model not false for redcode");
	    /* remove this ternary  */
	    MinisatClause1(S,lits,eqId);
	    assumeAbstr[i] = -1; /* disable it !!! */
	    doAbstr[i] = 0;
	    nCurrAbstr--;
	  }
	}
	else if (doScan) {

	  int nCex=0, last_i=-1, last_eqId=-1;
	for (j=0; j<nVars; j++) {
	  Lit wireLit;
	  int id, wCnf, k, mask, refCnf;

      	  i = (!up_down) ? j : nVars-1-j;

	  if (!enAbstrIn[i] || doAbstr[i]) {
	    /* already abstracted var */
	    continue;
	  }

	  eqId = assumeAbstr[i];
	  if (eqId < 0) continue;

	  t = eqId - 1;
#if 1
	  if (S.model[t]==l_False) {
	    /* remove this ternary  */
	    MinisatClause1(S,lits,eqId);
	    assumeAbstr[i] = -1; /* disable it !!! */
	    doAbstr[i] = 0;
	    nCurrAbstr--;
	    break;
	  }
#else
	  if (S.model[t]==l_False) {
	    /* remove this ternary  */
	    last_i = i;
	    nCex++;
	    last_eqId = eqId;
	  }
#endif
	}
#if 0
	Pdtutil_Assert(nCex>0,"wrong model for reused CEX");
	    MinisatClause1(S,lits,last_eqId);
	    assumeAbstr[last_i] = -1; /* disable it !!! */
	    doAbstr[last_i] = 0;
	    fprintf(dMgrO(ddm),"active CEX: %d/%d\n", nCex, nCurrAbstr);
	    nCurrAbstr--;

#else
        if (j>=nVars) {
	  /* SAT result! return NULL */
	  doEval=0;
          break;
	}
	Pdtutil_Assert(j<nVars,"wrong model for reused CEX");
	Pdtutil_Assert(i>=0&&i<nVars,"wrong model for reused CEX");
#endif
	}
      }

    }
    else if (prevCexUsed) {
      refinementDone = 1;
      prevCexUsed = 0;
      prevCex.clear();
      assumeSingleAbstrArray.copyTo(prevCex);
    }
    else {
      if (checkSingleAbstr && nCurrAbstr>0) {
	checkSingleAbstr = 0;
        refinementDone = 1;
        prevCex.clear();
	if (phase == 0 && !(refineUndef==1)) {
	  goAhead = 0; /* disable second phase */
          /* no refinement possible with SAT */
          fprintf(dMgrO(ddm),"\nDYNABSTR by ref. found %d/%d single red. (cach: %d) - ",
		 nCurrAbstr, nVars-nInitialAbstr, nCached); fflush(dMgrO(ddm));
	}
	else if (refineUndef==1) {
          fprintf(dMgrO(ddm),"\nDYNABSTR by ref. is refining %d/%d undef red. (cach: %d) - ",
		 nCurrAbstr, nVars-nInitialAbstr, nCached); fflush(dMgrO(ddm));
	}
      }
      else if (S.undefined()) {
	undefinedResult = 1;
        /* no refinement possible with SAT */
        fprintf(dMgrO(ddm),"\nDYNABSTR by refinement found %d/%d UNDEFINED reductions - ",
	       nCurrAbstr, nVars-nInitialAbstr); fflush(dMgrO(ddm));
      }
      else {
        /* no refinement possible with SAT */
        fprintf(dMgrO(ddm),"\nDYNABSTR by refinement found %d/%d reductions - ",
	       nCurrAbstr, nVars-nInitialAbstr); fflush(dMgrO(ddm));
      }
    }

  } while (goAhead && refinementDone /* && nCurrAbstr > 0 */);

  //  aig2CnfIdClose(ddm);
  if (nInitAbstrP != NULL) {
    *nInitAbstrP = nInitialAbstr;
  }

  for (i=0; i<nVars; i++) {
    if (enAbstrIn[i] && (assumeAbstr[i]>=0)) {
      doAbstr[i] = 1;
      if (phase > 0) {
        doAbstrOut[i] = 1;
        enAbstrIn[i] = 0;
      }
    }
  }

#if 0
  {
    Ddi_Bddarray_t *Lits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
    Ddi_Bddarray_t *LitsAux = Ddi_BddarrayMakeLiteralsAig(vA, 0);
    Ddi_Bdd_t *zeroAig = Ddi_BddMakeConstAig(ddm,0);

    for (i=0; i<nVars; i++) {
      int tCnf = assumeAbstr[i];
      if (tCnf >= 0 || checkMonotonicity) {
	Ddi_BddarrayWrite(Lits,i,zeroAig);
	Ddi_BddarrayWrite(LitsAux,i,zeroAig);
        if (ternarySmooth != NULL) {
	  Ddi_VarsetAddAcc(ternarySmooth,Ddi_VararrayRead(vA,i));
	}
      }
    }
    Ddi_BddComposeAcc(newaAig,vA,Lits);
    Ddi_BddComposeAcc(newaAig,vAuxA,LitsAux);
    if (newbAig != NULL) {
      Ddi_BddComposeAcc(newbAig,vA,Lits);
      Ddi_BddComposeAcc(newbAig,vAuxA,LitsAux);
    }

    if (Ddi_BddSize(newaAig) > Ddi_BddSize(a)) {
      DdiAigRedRemovalAcc (newaAig,care,1000,travMgr->settings.lazyTimeLimit);
    }
    if (Ddi_BddSize(newaAig) > Ddi_BddSize(a)) {
      fprintf(dMgrO(ddm),"INCREASED SIZE\n");
      Ddi_Free(newaAig);
      newaAig = Ddi_BddDup(a);
    }
    Ddi_Free(zeroAig);
    Ddi_Free(Lits);
    Ddi_Free(LitsAux);
  }

  if (newbAig != NULL) {
    prod = Ddi_BddAnd(newaAig,newbAig);
  }
  else {
    prod = Ddi_BddAnd(newaAig,b);
  }
  if (care != NULL) {
    Ddi_BddAndAcc(prod,care);
  }

  if (1&&undefinedResult) {
    if (!Ddi_AigSat(prod)) {
      fprintf(dMgrO(ddm),"validated UNDEFINED ternary interpolation\n");
    }
    else {
      Ddi_Free(newaAig);
      newaAig = Ddi_BddDup(a);
    }
  }

  Pdtutil_Assert(!checkFunction || !Ddi_AigSat(prod),
    "Wrong ternary interpolation\n");

  fprintf(dMgrO(ddm),"size %d->%d\n", size0, Ddi_BddSize(newaAig));
  if (0&&newbAig!=NULL)
    fprintf(dMgrO(ddm),"\nTERNARY_ITP(B) conv. size %d->%d\n",
      size0b, Ddi_BddSize(newbAig));

  Ddi_Free(newbAig);
#endif

  /* free aig0 aig1 */

  if (undefP != NULL) {
    *undefP = undefinedResult;
  }
  if (nAbstrP != NULL) {
    *nAbstrP = nCurrAbstr;
  }
  if (!doEval) {
    a2 = NULL;
  }
  else if (phase == 1) {
    a2 = Ddi_BddDup(a);
  }
  else {
    abstrVarLit = Ddi_BddarrayAlloc(ddm,0);
    vSubst = Ddi_VararrayAlloc(ddm,0);

    for (i=nVars-1; i>=0; i--) {
      Ddi_Var_t *aV = Ddi_VararrayRead(aVars,i);
      Ddi_Var_t *bV = Ddi_VararrayRead(bVars,i);
      if (enAbstrIn[i] && !doAbstr[i]) {
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(bV,1);
        Ddi_BddarrayInsertLast(abstrVarLit,lit);
        Ddi_Free(lit);
        Ddi_VararrayInsertLast(vSubst,aV);
  	//    	printf("%s ",Ddi_VarName(bV));
        enAbstrIn[i] = 0;
      }
    }

    a2 = Ddi_BddCompose(a,vSubst,abstrVarLit);

    Ddi_Free(vSubst);
    Ddi_Free(abstrVarLit);

    if (phase != 0 && undefinedResult) {
      if (forceValidated||!Ddi_AigSatAnd(a2,b,NULL)) {
        fprintf(dMgrO(ddm),"validated UNDEFINED dynamic abstraction\n");
      }
      else {
	abstrVarLit = Ddi_BddarrayMakeLiteralsAig(bVars, 1);
        Ddi_Free(a2);
	a2 = Ddi_BddCompose(a,aVars,abstrVarLit);
	Ddi_Free(abstrVarLit);
      }
    }
  }

  Ddi_Free(aSupp);
  Ddi_Free(bSupp);
  Pdtutil_Free(doAbstr);
  Pdtutil_Free(piCnfIds);
  Pdtutil_Free(assumeAbstr);
  Pdtutil_Free(redCodeBits);
  Pdtutil_Free(redCodeLimit);
  Pdtutil_Free(remapVars);
  Ddi_Free(piNodes);

  return a2;

}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigAbstrVarsForInterpolant (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Vararray_t *aVars,
  Ddi_Vararray_t *bVars,
  Ddi_Vararray_t *auxVars,
  char *wfileName,
  unsigned char *enAbstr,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i, j;
  Ddi_Bdd_t *a2;
  Ddi_Bdd_t *lit;
  Ddi_Bddarray_t *abstrVarLit;
  Ddi_Vararray_t *vSubst, *abVars;
  Ddi_Varset_t *aSupp, *bSupp, *abSupp, *aVarsSet, *bVarsSet;
  int abstrCnt=0, nInitialAbstr=0;
  int nVars = Ddi_VararrayNum(aVars), nSuppVars;
  unsigned char *doAbstr = Pdtutil_Alloc(unsigned char, nVars);
  Ddi_Bddarray_t *eqRelArray=NULL;
  Solver    S;
  vec<Lit> lits;
  vec<Lit> assumps, possibleAssumps, totAssumps, assumpsReverse;
  FILE *fp=NULL;
  Var *minisatAV, *minisatBV;
  int strategy = Ddi_MgrReadAigDynAbstrStrategy(ddm);
  int enableTimeout = 0 || ddm->settings.aig.satTimeout;
  int doEval=1, doEvalAbstr=0;
  long cpuTime, startTime;
  double timeLimit=-1.0;
  double totTimeLimit=30.0;
  int satIncremental = ddm->settings.aig.satIncremental;
  int doAbort = 0, sizeA, sizeB;
  Ddi_Bdd_t *aa=NULL;

  if (pAbort != NULL) *pAbort = 0;

  Pdtutil_Assert(nVars==Ddi_VararrayNum(bVars),"Wrong var array size");
  Pdtutil_Assert(nVars==Ddi_VararrayNum(auxVars),"Wrong var array size");

  if (Ddi_BddIsZero(a) || Ddi_BddIsZero(b)) {
    return (Ddi_BddDup(a));
  }
  if (Ddi_BddIsOne(a) && Ddi_BddIsOne(b)) {
    return (Ddi_BddDup(a));
  }

  minisatAV = Pdtutil_Alloc(Var, nVars);
  minisatBV = Pdtutil_Alloc(Var, nVars);

  aSupp = Ddi_BddSupp(a);
  bSupp = Ddi_BddSupp(b);

  aVarsSet = Ddi_VarsetMakeFromArray(aVars);
  bVarsSet = Ddi_VarsetMakeFromArray(bVars);

  Ddi_VarsetIntersectAcc(aSupp,aVarsSet);
  Ddi_VarsetIntersectAcc(bSupp,bVarsSet);

  Ddi_Free(aVarsSet);
  Ddi_Free(bVarsSet);

  nSuppVars = Ddi_VarsetNum(aSupp);

  Ddi_VarsetSetArray(aSupp);
  Ddi_VarsetSetArray(bSupp);

  abSupp = Ddi_VarsetUnion(aSupp,bSupp);
  abVars = Ddi_VararrayMakeFromVarset(abSupp,1);

  aa = Ddi_AigPartitionTop(a,0);

  sizeA = Ddi_BddSize(aa);
  sizeB = Ddi_BddSize(b);
  aig2CnfIdInitDecr(ddm,2*(sizeA+sizeB)/3);
  //  aig2CnfIdInit(ddm);

  if (sizeA>0) {
    MinisatClauses(S,aa,NULL,NULL,0);
  }
  else {
    Pdtutil_Assert(!Ddi_BddIsZero(a),"zero from in dyn abstr");
  }
  MinisatClauses(S,b,NULL,NULL,0);

  assumps.clear();
  eqRelArray = Ddi_BddarrayAlloc(ddm,0);

  for (i=0; i<nVars; i++) {
    Ddi_Bdd_t *wire, *eqRel;
    Ddi_Var_t *aV = Ddi_VararrayRead(aVars,i);
    Ddi_Var_t *bV = Ddi_VararrayRead(bVars,i);
    Ddi_Var_t *auxV = Ddi_VararrayRead(auxVars,i);
    doAbstr[i] = 1;
    if (!(Ddi_VarInVarset(aSupp,aV)&&Ddi_VarInVarset(bSupp,bV))) {
      nInitialAbstr++;
      continue;
    }
    doAbstr[i] = 0;
    lit = Ddi_BddMakeLiteralAig(bV,1);
    wire = Ddi_BddMakeLiteralAig(aV,1);
    eqRel = Ddi_BddMakeLiteralAig(auxV,1);
    Ddi_BddXnorAcc(wire,lit);
    Ddi_Free(lit);
    Ddi_BddXnorAcc(eqRel,wire);
    Ddi_Free(wire);
    Ddi_BddarrayInsertLast(eqRelArray,eqRel);
    MinisatClauses(S,eqRel,NULL,NULL,0);
    {
      int id = aig2CnfId(bmgr,Ddi_VarToBaig(auxV));
      Lit l = MinisatLit(id);
      assumps.push(l);
      id = aig2CnfId(bmgr,Ddi_VarToBaig(aV));
      minisatAV[i]=var(MinisatLit(id));
      id = aig2CnfId(bmgr,Ddi_VarToBaig(bV));
      minisatBV[i]=var(MinisatLit(id));
    }
    Ddi_Free(eqRel);
  }

  Ddi_Free(eqRelArray);
  Ddi_Free(aa);

  if (ddm->settings.aig.satVarActivity < 0) {
    int nCommon=0;
    int act = -ddm->settings.aig.satVarActivity;
    for (i=0; 1&&i<Ddi_VararrayNum(abVars); i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(abVars,i);
      bAigEdge_t varIndex = Ddi_VarToBaig(v);
      int vCnf = aig2CnfId(bmgr,varIndex);
      if (doAbstr[i]) continue;
      S.varBumpActivityExternal(MinisatLit(vCnf),act);
      Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
      nCommon++;
    }
    //    printf("COMMONVARS: %d\n", nCommon);
    act /= 10;
    for (i=0; 1&&i<Ddi_VararrayNum(auxVars); i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(auxVars,i);
      bAigEdge_t varIndex = Ddi_VarToBaig(v);
      int vCnf = aig2CnfId(bmgr,varIndex);
      if (doAbstr[i]) continue;
      S.varBumpActivityExternal(MinisatLit(vCnf),act);
      Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
    }
  }

  aig2SatActivity(ddm, &S);
  for (i=0; 0&&i<Ddi_VararrayNum(abVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(abVars,i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    int vCnf = aig2CnfId(bmgr,varIndex);
    double act = v->common.info->var.activity;
    S.varBumpActivityExternal(MinisatLit(vCnf),act);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
  }

  if (enableTimeout < 0) {
    enableTimeout *= -1;
    cpuTime = 10000.0;
  }
  else if (1||enableTimeout /* always enabled */) {
    int sat;
    S.minisat20_opt = true;
    if ((sat = S.okay())) {
      startTime = util_cpu_time ();
      if (enableTimeout && strategy==0) {
        sat = S.solve(assumps,200.0);
      }
      else {
        sat = S.solve(assumps);
      }
      cpuTime = util_cpu_time () - startTime;
    }
    S.minisat20_opt = false;
    if (sat) {
      doEval=0;
    }
    else if (S.undefined()) {
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c,
        fprintf(dMgrO(ddm),"DYN ABSTR ABORTED\n"));
      doAbort=1;
    }
    else if (strategy > 0) {
      int j;
      int nkeep = 0;
      doEval = 0;
      doEvalAbstr = 1;
      for (i=j=0; i<nVars; i++) {
        if (! doAbort && !doAbstr[i] && (enAbstr==NULL || enAbstr[i])) {
          int sat, k;
          Lit lit;

          lit = assumps[j++];
	  doAbstr[i]=1;
	  for (k=0; k<S.conflict.size(); k++) {
	    Lit kLit = S.conflict[k];
	    if (var(kLit) == var(lit)) {
	      nkeep++;
	      doAbstr[i]=0;
	      break;
	    }
	  }
	}
      }
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMin_c,
        fprintf(dMgrO(ddm),"DYN ABSTR KEPT %d/%d vars (time: %s)\n",
                nkeep, assumps.size(), util_print_time(cpuTime)));
    }
  }

  //  sat2AigActivity(ddm, &S);
  for (i=0; 0&&i<Ddi_VararrayNum(abVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(abVars,i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    int vCnf = aig2CnfId(bmgr,varIndex);
    double act = S.varReadActivityExternal(MinisatLit(vCnf)) / 1000.0;
    if (1) {
      //      if (act > 1000) act = 1000;
      v->common.info->var.activity += act;
      //      if (v->common.info->var.activity > 1000)
      //  v->common.info->var.activity = 1000;
    }
    S.varBumpActivityExternal(MinisatLit(vCnf),act);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
  }

  aig2CnfIdClose(ddm);

  if (doEval) {
    int nactive=0;
    unsigned char *activeV = Pdtutil_Alloc(unsigned char, nVars);
    possibleAssumps.clear();
    if (enableTimeout) {
      timeLimit = (cpuTime/1000.0 /* milliseconds -> seconds */)/10.0;
      if (enableTimeout>1) {
	timeLimit /= 5;
        if (enableTimeout>2) {
	  timeLimit /= 5;
        }
      }
    }

    startTime = util_cpu_time ();

    if (strategy==0) {
      for (i=nVars-1; i>=0; i--) {
        activeV[i] = 0;
        if (! doAbort && !doAbstr[i] && (enAbstr==NULL || enAbstr[i])) {
          int sat, k;
          Lit saveLit;

          j = assumps.size()-1;
          saveLit = assumps[j];
          assumps.pop();

          totAssumps.clear();
          assumps.copyTo(totAssumps);
	  for (k=0; k<possibleAssumps.size();k++) {
	    totAssumps.push(possibleAssumps[k]);
	  }

	  cpuTime = util_cpu_time () - startTime;
	  if (cpuTime > totTimeLimit*1000) {
	    doAbort = 1;
	  }
	  else if ((sat = S.okay())) {
	    if (!satIncremental) {
	      S.resetDB();
	    }
	    sat = S.solve(totAssumps,timeLimit);
	  }

          if (doAbort || S.undefined()) {
      	    possibleAssumps.push(saveLit);
            doAbstr[i]=0;
            activeV[i] = 1;
            nactive++;
          }
          else if (!sat) {
            /* still UNSAT! Can do abstraction */
            doAbstr[i]=1;
      	    abstrCnt++;
          }
          else {
      	    /* SAT: invalid abstraction */
      	    lits.clear();
      	    lits.push(saveLit);
            S.addClause(lits);
      	    //	enAbstr[i]=0;
          }
        }
      }
    }
    if (!doAbort && enableTimeout && nactive > 0) {
      int again;
      do {
        int sat;
        again = 1;
        if ((sat = S.okay())) {
          sat = S.solve();
        }
        if (!sat) {
      	  /* abstraction found: quit loop */
    	  again = 0;
        }
        else {
    	  /* seek first abstraction to fix */
    	  int ndiff=0;
	  /* possible assumptions are in reverse order */
	  j=possibleAssumps.size()-1;
	  Pdtutil_Assert(j==nactive-1,"wrong active posible assumptions");
          for (i=0; i<nVars; i++) {
            if (doAbstr[i] || (enAbstr!=NULL && !enAbstr[i])) continue;
    	    if (activeV[i]) {
    	      if ((S.model[minisatAV[i]] != l_Undef) &&
                  (S.model[minisatBV[i]] != l_Undef) &&
                  (S.model[minisatAV[i]] != S.model[minisatBV[i]])) {
		int l;
    	        activeV[i]=0;
    	        ndiff++;
    	        nactive--;
    	        lits.clear();
	        Pdtutil_Assert(j>=0,"missing possible assumption");
    	        lits.push(possibleAssumps[j]);
    	        S.addClause(lits);
		/* reove assumption */
		for (l=j; l<possibleAssumps.size()-1;l++) {
		  possibleAssumps[l]=possibleAssumps[l+1];
		}
		possibleAssumps.pop();
    	        break;
	      }
      	      j--;
	    }
    	  }
    	  again = (nactive>0 && ndiff>0);
        }
      } while (again);
      /* record abstractions from active array */
      for (i=0; i<nVars; i++) {
        if (activeV[i]) {
          doAbstr[i]=1;
      	  abstrCnt++;
        }
      }
      Pdtutil_Free(activeV);
    }

    if (pAbort != NULL) *pAbort = doAbort;

    if (wfileName != NULL) {
      fp = fopen (wfileName,"w");
      if (fp == NULL) {
        fprintf(dMgrO(ddm),"error opening %s\n", wfileName);
        return NULL;
      }
    }

  }

  if (doEval || doEvalAbstr) {

    abstrVarLit = Ddi_BddarrayAlloc(ddm,0);
    vSubst = Ddi_VararrayAlloc(ddm,0);

    //    	printf("\n");
    for (i=nVars-1; !doAbort && i>=0; i--) {
      Ddi_Var_t *aV = Ddi_VararrayRead(aVars,i);
      Ddi_Var_t *bV = Ddi_VararrayRead(bVars,i);
      if (!doAbstr[i]) {
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(bV,1);
        Ddi_BddarrayInsertLast(abstrVarLit,lit);
        Ddi_Free(lit);
        Ddi_VararrayInsertLast(vSubst,aV);
	//    	printf("%s ",Ddi_VarName(bV));
      }
      else {
        if (fp!=NULL) {
    	fprintf(fp,"%s\n",Ddi_VarName(bV));
        }
      }
    }

    //    	printf("\n");
    if (fp!=NULL) {
      fclose(fp);
    }

    a2 = Ddi_BddCompose(a,vSubst,abstrVarLit);

    Ddi_Free(vSubst);
    Ddi_Free(abstrVarLit);
  }
  else {
    a2=NULL;
  }

  if (doEval && abstrCnt+nInitialAbstr > 0) {
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c,
        fprintf(dMgrO(ddm),"Interpolant DYN ABSTR: %d/%d (%d initial)\n",
        abstrCnt, nVars-nInitialAbstr, nInitialAbstr));
#if 0
    fprintf(dMgrO(ddm),"Abstr mask: ");
    for (i=0; i<nVars; i++) {
      fprintf(dMgrO(ddm),"%d", doAbstr[i]);
    }
    fprintf(dMgrO(ddm),"\n");
#endif
  }

  Ddi_Free(aSupp);
  Ddi_Free(abSupp);
  Ddi_Free(abVars);
  Ddi_Free(bSupp);
  Pdtutil_Free(doAbstr);
  Pdtutil_Free(minisatAV);
  Pdtutil_Free(minisatBV);


  return(a2);

}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Varset_t *
Ddi_AigAbstrVarsIncremental (
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *vars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i, j;
  Ddi_Varset_t *fSupp, *varsSet, *resSet;
  int abstrCnt=0;
  int nVars = Ddi_VararrayNum(vars), nSuppVars;
  unsigned char *doAbstr = Pdtutil_Alloc(unsigned char, nVars);
  Solver    S;
  vec<Lit> lits;
  vec<Lit> assumps, assumpsReverse;
  Ddi_Bdd_t * c0;
  Ddi_Bdd_t * c1;


  if (Ddi_BddIsOne(f)) {
    return (Ddi_VarsetVoid(ddm));
  }

  resSet = Ddi_VarsetMakeFromArray(vars);
  if (Ddi_BddIsZero(f)) {
    return (resSet);
  }

  varsSet = Ddi_VarsetMakeFromArray(vars);
  c0 = Ddi_BddMakeConstAig(ddm,0);
  c1 = Ddi_BddMakeConstAig(ddm,1);

  fSupp = Ddi_BddSupp(f);
  Ddi_VarsetDiffAcc(resSet,fSupp);
  Ddi_VarsetIntersectAcc(fSupp,varsSet);
  Ddi_Free(varsSet);
  nSuppVars = Ddi_VarsetNum(fSupp);

  aig2CnfIdInit(ddm);

  MinisatClauses(S,f,NULL,NULL,0);

  assumps.clear();

  for (i=0; i<nVars; i++) {
    Ddi_Var_t *V = Ddi_VararrayRead(vars,i);
    doAbstr[i] = 1;
    if (!(Ddi_VarInVarset(fSupp,V))) continue;
    doAbstr[i] = 0;
    {
      int id = aig2CnfId(bmgr,Ddi_VarToBaig(V));
      Lit l = MinisatLit(-id);
      assumps.push(l);
    }
  }

  aig2CnfIdClose(ddm);

  for (i=nVars-1; i>=0; i--) {
    if (!doAbstr[i]) {
      int sat;
      Lit saveLit;

      j = assumps.size()-1;
      saveLit = assumps[j];
      assumps.pop();

      if ((sat = S.okay())) {
        sat = S.solve(assumps);
      }
      if (!sat) {
	/* still UNSAT! Can do abstraction */
	doAbstr[i]=1;
	abstrCnt++;
      }
      else {
	/* SAT: invalid abstraction */
	lits.clear();
	lits.push(saveLit);
        S.addClause(lits);
      }
    }
  }

  for (i=0; i<nVars; i++) {
    Ddi_Var_t *V = Ddi_VararrayRead(vars,i);
    if (doAbstr[i]) {
      Ddi_VarsetAddAcc(resSet,V);
    }
  }
  Ddi_Free(fSupp);
  Ddi_Free(c0);
  Ddi_Free(c1);

  return(resSet);

}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigOptByEquiv(
  Ddi_Bdd_t *fAig,
  Ddi_Bddarray_t *representatives,
  Ddi_Bddarray_t *equalNodes
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Bddarray_t *aux = Ddi_BddarrayAlloc(ddm, 1);

  Ddi_BddarrayWrite(aux, 0, fAig);
  Ddi_AigarrayOptByEquiv(aux, representatives, equalNodes);
  DdiGenericDataCopy((Ddi_Generic_t *)fAig, (Ddi_Generic_t *)Ddi_BddarrayRead(aux, 0));

  Ddi_Free(aux);
  return fAig;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayOptByEquiv(
  Ddi_Bddarray_t *fA,
  Ddi_Bddarray_t *representatives,
  Ddi_Bddarray_t *equalNodes
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i, n=Ddi_BddarrayNum(fA), nNodes;
  bAig_array_t *visitedNodes = bAigArrayAlloc();

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  }

  postOrderAigClearVisitedIntern(bmgr,visitedNodes);

  bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,-1);

  nNodes = visitedNodes->num;

  for (i=0; i<nNodes; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxAig1(bmgr,baig)==bAig_NULL,
      "NULL AUX aig1 required");
    bAig_Ref(bmgr, baig);
  }

  for (i=0; i<Ddi_BddarrayNum(representatives); i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(equalNodes,i);
    Ddi_Bdd_t *fRep = Ddi_BddarrayRead(representatives,i);
    Ddi_BddSetAig(fRep);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    bAigEdge_t fRepBaig = Ddi_BddToBaig(fRep);
    if (0||fBaig != fRepBaig) {
      //      fprintf(dMgrO(ddm),"equiv: %d - %d\n", fBaig/4, fRepBaig/4);
       Pdtutil_Assert(bAig_AuxAig1(bmgr,fBaig)==bAig_NULL,
        "NULL AUX aig1 required");
       bAig_AuxAig1(bmgr,fBaig) = bAig_NodeIsInverted(fBaig) ?
                                  bAig_Not(fRepBaig) : fRepBaig;
       bAig_Ref(bmgr, fRepBaig);
    }
  }

  if (nNodes < 20000)
  for (i=0; i<nNodes; i++) {
    int j;
    bAigEdge_t baig_i = visitedNodes->nodes[i];
    bAigEdge_t baig1 = bAig_AuxAig1(bmgr,baig_i);
    for (j=i+1; j<nNodes; j++) {
      bAigEdge_t baig_j = visitedNodes->nodes[j];
      if (bAig_NonInvertedEdge(baig_j) == bAig_NonInvertedEdge(baig1)) {
	visitedNodes->nodes[i] = baig_j;
	visitedNodes->nodes[j] = baig_i;
      }
    }
  }

  for (i=0; i<nNodes; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAigEdge_t baig1 = bAig_AuxAig1(bmgr,baig);
    if (bAig_NodeIsConstant(baig1)) {
      continue;
    }
    if (baig1 != bAig_NULL) {
#if 1
      bAigEdge_t fRepBaig = bAig_AuxAig1(bmgr,baig1);
      if (fRepBaig==bAig_NULL) {
        continue;
      }
      if (bAig_NodeIsInverted(baig1)) {
	fRepBaig = bAig_Not(fRepBaig);
      }
      bAig_RecursiveDeref(bmgr,baig1);
      baig1 = fRepBaig;
#else
      continue;
#endif
    }
    else if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      baig1 = bAig_NonInvertedEdge(baig);
    }
    else {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
    }
    bAig_Ref(bmgr, baig1);
    bAig_AuxAig1(bmgr,baig) = baig1;
  }

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    bAigEdge_t fBaig1 = bAig_AuxAig1(bmgr,fBaig);
    if (fBaig1 != bAig_NonInvertedEdge(fBaig)) {
      Ddi_Bdd_t *newf = Ddi_BddMakeFromBaig(ddm,fBaig1);
      if (bAig_NodeIsInverted(fBaig)) {
	Ddi_BddNotAcc(newf);
      }
      Ddi_BddarrayWrite(fA,i,newf);
      Ddi_Free(newf);
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_RecursiveDeref(bmgr,baig);
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
  }

  for (i=0; i<Ddi_BddarrayNum(representatives); i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(equalNodes,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    if (bAig_AuxAig1(bmgr,fBaig)!=bAig_NULL) {
      bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,fBaig));
      bAig_AuxAig1(bmgr,fBaig) = bAig_NULL;
    }
  }

  bAigArrayFree(visitedNodes);
  return 0;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayOptByEquivFwd(
  Ddi_Bddarray_t *fA,
  Ddi_Bddarray_t *representatives,
  Ddi_Bddarray_t *equalNodes,
  int *checkEq,
  int checkStartId
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i, checkResult=0, n=Ddi_BddarrayNum(fA), nNodes;
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  Ddi_Bddarray_t *gA;
  int doCheckEq = 0&&checkEq!=NULL, neqCnt=0, eqCnt=0, totCnt, undefCnt=0;
  bAig_array_t *visitedNodes1=NULL;
  long cpuTime=0, startTime=0;
  int enChecks = 1;
  long totTimeLimit = 10;
  Solver      S;

  startTime = util_cpu_time ();

  //  doCheckEq = 0;

  if (checkResult) {
    gA = Ddi_BddarrayDup(fA);
  }

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    if (0) {
      int j;
      Ddi_Bdd_t *fn = Ddi_BddNot(f);
      for (j=0; j<Ddi_BddarrayNum(representatives); j++) {
	Ddi_Bdd_t *r_j = Ddi_BddarrayRead(representatives,j);
	Ddi_Bdd_t *e_j = Ddi_BddarrayRead(equalNodes,j);
	if (Ddi_BddEqual(f,r_j)||Ddi_BddEqual(f,e_j)||
            Ddi_BddEqual(fn,r_j)||Ddi_BddEqual(fn,r_j)) {
	  fprintf(dMgrO(ddm),"eq on output\n");
	}
      }
      Ddi_Free(fn);
    }
    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  }

  postOrderAigClearVisitedIntern(bmgr,visitedNodes);

  bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,-1);

  nNodes = visitedNodes->num;

  for (i=0; i<nNodes; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxAig1(bmgr,baig)==bAig_NULL,
      "NULL AUX aig1 required");
    Pdtutil_Assert(bAig_AuxAig0(bmgr,baig)==bAig_NULL,
      "NULL AUX aig0 required");
    bAig_Ref(bmgr, baig);
  }

  totCnt = Ddi_BddarrayNum(representatives);

  for (i=0; i<Ddi_BddarrayNum(representatives); i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(equalNodes,i);
    Ddi_Bdd_t *fRep = Ddi_BddarrayRead(representatives,i);
    Ddi_BddSetAig(fRep);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    bAigEdge_t fRepBaig = Ddi_BddToBaig(fRep);

    Pdtutil_Assert(bAig_AuxInt(bmgr,fBaig)==-1, "NULL AUX int required");
    Pdtutil_Assert(bAig_AuxInt(bmgr,fRepBaig)==-1, "NULL AUX int required");

    if (doCheckEq) {
      checkEq[i] = 1;
    }
    if (0||fBaig != fRepBaig) {
      //      fprintf(dMgrO(ddm),"equiv: %d - %d\n", fBaig/4, fRepBaig/4);
       Pdtutil_Assert(bAig_AuxAig1(bmgr,fBaig)==bAig_NULL,
        "NULL AUX aig1 required");
       bAig_AuxAig1(bmgr,fBaig) = bAig_NodeIsInverted(fBaig) ?
                                  bAig_Not(fRepBaig) : fRepBaig;
       bAig_Ref(bmgr, fRepBaig);
       bAig_AuxInt(bmgr,fBaig) = i;
    }
  }

  for (i=0; 0 && i<nNodes; i++) {
    int j;
    bAigEdge_t baig_i = visitedNodes->nodes[i];
    bAigEdge_t baig1 = bAig_AuxAig1(bmgr,baig_i);
    for (j=i+1; j<nNodes; j++) {
      bAigEdge_t baig_j = visitedNodes->nodes[j];
      if (bAig_NonInvertedEdge(baig_j) == bAig_NonInvertedEdge(baig1)) {
	visitedNodes->nodes[i] = baig_j;
	visitedNodes->nodes[j] = baig_i;
      }
    }
  }

  aig2CnfIdInit(ddm);
  visitedNodes1 = bAigArrayAlloc();

  for (i=0; i<nNodes; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAigEdge_t baig1 = bAig_AuxAig1(bmgr,baig);
    bAigEdge_t baigEq = bAig_NULL;

    if (enChecks && totTimeLimit >= 0 &&
      ((util_cpu_time () - startTime)/1000.0 > totTimeLimit)) {
      enChecks = 0;
    }

    if (0 && bAig_NodeIsConstant(baig1)) {
      continue;
    }
    if (baig1 != bAig_NULL && enChecks) {
      int isEq = 1;
      int jj = bAig_AuxInt(bmgr,baig);
#if 1
      bAigEdge_t fRepBaig = bAig_AuxAig1(bmgr,baig1);
      if (fRepBaig==bAig_NULL) {
        continue;
      }
      if (bAig_NodeIsInverted(baig1)) {
	fRepBaig = bAig_Not(fRepBaig);
      }
      bAig_RecursiveDeref(bmgr,baig1);
      if (doCheckEq && jj>checkStartId) {
	int f, a, b, e, guard, sat;
	double timeLimit=0.1;
	vec<Lit> lits;
	vec<Lit> assumps;
	int ii, nOld = visitedNodes1->num;
        postOrderAigVisitIntern(bmgr,baig,visitedNodes1,-1);
        postOrderAigVisitIntern(bmgr,fRepBaig,visitedNodes1,-1);
	for (ii=nOld; ii<visitedNodes1->num; ii++) {
	  bAigEdge_t b_i = visitedNodes1->nodes[ii];

	  if (!bAig_isVarNode(bmgr,b_i) && !bAig_NodeIsConstant(b_i)) {
	    bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,b_i);
	    bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,b_i);

	    Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

	    /* convert AIG node to cnf clauses */
	    /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
	    f = aig2CnfId(bmgr,b_i);
	    a = bAig_NodeIsInverted(right) ? -aig2CnfId(bmgr,right) :
	      aig2CnfId(bmgr,right);
	    b = bAig_NodeIsInverted(left) ? -aig2CnfId(bmgr,left) :
	      aig2CnfId(bmgr,left);

	    //	    fprintf(dMgrO(ddm),"b_i: %d - r: %d l: %d - CNF: %d %d %d\n",
	    //    b_i, right, left, f, a, b);
	    if (bAig_AuxRef(bmgr,b_i) == 0) {
	      bAig_AuxRef(bmgr,b_i) = 1;
	      /* f -a -b */
	      MinisatClause3(S,lits,f,-a,-b);
	      /* -f a */
	      MinisatClause2(S,lits,-f,a);
	      /* -f b */
	      MinisatClause2(S,lits,-f,b);
	    }
	  }

	}
	/* build exor */
	f = bAig_NodeIsInverted(baig) ? -aig2CnfId(bmgr,baig) :
                                          aig2CnfId(bmgr,baig);
	e = bAig_NodeIsInverted(fRepBaig) ? -aig2CnfId(bmgr,fRepBaig) :
     	                                     aig2CnfId(bmgr,fRepBaig);
        guard = aig2CnfNewIdIntern(ddm);
	/* guard => (f!=e) --> (!guard+f+e)(!guard+!f+!e) */
	MinisatClause3(S,lits,-guard,f,e);
	MinisatClause3(S,lits,-guard,-f,-e);
	{
	  Lit l = MinisatLit(guard);
	  assumps.clear();
	  assumps.push(l);
	}
	sat = S.okay();
	if (sat) {
	  sat = S.solve(assumps,timeLimit);
	}

	if (S.undefined()) {
	  /* pessimistic */
	  isEq = 1;
	  undefCnt++;
	}
	else {
	  isEq = !sat;
	}
      }
      if (isEq) {
        baigEq = fRepBaig;
        bAig_Ref(bmgr, baigEq);
	eqCnt++;
      }
      else {
	/* modify input vector */
	checkEq[jj] = 0;
	neqCnt++;
      }
#else
      continue;
#endif
    }

    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      baig1 = bAig_NonInvertedEdge(baig);
    }
    else {
      /* compute baig1 */
      bAigEdge_t right, r = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left, l = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(r) ? bAig_Not(bAig_AuxAig1(bmgr,r)) :
                                       bAig_AuxAig1(bmgr,r);
      left  = bAig_NodeIsInverted(l) ? bAig_Not(bAig_AuxAig1(bmgr,l)) :
                                       bAig_AuxAig1(bmgr,l);
      baig1 = bAig_And(bmgr,right,left);
    }
    bAig_Ref(bmgr, baig1);

    if (baigEq != bAig_NULL) {
      bAig_AuxAig0(bmgr,baig) = baig1;
      bAig_AuxAig1(bmgr,baig) = baigEq;
    }
    else {
      bAig_AuxAig1(bmgr,baig) = baig1;
    }
  }
  aig2CnfIdClose(ddm);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes1);
  bAigArrayFree(visitedNodes1);

  if (doCheckEq) {
    fprintf(dMgrO(ddm),"check eq verdict: #eq: %d, #dif: %d, #tot: %d (#undef: %d)\n",
	   eqCnt, neqCnt, totCnt, undefCnt);
  }

  for (i=0; i<n; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fA,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    bAigEdge_t fBaig0 = bAig_AuxAig0(bmgr,fBaig);
    bAigEdge_t fBaig1 = (fBaig0!=bAig_NULL)?fBaig0:bAig_AuxAig1(bmgr,fBaig);
    if (fBaig1 != bAig_NonInvertedEdge(fBaig)) {
      Ddi_Bdd_t *newf = Ddi_BddMakeFromBaig(ddm,fBaig1);
      if (bAig_NodeIsInverted(fBaig)) {
	Ddi_BddNotAcc(newf);
      }
      Ddi_BddarrayWrite(fA,i,newf);
      Ddi_Free(newf);
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_RecursiveDeref(bmgr,bAig_AuxAig0(bmgr,baig));
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_RecursiveDeref(bmgr,baig);
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
  }

  for (i=0; i<Ddi_BddarrayNum(representatives); i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(equalNodes,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    if (bAig_AuxAig1(bmgr,fBaig)!=bAig_NULL) {
      bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,fBaig));
      bAig_AuxAig1(bmgr,fBaig) = bAig_NULL;
    }
    bAig_AuxInt(bmgr,fBaig)=-1;
  }

  bAigArrayFree(visitedNodes);

  if (checkResult) {
    Ddi_Bdd_t *care = Ddi_BddMakeConstAig(ddm, 1);
    for (i=0; i<Ddi_BddarrayNum(representatives); i++) {
      Ddi_Bdd_t *eq=Ddi_BddDup(Ddi_BddarrayRead(representatives, i));
      Ddi_BddXnorAcc(eq, Ddi_BddarrayRead(equalNodes, i));
      Ddi_BddAndAcc(care, eq);
      Ddi_Free(eq);
    }
    for (i=0; i<Ddi_BddarrayNum(fA); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(fA, i);
      Ddi_Bdd_t *g_i = Ddi_BddarrayRead(gA, i);
      Ddi_Bdd_t *diff = Ddi_BddXor(f_i, g_i);
      Pdtutil_Assert(!Ddi_AigSatAnd(diff, care, NULL), "Error");
      Ddi_Free(diff);
    }
    Ddi_Free(care);
    Ddi_Free(gA);
  }

  return 0;
}

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
aigOptTopInternTopAnd(
   bAig_Manager_t *manager,
   bAig_array_t *aigNodes,
   bAigEdge_t nodeIndex
)
{
  if (nodeVisited(manager,nodeIndex)>=32) {
    if (bAig_NodeIsInverted(nodeIndex) &&
        nodeVisited(manager,nodeIndex) <= 64) {
      /* conflicting phases: redundant aig */
      return -1;
    }
    else if (!bAig_NodeIsInverted(nodeIndex) &&
             nodeVisited(manager,nodeIndex) > 64) {
      /* conflicting phases: redundant aig */
      return -1;
    }
    return aigNodes->num;
  }

  recDepth++;

  nodeVisited(manager,nodeIndex) += 32;
  if (bAig_NodeIsInverted(nodeIndex)) {
    nodeVisited(manager,nodeIndex) += 64;
  }
  if (bAig_NodeIsConstant(nodeIndex) || bAig_isVarNode(manager,nodeIndex)) {
    bAigArrayWriteLast(aigNodes,nodeIndex);
  }
  else if (!bAig_NodeIsInverted(nodeIndex) /* top and */) {
    bAigEdge_t right = rightChild(manager,nodeIndex);
    bAigEdge_t left = leftChild(manager,nodeIndex);
    if (aigOptTopInternTopAnd(manager,aigNodes,right)<0)
      return -1;
    if (aigOptTopInternTopAnd(manager,aigNodes,left)<0)
      return -1;
  }
  else {
    bAigArrayWriteLast(aigNodes,nodeIndex);
  }

  recDepth--;

  return (aigNodes->num);
}


/**Function********************************************************************
  Synopsis    [Reverse engineer top level ite structure]
  Description [Reverse engineer top level ite structure]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static bAigEdge_t
aigPartitionTopIteIntern(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex,
  Ddi_Bdd_t *sel,
  Ddi_Bdd_t *thenAig,
  int sizeTh
)
{
  bAig_Manager_t *manager = ddm->aig.mgr;
  Ddi_Bdd_t *mySel0, *mySel1;
  bAigEdge_t right, left, thenBaig, elseBaig, selBaig, selBaigCompl,
    tmp, filteredBaig, newLeft, newRight, newNode;
  int isIte = 1, thenSize, elseSize, selSize, rightSize, leftSize;

  if (!bAig_NodeIsInverted(nodeIndex)) {
    isIte = 0;
    goto recur;
  }

  if (bAig_NodeIsConstant(nodeIndex) || bAig_isVarNode(manager,nodeIndex)) {
    isIte = 0;
    goto recur;
  }

  Pdtutil_Assert(bAig_NodeIsInverted(nodeIndex),"OR node expected");

  right = bAig_Not(rightChild(manager,nodeIndex));
  left = bAig_Not(leftChild(manager,nodeIndex));

  if (bAig_NodeIsInverted(right) || bAig_NodeIsInverted(left)) {
    isIte = 0;
    goto recur;
  }

  rightSize = bAig_NodeCount(manager,right);
  leftSize = bAig_NodeCount(manager,left);

  if (rightSize>sizeTh && leftSize>sizeTh) {
    isIte = 0;
    goto recur;
  }

  if (leftSize>sizeTh) {
    tmp = left; left = right; right = tmp;
  }

  thenBaig = rightChild(manager,right);
  selBaig = leftChild(manager,right);

  thenSize = bAig_NodeCount(manager,thenBaig);
  selSize = bAig_NodeCount(manager,selBaig);

  if (thenSize>sizeTh && selSize>sizeTh) {
    isIte = 0;
    goto recur;
  }

  if (selSize>sizeTh) {
    tmp = thenBaig; thenBaig = selBaig; selBaig = tmp;
  }

 recur:

  if (!isIte) {
    /* stop recurring */
    Ddi_Bdd_t *fAig = Ddi_BddMakeFromBaig(ddm,nodeIndex);
    Ddi_DataCopy(thenAig,fAig);
    Ddi_Free(fAig);
    return bAig_Zero;
  }

  // sel is sel & !left
  left = bAig_Not(left);
  mySel0 = Ddi_BddMakeFromBaig(ddm,selBaig);
  mySel1 = Ddi_BddMakeFromBaig(ddm,left);
  selBaig = bAig_And(manager,selBaig,left);
  left = bAig_Not(left);
  bAig_Ref(manager, selBaig);

  Pdtutil_Assert(Ddi_BddIsPartConj(sel)&&(Ddi_BddPartNum(sel)==2),
                 "wrong sel");

  selSize = Ddi_BddSize(mySel0);
  Ddi_BddAndAcc(Ddi_BddPartRead(sel,(selSize==1)?0:1),mySel0);
  Ddi_BddAndAcc(Ddi_BddPartRead(sel,1),mySel1);
  Ddi_Free(mySel0);
  Ddi_Free(mySel1);

  filteredBaig = aigPartitionTopIteIntern(ddm,thenBaig,sel,thenAig,sizeTh);
  newRight = bAig_And(manager,filteredBaig,selBaig);
  bAig_Ref(manager, newRight);
  bAig_RecursiveDeref(manager,filteredBaig);
  newNode = bAig_Or(manager,newRight,left);
  bAig_Ref(manager, newNode);

  bAig_RecursiveDeref(manager,selBaig);
  bAig_RecursiveDeref(manager,newRight);

  return (newNode);
}

/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
aigOptTopInternTopOr(
   bAig_Manager_t *manager,
   bAig_array_t *aigNodes,
   bAigEdge_t nodeIndex
)
{
  if (nodeVisited(manager,nodeIndex)>=32) {
    if (bAig_NodeIsInverted(nodeIndex) &&
        nodeVisited(manager,nodeIndex) <= 64) {
      /* conflicting phases: redundant aig */
      return -1;
    }
    else if (!bAig_NodeIsInverted(nodeIndex) &&
             nodeVisited(manager,nodeIndex) > 64) {
      /* conflicting phases: redundant aig */
      return -1;
    }
    return aigNodes->num;
  }
  nodeVisited(manager,nodeIndex) += 32;
  if (bAig_NodeIsInverted(nodeIndex)) {
    nodeVisited(manager,nodeIndex) += 64;
  }
  if (bAig_NodeIsConstant(nodeIndex) || bAig_isVarNode(manager,nodeIndex)) {
    bAigArrayWriteLast(aigNodes,nodeIndex);
  }
  else if (bAig_NodeIsInverted(nodeIndex) /* top or */) {
    bAigEdge_t right = rightChild(manager,nodeIndex);
    bAigEdge_t left = leftChild(manager,nodeIndex);
    right = bAig_Not(right);
    left = bAig_Not(left);
    if (aigOptTopInternTopOr(manager,aigNodes,right)<0)
      return -1;
    if (aigOptTopInternTopOr(manager,aigNodes,left)<0)
      return -1;
  }
  else {
    bAigArrayWriteLast(aigNodes,nodeIndex);
  }
  return (aigNodes->num);
}


/**Function********************************************************************
  Synopsis    [Aig to BDD conversion]
  Description [Aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
aigOptTopIntern(
   bAig_Manager_t *manager,
   bAig_array_t *aigNodes,
   bAigEdge_t nodeIndex,
   int topOr,
   int keepXor,
   int maxDepth
)
{
  if (nodeVisited(manager,nodeIndex)>=32) {
    if (bAig_NodeIsInverted(nodeIndex) &&
        nodeVisited(manager,nodeIndex) <= 64) {
      /* conflicting phases: redundant aig */
      return -1;
    }
    else if (!bAig_NodeIsInverted(nodeIndex) &&
             nodeVisited(manager,nodeIndex) > 64) {
      /* conflicting phases: redundant aig */
      return -1;
    }
    return aigNodes->num;
  }

  if (maxDepth == 0) {
    return 0;
  }
  else if (maxDepth > 0) {
    --maxDepth;
  }

  recDepth++;

  nodeVisited(manager,nodeIndex) += 32;
  if (bAig_NodeIsInverted(nodeIndex)) {
    nodeVisited(manager,nodeIndex) += 64;
  }
  if (bAig_NodeIsConstant(nodeIndex) || bAig_isVarNode(manager,nodeIndex)) {
    bAigArrayWriteLast(aigNodes,nodeIndex);
  }
  else if (keepXor && baigIsXorOrXnor(manager,nodeIndex)) {
    bAigArrayWriteLast(aigNodes,nodeIndex);
  }
  else if (bAig_NodeIsInverted(nodeIndex) == topOr) {
    bAigEdge_t right = rightChild(manager,nodeIndex);
    bAigEdge_t left = leftChild(manager,nodeIndex);
    if (topOr) {
      right = bAig_Not(right);
      left = bAig_Not(left);
    }
    if (aigOptTopIntern(manager,aigNodes,right,topOr,keepXor,maxDepth)<0)
      return -1;
    if (aigOptTopIntern(manager,aigNodes,left,topOr,keepXor,maxDepth)<0)
      return -1;
  }
  else {
    bAigArrayWriteLast(aigNodes,nodeIndex);
  }

  recDepth--;

  return (aigNodes->num);
}


/**Function********************************************************************
  Synopsis    [Clear Visited flag]
  Description [Clear Visited flag]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aigTopOrClearVisitedIntern(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{
  if (nodeVisited(manager,nodeIndex)<32) {
    return;
  }

  if (nodeVisited(manager,nodeIndex) > 64)
    nodeVisited(manager,nodeIndex) -= 64;
  nodeVisited(manager,nodeIndex) -= 32;

  aigTopOrClearVisitedIntern(manager,rightChild(manager,nodeIndex));
  aigTopOrClearVisitedIntern(manager,leftChild(manager,nodeIndex));

}

/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aig2BddIntern0(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex)
{
  Ddi_Bdd_t *left, *right, *res;
  bAig_Manager_t *manager = ddm->aig.mgr;

  if ( nodeIndex == bAig_Zero ) {
    return Ddi_BddMakeConst(ddm,0);
  }
  if ( nodeIndex == bAig_One ) {
    return Ddi_BddMakeConst(ddm,1);
  }

  if (bAig_isVarNode(manager,nodeIndex)) {
    Ddi_Var_t *v = Ddi_VarFromBaig(ddm,nodeIndex);
    return Ddi_BddMakeLiteral(v,!bAig_NodeIsInverted(nodeIndex));
  }

#if 0
  if (1&&nodeVisited(manager,nodeIndex)) {
    assert (nodeVisited(manager,nodeIndex)==2);
    res = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,nodeIndex));
  }
#else
  if (((Ddi_Bdd_t *)bAig_AuxPtr(manager,nodeIndex))!=NULL) {
    res = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,nodeIndex));
  }
#endif
  else {
    right = aig2BddIntern0(ddm,
          bAig_NodeReadIndexOfRightChild(manager,nodeIndex));
    left = aig2BddIntern0(ddm,
          bAig_NodeReadIndexOfLeftChild(manager,nodeIndex));

    res = Ddi_BddAnd(right,left);
    Ddi_Free(right);
    Ddi_Free(left);
    bAig_AuxPtr(manager,nodeIndex) = (void *)Ddi_BddDup(res);

#if 0
#if 0
    nodeSetVisited(manager,nodeIndex);
#else
    nodeVisited(manager,nodeIndex) = 2;
#endif
#endif
  }

  if (bAig_NodeIsInverted(nodeIndex)){
    Ddi_BddNotAcc(res);
  }

  return (res);
}


/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aig2BddIntern(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex)
{
  return aig2BddInternWithCuts(ddm,
			       nodeIndex,-1,NULL,NULL,NULL,NULL,0,-1.0,-1,0);
}


/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aig2BddInternWithAbort(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex,
  int th)
{
  return aig2BddInternWithCuts(ddm,
			       nodeIndex,th,NULL,NULL,NULL,NULL,0,-1.0,-1,0);
}


/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aig2BddInternWithCuts0(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex,
  int th,
  Ddi_Vararray_t *auxV,
  Ddi_Bddarray_t *auxF,
  Ddi_Bddarray_t *auxLits,
  int enPartial,
  float timeLimit
)
{
  Ddi_Bdd_t *leftBdd, *rightBdd, *leftAig, *rightAig, *resBdd, *resAig;
  bAigEdge_t left, right, baig;
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  int nBdds, maxN, nMultipleFo=0;
  int i, *lastRef, *nRef;
  bAigEdge_t *eqNode;
  int extRef = Ddi_MgrReadExtRef(ddm);
  st_table *bddTObaigTable;

  static int ncalls=0;
  ncalls++;

  bddTObaigTable = st_init_table(st_numcmp, st_numhash);

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(manager,nodeIndex,visitedNodes,-1);
  postOrderAigClearVisitedIntern(manager,visitedNodes);
  maxN = nBdds = 0;

  lastRef = Pdtutil_Alloc(int,visitedNodes->num);
  nRef = Pdtutil_Alloc(int,visitedNodes->num);
  eqNode = Pdtutil_Alloc(bAigEdge_t,visitedNodes->num);
  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = i;
    eqNode[i] = bAig_NULL;
    lastRef[i] = 0;
    nRef[i] = 0;
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      lastRef[ir] = lastRef[il] = i;
      nRef[ir]++; nRef[il]++;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    baig = visitedNodes->nodes[i];
    if (bAig_NodeIsConstant(baig)) {
      resBdd = Ddi_BddMakeConst(ddm,0);
      resAig = Ddi_BddMakeConstAig(ddm,0);
    }
    else if (bAig_isVarNode(manager,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      resBdd = Ddi_BddMakeLiteral(v,1);
      resAig = Ddi_BddMakeLiteralAig(v,1);
    }
    else {
      bAigEdge_t auxRes;
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      resBdd = NULL;
      rightBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,right));
      leftBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,left));
      rightAig = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr0(manager,right));
      leftAig = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr0(manager,left));
      if (bAig_NodeIsInverted(right)) {
        Ddi_BddNotAcc(rightBdd);
        Ddi_BddNotAcc(rightAig);
      }
      if (bAig_NodeIsInverted(left)) {
        Ddi_BddNotAcc(leftBdd);
        Ddi_BddNotAcc(leftAig);
      }

      if (0&&th>0) {
        Ddi_MgrAbortOnSiftEnableWithThresh(ddm,2*th,0);
      }
      resAig = Ddi_BddAnd(rightAig,leftAig);
      auxRes = Ddi_BddToBaig(resAig);
      if (bAig_AuxPtr(manager,auxRes)!=NULL) {
        resBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,auxRes));
        if (bAig_NodeIsInverted(auxRes)) {
          Ddi_BddNotAcc(resBdd);
	}
	ddm->stats.aig.n_merge_2++;
      }
      else {
        resBdd = Ddi_BddAnd(rightBdd,leftBdd);
        if (0&&th>0) {
          Ddi_MgrAbortOnSiftDisable(ddm);
        }
        if (1 && (resBdd == NULL || th > 0 && Ddi_BddSize(resBdd) > th)) {
          char name[100];
          Ddi_Var_t *aV;
          Ddi_Free(resBdd);
          Ddi_Free(resAig);
          if (/*nRef[ir]==1 &&*/ Ddi_BddSize(rightBdd)>Ddi_BddSize(leftBdd)) {
            sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV));
            aV = Ddi_VarFromName(ddm,name);
            if (aV == NULL) {
              aV = Ddi_VarNewBeforeVar(Ddi_BddTopVar(rightBdd));
              Ddi_VarAttachName (aV, name);
            }
            Ddi_Free(rightBdd);
            Ddi_Free(rightAig);
            /* warning: these ar not complemented! */
            rightBdd = (Ddi_Bdd_t*)(bAig_AuxPtr(manager,right));
            rightAig = (Ddi_Bdd_t*)(bAig_AuxPtr0(manager,right));
            if (enPartial) {
              Ddi_BddSetAig(rightBdd);
              if (Ddi_BddSize(rightAig)<Ddi_BddSize(rightBdd)) {
		Ddi_Bdd_t *a = Ddi_BddXor(rightBdd,rightAig);
		Pdtutil_Assert(!Ddi_AigSat(a),"wrong enpart");
		Ddi_Free(a);
                Ddi_BddarrayInsertLast(auxF,rightAig);
              }
              else {
                Ddi_BddarrayInsertLast(auxF,rightBdd);
              }
            }
            else {
              Ddi_BddarrayInsertLast(auxF,rightBdd);
            }

            Ddi_Free(bAig_AuxPtr(manager,right));
            Ddi_Free(bAig_AuxPtr0(manager,right));
            rightBdd = Ddi_BddSetMono(Ddi_BddMakeLiteralAig(aV,1));
            rightAig = Ddi_BddMakeLiteralAig(aV,1);
            bAig_AuxPtr(manager,right) = Ddi_BddDup(rightBdd);
            bAig_AuxPtr0(manager,right) = Ddi_BddDup(rightAig);
            if (bAig_NodeIsInverted(right)) {
              Ddi_BddNotAcc(rightBdd);
              Ddi_BddNotAcc(rightAig);
            }
            Ddi_VararrayInsertLast(auxV,aV);
          }
          else if (1)/*if (nRef[il]==1)*/ {
            sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV));
            aV = Ddi_VarFromName(ddm,name);
            if (aV == NULL) {
              aV = Ddi_VarNewBeforeVar(Ddi_BddTopVar(leftBdd));
              Ddi_VarAttachName (aV, name);
            }
            Ddi_Free(leftBdd);
            Ddi_Free(leftAig);
            /* warning: these ar not complemented! */
            leftBdd = (Ddi_Bdd_t*)(bAig_AuxPtr(manager,left));
            leftAig = (Ddi_Bdd_t*)(bAig_AuxPtr0(manager,left));
            if (enPartial) {
              Ddi_BddSetAig(leftBdd);
              if (Ddi_BddSize(leftAig)<Ddi_BddSize(leftBdd)) {
                Ddi_BddarrayInsertLast(auxF,leftAig);
              }
              else {
                Ddi_BddarrayInsertLast(auxF,leftBdd);
              }
            }
            else {
              Ddi_BddarrayInsertLast(auxF,leftBdd);
            }
            Ddi_Free(bAig_AuxPtr(manager,left));
            Ddi_Free(bAig_AuxPtr0(manager,left));
            leftBdd = Ddi_BddSetMono(Ddi_BddMakeLiteralAig(aV,1));
            leftAig = Ddi_BddMakeLiteralAig(aV,1);
            bAig_AuxPtr(manager,left) = Ddi_BddDup(leftBdd);
            bAig_AuxPtr0(manager,left) = Ddi_BddDup(leftAig);
            if (bAig_NodeIsInverted(left)) {
              Ddi_BddNotAcc(leftBdd);
              Ddi_BddNotAcc(leftAig);
            }
            Ddi_VararrayInsertLast(auxV,aV);
          }
          if (0&&th>0) {
            Ddi_MgrAbortOnSiftEnableWithThresh(ddm,2*th,0);
          }
          resBdd = Ddi_BddAnd(rightBdd,leftBdd);
          resAig = Ddi_BddAnd(rightAig,leftAig);
          if (0&&th>0) {
            Ddi_MgrAbortOnSiftDisable(ddm);
          }
        }
      }
      if (nRef[i]>1) {
	nMultipleFo++;
      }
      if (resBdd != NULL && th > 0
       && (((Ddi_BddSize(resBdd) > th) ||
           (nRef[i]>1 && Ddi_VararrayNum(auxV) > 2 &&
	    Ddi_BddSize(resBdd) > th/(Ddi_VararrayNum(auxV)<100 ?
              Ddi_VararrayNum(auxV) : 100 )))
           ) && (Ddi_VararrayNum(auxV)<1000)) {
	char name[100];
	Ddi_Var_t *aV;
        sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV));
        aV = Ddi_VarFromName(ddm,name);
        if (aV == NULL) {
          aV = Ddi_VarNewBeforeVar(Ddi_BddTopVar(resBdd));
          Ddi_VarAttachName (aV, name);
        }
        if (enPartial) {
          Ddi_BddSetAig(resBdd);
          if (Ddi_BddSize(resAig)<Ddi_BddSize(resBdd)) {
            Ddi_Free(resBdd);
            resBdd=resAig;
          }
          else {
            Ddi_Free(resAig);
          }
	}
        Ddi_BddarrayInsertLast(auxF,resBdd);
	Ddi_Free(resBdd);
	resBdd = Ddi_BddMakeLiteral(aV,1);
	resAig = Ddi_BddMakeLiteralAig(aV,1);
        Ddi_VararrayInsertLast(auxV,aV);
      }
      Ddi_Free(rightBdd);
      Ddi_Free(leftBdd);
      Ddi_Free(rightAig);
      Ddi_Free(leftAig);
      if (0||th<0) {
	Ddi_Bdd_t *toFreeBdd=NULL, *toFreeAig=NULL;
        if (i>=lastRef[ir]) {
	  DdNode *toFreeCU;
          toFreeBdd = (Ddi_Bdd_t*)bAig_AuxPtr(manager,right);
          toFreeAig = (Ddi_Bdd_t*)bAig_AuxPtr0(manager,right);
          bAig_AuxPtr(manager,right) = NULL;
          bAig_AuxPtr0(manager,right) = NULL;
	  toFreeCU = Cudd_Regular(Ddi_BddToCU(toFreeBdd));
          st_delete(bddTObaigTable, (char *) (&toFreeCU), NULL);
          Ddi_Free(toFreeBdd);
          Ddi_Free(toFreeAig);
  	  nBdds--;
        }
        if (i>=lastRef[il]) {
	  DdNode *toFreeCU;
          toFreeBdd = (Ddi_Bdd_t*)bAig_AuxPtr(manager,left);
          toFreeAig = (Ddi_Bdd_t*)bAig_AuxPtr0(manager,left);
          bAig_AuxPtr(manager,left) = NULL;
          bAig_AuxPtr0(manager,left) = NULL;
	  toFreeCU = Cudd_Regular(Ddi_BddToCU(toFreeBdd));
          st_delete(bddTObaigTable, (char *) (&toFreeCU), NULL);
          Ddi_Free(toFreeBdd);
          Ddi_Free(toFreeAig);
 	  nBdds--;
        }
	if (toFreeBdd!=NULL) {
	}
      }
#if 0
      //      else
      {
	bAigEdge_t node_i;
	DdNode *cuNode = Cudd_Regular (Ddi_BddToCU(resBdd));
        if (st_lookup_int(bddTObaigTable, (char *) cuNode, (int*)&node_i)) {
	  /* merge node_i <-> i */
          if (Ddi_BddIsComplement(resBdd)) {
            node_i = bAig_Not(node_i);
	  }
	  Ddi_Free(resAig);
          resAig = Ddi_BddMakeFromBaig(ddm,node_i);
	  eqNode[i]=node_i;
	  ddm->settings.aig.n_merge_3++;
	}
	else {
          node_i = Ddi_BddToBaig(resAig);
          if (Ddi_BddIsComplement(resBdd)) {
	    node_i = bAig_Not(node_i);
	  }
          st_insert(bddTObaigTable, (char *) cuNode, (char *) (long) node_i);
	}
      }
#endif

    }
    bAig_AuxPtr(manager,baig) = (void *) resBdd;
    bAig_AuxPtr0(manager,baig) = (void *) resAig;
    nBdds++;
    if (nBdds > maxN) {
      maxN = nBdds;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = -1;
  }

  Pdtutil_Free(lastRef);
  Pdtutil_Free(nRef);

  baig = visitedNodes->nodes[visitedNodes->num-1];
  resBdd = (Ddi_Bdd_t *)bAig_AuxPtr(manager,baig);
  resAig = (Ddi_Bdd_t *)bAig_AuxPtr0(manager,baig);
  bAig_AuxPtr(manager,baig) = NULL;
  bAig_AuxPtr0(manager,baig) = NULL;
  Pdtutil_Assert(resBdd != NULL,"invalid result bdd");
  Pdtutil_Assert(baig == nodeIndex,"mismatching baigs");

  if (bAig_NodeIsInverted(baig)){
    Ddi_BddNotAcc(resBdd);
    Ddi_BddNotAcc(resAig);
  }

  st_free_table(bddTObaigTable);
  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    Ddi_Free(bAig_AuxPtr(manager,baig));
    bAig_AuxPtr(manager,baig)=NULL;
    Ddi_Free(bAig_AuxPtr0(manager,baig));
    bAig_AuxPtr0(manager,baig)=NULL;
  }

  bAigArrayFree(visitedNodes);

  if (enPartial) {
    Ddi_BddSetAig(resBdd);
    if (Ddi_BddSize(resAig)<Ddi_BddSize(resBdd)) {
      Ddi_Bdd_t *t=resBdd; resBdd=resAig; resAig=t;
    }
  }
  Ddi_Free(resAig);

  Ddi_MgrCheckExtRef(ddm,extRef+1);

  return (resBdd);
}

/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aig2BddInternWithCuts(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex,
  int th,
  Ddi_Vararray_t *auxV,
  Ddi_Bddarray_t *auxF,
  Ddi_Bddarray_t *auxLits,
  Ddi_Bdd_t *constrainCare,
  int enPartial,
  float timeLimit,
  int sizeLimit,
  int auxVarIdStart
)
{
  bAig_array_t *nodeRoots = bAigArrayAlloc();
  Ddi_Bddarray_t *bddRoots;
  Ddi_Bdd_t *resBdd;

  bAigArrayWriteLast(nodeRoots,nodeIndex);
  bddRoots = aigarray2BddInternWithCuts(ddm,nodeRoots,th,
    auxV,auxF,auxLits,constrainCare,enPartial,timeLimit,
    sizeLimit,auxVarIdStart);
  bAigArrayFree(nodeRoots);
  if (bddRoots == NULL || Ddi_BddarrayRead(bddRoots,0)==NULL) {
    resBdd=NULL;
  }
  else {
    resBdd = Ddi_BddarrayExtract(bddRoots,0);
  }
  Ddi_Free(bddRoots);
  return (resBdd);
}

/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
aigarray2BddInternWithCuts(
  Ddi_Mgr_t *ddm,
  bAig_array_t *nodeRoots,
  int th,
  Ddi_Vararray_t *auxV,
  Ddi_Bddarray_t *auxF,
  Ddi_Bddarray_t *auxLits,
  Ddi_Bdd_t *constrainCare,
  int enPartial,
  float timeLimit,
  int sizeLimit,
  int auxVarIdStart
)
{
  Ddi_Bdd_t *leftBdd, *rightBdd, *leftAig, *rightAig, *resBdd, *resAig;
  bAigEdge_t left, right, baig;
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  int nBdds, nEval, maxN, nMultipleFo=0, nn, currCutLayer;
  int *lastRef, *nRef, *nPendingRef, *cutLayer, *evalDone, *isOutput;
  int i, nOutputs, nDoneOutputs;
  bAigEdge_t *eqNode;
  int extRef = Ddi_MgrReadExtRef(ddm);
  st_table *bddTObaigTable;
  st_generator *stgen;
  int cutsDone = 0;
  int doAbort = 0;
  Ddi_Bddarray_t *resArray=NULL;
  int *dominators = NULL, *enCutVar=NULL, nDom=0;
  //  enPartial = 0;
  int liveNodes, baseLiveNodes, stepLiveNodes = 100000;
  Ddi_Bdd_t *constrainBdd = NULL;
  int cutOnFaninNode = 1;
  int useCutLayer = 1;
  //  int maxcuts = 76700;
  int maxLive = 25000000;
  long cpuTime=0, startTime=0;

  static int ncalls=0;
  ncalls++;

  baseLiveNodes = Ddi_MgrReadLiveNodes(ddm);

  bddTObaigTable = st_init_table(st_numcmp, st_numhash);

  startTime = util_cpu_time ();

  visitedNodes = bAigArrayAlloc();
  for (i=0; i<nodeRoots->num; i++) {
    postOrderAigVisitIntern(manager,nodeRoots->nodes[i],visitedNodes,-1);
  }
  // bfsAigVisitIntern(manager,nodeIndex,visitedNodes,-1);
  postOrderAigClearVisitedIntern(manager,visitedNodes);
  maxN = nBdds = nEval = 0;

  bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,-1);

  lastRef = Pdtutil_Alloc(int,visitedNodes->num);
  nRef = Pdtutil_Alloc(int,visitedNodes->num);
  nPendingRef = Pdtutil_Alloc(int,visitedNodes->num);
  cutLayer = Pdtutil_Alloc(int,visitedNodes->num);
  evalDone = Pdtutil_Alloc(int,visitedNodes->num);
  isOutput = Pdtutil_Alloc(int,visitedNodes->num);
  eqNode = Pdtutil_Alloc(bAigEdge_t,visitedNodes->num);

#if 0
  dominators = Pdtutil_Alloc(int,visitedNodes->num);
  enCutVar = Pdtutil_Alloc(int,visitedNodes->num);
  dom_stats(manager, visitedNodes, dominators, NULL, 0);
#endif

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = i;
    eqNode[i] = bAig_NULL;
    lastRef[i] = 0;
    nRef[i] = 0;
    nPendingRef[i] = 0;
    cutLayer[i] = -1;
    evalDone[i] = -1;
    isOutput[i] = 0;
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      lastRef[ir] = lastRef[il] = i;
      nRef[ir]++; nRef[il]++;
      nPendingRef[ir]++; nPendingRef[il]++;
    }
  }

  for (i=0; 0&&i<visitedNodes->num; i++) {
    int ir, il;
    if (nRef[i] > 1000) {
      baig = visitedNodes->nodes[i];
      fprintf(dMgrO(ddm),"nref[%d] = %d\n", i, nRef[i]);
      if (bAig_isVarNode(manager,baig)) {
	Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	printf("VAR: %s\n", Ddi_VarName(v));
      }
    }
  }


  currCutLayer = 0;

  nn = visitedNodes->num;
  nOutputs = nodeRoots->num;
  for (i=0; i<nodeRoots->num; i++) {
    int j;
    baig = nodeRoots->nodes[i];
    if (bAig_NodeIsConstant(baig)) continue;
    j = bAig_AuxInt(manager,baig);
    nPendingRef[j]++;
    nRef[j]++;
    lastRef[j] = nn;
    isOutput[j] = 1;
  }
  nDoneOutputs = 0;


#if 0
  for (i=0; i<visitedNodes->num; i++) {
    int ir, il, enSizeChk = dominators[i]==i;
    baig = visitedNodes->nodes[i];
    enCutVar[i] = 0;
    //    if (enSizeChk < 0) continue;
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      if (dominators[ir]<0) {
	enCutVar[ir] = 1;
      }
      else {
	dominators[i] = i;
      }
      if (dominators[il]<0) {
	enCutVar[il] = 1;
      }
      else {
	dominators[i] = i;
      }
    }
    enSizeChk = dominators[i];
    if (enSizeChk >= 0) nDom++;
  }

  //  fprintf(dMgrO(ddm),"%d DOMINATOR SIZE\n", nDom);
#endif

  //  th = 10000;

  if (1&&constrainCare != NULL) {
    constrainBdd = Ddi_BddDup(constrainCare);
  }

  do {

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il, enSizeChk = 0 && enCutVar[i];
    if (i>visitedNodes->num/3) maxLive=20000000;
    if (0&&enSizeChk) {
      fprintf(dMgrO(ddm),"dom[%d]==%d\n",i,i);
    }
    if (evalDone[i]>=0) continue;

    liveNodes = Ddi_MgrReadLiveNodes(ddm);
    if (sizeLimit >= 0 && liveNodes > sizeLimit) {
      doAbort=1;
    }
    else if (liveNodes>baseLiveNodes+stepLiveNodes) {
      baseLiveNodes = liveNodes;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
	fprintf(dMgrO(ddm),"newLiveNodes: %d (n BDDs: %d (%d\%))\n",
		liveNodes, nBdds,nEval*100/visitedNodes->num);
      }
      if (constrainBdd!=NULL) {
	int j;
	for (j=0; j<visitedNodes->num; j++) {
	  bAigEdge_t baig_j = visitedNodes->nodes[j];
	  Ddi_Bdd_t *bdd_j = (Ddi_Bdd_t*)bAig_AuxPtr(manager,baig_j);
	  if (bdd_j != NULL) {
	    Ddi_BddConstrainAcc(bdd_j,constrainBdd);
	  }
	}
	liveNodes = Ddi_MgrReadLiveNodes(ddm);
	Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
	  fprintf(dMgrO(ddm),"newLiveNodes after restrict: %d\n", liveNodes);
	}
      }

    }
    else if (liveNodes<baseLiveNodes-stepLiveNodes) {
      baseLiveNodes = liveNodes;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
	fprintf(dMgrO(ddm),"newLiveNodes: %d (n BDDs: %d) (%d\%)\n",
		liveNodes, nBdds,nEval*100/visitedNodes->num);
      }
    }
    if (liveNodes>maxLive) {
      th = 500;
    }

    if (Ddi_VararrayNum(auxV)-auxVarIdStart>5000) {
      doAbort=1;
    }
    if (timeLimit>=0 &&((util_cpu_time () - startTime)/1000.0 > timeLimit)) {
      doAbort=1;
    }

    baig = visitedNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || doAbort) {
      resBdd = Ddi_BddMakeConst(ddm,0);
      resAig = Ddi_BddMakeConstAig(ddm,0);
    }
    else if (bAig_isVarNode(manager,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      resBdd = Ddi_BddMakeLiteral(v,1);
      resAig = Ddi_BddMakeLiteralAig(v,1);
      if (constrainCare != NULL) {
	Ddi_BddConstrainAcc(resBdd,constrainCare);
      }
    }
#if 0
    else if (enSizeChk) {

	char name[100];
	Ddi_Var_t *aV;
        sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV)+auxVarIdStart);
	//	if (Ddi_VararrayNum(auxV) > 1000 && th < 10000) th = th*2;
	cutsDone = 1;
        aV = Ddi_VarFromName(ddm,name);
        if (aV == NULL) {
          aV = Ddi_VarNew(ddm);
          Ddi_VarAttachName (aV, name);
        }

      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);


	resAig = Ddi_BddMakeFromBaig(ddm,baig);
        Ddi_BddarrayInsertLast(auxF,resAig);
	Ddi_Free(resAig);
	resBdd = Ddi_BddMakeLiteral(aV,1);
	resAig = Ddi_BddMakeLiteralAig(aV,1);
	Ddi_VararrayInsertLast(auxV,aV);

    }
    else if (dominators[i] < 0) {
      resBdd = resAig = NULL;
    }
#endif
    else {
      bAigEdge_t auxRes;
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");

      if (useCutLayer) {
      /* skip nodes with fanin not evalued or on current cut layer */
      if (evalDone[ir]<0 || (cutLayer[ir]>=0 && cutLayer[ir]==currCutLayer)) {
	continue;
      }
      if (evalDone[il]<0 || (cutLayer[il]>=0 && cutLayer[il]==currCutLayer)) {
	continue;
      }
      }

      nPendingRef[ir]--;
      nPendingRef[il]--;
      Pdtutil_Assert(nPendingRef[ir]>=0,"Invalid pending ref");
      Pdtutil_Assert(nPendingRef[il]>=0,"Invalid pending ref");

      resBdd = NULL;
      rightBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,right));
      leftBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,left));
      rightAig = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr0(manager,right));
      leftAig = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr0(manager,left));
      if (bAig_NodeIsInverted(right)) {
        Ddi_BddNotAcc(rightBdd);
        Ddi_BddNotAcc(rightAig);
      }
      if (bAig_NodeIsInverted(left)) {
        Ddi_BddNotAcc(leftBdd);
        Ddi_BddNotAcc(leftAig);
      }

      if (0&&th>0) {
        Ddi_MgrAbortOnSiftEnableWithThresh(ddm,2*th,0);
      }
      resAig = Ddi_BddAnd(rightAig,leftAig);
      auxRes = Ddi_BddToBaig(resAig);
      if (bAig_AuxPtr(manager,auxRes)!=NULL) {
        resBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,auxRes));
        if (bAig_NodeIsInverted(auxRes)) {
          Ddi_BddNotAcc(resBdd);
	}
	ddm->stats.aig.n_merge_2++;
      }
      else {
        resBdd = Ddi_BddAnd(rightBdd,leftBdd);
        if (0&&th>0) {
          Ddi_MgrAbortOnSiftDisable(ddm);
        }
        if (cutOnFaninNode &&
           (resBdd == NULL || th > 0 && Ddi_BddSize(resBdd) > th)) {
          char name[100];
          Ddi_Var_t *aV;
          Ddi_Free(resBdd);
          Ddi_Free(resAig);
          if (1 &&(/*nRef[ir]==1&&*/
                  Ddi_BddSize(rightBdd)>Ddi_BddSize(leftBdd))) {
	    cutsDone = 1;
	    //	    totncuts++;
            sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV)+auxVarIdStart);
	    //	    if (Ddi_VararrayNum(auxV) > 1000 && th < 10000) th = th*2;
            aV = Ddi_VarFromName(ddm,name);
            if (aV == NULL) {
              aV = Ddi_VarNewBeforeVar(Ddi_BddTopVar(rightBdd));
              Ddi_VarAttachName (aV, name);
            }
            Ddi_Free(rightBdd);
            Ddi_Free(rightAig);
            /* warning: these ar not complemented! */
            rightBdd = (Ddi_Bdd_t*)(bAig_AuxPtr(manager,right));
            rightAig = (Ddi_Bdd_t*)(bAig_AuxPtr0(manager,right));
            if (enPartial) {
	      //              Ddi_BddSetAig(rightBdd);
              if (1&&(Ddi_BddSize(rightAig)<Ddi_BddSize(rightBdd))) {
                Ddi_BddarrayInsertLast(auxF,rightAig);
              }
              else {
                Ddi_BddarrayInsertLast(auxF,rightBdd);
              }
            }
            else {
              Ddi_BddarrayInsertLast(auxF,rightBdd);
            }

            Ddi_Free(bAig_AuxPtr(manager,right));
            Ddi_Free(bAig_AuxPtr0(manager,right));
            rightBdd = Ddi_BddMakeLiteral(aV,1);
            rightAig = Ddi_BddMakeLiteralAig(aV,1);
            bAig_AuxPtr(manager,right) = Ddi_BddDup(rightBdd);
            bAig_AuxPtr0(manager,right) = Ddi_BddDup(rightAig);
            if (bAig_NodeIsInverted(right)) {
              Ddi_BddNotAcc(rightBdd);
              Ddi_BddNotAcc(rightAig);
            }
            Ddi_VararrayInsertLast(auxV,aV);
	    cutLayer[ir] = currCutLayer;
          }
          else /*if (nRef[il]==1)*/ {
	    //	    totncuts++;
            sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV)+auxVarIdStart);
	    //	    if (Ddi_VararrayNum(auxV) > 1000 && th < 10000) th = th*2;
	    cutsDone = 1;
            aV = Ddi_VarFromName(ddm,name);
            if (aV == NULL) {
              aV = Ddi_VarNewBeforeVar(Ddi_BddTopVar(leftBdd));
              Ddi_VarAttachName (aV, name);
            }
            Ddi_Free(leftBdd);
            Ddi_Free(leftAig);
            /* warning: these ar not complemented! */
            leftBdd = (Ddi_Bdd_t*)(bAig_AuxPtr(manager,left));
            leftAig = (Ddi_Bdd_t*)(bAig_AuxPtr0(manager,left));
            if (enPartial) {
              //Ddi_BddSetAig(leftBdd);
              if (1&&(Ddi_BddSize(leftAig)<Ddi_BddSize(leftBdd))) {
                Ddi_BddarrayInsertLast(auxF,leftAig);
              }
              else {
                Ddi_BddarrayInsertLast(auxF,leftBdd);
              }
            }
            else {
              Ddi_BddarrayInsertLast(auxF,leftBdd);
            }
            Ddi_Free(bAig_AuxPtr(manager,left));
            Ddi_Free(bAig_AuxPtr0(manager,left));
            leftBdd = Ddi_BddMakeLiteral(aV,1);
            leftAig = Ddi_BddMakeLiteralAig(aV,1);
            bAig_AuxPtr(manager,left) = Ddi_BddDup(leftBdd);
            bAig_AuxPtr0(manager,left) = Ddi_BddDup(leftAig);
            if (bAig_NodeIsInverted(left)) {
              Ddi_BddNotAcc(leftBdd);
              Ddi_BddNotAcc(leftAig);
            }
            Ddi_VararrayInsertLast(auxV,aV);
	    cutLayer[il] = currCutLayer;
          }
          if (0&&th>0) {
            Ddi_MgrAbortOnSiftEnableWithThresh(ddm,2*th,0);
          }
          resBdd = Ddi_BddAnd(rightBdd,leftBdd);
          resAig = Ddi_BddAnd(rightAig,leftAig);
          if (0&&th>0) {
            Ddi_MgrAbortOnSiftDisable(ddm);
          }
        }
      }
      if (nRef[i]>1) {
	nMultipleFo++;
      }
      if (resBdd == NULL || (resBdd != NULL && th > 0
       && (((Ddi_BddSize(resBdd) > th) ||
           (0 && nRef[i]>1 && auxV != NULL && Ddi_VararrayNum(auxV) > 2 &&
	    Ddi_BddSize(resBdd) > th/(Ddi_VararrayNum(auxV)<100 ?
              Ddi_VararrayNum(auxV) : 100 )))
           ) && (1||(Ddi_VararrayNum(auxV)<10000)))) {
	if (auxV == NULL) {
	  doAbort = 1;
	}
	else {
	char name[100];
	Ddi_Var_t *aV;
	//	    totncuts++;
        sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV)+auxVarIdStart);
	//	if (Ddi_VararrayNum(auxV) > 1000 && th < 10000) th = th*2;
	cutsDone = 1;
        aV = Ddi_VarFromName(ddm,name);
        if (aV == NULL) {
          aV = Ddi_VarNewBeforeVar(Ddi_BddTopVar(resBdd));
          Ddi_VarAttachName (aV, name);
        }
        if (enPartial) {
          Ddi_BddSetAig(resBdd);
          if (Ddi_BddSize(resAig)<Ddi_BddSize(resBdd)) {
            Ddi_Free(resBdd);
            resBdd=resAig;
	    resAig = NULL;
          }
          else {
            Ddi_Free(resAig);
          }
	}
        Ddi_BddarrayInsertLast(auxF,resBdd);
	Ddi_Free(resBdd);
	Ddi_Free(resAig);
	resBdd = Ddi_BddMakeLiteral(aV,1);
	resAig = Ddi_BddMakeLiteralAig(aV,1);
        Ddi_VararrayInsertLast(auxV,aV);
	cutLayer[i] = currCutLayer;
	}
      }
      Ddi_Free(rightBdd);
      Ddi_Free(leftBdd);
      Ddi_Free(rightAig);
      Ddi_Free(leftAig);
      nRef[ir]--; nRef[il]--;
      if (1||th<0 || !cutsDone) {
	Ddi_Bdd_t *toFreeBdd=NULL, *toFreeAig=NULL;
	//        if (i>=lastRef[ir]) {
        if (nRef[ir]<=0) {
	  DdNode *toFreeCU;
          toFreeBdd = (Ddi_Bdd_t*)bAig_AuxPtr(manager,right);
          toFreeAig = (Ddi_Bdd_t*)bAig_AuxPtr0(manager,right);
          bAig_AuxPtr(manager,right) = NULL;
          bAig_AuxPtr0(manager,right) = NULL;
	  toFreeCU = Cudd_Regular(Ddi_BddToCU(toFreeBdd));
          Ddi_Free(toFreeAig);
          if (st_delete(bddTObaigTable, (char *) (&toFreeAig), NULL)) {
            Ddi_Free(toFreeAig);
          }
          Ddi_Free(toFreeBdd);
  	  nBdds--;
        }
	//        if (i>=lastRef[il]) {
        if (nRef[il]<=0) {
	  DdNode *toFreeCU;
          toFreeBdd = (Ddi_Bdd_t*)bAig_AuxPtr(manager,left);
          toFreeAig = (Ddi_Bdd_t*)bAig_AuxPtr0(manager,left);
          bAig_AuxPtr(manager,left) = NULL;
          bAig_AuxPtr0(manager,left) = NULL;
	  toFreeCU = Cudd_Regular(Ddi_BddToCU(toFreeBdd));
          Ddi_Free(toFreeAig);
          if (st_delete(bddTObaigTable, (char *) (&toFreeAig), NULL)) {
            Ddi_Free(toFreeAig);
          }
          Ddi_Free(toFreeBdd);
 	  nBdds--;
        }
      }
#if 0
      else
      {
	Ddi_Bdd_t *node_i;
	DdNode *cuNode = Cudd_Regular (Ddi_BddToCU(resBdd));
        if (st_lookup_int(bddTObaigTable, (char *) cuNode, (int *)&node_i)) {
	  Ddi_Bdd_t *resAig2;
	  /* merge node_i <-> i */
          resAig2 = Ddi_BddDup(node_i);
	  if (0&&(Ddi_BddSize(resAig)<Ddi_BddSize(resAig2))) {
            if (Ddi_BddIsComplement(resBdd)) {
              Ddi_BddNotAcc(resAig);
	    }
            DdiGenericDataCopy((Ddi_Generic_t *)node_i,
                               (Ddi_Generic_t *)resAig);
	    Ddi_Free(resAig2);
            resAig2 = Ddi_BddDup(resAig);
	  }
	  Ddi_Free(resAig);
	  resAig = resAig2;
          if (Ddi_BddIsComplement(resBdd)) {
            Ddi_BddNotAcc(resAig);
	  }
	  ddm->settings.aig.n_merge_3++;
	}
	else {
	  node_i = Ddi_BddDup(resAig);
          if (Ddi_BddIsComplement(resBdd)) {
	    Ddi_BddNotAcc(node_i);
	  }
          st_insert(bddTObaigTable, (char *) cuNode, (char *) (long) node_i);
	}
      }
#endif

    }
    bAig_AuxPtr(manager,baig) = (void *) resBdd;
    bAig_AuxPtr0(manager,baig) = (void *) resAig;

    if (isOutput[i] && evalDone[i]<0) {
      nDoneOutputs++;
      //      isOutput[i] = 0;
      //      fprintf(dMgrO(ddm),"BAIG: %d - i: %d - no: %d/%d\n", baig, i,
      //  nDoneOutputs, nOutputs);
    }
    evalDone[i]=currCutLayer;
    nBdds++; nEval++;
    if (nBdds > maxN) {
      maxN = nBdds;
    }
  }

  for (i=0; i<visitedNodes->num-1; i++) {
    baig = visitedNodes->nodes[i];

    if (evalDone[i]<0 || bAig_AuxPtr(manager,baig)==NULL) continue;

    /* if no pending fanout & not a cut point */
    if (/*evalDone[i]<currCutLayer-1 &&*/ nPendingRef[i]==0 && cutLayer[i]<0) {
      Ddi_Bdd_t *toFreeBdd=NULL, *toFreeAig=NULL;
      DdNode *toFreeCU;
      toFreeBdd = (Ddi_Bdd_t*)bAig_AuxPtr(manager,baig);
      toFreeAig = (Ddi_Bdd_t*)bAig_AuxPtr0(manager,baig);
      Ddi_Free(toFreeAig);
      bAig_AuxPtr(manager,baig) = NULL;
      bAig_AuxPtr0(manager,baig) = NULL;
      toFreeCU = Cudd_Regular(Ddi_BddToCU(toFreeBdd));
      if (st_lookup(bddTObaigTable, (char *) toFreeCU, (char **)&toFreeAig)) {
        Ddi_Free(toFreeAig);
        st_delete(bddTObaigTable, (char *) (&toFreeCU), NULL);
      }
      Ddi_Free(toFreeBdd);
      nBdds--;
    }
  }

  currCutLayer++;

  } while (nDoneOutputs < nOutputs && nEval<visitedNodes->num);

  if (1)
  {
    DdNode *tmp;
    Ddi_Bdd_t *toFreeAig;
    st_foreach_item(bddTObaigTable, stgen, (char**)&tmp, (char **)&toFreeAig){
      Ddi_Free(toFreeAig);
      Pdtutil_Assert(tmp==Cudd_Regular(tmp),"Wrong node in st table");
    }
  }

  st_free_table(bddTObaigTable);


  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = -1;
  }

  Ddi_Free(constrainBdd);

  Pdtutil_Free(lastRef);
  Pdtutil_Free(nRef);
  Pdtutil_Free(nPendingRef);
  Pdtutil_Free(cutLayer);
  Pdtutil_Free(evalDone);
  Pdtutil_Free(isOutput);
  Pdtutil_Free(eqNode);

  Pdtutil_Free(dominators);
  Pdtutil_Free(enCutVar);

  resArray = Ddi_BddarrayAlloc(ddm,nodeRoots->num);

  for (i=0; i<nodeRoots->num; i++) {
    baig = nodeRoots->nodes[i];
    if (bAig_NodeIsConstant(baig)) {
      resBdd = Ddi_BddMakeConst(ddm,0);
      resAig = Ddi_BddMakeConstAig(ddm,0);
    }
    else {
      resBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,baig));
      resAig = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr0(manager,baig));
      //      bAig_AuxPtr(manager,baig) = NULL;
      //      bAig_AuxPtr0(manager,baig) = NULL;
      Pdtutil_Assert(resBdd != NULL,"invalid result bdd");
    }
    if (bAig_NodeIsInverted(baig)){
      Ddi_BddNotAcc(resBdd);
      Ddi_BddNotAcc(resAig);
    }

    if (enPartial) {
      Ddi_BddSetAig(resBdd);
      if (Ddi_BddSize(resAig)<Ddi_BddSize(resBdd)) {
        Ddi_Bdd_t *t=resBdd; resBdd=resAig; resAig=t;
      }
    }
    Ddi_Free(resAig);

    if (doAbort > 0) {
      Ddi_Free(resBdd);
      Ddi_Free(resArray);
    }
    else {
      Ddi_BddarrayWrite(resArray,i,resBdd);
      Ddi_Free(resBdd);
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    Ddi_Free(bAig_AuxPtr(manager,baig));
    bAig_AuxPtr(manager,baig)=NULL;
    Ddi_Free(bAig_AuxPtr0(manager,baig));
    bAig_AuxPtr0(manager,baig)=NULL;
  }

  bAigArrayFree(visitedNodes);

#if 0
  Ddi_MgrReduceHeap (ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);
#endif

  if (doAbort <= 0) {
    Ddi_MgrCheckExtRef(ddm,extRef+1);
  }
  return (resArray);
}

#if 1

/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aig2BddGenCutsIntern(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex,
  int th,
  Ddi_Vararray_t *auxV,
  Ddi_Bddarray_t *auxF
)
{
  Ddi_Bdd_t *leftBdd, *rightBdd, *resBdd;
  bAigEdge_t left, right, baig;
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  int nBdds, maxN;
  int i, *lastRef, *nRef, *isCut;
  int extRef = Ddi_MgrReadExtRef(ddm);
  st_table *bddTObaigTable;
  int doAbort = 0;

  bddTObaigTable = st_init_table(st_numcmp, st_numhash);

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(manager,nodeIndex,visitedNodes,-1);
  postOrderAigClearVisitedIntern(manager,visitedNodes);
  maxN = nBdds = 0;

  lastRef = Pdtutil_Alloc(int,visitedNodes->num);
  nRef = Pdtutil_Alloc(int,visitedNodes->num);
  isCut = Pdtutil_Alloc(int,visitedNodes->num);

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = i;
    lastRef[i] = 0;
    nRef[i] = 1;
    isCut[i] = 0;
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      lastRef[ir] = lastRef[il] = i;
      nRef[ir]++; nRef[il]++;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    baig = visitedNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || doAbort>0) {
      resBdd = Ddi_BddMakeConst(ddm,0);
    }
    else if (bAig_isVarNode(manager,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      resBdd = Ddi_BddMakeLiteral(v,1);
    }
    else {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      rightBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,right));
      leftBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,left));
      if (bAig_NodeIsInverted(right)) {
        Ddi_BddNotAcc(rightBdd);
      }
      if (bAig_NodeIsInverted(left)) {
        Ddi_BddNotAcc(leftBdd);
      }

      if (0&&th>0) {
        Ddi_MgrAbortOnSiftEnableWithThresh(ddm,2*th,0);
      }
      resBdd = Ddi_BddAnd(rightBdd,leftBdd);
      if (0&&th>0) {
        Ddi_MgrAbortOnSiftDisable(ddm);
      }
      if (1 && (resBdd == NULL || th > 0 && Ddi_BddSize(resBdd) > th)) {
	char name[100];
	Ddi_Var_t *aV;
	Ddi_Free(resBdd);
	if ((!bAig_isVarNode(manager,right)) &&
          nRef[ir]>1 && Ddi_BddSize(rightBdd)>Ddi_BddSize(leftBdd)) {
	  int k;
          sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV));
	  aV = Ddi_VarFromName(ddm,name);
	  if (aV == NULL) {
	    aV = Ddi_VarNewBeforeVar(Ddi_BddTopVar(rightBdd));
            Ddi_VarAttachName (aV, name);
	  }
	  for (k=0;k<Ddi_VararrayNum(auxV);k++) {
	    Pdtutil_Assert(
	      strcmp(name,Ddi_VarName(Ddi_VararrayRead(auxV,k)))!=0,
              "DUPLICATE NAME");
	  }
	  Ddi_Free(rightBdd);
          Ddi_Free(bAig_AuxPtr(manager,right));
	  rightBdd = Ddi_BddMakeLiteral(aV,1);
          bAig_AuxPtr(manager,right) = Ddi_BddDup(rightBdd);
          if (bAig_NodeIsInverted(right)) {
            Ddi_BddNotAcc(rightBdd);
          }
	  isCut[ir] = 1;
	}
	else if ((!bAig_isVarNode(manager,left)) && nRef[il]>1) {
	  int k;
          sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV));
	  aV = Ddi_VarFromName(ddm,name);
	  if (aV == NULL) {
  	    aV = Ddi_VarNewBeforeVar(Ddi_BddTopVar(leftBdd));
            Ddi_VarAttachName (aV, name);
	  }
	  for (k=0;k<Ddi_VararrayNum(auxV);k++) {
	    Pdtutil_Assert(
	      strcmp(name,Ddi_VarName(Ddi_VararrayRead(auxV,k)))!=0,
              "DUPLICATE NAME");
	  }
	  Ddi_Free(leftBdd);
          Ddi_Free(bAig_AuxPtr(manager,left));
	  leftBdd = Ddi_BddMakeLiteral(aV,1);
          bAig_AuxPtr(manager,left) = Ddi_BddDup(leftBdd);
          if (bAig_NodeIsInverted(left)) {
            Ddi_BddNotAcc(leftBdd);
          }
	  isCut[il] = 1;
	}
        if (0&&th>0) {
          Ddi_MgrAbortOnSiftEnableWithThresh(ddm,2*th,0);
        }
        resBdd = Ddi_BddAnd(rightBdd,leftBdd);
        if (0&&th>0) {
          Ddi_MgrAbortOnSiftDisable(ddm);
        }
      }
      if (resBdd != NULL && th > 0 && Ddi_BddSize(resBdd) > th && nRef[i]>1) {
	if (auxV == NULL) {
	  /* abort */
	  doAbort = i+1;
	}
        else {
      	  char name[100];
      	  Ddi_Var_t *aV;
          sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV));
          aV = Ddi_VarFromName(ddm,name);
          if (aV == NULL) {
            aV = Ddi_VarNewBeforeVar(Ddi_BddTopVar(resBdd));
            Ddi_VarAttachName (aV, name);
          }
      	  Ddi_Free(resBdd);
      	  resBdd = Ddi_BddMakeLiteral(aV,1);
      	  isCut[i] = 1;
        }
      }
      Ddi_Free(rightBdd);
      Ddi_Free(leftBdd);
      if (!isCut[ir] && i>=lastRef[ir]) {
        Ddi_Free(bAig_AuxPtr(manager,right));
        nBdds--;
      }
      if (!isCut[il] && i>=lastRef[il]) {
        Ddi_Free(bAig_AuxPtr(manager,left));
        nBdds--;
      }
#if 0
      else {
	int node_i;
	DdNode *cuNode = Cudd_Regular (Ddi_BddToCU(resBdd));

        if (st_lookup_int(bddTObaigTable, (char *) cuNode, (int*)&node_i)) {
	  /* merge node_i <-> i */
	  ddm->settings.aig.n_merge_3++;
	}
	else {
          st_insert(bddTObaigTable, (char *) cuNode, (char *) (long) i);
	}
      }
#endif

    }
    bAig_AuxPtr(manager,baig) = (void *) resBdd;
    nBdds++;
    if (nBdds > maxN) {
      maxN = nBdds;
    }
  }

  if (!isCut[visitedNodes->num-1]) {
    baig = visitedNodes->nodes[visitedNodes->num-1];
    Ddi_Free(bAig_AuxPtr(manager,baig));
    nBdds--;
  }

  if (doAbort == 0)
  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    baig = visitedNodes->nodes[i];
    if (bAig_NodeIsConstant(baig)) {
      resBdd = Ddi_BddMakeConstAig(ddm,0);
    }
    else if (bAig_isVarNode(manager,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      resBdd = Ddi_BddMakeLiteralAig(v,1);
    }
    else {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      rightBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,right));
      leftBdd = Ddi_BddDup((Ddi_Bdd_t *)bAig_AuxPtr(manager,left));
      if (bAig_NodeIsInverted(right)) {
        Ddi_BddNotAcc(rightBdd);
      }
      if (bAig_NodeIsInverted(left)) {
        Ddi_BddNotAcc(leftBdd);
      }

      resBdd = Ddi_BddAnd(rightBdd,leftBdd);

      Ddi_Free(rightBdd);
      Ddi_Free(leftBdd);

      if (isCut[i]) {
  	Ddi_Var_t *aV;
        Ddi_BddarrayInsertLast(auxF,resBdd);
	Ddi_Free(resBdd);
        resBdd = (Ddi_Bdd_t *)bAig_AuxPtr(manager,baig);
	Ddi_BddSetMono(resBdd);
        aV = Ddi_BddTopVar(resBdd);
	Ddi_VararrayInsertLast(auxV,aV);
	Ddi_BddSetAig(resBdd);
      }
    }
    bAig_AuxPtr(manager,baig) = (void *) resBdd;
  }

  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_AuxInt(manager,baig) = -1;
  }

  Pdtutil_Free(lastRef);
  Pdtutil_Free(nRef);
  Pdtutil_Free(isCut);

  baig = visitedNodes->nodes[visitedNodes->num-1];
  resBdd = (Ddi_Bdd_t *)bAig_AuxPtr(manager,baig);
  bAig_AuxPtr(manager,baig) = NULL;
  Pdtutil_Assert(resBdd != NULL,"invalid result bdd");
  Pdtutil_Assert(baig == nodeIndex,"mismatching baigs");

  if (bAig_NodeIsInverted(baig)){
    Ddi_BddNotAcc(resBdd);
  }

#if 0
  fprintf(dMgrO(ddm),"AIG2BDD: %d/%d -> %d\n",
    maxN, visitedNodes->num, Ddi_BddSize(resBdd));
#endif

  st_free_table(bddTObaigTable);
  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    Ddi_Free(bAig_AuxPtr(manager,baig));
  }

  bAigArrayFree(visitedNodes);

  Ddi_MgrCheckExtRef(ddm,extRef+1);

  if (doAbort > 0) {
    Ddi_Free(resBdd);
    return NULL;
  }

  return (resBdd);
}

#endif

/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aig2BddDiffInternWithCuts(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex,
  int th,
  Ddi_Vararray_t *auxV,
  Ddi_Bddarray_t *auxF
)
{
  Ddi_Bdd_t *leftBdd0, *rightBdd0, *leftBdd1, *rightBdd1,
    *resBdd0, *resBdd1;
  bAigEdge_t left, right, baig, f0, f1;
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  int nBdds, maxN;
  int i, eq=0, diff=0;
  int extRef = Ddi_MgrReadExtRef(ddm);
  st_table *bddTObaigTable;

  bddTObaigTable = st_init_table(st_numcmp, st_numhash);

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(manager,nodeIndex,visitedNodes,-1);
  postOrderAigClearVisitedIntern(manager,visitedNodes);
  maxN = nBdds = 0;

  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_AuxRef(manager,baig) = 0;

    if (!(bAig_NodeIsConstant(baig) || bAig_isVarNode(manager,baig))) {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      bAig_AuxRef(manager,right)++;
      bAig_AuxRef(manager,left)++;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    char name[1000];
    Ddi_Var_t *aV;
    baig = visitedNodes->nodes[i];
    f0 = bAig_AuxAig0(manager,baig);
    f1 = bAig_AuxAig1(manager,baig);

    if (f0 == f1) {
      bAig_AuxPtr0(manager,baig) = bAig_AuxPtr1(manager,baig) = NULL;
      eq++;
    }
    else {
    diff++;
    Pdtutil_Assert(!bAig_NodeIsConstant(baig),"Constant AIG !");
    if (bAig_isVarNode(manager,baig)) {
      resBdd0 = Ddi_BddSetMono(Ddi_BddMakeFromBaig(ddm,f0));
      resBdd1 = Ddi_BddSetMono(Ddi_BddMakeFromBaig(ddm,f1));
    }
    else {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      if (bAig_AuxPtr0(manager,right) == NULL) {
        rightBdd0 = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig0(manager,right));
        if (bAig_isVarNode(manager,right)) {
	  Ddi_BddSetMono(rightBdd0);
          bAig_AuxPtr0(manager,right) = Ddi_BddDup(rightBdd0);
          bAig_AuxPtr1(manager,right) = rightBdd0;
	}
	else {
	  Ddi_BddarrayInsertLast(auxF,rightBdd0);
	  Ddi_Free(rightBdd0);
          sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV));
	  aV = Ddi_VarFromName(ddm,name);
	  if (aV == NULL) {
	    aV = Ddi_VarNew(ddm);
            Ddi_VarAttachName (aV, name);
  	  }
	  Ddi_VararrayInsertLast(auxV,aV);
	  bAig_AuxPtr0(manager,right) =
            Ddi_BddSetMono(Ddi_BddMakeLiteralAig(aV,1));
	  bAig_AuxPtr1(manager,right) =
            Ddi_BddSetMono(Ddi_BddMakeLiteralAig(aV,1));
	}
      }
      if (bAig_AuxPtr0(manager,left) == NULL) {
	leftBdd0 = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig0(manager,left));
        if (bAig_isVarNode(manager,left)) {
	  Ddi_BddSetMono(leftBdd0);
          bAig_AuxPtr0(manager,left) = Ddi_BddDup(leftBdd0);
          bAig_AuxPtr1(manager,left) = leftBdd0;
	}
	else {
  	  Ddi_BddarrayInsertLast(auxF,leftBdd0);
  	  Ddi_Free(leftBdd0);
          sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV));
	  aV = Ddi_VarFromName(ddm,name);
	  if (aV == NULL) {
	    aV = Ddi_VarNew(ddm);
            Ddi_VarAttachName (aV, name);
 	  }
	  Ddi_VararrayInsertLast(auxV,aV);
	  bAig_AuxPtr0(manager,left) =
            Ddi_BddSetMono(Ddi_BddMakeLiteralAig(aV,1));
	  bAig_AuxPtr1(manager,left) =
            Ddi_BddSetMono(Ddi_BddMakeLiteralAig(aV,1));
	}
      }
      rightBdd0 = Ddi_BddDup((Ddi_Bdd_t*)bAig_AuxPtr0(manager,right));
      rightBdd1 = Ddi_BddDup((Ddi_Bdd_t*)bAig_AuxPtr1(manager,right));
      if (bAig_NodeIsInverted(right)) {
        Ddi_BddNotAcc(rightBdd0);
        Ddi_BddNotAcc(rightBdd1);
      }
      leftBdd0 = Ddi_BddDup((Ddi_Bdd_t*)bAig_AuxPtr0(manager,left));
      leftBdd1 = Ddi_BddDup((Ddi_Bdd_t*)bAig_AuxPtr1(manager,left));
      if (bAig_NodeIsInverted(left)) {
        Ddi_BddNotAcc(leftBdd0);
        Ddi_BddNotAcc(leftBdd1);
      }

      resBdd0 = Ddi_BddAnd(rightBdd0,leftBdd0);
      resBdd1 = Ddi_BddAnd(rightBdd1,leftBdd1);

      Ddi_Free(rightBdd0);
      Ddi_Free(leftBdd0);
      Ddi_Free(rightBdd1);
      Ddi_Free(leftBdd1);

    }
    bAig_AuxPtr0(manager,baig) = (void *) resBdd0;
    bAig_AuxPtr1(manager,baig) = (void *) resBdd1;
    nBdds++;
    if (nBdds > maxN) {
      maxN = nBdds;
    }
    }
    if (!(bAig_NodeIsConstant(baig) || bAig_isVarNode(manager,baig))) {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      if (--bAig_AuxRef(manager,right)<=0) {
        Ddi_Free(bAig_AuxPtr0(manager,right));
        Ddi_Free(bAig_AuxPtr1(manager,right));
	nBdds--;
      }
      if (--bAig_AuxRef(manager,left)<=0) {
        Ddi_Free(bAig_AuxPtr0(manager,left));
        Ddi_Free(bAig_AuxPtr1(manager,left));
	nBdds--;
      }
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    bAig_AuxRef(manager,baig) = 0;
  }

  baig = visitedNodes->nodes[visitedNodes->num-1];
  resBdd0 = (Ddi_Bdd_t *)bAig_AuxPtr0(manager,baig);
  bAig_AuxPtr0(manager,baig) = NULL;
  resBdd1 = (Ddi_Bdd_t *)bAig_AuxPtr1(manager,baig);
  bAig_AuxPtr1(manager,baig) = NULL;
  Pdtutil_Assert(baig == nodeIndex,"mismatching baigs");

  if (resBdd0 == NULL) {
    return (NULL);
  }

  if (bAig_NodeIsInverted(baig)){
    Ddi_BddNotAcc(resBdd0);
    Ddi_BddNotAcc(resBdd1);
  }

  Ddi_BddOrAcc(resBdd0,resBdd1);
  Ddi_Free(resBdd1);

  Ddi_MgrReduceHeap (ddm, Ddi_ReorderingMethodString2Enum((char *)"sift"), 0);

#if 1
  fprintf(dMgrO(ddm),"AIG2BDDDIFF: %d/%d (eq:%d,diff:%d) -> %d\n",
    maxN, visitedNodes->num, eq, diff, Ddi_BddSize(resBdd0));
#endif

  st_free_table(bddTObaigTable);
  for (i=0; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    Ddi_Free(bAig_AuxPtr0(manager,baig));
    Ddi_Free(bAig_AuxPtr1(manager,baig));
  }

  Ddi_MgrCheckExtRef(ddm,extRef+1);
  return (resBdd0);
}


/**Function********************************************************************

  Synopsis    [Inner steps of aig to CNF conversion]
  Description [Inner steps of aig to CNF conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aig2CnfIntern(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex,
  FILE *fp                       /* IN: pointer to the store file */,
  int *clauseNPtr                /* OUT: number of added clauses */,
  int *varMaxPtr                 /* OUT: mac var ID */
)
{
  bAig_Manager_t *manager = ddm->aig.mgr;

  Pdtutil_Assert ((nodeIndex!=bAig_Zero && nodeIndex!=bAig_One),
    "constant AIG found in AIG2CNF");

  if (aig2CnfId(manager,nodeIndex) > *varMaxPtr) {
    *varMaxPtr = aig2CnfId(manager,nodeIndex);
  }

  if (bAig_isVarNode(manager,nodeIndex)) {
    return;
  }

  if (nodeVisited(manager,nodeIndex)>=4) {
    Pdtutil_Assert (nodeVisited(manager,nodeIndex)<8,
      "Error setting visited flag");
    return;
  }
  else {
    int f, a, b;
    bAigEdge_t right = bAig_NodeReadIndexOfRightChild(manager,nodeIndex);
    bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(manager,nodeIndex);

    Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");
    aig2CnfIntern(ddm,right,fp,clauseNPtr,varMaxPtr);
    aig2CnfIntern(ddm,left,fp,clauseNPtr,varMaxPtr);

    /* convert AIG node to cnf clauses */
    /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
    f = aig2CnfId(manager,nodeIndex);
    a = bAig_NodeIsInverted(right) ? -aig2CnfId(manager,right) :
                                      aig2CnfId(manager,right);
    b = bAig_NodeIsInverted(left) ? -aig2CnfId(manager,left) :
                                     aig2CnfId(manager,left);
    fprintf(fp, "%d %d %d 0\n", f, -a, -b);
    fprintf(fp, "%d %d 0\n", -f, a);
    fprintf(fp, "%d %d 0\n", -f, b);
    *clauseNPtr += 3;

    nodeVisited(manager,nodeIndex) += 4;
  }

  return;
}



/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static bAigEdge_t
composeIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  int enaMultiple
)
{
  bAigEdge_t res, right, left, r, l;
  int neg = bAig_NodeIsInverted(nodeIndex);

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    return (nodeIndex);
  }

  if (printCompose) printf("compose node: %d\n", nodeIndex);

  if (bAig_isVarNode(manager,nodeIndex)) {
    if (nodeVisited(manager,nodeIndex)) {
      if (nodeVisited(manager,nodeIndex)==2) {
        printf("problem\n");
      }
      Pdtutil_Assert(nodeVisited(manager,nodeIndex)!=2,"circular var dep.");
      if (enaMultiple && nodeVisited(manager,nodeIndex)==1) {
	nodeVisited(manager,nodeIndex) = 2;
        res = composeIntern(manager,
          bAig_AuxPtrNum(manager,nodeIndex),enaMultiple);
	nodeVisited(manager,nodeIndex) = 1;
      }
      else {
        res = bAig_AuxPtrNum(manager,nodeIndex);
      }
      if (neg){
        res = bAig_Not(res);
      }
      if (printCompose) printf("compose C: %d\n", res);
    }
    else {
      res = nodeIndex;
    }
  }
  else {
    if (nodeVisited(manager,nodeIndex)) {
      res = bAig_AuxPtrNum(manager,nodeIndex);
    }
    else {
      r = bAig_NodeReadIndexOfRightChild(manager,nodeIndex);
      l = bAig_NodeReadIndexOfLeftChild(manager,nodeIndex);
      Pdtutil_Assert(bAig_NonInvertedEdge(nodeIndex)!=bAig_NonInvertedEdge(r),
		     "child != parent AIG");
      Pdtutil_Assert(bAig_NonInvertedEdge(nodeIndex)!=bAig_NonInvertedEdge(l),
		     "child != parent AIG");
      right = composeIntern(manager,r,enaMultiple);
      bAig_Ref(manager, right);
      left = composeIntern(manager,l,enaMultiple);
      bAig_Ref(manager, left);
      res = bAig_And(manager,right,left);
      bAig_Ref(manager, res);
      bAig_RecursiveDeref(manager,right);
      bAig_RecursiveDeref(manager,left);

      bAig_AuxPtrNum(manager,nodeIndex) = res;
      nodeSetVisited(manager,nodeIndex);
    }
    if (neg){
      res = bAig_Not(res);
    }
    if (printCompose) printf("compose C2: %d\n", res);
  }

  return (res);
}


/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
coiIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex
)
{
  bAigEdge_t res, right, left, r, l;
  int neg = bAig_NodeIsInverted(nodeIndex);

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    return;
  }
  if (nodeVisited(manager,nodeIndex)) {
    return;
  }

  nodeVisited(manager,nodeIndex) = 1;

  if (bAig_isVarNode(manager,nodeIndex)) {
    coiIntern(manager,bAig_AuxPtrNum(manager,nodeIndex));
  }
  else {
    r = bAig_NodeReadIndexOfRightChild(manager,nodeIndex);
    l = bAig_NodeReadIndexOfLeftChild(manager,nodeIndex);
    Pdtutil_Assert(bAig_NonInvertedEdge(nodeIndex)!=bAig_NonInvertedEdge(r),
		     "child != parent AIG");
    Pdtutil_Assert(bAig_NonInvertedEdge(nodeIndex)!=bAig_NonInvertedEdge(l),
		     "child != parent AIG");
    coiIntern(manager,r);
    coiIntern(manager,l);
  }

}


/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
FindMinCut
(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  Ddi_Var_t *initVar,
  Ddi_Varset_t *smoothVars,
  int observeLevels,
  int maxPiNum,
  int startFromPiFanout,
  int doFullFlow,
  float cutRatio
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  bAigEdge_t nodeIndex;
  bAigEdge_t varIndex;
  int nNodes, pathCnt, varCnt, minCutCnt, cutSize, smoothCnt;
  bAig_array_t *visitedNodes;
  mincut_info *nodeInfoArray;
  int i, k, startId, visitId, targetId, nRoots, *roots;
  int *bfvAuxArray;
  Ddi_Bdd_t *newF;
  int cutRegionSize, cutMaxSize, flowCnt;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int doPrint = 0||(verbosity >= Pdtutil_VerbLevelDevMax_c);
  int fIsPartConj = Ddi_BddIsPartConj(f);
  Ddi_Bdd_t *retF=NULL;
  int useFreePis=0;
  static int nCallsMinCut=0;

  //  doingMinCut = 1;

  nCallsMinCut++;

  if (!fIsPartConj) Ddi_BddSetPartConj(f);

  nRoots = Ddi_BddPartNum(f);
  roots = Pdtutil_Alloc(int,nRoots);

  visitedNodes = bAigArrayAlloc();

  for (i=0; i<nRoots; i++) {
    int prevSize = visitedNodes->num;
    Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
    nodeIndex = Ddi_BddToBaig(f_i);
    postOrderAigVisitIntern(bmgr,nodeIndex,visitedNodes,-1);
    if (visitedNodes->num > prevSize) {
      roots[i] = visitedNodes->num-1;
    }
    else {
      int j;
      for (j=visitedNodes->num-1; j>=0; j--) {
        if (bAig_NonInvertedEdge(visitedNodes->nodes[j]) ==
            bAig_NonInvertedEdge(nodeIndex)) {
          roots[i] = j;
	  break;
	}
      }
    }
  }
  aigArrayClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  nNodes = visitedNodes->num;
  cutMaxSize = nNodes;
  if (cutRatio >= 0) {
    cutMaxSize = (int) (cutRatio * cutMaxSize);
  }

  nodeInfoArray = Pdtutil_Alloc(mincut_info,nNodes);
  bfvAuxArray = Pdtutil_Alloc(int,nNodes);

  for (i=0; i<nNodes; i++) {
    nodeInfoArray[i].foCnt = -1;
    nodeInfoArray[i].foIds=NULL;
    nodeInfoArray[i].isPathNext=NULL;
    nodeInfoArray[i].fiIds[0] = nodeInfoArray[i].fiIds[1] = -1;
    nodeInfoArray[i].isFiPrev[0] = nodeInfoArray[i].isFiPrev[1] = 0;
    nodeInfoArray[i].visited = 0;
    nodeInfoArray[i].flowVisited = 0;
    nodeInfoArray[i].pathPrev = -1;
    nodeInfoArray[i].pathNext = -1;
    nodeInfoArray[i].bfVisited = 0;
    nodeInfoArray[i].inLevel = -1;
    nodeInfoArray[i].inLevelMin = -1;
    nodeInfoArray[i].outLevelMax = -1;
    nodeInfoArray[i].outLevel = -1;
    nodeInfoArray[i].refInput = -1;
    nodeInfoArray[i].cutIndex = -1;
    nodeInfoArray[i].isTarget = 0;
    nodeInfoArray[i].isInput = 0;
    nodeInfoArray[i].lockedInput = 0;
    nodeInfoArray[i].isSmoothInput = 0;
    nodeInfoArray[i].isSmooth = 0;
    nodeInfoArray[i].isMinCut = 0;
    nodeInfoArray[i].isShortEdgeCut = 0;
    nodeInfoArray[i].isShortEdge[0] = 0;
    nodeInfoArray[i].isShortEdge[1] = 0;
    nodeInfoArray[i].noFlowRegion = 0;
    nodeInfoArray[i].noCutRegion = 0;
  }

  /* initialize:
    - node<->id correspondence (using _AuxInt field
    - fanout count
    - fanin index info (fiIds field)
  */

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
    nodeInfoArray[i].foCnt = 0;
    if (!bAig_NodeIsConstant(baig) && bAig_isVarNode(bmgr,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      nodeInfoArray[i].isSmooth = Ddi_VarInVarset(smoothVars,v);
    }
    else if (!bAig_NodeIsConstant(baig)) {
      ir = rightChildAuxInt(bmgr,baig);
      il = leftChildAuxInt(bmgr,baig);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      Pdtutil_Assert(nodeInfoArray[ir].foCnt>=0,"fo cnt not initialized");
      Pdtutil_Assert(nodeInfoArray[il].foCnt>=0,"fo cnt not initialized");
      nodeInfoArray[ir].foCnt++;
      nodeInfoArray[il].foCnt++;
      nodeInfoArray[i].fiIds[0]=ir;
      nodeInfoArray[i].fiIds[1]=il;
    }
  }

  varIndex = Ddi_VarToBaig(initVar);
  Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
  startId = visitId = bAig_AuxInt(bmgr,varIndex);

  for (i=0; i<nRoots; i++) {
    targetId = roots[i];
    nodeInfoArray[targetId].isTarget = 1;
    nodeInfoArray[targetId].outLevel = 0;
    nodeInfoArray[targetId].outLevelMax = 0;
  }

  /* alloc fanout arrays */
  for (i=0; i<visitedNodes->num; i++) {
    nodeInfoArray[i].foIds = Pdtutil_Alloc(int,nodeInfoArray[i].foCnt);
    nodeInfoArray[i].isPathNext = Pdtutil_Alloc(char,nodeInfoArray[i].foCnt);
  }

  /* setup fanout info */
  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    bAigEdge_t baig = visitedNodes->nodes[i];

    nodeInfoArray[i].foCnt = 0;
    nodeInfoArray[i].inLevel = 0;

    ir = nodeInfoArray[i].fiIds[0];
    il = nodeInfoArray[i].fiIds[1];
    if (ir>=0 && il>=0) {
      int lr = nodeInfoArray[ir].inLevel;
      int ll = nodeInfoArray[il].inLevel;
      Pdtutil_Assert(nodeInfoArray[ir].foCnt>=0,"fo cnt not initialized");
      Pdtutil_Assert(nodeInfoArray[il].foCnt>=0,"fo cnt not initialized");
      nodeInfoArray[ir].foIds[nodeInfoArray[ir].foCnt]=i;
      nodeInfoArray[ir].isPathNext[nodeInfoArray[ir].foCnt]=0;
      nodeInfoArray[il].foIds[nodeInfoArray[il].foCnt]=i;
      nodeInfoArray[il].isPathNext[nodeInfoArray[il].foCnt]=0;
      nodeInfoArray[ir].foCnt++;
      nodeInfoArray[il].foCnt++;
      nodeInfoArray[i].inLevel = (lr > ll) ? lr+1 : ll+1;
    }
  }

  /* set optput level by bf backward visit: bfvAuxArray is used
     as FIFO data structure and output buffer */

  k=0;
  for (i=0; i<nRoots; i++) {
    bfvAuxArray[k++] = roots[i];
    nodeInfoArray[roots[i]].bfVisited = 1;
  }

  for (i=0; i<k && i<nNodes; i++) {
    int ir, il;
    int j = bfvAuxArray[i];
    int levelMax = nodeInfoArray[j].outLevelMax;
    int level = nodeInfoArray[j].outLevel;
    bAigEdge_t baig = visitedNodes->nodes[j];

    if (observeLevels < 0 && level < 1 || levelMax < observeLevels) {
      nodeInfoArray[j].isTarget = 1;
    }

    ir = nodeInfoArray[j].fiIds[0];
    il = nodeInfoArray[j].fiIds[1];
    if (ir>=0 && il>=0) {
      if (!nodeInfoArray[ir].bfVisited) {
	bfvAuxArray[k++] = ir;
        nodeInfoArray[ir].bfVisited = 1;
        nodeInfoArray[ir].outLevel = level+1;
      }
      if (levelMax+1 > nodeInfoArray[ir].outLevelMax) {
        nodeInfoArray[ir].outLevelMax = levelMax+1;
      }
      if (!nodeInfoArray[il].bfVisited) {
	bfvAuxArray[k++] = il;
        nodeInfoArray[il].bfVisited = 1;
        nodeInfoArray[il].outLevel = level+1;
      }
      if (levelMax+1 > nodeInfoArray[il].outLevelMax) {
        nodeInfoArray[il].outLevelMax = levelMax+1;
      }
    }
  }
  for (i=0; i<visitedNodes->num; i++) {
    nodeInfoArray[i].bfVisited = 0;
  }

  if (startId >= 0) {

    /* set input level by bf forward visit from startId node.
       Fanout and fanin edges are considered, so that nearest PIs are
       considered */
    bfvAuxArray[0] = startId;
    nodeInfoArray[startId].bfVisited = 1;
    flowCnt = 0;

    for (i=varCnt=0, k=1; i<k && i<nNodes; i++) {
      int ir, il, l;
      int j = bfvAuxArray[i];
      bAigEdge_t baig = visitedNodes->nodes[j];

      if (bAig_isVarNode(bmgr,baig) && varCnt<maxPiNum) {
        nodeInfoArray[j].isInput = nodeInfoArray[j].isSmooth;
        nodeInfoArray[j].isSmoothInput = nodeInfoArray[j].isSmooth;
	if (nodeInfoArray[j].isInput) {
  	  varCnt++;
	}
      }
      else if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
	/* visit fanin edges */
        ir = nodeInfoArray[j].fiIds[0];
        il = nodeInfoArray[j].fiIds[1];
        if (!nodeInfoArray[ir].bfVisited) {
	  Pdtutil_Assert(k<nNodes,"wrong bfv index");
	  Pdtutil_Assert(ir>=0,"wrong ir index");
    	  bfvAuxArray[k++] = ir;
          nodeInfoArray[ir].bfVisited = 1;
        }
        if (!nodeInfoArray[il].bfVisited) {
	  Pdtutil_Assert(k<nNodes,"wrong bfv index");
	  Pdtutil_Assert(il>=0,"wrong il index");
    	  bfvAuxArray[k++] = il;
          nodeInfoArray[il].bfVisited = 1;
        }
      }

      for (l=0; l<nodeInfoArray[j].foCnt; l++) {
	/* visit fanout edges */
        int foNodeId = nodeInfoArray[j].foIds[l];
        if (!nodeInfoArray[foNodeId].bfVisited) {
	  Pdtutil_Assert(k<nNodes,"wrong bfv index");
	  Pdtutil_Assert(foNodeId>=0,"wrong fo index");
    	  bfvAuxArray[k++] = foNodeId;
          nodeInfoArray[foNodeId].bfVisited = 1;
	}
      }

    }

    /* BF visit from selected PIs. Choose flow nodes < cutMaxSize */
    for (i=k=0; i<nNodes; i++) {
      nodeInfoArray[i].bfVisited = 0;
      if (nodeInfoArray[i].isInput) {
        bfvAuxArray[k++] = i;
      }
    }
    Pdtutil_Assert(k>0,"missing inputs for bf visit");

    for (i=0; i<k && i<nNodes; i++) {
      int ir, il, l;
      int j = bfvAuxArray[i];
      bAigEdge_t baig = visitedNodes->nodes[j];

      if (bAig_isVarNode(bmgr,baig) && flowCnt<cutMaxSize) {
	if (nodeInfoArray[j].isInput) {
	  flowCnt++;
          nodeInfoArray[j].flowVisited = 1;
	}
      }
      else if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
	/* visit fanin edges */
        ir = nodeInfoArray[j].fiIds[0];
        il = nodeInfoArray[j].fiIds[1];
        Pdtutil_Assert(ir>=0 && il>=0,"invalid ir-il");
        if (flowCnt++ <= cutMaxSize) {
          nodeInfoArray[j].flowVisited =
            nodeInfoArray[ir].flowVisited || nodeInfoArray[il].flowVisited;
        }
	else {
          if (nodeInfoArray[ir].flowVisited ||
              nodeInfoArray[il].flowVisited) {
            nodeInfoArray[j].flowVisited = -1;
	  }
          nodeInfoArray[j].isTarget = nodeInfoArray[j].isTarget ||
            (nodeInfoArray[ir].flowVisited==1) ||
            (nodeInfoArray[il].flowVisited==1);
        }
      }

      for (l=0; l<nodeInfoArray[j].foCnt; l++) {
	/* visit fanout edges */
        int foNodeId = nodeInfoArray[j].foIds[l];
        if (!nodeInfoArray[foNodeId].bfVisited) {
	  Pdtutil_Assert(k<nNodes,"wrong bfv index");
	  Pdtutil_Assert(foNodeId>=0,"wrong fo index");
    	  bfvAuxArray[k++] = foNodeId;
          nodeInfoArray[foNodeId].bfVisited = 1;
	}
      }

    }

    /* propagate input frontier one level forward by visiting nodes backward
       and setting fanout nodes of inputs */
    for (i=visitedNodes->num-1; i>=0; i--) {
      nodeInfoArray[i].bfVisited = 0;
      //      nodeInfoArray[i].flowVisited = 0;
      if (startFromPiFanout && nodeInfoArray[i].isInput
          && !nodeInfoArray[i].isTarget) {
	int l;
        for (l=0; l<nodeInfoArray[i].foCnt; l++) {
	  /* visit fanout edges */
          int foNodeId = nodeInfoArray[i].foIds[l];
          nodeInfoArray[foNodeId].isInput = 1;
          nodeInfoArray[foNodeId].refInput = i;
        }
        nodeInfoArray[i].isInput = 0;
        nodeInfoArray[i].refInput = i;
      }
      else if (nodeInfoArray[i].isInput && !nodeInfoArray[i].isTarget) {
        nodeInfoArray[i].refInput = i;
      }
    }


    /* MAX FLOW */

    for (i=pathCnt=varCnt=0; i<nNodes; i++) {
      int ir, il, pathFound, ii;
      int terminalId = visitedNodes->num;
      //      int j = bfvAuxArray[i];
      int j = i;

      if (nodeInfoArray[j].isInput && nodeInfoArray[j].isTarget) {
        nodeInfoArray[j].pathNext = terminalId;
	pathCnt++;
      }
      else if (nodeInfoArray[j].isInput && !nodeInfoArray[j].isTarget) {
	varCnt++;
        for (pathFound=1; pathFound; ) {
          for (ii=0; ii<visitedNodes->num; ii++) {
            nodeInfoArray[ii].visited = 0;
	  }
          nodeInfoArray[j].flowVisited = 1;
	  pathFound = findFwdAugmPath(j,j,visitedNodes,nodeInfoArray,1);
          if (pathFound && doPrint) {
            int pathId = nodeInfoArray[j].pathNext;
            fprintf(dMgrO(ddm),"PATH %d found\n",pathCnt++);
            fprintf(dMgrO(ddm),"%d",j);
	    while (pathId != terminalId) {
              fprintf(dMgrO(ddm),"->%d",pathId);
	      pathId = nodeInfoArray[pathId].pathNext;
	    }
            fprintf(dMgrO(ddm),"\n");
	  }
	}
      }
    }
    if (doPrint) {
      fprintf(dMgrO(ddm),"TOTAL %d paths found (%d vars)\n", pathCnt, varCnt);
    }
    /* MIN CUT */

    for (i=0; i<visitedNodes->num; i++) {
      nodeInfoArray[i].visited = 0;
    }
    for (i=0; i<nNodes; i++) {
      int pathFound;
      //      int j = bfvAuxArray[i];
      int j = i;
      if (nodeInfoArray[j].isInput && nodeInfoArray[j].isTarget) {
        nodeInfoArray[j].visited = 1;
      }
      else if (nodeInfoArray[j].isInput && !nodeInfoArray[j].isTarget) {
	pathFound = findFwdAugmPath(j,j,visitedNodes,nodeInfoArray,1);
	Pdtutil_Assert(!pathFound,"Wrong max flow");
      }
      else if (useFreePis && (nodeInfoArray[j].fiIds[0]==-1)) {
        Pdtutil_Assert(nodeInfoArray[j].fiIds[1]==-1,"error on free pi");
	pathFound = findFwdAugmPath(j,j,visitedNodes,nodeInfoArray,1);
	Pdtutil_Assert(!pathFound,"Wrong max flow");
      }
    }
    for (i=minCutCnt=0; i<visitedNodes->num; i++) {
      int prev = nodeInfoArray[i].pathPrev;
      int next = nodeInfoArray[i].pathNext;
      if (!nodeInfoArray[i].visited || nodeInfoArray[i].pathNext<0) {
	continue;
      }
      if (nodeInfoArray[i].isTarget && !nodeInfoArray[i].isMinCut) {
        nodeInfoArray[i].isMinCut = 1;
	minCutCnt++;
      }
      else if (next>=0 && !nodeInfoArray[next].visited
		  && !nodeInfoArray[i].isMinCut) {
        nodeInfoArray[i].isMinCut = 1;
	minCutCnt++;
      }
    }

    /* consider not covered paths push multiple cuts to deeper cut */
    for (i=0; i<nNodes; i++) {
      //      int j = bfvAuxArray[i];
      int j = i;
      int terminalId = visitedNodes->num;
      if (nodeInfoArray[j].isInput && nodeInfoArray[j].isTarget) {
	Pdtutil_Assert(nodeInfoArray[j].isMinCut,"missing min cut");
      }
      if (nodeInfoArray[j].isInput && !nodeInfoArray[j].isTarget) {
        int pathId = nodeInfoArray[j].pathNext;
        int cutCnt=nodeInfoArray[j].isMinCut;
	if (pathId < 0) continue;
	while (pathId != terminalId) {
	  if (nodeInfoArray[pathId].isMinCut) {
	    cutCnt++;
            nodeInfoArray[pathId].refInput = j;
	  }
	  pathId = nodeInfoArray[pathId].pathNext;
	}
	if (cutCnt==0) {
	  /* uncovered path */
	  nodeInfoArray[j].isMinCut = 1;
	  minCutCnt++;
	}
	else if (0 && cutCnt>1) {
	  /* push to last cut */
          pathId = nodeInfoArray[j].pathNext;
	  while (cutCnt>1) {
	    if (nodeInfoArray[pathId].isMinCut) {
	      nodeInfoArray[pathId].isMinCut = 0;
	      nodeInfoArray[pathId].refInput = -1;
	      cutCnt--;
	      minCutCnt--;
	    }
	    pathId = nodeInfoArray[pathId].pathNext;
	  }
	}
	else {
	}
      }
    }

    Pdtutil_Assert(minCutCnt>=pathCnt,"mincut does not match maxflow");

    /* Check MIN CUT */

    for (i=0; i<visitedNodes->num; i++) {
      nodeInfoArray[i].visited = 0;
      nodeInfoArray[i].pathNext = -1;
      nodeInfoArray[i].pathPrev = -1;
      if (nodeInfoArray[i].isMinCut) {
        if (doPrint) {
          fprintf(dMgrO(ddm),"MinCUT: %d\n", i);
	}
      }
    }
    for (i=0; i<nNodes; i++) {
      int pathFound;
      //      int j = bfvAuxArray[i];
      int j = i;

      if (nodeInfoArray[j].isInput && !nodeInfoArray[j].isTarget) {
	pathFound = findFwdAugmPath(j,j,visitedNodes,nodeInfoArray,1);
        if (pathFound) {
          int pathId = nodeInfoArray[j].pathNext;
          int terminalId = visitedNodes->num;
          fprintf(dMgrO(ddm),"WRONG PATH %d found\n",pathCnt++);
          fprintf(dMgrO(ddm),"%d",j);
	  while (pathId != terminalId) {
            fprintf(dMgrO(ddm),"->%d",pathId);
	    pathId = nodeInfoArray[pathId].pathNext;
	  }
          fprintf(dMgrO(ddm),"\n");
	}
	Pdtutil_Assert(!pathFound,"Wrong min cut");
      }
    }

    for (i=cutSize=0; i<visitedNodes->num; i++) {
      cutSize += nodeInfoArray[i].visited;
    }
    if (doPrint) {
      fprintf(dMgrO(ddm),"TOTAL min cut num: %d - size: %d/%d\n", minCutCnt,
	   cutSize, nNodes);
    }
  }

  /* mark nocut region */

  for (i=nNodes-1; i>=0; i--) {
    int ir, il;

    nodeInfoArray[i].foCnt = 0;

    if (0 && nodeInfoArray[i].flowVisited && !nodeInfoArray[i].isMinCut) {
      nodeInfoArray[i].noCutRegion = 0;
    }
    if (nodeInfoArray[i].flowVisited==0) {
      nodeInfoArray[i].noCutRegion = 1;
    }

    if (nodeInfoArray[i].isTarget) {
      nodeInfoArray[i].noCutRegion = 1;
    }

    if (!nodeInfoArray[i].noCutRegion || nodeInfoArray[i].isMinCut) {
      continue;
    }

    ir = nodeInfoArray[i].fiIds[0];
    il = nodeInfoArray[i].fiIds[1];
    if (ir>=0 && il>=0) {
      nodeInfoArray[ir].noCutRegion = 1;
      nodeInfoArray[il].noCutRegion = 1;
    }
  }

  cutRegionSize = 0;
  smoothCnt=0;
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
    Pdtutil_Free(nodeInfoArray[i].foIds);
    Pdtutil_Free(nodeInfoArray[i].isPathNext);
    if (!nodeInfoArray[i].noCutRegion) {
      cutRegionSize++;
    }
    if (nodeInfoArray[i].isSmoothInput && !nodeInfoArray[i].isMinCut) {
      smoothCnt++;
    }
  }

  if (doPrint) {
    fprintf(dMgrO(ddm),"min cut region size: %d/%d\n", cutRegionSize, nNodes);
  }

  if (doFullFlow) {
    for (i=0; i<visitedNodes->num; i++) {

      int ir = nodeInfoArray[i].fiIds[0];
      int il = nodeInfoArray[i].fiIds[1];
      if (ir>=0 && il>=0) {
        nodeInfoArray[i].flowVisited =
          nodeInfoArray[ir].flowVisited || nodeInfoArray[il].flowVisited;
      }

      nodeInfoArray[i].noCutRegion = !nodeInfoArray[i].flowVisited;
      nodeInfoArray[i].isMinCut = 0;
      nodeInfoArray[i].isTarget = 0;
      nodeInfoArray[i].refInput = -1;
    }
  }

  /* varCnt: # num of flow start inputs
     smoothCnt: # start inputs - (inputs with cut)
     minCutCnt
   */

  if (minCutCnt < varCnt /* && minCutCnt < smoothCnt */) {
    newF = evalMinCut(f,care,
      visitedNodes,nodeInfoArray,doFullFlow,roots,nRoots);

    //  Pdtutil_Assert(Ddi_BddEqual(newF,f),"wrong min cut OPT");
    if (newF != NULL && (Ddi_BddSize(newF) < 1.1*Ddi_BddSize(f))) {
      fprintf(dMgrO(ddm),"MIN CUT OPT: %d -> %d\n", Ddi_BddSize(f), Ddi_BddSize(newF));
      DdiGenericDataCopy((Ddi_Generic_t *)f,(Ddi_Generic_t *)newF);
      retF = f;
    }
    Ddi_Free(newF);
  }


  Pdtutil_Free(bfvAuxArray);
  Pdtutil_Free(nodeInfoArray);

  bAigArrayFree(visitedNodes);

  //  doingMinCut = 0;

  if (!fIsPartConj) Ddi_BddSetAig(f);
  Pdtutil_Free(roots);

  return (retF);
}


/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
FindMinCutArray
(
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *care,
  Ddi_Vararray_t *initVars,
  Ddi_Bddarray_t *substF,
  Ddi_Vararray_t *substV,
  int observeLevels,
  int maxPiNum,
  int startFromPiFanout,
  int doFullFlow,
  int disablePiFlow,
  int fwdCut,
  int cutShortEdges,
  float cutRatio
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  bAigEdge_t nodeIndex;
  bAigEdge_t varIndex;
  int nNodes, pathCnt, varCnt, varPoCnt, minCutCnt, cutSize, smoothCnt;
  bAig_array_t *visitedNodes;
  mincut_info *nodeInfoArray;
  int i, k, startId, visitId, targetId, nRoots, *roots;
  int *bfvAuxArray;
  Ddi_Bddarray_t *newFA;
  int cutRegionSize, cutMaxSize, flowCnt;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int doPrint = 0||(verbosity >= Pdtutil_VerbLevelDevMax_c);
  Ddi_Bdd_t *retF=NULL;
  int useFreePis=0;
  int nObserve=0;
  int pathLenAvg, pathLenMin, pathLenMax;
  static int nCallsMinCut=0;
  int activeGateNum=0, maxInLevel=0, maxPathLen=0, minPathLen=-1,
    avgPathLen=0, shortEdgesCnt=0, shortEdgesCutCnt=0;
  //  int pushPis = 5;
  int pushPis = -1;
  int inLevelMin;
  int doMinCut = !cutShortEdges;
  int maxLevelId=-1;

  //  doingMinCut = 1;

  nCallsMinCut++;

  nRoots = Ddi_BddarrayNum(fA);
  roots = Pdtutil_Alloc(int,nRoots);

  visitedNodes = bAigArrayAlloc();

  for (i=0; i<nRoots; i++) {
    int prevSize = visitedNodes->num;
    Ddi_Bdd_t *f_i = Ddi_BddarrayRead(fA,i);
    nodeIndex = Ddi_BddToBaig(f_i);
    postOrderAigVisitIntern(bmgr,nodeIndex,visitedNodes,-1);
    if (visitedNodes->num > prevSize) {
      roots[i] = visitedNodes->num-1;
    }
    else {
      int j;
      for (j=visitedNodes->num-1; j>=0; j--) {
        if (bAig_NonInvertedEdge(visitedNodes->nodes[j]) ==
            bAig_NonInvertedEdge(nodeIndex)) {
          roots[i] = j;
	  break;
	}
      }
    }
  }

  if (0 && care != NULL) {
    nodeIndex = Ddi_BddToBaig(care);
    postOrderAigVisitIntern(bmgr,nodeIndex,visitedNodes,-1);
  }

  aigArrayClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  nNodes = visitedNodes->num;
  cutMaxSize = nNodes;
  if (cutRatio >= 0) {
    cutMaxSize = (int) (cutRatio * cutMaxSize);
  }

  nodeInfoArray = Pdtutil_Alloc(mincut_info,nNodes);
  bfvAuxArray = Pdtutil_Alloc(int,nNodes);

  for (i=0; i<nNodes; i++) {
    nodeInfoArray[i].foCnt = -1;
    nodeInfoArray[i].foIds=NULL;
    nodeInfoArray[i].isPathNext=NULL;
    nodeInfoArray[i].fiIds[0] = nodeInfoArray[i].fiIds[1] = -1;
    nodeInfoArray[i].isFiPrev[0] = nodeInfoArray[i].isFiPrev[1] = 0;
    nodeInfoArray[i].visited = 0;
    nodeInfoArray[i].flowVisited = 0;
    nodeInfoArray[i].pathPrev = -1;
    nodeInfoArray[i].pathNext = -1;
    nodeInfoArray[i].bfVisited = 0;
    nodeInfoArray[i].inLevel = -1;
    nodeInfoArray[i].inLevelMin = -1;
    nodeInfoArray[i].outLevel = -1;
    nodeInfoArray[i].outLevelMax = -1;
    nodeInfoArray[i].refInput = -1;
    nodeInfoArray[i].cutIndex = -1;
    nodeInfoArray[i].isTarget = 0;
    nodeInfoArray[i].isInput = 0;
    nodeInfoArray[i].lockedInput = 0;
    nodeInfoArray[i].isSmoothInput = 0;
    nodeInfoArray[i].isSmooth = 0;
    nodeInfoArray[i].isMinCut = 0;
    nodeInfoArray[i].noFlowRegion = 0;
    nodeInfoArray[i].noCutRegion = 0;
  }

  /* initialize:
    - node<->id correspondence (using _AuxInt field
    - fanout count
    - fanin index info (fiIds field)
  */

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il, lr, ll;
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
  }

  if (initVars != NULL) {

    /* set input level */

    for (i=0; i<Ddi_VararrayNum(initVars); i++) {
      Ddi_Var_t *initVar = Ddi_VararrayRead(initVars,i);
      varIndex = Ddi_VarToBaig(initVar);
      Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
      startId = bAig_AuxInt(bmgr,varIndex);
      if (startId<0) continue; /* var is not in support: skip */
      nodeInfoArray[startId].inLevel = 1;
      nodeInfoArray[startId].inLevelMin = 1;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il, lr, ll, lrm, llm, lm;
    bAigEdge_t baig = visitedNodes->nodes[i];
    lm = nodeInfoArray[i].inLevelMin;
    nodeInfoArray[i].foCnt = 0;
    if (!bAig_NodeIsConstant(baig) && bAig_isVarNode(bmgr,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      nodeInfoArray[i].isSmooth = 0;
      nodeInfoArray[i].isSmoothInput = useFreePis;
      if (nodeInfoArray[i].inLevel < 0) {
        nodeInfoArray[i].inLevel = 0;
        nodeInfoArray[i].inLevelMin = 0;
      }
    }
    else if (!bAig_NodeIsConstant(baig)) {
      ir = rightChildAuxInt(bmgr,baig);
      il = leftChildAuxInt(bmgr,baig);
      lr = nodeInfoArray[ir].inLevel;
      ll = nodeInfoArray[il].inLevel;
      lrm = nodeInfoArray[ir].inLevelMin;
      llm = nodeInfoArray[il].inLevelMin;
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      Pdtutil_Assert(nodeInfoArray[ir].foCnt>=0,"fo cnt not initialized");
      Pdtutil_Assert(nodeInfoArray[il].foCnt>=0,"fo cnt not initialized");
      nodeInfoArray[ir].foCnt++;
      nodeInfoArray[il].foCnt++;
      nodeInfoArray[i].fiIds[0]=ir;
      nodeInfoArray[i].fiIds[1]=il;
      if (lr==0 && ll==0) {
        nodeInfoArray[i].inLevel = 0;
        nodeInfoArray[i].inLevelMin = 0;
      }
      else {
        nodeInfoArray[i].inLevel = (lr > ll) ? lr+1 : ll+1;
        if (lrm>0 && ((lrm+1)<lm || lm<0)) {
          lm = nodeInfoArray[i].inLevelMin = lrm+1;
        }
        if (llm>0 && ((llm+1)<lm || lm<0)) {
          nodeInfoArray[i].inLevelMin = llm+1;
        }
      }
      Pdtutil_Assert(nodeInfoArray[i].inLevelMin<=nodeInfoArray[i].inLevel,
                     "levelmax < level");
      if (nodeInfoArray[i].inLevel > maxInLevel) {
        maxInLevel = nodeInfoArray[i].inLevel;
      }
    }
  }

  for (i=0; i<nRoots; i++) {
    targetId = roots[i];
    nodeInfoArray[targetId].isTarget = 1;
    nodeInfoArray[targetId].outLevel = 0;
    nodeInfoArray[targetId].outLevelMax = 0;
  }

  /* alloc fanout arrays */
  for (i=0; i<visitedNodes->num; i++) {
    nodeInfoArray[i].foIds = Pdtutil_Alloc(int,nodeInfoArray[i].foCnt);
    nodeInfoArray[i].isPathNext = Pdtutil_Alloc(char,nodeInfoArray[i].foCnt);
  }

  /* setup fanout info */
  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    bAigEdge_t baig = visitedNodes->nodes[i];

    nodeInfoArray[i].foCnt = 0;

    ir = nodeInfoArray[i].fiIds[0];
    il = nodeInfoArray[i].fiIds[1];
    if (ir>=0 && il>=0) {
      int lr = nodeInfoArray[ir].inLevel;
      int ll = nodeInfoArray[il].inLevel;

      Pdtutil_Assert(nodeInfoArray[ir].foCnt>=0,"fo cnt not initialized");
      Pdtutil_Assert(nodeInfoArray[il].foCnt>=0,"fo cnt not initialized");
      nodeInfoArray[ir].foIds[nodeInfoArray[ir].foCnt]=i;
      nodeInfoArray[ir].isPathNext[nodeInfoArray[ir].foCnt]=0;
      nodeInfoArray[il].foIds[nodeInfoArray[il].foCnt]=i;
      nodeInfoArray[il].isPathNext[nodeInfoArray[il].foCnt]=0;
      nodeInfoArray[ir].foCnt++;
      nodeInfoArray[il].foCnt++;

      if (cutShortEdges==1 && nodeInfoArray[i].inLevel > maxInLevel/10) {
        if (lr>0 && (lr*10 < nodeInfoArray[i].inLevel)) {
          if (!nodeInfoArray[ir].isShortEdgeCut) {
            nodeInfoArray[ir].isShortEdgeCut = 1;
            shortEdgesCutCnt++;
          }
          nodeInfoArray[i].isShortEdge[0] = 1;
          shortEdgesCnt++;
        }
        if (ll>0 && (ll*10 < nodeInfoArray[i].inLevel)) {
          if (!nodeInfoArray[il].isShortEdgeCut) {
            nodeInfoArray[il].isShortEdgeCut = 1;
            shortEdgesCutCnt++;
          }
          nodeInfoArray[i].isShortEdge[1] = 1;
          shortEdgesCnt++;
        }
      }

    }
  }

  for (i=visitedNodes->num-1; i>=0; i--) {
    int ir, il;
    int levelMax = nodeInfoArray[i].outLevelMax;
    int level = nodeInfoArray[i].inLevel;

    if (maxLevelId<0 || (level>maxLevelId)) {
      maxLevelId = i;
    }
    ir = nodeInfoArray[i].fiIds[0];
    il = nodeInfoArray[i].fiIds[1];
    if (ir>=0 && il>=0) {
      if (levelMax+1 > nodeInfoArray[ir].outLevelMax) {
        nodeInfoArray[ir].outLevelMax = levelMax+1;
      }
      if (levelMax+1 > nodeInfoArray[il].outLevelMax) {
        nodeInfoArray[il].outLevelMax = levelMax+1;
      }
    }
  }

  Pdtutil_Assert(maxLevelId>=0 && maxLevelId<visitedNodes->num,
                 "wrong max level id");

  for (k=0; k<nRoots; k++) {
    targetId = roots[k];
    if (1 && (nodeInfoArray[targetId].inLevel <
              nodeInfoArray[maxLevelId].inLevel/10)) continue;

    for (i=targetId; i>=0; i--) {
      int ir, il;
      int levelMin = nodeInfoArray[i].inLevelMin;
      int level = nodeInfoArray[i].inLevel;

      ir = nodeInfoArray[i].fiIds[0];
      il = nodeInfoArray[i].fiIds[1];

      if (ir>=0 && il>=0) {
        int rlM, rl, llM, ll;
        int rd, rdM, ld, ldM;
        rlM = nodeInfoArray[ir].inLevelMin;
        llM = nodeInfoArray[il].inLevelMin;
        rl = nodeInfoArray[ir].inLevel;
        ll = nodeInfoArray[il].inLevel;
        rd = level-rl;
        ld = level-ll;
        rdM = levelMin-rlM;
        ldM = levelMin-llM;
        if (rdM==1 && ldM==1) {
          if (rd>ld) {
            /* force cut left */
            ldM++;
          }
          else {
            /* force cut right */
            rdM++;
          }
        }
        if (rdM==1) {
          if (!nodeInfoArray[il].isShortEdgeCut) {
            nodeInfoArray[il].isShortEdgeCut = 1;
            shortEdgesCutCnt++;
          }
          else break;
          nodeInfoArray[i].isShortEdge[1] = 1;
          shortEdgesCnt++;
          i = ir+1;
        }
        else if (ldM==1) {
          if (!nodeInfoArray[ir].isShortEdgeCut) {
            nodeInfoArray[ir].isShortEdgeCut = 1;
            shortEdgesCutCnt++;
          }
          else break;
          nodeInfoArray[i].isShortEdge[0] = 1;
          shortEdgesCnt++;
          i = il+1;
        }
      }
      else {
        break;
      }
    }
  }

  /* set optput level by bf backward visit: bfvAuxArray is used
     as FIFO data structure and output buffer */

  k=0;
  for (i=0; i<nRoots; i++) {
    int j;
    for (j=0; j<i; j++) {
      if (roots[j]==roots[i]) break;
    }
    if (j==i) {
      bfvAuxArray[k++] = roots[i];
      //    fprintf(dMgrO(ddm),"-> %d\n", roots[i]);
      nodeInfoArray[roots[i]].bfVisited = 1;
    }
  }

  inLevelMin = nodeInfoArray[visitedNodes->num-1].inLevel;
  if (observeLevels>0) {
    inLevelMin -= 2*observeLevels;
  }
  for (i=0; i<k && i<nNodes; i++) {
    int ir, il;
    int j = bfvAuxArray[i];
    int inLevel = nodeInfoArray[j].inLevel;
    int level = nodeInfoArray[j].outLevel;
    int levelMax = nodeInfoArray[j].outLevelMax;
    bAigEdge_t baig = visitedNodes->nodes[j];

    if (inLevel>0) {
      int pathLen = inLevel+level;
      activeGateNum++;
      if (minPathLen<0 || minPathLen>pathLen) {
        minPathLen = pathLen;
      }
      if (maxPathLen<pathLen) {
        maxPathLen = pathLen;
      }
      avgPathLen += pathLen;
    }

    //    if (observeLevels < 0 && level < 1 || levelMax < observeLevels) {
    if (observeLevels < 0 && level < 1 || (level <= observeLevels)) {
      if (inLevel >= inLevelMin) {
        nodeInfoArray[j].isTarget = 1;
        nObserve++;
      }
    }

    ir = nodeInfoArray[j].fiIds[0];
    il = nodeInfoArray[j].fiIds[1];
    if (ir>=0 && il>=0) {
      if (!nodeInfoArray[ir].bfVisited) {
	bfvAuxArray[k++] = ir;
	//    fprintf(dMgrO(ddm),"-> %d\n", ir);
        nodeInfoArray[ir].bfVisited = 1;
        nodeInfoArray[ir].outLevel = level+1;
      }
      if (!nodeInfoArray[il].bfVisited) {
	bfvAuxArray[k++] = il;
	//    fprintf(dMgrO(ddm),"-> %d\n", il);

        nodeInfoArray[il].bfVisited = 1;
        nodeInfoArray[il].outLevel = level+1;
      }
    }
  }
  for (i=0; i<visitedNodes->num; i++) {
    nodeInfoArray[i].bfVisited = 0;
  }

  if (initVars != NULL) {

    /* set input level by bf forward visit from startId node.
       Fanout and fanin edges are considered, so that nearest PIs are
       considered */

    for (i=k=0; i<Ddi_VararrayNum(initVars); i++) {
      Ddi_Var_t *initVar = Ddi_VararrayRead(initVars,i);
      varIndex = Ddi_VarToBaig(initVar);
      Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
      startId = bAig_AuxInt(bmgr,varIndex);
      if (startId<0) continue; /* var is not in support: skip */
      bfvAuxArray[k++] = startId;
      nodeInfoArray[startId].bfVisited = 1;
      nodeInfoArray[startId].isInput = 1;
      nodeInfoArray[startId].isSmooth = 1;
      nodeInfoArray[startId].isSmoothInput = 0;
      // fprintf(dMgrO(ddm),"input var: %s - id: %d\n",
      // Ddi_VarName(initVar), startId);
    }
    flowCnt = 0;

    for (i=varCnt=0; i<k && i<nNodes; i++) {
      int ir, il, l;
      int j = bfvAuxArray[i];
      bAigEdge_t baig = visitedNodes->nodes[j];

      if (bAig_isVarNode(bmgr,baig) && (maxPiNum <=0 || varCnt<maxPiNum)) {
        nodeInfoArray[j].isInput = nodeInfoArray[j].isSmooth;
        nodeInfoArray[j].isSmoothInput = nodeInfoArray[j].isSmooth;
	if (nodeInfoArray[j].isInput) {
  	  varCnt++;
	}
	else {
	  nodeInfoArray[j].noFlowRegion = (char) disablePiFlow;
	}
      }
      else if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
	/* visit fanin edges */
        ir = nodeInfoArray[j].fiIds[0];
        il = nodeInfoArray[j].fiIds[1];
        if (!nodeInfoArray[ir].bfVisited) {
	  Pdtutil_Assert(k<nNodes,"wrong bfv index");
	  Pdtutil_Assert(ir>=0,"wrong ir index");
    	  bfvAuxArray[k++] = ir;
          nodeInfoArray[ir].bfVisited = 1;
        }
        if (!nodeInfoArray[il].bfVisited) {
	  Pdtutil_Assert(k<nNodes,"wrong bfv index");
	  Pdtutil_Assert(il>=0,"wrong il index");
    	  bfvAuxArray[k++] = il;
          nodeInfoArray[il].bfVisited = 1;
        }
	nodeInfoArray[j].noFlowRegion = nodeInfoArray[ir].noFlowRegion ||
	                                nodeInfoArray[il].noFlowRegion;
      }

      for (l=0; l<nodeInfoArray[j].foCnt; l++) {
	/* visit fanout edges */
        int foNodeId = nodeInfoArray[j].foIds[l];
        if (!nodeInfoArray[foNodeId].bfVisited) {
	  Pdtutil_Assert(k<nNodes,"wrong bfv index");
	  Pdtutil_Assert(foNodeId>=0,"wrong fo index");
    	  bfvAuxArray[k++] = foNodeId;
          nodeInfoArray[foNodeId].bfVisited = 1;
	}
      }

    }

    if (useFreePis) {
      /* BF visit from fre PIs. Mark nodes as target */
      for (i=k=0; i<nNodes; i++) {
	nodeInfoArray[i].bfVisited = 0;
	if (nodeInfoArray[i].isSmoothInput) {
	  bfvAuxArray[k++] = i;
	  nodeInfoArray[i].bfVisited = 1;
	}
      }
      Pdtutil_Assert(k>0,"missing inputs for bf visit");

      for (i=0; i<k && i<nNodes; i++) {
	int ir, il, l;
	int j = bfvAuxArray[i];
	bAigEdge_t baig = visitedNodes->nodes[j];

	if (!bAig_isVarNode(bmgr,baig)) {
	  nodeInfoArray[i].isTarget = 1;
	}
	for (l=0; l<nodeInfoArray[j].foCnt; l++) {
	  /* visit fanout edges */
	  int foNodeId = nodeInfoArray[j].foIds[l];
	  if (!nodeInfoArray[foNodeId].bfVisited) {
	    Pdtutil_Assert(k<nNodes,"wrong bfv index");
	    Pdtutil_Assert(foNodeId>=0,"wrong fo index");
	    bfvAuxArray[k++] = foNodeId;
	    nodeInfoArray[foNodeId].bfVisited = 1;
	  }
	}
      }

      for (i=visitedNodes->num-1; i>=0; i--) {
	nodeInfoArray[i].bfVisited = 0;
      }
    }

    /* BF visit from selected PIs. Choose flow nodes < cutMaxSize */
    for (i=k=0; i<nNodes; i++) {
      nodeInfoArray[i].bfVisited = 0;
      if (nodeInfoArray[i].isInput) {
        bfvAuxArray[k++] = i;
      }
    }
    Pdtutil_Assert(k>0,"missing inputs for bf visit");

    for (i=0; i<k && i<nNodes; i++) {
      int ir, il, l;
      int j = bfvAuxArray[i];
      bAigEdge_t baig = visitedNodes->nodes[j];

      if (bAig_isVarNode(bmgr,baig) && flowCnt<cutMaxSize) {
	if (nodeInfoArray[j].isInput) {
	  flowCnt++;
          nodeInfoArray[j].flowVisited = 1;
	}
      }
      else if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
	/* visit fanin edges */
        ir = nodeInfoArray[j].fiIds[0];
        il = nodeInfoArray[j].fiIds[1];
        Pdtutil_Assert(ir>=0 && il>=0,"invalid ir-il");
        if (flowCnt++ <= cutMaxSize) {
          nodeInfoArray[j].flowVisited =
            nodeInfoArray[ir].flowVisited || nodeInfoArray[il].flowVisited;
        }
	else {
          if (nodeInfoArray[ir].flowVisited ||
              nodeInfoArray[il].flowVisited) {
            nodeInfoArray[j].flowVisited = -1;
	  }
          nodeInfoArray[j].isTarget = nodeInfoArray[j].isTarget ||
            (nodeInfoArray[ir].flowVisited==1) ||
            (nodeInfoArray[il].flowVisited==1);
        }
      }

      for (l=0; l<nodeInfoArray[j].foCnt; l++) {
	/* visit fanout edges */
        int foNodeId = nodeInfoArray[j].foIds[l];
        if (!nodeInfoArray[foNodeId].bfVisited) {
	  Pdtutil_Assert(k<nNodes,"wrong bfv index");
	  Pdtutil_Assert(foNodeId>=0,"wrong fo index");
    	  bfvAuxArray[k++] = foNodeId;
          nodeInfoArray[foNodeId].bfVisited = 1;
	}
      }

    }

    /* propagate input frontier one level forward by visiting nodes backward
       and setting fanout nodes of inputs */
    for (i=visitedNodes->num-1; i>=0; i--) {
      nodeInfoArray[i].bfVisited = 0;
      //      nodeInfoArray[i].flowVisited = 0;
      if (startFromPiFanout && nodeInfoArray[i].isInput
          && !nodeInfoArray[i].isTarget) {
	int l;
        for (l=0; l<nodeInfoArray[i].foCnt; l++) {
	  /* visit fanout edges */
          int foNodeId = nodeInfoArray[i].foIds[l];
          nodeInfoArray[foNodeId].isInput = 1;
          nodeInfoArray[foNodeId].refInput = i;
        }
        nodeInfoArray[i].isInput = 0;
        nodeInfoArray[i].refInput = i;
      }
      else if (nodeInfoArray[i].isInput && !nodeInfoArray[i].isTarget) {
        nodeInfoArray[i].refInput = i;
      }
    }
    if (pushPis>0) {
      for (i=0; i<visitedNodes->num; i++) {
        if (!nodeInfoArray[i].isInput && !nodeInfoArray[i].isTarget) {
          if (nodeInfoArray[i].inLevel>0 &&
              nodeInfoArray[i].inLevel<pushPis) {
            int id0 = nodeInfoArray[i].fiIds[0];
            int id1 = nodeInfoArray[i].fiIds[1];
            nodeInfoArray[i].isInput = 1;
            if (nodeInfoArray[id0].refInput>=0) {
              nodeInfoArray[i].refInput = nodeInfoArray[id0].refInput;
            }
            else {
              Pdtutil_Assert(nodeInfoArray[id1].refInput>=0,
                             "missing ref in");
              nodeInfoArray[i].refInput = nodeInfoArray[id1].refInput;
            }
          }
        }
      }
    }

    fprintf(dMgrO(ddm),
            "ACTIVE GATES: %d/%d - shortEdges: %d, shortEdgeCuts: %d\n",
            activeGateNum, visitedNodes->num,
            shortEdgesCnt, shortEdgesCutCnt);

    if (doMinCut) {

      /* MAX FLOW */

      pathLenAvg=0;
      pathLenMin=-1;
      pathLenMax=-1;

      //      fprintf(dMgrO(ddm),"path len: ");

      for (i=pathCnt=varCnt=varPoCnt=0; i<nNodes; i++) {
        int ir, il, pathFound, ii;
        int terminalId = visitedNodes->num;
        //      int j = bfvAuxArray[i];
        int j = i;

        if (nodeInfoArray[j].isInput && nodeInfoArray[j].isTarget) {
          nodeInfoArray[j].pathNext = terminalId;
          pathCnt++; varPoCnt++;
        }
        else if (nodeInfoArray[j].isInput && !nodeInfoArray[j].isTarget) {
          varCnt++;
          for (pathFound=1; pathFound; ) {
            for (ii=0; ii<visitedNodes->num; ii++) {
              nodeInfoArray[ii].visited = nodeInfoArray[ii].noFlowRegion;
            }
            nodeInfoArray[j].flowVisited = 1;
            pathFound = findFwdAugmPath(j,j,visitedNodes,nodeInfoArray,1);
            if (pathFound) {
              int pathLen = 0;
              if (doPrint) {
                int pathId = nodeInfoArray[j].pathNext;
                fprintf(dMgrO(ddm),"PATH %d found\n",pathCnt);
                fprintf(dMgrO(ddm),"%d",j);
                while (pathId != terminalId) {
                  fprintf(dMgrO(ddm),"->%d",pathId);
                  pathId = nodeInfoArray[pathId].pathNext;
                }
                fprintf(dMgrO(ddm),"\n");
              }
              else {
                int pathId = nodeInfoArray[j].pathNext;
                while (pathId != terminalId) {
                  pathLen++;
                  pathId = nodeInfoArray[pathId].pathNext;
                }
              }
	      //              fprintf(dMgrO(ddm),"%d ", pathLen);
              if (pathLenMin<0 || pathLen < pathLenMin) {
                pathLenMin = pathLen;
              }
              if (pathLenMax<0 || pathLen > pathLenMax) {
                pathLenMax = pathLen;
              }
              pathLenAvg += pathLen;
              pathCnt++;
            }
          }
        }
      }

      //      fprintf(dMgrO(ddm),"\n");
      pathLenAvg /= pathCnt;
      if (activeGateNum==0) activeGateNum = 1;
      avgPathLen /= activeGateNum;
      if (1||doPrint) {
        fprintf(dMgrO(ddm),"TOTAL %d paths found (%d vars, %d PO vars)\n",
                pathCnt, varCnt, varPoCnt);
        fprintf(dMgrO(ddm),"path len - avg: %d, min: %d, max: %d\n",
                pathLenAvg, pathLenMin, pathLenMax);
        fprintf(dMgrO(ddm),"TOTAL path len - avg: %d, min: %d, max: %d\n",
                avgPathLen, minPathLen, maxPathLen);
        //        exit(1);
      }
      /* MIN CUT */

      for (i=0; i<visitedNodes->num; i++) {
        nodeInfoArray[i].visited = 0;
      }
      for (i=0; i<nNodes; i++) { // check that no more flow is allowed
        int pathFound;
        //      int j = bfvAuxArray[i];
        int j = i;
        if (nodeInfoArray[j].isInput && nodeInfoArray[j].isTarget) {
          nodeInfoArray[j].visited = 1; // set blocked flows visited
        }
        else if (nodeInfoArray[j].isInput && !nodeInfoArray[j].isTarget) {
          pathFound = findFwdAugmPath(j,j,visitedNodes,nodeInfoArray,1);
          Pdtutil_Assert(!pathFound,"Wrong max flow");
        }
      }
      for (i=minCutCnt=0; i<visitedNodes->num; i++) {
        int prev = nodeInfoArray[i].pathPrev;
        int next = nodeInfoArray[i].pathNext;
        int ii, outFlow = 0;
        for (ii=0; ii<nodeInfoArray[i].foCnt; ii++) {
          /* visit fanout edges */
          int foNodeId = nodeInfoArray[i].foIds[ii];
          if (nodeInfoArray[foNodeId].pathNext<0) {
            outFlow=1;
            break;
          }
        }
        if (!nodeInfoArray[i].visited || nodeInfoArray[i].pathNext<0) {
          if (prev>=0 && nodeInfoArray[prev].isMinCut
              && nodeInfoArray[prev].isMinCut<3
              && !nodeInfoArray[i].isMinCut) {
            // flow path node with next not reached by blocked paths
            nodeInfoArray[i].isMinCut = 2;
            if (outFlow || nodeInfoArray[i].isTarget) {
              nodeInfoArray[i].isMinCut = 4;
            }
          }
        }
        else if (nodeInfoArray[i].isTarget && !nodeInfoArray[i].isMinCut) {
          nodeInfoArray[i].isMinCut = 5;
          minCutCnt++;
        }
        else if (next>=0 && !nodeInfoArray[next].visited
                 && !nodeInfoArray[i].isMinCut) {
          // flow path node with next not reached by blocked paths
          nodeInfoArray[i].isMinCut = 1;
          if (outFlow) {
            nodeInfoArray[i].isMinCut = 5;
          }
          minCutCnt++;
        }
      }

      for (i=0; i<visitedNodes->num; i++) {
        if (fwdCut) {
          nodeInfoArray[i].isMinCut = nodeInfoArray[i].isMinCut%2;
        }
        else {
          nodeInfoArray[i].isMinCut = nodeInfoArray[i].isMinCut > 3;
        }
        if (0&&nodeInfoArray[i].isMinCut) {
          printf("cut: %d , %d-%d\n", nodeInfoArray[i].inLevel,
                 nodeInfoArray[i].outLevel, nodeInfoArray[i].outLevelMax);
        }
      }

      /* consider not covered paths push multiple cuts to deeper cut */
      for (i=0; i<nNodes; i++) {
        //      int j = bfvAuxArray[i];
        int j = i;
        int terminalId = visitedNodes->num;
        if (nodeInfoArray[j].isInput && nodeInfoArray[j].isTarget) {
          Pdtutil_Assert(nodeInfoArray[j].isMinCut,"missing min cut");
        }
        if (nodeInfoArray[j].isInput && !nodeInfoArray[j].isTarget) {
          int pathId = nodeInfoArray[j].pathNext;
          int cutCnt = nodeInfoArray[j].isMinCut;
          if (pathId < 0) continue;
          while (pathId != terminalId) {
            if (nodeInfoArray[pathId].isMinCut) {
              cutCnt++;
              nodeInfoArray[pathId].refInput = j;
            }
            pathId = nodeInfoArray[pathId].pathNext;
          }
          if (cutCnt==0) {
            /* uncovered path */
            nodeInfoArray[j].isMinCut = 1;
            minCutCnt++;
          }
          else if (0 && cutCnt>1) {
            /* push to last cut */
            pathId = nodeInfoArray[j].pathNext;
            while (cutCnt>1) {
              if (nodeInfoArray[pathId].isMinCut) {
                nodeInfoArray[pathId].isMinCut = 0;
                nodeInfoArray[pathId].refInput = -1;
                cutCnt--;
                minCutCnt--;
              }
              pathId = nodeInfoArray[pathId].pathNext;
            }
          }
          else {
          }
        }
      }

      Pdtutil_Assert(minCutCnt>=pathCnt,"mincut does not match maxflow");

      /* Check MIN CUT */

      for (i=0; i<visitedNodes->num; i++) {
        nodeInfoArray[i].visited = 0;
        nodeInfoArray[i].pathNext = -1;
        nodeInfoArray[i].pathPrev = -1;
        if (nodeInfoArray[i].isMinCut) {
          if (doPrint) {
            fprintf(dMgrO(ddm),"MinCUT: %d\n", i);
          }
        }
      }
      if (0)
        for (i=0; i<nNodes; i++) {
          int pathFound;
          //      int j = bfvAuxArray[i];
          int j = i;

          if (nodeInfoArray[j].isInput && !nodeInfoArray[j].isTarget) {
            pathFound = findFwdAugmPath(j,j,visitedNodes,nodeInfoArray,1);
            if (pathFound) {
              int pathId = nodeInfoArray[j].pathNext;
              int terminalId = visitedNodes->num;
              fprintf(dMgrO(ddm),"WRONG PATH %d found\n",pathCnt++);
              fprintf(dMgrO(ddm),"%d",j);
              while (pathId != terminalId) {
                fprintf(dMgrO(ddm),"->%d",pathId);
                pathId = nodeInfoArray[pathId].pathNext;
              }
              fprintf(dMgrO(ddm),"\n");
            }
            Pdtutil_Assert(!pathFound,"Wrong min cut");
          }
        }

      for (i=cutSize=0; i<visitedNodes->num; i++) {
        cutSize += nodeInfoArray[i].visited;
      }
      if (doPrint) {
        fprintf(dMgrO(ddm),"TOTAL min cut num: %d - size: %d/%d\n",
                minCutCnt, cutSize, nNodes);
      }
    }

  }

  /* mark nocut region */

  for (i=nNodes-1; i>=0; i--) {
    int ir, il;

    nodeInfoArray[i].foCnt = 0;

    if (0 && nodeInfoArray[i].flowVisited && !nodeInfoArray[i].isMinCut) {
      nodeInfoArray[i].noCutRegion = 0;
    }
    if (nodeInfoArray[i].flowVisited==0) {
      nodeInfoArray[i].noCutRegion = 1;
    }

    if (nodeInfoArray[i].isTarget) {
      nodeInfoArray[i].noCutRegion = 1;
    }

    if (!nodeInfoArray[i].noCutRegion || nodeInfoArray[i].isMinCut) {
      continue;
    }

    ir = nodeInfoArray[i].fiIds[0];
    il = nodeInfoArray[i].fiIds[1];
    if (ir>=0 && il>=0) {
      nodeInfoArray[ir].noCutRegion = 1;
      nodeInfoArray[il].noCutRegion = 1;
    }
  }

  cutRegionSize = 0;
  smoothCnt=0;
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
    Pdtutil_Free(nodeInfoArray[i].foIds);
    Pdtutil_Free(nodeInfoArray[i].isPathNext);
    if (!nodeInfoArray[i].noCutRegion) {
      cutRegionSize++;
    }
    if (nodeInfoArray[i].isSmoothInput && !nodeInfoArray[i].isMinCut) {
      smoothCnt++;
    }
  }

  if (doPrint) {
    fprintf(dMgrO(ddm),"min cut region size: %d/%d\n", cutRegionSize, nNodes);
  }

  if (doFullFlow) {
    for (i=0; i<visitedNodes->num; i++) {

      int ir = nodeInfoArray[i].fiIds[0];
      int il = nodeInfoArray[i].fiIds[1];
      if (ir>=0 && il>=0) {
        nodeInfoArray[i].flowVisited =
          nodeInfoArray[ir].flowVisited || nodeInfoArray[il].flowVisited;
      }

      nodeInfoArray[i].noCutRegion = !nodeInfoArray[i].flowVisited;
      //  nodeInfoArray[i].isMinCut = 0;
      //  nodeInfoArray[i].isTarget = 0;
      //  nodeInfoArray[i].refInput = -1;
    }
  }

  /* varCnt: # num of flow start inputs
     smoothCnt: # start inputs - (inputs with cut)
     minCutCnt
   */

#if 1
  newFA = NULL;
  if (1 || minCutCnt < varCnt /* && minCutCnt < smoothCnt */) {
    newFA = evalMinCutArray(fA,substF,substV,
      visitedNodes,nodeInfoArray,doFullFlow,roots,nRoots,cutShortEdges);
  }
#endif

  Pdtutil_Free(bfvAuxArray);
  Pdtutil_Free(nodeInfoArray);

  bAigArrayFree(visitedNodes);

  //  doingMinCut = 0;

  Pdtutil_Free(roots);

  return (newFA);
}

/**Function********************************************************************

  Synopsis    [Min cut with modified Bellman-Ford algorithm]
  Description [Min cut with modified Bellman-Ford algorithm]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
FindMinCutArrayBF
(
  Ddi_Bddarray_t *fA,
  Ddi_Bdd_t *care,
  Ddi_Vararray_t *initVars,
  Ddi_Vararray_t *lockedVars,
  Ddi_Bddarray_t *substF,
  Ddi_Vararray_t *substV
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  bAigEdge_t nodeIndex;
  bAigEdge_t varIndex;
  int nNodes, pathCnt, varCnt, varPoCnt, minCutCnt, cutSize=0, smoothCnt;
  bAig_array_t *visitedNodes;
  mincut_info *nodeInfoArray;
  int i, k, startId, visitId, targetId, nRoots, *roots;
  int *bfvAuxArray;
  Ddi_Bddarray_t *newFA;
  int cutRegionSize, cutMaxSize, flowCnt;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int doPrint = 1||(verbosity >= Pdtutil_VerbLevelDevMax_c);
  Ddi_Bdd_t *retF=NULL;
  int useFreePis=0;

  static int nCallsMinCut=0;

  //  doingMinCut = 1;

  nCallsMinCut++;

  nRoots = Ddi_BddarrayNum(fA);
  roots = Pdtutil_Alloc(int,nRoots);

  visitedNodes = bAigArrayAlloc();

  for (i=0; i<nRoots; i++) {
    int prevSize = visitedNodes->num;
    Ddi_Bdd_t *f_i = Ddi_BddarrayRead(fA,i);
    nodeIndex = Ddi_BddToBaig(f_i);
    postOrderAigVisitIntern(bmgr,nodeIndex,visitedNodes,-1);
    if (visitedNodes->num > prevSize) {
      roots[i] = visitedNodes->num-1;
    }
    else {
      int j;
      for (j=visitedNodes->num-1; j>=0; j--) {
        if (bAig_NonInvertedEdge(visitedNodes->nodes[j]) ==
            bAig_NonInvertedEdge(nodeIndex)) {
          roots[i] = j;
	  break;
	}
      }
    }
  }

  if (0 && care != NULL) {
    nodeIndex = Ddi_BddToBaig(care);
    postOrderAigVisitIntern(bmgr,nodeIndex,visitedNodes,-1);
  }

  aigArrayClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  nNodes = visitedNodes->num;
  cutMaxSize = nNodes;

  nodeInfoArray = Pdtutil_Alloc(mincut_info,nNodes);
  bfvAuxArray = Pdtutil_Alloc(int,nNodes);

  for (i=0; i<nNodes; i++) {
    nodeInfoArray[i].foCnt = -1;
    nodeInfoArray[i].foIds=NULL;
    nodeInfoArray[i].isPathNext=NULL;
    nodeInfoArray[i].fiIds[0] = nodeInfoArray[i].fiIds[1] = -1;
    nodeInfoArray[i].isFiPrev[0] = nodeInfoArray[i].isFiPrev[1] = 0;
    nodeInfoArray[i].visited = 0;
    nodeInfoArray[i].flowVisited = 0;
    nodeInfoArray[i].pathPrev = -1;
    nodeInfoArray[i].pathNext = -1;
    nodeInfoArray[i].bfVisited = 0;
    nodeInfoArray[i].outLevel = -1;
    nodeInfoArray[i].refInput = -1;
    nodeInfoArray[i].cutIndex = -1;
    nodeInfoArray[i].isTarget = 0;
    nodeInfoArray[i].isInput = 0;
    nodeInfoArray[i].lockedInput = 0;
    nodeInfoArray[i].isSmoothInput = 0;
    nodeInfoArray[i].isSmooth = 0;
    nodeInfoArray[i].isMinCut = 0;
    nodeInfoArray[i].noFlowRegion = 0;
    nodeInfoArray[i].noCutRegion = 0;
  }

  /* initialize:
    - node<->id correspondence (using _AuxInt field
    - fanout count
    - fanin index info (fiIds field)
  */

  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
    nodeInfoArray[i].foCnt = 0;
    if (!bAig_NodeIsConstant(baig) && bAig_isVarNode(bmgr,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      nodeInfoArray[i].isSmooth = 1;
    }
    else if (!bAig_NodeIsConstant(baig)) {
      ir = rightChildAuxInt(bmgr,baig);
      il = leftChildAuxInt(bmgr,baig);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      Pdtutil_Assert(nodeInfoArray[ir].foCnt>=0,"fo cnt not initialized");
      Pdtutil_Assert(nodeInfoArray[il].foCnt>=0,"fo cnt not initialized");
      nodeInfoArray[ir].foCnt++;
      nodeInfoArray[il].foCnt++;
      nodeInfoArray[i].fiIds[0]=ir;
      nodeInfoArray[i].fiIds[1]=il;
    }
  }

  for (i=0; i<nRoots; i++) {
    targetId = roots[i];
    nodeInfoArray[targetId].isTarget = 1;
    nodeInfoArray[targetId].outLevel = 0;
  }

  /* alloc fanout arrays */
  for (i=0; i<visitedNodes->num; i++) {
    nodeInfoArray[i].foIds = Pdtutil_Alloc(int,nodeInfoArray[i].foCnt);
    nodeInfoArray[i].isPathNext = Pdtutil_Alloc(char,nodeInfoArray[i].foCnt);
  }

  /* setup fanout info */
  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    bAigEdge_t baig = visitedNodes->nodes[i];

    nodeInfoArray[i].foCnt = 0;

    ir = nodeInfoArray[i].fiIds[0];
    il = nodeInfoArray[i].fiIds[1];
    if (ir>=0 && il>=0) {
      Pdtutil_Assert(nodeInfoArray[ir].foCnt>=0,"fo cnt not initialized");
      Pdtutil_Assert(nodeInfoArray[il].foCnt>=0,"fo cnt not initialized");
      nodeInfoArray[ir].foIds[nodeInfoArray[ir].foCnt]=i;
      nodeInfoArray[ir].isPathNext[nodeInfoArray[ir].foCnt]=0;
      nodeInfoArray[il].foIds[nodeInfoArray[il].foCnt]=i;
      nodeInfoArray[il].isPathNext[nodeInfoArray[il].foCnt]=0;
      nodeInfoArray[ir].foCnt++;
      nodeInfoArray[il].foCnt++;
    }
  }

  Pdtutil_Assert(initVars!=NULL,"NULL init vars array");

  /* set input level by bf forward visit from startId node.
       Fanout and fanin edges are considered, so that nearest PIs are
       considered */

  for (i=0; i<Ddi_VararrayNum(initVars); i++) {
    Ddi_Var_t *initVar = Ddi_VararrayRead(initVars,i);
    varIndex = Ddi_VarToBaig(initVar);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    startId = bAig_AuxInt(bmgr,varIndex);
    if (startId<0) continue; /* var is not in support: skip */
    nodeInfoArray[startId].isInput = 1;
    nodeInfoArray[startId].isSmooth = 0;
  }

  for (i=0; lockedVars!=NULL && i<Ddi_VararrayNum(lockedVars); i++) {
    Ddi_Var_t *lockedVar = Ddi_VararrayRead(lockedVars,i);
    varIndex = Ddi_VarToBaig(lockedVar);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");
    startId = bAig_AuxInt(bmgr,varIndex);
    if (startId<0) continue; /* var is not in support: skip */
    nodeInfoArray[startId].lockedInput = 1;
    nodeInfoArray[startId].isInput = 1;
    nodeInfoArray[startId].isTarget = 1;
    nodeInfoArray[startId].isSmooth = 0;
  }

  flowCnt=0;
  while (findFwdBwdAugmPathBF(visitedNodes,nodeInfoArray,bfvAuxArray,
			      0/*startFromAll*/,0/*setMinCut*/,doPrint)) {
    flowCnt++;
  }

  /* MARK MIN CUT */
  minCutCnt = findFwdBwdAugmPathBF(visitedNodes,nodeInfoArray,bfvAuxArray,
				   1/*startFromAll*/,1/*setMinCut*/,doPrint);
  //  Pdtutil_Assert(minCutCnt==flowCnt,"invalid min cut");



  Pdtutil_Assert(minCutCnt>=pathCnt,"mincut does not match maxflow");

  /* Check MIN CUT */

  for (i=0; i<visitedNodes->num; i++) {
    nodeInfoArray[i].visited = 0;
    nodeInfoArray[i].pathNext = -1;
    nodeInfoArray[i].pathPrev = -1;
    if (nodeInfoArray[i].isMinCut) {
      if (doPrint) {
	fprintf(dMgrO(ddm),"MinCUT: %d\n", i);
      }
    }
  }

  if (doPrint) {
    fprintf(dMgrO(ddm),"TOTAL min cut num: %d - size: %d/%d\n", minCutCnt,
	    cutSize, nNodes);
  }


  cutRegionSize = 0;
  smoothCnt=0;
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
    Pdtutil_Free(nodeInfoArray[i].foIds);
    Pdtutil_Free(nodeInfoArray[i].isPathNext);
    if (!nodeInfoArray[i].noCutRegion) {
      cutRegionSize++;
    }
    if (nodeInfoArray[i].isSmoothInput && !nodeInfoArray[i].isMinCut) {
      smoothCnt++;
    }
  }


#if 1
  newFA = NULL;
  if (1 || minCutCnt < varCnt /* && minCutCnt < smoothCnt */) {
    newFA = evalMinCutArray(fA,substF,substV,
       visitedNodes,nodeInfoArray,1/*doFullFlow*/,roots,nRoots,0);
  }
#endif

  Pdtutil_Free(bfvAuxArray);
  Pdtutil_Free(nodeInfoArray);

  bAigArrayFree(visitedNodes);

  //  doingMinCut = 0;

  Pdtutil_Free(roots);

  return (newFA);
}


/**Function********************************************************************

  Synopsis    [Recursive steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
findFwdAugmPath(
  int startId,
  int visitId,
  bAig_array_t *visitedNodes,
  mincut_info *nodeInfoArray,
  int enBack
)
{
  int i, prev, next, terminalId = visitedNodes->num;


  if (nodeInfoArray[startId].visited || nodeInfoArray[startId].isMinCut) {
    return 0;
  }

  nodeInfoArray[startId].visited = 1;

  prev = nodeInfoArray[startId].pathPrev;
  next = nodeInfoArray[startId].pathNext;

  if (next<0) {

    if (enBack<2 && nodeInfoArray[startId].isTarget) {
      Pdtutil_Assert(startId!=visitId,"startId == visitId");
      nodeInfoArray[startId].pathNext = terminalId;
      return 1;
    }

    for (i=0; i<nodeInfoArray[startId].foCnt; i++) {
      int next = nodeInfoArray[startId].foIds[i];
      if (findFwdAugmPath(next,
            visitId,visitedNodes,nodeInfoArray,enBack)) {
        nodeInfoArray[startId].pathNext = next;
        nodeInfoArray[next].pathPrev = startId;
	return 1;
      }
    }

    return 0;

  }

  if (!enBack) return 0;

  if (prev < 0) { /* input */
    return 0;
  }

  //  Pdtutil_Assert(!nodeInfoArray[startId].isInput,"INPUT found");

  /* for each fanout of prev != startId */
  for (i=0; i<nodeInfoArray[prev].foCnt; i++) {
    int next = nodeInfoArray[prev].foIds[i];
    if (next == startId) continue;
    if (findFwdAugmPath(next,
          visitId,visitedNodes,nodeInfoArray,enBack)) {
      nodeInfoArray[prev].pathNext = next;
      minCutNodeSetNext(nodeInfoArray,prev,next);
      nodeInfoArray[next].pathPrev = prev;
      nodeInfoArray[startId].pathPrev = -1;
      return 1;
    }
  }

  if (findFwdAugmPath(prev,visitId,visitedNodes,nodeInfoArray,enBack)) {
    nodeInfoArray[prev].pathNext = -1;
    nodeInfoArray[startId].pathPrev = -1;
    return 1;
  }

  return 0;

}


/**Function********************************************************************

  Synopsis    [Recursive steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
findFwdBwdAugmPathBF(
  bAig_array_t *visitedNodes,
  mincut_info *nodeInfoArray,
  int *bfvAuxArray,
  int startFromAll,
  int setMinCut,
  int doPrint
)
{
  int i, k, prev, next, curr, terminalId = visitedNodes->num;
  int nNodes = visitedNodes->num;
  int pathFound = 0, nMinCut=0, pathTarget = -1;

  /* BF visit from selected PIs. Choose flow nodes < cutMaxSize */
  /* push start nodes to FIFO QUEUE */
  for (i=k=0; i<nNodes; i++) {
    nodeInfoArray[i].bfVisited = 0;
    if (nodeInfoArray[i].isInput && !nodeInfoArray[i].isSmooth) {
      nodeInfoArray[i].bfVisited = 1;
      if (!nodeInfoArray[i].flowVisited) {
	bfvAuxArray[k++] = i;
      }
    }
    else if (0&&startFromAll && !nodeInfoArray[i].isInput &&
	     nodeInfoArray[i].isSmooth) {
      bfvAuxArray[k++] = i;
      nodeInfoArray[i].bfVisited = 1;
    }
    else if (0&&startFromAll && !nodeInfoArray[i].isInput &&
	     nodeInfoArray[i].isSmooth && nodeInfoArray[i].flowVisited) {
      bfvAuxArray[k++] = i;
      nodeInfoArray[i].bfVisited = 1;
    }
  }

  if (k==0 && !setMinCut) {
    Pdtutil_Assert(!setMinCut,"problem setting min cut");
    return (0);
  }

  for (i=0; i<k && i<nNodes; i++) {
    int ir, il, l;
    int j = bfvAuxArray[i];
    bAigEdge_t baig = visitedNodes->nodes[j];

    if (nodeInfoArray[j].isTarget && !nodeInfoArray[j].flowVisited) {
      /* augmenting path found */
      pathFound = 1;
      pathTarget = j;
      break;
    }

    /* visit fanin edges */
    ir = nodeInfoArray[j].fiIds[0];
    il = nodeInfoArray[j].fiIds[1];
    if (ir>=0 && il>=0) {
      if (!nodeInfoArray[ir].bfVisited) {
	Pdtutil_Assert(k<nNodes,"wrong bfv index");
	bfvAuxArray[k++] = ir;
	nodeInfoArray[ir].bfVisited = 1;
	nodeInfoArray[ir].pathPrev = j;
      }
      if (!nodeInfoArray[il].bfVisited) {
	Pdtutil_Assert(k<nNodes,"wrong bfv index");
	bfvAuxArray[k++] = il;
	nodeInfoArray[il].bfVisited = 1;
	nodeInfoArray[il].pathPrev = j;
      }
    }

    if (!nodeInfoArray[j].flowVisited)  {
      /* flow blocks forward propagation */

      for (l=0; l<nodeInfoArray[j].foCnt; l++) {
	/* visit fanout edges */
	int foNodeId = nodeInfoArray[j].foIds[l];
	if (!nodeInfoArray[foNodeId].bfVisited) {
	  Pdtutil_Assert(k<nNodes,"wrong bfv index");
	  Pdtutil_Assert(foNodeId>=0,"wrong fo index");
	  bfvAuxArray[k++] = foNodeId;
	  nodeInfoArray[foNodeId].bfVisited = 1;
	  nodeInfoArray[foNodeId].pathPrev = j;
	}
      }
    }

  }


  if (setMinCut) {
    Pdtutil_Assert(!pathFound,"flow found when searching Min Cut");
    for (i=0; i<nNodes; i++) {
      int ii, jj;
      nodeInfoArray[i].noCutRegion = !nodeInfoArray[i].bfVisited;
      if (nodeInfoArray[i].flowVisited && nodeInfoArray[i].bfVisited &&
	  nodeInfoArray[i].isTarget /*&& nodeInfoArray[i].isInput*/) {
	nodeInfoArray[i].isMinCut = 1;
	nMinCut++;
	if (doPrint) {
	  printf("MIN CUT id: %d\n", i);
	}
      }
      if (nodeInfoArray[i].fiIds[0]<0) continue;
      if (nodeInfoArray[i].flowVisited && !nodeInfoArray[i].bfVisited) {
	for (ii=0; ii<2; ii++) {
	/* visit fanin edges */
	  jj = nodeInfoArray[i].fiIds[ii];
	  if (nodeInfoArray[jj].bfVisited && !nodeInfoArray[jj].isMinCut) {
	    nodeInfoArray[jj].isMinCut = 1;
	    nMinCut++;
	    Pdtutil_Assert(!nodeInfoArray[i].isMinCut,
			   "functionally dependent cuts");
	    if (doPrint) {
	      printf("MIN CUT id: %d\n", jj);
	    }
	  }
	}
      }
    }
  }

  if (pathFound) {
    /* update residual graph */
    int pathStart = -1;
    if (doPrint) {
      printf("AUGMENTING PATH found (reversed): ");
    }
    for (curr=pathTarget,next=-1; curr!=-1;
	 next=curr,curr=nodeInfoArray[curr].pathPrev) {
      if (doPrint) {
	printf("%d %s", curr,
		nodeInfoArray[curr].pathPrev>=0 ? "<- ":"");
      }
      nodeInfoArray[curr].pathNext = next;
      nodeInfoArray[curr].flowVisited = 1;
    }
    if (doPrint) {
      printf("\n");
    }
    Pdtutil_Assert(next>=0,"unable to visit path forward");
    pathStart = next;
    for (curr=pathStart; curr!=-1; curr=nodeInfoArray[curr].pathNext) {
      nodeInfoArray[curr].refInput = pathStart;
    }
  }

  /* reset graph */
  for (i=0; i<nNodes; i++) {
    nodeInfoArray[i].bfVisited = 0;
    nodeInfoArray[i].pathPrev = -1;
    if (setMinCut && !nodeInfoArray[i].isMinCut) {
      nodeInfoArray[i].refInput = -1;
    }
  }

  return (setMinCut ? nMinCut : pathFound);

}


/**Function********************************************************************

  Synopsis    [Recursive steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
evalMinCut(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *care,
  bAig_array_t *visitedNodes,
  mincut_info *nodeInfoArray,
  int doFullFlow,
  int *roots,
  int nRoots
)
{
  int i, j, cutv_i=0;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Vararray_t *newVars = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *newSharedVars = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *refVars = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bddarray_t *refVarsLits;
  Ddi_Bddarray_t *sharedF = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Bdd_t *auxProd = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Varset_t *mySmooth = Ddi_VarsetVoid(ddm);
  int *sharedIds, nSharedVars=0;
  Ddi_Bdd_t *resBdd, *careBdd = Ddi_BddMakeConstAig(ddm,1);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int doPrint = (verbosity >= Pdtutil_VerbLevelDevMax_c);

  int auxSize;
  static int nCalls=0;

  nCalls++;

  if (care != NULL) {
    Ddi_BddAndAcc(careBdd,care);
  }

  sharedIds = Pdtutil_Alloc(int,visitedNodes->num);
  for (i=0; i<visitedNodes->num; i++) {
    sharedIds[i] = -1;
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAigEdge_t baig1;
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (bAig_isVarNode(bmgr,baig)) {
      baig1 = bAig_NonInvertedEdge(baig);
      bAig_Ref(bmgr, baig1);
      if (nodeInfoArray[i].isSmoothInput && !nodeInfoArray[i].isMinCut) {
	Ddi_Var_t *smv = Ddi_VarFromBaig(ddm,baig);
	Ddi_VarsetAddAcc(mySmooth,smv);
      }
    }
    else {
      /* compute baig1 */
      bAigEdge_t right, left;
      int ir = nodeInfoArray[i].fiIds[0];
      int il = nodeInfoArray[i].fiIds[1];
      bAigEdge_t br = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t bl = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(br) ? bAig_Not(bAig_AuxAig1(bmgr,br)) :
                                       bAig_AuxAig1(bmgr,br);
      left  = bAig_NodeIsInverted(bl) ? bAig_Not(bAig_AuxAig1(bmgr,bl)) :
                                       bAig_AuxAig1(bmgr,bl);

      if (!nodeInfoArray[i].noCutRegion) {
        if (nodeInfoArray[ir].noCutRegion) {
	  /* node is in cut region with fanin out of cut region */
	  Ddi_Var_t *rV;
          if (sharedIds[ir] >= 0) {
	    rV = Ddi_VararrayRead(newSharedVars,sharedIds[ir]);
	  }
	  else {
	    char name[1000];
	    Ddi_Bdd_t *auxF, *auxLit;
	    sharedIds[ir] = nSharedVars;
  	    sprintf(name,"Pdtrav_MinCut_AuxVar_%d", nSharedVars++);
  	    rV = Ddi_VarFromName(ddm, name);
	    if (rV == NULL) {
	      rV = Ddi_VarNew(ddm);
	      Ddi_VarAttachName(rV, name);
	    }
	    Ddi_VararrayInsertLast(newSharedVars,rV);
	    auxF = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig1(bmgr,br));
	    Ddi_BddarrayInsertLast(sharedF,auxF);
	    auxLit = Ddi_BddMakeLiteralAig(rV,1);
	    Ddi_BddXnorAcc(auxF,auxLit);
	    Ddi_BddAndAcc(careBdd,auxF);
	    Ddi_Free(auxF);
	    Ddi_Free(auxLit);
	  }
	  right = Ddi_VarToBaig(rV);
	  if (bAig_NodeIsInverted(br)) {
	    right = bAig_Not(right);
	  }
	}
        if (nodeInfoArray[il].noCutRegion) {
	  /* node is in cut region with fanin out of cut region */
	  Ddi_Var_t *rV;
          if (sharedIds[il] >= 0) {
	    rV = Ddi_VararrayRead(newSharedVars,sharedIds[il]);
	  }
	  else {
	    char name[1000];
	    Ddi_Bdd_t *auxF, *auxLit;
	    sharedIds[il] = nSharedVars;
  	    sprintf(name,"Pdtrav_MinCut_AuxVar_%d", nSharedVars++);
  	    rV = Ddi_VarFromName(ddm, name);
	    if (rV == NULL) {
	      rV = Ddi_VarNew(ddm);
	      Ddi_VarAttachName(rV, name);
	    }
	    Ddi_VararrayInsertLast(newSharedVars,rV);
	    auxF = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig1(bmgr,bl));
	    Ddi_BddarrayInsertLast(sharedF,auxF);
	    auxLit = Ddi_BddMakeLiteralAig(rV,1);
	    Ddi_BddXnorAcc(auxF,auxLit);
	    Ddi_BddAndAcc(careBdd,auxF);
	    Ddi_Free(auxF);
	    Ddi_Free(auxLit);
	  }
	  left = Ddi_VarToBaig(rV);
	  if (bAig_NodeIsInverted(bl)) {
	    left = bAig_Not(left);
	  }
	}
      }
      else if (1 && !nodeInfoArray[i].isMinCut){
	Pdtutil_Assert(ir<0||
          nodeInfoArray[ir].noCutRegion,"wrong no cut fanin");
	Pdtutil_Assert(il<0||
          nodeInfoArray[il].noCutRegion,"wrong no cut fanin");
      }

      baig1 = bAig_And(bmgr,right,left);

      if ((j=nodeInfoArray[i].refInput)>=0) {
        char name[1000];
	Ddi_Var_t *newv;
        bAigEdge_t baigRef;
	Ddi_Var_t *refv;
	Ddi_Bdd_t *lit, *auxF;

        while (j!=nodeInfoArray[j].refInput) {
	  Pdtutil_Assert(j>=0,"wrong ref input");
          j = nodeInfoArray[j].refInput;
	}
        baigRef = visitedNodes->nodes[j];
	refv = Ddi_VarFromBaig(ddm,baigRef);

	Pdtutil_Assert(refv!=NULL,"no ref var");

	sprintf(name,"Pdtrav_MinCut_Var_%d_%d", nCalls, cutv_i);
	newv = Ddi_VarFromName(ddm, name);
	if (newv == NULL) {
	  newv = Ddi_VarNew(ddm);
	  Ddi_VarAttachName(newv, name);
	}
	lit = Ddi_BddMakeLiteralAig(newv, 1);
	Ddi_VararrayWrite(newVars,cutv_i,newv);
	Ddi_VararrayWrite(refVars,cutv_i++,refv);
	auxF = Ddi_BddMakeFromBaig(ddm,baig1);
	Ddi_BddXnorAcc(auxF,lit);
	Ddi_BddAndAcc(auxProd,auxF);
	Ddi_Free(auxF);
	baig1 = Ddi_BddToBaig(lit);
        bAig_Ref(bmgr, baig1);
	Ddi_Free(lit);
      }
      else {
        bAig_Ref(bmgr, baig1);
      }
    }
    bAig_AuxAig1(bmgr,baig) = baig1;

  }

  resBdd = Ddi_BddMakePartConjVoid(ddm);
  for (i=0; i<nRoots; i++) {
    int j = roots[i];
    Ddi_Bdd_t *res_i = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig1(bmgr,
             visitedNodes->nodes[j]));
    //    Pdtutil_Assert(aigIsInv(Ddi_BddPartRead(f,i))==
    //          bAig_NodeIsInverted(visitedNodes->nodes[j]),"AAAHHH");
    if (aigIsInv(Ddi_BddPartRead(f,i))) {
      Ddi_BddNotAcc(res_i);
    }
    Ddi_BddPartInsertLast(resBdd,res_i);
    Ddi_Free(res_i);
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
  }

  refVarsLits = Ddi_BddarrayMakeLiteralsAig(refVars,1);
  //  mySmooth = Ddi_VarsetMakeFromArray(refVars);

  auxSize = Ddi_BddSize(auxProd);

  if (0 && (Ddi_BddSize(auxProd) <
            2*(Ddi_BddSize(resBdd)+Ddi_BddarraySize(sharedF)))) {

    if (doFullFlow) {
      /* no auxProd */
      Ddi_Bdd_t *tmp = auxProd;
      auxProd = resBdd;
      resBdd = tmp;
      Ddi_BddSetAig(auxProd);
      Ddi_BddSetPartConj(resBdd);
      Ddi_AigExistAcc(auxProd,mySmooth,careBdd,2,0,-1.0);
    }
    else {
      Ddi_Bdd_t *tryExist = Ddi_BddDup(auxProd);
      Ddi_AigExistAcc(tryExist,mySmooth,careBdd,3,0,100.0);
      if (Ddi_BddSize(tryExist)<1.2*Ddi_BddSize(auxProd)) {
	Ddi_Free(auxProd);
        auxProd = Ddi_BddDup(tryExist);
      }
      Ddi_Free(tryExist);
    }

    {
      int rrl = Ddi_MgrReadAigRedRemLevel(ddm);

      Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,3);
      DdiAigRedRemovalAcc (auxProd,careBdd,-1,200.0);
      Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRem_c,inum,rrl);
    }

    if (doPrint) {
      fprintf(dMgrO(ddm),"AUXSIZE: %d -> %d\n", auxSize, Ddi_BddSize(auxProd));
      fprintf(dMgrO(ddm),"BASESIZE: %d\n", Ddi_BddSize(resBdd));
    }

    Ddi_BddPartInsertLast(resBdd,auxProd);
    if (nSharedVars > 0) {
      Ddi_Bddarray_t *b,*a = Ddi_BddarrayAlloc(ddm,1);
      a = Ddi_BddarrayMakeFromBddPart(resBdd);
      b = Ddi_AigarrayCompose (a,newSharedVars,sharedF);
      resBdd = Ddi_BddMakePartConjFromArray(b);
      Ddi_Free(a);
      Ddi_Free(b);
      // Ddi_BddComposeAcc(auxProd,newSharedVars,sharedF);
    }

    //    Ddi_BddComposeAcc(resBdd,newVars,refVarsLits);
    if (doPrint) {
      fprintf(dMgrO(ddm),"TOTSIZE: %d\n", Ddi_BddSize(resBdd));
    }
  }
  else {
    Ddi_Free(resBdd);
  }

  Pdtutil_Free(sharedIds);
  Ddi_Free(sharedF);
  Ddi_Free(careBdd);
  Ddi_Free(newSharedVars);
  Ddi_Free(mySmooth);
  Ddi_Free(refVars);
  Ddi_Free(refVarsLits);
  Ddi_Free(newVars);
  Ddi_Free(auxProd);

  return (resBdd);

}



/**Function********************************************************************
  Synopsis    [Recursive steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
evalMinCutArray(
  Ddi_Bddarray_t *fA,
  Ddi_Bddarray_t *auxFA,
  Ddi_Vararray_t *auxVA,
  bAig_array_t *visitedNodes,
  mincut_info *nodeInfoArray,
  int doFullFlow,
  int *roots,
  int nRoots,
  int cutShortEdges
)
{
  int i, j, cutv_i=0;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Vararray_t *newVars = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *newSharedVars = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *refVars = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bddarray_t *refVarsLits=NULL;
  Ddi_Bddarray_t *sharedF = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Bdd_t *auxProd = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Varset_t *mySmooth = Ddi_VarsetVoid(ddm);
  int *sharedIds, nSharedVars=0;
  Ddi_Bddarray_t *resBddA;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int doPrint = 1 || (verbosity >= Pdtutil_VerbLevelDevMax_c);
  int totCut = 0, totCutInput = 0;
  int auxSize;
  static int nCalls=0;
  int doMinCut = !cutShortEdges;

  nCalls++;

  sharedIds = Pdtutil_Alloc(int,visitedNodes->num);
  for (i=0; i<visitedNodes->num; i++) {
    sharedIds[i] = -1;
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAigEdge_t baig1;
    int refInput = -1;
    int doCut = 0;
    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if (bAig_isVarNode(bmgr,baig)) {
      baig1 = bAig_NonInvertedEdge(baig);
      bAig_Ref(bmgr, baig1);
      if (doMinCut) {
        if (nodeInfoArray[i].isMinCut) {
          totCutInput++;
          if (doFullFlow && nodeInfoArray[i].isSmooth) {
            refInput = nodeInfoArray[i].refInput;
          }
        }
        if (nodeInfoArray[i].isSmoothInput && !nodeInfoArray[i].isMinCut) {
          Ddi_Var_t *smv = Ddi_VarFromBaig(ddm,baig);
          Ddi_VarsetAddAcc(mySmooth,smv);
        }
      }
    }
    else {
      /* compute baig1 */
      bAigEdge_t right, left;
      int ir = nodeInfoArray[i].fiIds[0];
      int il = nodeInfoArray[i].fiIds[1];
      bAigEdge_t br = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t bl = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right = bAig_NodeIsInverted(br) ? bAig_Not(bAig_AuxAig1(bmgr,br)) :
                                       bAig_AuxAig1(bmgr,br);
      left  = bAig_NodeIsInverted(bl) ? bAig_Not(bAig_AuxAig1(bmgr,bl)) :
                                       bAig_AuxAig1(bmgr,bl);
      if (cutShortEdges==1) {
        if (nodeInfoArray[i].isShortEdge[0]) {
          /* short edge, use cut var */
          right = bAig_NodeIsInverted(br) ? bAig_Not(bAig_AuxAig0(bmgr,br)) :
                                       bAig_AuxAig0(bmgr,br);
        }
        if (nodeInfoArray[i].isShortEdge[1]) {
          /* short edge, use cut var */
          left = bAig_NodeIsInverted(bl) ? bAig_Not(bAig_AuxAig0(bmgr,bl)) :
                                       bAig_AuxAig0(bmgr,bl);
        }
      }

      if (nodeInfoArray[ir].cutIndex>=0) {
	Pdtutil_Assert(doFullFlow,"invalid setting");
	if (nodeInfoArray[i].noCutRegion) {
	  /* replace cut var with corresponding func */
	  int id = nodeInfoArray[ir].cutIndex;
	  right = Ddi_VarToBaig(Ddi_VararrayRead(auxVA,id));
	  if (bAig_NodeIsInverted(br)) right = bAig_Not(right);
	}
      }
      if (nodeInfoArray[il].cutIndex>=0) {
	Pdtutil_Assert(doFullFlow,"invalid setting");
	if (nodeInfoArray[i].noCutRegion) {
	  /* replace cut var with corresponding func */
	  int id = nodeInfoArray[il].cutIndex;
	  left = Ddi_VarToBaig(Ddi_VararrayRead(auxVA,id));
	  if (bAig_NodeIsInverted(bl)) left = bAig_Not(left);
	}
      }

      if (nodeInfoArray[i].isMinCut) {
	totCut++;
      }

      if (!doFullFlow && (refInput=nodeInfoArray[i].refInput)>=0) {
        while (refInput!=nodeInfoArray[refInput].refInput) {
	  Pdtutil_Assert(refInput>=0,"wrong ref input");
          refInput = nodeInfoArray[refInput].refInput;
	}
      }
      if (doFullFlow && nodeInfoArray[i].isMinCut) {
	refInput = nodeInfoArray[i].refInput;
      }

      baig1 = bAig_And(bmgr,right,left);
      bAig_Ref(bmgr, baig1);
    }

    doCut = (refInput>=0 ||
             cutShortEdges && nodeInfoArray[i].isShortEdgeCut);

    if (doCut) {
      char name[1000];
      Ddi_Var_t *newv;
      bAigEdge_t baigRef;
      Ddi_Var_t *refv=NULL;
      Ddi_Bdd_t *lit, *auxF;
      int doCompose = 0;
      if (refInput>=0) {
        baigRef = visitedNodes->nodes[refInput];
        refv = Ddi_VarFromBaig(ddm,baigRef);
        Pdtutil_Assert(refv!=NULL,"no ref var");
        Ddi_VararrayWrite(refVars,cutv_i,refv);
        sprintf(name,"Pdtrav_MinCut_Var_%d_%d", nCalls, cutv_i);
      }
      else {
        sprintf(name,"Pdtrav_ShortCut_Var_%d_%d", nCalls, cutv_i);
      }
      //      printf("GENERATING NEW VAR: %s\n", name);
      newv = Ddi_VarFromName(ddm, name);
      if (newv == NULL) {
	newv = Ddi_VarNew(ddm);
	Ddi_VarAttachName(newv, name);
      }
      lit = Ddi_BddMakeLiteralAig(newv, 1);
      Ddi_VararrayWrite(newVars,cutv_i++,newv);
      auxF = Ddi_BddMakeFromBaig(ddm,baig1);
      do {
	Ddi_Varset_t *vs = Ddi_BddSupp(auxF);
	Ddi_Varset_t *vs2 = Ddi_VarsetMakeFromArray(auxVA);
	Ddi_VarsetIntersectAcc(vs,vs2);
	doCompose = Ddi_VarsetNum(vs)>0;
	Ddi_Free(vs);
	Ddi_Free(vs2);
	if (doCompose) {
	  Ddi_BddComposeAcc(auxF,auxVA,auxFA);
	}
      } while (doCompose);
      if (auxFA != NULL && auxVA != NULL) {
	if (doFullFlow &&
	    (/*nodeInfoArray[i].isTarget &&*/ !nodeInfoArray[i].isInput)) {
	  nodeInfoArray[i].cutIndex = Ddi_BddarrayNum(auxFA);
	}
	Ddi_BddarrayInsertLast(auxFA, auxF);
	Ddi_VararrayInsertLast(auxVA, newv);
      }
      Ddi_Free(auxF);
      if (cutShortEdges==1) {
        bAigEdge_t baig0 = Ddi_BddToBaig(lit);
	bAig_Ref(bmgr, baig0);
        bAig_AuxAig0(bmgr,baig) = baig0;
      }
      else {
        if (!doFullFlow) {
          bAig_RecursiveDeref(bmgr,baig1);
          baig1 = Ddi_BddToBaig(lit);
          bAig_Ref(bmgr, baig1);
        }
      }
      Ddi_Free(lit);
    }

    bAig_AuxAig1(bmgr,baig) = baig1;

  }

  resBddA = Ddi_BddarrayAlloc(ddm,nRoots);
  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *res_i, *f_i = Ddi_BddarrayRead(fA,i);
    int j = roots[i];
    if (Ddi_BddIsConstant(f_i)) {
      res_i = Ddi_BddDup(f_i);
    }
    else {
      bAigEdge_t baig = visitedNodes->nodes[j];
      bAigEdge_t baig1 = bAig_AuxAig1(bmgr,baig);
      if (nodeInfoArray[j].cutIndex>=0) {
	int id = nodeInfoArray[j].cutIndex;
	Pdtutil_Assert(doFullFlow,"invalid setting");
	Pdtutil_Assert(nodeInfoArray[j].isMinCut,"cut required");
	/* replace cut var with corresponding func */
	baig1 = Ddi_VarToBaig(Ddi_VararrayRead(auxVA,id));
      }
      res_i = Ddi_BddMakeFromBaig(ddm,baig1);
      //    Pdtutil_Assert(aigIsInv(Ddi_BddPartRead(f,i))==
      //          bAig_NodeIsInverted(visitedNodes->nodes[j]),"AAAHHH");
      if (aigIsInv(Ddi_BddarrayRead(fA,i))) {
        Ddi_BddNotAcc(res_i);
      }
    }
    Ddi_BddarrayWrite(resBddA,i,res_i);
    Ddi_Free(res_i);
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
    if (bAig_AuxAig0(bmgr,baig) != bAig_NULL) {
      bAig_RecursiveDeref(bmgr,bAig_AuxAig0(bmgr,baig));
      bAig_AuxAig0(bmgr,baig) = bAig_NULL;
    }
  }

  //  refVarsLits = Ddi_BddarrayMakeLiteralsAig(refVars,1);
  //  mySmooth = Ddi_VarsetMakeFromArray(refVars);

  if (doPrint && auxFA != NULL && Ddi_BddarrayNum(auxFA)>0) {
    fprintf(dMgrO(ddm),"MINCUT: input=%d, intern=%d, auxv=%d\n",
	   totCutInput, totCut, Ddi_BddarrayNum(auxFA));
    fprintf(dMgrO(ddm),"AUXSIZE: %d\n", Ddi_BddarraySize(auxFA));
      fprintf(dMgrO(ddm),"BASESIZE: %d\n", Ddi_BddarraySize(resBddA));
  }


  Pdtutil_Free(sharedIds);
  Ddi_Free(sharedF);
  Ddi_Free(newSharedVars);
  Ddi_Free(mySmooth);
  Ddi_Free(refVars);
  Ddi_Free(refVarsLits);
  Ddi_Free(newVars);
  Ddi_Free(auxProd);

  return (resBddA);

}


/**Function********************************************************************

  Synopsis    [Inner steps of aig to BDD conversion]
  Description [Inner steps of aig to BDD conversion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
existIntern(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex,
  bAigEdge_t *res0p,
  bAigEdge_t *res1p,
  int depth
  )
{
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAigEdge_t right0, left0, right1, left1;
  int neg = bAig_NodeIsInverted(nodeIndex);

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    *res0p = *res1p = nodeIndex;
    bAig_AuxAig0(manager,nodeIndex) = bAig_NonInvertedEdge(nodeIndex);
    bAig_AuxAig1(manager,nodeIndex) = bAig_NonInvertedEdge(nodeIndex);
    return;
  }

  depth++;

  if (nodeVisited(manager,nodeIndex)) {
    *res0p = bAig_AuxAig0(manager,nodeIndex);
    *res1p = bAig_AuxAig1(manager,nodeIndex);
    if (neg){
      *res0p = bAig_Not(*res0p);
      *res1p = bAig_Not(*res1p);
    }
  }
  else if (bAig_isVarNode(manager,nodeIndex)) {
    *res0p = *res1p = nodeIndex;
    bAig_AuxAig0(manager,nodeIndex) = bAig_NonInvertedEdge(nodeIndex);
    bAig_AuxAig1(manager,nodeIndex) = bAig_NonInvertedEdge(nodeIndex);
  }
  else {
    existIntern(ddm,
      bAig_NodeReadIndexOfRightChild(manager,nodeIndex),&right0,&right1,depth);
    existIntern(ddm,
      bAig_NodeReadIndexOfLeftChild(manager,nodeIndex),&left0,&left1,depth);
    *res0p = bAig_And(manager,right0,left0);
    *res1p = bAig_And(manager,right1,left1);

    nodeSetVisited(manager,nodeIndex);

    bAig_AuxAig0(manager,nodeIndex) = *res0p;
    bAig_AuxAig1(manager,nodeIndex) = *res1p;

    if (0 && (depth < 3) && (*res0p != *res1p)) {
      int *cex;
      int satDiff=1, bddDiff=1;

#if 0

      if (ddm->settings.aig.satCompare) {
        satDiff = ((cex = AigSatDiff(ddm,nodeIndex)) != NULL);
	Pdtutil_Free(cex);
      }

      if (ddm->settings.aig.bddCompare) {
        Ddi_Bdd_t *cof0 =
          Ddi_BddCofactor((Ddi_Bdd_t *)bAig_AuxPtr(manager,nodeIndex),
            cofVar,0);
        Ddi_Bdd_t *cof1 =
          Ddi_BddCofactor((Ddi_Bdd_t *)bAig_AuxPtr(manager,nodeIndex),
            cofVar,1);
        bddDiff = !Ddi_BddEqual(cof0,cof1);
        Ddi_Free(cof0);
        Ddi_Free(cof1);
      }
#endif

      if (ddm->settings.aig.satCompare && ddm->settings.aig.bddCompare) {
	Pdtutil_Assert(satDiff == bddDiff,"mismatching BDD and SAT checks");
      }

      if (!satDiff || !bddDiff) {
	int size0, size1;
	size0 = myNodeCountIntern(manager,*res0p);
        myNodeClearVisitedIntern(manager,*res0p);
	size1 = myNodeCountIntern(manager,*res1p);
        myNodeClearVisitedIntern(manager,*res1p);

        if (size0<size1) {
          bAig_AuxAig1(manager,nodeIndex) = *res1p = *res0p;
	}
	else {
          bAig_AuxAig0(manager,nodeIndex) = *res0p = *res1p;
	}
      }
    }

    if (neg){
      *res0p = bAig_Not(*res0p);
      *res1p = bAig_Not(*res1p);
    }

  }

  return;
}


/**Function********************************************************************

  Synopsis    [Clear Visited flag]
  Description [Clear Visited flag]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
composeClearVisitedIntern(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex,
   int enaMultiple
)
{

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    return;
  }

  if (!nodeVisited(manager,nodeIndex)) {
    return;
  }

  nodeClearVisited(manager,nodeIndex);

  if (enaMultiple && bAig_isVarNode(manager,nodeIndex)) {
    composeClearVisitedIntern(manager,
      bAig_AuxPtrNum(manager,nodeIndex),enaMultiple);
  }

  bAig_RecursiveDeref(manager,bAig_AuxPtrNum(manager,nodeIndex));
  bAig_AuxPtr(manager,nodeIndex) = NULL;

  composeClearVisitedIntern(manager,rightChild(manager,nodeIndex),enaMultiple);
  composeClearVisitedIntern(manager,leftChild(manager,nodeIndex),enaMultiple);

}

/**Function********************************************************************

  Synopsis    [Clear Visited flag]
  Description [Clear Visited flag]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
existClearVisitedIntern(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    if (bAig_AuxAig0(manager,nodeIndex)!=bAig_NULL) {
      bAig_RecursiveDeref(manager,bAig_AuxAig0(manager,nodeIndex));
    }
    if (bAig_AuxAig1(manager,nodeIndex)!=bAig_NULL) {
      bAig_RecursiveDeref(manager,bAig_AuxAig1(manager,nodeIndex));
    }
    bAig_AuxAig0(manager,nodeIndex) = bAig_NULL;
    bAig_AuxAig1(manager,nodeIndex) = bAig_NULL;
    return;
  }

  if (!nodeVisited(manager,nodeIndex)) {
    return;
  }

  nodeClearVisited(manager,nodeIndex);
  nodeAuxChar(manager,nodeIndex) = 0;
  bAig_AuxAig0(manager,nodeIndex) = bAig_NULL;
  bAig_AuxAig1(manager,nodeIndex) = bAig_NULL;

  existClearVisitedIntern(manager,rightChild(manager,nodeIndex));
  existClearVisitedIntern(manager,leftChild(manager,nodeIndex));

}

/**Function********************************************************************

  Synopsis    [Clear Visited flag]
  Description [Clear Visited flag]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aig2BddClearVisitedIntern(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    return;
  }

#if 0
  if (!nodeVisited(manager,nodeIndex)) {
#else
  if (bAig_AuxPtr(manager,nodeIndex) == NULL) {
#endif
    return;
  }

#if 0
  nodeClearVisited(manager,nodeIndex);
#endif
  Ddi_Free(bAig_AuxPtr(manager,nodeIndex));
  bAig_AuxPtr(manager,nodeIndex) = NULL;

  aig2BddClearVisitedIntern(manager,rightChild(manager,nodeIndex));
  aig2BddClearVisitedIntern(manager,leftChild(manager,nodeIndex));

}


/**Function********************************************************************
  Synopsis    [Clear Visited flag]
  Description [Clear Visited flag]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aig2CnfClearVisitedIntern(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{
  Ddi_Mgr_t *ddm = (Ddi_Mgr_t *)manager->owner;

  int id = bAig_CnfId(manager,nodeIndex);

  if (id != 0) {
    Pdtutil_Assert(ddm->cnf.cnf2aig[id] == bAig_NonInvertedEdge(nodeIndex),
      "Incompatible CNF id");
    ddm->cnf.cnf2aig[id] = bAig_NULL;
  }
  bAig_CnfId(manager,nodeIndex) = 0;

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    return;
  }

  if (nodeVisited(manager,nodeIndex)<4) {
    return;
  }

  nodeVisited(manager,nodeIndex) -= 4;

  aig2CnfClearVisitedIntern(manager,rightChild(manager,nodeIndex));
  aig2CnfClearVisitedIntern(manager,leftChild(manager,nodeIndex));

}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
aig2CnfIdLoad(
  Ddi_Mgr_t *ddm,
  bAig_array_t *cnfMapping,
  int setActive
)
{
  int i, vCnf;
  Pdtutil_Assert(ddm->cnf.cnf2aigOpen,"cnf2aig is not open");

  for (i=1; i<cnfMapping->num; i++) {
    bAigEdge_t baig = cnfMapping->nodes[i];
    if (baig == bAig_NULL) {
      vCnf = aig2CnfNewIdIntern(ddm);
    }
    else {
      vCnf = aig2CnfId(ddm->aig.mgr,baig);
      cnfSetActive(ddm,vCnf,setActive);
    }
    Pdtutil_Assert(vCnf==i,"error in cnf mapping load");
  }
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
aig2CnfIdInit(
  Ddi_Mgr_t *ddm
)
{
#if 1

  Pdtutil_Assert(!ddm->cnf.cnf2aigOpen,"cnf2aig is not closed");
  ddm->cnf.cnf2aigOpen=1;
  ddm->cnf.cnf2aigStrategy=0;
  if (ddm->cnf.cnf2aig!=NULL) {
    int i;
    Pdtutil_Assert(ddm->cnf.maxCnfId < ddm->cnf.cnf2aigSize,
      "maxCnfAig out of bounds");
    for (i=1; i<=ddm->cnf.maxCnfId; i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (baig == bAig_NULL) {
	continue;
      }
      assert(bAig_CnfId(ddm->aig.mgr,baig)==0);
      Pdtutil_Assert(bAig_CnfId(ddm->aig.mgr,baig)==0,"cnf ID nod cleared");
    }
  }
  else {
    ddm->cnf.cnf2aigSize = 10000;
    ddm->cnf.cnf2aig = Pdtutil_Alloc(int,ddm->cnf.cnf2aigSize);
    ddm->cnf.cnfActive = Pdtutil_Alloc(unsigned char,ddm->cnf.cnf2aigSize);
  }
  ddm->cnf.maxCnfId = 0;
#endif
  return 0;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
aig2CnfIdInitDecr(
  Ddi_Mgr_t *ddm,
  int size
)
{
#if 1
  Pdtutil_Assert(!ddm->cnf.cnf2aigOpen,"cnf2aig is not closed");
  if (ddm->settings.aig.satVarActivity < -1) {
    int r, a = ddm->settings.aig.satVarActivity;
    ddm->settings.aig.satVarActivity=0;
    r = aig2CnfIdInit(ddm);
    ddm->settings.aig.satVarActivity=a;
    return r;
  }
  ddm->cnf.cnf2aigOpen=1;
  ddm->cnf.cnf2aigStrategy=1;
  if (ddm->cnf.cnf2aig!=NULL) {
    int i;
    Pdtutil_Assert(ddm->cnf.maxCnfId < ddm->cnf.cnf2aigSize,
      "maxCnfAig out of bounds");
    for (i=1; i<=ddm->cnf.maxCnfId; i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (baig == bAig_NULL) {
	continue;
      }
      assert(bAig_CnfId(ddm->aig.mgr,baig)==0);
      Pdtutil_Assert(bAig_CnfId(ddm->aig.mgr,baig)==0,"cnf ID nod cleared");
    }
  }
  else {
    ddm->cnf.cnf2aigSize = size;
    ddm->cnf.cnf2aig = Pdtutil_Alloc(int,ddm->cnf.cnf2aigSize);
    ddm->cnf.cnfActive = Pdtutil_Alloc(unsigned char,ddm->cnf.cnf2aigSize);
  }
  ddm->cnf.maxCnfId = size;
  ddm->cnf.currCnfId = size;
  while (ddm->cnf.maxCnfId >= ddm->cnf.cnf2aigSize) {
    ddm->cnf.cnf2aigSize *= 2;
    ddm->cnf.cnf2aig = Pdtutil_Realloc(int, ddm->cnf.cnf2aig,
     ddm->cnf.cnf2aigSize);
    ddm->cnf.cnfActive = Pdtutil_Realloc(unsigned char, ddm->cnf.cnfActive,
     ddm->cnf.cnf2aigSize);
  }
#endif
  return 0;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int aig2CnfIdClose(
  Ddi_Mgr_t *ddm
)
{
  Pdtutil_Assert(ddm->cnf.cnf2aigOpen,"cnf2aig is not opened");
  ddm->cnf.cnf2aigOpen=0;
  if (ddm->cnf.cnf2aig!=NULL) {
    int i;
    Pdtutil_Assert(ddm->cnf.maxCnfId < ddm->cnf.cnf2aigSize,
      "maxCnfAig out of bounds");
    for (i=1; i<=ddm->cnf.maxCnfId; i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (ddm->cnf.cnf2aigStrategy>0) {
        if (i==ddm->cnf.maxCnfId || i<ddm->cnf.currCnfId) {
          ddm->cnf.cnf2aig[i] = bAig_NULL;
          ddm->cnf.cnfActive[i] = (unsigned char)0;
          continue;
        }
      }
      if (baig == bAig_NULL) {
	continue;
      }
      ddm->cnf.cnf2aig[i] = bAig_NULL;
      ddm->cnf.cnfActive[i] = (unsigned char)0;
      bAig_CnfId(ddm->aig.mgr,baig) = 0;
      bAig_AuxRef(ddm->aig.mgr,baig) = 0;
      nodeAuxChar(ddm->aig.mgr,baig) = 0;
    }
  }
  ddm->cnf.cnf2aigStrategy=0;
  return 0;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int aig2CnfIdClear(
  Ddi_Mgr_t *ddm,
  bAigEdge_t nodeIndex
)
{
  bAig_Manager_t *manager = ddm->aig.mgr;
  int id;

  Pdtutil_Assert(ddm->cnf.cnf2aigOpen,"cnf2aig is not opened");

  Pdtutil_Assert(bAig_CnfId(manager,nodeIndex) != 0, "aig without cnf id");

  id = bAig_CnfId(manager,nodeIndex);
  Pdtutil_Assert(abs(id) <= ddm->cnf.maxCnfId,"wrong CNF id");
  Pdtutil_Assert(abs(id) > 0,"wrong CNF id");

  if (ddm->cnf.cnf2aig!=NULL) {
    ddm->cnf.cnf2aig[id] = bAig_NULL;
    ddm->cnf.cnfActive[id] = (unsigned char)0;
  }

  bAig_CnfId(manager,nodeIndex) = 0;

  return id;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static bAigEdge_t cnfId2AigClear(
  Ddi_Mgr_t *ddm,
  bAig_array_t *cnfMappedVars,
  int cnfId
)
{
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAigEdge_t nodeIndex;

  Pdtutil_Assert(ddm->cnf.cnf2aigOpen,"cnf2aig is not opened");

  Pdtutil_Assert(ddm->cnf.cnf2aig!=NULL,"no cnf2aig table");

  Pdtutil_Assert(cnfId < ddm->cnf.cnf2aigSize,
		 "cnfAig out of bounds");

  nodeIndex = ddm->cnf.cnf2aig[cnfId];

  Pdtutil_Assert(abs(bAig_CnfId(manager,nodeIndex)) == abs(cnfId), 
		 "wrong cnf id");

  bAig_CnfId(manager,nodeIndex) = 0;

  ddm->cnf.cnf2aig[cnfId] = bAig_NULL;
  ddm->cnf.cnfActive[cnfId] = (unsigned char)0;

  if (cnfMappedVars!=NULL && cnfMappedVars->num>cnfId) {
    cnfMappedVars->nodes[cnfId] = bAig_NULL;
  }

  return nodeIndex;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int satActivity(
  Ddi_Mgr_t *ddm,
  Solver *S
)
{
  int i;
  double act, norm, up;

  if (ddm->settings.aig.satVarActivity <= 0) return 0;

  if (ddm->settings.aig.satVarActivity == 2) return 0;

  norm = (double) S->nVars() * 1e10;
  up = ddm->settings.aig.satVarActivity > 0;

  for (i=1; i<=S->nVars(); i++) {
    act = up ? ((double) (-i) / norm) + 1.0 :((double) (i) / norm) ;
    S->varBumpActivityExternal(MinisatLit(i),act);
  }
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int aig2SatActivity(
  Ddi_Mgr_t *ddm,
  Solver *S
)
{
  satActivity(ddm,S);

  if (ddm->settings.aig.satVarActivity <= 1) return 0;
  Pdtutil_Assert(ddm->cnf.cnf2aigOpen,"cnf2aig is not opened");

  if (ddm->cnf.cnf2aig!=NULL) {
    int i; double act;
    bAig_Manager_t *manager = ddm->aig.mgr;
    Pdtutil_Assert(ddm->cnf.maxCnfId < ddm->cnf.cnf2aigSize,
      "maxCnfAig out of bounds");
    for (i=1; i<=ddm->cnf.maxCnfId; i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (baig == bAig_NULL) {
	continue;
      }
      act = (double) bAig_AuxFloat(manager,baig);
      if (act > 0) {
        S->varBumpActivityExternal(MinisatLit(i),act);
      }
    }
  }
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void cnfSetActive(
  Ddi_Mgr_t *ddm,
  int i,
  int val
)
{
  Pdtutil_Assert(ddm->cnf.cnf2aigOpen,"cnf2aig is not opened");
  Pdtutil_Assert(ddm->cnf.maxCnfId >= i, "cnf id out of bounds");
  if (i<0) i=-i;
  ddm->cnf.cnfActive[i] = (unsigned char)val;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static unsigned char cnfReadActive(
  Ddi_Mgr_t *ddm,
  int i
)
{
  Pdtutil_Assert(ddm->cnf.cnf2aigOpen,"cnf2aig is not opened");

  if (i<0) i=-i;
  if (ddm->cnf.maxCnfId < i) return 0;

  return ddm->cnf.cnfActive[i];
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int vararray2AigActivity(
  Ddi_Vararray_t *vA,
  float scale
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(vA);
  bAig_Manager_t *manager = ddm->aig.mgr;
  int i, nv=Ddi_VararrayNum(vA); double act;

  if (ddm->settings.aig.satVarActivity <= 1) return 0;

  for (i=0; i<nv; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    int varIndex = Ddi_VarToBaig(v);
    bAig_AuxFloat(manager,varIndex) = (float) (nv-i) * scale;
    //    bAig_AuxFloat(manager,varIndex) = (float) (i) * scale;
  }

  return 1;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int sat2AigActivity(
  Ddi_Mgr_t *ddm,
  Solver *S
)
{
  if (ddm->settings.aig.satVarActivity <= 1) return 0;

  Pdtutil_Assert(ddm->cnf.cnf2aigOpen,"cnf2aig is not opened");
  if (ddm->cnf.cnf2aig!=NULL) {
    int i; double act;
    bAig_Manager_t *manager = ddm->aig.mgr;
    Pdtutil_Assert(ddm->cnf.maxCnfId < ddm->cnf.cnf2aigSize,
      "maxCnfAig out of bounds");
    for (i=1; i<=ddm->cnf.maxCnfId && i<S->nVars(); i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (baig == bAig_NULL) {
	continue;
      }
      act = S->varReadActivityExternal(MinisatLit(i));
      if (act>0) {
        bAig_AuxFloat(manager,baig) = (float) (act/(1e20));
      }
      else {
        bAig_AuxFloat(manager,baig) = 0;
      }
    }
  }
  return 1;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
aig2CnfIdIntern(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{
  Ddi_Mgr_t *ddm = (Ddi_Mgr_t *)manager->owner;
  int id = 0;
  static int nCalls=0;

  //  nCalls++;

  if (bAig_CnfId(manager,nodeIndex) != 0) {
    id = bAig_CnfId(manager,nodeIndex);
    Pdtutil_Assert(abs(id) <= ddm->cnf.maxCnfId,"wrong CNF id");
    return (id);
  }
  //  if (nCalls > 60000)
  //printf("C: %d\n", nCalls);

  if (ddm->cnf.cnf2aigStrategy==0) {
    id = bAig_CnfId(manager,nodeIndex) = ++ddm->cnf.maxCnfId;
    //  fprintf(dMgrO(ddm),"AIG2CNF: %d -> %d\n",nodeIndex/4,maxCnfId);
#if 1
  }
  else {
    Pdtutil_Assert(ddm->cnf.maxCnfId>0,"invalid maxcnfid");
    id = bAig_CnfId(manager,nodeIndex) = --ddm->cnf.currCnfId;
    if (ddm->cnf.currCnfId<=1) {
      ddm->cnf.cnf2aigStrategy=0;
      ddm->cnf.maxCnfId--;
    }
  }
  while (ddm->cnf.maxCnfId >= ddm->cnf.cnf2aigSize) {
    ddm->cnf.cnf2aigSize *= 2;
    ddm->cnf.cnf2aig = Pdtutil_Realloc(int, ddm->cnf.cnf2aig,
     ddm->cnf.cnf2aigSize);
    ddm->cnf.cnfActive = Pdtutil_Realloc(unsigned char, ddm->cnf.cnfActive,
     ddm->cnf.cnf2aigSize);
  }
  Pdtutil_Assert(id>0,"wrong CNF id");

  ddm->cnf.cnf2aig[id] = bAig_NonInvertedEdge(nodeIndex);
  ddm->cnf.cnfActive[id] = (unsigned char)0;
#endif
  return (id);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
aig2CnfIdRead(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{
  Ddi_Mgr_t *ddm = (Ddi_Mgr_t *)manager->owner;

  if (bAig_CnfId(manager,nodeIndex) != 0) {
    int id = bAig_CnfId(manager,nodeIndex);
    Pdtutil_Assert(id!=0 && abs(id) <= ddm->cnf.maxCnfId,"wrong CNF id");
    return (id);
  }

  return (0);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aig2CnfIdWrite(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex,
   int id
)
{
  bAig_CnfId(manager,nodeIndex) = id;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
aig2CnfNewIdIntern(
  Ddi_Mgr_t *ddm
)
{
  int id;
  if (ddm->cnf.cnf2aigStrategy==0) {
    id = ++ddm->cnf.maxCnfId;
  }
  else {
    Pdtutil_Assert(ddm->cnf.maxCnfId>0,"invalid maxcnfid");
    id = --ddm->cnf.currCnfId;
    if (ddm->cnf.currCnfId<=1) {
      ddm->cnf.cnf2aigStrategy=0;
      ddm->cnf.maxCnfId--;
    }
  }
  while (ddm->cnf.maxCnfId >= ddm->cnf.cnf2aigSize) {
    ddm->cnf.cnf2aigSize *= 2;
    ddm->cnf.cnf2aig = Pdtutil_Realloc(int, ddm->cnf.cnf2aig,
      ddm->cnf.cnf2aigSize);
    ddm->cnf.cnfActive = Pdtutil_Realloc(unsigned char, ddm->cnf.cnfActive,
      ddm->cnf.cnf2aigSize);
  }
  ddm->cnf.cnf2aig[id] = bAig_NULL;
  ddm->cnf.cnfActive[id] = (unsigned char)0;

  return (id);
}






/**Function********************************************************************
  Synopsis    [call external SAT solver]
  Description [call external SAT solver]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
satDiffSolve
(
  char *filename
)
{
  char   cstring[200];

  sprintf(cstring, "(time zchaff-lemmas %s.cnf %s.chk %s.res) >& %s.sat>&1",
    filename, filename, filename, filename);
  system (cstring);

  sprintf(cstring, "rm %s.sat", filename);
  system(cstring);
}



/**Function********************************************************************
  Synopsis    [call external SAT solver]
  Description [call external SAT solver]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int *
satSolve0
(
  char *filename,
  int *satP,
  int timeLimit
)
{
  char   cstring[200];
  int sat=0, lit;
  int *cex = NULL;
  FILE *fp;

  if (timeLimit > 0) {
    sprintf(cstring, "/home/cabodi/bin/solver.sh %s.cnf %s.sat",
       filename, timeLimit, filename);
  }
  else {
    sprintf(cstring, "/home/cabodi/bin/solver.sh %s.cnf %s.sat", filename, filename);
  }
  system (cstring);

  sprintf(cstring, "%s.sat", filename);
  fp = fopen(cstring, "r");
  if (fp == NULL) {
    printf("error parsing sat result\n");
  }
  else {
    while (fgets(cstring, 199, fp)!=NULL)
    {
      if (strstr(cstring, "ABORT")) {
	 sat = -1;
  	 break;
      }
      if (strstr(cstring, "UNSAT")) {
  	 break;
      }
      else if (strstr(cstring, "SATISFIABLE")) {
	int i=0, len=1000;
        sat = 1;
        cex = Pdtutil_Alloc(int,len);
	while (fscanf(fp,"%d", &lit)==1) {
	  if (i+1 >= len) {
            len *= 2;
            cex = Pdtutil_Realloc(int,cex,len);
	  }
	  cex[i++] = lit;
	}
	cex[i] = 0;
	break;
      }
    }
    fclose(fp);
  }
  sprintf(cstring, "rm %s.sat", filename);
  system(cstring);

  *satP = sat;
  return cex;

}

/**Function********************************************************************
  Synopsis    [call external SAT solver]
  Description [call external SAT solver]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int *
satSolve
(
  char *filename,
  int *satP,
  int timeLimit
)
{
  int *cex;
  char *filename_ext = Pdtutil_Alloc(char, strlen(filename)+5);
  sprintf(filename_ext,"%s.cnf",filename);
  // StQ 2010.07.07
  //  fprintf(stderr, "Error: Zchaff Call!\n");
  //  exit (1);
  //cex = callZchaff(filename_ext,timeLimit,satP);
  cex = satSolve0(filename,satP,timeLimit);
#if 0
  cex1 = satSolve0(filename,&sat1,timeLimit);
  Pdtutil_Assert(*satP == sat1,"error calling linked Zchaff");
  if (0&&cex != NULL) {
    for (i=0;cex1[i]!=0;i++) {
      Pdtutil_Assert(cex[i] == cex1[i],"error calling linked Zchaff");
    }
    Pdtutil_Assert(cex[i] == 0,"error calling linked Zchaff");
    Pdtutil_Free(cex1);
  }
#endif
  Pdtutil_Free(filename_ext);
  return cex;
}

/**Function********************************************************************
  Synopsis    [call external SAT solver]
  Description [call external SAT solver]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int *
satSolveBerkmin
(
  char *filename,
  int *satP,
  int timeLimit
)
{
  char   cstring[200];
  int sat=-1, lit;
  int *cex = NULL;
  FILE *fp;

  if (timeLimit > 0) {
    /* sprintf(cstring, "(time berkmin %s.cnf s 1 t %d) >& %s.sat>&1",*/
    sprintf(cstring, "(time berkmin %s.cnf t %d) >& %s.sat>&1",
       filename, timeLimit, filename);
  }
  else {
    sprintf(cstring, "(time berkmin %s.cnf s 1) >& %s.sat>&1",
      filename, filename);
  }
  system (cstring);

  sprintf(cstring, "%s.sat", filename);
  fp = fopen(cstring, "r");
  if (fp == NULL) {
    printf("error parsing sat result\n");
  }
  else {
    while (fgets(cstring, 199, fp)!=NULL)
    {
      if (strstr(cstring, "exceeded")) {
	 sat = -1;
  	 break;
      }
      if (strstr(cstring, "UNSAT")) {
	 sat = 0;
  	 break;
      }
      else if (strstr(cstring, "Satisfiable")) {
	int i=0, len=1000;
	char dummyStr1[20], dummyStr2[20];
        sat = 1;
        cex = Pdtutil_Alloc(int,len);
        fgets(cstring, 199, fp);
	if (fscanf(fp,"%s%s", dummyStr1, dummyStr2) != 2) {
	  printf("error processing Berkmin cex");
	}
	while (fscanf(fp,"%d", &lit)==1) {
	  if (i+1 >= len) {
            len *= 2;
            cex = Pdtutil_Realloc(int,cex,len);
	  }
	  cex[i++] = lit;
	}
	cex[i] = 0;
	break;
      }
    }
    fclose(fp);
  }
  sprintf(cstring, "rm %s.sat", filename);
  system(cstring);

  *satP = sat;
  return cex;

}


/**Function********************************************************************
  Synopsis    [call external SAT solver]
  Description [call external SAT solver]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int *
satSolveCircuit
(
  char *filename,
  int *satP,
  int timeLimit
)
{
  char   cstring[200];
  int sat=-1;
  int *cex = NULL;
  FILE *fp;

  if (timeLimit > 0) {
    sprintf(cstring, "(time csolve -e -b -t %d %s.bench) >& %s.sat>&1",
       timeLimit, filename, filename);
  }
  else {
    sprintf(cstring,"(time csolve -e -b %s.bench) >& %s.sat>&1", filename, filename);
  }
  system (cstring);

  sprintf(cstring, "%s.sat", filename);
  fp = fopen(cstring, "r");
  if (fp == NULL) {
    printf("error parsing sat result\n");
  }
  else {
    while (fgets(cstring, 199, fp)!=NULL)
    {
      if (strstr(cstring, "ABORT")) {
        sat = -1;
        break;
      }
      if (strstr(cstring, "unsatisfiable")) {
	sat = 0;
  	break;
      }
      else if (strstr(cstring, "satisfiable")) {
	int i=0, len=1000;
        sat = 1;
        cex = Pdtutil_Alloc(int,len);
#if 0
	while (fscanf(fp,"%d", &lit)==1) {
	  if (i+1 >= len) {
            len *= 2;
            cex = Pdtutil_Realloc(int,cex,len);
	  }
	  cex[i++] = lit;
	}
	cex[i] = 0;
#else
	  cex[i++] = 0;
#endif
	break;
      }
    }
    fclose(fp);
  }
  sprintf(cstring, "rm %s.sat", filename);
  system(cstring);

  *satP = sat;
  return cex;

}

/**Function********************************************************************
  Synopsis    [call external SAT solver]
  Description [call external SAT solver]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
satDiffSolve0
(
  char *filename
)
{
  char   cstring[200];
  int *cex, *checks, nChecks, i, nDiff;
  int sat=0;
  FILE *fp, *fp2;

  sprintf(cstring, "%s.chk", filename);
  fp = fopen(cstring, "r");
  if (fp == NULL) {
    printf("error reading checks\n");
  }
  fscanf(fp,"%d",&nChecks);
  checks = Pdtutil_Alloc(int,nChecks);
  for (i=0; i<nChecks; i++) {
    fscanf(fp,"%d",&checks[i]);
  }
  fclose(fp);

  nDiff = 0;
  for (i=0; i<nChecks; i++) {
    sprintf(cstring, "%s.cnf", filename);
    fp = fopen(cstring, "r");
    sprintf(cstring, "%s-2.cnf", filename);
    fp2 = fopen(cstring, "w");
    while (fgets(cstring,199,fp)!=NULL) {
      int nv, nc;
      if (sscanf(cstring,"p cnf %d %d", &nv, &nc) == 2) {
        fprintf(fp2, "p cnf %d %d\n", nv, nc+1);
      }
      else {
        fprintf(fp2, "%s", cstring);
      }
    }
    fprintf(fp2, "%d\n", checks[i]);
    fclose(fp);
    fclose(fp2);

    sprintf(cstring, "%s-2", filename);
    cex = satSolve(cstring, &sat, -1);
    if (!sat) {
      checks[i] = 0;
    }
    else {
      nDiff++;
    }
    Pdtutil_Free(cex);
    sprintf(cstring, "rm %s-2.cnf", filename);
    system(cstring);
  }

  sprintf(cstring, "%s.res", filename);
  fp = fopen(cstring, "w");
  if (fp == NULL) {
    printf("error parsing sat result\n");
  }
  fprintf(fp,"%d\n",nDiff);
  for (i=0; i<nChecks; i++) {
    if (checks[i] != 0) {
      fprintf(fp,"%d\n",checks[i]);
    }
  }
  fclose(fp);

}






/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
AigSatDiffTot
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  bAigEdge_t careBaig,
  int mergeDirection,
  int mergeCompl,
  int cacheEnable
)
{
  int clauseN, varMax, i, n;
  int *compareLit, nCompare;
  fpos_t posFile;
  FILE *fp;
  bAig_Manager_t *manager = ddm->aig.mgr;

#if 0
  bAigEdge_t f0, f1;
  f0 = bAig_AuxAig0(ddm->aig.mgr,baig);
  f1 = bAig_AuxAig1(ddm->aig.mgr,baig);
  Pdtutil_Assert (f0 != f1, "Checking diff of equal AIGs");

  if (bAig_NodeIsConstant(f0) || bAig_NodeIsConstant(f1)) {
    /* constant term, no SAT required */
  }
#endif

  fp = fopen ("satDiffCheck.cnf","w");
  if (fp == NULL) {
    fprintf(dMgrO(ddm),"error parsing sat result\n");
    return;
  }

  fgetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", 0, 0);
  clauseN = 0;
  varMax = -1;
  aig2CnfIdInit(ddm);

  compareLit = Pdtutil_Alloc(int,visitedNodes->num);
  nCompare = existDiffCnfStoreIntern(ddm,visitedNodes,careBaig,
                compareLit,fp,&clauseN,&varMax,mergeCompl,cacheEnable);

  if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
    int careCnf = bAig_NodeIsInverted(careBaig) ?
        -aig2CnfId(manager,careBaig) : aig2CnfId(manager,careBaig);
    fprintf(fp, "%d 0\n", careCnf);
    clauseN += 1;
    aig2CnfIntern(ddm,careBaig,fp,&clauseN, &varMax);
  }

  fsetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", varMax, clauseN);
  fclose (fp);

  if (nCompare > 0) {

    ddm->stats.aig.n_check_2 += nCompare;
    ddm->stats.aig.n_merge_2 += nCompare;

    fp = fopen ("satDiffCheck.chk","w");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return;
    }
    fprintf(fp,"%d\n",nCompare);
    for (i=n=0;i<visitedNodes->num; i++) {
      if (compareLit[i] != 0) {
        fprintf(fp,"%d\n",compareLit[i]);
        n++;
      }
    }
    Pdtutil_Assert(nCompare==n,"invalid num of compare points");
    fclose(fp);
#if 1
    satDiffSolve((char *)"satDiffCheck");
#endif
#if 1
    system("rm satDiffCheck.cnf");
    system("rm satDiffCheck.chk");
#endif
    fp = fopen ("satDiffCheck.res","r");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return;
    }
    fscanf(fp,"%d",&n);
    Pdtutil_Assert(nCompare==n,"invalid num of compare points in res file");
    for (i=0;i<visitedNodes->num; i++) {
      int diff;
      if (compareLit[i] != 0) {
        fscanf(fp,"%d",&diff);
        n--;
        ddm->stats.aig.n_merge_2 -= !diff;
        /* -1: diff - >0: const - 0: not checked */
	compareLit[i] = diff ? -1 : 1;
      }
    }
    Pdtutil_Assert(n==0,"invalid num of compare points in res file");
    fclose(fp);
    system("rm satDiffCheck.res");

    existDiffMergeIntern(ddm,visitedNodes,careBaig,compareLit,
      mergeDirection,mergeCompl,cacheEnable);

    Pdtutil_Free(compareLit);

  }
  else {
    existDiffClearCnfIntern(ddm,visitedNodes);
  }
  if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
    aig2CnfClearVisitedIntern(manager,careBaig);
  }

}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
AigSatRedCheck
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  bAigEdge_t careBaig,
  int constVal
)
{
  int clauseN, varMax, i, n, nRed;
  int *compareLit, nCompare;
  fpos_t posFile;
  FILE *fp;
  bAig_Manager_t *manager = ddm->aig.mgr;

  nRed = 0;

  fp = fopen ("satRedCheck.cnf","w");
  if (fp == NULL) {
    fprintf(dMgrO(ddm),"error parsing sat result\n");
    return 0;
  }

  fgetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", 0, 0);
  clauseN = 0;
  varMax = -1;
  aig2CnfIdInit(ddm);

  compareLit = Pdtutil_Alloc(int,visitedNodes->num);
  nCompare = redCnfStoreIntern(ddm,visitedNodes,careBaig,
                compareLit,fp,&clauseN,&varMax,constVal);

  if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
    int careCnf = bAig_NodeIsInverted(careBaig) ?
        -aig2CnfId(manager,careBaig) : aig2CnfId(manager,careBaig);
    fprintf(fp, "%d 0\n", careCnf);
    clauseN += 1;
    aig2CnfIntern(ddm,careBaig,fp,&clauseN, &varMax);
  }

  fsetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", varMax, clauseN);
  fclose (fp);

  existDiffClearCnfIntern(ddm,visitedNodes);

  if (nCompare > 0) {

    ddm->stats.aig.n_check_2 += nCompare;
    ddm->stats.aig.n_merge_2 += nCompare;

    fp = fopen ("satRedCheck.chk","w");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return 0;
    }
    fprintf(fp,"%d\n",nCompare);
    for (i=n=0;i<visitedNodes->num; i++) {
      if (compareLit[i] != 0) {
        fprintf(fp,"%d\n",compareLit[i]);
        n++;
      }
    }
    Pdtutil_Assert(nCompare==n,"invalid num of compare points");
    fclose(fp);
#if 1
    satDiffSolve((char *)"satRedCheck");
#endif
#if 1
    system("rm satRedCheck.cnf");
    system("rm satRedCheck.chk");
#endif
    fp = fopen ("satRedCheck.res","r");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return 0;
    }
    fscanf(fp,"%d",&n);
    Pdtutil_Assert(nCompare==n,"invalid num of compare points in res file");
    for (i=0;i<visitedNodes->num; i++) {
      if (compareLit[i] != 0) {
        int diff;
        fscanf(fp,"%d",&diff);
        n--;
        ddm->stats.aig.n_merge_2 -= !diff;
        /* -1: diff - >0: const - 0: not checked */
	compareLit[i] = diff ? -1 : 1;
      }
    }
    Pdtutil_Assert(n==0,"invalid num of compare points in res file");
    fclose(fp);
    system("rm satRedCheck.res");

    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      if (bAig_NodeIsConstant(baig)) { // was (f1), but f1 NOT assigned!
	Pdtutil_Assert(compareLit[i]==0,"Checked const node");
        continue;
      }
      if (compareLit[i] > 0) {
	nRed++;
        bAig_AuxAig1(manager,baig) = constVal ? bAig_One : bAig_Zero;
      }
      else {
        bAigNodeComputeAuxVal(manager,baig,1);
      }
    }
  }
  Pdtutil_Free(compareLit);

  if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
    aig2CnfClearVisitedIntern(manager,careBaig);
  }
  return nRed;

}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
AigSatRedEqCheck
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  bAigEdge_t careBaig,
  int **compareLitArray,
  int eqPhase
)
{
  int clauseN, varMax, i, j, n, nRed;
  int nCompare;
  fpos_t posFile;
  FILE *fp;
  bAig_Manager_t *manager = ddm->aig.mgr;

  nRed = 0;

  fp = fopen ("satRedCheck.cnf","w");
  if (fp == NULL) {
    fprintf(dMgrO(ddm),"error parsing sat result\n");
    return 0;
  }

  fgetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", 0, 0);
  clauseN = 0;
  varMax = -1;
  aig2CnfIdInit(ddm);

  nCompare = redEqCnfStoreIntern(ddm,visitedNodes,careBaig,
                compareLitArray,fp,&clauseN,&varMax,eqPhase);

  if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
    int careCnf = bAig_NodeIsInverted(careBaig) ?
        -aig2CnfId(manager,careBaig) : aig2CnfId(manager,careBaig);
    fprintf(fp, "%d 0\n", careCnf);
    clauseN += 1;
    aig2CnfIntern(ddm,careBaig,fp,&clauseN, &varMax);
  }

  fsetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", varMax, clauseN);
  fclose (fp);

  existDiffClearCnfIntern(ddm,visitedNodes);

  if (nCompare > 0) {

    ddm->stats.aig.n_check_2 += nCompare;
    ddm->stats.aig.n_merge_2 += nCompare;

    fp = fopen ("satRedCheck.chk","w");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return 0;
    }
    fprintf(fp,"%d\n",nCompare);
    n = visitedNodes->num;
    for (i=0;i<visitedNodes->num; i++) {
      if (compareLitArray[i] != NULL) {
        for (j=0;compareLitArray[i][j]>=0; j+=2) {
          fprintf(fp,"%d\n",compareLitArray[i][j+1]);
          nCompare--;
	}
      }
    }
    Pdtutil_Assert(nCompare==0,"invalid num of compare points");
    fclose(fp);

    if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
      aig2CnfClearVisitedIntern(manager,careBaig);
    }

#if 1
    satDiffSolve((char *)"satRedCheck");
#endif
#if 1
    system("rm satRedCheck.cnf");
    system("rm satRedCheck.chk");
#endif
    fp = fopen ("satRedCheck.res","r");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return 0;
    }
    fscanf(fp,"%d",&nCompare);

    n = visitedNodes->num;
    for (i=0;i<visitedNodes->num; i++) {
      bAigEdge_t baig_i = visitedNodes->nodes[i];
      int merged = 0;
      if (compareLitArray[i] != NULL) {
        for (j=0;compareLitArray[i][j]>=0; j+=2) {
          int diff;
          fscanf(fp,"%d",&diff);
          nCompare--;
  	  compareLitArray[i][j+1] = diff ? -1 : 1;
          ddm->stats.aig.n_merge_2 -= !diff;
	  if (!diff && !merged) {
            bAigEdge_t baig_j = visitedNodes->nodes[compareLitArray[i][j]];
   	    nRed++;
	    if (0)
	    {
              bAigEdge_t a = bAig_And(manager,careBaig,
                bAig_Xor(manager,bAig_AuxAig1(manager,baig_i),
			      bAig_AuxAig1(manager,baig_j)));
              Ddi_Bdd_t *checkAig = Ddi_BddMakeFromBaig(ddm,a);
              Pdtutil_Assert(!Ddi_AigSat(checkAig),"invalid merge");
              Ddi_Free(checkAig);
	    }
            bAig_RecursiveDeref(manager,bAig_AuxAig1(manager,baig_i));
            bAig_AuxAig1(manager,baig_i) =
              eqPhase ? bAig_AuxAig1(manager,baig_j) :
	        bAig_Not(bAig_AuxAig1(manager,baig_j));
	    merged = 1;
	  }
	}
      }
      if (!merged) {
        bAigNodeComputeAuxVal(manager,baig_i,1);
      }
      bAig_Ref(manager, bAig_AuxAig1(manager,baig_i));
    }
    Pdtutil_Assert(nCompare==0,"invalid num of compare points in res file");

    fclose(fp);
    system("rm satRedCheck.res");

  }
  else if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
    aig2CnfClearVisitedIntern(manager,careBaig);
  }

  return nRed;

}

#if 0
/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
AigSatRedEqCheckMinisat
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  bAigEdge_t careBaig,
  int **compareLitArray,
  int eqPhase
)
{
  int clauseN, varMax, f0Cnf, f1Cnf, sat, f1Const, i, j, n, nRed;
  int nCompare;
  bAigEdge_t f0, f1;
  fpos_t posFile;
  FILE *fp;
  bAig_Manager_t *manager = ddm->aig.mgr;

  nRed = 0;

  fp = fopen ("satRedCheck.cnf","w");
  if (fp == NULL) {
    fprintf(dMgrO(ddm),"error parsing sat result\n");
    return 0;
  }

  fgetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", 0, 0);
  clauseN = 0;
  varMax = -1;
  aig2CnfIdInit(ddm);

  nCompare = redEqCnfStoreIntern(ddm,visitedNodes,careBaig,
                compareLitArray,fp,&clauseN,&varMax,eqPhase);


  for (i=0; i<aigNodes->num; i++) {
    int j;
    bAigEdge_t f_i, baig = aigNodes->nodes[i];

    f_i = bAig_AuxAig1(manager,baig);
    Pdtutil_Assert(f_i!=bAig_NULL,"NULL aux aig found");

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if (bAig_NodeIsConstant(f_i)) {
      continue;
    }

    if (compareLitArray[i] != NULL) {
      MinisatClauses(S,f_i,NULL,NULL,1);

      for (j=0;compareLitArray[i][j]>=0; j+=2) {
        bAigEdge_t baig_j = aigNodes->nodes[compareLitArray[i][j]];

        /* store CNF clauses of val function */

        f_j = bAig_AuxAig1(manager,baig_j);

        fiCnf = aig2CnfId(manager,f_i);
        fjCnf = aig2CnfId(manager,f_j);

        nCompare++;

        /* generate comparison clauses */
        /* nex var representing comparison (Xor) */
        vXor = aig2CnfNewIdIntern(ddm);
        compareLitArray[i][j+1] = vXor;
        /* v=(fi!=fj) --> (v+fi+!fj)(v+!fi+fj)(!v+fi+fj)(!v+!fi+!fj) */

        while (abs(vXor) > S.nVars()) S.newVar();

        /* vXor fiCnf -fjCnf */
        MinisatClause3(S,lits,vXor,fiCnf,-fjCnf);
        /* vXor -fiCnf fjCnf */
        MinisatClause3(S,lits,vXor,-fiCnf,fjCnf);
        /* -vXor fiCnf fjCnf */
        MinisatClause3(S,lits,-vXor,fiCnf,fjCnf);
        /* -vXor -fiCnf -fjCnf */
        MinisatClause3(S,lits,-vXor,-fiCnf,-fjCnf);

      }
    }
  }

  if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
    int careCnf = bAig_NodeIsInverted(careBaig) ?
        -aig2CnfId(manager,careBaig) : aig2CnfId(manager,careBaig);
    fprintf(fp, "%d 0\n", careCnf);
    clauseN += 1;
    aig2CnfIntern(ddm,careBaig,fp,&clauseN, &varMax);
  }

  fsetpos (fp, &posFile);
  fprintf(fp, "p cnf %9d %9d\n", varMax, clauseN);
  fclose (fp);

  existDiffClearCnfIntern(ddm,visitedNodes);

  if (nCompare > 0) {

    ddm->stats.aig.n_check_2 += nCompare;
    ddm->stats.aig.n_merge_2 += nCompare;

    fp = fopen ("satRedCheck.chk","w");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return 0;
    }
    fprintf(fp,"%d\n",nCompare);
    n = visitedNodes->num;
    for (i=0;i<visitedNodes->num; i++) {
      if (compareLitArray[i] != NULL) {
        for (j=0;compareLitArray[i][j]>=0; j+=2) {
          fprintf(fp,"%d\n",compareLitArray[i][j+1]);
          nCompare--;
	}
      }
    }
    Pdtutil_Assert(nCompare==0,"invalid num of compare points");
    fclose(fp);

    if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
      aig2CnfClearVisitedIntern(manager,careBaig);
    }

#if 1
    satDiffSolve("satRedCheck");
#endif
#if 1
    system("rm satRedCheck.cnf");
    system("rm satRedCheck.chk");
#endif
    fp = fopen ("satRedCheck.res","r");
    if (fp == NULL) {
      fprintf(dMgrO(ddm),"error parsing sat result\n");
      return 0;
    }
    fscanf(fp,"%d",&nCompare);

    n = visitedNodes->num;
    for (i=0;i<visitedNodes->num; i++) {
      bAigEdge_t baig_i = visitedNodes->nodes[i];
      int merged = 0;
      if (compareLitArray[i] != NULL) {
        for (j=0;compareLitArray[i][j]>=0; j+=2) {
          int diff;
          fscanf(fp,"%d",&diff);
          nCompare--;
  	  compareLitArray[i][j+1] = diff ? -1 : 1;
          ddm->settings.aig.n_merge_2 -= !diff;
	  if (!diff && !merged) {
            bAigEdge_t baig_j = visitedNodes->nodes[compareLitArray[i][j]];
   	    nRed++;
	    if (0)
	    {
              bAigEdge_t a = bAig_And(manager,careBaig,
                bAig_Xor(manager,bAig_AuxAig1(manager,baig_i),
			      bAig_AuxAig1(manager,baig_j)));
              Ddi_Bdd_t *checkAig = Ddi_BddMakeFromBaig(ddm,a);
              Pdtutil_Assert(!Ddi_AigSat(checkAig),"invalid merge");
              Ddi_Free(checkAig);
	    }
            bAig_RecursiveDeref(manager,bAig_AuxAig1(manager,baig_i));
            bAig_AuxAig1(manager,baig_i) =
              eqPhase ? bAig_AuxAig1(manager,baig_j) :
	        bAig_Not(bAig_AuxAig1(manager,baig_j));
	    merged = 1;
	  }
	}
      }
      if (!merged) {
        bAigNodeComputeAuxVal(manager,baig_i,1);
      }
      bAig_Ref(manager, bAig_AuxAig1(manager,baig_i));
    }
    Pdtutil_Assert(nCompare==0,"invalid num of compare points in res file");

    fclose(fp);
    system("rm satRedCheck.res");

  }
  else if (careBaig != bAig_NULL && !bAig_NodeIsConstant(careBaig)) {
    aig2CnfClearVisitedIntern(manager,careBaig);
  }

  return nRed;

}

#endif

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
AigSatOptMerge
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  bAigEdge_t careBaig,
  int doRedRem,
  int mergeDirection,
  Ddi_AigSignatureArray_t *cof0Sig,
  Ddi_AigSignatureArray_t *cof1Sig,
  Ddi_AigSignature_t *careSig
)
{
  int i, nc0, nm0;
  bAigEdge_t f0, f1;
  bAig_Manager_t *manager = ddm->aig.mgr;
  nc0 = ddm->stats.aig.n_check_1;
  nm0 = ddm->stats.aig.n_merge_1;
  i=0;
  if (0&&i<visitedNodes->num-100) {
    i = visitedNodes->num-100;
  }
  for (; i<visitedNodes->num; i++) {
#if 0
    int nn = manager->nodesArraySize;
#endif
    bAigEdge_t baig = visitedNodes->nodes[i];

    f0 = bAig_AuxAig0(manager,baig);
    f1 = bAig_AuxAig1(manager,baig);


    if (f0 != f1) {
      existOptMergeIntern(ddm,visitedNodes,i,mergeDirection,0,1,careBaig,NULL);
#if 1
      if (doRedRem) {
      f0 = bAig_AuxAig0(manager,baig);
      f1 = bAig_AuxAig1(manager,baig);
      if (f0 != f1) {
        Ddi_AigSignature_t sConst, *pCheck;
        DdiSetSignatureConstant(&sConst,1);
	pCheck = mergeDirection<0 ? &cof1Sig->sArray[i] : &cof0Sig->sArray[i];
        if (0&&DdiEqSignatures(&sConst,pCheck,careSig)) {
          existOptMergeIntern(ddm,
            visitedNodes,i,mergeDirection,1,1,careBaig,NULL);
	}
        f0 = bAig_AuxAig0(manager,baig);
        f1 = bAig_AuxAig1(manager,baig);
        if (f0 != f1) {
          DdiSetSignatureConstant(&sConst,0);
          if (0&&DdiEqSignatures(&sConst,pCheck,careSig)) {
            existOptMergeIntern(ddm,visitedNodes,
              i,mergeDirection,-1,1,careBaig,NULL);
	  }
          if (1&&f0 != f1) {
            existOptMergeIntern(ddm,visitedNodes,i,0,2,1,careBaig,NULL);
            f0 = bAig_AuxAig0(manager,baig);
            f1 = bAig_AuxAig1(manager,baig);
            if (f0 != f1) {
              existOptMergeIntern(ddm,
                visitedNodes,i,0,3,1,careBaig,NULL);
            }
	  }
        }
      }
      }
#endif
    }
#if 0
    fprintf(dMgrO(ddm),"|%d(+%d)|", manager->nodesArraySize,
                         manager->nodesArraySize - nn); fflush(dMgrO(ddm));
#endif
  }

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"{%d/%d}", ddm->stats.aig.n_merge_1-nm0,
	 ddm->stats.aig.n_check_1-nc0); fflush(dMgrO(ddm));
  }

}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
existOptMergeIntern
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  int refI,
  int mergeDirection,
  int constRedundancy,
  int useCofactorCare,
  bAigEdge_t careBaig,
  Ddi_AigSignatureArray_t *varSigs
)
{
  int i, reComp0, reComp1, doProp;
  bAigEdge_t f0, f1, f01, f0Old, f1Old, f01Old;
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAigEdge_t right, left, r0, r1, l0, l1;
  int nSave0, nSave1, okMerge, doAbort = 0, enAbort = 0;
  bAigEdge_t baig;
  bAigEdge_t *saveEval0 = Pdtutil_Alloc(bAigEdge_t, visitedNodes->num-refI);
  bAigEdge_t *saveIds0 = Pdtutil_Alloc(bAigEdge_t, visitedNodes->num-refI);
  bAigEdge_t *saveEval1 = Pdtutil_Alloc(bAigEdge_t, visitedNodes->num-refI);
  bAigEdge_t *saveIds1 = Pdtutil_Alloc(bAigEdge_t, visitedNodes->num-refI);

  /* merge direction < 0: merge to 0 - recompute 1 */
  /* merge direction == 0: no merge - recompute 0 and 1 */
  /* merge direction > 0: merge to 1 - recompute 0 */
  reComp0 = mergeDirection >= 0;
  reComp1 = mergeDirection <= 0;

  /* try merge refNode */
  nSave0 = nSave1 = 0;
  baig = visitedNodes->nodes[refI];
  f0 = bAig_AuxAig0(manager,baig);
  f1 = bAig_AuxAig1(manager,baig);
  /*Pdtutil_Assert(f0!=f1,"starting opt from merged AIG node");*/
  if (constRedundancy == 1) {
    if (mergeDirection<0) {
      f1 = constRedundancy > 0 ? bAig_One : bAig_Zero;
    }
    else {
      f0 = constRedundancy > 0 ? bAig_One : bAig_Zero;
    }
  }
  else if (mergeDirection==0 && constRedundancy == 2 /* OR */) {
    /* move cofactor */
    f0 = f1 = bAig_Or(manager,f0,f1);
  }
  else if (mergeDirection==0 && constRedundancy == -2 /* OR */) {
    /* move cofactor */
    f1 = bAig_Zero;
    f0 = bAig_Or(manager,f0,f1);
  }
  else if (mergeDirection==0 && constRedundancy == 3 /* AND */) {
    /* move cofactor */
    f0 = f1 = bAig_And(manager,f0,f1);
  }
  else if (mergeDirection==0 && constRedundancy == -3 /* OR */) {
    /* move cofactor */
    f1 = bAig_One;
    f0 = bAig_And(manager,f0,f1);
  }
  else {
    if (mergeDirection<0) {
      f1 = f0;
    }
    else {
      f0 = f1;
    }
  }
  doProp = 0;
  if (reComp1) {
    doProp = doProp || (bAig_AuxAig1(manager,baig) != f1);
    saveIds1[nSave1] = baig;
    saveEval1[nSave1++] = bAig_AuxAig1(manager,baig);
    bAig_AuxAig1(manager,baig) = f1;
    bAig_Ref(manager, f1);
  }
  if (reComp0) {
    doProp = doProp || (bAig_AuxAig0(manager,baig) != f0);
    saveIds0[nSave0] = baig;
    saveEval0[nSave0++] = bAig_AuxAig0(manager,baig);
    bAig_AuxAig0(manager,baig) = f0;
    bAig_Ref(manager, f0);
  }

  okMerge = 0;

  if (doProp) {

  nodeSetVisited(manager,baig);

  for (i=refI+1; i<visitedNodes->num; i++) {
    baig = visitedNodes->nodes[i];
    Pdtutil_Assert(baig<manager->nodesArraySize,"AIG node is too large");
    if (!bAig_isVarNode(manager,baig)) {
      int eq;
      f0 = bAig_AuxAig0(manager,baig);
      f1 = bAig_AuxAig1(manager,baig);
      eq = (f0 == f1);
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      if (nodeVisited(manager,right) || nodeVisited(manager,left)) {
        /* compute node */
        if (reComp1) {
          /* re-compute 1 */
	  Pdtutil_Assert(bAig_AuxAig1(manager,right) != bAig_NULL, "NULL AIG");
	  Pdtutil_Assert(bAig_AuxAig1(manager,left) != bAig_NULL, "NULL AIG");
          r1 = bAig_NodeIsInverted(right) ?
           bAig_Not(bAig_AuxAig1(manager,right)) : bAig_AuxAig1(manager,right);
          l1 = bAig_NodeIsInverted(left) ?
           bAig_Not(bAig_AuxAig1(manager,left)) : bAig_AuxAig1(manager,left);
          f1 = bAig_And(manager,r1,l1);
	  if (f1 != bAig_AuxAig1(manager,baig)) {
            saveIds1[nSave1] = baig;
            saveEval1[nSave1++] = bAig_AuxAig1(manager,baig);
            bAig_AuxAig1(manager,baig) = f1;
            bAig_Ref(manager, f1);
            nodeSetVisited(manager,baig);
	  }
	}
        if (reComp0) {
          /* re-compute 0 */
	  Pdtutil_Assert(bAig_AuxAig0(manager,right) != bAig_NULL, "NULL AIG");
	  Pdtutil_Assert(bAig_AuxAig0(manager,left) != bAig_NULL, "NULL AIG");
          r0 = bAig_NodeIsInverted(right) ?
           bAig_Not(bAig_AuxAig0(manager,right)) : bAig_AuxAig0(manager,right);
          l0 = bAig_NodeIsInverted(left) ?
           bAig_Not(bAig_AuxAig0(manager,left)) : bAig_AuxAig0(manager,left);
          f0 = bAig_And(manager,r0,l0);
	  if (f0 != bAig_AuxAig0(manager,baig)) {
            saveIds0[nSave0] = baig;
            saveEval0[nSave0++] = bAig_AuxAig0(manager,baig);
            bAig_AuxAig0(manager,baig) = f0;
            bAig_Ref(manager, f0);
            nodeSetVisited(manager,baig);
	  }
	}
	if (!(constRedundancy==1) && eq && (f0 != f1)) {
	  doAbort = 1;
	  break;
	}
      }
    }

  }

  /* check output */
  baig = visitedNodes->nodes[visitedNodes->num-1];
  if (!doAbort && nodeVisited(manager,baig)) {
    bAigEdge_t check;
    Ddi_Bdd_t *checkAig;
    f0 = bAig_AuxAig0(manager,baig);
    f1 = bAig_AuxAig1(manager,baig);
    if (nSave0>0 && saveIds0[nSave0-1] == baig) {
      f0Old = saveEval0[nSave0-1];
    }
    else {
      f0Old = f0;
    }
    if (nSave1>0 && saveIds1[nSave1-1] == baig) {
      f1Old = saveEval1[nSave1-1];
    }
    else {
      f1Old = f1;
    }

    if (bAig_NodeIsInverted(baig)) {
      f0Old = bAig_Not(f0Old);
      f1Old = bAig_Not(f1Old);
      f0 = bAig_Not(f0);
      f1 = bAig_Not(f1);
    }

    if (mergeDirection<0) {
      if (f1 == f1Old) {
	/* merge not observable. OK ! */
	okMerge = 1;
      }
      else {
	/* check observability */
	if (useCofactorCare)
          check = bAig_And(manager,bAig_Not(f0),bAig_Xor(manager,f1,f1Old));
        else
          check = bAig_Xor(manager,f1,f1Old);
        checkAig = Ddi_BddMakeFromBaig(ddm,bAig_And(manager,check,careBaig));
#if 0
        okMerge = (Ddi_AigSatWithAbort(checkAig,
          ddm->settings.aig.satTimeLimit1) == 0);
#else
	if (varSigs != NULL)
        {
          Ddi_Bdd_t *cexAig = Ddi_AigSatWithCex(checkAig);
	  okMerge = 1;
	  if (cexAig != NULL) {
	    Ddi_BddSetMono(cexAig);
            DdiUpdateVarSignature(varSigs, cexAig);
            Ddi_Free(cexAig);
	    okMerge = 0;
	  }
	}
	else {
          okMerge = (Ddi_AigSatWithAbort(checkAig,
            ddm->settings.aig.satTimeLimit1) == 0);
	}
#endif
        Ddi_Free(checkAig);
      }
      if (enAbort&&okMerge) {
	/* check size */
	int sizeOld, sizeNew;
        sizeNew = myNodeCountIntern(manager,f1);
        myNodeClearVisitedIntern(manager,f1);
        sizeOld = myNodeCountIntern(manager,f1Old);
        myNodeClearVisitedIntern(manager,f1Old);
	okMerge = sizeOld >= sizeNew;
      }
    }
    else if (mergeDirection<0) {
      if (f0 == f0Old) {
	/* merge not observable. OK ! */
	okMerge = 1;
      }
      else {
	/* check observability */
	if (useCofactorCare)
          check = bAig_And(manager,bAig_Not(f1),bAig_Xor(manager,f0,f0Old));
        else
          check = bAig_Xor(manager,f0,f0Old);
        checkAig = Ddi_BddMakeFromBaig(ddm,bAig_And(manager,check,careBaig));
        okMerge = (Ddi_AigSatWithAbort(checkAig,
          ddm->settings.aig.satTimeLimit1) == 0);
#if 0
        okMerge = (Ddi_AigSatWithAbort(checkAig,
          ddm->settings.aig.satTimeLimit1) == 0);
#else
	if (varSigs != NULL)
        {
          Ddi_Bdd_t *cexAig = Ddi_AigSatWithCex(checkAig);
	  okMerge = 1;
	  if (cexAig != NULL) {
	    Ddi_BddSetMono(cexAig);
            DdiUpdateVarSignature(varSigs, cexAig);
            Ddi_Free(cexAig);
	    okMerge = 0;
	  }
	}
	else {
          okMerge = (Ddi_AigSatWithAbort(checkAig,
            ddm->settings.aig.satTimeLimit1) == 0);
	}
#endif
        Ddi_Free(checkAig);
      }
      if (enAbort&&okMerge) {
	/* check size */
	int sizeOld, sizeNew;
        sizeNew = myNodeCountIntern(manager,f0);
        myNodeClearVisitedIntern(manager,f0);
        sizeOld = myNodeCountIntern(manager,f0Old);
        myNodeClearVisitedIntern(manager,f0Old);
	okMerge = sizeOld >= sizeNew;
      }
    }
    else {
      f01 = bAig_Or(manager,f0,f1);
      f01Old = bAig_Or(manager,f0Old,f1Old);
      bAig_Ref(manager, f01);
      bAig_Ref(manager, f01Old);
      if (f01 == f01Old) {
	/* transformation not observable. OK ! */
	okMerge = 1;
      }
      else {
	/* check observability */
        check = bAig_Xor(manager,f01,f01Old);
        checkAig = Ddi_BddMakeFromBaig(ddm,bAig_And(manager,check,careBaig));
        okMerge = (Ddi_AigSatWithAbort(checkAig,
          ddm->settings.aig.satTimeLimit1) == 0);
        Ddi_Free(checkAig);
      }
      if (enAbort&&okMerge) {
	/* check size */
	int sizeOld, sizeNew;
        sizeNew = myNodeCountIntern(manager,f01);
        myNodeClearVisitedIntern(manager,f01);
        sizeOld = myNodeCountIntern(manager,f01Old);
        myNodeClearVisitedIntern(manager,f01Old);
	okMerge = sizeOld >= sizeNew;
      }
      bAig_RecursiveDeref(manager,f01);
      bAig_RecursiveDeref(manager,f01Old);
    }
  }
  if (!doAbort)
    ddm->stats.aig.n_check_1++;
  }

  if (doAbort || !okMerge) {
    while(--nSave0 >= 0) {
      baig = saveIds0[nSave0];
      Pdtutil_Assert(saveEval0[nSave0] != bAig_NULL, "NULL AIG");
      bAig_RecursiveDeref(manager, bAig_AuxAig0(manager,baig));
      bAig_AuxAig0(manager,baig) = saveEval0[nSave0];
      nodeClearVisited(manager,baig);
    }
    while(--nSave1 >= 0) {
      baig = saveIds1[nSave1];
      Pdtutil_Assert(saveEval1[nSave1] != bAig_NULL, "NULL AIG");
      bAig_RecursiveDeref(manager, bAig_AuxAig1(manager,baig));
      bAig_AuxAig1(manager,baig) = saveEval1[nSave1];
      nodeClearVisited(manager,baig);
    }
  }
  else {
    ddm->stats.aig.n_merge_1++;
    while(--nSave0 >= 0) {
      baig = saveIds0[nSave0];
      nodeClearVisited(manager,baig);
      baig = saveEval0[nSave0];
      Pdtutil_Assert(baig>=0&&baig<manager->nodesArraySize,
        "wrong node in save array");
      bAig_RecursiveDeref(manager,baig);
    }
    while(--nSave1 >= 0) {
      baig = saveIds1[nSave1];
      nodeClearVisited(manager,baig);
      baig = saveEval1[nSave1];
      Pdtutil_Assert(baig>=0&&baig<manager->nodesArraySize,
        "wrong node in save array");
      bAig_RecursiveDeref(manager,baig);
    }
  }


  Pdtutil_Free(saveEval0);
  Pdtutil_Free(saveIds0);
  Pdtutil_Free(saveEval1);
  Pdtutil_Free(saveIds1);

  if (!doProp)
    return(-1);
  else
    return (okMerge);
}


/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
existDiffEvalIntern
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  bAigEdge_t careBaig,
  int cacheEnable
)
{
  bAigEdge_t f0, f1;
  bAig_Manager_t *manager = ddm->aig.mgr;
  int i;
  bAigEdge_t right, left, r0, r1, l0, l1, cachedEntry;
  int cachedMerge;

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];

    f0 = bAig_AuxAig0(manager,baig);
    f1 = bAig_AuxAig1(manager,baig);

    if (f0 == bAig_NULL) {
      if (bAig_NodeIsConstant(baig) || bAig_isVarNode(manager,baig)) {
        f0 = f1 = bAig_NonInvertedEdge(baig);
      }
      else {
        right = bAig_NodeReadIndexOfRightChild(manager,baig);
        left = bAig_NodeReadIndexOfLeftChild(manager,baig);
        /* compute node */
        r0 = bAig_NodeIsInverted(right) ?
           bAig_Not(bAig_AuxAig0(manager,right)) : bAig_AuxAig0(manager,right);
        r1 = bAig_NodeIsInverted(right) ?
           bAig_Not(bAig_AuxAig1(manager,right)) : bAig_AuxAig1(manager,right);
        l0 = bAig_NodeIsInverted(left) ?
           bAig_Not(bAig_AuxAig0(manager,left)) : bAig_AuxAig0(manager,left);
        l1 = bAig_NodeIsInverted(left) ?
           bAig_Not(bAig_AuxAig1(manager,left)) : bAig_AuxAig1(manager,left);
        f0 = bAig_And(manager,r0,l0);
        f1 = bAig_And(manager,r1,l1);
      }

      if (f0 != f1 && cacheEnable) {
        /* check cache */
	ddm->stats.aig.n_check_3++;
        cachedMerge = bAigMergeCacheRead(manager,f0,f1,&cachedEntry);
        if (cachedEntry != bAig_NULL && cachedMerge) {
          /* do merge */
          if (cachedMerge == 1) {
            f1 = f0;
          }
          else {
            f0 = f1;
          }
        }
      }

      bAig_AuxAig0(manager,baig) = f0;
      bAig_AuxAig1(manager,baig) = f1;
      bAig_Ref(manager, f0);
      bAig_Ref(manager, f1);
    }
  }

}


/**Function********************************************************************
  Synopsis    [ternary evaluation]
  Description [ternary evaluation]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
ternaryEvalIntern
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  bAigEdge_t careBaig,
  int startTernary
)
{
  bAigEdge_t f0, f1;
  bAig_Manager_t *manager = ddm->aig.mgr;
  int i;
  bAigEdge_t right, left, r0, r1, l0, l1;

  if (startTernary >= 0) {
    for (i=0; i<aigNodes->num; i++) {
      bAigEdge_t newF0, newF1;
      bAigEdge_t baig = aigNodes->nodes[i];

      f0 = bAig_AuxAig0(manager,baig);
      f1 = bAig_AuxAig1(manager,baig);
      if (i<startTernary) {
        newF0 = bAig_And(manager,bAig_Not(f0),bAig_Not(f1));
        newF1 = bAig_And(manager,f0,f1);
        bAig_Ref(manager, newF0);
        bAig_Ref(manager, newF1);
      }
      else {
	newF0 = newF1 = bAig_NULL;
      }
      bAig_RecursiveDeref(manager,f0);
      bAig_RecursiveDeref(manager,f1);
      bAig_AuxAig0(manager,baig) = newF0;
      bAig_AuxAig1(manager,baig) = newF1;
    }
  }

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];

    if (bAig_NodeIsConstant(baig)) {
      f1 = bAig_Zero;
      f0 = bAig_Not(f1);
    }
    else if (bAig_NodeIsConstant(baig) || bAig_isVarNode(manager,baig)) {
      f1 = bAig_NonInvertedEdge(baig);
      f0 = bAig_Not(f1);
    }
    else {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      r0 = bAig_AuxAig0(manager,right);
      r1 = bAig_AuxAig1(manager,right);
      if (bAig_NodeIsInverted(right)) {
        bAigSwap(r0,r1);
      }
      l0 = bAig_AuxAig0(manager,left);
      l1 = bAig_AuxAig1(manager,left);
      if (bAig_NodeIsInverted(left)) {
        bAigSwap(l0,l1);
      }
      f0 = bAig_Or(manager,r0,l0);
      f1 = bAig_And(manager,r1,l1);
      bAig_Ref(manager, f0);
      bAig_Ref(manager, f1);
    }
    if (bAig_AuxAig0(manager,baig) != bAig_NULL) {
      bAig_RecursiveDeref(manager,f0);
      f0 = bAig_AuxAig0(manager,baig);
    }
    if (bAig_AuxAig1(manager,baig) != bAig_NULL) {
      bAig_RecursiveDeref(manager,f1);
      f1 = bAig_AuxAig1(manager,baig);
    }
    bAig_AuxAig0(manager,baig) = f0;
    bAig_AuxAig1(manager,baig) = f1;
  }
}


/**Function********************************************************************
  Synopsis    [ternary evaluation]
  Description [ternary evaluation]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
monotoneSplitIntern
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  int assumeRed
)
{
  bAigEdge_t f0, f1;
  bAig_Manager_t *manager = ddm->aig.mgr;
  int i;
  bAigEdge_t right, left, r0, r1, l0, l1;

  for (i=0; i<aigNodes->num; i++) {

    bAigEdge_t baig = aigNodes->nodes[i];

    f0 = bAig_AuxAig0(manager,baig);
    f1 = bAig_AuxAig1(manager,baig);

    if (f0 == bAig_NULL) {
      if (bAig_NodeIsConstant(baig)) {
        f1 = bAig_Zero;
        f0 = bAig_Not(f1);
      }
      else if (bAig_isVarNode(manager,baig)) {
        f1 = bAig_NonInvertedEdge(baig);
        f0 = bAig_Not(f1);
      }
      else {
        right = bAig_NodeReadIndexOfRightChild(manager,baig);
        left = bAig_NodeReadIndexOfLeftChild(manager,baig);
	if (assumeRed && (nodeAuxChar(manager,right)!=0)) {
	  r1 = (nodeAuxChar(manager,right)==1) ? bAig_One : bAig_Zero;
	  r0 = bAig_Not(r1);
	}
	else {
	  r0 = bAig_AuxAig0(manager,right);
	  r1 = bAig_AuxAig1(manager,right);
	}
        if (bAig_NodeIsInverted(right)) {
      	  bAigSwap(r0,r1);
        }
	if (assumeRed && (nodeAuxChar(manager,left)!=0)) {
	  l1 = (nodeAuxChar(manager,left)==1) ? bAig_One : bAig_Zero;
	  l0 = bAig_Not(l1);
	}
	else {
	  l0 = bAig_AuxAig0(manager,left);
	  l1 = bAig_AuxAig1(manager,left);
	}
        if (bAig_NodeIsInverted(left)) {
      	  bAigSwap(l0,l1);
        }
        f0 = bAig_Or(manager,r0,l0);
        f1 = bAig_And(manager,r1,l1);
      }

      bAig_AuxAig0(manager,baig) = f0;
      bAig_AuxAig1(manager,baig) = f1;
      bAig_Ref(manager, f0);
      bAig_Ref(manager, f1);
    }
  }
}


/**Function********************************************************************
  Synopsis    [ternary evaluation]
  Description [ternary evaluation]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
newAigEvalIntern
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes
)
{
  bAigEdge_t f;
  bAig_Manager_t *manager = ddm->aig.mgr;
  int i;
  bAigEdge_t right, left, r, l;

  for (i=0; i<aigNodes->num; i++) {

    bAigEdge_t baig = aigNodes->nodes[i];

    f = bAig_AuxAig0(manager,baig);

    if (f == bAig_NULL) {
      if (bAig_NodeIsConstant(baig)) {
        f = bAig_Zero;
      }
      else if (bAig_isVarNode(manager,baig)) {
        f = bAig_NonInvertedEdge(baig);
      }
      else {
        right = bAig_NodeReadIndexOfRightChild(manager,baig);
        left = bAig_NodeReadIndexOfLeftChild(manager,baig);
        r = bAig_NULL;
        if (nodeAuxChar(manager,right)!=0) {
          r = (nodeAuxChar(manager,right)==1) ? bAig_One : bAig_Zero;
        }
        if (r == bAig_NULL) {
	  r = bAig_AuxAig0(manager,right);
	}
        if (bAig_NodeIsInverted(right)) {
	  r = bAig_Not(r);
        }
        l = bAig_NULL;
        if (nodeAuxChar(manager,left)!=0) {
          l = (nodeAuxChar(manager,left)==1) ? bAig_One : bAig_Zero;
        }
        if (l == bAig_NULL) {
	  l = bAig_AuxAig0(manager,left);
	}
        if (bAig_NodeIsInverted(left)) {
	  l = bAig_Not(l);
        }
        f = bAig_And(manager,r,l);
      }

      bAig_AuxAig0(manager,baig) = f;
      bAig_Ref(manager, f);
    }
  }
}

/**Function********************************************************************
  Synopsis    [ternary evaluation]
  Description [ternary evaluation]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
newAigEvalInternNnf
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  nnfCoreMgr_t *nnfCoreMgr
)
{
  bAigEdge_t f;
  bAig_Manager_t *manager = ddm->aig.mgr;
  int i;
  bAigEdge_t right, left, r, l;

  for (i=0; i<aigNodes->num; i++) {

    bAigEdge_t baig = aigNodes->nodes[i];

    f = bAig_AuxAig0(manager,baig);

    if (f == bAig_NULL) {
      if (bAig_NodeIsConstant(baig)) {
        f = bAig_Zero;
      }
      else if (bAig_isVarNode(manager,baig)) {
        f = bAig_NonInvertedEdge(baig);
      }
      else {
	int isAnd = (nnfCoreMgr->gateType[i] == 'A');
        right = bAig_NodeReadIndexOfRightChild(manager,baig);
        left = bAig_NodeReadIndexOfLeftChild(manager,baig);
        r = bAig_NULL;
        l = bAig_NULL;
        int redr=0, redl=0;
        /* check if left is constant 0 */
        if (nodeAuxChar(manager,left)!=0) {
          bAigEdge_t ll;
          ll = (nodeAuxChar(manager,left)==1) ? bAig_One : bAig_Zero;
          if (bAig_NodeIsInverted(left)) {
            ll = bAig_Not(ll);
          }
          if (isAnd) {
            if (ll == bAig_Zero) {
              /* r is don't care: set one */
              r = bAig_NodeIsInverted(right)? bAig_Zero : bAig_One;
              redr=1;
            }
            else if (ll == bAig_One) {
              /* l is don't care: set one */
              l = bAig_One;
              redl=1;
            }
          }
        }
        if (r == bAig_NULL) {
	  r = bAig_AuxAig0(manager,right);
	}
        if (bAig_NodeIsInverted(right)) {
	  r = bAig_Not(r);
        }
        /* check if right is constant 0 */
        if (l==bAig_NULL) {
        if (nodeAuxChar(manager,right)!=0) {
          bAigEdge_t rr;
          rr = (nodeAuxChar(manager,right)==1) ? bAig_One : bAig_Zero;
          if (bAig_NodeIsInverted(right)) {
            rr = bAig_Not(rr);
          }
          if (isAnd) {
            if (rr == bAig_Zero) {
              /* l is don't care: set one */
              l = bAig_NodeIsInverted(left)? bAig_Zero : bAig_One;
              redl=1;
            }
            else if (rr == bAig_One) {
              /* r is don't care: set one */
              r = bAig_One;
              redr=1;
            }
          }
        }
        if (l == bAig_NULL) {
	  l = bAig_AuxAig0(manager,left);
	}
        if (bAig_NodeIsInverted(left)) {
	  l = bAig_Not(l);
        }
        }
        f = bAig_And(manager,r,l);
        if (redr&&redl) {
          assert(f==bAig_One);
        }
        if (redr) {
          assert(f==l);
        }
        if (redl) {
          assert(f==r);
        }
      }

      bAig_AuxAig0(manager,baig) = f;
      bAig_Ref(manager, f);
    }
  }
}


/**Function********************************************************************
  Synopsis    [ternary evaluation]
  Description [ternary evaluation]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiAigCheckRedFull
(
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *care
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i, cnt=0;
  bAig_array_t *visitedNodes = bAigArrayAlloc();

  postOrderAigVisitIntern(bmgr,Ddi_BddToBaig(fAig),visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  //  for (i=0; i<visitedNodes->num; i++) {
  for (i=1261; i<1262; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    Ddi_Bdd_t *newf;
    newf = checkRedIntern(fAig,care,baig,0);
    if (newf != NULL) {
      cnt++;
      Ddi_Free(newf);
    }
    else {
      newf = checkRedIntern(fAig,care,baig,1);
      if (newf != NULL) {
	cnt++;
	Ddi_Free(newf);
      }
    }
  }

  fprintf(dMgrO(ddm),"%d single redundancies found\n", cnt);
  bAigArrayFree(visitedNodes);

}


/**Function********************************************************************
  Synopsis    [ternary evaluation]
  Description [ternary evaluation]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
checkRedIntern
(
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *careAig,
  bAigEdge_t redNode,
  int redVal
)
{
  bAigEdge_t f0, f1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i;
  bAigEdge_t right, left, r0, r1, l0, l1;
  Ddi_Bdd_t *checkRed;
  int ok;
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  bAigEdge_t newfBaig;
  Ddi_Bdd_t *newfAig;

  postOrderAigVisitIntern(bmgr,Ddi_BddToBaig(fAig),visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];

    if (bAig_NonInvertedEdge(baig) == bAig_NonInvertedEdge(redNode)) {
      f1 = redVal==1 ? bAig_One : bAig_Zero;
    }
    else if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      f1 = bAig_NonInvertedEdge(baig);
    }
    else {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      r1 = bAig_NodeIsInverted(right) ?
        bAig_Not(bAig_AuxAig1(bmgr,right)) : bAig_AuxAig1(bmgr,right);
      l1 = bAig_NodeIsInverted(left) ?
        bAig_Not(bAig_AuxAig1(bmgr,left)) : bAig_AuxAig1(bmgr,left);
      f1 = bAig_And(bmgr,r1,l1);
    }
    bAig_AuxAig1(bmgr,baig) = f1;
    bAig_Ref(bmgr, f1);
  }

  newfBaig = bAig_AuxAig1(bmgr,Ddi_BddToBaig(fAig));
  newfAig = Ddi_BddMakeFromBaig(ddm,newfBaig);
  if (bAig_NodeIsInverted(Ddi_BddToBaig(fAig))) {
    Ddi_BddNotAcc(newfAig);
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
  }

  checkRed = Ddi_BddXor(newfAig,fAig);

  if (careAig!=NULL) {
    Ddi_BddAndAcc(checkRed,careAig);
  }
  ok = !Ddi_AigSat(checkRed);

  Ddi_Free(checkRed);
  bAigArrayFree(visitedNodes);

  if (ok) {
    return (newfAig);
  }
  else {
    Ddi_Free(newfAig);
    return NULL;
  }

}


/**Function********************************************************************
  Synopsis    [ternary evaluation]
  Description [ternary evaluation]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
checkRedPartialIntern
(
  Ddi_Bdd_t *fAig,
  Ddi_Bdd_t *careAig,
  bAig_array_t *visitedNodes,
  int redId,
  int redVal,
  double time_limit
)
{
  bAigEdge_t f0, f1;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i;
  bAigEdge_t right, left, r0, r1, l0, l1;
  Ddi_Bdd_t *checkRed;
  int ok;
  bAigEdge_t newfBaig;
  Ddi_Bdd_t *newfAig;

  for (i=redId; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];

    if (i == redId) {
      f1 = redVal==1 ? bAig_One : bAig_Zero;
    }
    else if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
      f1 = bAig_NonInvertedEdge(baig);
    }
    else {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      r1 = bAig_NodeIsInverted(right) ?
        bAig_Not(bAig_AuxAig1(bmgr,right)) : bAig_AuxAig1(bmgr,right);
      l1 = bAig_NodeIsInverted(left) ?
        bAig_Not(bAig_AuxAig1(bmgr,left)) : bAig_AuxAig1(bmgr,left);
      f1 = bAig_And(bmgr,r1,l1);
    }
    bAig_Ref(bmgr, f1);
    if (bAig_AuxAig1(bmgr,baig) != bAig_NULL) {
      bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    }
    bAig_AuxAig1(bmgr,baig) = f1;
  }


  newfBaig = bAig_AuxAig1(bmgr,Ddi_BddToBaig(fAig));
  newfAig = Ddi_BddMakeFromBaig(ddm,newfBaig);
  if (bAig_NodeIsInverted(Ddi_BddToBaig(fAig))) {
    Ddi_BddNotAcc(newfAig);
  }

  checkRed = Ddi_BddXor(newfAig,fAig);

  if (careAig!=NULL) {
    Ddi_BddAndAcc(checkRed,careAig);
  }
  ok = Ddi_AigSatWithAbort(checkRed,(int)time_limit)==0;

  Ddi_Free(checkRed);

  if (ok) {
    return (newfAig);
  }
  else {
    Ddi_Free(newfAig);
    return NULL;
  }

}


/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
existDiffCnfStoreIntern
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  bAigEdge_t careBaig,
  int *compareLit,
  FILE *fp                       /* IN: pointer to the store file */,
  int *clauseNPtr                /* OUT: number of added clauses */,
  int *varMaxPtr                 /* OUT: mac var ID */,
  int mergeCompl,
  int cacheEnable
)
{
  bAigEdge_t f0, f1;
  bAig_Manager_t *manager = ddm->aig.mgr;
  int vXor, f0Cnf, f1Cnf, i;
  int nCompare=0;
  bAigEdge_t right, left, r0, r1, l0, l1, cachedEntry;
  int cachedMerge=0, cachedDiff=0;
  int doCheck;

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    /* reset local ref counter */
    bAig_AuxRef(manager,baig) = 0;

    if (!(bAig_NodeIsConstant(baig) || bAig_isVarNode(manager,baig))) {
      right = bAig_NodeReadIndexOfRightChild(manager,baig);
      left = bAig_NodeReadIndexOfLeftChild(manager,baig);
      bAig_AuxRef(manager,right)++;
      bAig_AuxRef(manager,left)++;
    }
  }

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];

    compareLit[i] = 0;

    f0 = bAig_AuxAig0(manager,baig);
    f1 = bAig_AuxAig1(manager,baig);

#if 1
    if (f0 == bAig_NULL) {
      Pdtutil_Assert(f1 == bAig_NULL, "NULL Aig required");

      if (bAig_NodeIsConstant(baig) || bAig_isVarNode(manager,baig)) {
        f0 = f1 = bAig_NonInvertedEdge(baig);
      }
      else {
        right = bAig_NodeReadIndexOfRightChild(manager,baig);
        left = bAig_NodeReadIndexOfLeftChild(manager,baig);
        /* compute node */
        r0 = bAig_NodeIsInverted(right) ?
           bAig_Not(bAig_AuxAig0(manager,right)) : bAig_AuxAig0(manager,right);
        r1 = bAig_NodeIsInverted(right) ?
           bAig_Not(bAig_AuxAig1(manager,right)) : bAig_AuxAig1(manager,right);
        l0 = bAig_NodeIsInverted(left) ?
           bAig_Not(bAig_AuxAig0(manager,left)) : bAig_AuxAig0(manager,left);
        l1 = bAig_NodeIsInverted(left) ?
           bAig_Not(bAig_AuxAig1(manager,left)) : bAig_AuxAig1(manager,left);
        f0 = bAig_And(manager,r0,l0);
        f1 = bAig_And(manager,r1,l1);
      }

      if (f0 != f1 && cacheEnable) {
        /* check cache */
	ddm->stats.aig.n_check_3++;
        cachedMerge = bAigMergeCacheRead(manager,f0,f1,&cachedEntry);
        if (cachedEntry != bAig_NULL && cachedMerge) {
          /* do merge */
          if (cachedMerge == 1) {
            f1 = f0;
          }
          else {
            f0 = f1;
          }
        }
	else {
          if (cachedEntry == careBaig) {
	    cachedDiff = 1;
	  }
	}
      }

      bAig_AuxAig0(manager,baig) = f0;
      bAig_AuxAig1(manager,baig) = f1;

    }
#endif


    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if (bAig_NodeIsConstant(f0) || bAig_NodeIsConstant(f1)) {
      continue;
    }
    if (f0 == f1 || f0 == bAig_Not(f1)) {
      /* skip structurally merged nodes */
      continue;
    }
    if (bAig_isVarNode(manager,baig)) {
      /* this is the smoothing variable: cofactor differ */
      continue;
    }

    right = bAig_NodeReadIndexOfRightChild(manager,baig);
    left = bAig_NodeReadIndexOfLeftChild(manager,baig);
    doCheck = (((bAig_AuxAig0(manager,right) != bAig_AuxAig1(manager,right)) &&
                (1||nodeAuxChar(manager,right) == 1)) ||
               ((bAig_AuxAig0(manager,left) != bAig_AuxAig1(manager,left)) &&
                (1||nodeAuxChar(manager,left) == 1)));
    doCheck = doCheck && (nodeAuxChar(manager,baig) == 0);
    if (cachedDiff/* || (bAig_AuxRef(manager,baig) == 1)*/) {
      if (cachedDiff) {
        ddm->stats.aig.n_diff++;
      }
      else {
        ddm->stats.aig.n_diff_1++;
      }
    }
    else if (doCheck) {
      /* store CNF clauses of cofactor functions */
      aig2CnfIntern(ddm,f0,fp,clauseNPtr, varMaxPtr);
      aig2CnfIntern(ddm,f1,fp,clauseNPtr, varMaxPtr);

      /* generate comparison clauses */
      /* nex var representing comparison (Xor) */
      vXor = aig2CnfNewIdIntern(ddm);
      if (vXor > *varMaxPtr) {
        *varMaxPtr = vXor;
      }
      compareLit[i] = vXor;
      nCompare++;

      f0Cnf = bAig_NodeIsInverted(f0) ? -aig2CnfId(manager,f0) :
                                        aig2CnfId(manager,f0);
      f1Cnf = bAig_NodeIsInverted(f1) ? -aig2CnfId(manager,f1) :
                                        aig2CnfId(manager,f1);

      if (mergeCompl) {
	f1Cnf = -f1Cnf;
      }
#if 1
      /* v=(f0!=f1) --> (v+f0+!f1)(v+!f0+f1)(!v+f0+f1)(!v+!f0+!f1) */
      fprintf(fp, "%d %d %d 0\n", vXor, f0Cnf, -f1Cnf);
      fprintf(fp, "%d %d %d 0\n", vXor, -f0Cnf, f1Cnf);
      fprintf(fp, "%d %d %d 0\n", -vXor, f0Cnf, f1Cnf);
      fprintf(fp, "%d %d %d 0\n", -vXor, -f0Cnf, -f1Cnf);
      *clauseNPtr += 4;
#else
      f0Cnf = aig2CnfId(manager,f0);
      fprintf(fp, "%d %d 0\n", vXor, f0Cnf);
      fprintf(fp, "%d %d 0\n", -vXor, -f0Cnf);
      *clauseNPtr += 2;
#endif
    }
  }

  return (nCompare);

}

/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
redCnfStoreIntern
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  bAigEdge_t careBaig,
  int *compareLit,
  FILE *fp                       /* IN: pointer to the store file */,
  int *clauseNPtr                /* OUT: number of added clauses */,
  int *varMaxPtr                 /* OUT: mac var ID */,
  int constVal
)
{
  bAigEdge_t f1;
  bAig_Manager_t *manager = ddm->aig.mgr;
  int vXor, f1Cnf, i;
  int nCompare=0;
  bAigEdge_t right, left;
  int doCheck;

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];

    compareLit[i] = 0;

    f1 = bAig_AuxAig1(manager,baig);

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if (bAig_NodeIsConstant(f1)) {
      continue;
    }
#if 0
    /* allow checks on variables */
    if (bAig_isVarNode(manager,baig)) {
      /* this is the smoothing variable: cofactor differ */
      continue;
    }
#endif

    right = bAig_NodeReadIndexOfRightChild(manager,baig);
    left = bAig_NodeReadIndexOfLeftChild(manager,baig);

    doCheck = (nodeAuxChar(manager,baig) == 0);
    if (doCheck) {
      /* store CNF clauses of val function */
      aig2CnfIntern(ddm,f1,fp,clauseNPtr, varMaxPtr);

      f1Cnf = aig2CnfId(manager,f1);

      nCompare++;
      if (0&&constVal == 0) {
        /* disabled as zchaff-multiple requires incremental cmf ids */
        compareLit[i] = f1Cnf;
      }
      else {
        /* generate comparison clauses */
        /* nex var representing comparison (Xor) */
        vXor = aig2CnfNewIdIntern(ddm);
        if (vXor > *varMaxPtr) {
          *varMaxPtr = vXor;
        }
        compareLit[i] = vXor;
        if (constVal == 0) {
	  f1Cnf = -f1Cnf;
	}
        /* v=(!f0) --> (v+f0)(!v+!f0) */
        fprintf(fp, "%d %d 0\n", vXor, f1Cnf);
        fprintf(fp, "%d %d 0\n", -vXor, -f1Cnf);
        *clauseNPtr += 2;
      }
    }
  }

  return (nCompare);

}


/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
redEqCnfStoreIntern
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  bAigEdge_t careBaig,
  int **compareLitArray,
  FILE *fp                       /* IN: pointer to the store file */,
  int *clauseNPtr                /* OUT: number of added clauses */,
  int *varMaxPtr                 /* OUT: mac var ID */,
  int constVal
)
{
  bAigEdge_t f_i, f_j;
  bAig_Manager_t *manager = ddm->aig.mgr;
  int vXor, fiCnf, fjCnf, i, j;
  int nCompare=0;

  /* compare lit ha gi filtrato le signatures */

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];

    f_i = bAig_AuxAig1(manager,baig);
    Pdtutil_Assert(f_i!=bAig_NULL,"NULL aux aig found");

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if (bAig_NodeIsConstant(f_i)) {
      continue;
    }

    if (compareLitArray[i] != NULL) {
      for (j=0;compareLitArray[i][j]>=0; j+=2) {
        bAigEdge_t baig_j = aigNodes->nodes[compareLitArray[i][j]];

        /* store CNF clauses of val function */
        aig2CnfIntern(ddm,f_i,fp,clauseNPtr, varMaxPtr);

        f_j = bAig_AuxAig1(manager,baig_j);

        fiCnf = aig2CnfId(manager,f_i);
        fjCnf = aig2CnfId(manager,f_j);

        nCompare++;

        /* generate comparison clauses */
        /* nex var representing comparison (Xor) */
        vXor = aig2CnfNewIdIntern(ddm);
        if (vXor > *varMaxPtr) {
          *varMaxPtr = vXor;
        }
        compareLitArray[i][j+1] = vXor;
        /* v=(fi!=fj) --> (v+fi+!fj)(v+!fi+fj)(!v+fi+fj)(!v+!fi+!fj) */
        fprintf(fp, "%d %d %d 0\n", vXor, fiCnf, -fjCnf);
        fprintf(fp, "%d %d %d 0\n", vXor, -fiCnf, fjCnf);
        fprintf(fp, "%d %d %d 0\n", -vXor, fiCnf, fjCnf);
        fprintf(fp, "%d %d %d 0\n", -vXor, -fiCnf, -fjCnf);
        *clauseNPtr += 4;
      }
    }
  }

  return (nCompare);

}


/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
existDiffMergeIntern
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  bAigEdge_t careBaig,
  int *compareLit,
  int mergeDirection,
  int mergeCompl,
  int cacheEnable
)
{
  bAigEdge_t f0, f1, f0Old, f1Old;
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAigEdge_t right, left, r0, r1, l0, l1;
  int i;

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];

    f0Old = f0 = bAig_AuxAig0(manager,baig);
    f1Old = f1 = bAig_AuxAig1(manager,baig);

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
    if (bAig_NodeIsConstant(f0) || bAig_NodeIsConstant(f1)) {
      continue;
    }
    if (f0 == f1) {
      /* skip structurally merged nodes */
      continue;
    }
    if (bAig_isVarNode(manager,baig)) {
      /* this is the smoothing variable: cofactor differ */
      continue;
    }

    if (0&&(compareLit[i]>0)) {
      /* merge candidate */
      Ddi_Bdd_t *f0Bdd = Ddi_BddMakeFromBaig(ddm,f0);
      Ddi_Bdd_t *f1Bdd = Ddi_BddMakeFromBaig(ddm,f1);
      Ddi_BddSetMono(f0Bdd);
      Ddi_BddSetMono(f1Bdd);
      Pdtutil_Assert(Ddi_BddEqual(f0Bdd,f1Bdd),"Wrong MERGE");
      Ddi_Free(f0Bdd);
      Ddi_Free(f1Bdd);
    }

    /* reset CNF visit */
    aig2CnfClearVisitedIntern(manager,f0);
    aig2CnfClearVisitedIntern(manager,f1);

    /* recompute cofactor functions */

    right = bAig_NodeReadIndexOfRightChild(manager,baig);
    left = bAig_NodeReadIndexOfLeftChild(manager,baig);
    /* recompute node */
    r0 = bAig_NodeIsInverted(right) ?
         bAig_Not(bAig_AuxAig0(manager,right)) : bAig_AuxAig0(manager,right);
    r1 = bAig_NodeIsInverted(right) ?
         bAig_Not(bAig_AuxAig1(manager,right)) : bAig_AuxAig1(manager,right);
    l0 = bAig_NodeIsInverted(left) ?
         bAig_Not(bAig_AuxAig0(manager,left)) : bAig_AuxAig0(manager,left);
    l1 = bAig_NodeIsInverted(left) ?
         bAig_Not(bAig_AuxAig1(manager,left)) : bAig_AuxAig1(manager,left);
    f0 = bAig_And(manager,r0,l0);
    f1 = bAig_And(manager,r1,l1);

    if (mergeCompl) {
      f1 = bAig_Not(f1);
    }
    if (f0 != f1 && (compareLit[i]!=0)) {
      if (compareLit[i]>0) {
#if 1
        /* merge ! */
        int size0=0, size1=0;
        switch (mergeDirection) {
          case 0: /* bidir: 0<->1 */
            size0 = myNodeCountIntern(manager,f0);
            myNodeClearVisitedIntern(manager,f0);
            size1 = myNodeCountIntern(manager,f1);
            myNodeClearVisitedIntern(manager,f1);
          break;
          case -1: /* 0<-1 */
            size0 = 0;
            size1 = 1;
          break;
          case 1: /* 0->1 */
            size0 = 1;
            size1 = 0;
          break;
        }

        if (size0<size1) {
          if (cacheEnable) {
            bAigMergeCacheWrite(manager,f0,f1,careBaig,1/* f1 merged to f0*/);
          }
          f1 = f0;
        }
        else {
          if (cacheEnable) {
            bAigMergeCacheWrite(manager,f0,f1,careBaig,2/* f0 merged to f1*/);
          }
          f0 = f1;
        }
#else
        f1 = bAig_Zero;
#endif
      }
      else {
	/* cache diff */
        if (cacheEnable) {
          bAigMergeCacheWrite(manager,f0,f1,careBaig,0/*not merged*/);
        }
      }
    }
    if (mergeCompl) {
      f1 = bAig_Not(f1);
    }
    bAig_AuxAig0(ddm->aig.mgr,baig) = f0;
    bAig_AuxAig1(ddm->aig.mgr,baig) = f1;
    bAig_Ref(manager, f0);
    bAig_Ref(manager, f1);
    bAig_RecursiveDeref(manager,f0Old);
    bAig_RecursiveDeref(manager,f1Old);

  }

}


/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
existDiffClearCnfIntern
(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes
)
{
  int i;
  bAigEdge_t f0, f1;
  bAig_Manager_t *manager = ddm->aig.mgr;

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];

    f0 = bAig_AuxAig0(manager,baig);
    f1 = bAig_AuxAig1(manager,baig);

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }
#if 0
    if (bAig_isVarNode(manager,baig)) {
      /* this is the smoothing variable: cofactor differ */
      continue;
    }
#endif

    /* reset CNF visit */
    aig2CnfClearVisitedIntern(manager,f0);
    aig2CnfClearVisitedIntern(manager,f1);

  }

}


/**Function********************************************************************
  Synopsis    [Sort by Fanout count]
  Description [Sort by fanout count. Variables are sorted by increasing
               transitive fanout in fAig. Counting sort is used.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
AigVararraySortByFanout(
  Ddi_Vararray_t *vA,
  Ddi_Bdd_t *fAig
)
{
  int i,j,n = Ddi_BddSize(fAig)+1;
  int nv = Ddi_VararrayNum(vA);
  int *countArray = Pdtutil_Alloc(int,n);
  int *foArray = Pdtutil_Alloc(int,nv);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Vararray_t *newArray = Ddi_VararrayAlloc(ddm,nv);

  for (j=0; j<n; j++) countArray[j]=0;

  for (i=0; i<nv; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    int foCnt = DdiAigFanoutCount (fAig,v);
    Pdtutil_Assert(foCnt<n,"Wrong fanout count");
    countArray[foCnt]++;
    foArray[i] = foCnt;
  }

  /* multiple occourrences */
  for (i=1; i<n; i++) {
    countArray[i] += countArray[i-1];
  }

  for (i=0; i<nv; i++) {
    Ddi_VararrayWrite(newArray,i,NULL);
  }

  /* do sort */
  for (i=nv-1; i>=0; i--) {
    j=--countArray[foArray[i]];
    Pdtutil_Assert(j>=0 && j<nv, "error in counting sort");
    Pdtutil_Assert(Ddi_VararrayRead(newArray,j)==NULL,
      "wrong index in counting sort");
    Ddi_VararrayWrite(newArray,j,Ddi_VararrayRead(vA,i));
  }

  /* rewrite original array */

  for (i=0; i<nv; i++) {
    Ddi_VararrayWrite(vA,i,Ddi_VararrayRead(newArray,i));
  }

  Ddi_Free(newArray);
  Pdtutil_Free(countArray);
  Pdtutil_Free(foArray);
  return 0;
}

/**Function********************************************************************
  Synopsis    [Sort by Fanout count]
  Description [Sort by fanout count. Variables are sorted by increasing
               transitive fanout in fAig. Counting sort is used.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
AigVararraySortByFlow(
  Ddi_Vararray_t *vA,
  Ddi_Bdd_t *fAig
)
{
  int i,j,n = Ddi_BddSize(fAig)+1;
  int nv = Ddi_VararrayNum(vA);
  int *countArray = Pdtutil_Alloc(int,n);
  int *flowArray = Pdtutil_Alloc(int,nv);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Vararray_t *newArray = Ddi_VararrayAlloc(ddm,nv);

  for (j=0; j<n; j++) countArray[j]=0;

  for (i=0; i<nv; i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    int flowCnt = DdiAigFanoutCount (fAig,v);
    Pdtutil_Assert(flowCnt<n,"Wrong fanout count");
    countArray[flowCnt]++;
    flowArray[i] = flowCnt;
  }

  /* multiple occourrences */
  for (i=1; i<n; i++) {
    countArray[i] += countArray[i-1];
  }

  for (i=0; i<nv; i++) {
    Ddi_VararrayWrite(newArray,i,NULL);
  }

  /* do sort */
  for (i=nv-1; i>=0; i--) {
    j=--countArray[flowArray[i]];
    Pdtutil_Assert(j>=0 && j<nv, "error in counting sort");
    Pdtutil_Assert(Ddi_VararrayRead(newArray,j)==NULL,
      "wrong index in counting sort");
    Ddi_VararrayWrite(newArray,j,Ddi_VararrayRead(vA,i));
  }

  /* rewrite original array */

  for (i=0; i<nv; i++) {
    Ddi_VararrayWrite(vA,i,Ddi_VararrayRead(newArray,i));
  }

  Ddi_Free(newArray);
  Pdtutil_Free(countArray);
  Pdtutil_Free(flowArray);
  return 0;
}

/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiAigArrayVarsWithCnfInfo (
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  bAig_array_t *varNodes
)
{
  int i;
  bAig_Manager_t *manager = ddm->aig.mgr;

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(manager,baig)) {
      bAigArrayWriteLast(varNodes,baig);
    }
    else {
      int cnf = aig2CnfIdRead(manager,baig);
      if (cnf>=0 && cnfReadActive(ddm,cnf)) {
        /* node is cnf active */
        bAigArrayWriteLast(varNodes,baig);
      }
    }

  }
}


/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigArraySortByLevel(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  bAigEdge_t start,
  int countMaxLevel
)
{
  return bAigArraySortByLevel(ddm,aigNodes,start,countMaxLevel);
}

/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
DdiAigArraySortByLevelWithFlowStart(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  Ddi_Vararray_t *startVars
)
{
  return bAigArraySortByLevelWithFlowStart(ddm,aigNodes,
                                           startVars);
}

/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
bAigArraySortByLevel(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  bAigEdge_t start,
  int countMaxLevel
)
{
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAigEdge_t right, left;
  bAigEdge_t *nodes;
  int maxL,i,nLevel0;
  int *count;
  int *level = NULL;

  //  return 0;

  level = Pdtutil_Alloc(int,aigNodes->num);

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    bAig_AuxInt(manager,baig) = i;
  }
  maxL = 0;
  for (i=0; i<aigNodes->num; i++) {
    int lr, ll;
    bAigEdge_t baig = aigNodes->nodes[i];
    //bAigEdge_t f0 = bAig_AuxAig0(manager,baig);
    //bAigEdge_t f1 = bAig_AuxAig1(manager,baig);

    if (bAig_NonInvertedEdge(baig)==bAig_NonInvertedEdge(start)) {
      level[i] = 1;
      if (level[i] > maxL) {
        maxL = level[i];
      }
      continue;
    }

    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(manager,baig)) {
      level[i] = 0;
      continue;
    }
#if 0
    if (f0 != bAig_NULL && f0 == f1) {
      /* merged ! */
      level[i] = 0;
      continue;
    }
#endif
    right = bAig_NodeReadIndexOfRightChild(manager,baig);
    left = bAig_NodeReadIndexOfLeftChild(manager,baig);
    lr = level[bAig_AuxInt(manager,right)];
    ll = level[bAig_AuxInt(manager,left)];
    level[i] = (lr < ll) ? ll : lr;
    if (start == bAig_NULL || level[i] > 0) {
      level[i]++;
    }
    if (level[i] > maxL) {
      maxL = level[i];
    }

  }
  /* counting sort */
  count = Pdtutil_Alloc(int,maxL+1);
  for (i=0; i<=maxL; i++) {
    count[i]=0;
  }
  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    bAig_AuxInt(manager,baig) = -1;
    count[level[i]]++;
  }

  for (i=maxL; i>0; i--) {
    if (count[i]==1 && count[i-1] > 1) {
      //printf("(l:%d/%d)",i,maxL); fflush(dMgrO(ddm));
      break;
    }
  }
  if (countMaxLevel >= 0 && countMaxLevel < maxL) {
    maxL = countMaxLevel;
  }

  for (i=1; i<=maxL; i++) {
    count[i] += count[i-1];
  }

  if (countMaxLevel >= 0)
     nLevel0 = count[countMaxLevel];
  else
     nLevel0 = countMaxLevel;

  nodes = Pdtutil_Alloc(bAigEdge_t,aigNodes->num);
  for (i=aigNodes->num-1; i>=0; i--) {
    nodes[--count[level[i]]] = aigNodes->nodes[i];
  }
  for (i=aigNodes->num-1; i>=0; i--) {
    aigNodes->nodes[i] = nodes[i];
  }

  Pdtutil_Free(nodes);
  Pdtutil_Free(level);
  Pdtutil_Free(count);
  return nLevel0;
}

/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
bAigArraySetOutLevels(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  Ddi_Bddarray_t *roots
)
{
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAigEdge_t right, left;
  int maxL,i;

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxInt1(manager,baig)<0,"wrong aux int1 field");
    bAig_AuxInt1(manager,baig) = i;
  }

  for (i=0; i<Ddi_BddarrayNum(roots); i++) {
    Ddi_Bdd_t *f_i = Ddi_BddarrayRead(roots,i);
    bAigEdge_t baig = Ddi_BddToBaig(f_i);
    if (bAig_AuxInt1(manager,baig)>=0) {
      bAig_AuxInt(manager,baig) = 1;
    }
  }

  maxL=1;
  for (i=aigNodes->num-1; i>=0; i--) {
    int lr, ll, level, ir, il;
    bAigEdge_t baig = aigNodes->nodes[i];

    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(manager,baig)) {
      continue;
    }
    level = bAig_AuxInt(manager,baig);
    if (level<0) continue;
    if (level>maxL) maxL=level;
    level++;
    right = bAig_NodeReadIndexOfRightChild(manager,baig);
    left = bAig_NodeReadIndexOfLeftChild(manager,baig);
    ir = bAig_AuxInt1(manager,right);
    il = bAig_AuxInt1(manager,left);
    lr = bAig_AuxInt(manager,right);
    ll = bAig_AuxInt(manager,left);
    Pdtutil_Assert(il>=0&&il<aigNodes->num,"wrong aig nore inbaig array");
    Pdtutil_Assert(ir>=0&&ir<aigNodes->num,"wrong aig nore inbaig array");
    if (lr<0 || level < lr) {
      bAig_AuxInt(manager,right) = level;
    }
    if (ll<0 || level < ll) {
      bAig_AuxInt(manager,left) = level;
    }
  }

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    bAig_AuxInt1(manager,baig) = -1;
  }

  return maxL;
}

/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
bAigArraySortByLevelWithFlowStart(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  Ddi_Vararray_t *startVars
)
{
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAigEdge_t right, left;
  bAigEdge_t *nodes;
  int maxL,i,nLevel0;
  int *count;
  int *level = NULL;
  int *foLevelMin = NULL;

  //  return 0;

  level = Pdtutil_Alloc(int,aigNodes->num);
  foLevelMin = Pdtutil_Alloc(int,aigNodes->num);

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    bAig_AuxInt(manager,baig) = i;
    foLevelMin[i] = 0;
  }
  for (i=0; i<Ddi_VararrayNum(startVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(startVars,i);
    Pdtutil_Assert(Ddi_VarReadMark(v) == 0,"0 var mark required");
    Ddi_VarWriteMark(v,1);
  }

  maxL = 0;
  for (i=0; i<aigNodes->num; i++) {
    int lr, ll;
    bAigEdge_t baig = aigNodes->nodes[i];

    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(manager,baig)) {
      level[i] = 0;
      if (bAig_isVarNode(manager,baig)) {
        Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
        if (Ddi_VarReadMark(v) == 1) {
          /* flow start var */
          level[i] = 1;
          if (level[i] > maxL) {
            maxL = level[i];
          }
        }
      }
      continue;
    }
    right = bAig_NodeReadIndexOfRightChild(manager,baig);
    left = bAig_NodeReadIndexOfLeftChild(manager,baig);
    lr = level[bAig_AuxInt(manager,right)];
    ll = level[bAig_AuxInt(manager,left)];
    level[i] = (lr < ll) ? ll : lr;
    if (level[i] > 0) {
      level[i]++;
    }
    if (level[i] > maxL) {
      maxL = level[i];
    }
  }

  for (i=aigNodes->num-1; i>=0; i--) {
    int ir, il;
    bAigEdge_t baig = aigNodes->nodes[i];

    if (level[i]==0) {
      level[i]=foLevelMin[i];
    }
    if (level[i]==0) {
      continue;
    }
    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(manager,baig)) {
      continue;
    }
    ir = rightChildAuxInt(manager,baig);
    il = leftChildAuxInt(manager,baig);
    if ((foLevelMin[ir] == 0) || (level[i] < foLevelMin[ir])) {
      foLevelMin[ir] = level[i];
    }
    if ((foLevelMin[il] == 0) || (level[i] < foLevelMin[il])) {
      foLevelMin[il] = level[i];
    }
  }

  for (i=0; i<Ddi_VararrayNum(startVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(startVars,i);
    Ddi_VarWriteMark(v,0);
  }


  /* counting sort */
  count = Pdtutil_Alloc(int,maxL+1);
  for (i=0; i<=maxL; i++) {
    count[i]=0;
  }
  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    bAig_AuxInt(manager,baig) = -1;
    count[level[i]]++;
  }

  for (i=maxL; i>0; i--) {
    if (count[i]==1 && count[i-1] > 1) {
      //printf("(l:%d/%d)",i,maxL); fflush(dMgrO(ddm));
      break;
    }
  }

  for (i=1; i<=maxL; i++) {
    count[i] += count[i-1];
  }


  nodes = Pdtutil_Alloc(bAigEdge_t,aigNodes->num);
  for (i=aigNodes->num-1; i>=0; i--) {
    nodes[i] = bAig_NULL;
  }
  for (i=aigNodes->num-1; i>=0; i--) {
    count[level[i]]--;
    Pdtutil_Assert(nodes[count[level[i]]]==bAig_NULL,"null aig required");
    nodes[count[level[i]]] = aigNodes->nodes[i];
  }
  for (i=aigNodes->num-1; i>=0; i--) {
    aigNodes->nodes[i] = nodes[i];
  }

  Pdtutil_Free(nodes);
  Pdtutil_Free(level);
  Pdtutil_Free(foLevelMin);
  Pdtutil_Free(count);
  return 1;
}


/**Function********************************************************************
  Synopsis    [Optimizations for exist cofactors]
  Description [Optimizations for exist cofactors]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
bAigArraySiftVarIntern(
  Ddi_Mgr_t *ddm,
  bAig_array_t *aigNodes,
  bAigEdge_t start
)
{
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAigEdge_t right, left, r0, r1, l0, l1, res;
  int i;

  for (i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    bAigEdge_t f0 = bAig_AuxAig0(manager,baig);
    bAigEdge_t f1 = bAig_AuxAig1(manager,baig);

    if (bAig_NodeIsConstant(baig)) {
      continue;
    }

    if (bAig_isVarNode(manager,baig)) {
      if (f0 == bAig_NULL) {
        bAig_Ref(manager, baig);
        bAig_Ref(manager, baig);
        bAig_AuxAig0(manager,baig) = bAig_NonInvertedEdge(baig);
        bAig_AuxAig1(manager,baig) = bAig_NonInvertedEdge(baig);
      }
      if (f0 == f1) {
	continue;
      }
    }

    //    if (f0 != bAig_NULL && f0 == f1) {
    //      continue;
    //    }

    if (f0 != bAig_NULL && f0 != f1) {
      if (bAig_NodeIsConstant(f0)||bAig_NodeIsConstant(f1)) {
        bAigEdge_t mux=0;
        bAigEdge_t muxControl = start;
	if (f0 == bAig_Zero) {
          mux = bAig_And(manager,muxControl,f1);
	}
	else if (f1 == bAig_Zero) {
          mux = bAig_And(manager,bAig_Not(muxControl),f0);
	}
	else if (f0 == bAig_One) {
          mux = bAig_Or(manager,bAig_Not(muxControl),f1);
	}
	else if (f1 == bAig_One) {
          mux = bAig_Or(manager,muxControl,f0);
	}
        bAig_Ref(manager, mux);
        bAig_Ref(manager, mux);
        bAig_RecursiveDeref(manager,f0);
        bAig_RecursiveDeref(manager,f1);
        bAig_AuxAig0(manager,baig) = mux;
        bAig_AuxAig1(manager,baig) = mux;
        continue;
      }
    }

    right = bAig_NodeReadIndexOfRightChild(manager,baig);
    left = bAig_NodeReadIndexOfLeftChild(manager,baig);
    /* compute node */
    r0 = bAig_NodeIsInverted(right) ?
       bAig_Not(bAig_AuxAig0(manager,right)) : bAig_AuxAig0(manager,right);
    r1 = bAig_NodeIsInverted(right) ?
       bAig_Not(bAig_AuxAig1(manager,right)) : bAig_AuxAig1(manager,right);
    l0 = bAig_NodeIsInverted(left) ?
       bAig_Not(bAig_AuxAig0(manager,left)) : bAig_AuxAig0(manager,left);
    l1 = bAig_NodeIsInverted(left) ?
       bAig_Not(bAig_AuxAig1(manager,left)) : bAig_AuxAig1(manager,left);

    Pdtutil_Assert(r0==r1 && l0==l1,"equal cofactors required by var sift");

    res = bAig_And(manager,r0,l0);

    bAig_Ref(manager, res);
    bAig_Ref(manager, res);
    bAig_RecursiveDeref(manager,f0);
    bAig_RecursiveDeref(manager,f1);
    bAig_AuxAig0(manager,baig) = res;
    bAig_AuxAig1(manager,baig) = res;

  }

  return 1;
}



/**Function********************************************************************
  Synopsis    [Operate compose]
  Description [Operate compose]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
siftVarAcc (
  Ddi_Bdd_t *fAig,
  Ddi_Var_t *v,
  Ddi_Bdd_t *care
)
{
  bAig_Manager_t  *bmgr;
  Ddi_Bdd_t *newfAig;
  bAig_array_t *visitedNodes;
  bAigEdge_t varIndex, fBaig, careBaig, newfBaig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  int i, extRef = Ddi_MgrReadExtRef(ddm);

  bmgr = ddm->aig.mgr;
  fBaig = Ddi_BddToBaig(fAig);
  careBaig = bAig_One;
  if (care != NULL) {
    careBaig = Ddi_BddToBaig(care);
  }
  //  cofVar = v;

  visitedNodes = bAigArrayAlloc();
  postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  varIndex = Ddi_VarToBaig(v);
  Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable in ExistVar");

  bAig_AuxAig0(bmgr,varIndex) = bAig_Zero;
  bAig_AuxAig1(bmgr,varIndex) = bAig_One;

  existDiffEvalIntern(ddm,visitedNodes,careBaig,1/*cache enable*/);
  //  AigSatDiffTot(ddm,visitedNodes,careBaig,0,0,0/*cacheEnable*/);

  bAigArraySiftVarIntern(ddm,visitedNodes,varIndex);

  newfBaig = bAig_NodeIsInverted(fBaig) ? bAig_Not(bAig_AuxAig0(bmgr,fBaig)) :
                                      bAig_AuxAig0(bmgr,fBaig);

  newfAig = Ddi_BddMakeFromBaig(ddm,newfBaig);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig0 = bAig_AuxAig0(bmgr,visitedNodes->nodes[i]);
    bAigEdge_t baig1 = bAig_AuxAig1(bmgr,visitedNodes->nodes[i]);
    if (baig0 != bAig_NULL && !bAig_NodeIsConstant(baig0)) {
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig0));
    }
    if (baig1 != bAig_NULL && !bAig_NodeIsConstant(baig1)) {
      bAig_RecursiveDeref(bmgr,bAig_NonInvertedEdge(baig1));
    }
  }

  bAigArrayFree(visitedNodes);

  Ddi_MgrCheckExtRef(ddm,extRef+1);

  return(newfAig);
}


/**Function********************************************************************

  Synopsis    [Count nodes of a bAig. Internal recursion]
  Description [Count nodes of a bAig. Internal recursion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
logBaig(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{
  fprintf(stdout,"TOP: %c %d\n", bAig_NodeIsInverted(nodeIndex) ? '!' : ' ',
	 bAigNodeID(nodeIndex));
   (void) myNodeCountInternWithPrint(manager,nodeIndex);
   myNodeClearVisitedIntern(manager,nodeIndex);
}

/**Function********************************************************************

  Synopsis    [Count nodes of a bAig. Internal recursion]
  Description [Count nodes of a bAig. Internal recursion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
logBaigNotShared(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex,
   bAig_array_t *sharedRoots
)
{
  int i;
  fprintf(stdout,"TOP: %c %d\n", bAig_NodeIsInverted(nodeIndex) ? '!' : ' ',
	 bAigNodeID(nodeIndex));
  for (i=0; i<sharedRoots->num; i++)
    (void) myNodeCountIntern(manager,sharedRoots->nodes[i]);
  (void) myNodeCountInternWithPrint(manager,nodeIndex);
  for (i=0; i<sharedRoots->num; i++)
    (void) myNodeClearVisitedIntern(manager,sharedRoots->nodes[i]);
  myNodeClearVisitedIntern(manager,nodeIndex);
}


/**Function********************************************************************

  Synopsis    [Count nodes of a bAig. Internal recursion]
  Description [Count nodes of a bAig. Internal recursion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
logAig(
  Ddi_Bdd_t *f
)
{
  logBaig(Ddi_ReadMgr(f)->aig.mgr,Ddi_BddToBaig(f));
}

/**Function********************************************************************

  Synopsis    [Count nodes of a bAig. Internal recursion]
  Description [Count nodes of a bAig. Internal recursion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
logAigNotShared(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *sh,
  Ddi_Bddarray_t *shA
)
{
  bAig_array_t *sharedRoots = bAigArrayAlloc();
  if (sh!=NULL) {
    bAigArrayPush(sharedRoots,Ddi_BddToBaig(sh));
  }
  if (shA!=NULL) {
    int i;
    for (i=0; i<Ddi_BddarrayNum(shA); i++) {
      Ddi_Bdd_t *sh_i = Ddi_BddarrayRead(shA,i);
      bAigArrayPush(sharedRoots,Ddi_BddToBaig(sh_i));
    }
  }
  logBaigNotShared(Ddi_ReadMgr(f)->aig.mgr,Ddi_BddToBaig(f),sharedRoots);
  bAigArrayFree(sharedRoots);
}

 void myLogAig(Ddi_Bdd_t *f) { logAig(f); }

/**Function********************************************************************

  Synopsis    [Count nodes of a bAig. Internal recursion]
  Description [Count nodes of a bAig. Internal recursion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
myNodeCountIntern(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{
  int count;

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    return 0;
  }

  if (nodeVisited(manager,nodeIndex)>=8) {
    return 0;
  }

  nodeVisited(manager,nodeIndex) += 8;

  if (bAig_isVarNode(manager,nodeIndex)) {
    return 1;
  }

  count = 1;
  count += myNodeCountIntern(manager,rightChild(manager,nodeIndex));
  count += myNodeCountIntern(manager,leftChild(manager,nodeIndex));

  return (count);
}

/**Function********************************************************************

  Synopsis    [Count nodes of a bAig. Internal recursion]
  Description [Count nodes of a bAig. Internal recursion]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
myNodeCountInternWithPrint(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{
  int count;

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    return 0;
  }

  if (nodeVisited(manager,nodeIndex)>=8) {
    if (bAig_isVarNode(manager,nodeIndex)) {
      fprintf(stdout,"%d: v=%s\n", bAigNodeID(nodeIndex),
	      bAig_NodeReadName(manager,nodeIndex));
      return 0;
    }
    return 0;
  }

  nodeVisited(manager,nodeIndex) += 8;

  if (bAig_isVarNode(manager,nodeIndex)) {
    fprintf(stdout,"%d: v=%s\n", bAigNodeID(nodeIndex),
        bAig_NodeReadName(manager,nodeIndex));
    return 1;
  }

  if (1) {
    char nr = bAig_NodeIsInverted(rightChild(manager,nodeIndex)) ? '!' : ' ';
    char nl = bAig_NodeIsInverted(leftChild(manager,nodeIndex)) ? '!' : ' ';
    fprintf(stdout,"%5d = AND ( %c%5d%s, %c%5d%s )\n",
	    bAigNodeID(nodeIndex),
	    nr, bAigNodeID(rightChild(manager,nodeIndex)),
	    bAig_isVarNode(manager,rightChild(manager,nodeIndex)) ? "V":"",
	    nl, bAigNodeID(leftChild(manager,nodeIndex)),
	    bAig_isVarNode(manager,leftChild(manager,nodeIndex)) ? "V":"");
  }

  count = 1;
  count += myNodeCountInternWithPrint(manager,rightChild(manager,nodeIndex));
  count += myNodeCountInternWithPrint(manager,leftChild(manager,nodeIndex));

  return (count);
}


/**Function********************************************************************
  Synopsis    [bAig store. Internal recursion: phase 1]
  Description [bAig store. Internal recursion: phase 1.
    For format see Pdtutil_AigDump_e
    ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
nodeNetStoreIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  FILE *fp,
  Pdtutil_AigDump_e format
  )
{
  int count;

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One || nodeIndex == bAig_NULL ) {
    return 0;
  }

  if (nodeVisited(manager,nodeIndex)>=64) {
    if (bAig_NodeIsInverted(nodeIndex)&&nodeVisited(manager,nodeIndex)<128) {
      nodeVisited(manager,nodeIndex) += 128;
    }
    return 0;
  }

  nodeVisited(manager,nodeIndex) += 64;
  if (bAig_NodeIsInverted(nodeIndex)) {
    nodeVisited(manager,nodeIndex) += 128;
  }

  if (bAig_isVarNode(manager,nodeIndex)) {
    switch(format) {
      case Pdtutil_Aig2BenchId_c:
        fprintf(fp,"INPUT(NODE_%d)\n", bAig_NonInvertedEdge(nodeIndex));
        break;
      case Pdtutil_Aig2BenchName_c:
        Pdtutil_Assert(bAig_NodeReadName(manager,nodeIndex), "Missing variable name.");
        fprintf(fp,"INPUT(%s)\n", bAig_NodeReadName(manager,nodeIndex));
        break;
      case Pdtutil_Aig2Blif_c:
        fprintf(fp,".inputs %s\n", bAig_NodeReadName(manager,nodeIndex));
        break;
      case Pdtutil_Aig2Slif_c:
        fprintf(fp,".inputs %s ;\n", bAig_NodeReadName(manager,nodeIndex));
        break;
      default:
        Pdtutil_Assert (0, "Invalid Net format for AIG store.");
        break;
    }
  }

  count = 1;
  count += nodeNetStoreIntern (manager, rightChild (manager, nodeIndex),
    fp, format);
  count += nodeNetStoreIntern (manager, leftChild (manager, nodeIndex),
    fp, format);

  return (count);
}

/**Function********************************************************************
  Synopsis    [bAig store. Internal recursion: phase 1]
  Description [bAig store. Internal recursion: phase 1.
    For format see Pdtutil_AigDump_e
    ]
  SideEffects []
  SeeAlso     []
******************************************************************************/

static int
nodeNetStoreInternNoPI(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  FILE *fp,
  Pdtutil_AigDump_e format
  )
{
  int count;

  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One || nodeIndex == bAig_NULL ) {
    return 0;
  }

  if (nodeVisited(manager,nodeIndex)>=64) {
    if (bAig_NodeIsInverted(nodeIndex)&&nodeVisited(manager,nodeIndex)<128) {
      nodeVisited(manager,nodeIndex) += 128;
    }
    return 0;
  }

  nodeVisited(manager,nodeIndex) += 64;
  if (bAig_NodeIsInverted(nodeIndex)) {
    nodeVisited(manager,nodeIndex) += 128;
  }

  count = 1;
  count += nodeNetStoreInternNoPI (manager, rightChild (manager, nodeIndex),
    fp, format);
  count += nodeNetStoreInternNoPI (manager, leftChild (manager, nodeIndex),
    fp, format);

  return (count);
}

/**Function********************************************************************
  Synopsis    [bAig store. Internal recursion: phase 2]
  Description [bAig store. Internal recursion: phase 2.
    For format see Pdtutil_AigDump_e
    ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
nodeNetStoreClearIntern(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex,
   FILE *fp,
   Pdtutil_AigDump_e format
  )
{
  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    return 0;
  }

  if (nodeVisited(manager,nodeIndex)<64) {
    return 0;
  }

  nodeVisited(manager,nodeIndex) -= 64;

  if (nodeVisited(manager,nodeIndex)>=128) {
    nodeVisited(manager,nodeIndex) -= 128;
    switch(format) {
      case Pdtutil_Aig2BenchId_c:
        fprintf(fp,"_NOT_NODE_%d = NOT ( NODE_%d )\n",
	  bAig_NonInvertedEdge(nodeIndex),
	  bAig_NonInvertedEdge(nodeIndex));
        break;
      case Pdtutil_Aig2BenchName_c:
        fprintf(fp,"_NOT_%s = NOT ( %s )\n",
	  bAig_NodeReadName(manager,nodeIndex),
	  bAig_NodeReadName(manager,nodeIndex));
        break;
      case Pdtutil_Aig2Blif_c:
        break;
      case Pdtutil_Aig2Slif_c:
        break;
      default:
        Pdtutil_Assert(0,"Invalid Net format for AIG store");
        break;
    }
  }

  if (!bAig_isVarNode(manager,nodeIndex)) {
    bAigEdge_t right = rightChild(manager,nodeIndex);
    bAigEdge_t left = leftChild(manager,nodeIndex);
    switch(format) {
      case Pdtutil_Aig2BenchId_c:
        fprintf(fp,"NODE_%d = AND ( %sNODE_%d , %sNODE_%d )\n",
	  bAig_NonInvertedEdge(nodeIndex),
          bAig_NodeIsInverted(right) ? "_NOT_" : "",
	  bAig_NonInvertedEdge(right),
          bAig_NodeIsInverted(left) ? "_NOT_" : "",
	  bAig_NonInvertedEdge(left));
        break;
      case Pdtutil_Aig2BenchName_c:
        fprintf(fp,"%s = AND ( %s%s , %s%s )\n",
	  bAig_NodeReadName(manager,nodeIndex),
          bAig_NodeIsInverted(right) ? "_NOT_" : "",
	  bAig_NodeReadName(manager,right),
          bAig_NodeIsInverted(left) ? "_NOT_" : "",
	  bAig_NodeReadName(manager,left));
        break;
      case Pdtutil_Aig2Blif_c:
        fprintf(fp,".names %s %s %s\n",
	  bAig_NodeReadName(manager,right),
	  bAig_NodeReadName(manager,left),
	  bAig_NodeReadName(manager,nodeIndex));
        fprintf(fp,"%d%d 1\n",
          !bAig_NodeIsInverted(right),!bAig_NodeIsInverted(left));
        break;
      case Pdtutil_Aig2Slif_c:
        fprintf(fp,"%s = ", bAig_NodeReadName (manager, nodeIndex));
        fprintf(fp,"%s", bAig_NodeReadName(manager,right));
        if (bAig_NodeIsInverted (right))
          fprintf(fp, "' ");
        else
          fprintf(fp, " ");
        fprintf(fp,"%s", bAig_NodeReadName(manager,left));
        if (bAig_NodeIsInverted (left))
          fprintf(fp, "'");
        fprintf(fp, ";\n");
        break;
      default:
        Pdtutil_Assert(0,"Invalid Net format for AIG store");
        break;
    }
    nodeNetStoreClearIntern (manager, right, fp, format);
    nodeNetStoreClearIntern (manager, left, fp, format);
  }

  return 0;
}



/**Function********************************************************************

  Synopsis    [Clear Visited flag]
  Description [Clear Visited flag]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
myNodeClearVisitedIntern(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{
  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    return;
  }

  if (nodeVisited(manager,nodeIndex)<8) {
    return;
  }

  nodeVisited(manager,nodeIndex) -= 8;

  if (bAig_isVarNode(manager,nodeIndex)) {
    return;
  }

  myNodeClearVisitedIntern(manager,rightChild(manager,nodeIndex));
  myNodeClearVisitedIntern(manager,leftChild(manager,nodeIndex));

}


/**Function********************************************************************

  Synopsis    [Clear Visited flag]
  Description [Clear Visited flag]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
existMergeClearVisitedIntern(
   bAig_Manager_t *manager,
   bAigEdge_t nodeIndex)
{
  if ( nodeIndex == bAig_Zero || nodeIndex == bAig_One ) {
    return;
  }

  if (bAig_isVarNode(manager,nodeIndex)) {
    return;
  }

  if (nodeVisited(manager,nodeIndex)==0) {
    return;
  }

  nodeVisited(manager,nodeIndex) = 0;

  existMergeClearVisitedIntern(manager,rightChild(manager,nodeIndex));
  existMergeClearVisitedIntern(manager,leftChild(manager,nodeIndex));

}



/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
bfsOrderAigVisitIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  bAig_array_t *visitedNodes
)
{
  int head, i, i0;

  head = i0 = visitedNodes->num;
  if (nodeVisited(manager,nodeIndex)) return;

  bAigArrayWriteLast(visitedNodes,nodeIndex);
  nodeSetVisited(manager,nodeIndex);

  while (head < visitedNodes->num) {

    nodeIndex = visitedNodes->nodes[head++];

    if (!bAig_NodeIsConstant(nodeIndex) &&
        !bAig_isVarNode(manager,nodeIndex)) {
      bAigEdge_t right = rightChild(manager,nodeIndex);
      bAigEdge_t left = leftChild(manager,nodeIndex);
      if (!nodeVisited(manager,right)) {
        nodeSetVisited(manager,right);
        bAigArrayWriteLast(visitedNodes,right);
      }
      if (!nodeVisited(manager,left)) {
        nodeSetVisited(manager,left);
        bAigArrayWriteLast(visitedNodes,left);
      }
    }
  }

  for (i=0; i<(visitedNodes->num-i0)/2; i++) {
    bAigEdge_t tmp = visitedNodes->nodes[i0+i];
    visitedNodes->nodes[i0+i] = visitedNodes->nodes[visitedNodes->num-1-i0];
    visitedNodes->nodes[visitedNodes->num-1-i0] = tmp;
  }

}




/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
postOrderAigByAuxIntVisitIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  bAig_array_t *visitedNodes,
  int *inOrderTimeP,
  int maxDepth
)
{
  Pdtutil_Assert(nodeVisited(manager,nodeIndex) < 8, "visited error in PO");

  if (nodeVisited(manager,nodeIndex) >= 4) {
    return;
  }

  if (maxDepth == 0) {
    return;
  }
  --maxDepth;

  nodeVisited(manager,nodeIndex) += 4;

  if (!bAig_NodeIsConstant(nodeIndex) && !bAig_isVarNode(manager,nodeIndex)) {
    bAigEdge_t index0 = rightChild(manager,nodeIndex);
    bAigEdge_t index1 = leftChild(manager,nodeIndex);
    if (bAig_AuxInt(manager,index0)>bAig_AuxInt(manager,index1)) {
      /* swap */
      bAigEdge_t tmp = index0;
      index0 = index1;
      index1 = tmp;
    }
    postOrderAigByAuxIntVisitIntern(manager,index0,visitedNodes,
                                    inOrderTimeP,maxDepth);
    if (inOrderTimeP!=NULL) {
      bAig_AuxInt1(manager,nodeIndex) = (*inOrderTimeP)++;
    }
    postOrderAigByAuxIntVisitIntern(manager,index1,visitedNodes,
                                    inOrderTimeP,maxDepth);
  }
  else {
    if (inOrderTimeP!=NULL) {
      bAig_AuxInt1(manager,nodeIndex) = (*inOrderTimeP)++;
    }
  }

  bAigArrayWriteLast(visitedNodes,nodeIndex);

}


/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
postOrderAigByMaxAuxRefWithDecrVisitIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  bAig_array_t *visitedNodes,
  int *inOrderTimeP
)
{
  Pdtutil_Assert(nodeVisited(manager,nodeIndex) < 8, "visited error in PO");

  if (bAig_AuxRef(manager,nodeIndex)>0) {
    bAig_AuxRef(manager,nodeIndex) = bAig_AuxRef(manager,nodeIndex)-1;
  }
  if (nodeVisited(manager,nodeIndex) >= 4) {
    return;
  }

  nodeVisited(manager,nodeIndex) += 4;

  if (!bAig_NodeIsConstant(nodeIndex) && !bAig_isVarNode(manager,nodeIndex)) {
    bAigEdge_t index0 = rightChild(manager,nodeIndex);
    bAigEdge_t index1 = leftChild(manager,nodeIndex);
    int swap = bAig_AuxRef(manager,index0)<bAig_AuxRef(manager,index1);
    if (!swap && bAig_AuxRef(manager,index0)==bAig_AuxRef(manager,index1)) {
      // use level
      swap = bAig_AuxInt(manager,index0)>bAig_AuxInt(manager,index1);
    }
    if (swap) {
      /* swap */
      bAigEdge_t tmp = index0;
      index0 = index1;
      index1 = tmp;
    }
    postOrderAigByMaxAuxRefWithDecrVisitIntern(manager,index0,
      visitedNodes,inOrderTimeP);
    if (inOrderTimeP!=NULL) {
      bAig_AuxInt1(manager,nodeIndex) = (*inOrderTimeP)++;
    }
    postOrderAigByMaxAuxRefWithDecrVisitIntern(manager,index1,
      visitedNodes,inOrderTimeP);
  }
  else {
    if (inOrderTimeP!=NULL) {
      bAig_AuxInt1(manager,nodeIndex) = (*inOrderTimeP)++;
    }
  }

  bAigArrayWriteLast(visitedNodes,nodeIndex);

}

/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
postOrderAigVisitIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  bAig_array_t *visitedNodes,
  int maxDepth
)
{
  char isTerminal = 0;

  Pdtutil_Assert(nodeVisited(manager,nodeIndex) < 8, "visited error in PO");

  if (nodeVisited(manager,nodeIndex) >= 4) {
    return;
  }

  if (maxDepth == 0) {
    return;
  }
  else if (maxDepth > 0) {
    --maxDepth;
  }
  else if (maxDepth < -100) {
    /* use cnfActive */
    Ddi_Mgr_t *ddm = (Ddi_Mgr_t *)manager->owner;
    int cnf = aig2CnfIdRead(manager,nodeIndex);
    if (cnf>0 && cnfReadActive(ddm,cnf)) {
      isTerminal = 1;
    }
  }

  nodeVisited(manager,nodeIndex) += 4;

  if (bAig_NodeIsConstant(nodeIndex) || bAig_isVarNode(manager,nodeIndex)) {
    isTerminal = 1;
  }

  if (!isTerminal) {
    postOrderAigVisitIntern(manager,
      rightChild(manager,nodeIndex),visitedNodes,maxDepth);
    postOrderAigVisitIntern(manager,
      leftChild(manager,nodeIndex),visitedNodes,maxDepth);
  }

  bAigArrayWriteLast(visitedNodes,nodeIndex);

}

/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
postOrderAigVisitInternReversed(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  bAig_array_t *visitedNodes,
  int maxDepth
)
{

  Pdtutil_Assert(nodeVisited(manager,nodeIndex) < 8, "visited error in PO");

  if (nodeVisited(manager,nodeIndex) >= 4) {
    return;
  }

  if (maxDepth == 0) {
    return;
  }
  --maxDepth;

  nodeVisited(manager,nodeIndex) += 4;

  if (!bAig_NodeIsConstant(nodeIndex) && !bAig_isVarNode(manager,nodeIndex)) {
    postOrderAigVisitInternReversed(manager,
      leftChild(manager,nodeIndex),visitedNodes,maxDepth);
    postOrderAigVisitInternReversed(manager,
      rightChild(manager,nodeIndex),visitedNodes,maxDepth);
  }

  bAigArrayWriteLast(visitedNodes,nodeIndex);

}


/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
bfsAigVisitIntern(
  bAig_Manager_t *manager,
  bAigEdge_t nodeIndex,
  bAig_array_t *visitedNodes,
  int maxDepth
)
{
  int i;

  bAigArrayWriteLast(visitedNodes,nodeIndex);
  nodeVisited(manager,nodeIndex) += 4;

  i = 0;

  while (i<visitedNodes->num) {
    bAigEdge_t baig = visitedNodes->nodes[i++];
    Pdtutil_Assert(nodeVisited(manager,baig) < 8, "visited error in BFS");


    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(manager,baig)) {
      if (nodeVisited(manager,rightChild(manager,baig)) < 4) {
        bAigArrayWriteLast(visitedNodes,rightChild(manager,baig));
        nodeVisited(manager,rightChild(manager,baig)) += 4;
      }
      if (nodeVisited(manager,leftChild(manager,baig)) < 4) {
        bAigArrayWriteLast(visitedNodes,leftChild(manager,baig));
        nodeVisited(manager,leftChild(manager,baig)) += 4;
      }
    }

  }

  /* revert order */
  for (i=0; i<visitedNodes->num/2; i++) {
    int n = visitedNodes->num-1;
    bAigEdge_t baig = visitedNodes->nodes[i];
    visitedNodes->nodes[i] = visitedNodes->nodes[n-i];
    visitedNodes->nodes[n-i] = baig;
  }
}

/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
bfsOrderBddAigVisitIntern(
  Ddi_Bdd_t *fAig,
  bAig_array_t *visitedNodes
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *manager = ddm->aig.mgr;

  if (Ddi_BddIsPart(fAig)) {
    int i;
    for (i=0; i<Ddi_BddPartNum(fAig); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(fAig,i);
      bfsOrderAigVisitIntern(manager,Ddi_BddToBaig(f_i),visitedNodes);
    }
  }
  else {
    bfsOrderAigVisitIntern(manager,Ddi_BddToBaig(fAig),visitedNodes);
  }

}


/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
postOrderBddAigByAuxIntVisitIntern(
  Ddi_Bdd_t *fAig,
  bAig_array_t *visitedNodes,
  int *inOrderTimeP,
  int maxDepth
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *manager = ddm->aig.mgr;

  if (Ddi_BddIsPartConj(fAig) || Ddi_BddIsPartDisj(fAig)) {
    int i, nRoots = Ddi_BddPartNum(fAig);
    Ddi_Bdd_t **roots = Pdtutil_Alloc(Ddi_Bdd_t *, nRoots);

    for (i=0; i<Ddi_BddPartNum(fAig); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(fAig,i);
      roots[i] = f_i;
    }

    qsort((void **)roots,nRoots,sizeof(Ddi_Bdd_t *),AuxIntAigCompare);

    for (i=0; i<nRoots; i++) {
    //    for (i=nRoots-1; i>=0; i--) {
      Ddi_Bdd_t *f_i = roots[i];
      bAigEdge_t fBaig = Ddi_BddToBaig(f_i);
      postOrderAigByAuxIntVisitIntern(manager,fBaig,visitedNodes,
                                      inOrderTimeP,-1);
    }
    Pdtutil_Free(roots);
  }
  else {
    postOrderAigByAuxIntVisitIntern(manager,
      Ddi_BddToBaig(fAig),visitedNodes,inOrderTimeP,-1);
  }

}

/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
postOrderBddAigByMaxRefVisitIntern(
  Ddi_Bdd_t *fAig,
  bAig_array_t *visitedNodes,
  int *inOrderTimeP
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *manager = ddm->aig.mgr;
  int i;
  // compute fanout refs
  bAig_array_t *auxNodes = bAigArrayAlloc();
  Ddi_PostOrderBddAigVisitIntern(fAig,auxNodes,-1);
  postOrderAigClearVisitedIntern(manager,auxNodes);
  for (i=0; i<auxNodes->num; i++) {
    bAigEdge_t baig = auxNodes->nodes[i];
    bAig_AuxRef(manager,baig) = 0;
    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(manager,baig)) {
      continue;
    }
    bAigEdge_t right = bAig_NodeReadIndexOfRightChild(manager,baig);
    bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(manager,baig);
    bAig_AuxRef(manager,right) = bAig_AuxRef(manager,right)+1;
    bAig_AuxRef(manager,left) = bAig_AuxRef(manager,left)+1;
  }

  if (Ddi_BddIsPartConj(fAig) || Ddi_BddIsPartDisj(fAig)) {
    int i, nRoots = Ddi_BddPartNum(fAig);
    Ddi_Bdd_t **roots = Pdtutil_Alloc(Ddi_Bdd_t *, nRoots);

    for (i=0; i<Ddi_BddPartNum(fAig); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(fAig,i);
      roots[i] = f_i;
    }

    qsort((void **)roots,nRoots,sizeof(Ddi_Bdd_t *),AuxIntAigCompare);

    for (i=nRoots-1; i>=0; i--) {
    //    for (i=nRoots-1; i>=0; i--) {
      Ddi_Bdd_t *f_i = roots[i];
      bAigEdge_t fBaig = Ddi_BddToBaig(f_i);
      postOrderAigByMaxAuxRefWithDecrVisitIntern(manager,
        fBaig,visitedNodes,inOrderTimeP);
    }
    Pdtutil_Free(roots);
  }
  else {
    postOrderAigByMaxAuxRefWithDecrVisitIntern(manager,
      Ddi_BddToBaig(fAig),visitedNodes,inOrderTimeP);
  }

  for (i=0; i<auxNodes->num; i++) {
    bAigEdge_t baig = auxNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxRef(manager,baig) == 0,"non 0 aux int");
  }
  //  bAigArrayAuxIntClear(bmgr,auxNodes);
  bAigArrayFree(auxNodes);
}

/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
postOrderBddAigVisitIntern(
  Ddi_Bdd_t *fAig,
  bAig_array_t *visitedNodes,
  int useCnfActive,
  int maxDepth
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *manager = ddm->aig.mgr;

  if (useCnfActive) maxDepth = -101;

  if (Ddi_BddIsPartConj(fAig) || Ddi_BddIsPartDisj(fAig)) {
    int i;
    for (i=0; i<Ddi_BddPartNum(fAig); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(fAig,i);
      postOrderBddAigVisitIntern(f_i,visitedNodes,useCnfActive,maxDepth);
    }
  }
  else {
    postOrderAigVisitIntern(manager,Ddi_BddToBaig(fAig),visitedNodes,maxDepth);
  }

}

/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
postOrderBddAigVisitInternReversed(
  Ddi_Bdd_t *fAig,
  bAig_array_t *visitedNodes,
  int useCnfActive,
  int maxDepth
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  bAig_Manager_t *manager = ddm->aig.mgr;

  if (useCnfActive) maxDepth = -101;

  if (Ddi_BddIsPartConj(fAig) || Ddi_BddIsPartDisj(fAig)) {
    int i;
    for (i=0; i<Ddi_BddPartNum(fAig); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(fAig,i);
      postOrderAigVisitInternReversed(manager,Ddi_BddToBaig(f_i),visitedNodes,maxDepth);
    }
  }
  else {
    postOrderAigVisitInternReversed(manager,Ddi_BddToBaig(fAig),visitedNodes,maxDepth);
  }

}


/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayNodes(
  Ddi_Bddarray_t *fAigArray,
  int maxLevel
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigArray);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  Ddi_Bddarray_t *result;
  int i, nNodes, nRoots = Ddi_BddarrayNum(fAigArray);

  visitedNodes = bAigArrayAlloc();

  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fAigArray,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  }

  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  result = Ddi_BddarrayAlloc(ddm,0);

  nNodes = visitedNodes->num;
  if (maxLevel >= 0) {
    nNodes = bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,maxLevel);
  }

  for (i=0; i<visitedNodes->num; i++) {
    if (i<nNodes) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    Ddi_Bdd_t *n_i = Ddi_BddMakeFromBaig(ddm,baig);
    Ddi_BddarrayInsertLast(result,n_i);
    Ddi_Free(n_i);
    }
  }

  bAigArrayFree(visitedNodes);

  return (result);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_AigPartPropImplications(
  Ddi_Bdd_t *fAigPart,
  Ddi_Bdd_t *constr,
  int propUpOrDown
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigPart);
  int i, np, isDisj = Ddi_BddIsPartDisj(fAigPart);
  int size, size0 = Ddi_BddSize(fAigPart);

  if (isDisj) Ddi_BddNotAcc(fAigPart);

  Pdtutil_Assert(Ddi_BddIsPartConj(fAigPart),"Part Conj DD required");

  np = Ddi_BddPartNum(fAigPart);
  if (constr != NULL) {
    Ddi_Bdd_t *myConstr = Ddi_BddDup(constr);
    int j = propUpOrDown ? np-1: 0;
    Ddi_Bdd_t *f_j = Ddi_BddPartRead(fAigPart,j);
    Ddi_Bdd_t *impliedCube = DdiAigImpliedVarsAcc(myConstr,NULL,NULL);
    if (impliedCube!=NULL) {
      Ddi_AigConstrainCubeAcc(f_j,impliedCube);
      if (1 || i==1) Ddi_BddAndAcc(myConstr,impliedCube);
    }
    Ddi_Free(impliedCube);
    Ddi_Free(myConstr);
  }
  else {
    for (i=1; i<np; i++) {
      int j = propUpOrDown ? i: np-i-1;
      int j0 = propUpOrDown ? i-1: np-i;
      Ddi_Bdd_t *f_j = Ddi_BddPartRead(fAigPart,j);
      Ddi_Bdd_t *f_j0 = Ddi_BddPartRead(fAigPart,j0);
      Ddi_Bdd_t *impliedCube = DdiAigImpliedVarsAcc(f_j0,NULL,NULL);
      if (impliedCube!=NULL) {
        Ddi_AigConstrainCubeAcc(f_j,impliedCube);
        if (1 || i==1) Ddi_BddAndAcc(f_j0,impliedCube);
      }
      Ddi_Free(impliedCube);
    }
  }

  size = Ddi_BddSize(fAigPart);
  fprintf(dMgrO(ddm),"Implication prop: %d -> %d\n", size0, size);

  if (isDisj) Ddi_BddNotAcc(fAigPart);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarraySortByLevel(
  Ddi_Bddarray_t *fAigArray
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigArray);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  Ddi_Bddarray_t *result;
  int i, nRoots = Ddi_BddarrayNum(fAigArray);

  visitedNodes = bAigArrayAlloc();
  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fAigArray,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
  }

  bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,-1);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
  }

  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fAigArray,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    int pos = bAig_AuxInt(bmgr,fBaig);
    Pdtutil_Assert(bAig_NonInvertedEdge(visitedNodes->nodes[pos])==
                   bAig_NonInvertedEdge(fBaig),"wrong AIG node");
    /* fix possible wrong phase */
    visitedNodes->nodes[pos] = fBaig;
    assert(nodeVisited(bmgr, fBaig) >= 4);
    nodeVisited(bmgr,fBaig) -= 4;
  }

  result = Ddi_BddarrayAlloc(ddm,0);
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    if (nodeVisited(bmgr, baig) < 4) {
       Ddi_Bdd_t *n_i = Ddi_BddMakeFromBaig(ddm,baig);
       Ddi_BddarrayInsertLast(result,n_i);
       Ddi_Free(n_i);
    }
  }
  assert(Ddi_BddarrayNum(result) == nRoots);

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
  }

  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fAigArray,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    assert(nodeVisited(bmgr, fBaig) < 4);
    nodeVisited(bmgr,fBaig) += 4;
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  bAigArrayFree(visitedNodes);

  return (result);
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Vararray_t *
Ddi_AigDFSOrdVars(
  Ddi_Bdd_t *fAig
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAig);
  Ddi_Vararray_t *vA;
  Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,1);
  Ddi_BddarrayWrite(fA,0,fAig);
  vA = Ddi_AigarrayDFSOrdVars(fA);
  Ddi_Free(fA);
  return(vA);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Vararray_t *
Ddi_AigarrayDFSOrdVars(
  Ddi_Bddarray_t *fAigArray
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fAigArray);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  bAig_array_t *visitedNodes;
  bAig_array_t *visitedNodes1;
  Ddi_Vararray_t *result;
  int i, nRoots = Ddi_BddarrayNum(fAigArray);
  Ddi_Bdd_t **roots = Pdtutil_Alloc(Ddi_Bdd_t *, nRoots);

  visitedNodes = bAigArrayAlloc();
  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f = Ddi_BddarrayRead(fAigArray,i);
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    postOrderAigVisitIntern(bmgr,fBaig,visitedNodes,-1);
    roots[i] = f;
  }

  /* levelize */
  /* compute levels */
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t right, left, baig = visitedNodes->nodes[i];
    int lr, ll;

    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
      bAig_AuxInt(bmgr,baig) = 0;
      continue;
    }
    right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
    left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
    lr = bAig_AuxInt(bmgr,right);
    ll = bAig_AuxInt(bmgr,left);
    bAig_AuxInt(bmgr,baig) = ((lr < ll) ? ll : lr)+1;
  }

  postOrderAigClearVisitedIntern(bmgr,visitedNodes);

  qsort((void **)roots,nRoots,sizeof(Ddi_Bdd_t *),AuxIntAigCompare);

  visitedNodes1 = bAigArrayAlloc();
  for (i=0; i<nRoots; i++) {
    Ddi_Bdd_t *f = roots[i];
    bAigEdge_t fBaig = Ddi_BddToBaig(f);
    postOrderAigByAuxIntVisitIntern(bmgr,fBaig,visitedNodes1,
                                    NULL,-1);
  }
  postOrderAigClearVisitedIntern(bmgr,visitedNodes1);

  result = Ddi_VararrayAlloc(ddm,0);
  for (i=0; i<visitedNodes1->num; i++) {
    bAigEdge_t baig = visitedNodes1->nodes[i];
    if (bAig_isVarNode(bmgr,baig)&&!bAig_NodeIsConstant(baig)) {
      Ddi_VararrayInsertLast(result,Ddi_VarFromBaig(ddm,baig));
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
  }

  bAigArrayFree(visitedNodes);
  bAigArrayFree(visitedNodes1);

  Pdtutil_Free(roots);

  return (result);
}

/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aigArrayClearVisitedIntern(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes
)
{
  bAigEdge_t nodeIndex;
  int i;

  for (i=0; i<visitedNodes->num; i++) {
    nodeIndex = visitedNodes->nodes[i];
    nodeClearVisited(bmgr,nodeIndex);
  }
}


/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aigArrayClearAuxAigIntern(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes
)
{
  bAigEdge_t nodeIndex;
  int i;

  for (i=0; i<visitedNodes->num; i++) {
    nodeIndex = visitedNodes->nodes[i];
    bAig_AuxAig0(bmgr,nodeIndex) = bAig_AuxAig1(bmgr,nodeIndex) = bAig_NULL;
  }
}

/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aigArrayClearAuxIntIntern(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes
)
{
  bAigEdge_t nodeIndex;
  int i;

  for (i=0; i<visitedNodes->num; i++) {
    nodeIndex = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,nodeIndex) = -1;
  }
}


/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aigArrayLevelizeIntern(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes
)
{
  bAigEdge_t nodeIndex;
  int i;

  /* levelize */
  /* compute levels */
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t right, left, baig = visitedNodes->nodes[i];
    int lr, ll;

    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
      bAig_AuxInt(bmgr,baig) = 0;
      continue;
    }
    right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
    left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
    lr = bAig_AuxInt(bmgr,right);
    ll = bAig_AuxInt(bmgr,left);
    bAig_AuxInt(bmgr,baig) = ((lr < ll) ? ll : lr)+1;
  }

}


/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aigArrayLevelizeMaxFromOutIntern(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes
)
{
  bAigEdge_t nodeIndex;
  int i;

  /* levelize */
  /* compute levels */
  for (i=visitedNodes->num-1; i>=0; i--) {
    bAigEdge_t right, left, baig = visitedNodes->nodes[i];
    int lr, ll, l;

    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
      continue;
    }
    l = bAig_AuxInt(bmgr,baig);
    right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
    left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
    lr = bAig_AuxInt(bmgr,right);
    ll = bAig_AuxInt(bmgr,left);
    if (l>=lr) {
      bAig_AuxInt(bmgr,right) = l+1;
    }
    if (l>=ll) {
      bAig_AuxInt(bmgr,left) = l+1;
    }
  }

}




/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
postOrderAigClearVisitedIntern(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes
)
{
  bAigEdge_t nodeIndex;
  int i;

  for (i=0; i<visitedNodes->num; i++) {
    nodeIndex = visitedNodes->nodes[i];
    if (nodeVisited(bmgr,nodeIndex) >= 4) {
      nodeVisited(bmgr,nodeIndex) -= 4;
    }
  }
}

/**Function********************************************************************
  Synopsis    [Post order AIG visit]
  Description [Post order AIG visit. Visit array is filled with Node indexes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
bfsOrderAigClearVisitedIntern(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes
)
{
  bAigEdge_t nodeIndex;
  int i;

  for (i=0; i<visitedNodes->num; i++) {
    nodeIndex = visitedNodes->nodes[i];
    if (nodeVisited(bmgr,nodeIndex)) {
      nodeVisited(bmgr,nodeIndex) = 0;
    }
  }
}

/**Function********************************************************************
  Synopsis    [merge cache read]
  Description [merge cache read]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
bAigMergeCacheRead(
  bAig_Manager_t *manager,
  bAigEdge_t node0,
  bAigEdge_t node1,
  bAigEdge_t *res
)
{
  int merge;

  if (bAig_NodeIsConstant(node0) || bAig_NodeIsConstant(node1)) {
    *res = bAig_NULL;
    return 0;
  }
  Pdtutil_Assert(node0!=node1,"read cache entry for equal nodes");
  //  aux = bAig_And(manager,node0,node1);
  // *res = bAig_CacheAig(manager,aux)>>2;
  // merge = bAig_CacheAig(manager,aux) & (0x3);
  // Pdtutil_Assert(merge <= 3, "wrong cache entry");
  return (0&&merge);
}


/**Function********************************************************************
  Synopsis    [merge cache write]
  Description [merge cache write]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
bAigMergeCacheWrite(
  bAig_Manager_t *manager,
  bAigEdge_t node0,
  bAigEdge_t node1,
  bAigEdge_t entry,
  int merged
)
{
  bAigEdge_t aux;

  if (bAig_NodeIsConstant(node0) || bAig_NodeIsConstant(node1)) {
    return 0;
  }
  Pdtutil_Assert(node0!=node1,"read cache entry for equal nodes");
  aux = bAig_And(manager,node0,node1);
  bAig_CacheAig(manager,aux) = (bAigEdge_t)((entry<<2)+merged);
  return (1);
}


/**Function********************************************************************
  Synopsis    [compute node aux val]
  Description [compute node aux val]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
bAigNodeComputeAuxVal(
  bAig_Manager_t *bmgr,
  bAigEdge_t baig,
  int cof                  /* 0: compute aux0, 1: aux1, 2: both */
)
{
  bAigEdge_t left, right, r, l;
  bAigEdge_t old, val;
  int changed = 0;
  if (!bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
    right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
    left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
    old = val = bAig_AuxAig0(bmgr,baig);
    if ((cof==0||cof==2) && !bAig_NodeIsConstant(val)) {
      r = bAig_NodeIsInverted(right) ?
          bAig_Not(bAig_AuxAig0(bmgr,right)) : bAig_AuxAig0(bmgr,right);
      l = bAig_NodeIsInverted(left) ?
          bAig_Not(bAig_AuxAig0(bmgr,left)) : bAig_AuxAig0(bmgr,left);
      val = bAig_And(bmgr,r,l);
      bAig_Ref(bmgr, val);
      changed = changed || (val != old);
      bAig_RecursiveDeref(bmgr,old);
      bAig_AuxAig0(bmgr,baig) = val;
    }
    old = val = bAig_AuxAig1(bmgr,baig);
    if ((cof==1||cof==2) && !bAig_NodeIsConstant(val)) {
      r = bAig_NodeIsInverted(right) ?
          bAig_Not(bAig_AuxAig1(bmgr,right)) : bAig_AuxAig1(bmgr,right);
      l = bAig_NodeIsInverted(left) ?
          bAig_Not(bAig_AuxAig1(bmgr,left)) : bAig_AuxAig1(bmgr,left);
      val = bAig_And(bmgr,r,l);
      bAig_Ref(bmgr, val);
      changed = changed || (val != old);
      bAig_RecursiveDeref(bmgr,old);
      bAig_AuxAig1(bmgr,baig) = val;
    }
  }
  return (changed);
}



// StQ 2010.07.07
#if 0
/**Function********************************************************************
  Synopsis    [Ddi_message]
  Description [Print a message for zchaff section]
  SideEffects []
  SeeAlso     [See callzchaff()]
******************************************************************************/
static void zchaffMessage (int which)
{
   switch (which) {
     case 1: fprintf(dMgrO(ddm),"\nError: specified file is not in CNF format\n");
     default: fprintf(dMgrO(ddm),"\nUsage: zchaff <cnf_name> [time_limit]\n");
   }
}

/**Function********************************************************************
  Synopsis    [Ddi_parseClause]
  Description [Parsing a line in order to create a clause for zchaff]
  SideEffects []
  SeeAlso     [See callzchaff()]
******************************************************************************/
static int zchaffParseClause (char *line, int *clause)
{
   int lit, num_lit=0, sign;
   char *space=line;

   do {
      if (sscanf(space, "%d", &lit)!=1)
	 return 0;
      if (lit) { /* note: clause's lenght NOT checked (may exceed the maximum) */
	 sign = lit<0 ? 1 : 0;
	 clause[num_lit++] = ((abs(lit)) << 1) + sign;
	 space = strchr(space, ' ');
	 if (!space) return 0;
	 else space++;
      }
   } while (lit);

   return num_lit;
}


/**Function********************************************************************
  Synopsis    [ddi_printSolution]
  Description [Get zchaff manager and print the solution found]
  SideEffects []
  SeeAlso     [see callzchaff()]
******************************************************************************/
static void zchaffPrintSolution (SAT_Manager zchm)
{
   int i, val;

   for (i=1; i<=SAT_NumVariables(zchm); i++) {
      val = SAT_GetVarAsgnment(zchm, i);
      fprintf(dMgrO(ddm),"%s%d ", val ? "" : "-", i);
   }
   fprintf(dMgrO(ddm),"\n");
}


/**Function********************************************************************
  Synopsis    [compute node aux val]
  Description [compute node aux val]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int *
callZchaff(
  char *cnfFile,
  int timeLimit,
  int *sat
)
{
   int varNum, clauseNum, curr_clause[CLAUSE_SIZE];
   int i, val, result, num_clauses=0, num_lit;
   int *solution=NULL;
   char line[LINE_SIZE];
   SAT_Manager zch_mgr;
   FILE *fin;

   fin = fopen( cnfFile, "r");
   if (!fin) {
   	zchaffMessage(0);
	return 0;
   }

   //printf("Reading %s ... ", cnfFile );
   while (fgets(line, LINE_SIZE-1, fin) && line[0]=='c'); /*skip comments*/
   if (sscanf(line, "p cnf %d %d", &varNum, &clauseNum) != 2) {
   	fclose(fin);
	zchaffMessage(1);
	return 0;
   }

   /* init manager and create all vars */
   zch_mgr = SAT_InitManager();
   SAT_SetNumVariables(zch_mgr, varNum ); // MC 2/9/2004: added SetNumVariables

   /* parse clauses */
   while (fgets(line, LINE_SIZE-1, fin)) {
      num_lit = zchaffParseClause(line, curr_clause);
      if (!num_lit) {
      	fclose(fin);
	zchaffMessage(1);
	return 0;
      }
      num_clauses++;
      SAT_AddClause(zch_mgr, curr_clause, num_lit, 0);
   }
   //printf("%d clauses found\n", num_clauses);
   fclose(fin);

   //   fprintf(dMgrO(ddm),"Solving the SAT problem: ");
   if ( timeLimit > 0 )
   	SAT_SetTimeLimit(zch_mgr, timeLimit);
   result = SAT_Solve(zch_mgr);
   if (result == UNSATISFIABLE) {
   //   	printf("UNSATISFIABLE\n");
      	result = 0;
   }
   else if (result == SATISFIABLE) {
   //      	printf("SATISFIABLE\n");
	solution = Pdtutil_Alloc(int, SAT_NumVariables(zch_mgr)+1);
   	for (i=1; i<=SAT_NumVariables(zch_mgr); i++) {
      		val = SAT_GetVarAsgnment(zch_mgr, i);
      		if( val )
			solution[i-1] = i;
		else
			solution[i-1] = -i;
	}
	solution[i-1] = 0;
	//printf("%s%d ", val ? "" : "-", i);
	result = 1;
   } else {
     //   	printf("UNKNOWN\n");
	result = 0;
   }

   SAT_ReleaseManager(zch_mgr);

   *sat = result;

   return solution;
}
#endif

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
MinisatClauses(
  Solver&    S,
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g,
  int *na,
  int genRelation
)
{
  return MinisatClausesWithSuppFlow(NULL,S,NULL,f,g,NULL,na,NULL,NULL,genRelation,0,0,0);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
MinisatClausesIncr(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g,
  int *na,
  int genRelation
)
{
  return MinisatClausesWithSuppFlow(incrSat,*incrSat->S,incrSat->S22,f,g,
                                    NULL,na,NULL,NULL,genRelation,0,0,0);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
Minisat22Clauses(
  void *S22,
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g,
  int *na,
  int genRelation
)
{
  Solver Sdummy;
  return MinisatClausesWithSuppFlow(NULL,Sdummy,S22,f,g,
                                    NULL,na,NULL,NULL,genRelation,0,0,0);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
aig2CnfClauses(
  Ddi_Bdd_t *f,
  FILE *fp,
  int *clauseNp,
  int *varMaxp
)
{
  int fCnf;
  bAigEdge_t baig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *manager = ddm->aig.mgr;
  vec<Lit> lits;
  int retVal = 0;
  int merged=0;
  bAig_array_t *visitedNodes2 = bAigArrayAlloc();
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  int j;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  aigCnfInfo_t *aigCnfInfo;
  aigCnfMgr_t *aigCnfMgr;
  int phFilter = aigCnfLevel == 2;
  int circSat;
  int circImpl = 0;

  Pdtutil_Assert(clauseNp!=NULL&&varMaxp!=NULL,"NULL clauseN/varMap");
  *clauseNp = *varMaxp = 0;

  if (aigCnfLevel > 4) {
    circImpl = (aigCnfLevel-2);
    aigCnfLevel -= 2;
    phFilter = aigCnfLevel == 2;
  }

  if (Ddi_BddIsPartConj(f)) {
    int i;
    for (i=0; i<Ddi_BddPartNum(f); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
      if (Ddi_BddIsConstant(f_i)) continue;
      postOrderAigVisitIntern(manager,Ddi_BddToBaig(f_i),visitedNodes,-1);
    }
  }
  else {
    postOrderAigVisitIntern(manager,Ddi_BddToBaig(f),visitedNodes,-1);
  }

  postOrderAigClearVisitedIntern(manager,visitedNodes);

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    if (bAig_AuxInt(manager,baig) != 1) {
      bAig_AuxInt(manager,baig) = -1;
    }
  }

  if (1 || (aigCnfLevel>0)) {
    Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,0);
    if (Ddi_BddIsPartConj(f)) {
      int i;
      for (i=0; i<Ddi_BddPartNum(f); i++) {
	Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
	if (Ddi_BddIsConstant(f_i)) continue;
	Ddi_BddarrayInsertLast(fA,f_i);
      }
    }
    else {
      Ddi_BddarrayWrite(fA,0,f);
    }
    aigCnfInfo = genAigCnfInfo(manager,visitedNodes,fA,NULL,NULL,0,0);
    Ddi_Free(fA);
  }

  if (Ddi_BddIsPartConj(f)) {
    int i, j;
    for (i=0; i<Ddi_BddPartNum(f); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
      if (Ddi_BddIsConstant(f_i)) continue;
      baig = f_i->data.aig->aigNode;
      fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                      aig2CnfId(ddm->aig.mgr,baig);
      retVal = fCnf;
      /* fCnf */
      j = bAig_AuxInt(manager,baig);
      //     aigCnfInfo[j].implied = fCnf<0 ? -1 : 1;
      FileStoreClause1(fp,fCnf);
      (*clauseNp)++;
    }
  }
  else {
    int j;
    baig = f->data.aig->aigNode;
    fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                      aig2CnfId(ddm->aig.mgr,baig);
    retVal = fCnf;
    /* fCnf */
    j = bAig_AuxInt(manager,baig);
    //      aigCnfInfo[j].implied = fCnf<0 ? -1 : 1;
    FileStoreClause1(fp,fCnf);
    (*clauseNp)++;
  }

  aigCnfMgr = aigCnfMgrAlloc(ddm,visitedNodes->num);
  aigCnfMgr->aigCnfInfo = aigCnfInfo;
  aigCnfMgr->visitedNodes = visitedNodes;
  //  aigCnfMgr->cutFrontier = NULL;
  aigCnfMgr->nNodes = visitedNodes->num;
  aigCnfMgr->aigCnfLevel = aigCnfLevel;
  aigCnfMgr->phFilter = phFilter;

  circSat = genAigCnfPropImplications(aigCnfMgr);

  for (j=0; j<visitedNodes->num; j++) {

    baig = visitedNodes->nodes[j];

    if (!bAig_isVarNode(manager,baig) && !bAig_NodeIsConstant(baig)) {
      int f, a, b, ir, il;
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(manager,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(manager,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);

      if (aigCnfLevel==0) {
	/* standard tseitin transformation */
	/* convert AIG node to cnf clauses */
	/* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
	f = aig2CnfId(manager,baig);
	a = bAig_NodeIsInverted(right) ? -aig2CnfId(manager,right) :
                                          aig2CnfId(manager,right);
	b = bAig_NodeIsInverted(left) ? -aig2CnfId(manager,left) :
                                         aig2CnfId(manager,left);

	/* f -a -b */
	FileStoreClause3(fp,f,-a,-b);
	/* -f a */
	FileStoreClause2(fp,-f,a);
	/* -f b */
	FileStoreClause2(fp,-f,b);
	(*clauseNp) += 3;
      }
      else {
	if (aigCnfInfo[j].isRoot == 3) {
	  /* Xor */
	  int iA = aigCnfInfo[j].opIds[0];
	  int iB = aigCnfInfo[j].opIds[1];
	  bAigEdge_t baigA = visitedNodes->nodes[abs(iA)-1];
	  bAigEdge_t baigB = visitedNodes->nodes[abs(iB)-1];
	  f = DdiAig2CnfId(manager,baig);
	  a = (iA<0) ? -DdiAig2CnfId(manager,baigA) :
	                DdiAig2CnfId(manager,baigA);
	  b = (iB<0) ? -DdiAig2CnfId(manager,baigB) :
	                DdiAig2CnfId(manager,baigB);
	  Pdtutil_Assert(aigCnfInfo[j].ca->size()==0,"wrong clause array");
          if (circImpl && (aigCnfInfo[j].implied > 0)) {
            {
              /* a = !b */
              /* !a !b */
              aigCnfInfo[j].ca->push();
              (*aigCnfInfo[j].ca)[0].push(MinisatLit(-a));
              (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
              /* a b */
              aigCnfInfo[j].ca->push();
              (*aigCnfInfo[j].ca)[1].push(MinisatLit(a));
              (*aigCnfInfo[j].ca)[1].push(MinisatLit(b));
            }
            if (bAig_isVarNode(manager,baigA)&&!bAig_isVarNode(manager,baigB)) {
              bAigEdge_t t = baigA; baigA = baigB; baigB = t;
              int tI = iA; iA = iB; iB = tI; t = a; a = b; b = t;
            }
            if (circImpl>1 &&
                bAig_isVarNode(manager,baigB)&&!bAig_isVarNode(manager,baigA)) {
              int k;
	      for (k=0; k<aigCnfInfo[abs(iA)-1].ca->size(); k++) {
                Lit lit = (*aigCnfInfo[abs(iA)-1].ca)[k][0];
                int v = var(lit);
                if ((v+1)==abs(a)) {
                  int isCompl = 1; /* this is a!=B */
                  if (sign(lit) ^ a<0) {
                    /* literal different from a */
                    isCompl = !isCompl;
                  }
                  (*aigCnfInfo[abs(iA)-1].ca)[k][0]=
                    (isCompl ? MinisatLit(-b) : MinisatLit(b));
                }
	      }
            }
          }
          else if (circImpl && (aigCnfInfo[j].implied < 0)) {
            /* a = b */
            /* a !b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[0].push(MinisatLit(a));
            (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
            /* !a b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[1].push(MinisatLit(-a));
            (*aigCnfInfo[j].ca)[1].push(MinisatLit(b));
            if (bAig_isVarNode(manager,baigA)&&!bAig_isVarNode(manager,baigB)) {
              bAigEdge_t t = baigA; baigA = baigB; baigB = t;
              int tI = iA; iA = iB; iB = tI; t = a; a = b; b = t;
            }
            if (circImpl>1 &&
                bAig_isVarNode(manager,baigB)&&!bAig_isVarNode(manager,baigA)) {
              int k;
	      for (k=0; k<aigCnfInfo[abs(iA)-1].ca->size(); k++) {
                Lit lit = (*aigCnfInfo[abs(iA)-1].ca)[k][0];
                int v = var(lit);
                if ((v+1)==abs(a)) {
                  int isCompl = 0; /* this is a==B */
                  if (sign(lit) ^ a<0) {
                    /* literal different from a */
                    isCompl = !isCompl;
                  }
                  (*aigCnfInfo[abs(iA)-1].ca)[k][0]=
                    (isCompl ? MinisatLit(-b) : MinisatLit(b));
                }
	      }
            }
          }
          else {
            /* !f !a !b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[0].push(MinisatLit(-f));
            (*aigCnfInfo[j].ca)[0].push(MinisatLit(-a));
            (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
            /* !f a b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[1].push(MinisatLit(-f));
            (*aigCnfInfo[j].ca)[1].push(MinisatLit(a));
            (*aigCnfInfo[j].ca)[1].push(MinisatLit(b));
            /* f a !b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[2].push(MinisatLit(f));
            (*aigCnfInfo[j].ca)[2].push(MinisatLit(a));
            (*aigCnfInfo[j].ca)[2].push(MinisatLit(-b));
            /* f !a b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[3].push(MinisatLit(f));
            (*aigCnfInfo[j].ca)[3].push(MinisatLit(-a));
            (*aigCnfInfo[j].ca)[3].push(MinisatLit(b));
          }
	}
	else if (aigCnfInfo[j].isRoot == 4) {
	  /* ITE */
	  int s;
	  int iS = aigCnfInfo[j].opIds[0];
	  int iA = aigCnfInfo[j].opIds[1];
	  int iB = aigCnfInfo[j].opIds[2];
	  bAigEdge_t baigS = visitedNodes->nodes[abs(iS)-1];
	  bAigEdge_t baigA = visitedNodes->nodes[abs(iA)-1];
	  bAigEdge_t baigB = visitedNodes->nodes[abs(iB)-1];
	  f = DdiAig2CnfId(manager,baig);
	  s = (iS<0) ? -DdiAig2CnfId(manager,baigS) :
	                DdiAig2CnfId(manager,baigS);
	  a = (iA<0) ? -DdiAig2CnfId(manager,baigA) :
	                DdiAig2CnfId(manager,baigA);
	  b = (iB<0) ? -DdiAig2CnfId(manager,baigB) :
	                DdiAig2CnfId(manager,baigB);
	  Pdtutil_Assert(aigCnfInfo[j].ca->size()==0,"wrong clause array");
	  /* s f !b */
	  aigCnfInfo[j].ca->push();
	  (*aigCnfInfo[j].ca)[0].push(MinisatLit(s));
	  (*aigCnfInfo[j].ca)[0].push(MinisatLit(f));
	  (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
	  /* s !f b */
	  aigCnfInfo[j].ca->push();
	  (*aigCnfInfo[j].ca)[1].push(MinisatLit(s));
	  (*aigCnfInfo[j].ca)[1].push(MinisatLit(-f));
	  (*aigCnfInfo[j].ca)[1].push(MinisatLit(b));
	  /* !s f !a */
	  aigCnfInfo[j].ca->push();
	  (*aigCnfInfo[j].ca)[2].push(MinisatLit(-s));
	  (*aigCnfInfo[j].ca)[2].push(MinisatLit(f));
	  (*aigCnfInfo[j].ca)[2].push(MinisatLit(-a));
	  /* !s !f a */
	  aigCnfInfo[j].ca->push();
	  (*aigCnfInfo[j].ca)[3].push(MinisatLit(-s));
	  (*aigCnfInfo[j].ca)[3].push(MinisatLit(-f));
	  (*aigCnfInfo[j].ca)[3].push(MinisatLit(a));
	}
	else if (aigCnfInfo[ir].isRoot || aigCnfInfo[il].isRoot) {
	  /* cut gate, i.e. not an internal one */
	  int ldr = aigCnfInfo[j].ldr;
	  if (aigCnfInfo[ldr].isRoot < 3) {
	    bAigEdge_t baigLdr = visitedNodes->nodes[ldr];
	    Pdtutil_Assert(aigCnfInfo[ldr].isRoot,"wrong leader");
	    f = DdiAig2CnfId(manager,baigLdr);
	    if (aigCnfInfo[ir].isRoot) {
	      int last = aigCnfInfo[ldr].ca->size();
	      Pdtutil_Assert(last>0,"missing clause array");
	      a = bAig_NodeIsInverted(right) ? -DdiAig2CnfId(manager,right) :
		DdiAig2CnfId(manager,right);
	      if (phFilter && (aigCnfInfo[ir].isRoot<3)) {
		if (aigCnfInfo[ir].ref0==1 && aigCnfInfo[ir].ref1==0) {
		  merged ++;
		}
	      }
	      /* -f a */
              if ((aigCnfInfo[ldr].implied == 0)) {
                aigCnfInfo[ldr].ca->push();
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(-f));
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(a));
              }
              else  if ((aigCnfInfo[ldr].implied > 0)) {
                aigCnfInfo[ldr].ca->push();
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(a));
              }
	      /* f -a ... */
	      Pdtutil_Assert(ldr>=ir,"wrong leader");
              if ((circImpl<=2) || (aigCnfInfo[ldr].implied < 1)) {
                (*aigCnfInfo[ldr].ca)[0].push(MinisatLit(-a));
              }
	    }
	    if (aigCnfInfo[il].isRoot) {
	      int last = aigCnfInfo[ldr].ca->size();
	      Pdtutil_Assert(last>0,"missing clause array");
	      b = bAig_NodeIsInverted(left) ? -DdiAig2CnfId(manager,left) :
		DdiAig2CnfId(manager,left);
	      if (phFilter && (aigCnfInfo[il].isRoot<3)) {
		if (aigCnfInfo[il].ref0==1 && aigCnfInfo[il].ref1==0) {
		  merged ++;
		}
	      }
	      /* -f b */
              if ((aigCnfInfo[ldr].implied == 0)) {
                aigCnfInfo[ldr].ca->push();
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(-f));
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(b));
              }
              else  if ((aigCnfInfo[ldr].implied > 0)) {
                aigCnfInfo[ldr].ca->push();
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(b));
              }
	      /* f -b ... */
	      Pdtutil_Assert(ldr>=ir,"wrong leader");
              if ((circImpl<=2) ||(aigCnfInfo[ldr].implied < 1)) {
                (*aigCnfInfo[ldr].ca)[0].push(MinisatLit(-b));
              }
	    }
	  }
	}


      }
    }

  }

  if (aigCnfLevel > 0) {
    for (j=0; j<visitedNodes->num; j++) {
      baig = visitedNodes->nodes[j];
      genAigCnfFileClauses(aigCnfMgr,fp,j,clauseNp);
    }
  }

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    bAig_AuxInt(manager,baig) = -1;
    if (aigCnfLevel>0 && aigCnfInfo[j].ca != NULL) {
      delete aigCnfInfo[j].ca;
    }
  }

  aigCnfMgrFree(aigCnfMgr);

  *varMaxp = ddm->cnf.maxCnfId;

  //  bAigArrayFree(visitedNodes);
  bAigArrayFree(visitedNodes2);

  return (retVal);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
MinisatClausesWithAbstraction(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g
)
{
  int fCnf;
  bAigEdge_t baig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *manager = ddm->aig.mgr;
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  Ddi_Varset_t *flowVars = NULL;
  Ddi_Vararray_t *flowVarsA = NULL;
  Ddi_Bdd_t *fPart, *gPart;
  Ddi_Bddarray_t *fA=NULL, *gA=NULL;
  int i, j, nF, refinementOK=0;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  int phFilter = aigCnfLevel == 2;
  int genVarFlow = aigCnfLevel > 2;
  int refSat = Ddi_AigSatAnd(f,g,NULL);
  aigCnfMgr_t *aigCnfMgr;
  aigCnfInfo_t *aigCnfInfo;

  Solver    S, S1;
  vec<Lit> lits;

  if (refSat) return 1;

  Pdtutil_Assert (f!=NULL && g!=NULL, "Missing f or g term");

  fPart = Ddi_BddDup(f); Ddi_BddSetPartConj(fPart);
  gPart = Ddi_BddDup(g); Ddi_BddSetPartConj(gPart);
  flowVars = Ddi_BddSupp(g);
  flowVarsA = Ddi_VararrayMakeFromVarset(flowVars,1);
  Ddi_Free(flowVars);

  for (i=0; i<Ddi_BddPartNum(fPart); i++) {
    Ddi_Bdd_t *f_i = Ddi_BddPartRead(fPart,i);
    postOrderAigVisitIntern(manager,Ddi_BddToBaig(f_i),visitedNodes,-1);
  }
  nF = visitedNodes->num;
  for (i=0; i<Ddi_BddPartNum(gPart); i++) {
    Ddi_Bdd_t *g_i = Ddi_BddPartRead(gPart,i);
    postOrderAigVisitIntern(manager,Ddi_BddToBaig(g_i),visitedNodes,-1);
  }
  postOrderAigClearVisitedIntern(manager,visitedNodes);

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    Pdtutil_Assert (bAig_AuxInt(manager,baig) == -1, "wrong auxInt field");
    bAig_AuxInt(manager,baig) = j;
  }

  fA = Ddi_BddarrayMakeFromBddPart(fPart);
  gA = Ddi_BddarrayMakeFromBddPart(gPart);

  Ddi_BddarrayAppend(fA,gA);
  Ddi_Free(gA);

  aig2CnfIdInit(ddm);

  aigCnfInfo = genAigCnfInfo(manager,visitedNodes,fA,flowVarsA,NULL,0,0);

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *fg_i = Ddi_BddarrayRead(fA,i);
    baig = fg_i->data.aig->aigNode;
    fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                        aig2CnfId(ddm->aig.mgr,baig);
    while (abs(fCnf) > S.nVars())
      S.newVar();

    /* fCnf */
    MinisatClause1(S,lits,fCnf);
  }

  aigCnfMgr = aigCnfMgrAlloc(ddm,visitedNodes->num);
  aigCnfMgr->aigCnfInfo = aigCnfInfo;
  aigCnfMgr->visitedNodes = visitedNodes;
  //  aigCnfMgr->cutFrontier = NULL;
  aigCnfMgr->nNodes = visitedNodes->num;
  aigCnfMgr->aigCnfLevel = aigCnfLevel;
  aigCnfMgr->phFilter = phFilter;

  genAigCnfGenClauses(aigCnfMgr);
  genAigCnfFlowFrontier(aigCnfMgr,NULL,1);

  for (j=0; j<visitedNodes->num; j++) {
    int k;
    bAigEdge_t baig = visitedNodes->nodes[j];
    int inFlow = aigCnfInfo[j].isVarFlow;
    Solver    *pS = inFlow ? &S: &S1;
    genAigCnfSolverClauses(aigCnfMgr,pS,NULL,NULL,j);
  }

  while (aigCnfMgr->cutFrontierNum>0 && !refinementOK) {
    int sat;

    refinementOK = 0;

    if (!S.okay()) {
      sat = 0;
    }
    else {
      sat = S.solve(-1);
    }
    if (sat) {
      //      printf("SAT\n");
      refinementOK = genAigCnfFlowRefine(aigCnfMgr,&S,&S1);
    }
    else {
      refinementOK = 1;
    }

  }

  if (aigCnfMgr->cutFrontierNum > 0) {
    printf("refinement possible: %d\n", aigCnfMgr->cutFrontierNum);
  }
  if (aigCnfMgr->nNoFlow > 0) {
    printf("no flow cut num: %d/%d (ref: %d)\n",
           aigCnfMgr->nNoFlow, aigCnfMgr->nFlow, aigCnfMgr->nRef);
  }

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    bAig_AuxInt(manager,baig) = -1;
    bAig_AuxRef(manager,baig) = 0;
    if (aigCnfInfo[j].ca != NULL) {
      delete aigCnfInfo[j].ca;
    }
  }

  aigCnfMgrFree(aigCnfMgr);

  aig2CnfIdClose(ddm);

  Ddi_Free(fA);
  Ddi_Free(flowVarsA);
  Ddi_Free(fPart);
  Ddi_Free(gPart);

  return (refinementOK);
}

#if 1
/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static bAig_array_t **
MinisatItpSeqClauses(
  Solver&    S,
  Ddi_Bdd_t *f,
  int *nA
)
{
  int fCnf;
  bAigEdge_t baig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *manager = ddm->aig.mgr;
  vec<Lit> lits;
  int nABaig;
  int np;
  int retVal = 0;
  int i;

  bAig_array_t *visitedNodes = bAigArrayAlloc();
  bAig_array_t **visitedNodesArray = NULL;
  int j, j0;

  Pdtutil_Assert(Ddi_BddIsPartConj(f),"Part CONJ dd required");
  np = Ddi_BddPartNum(f);

  visitedNodesArray = Pdtutil_Alloc(bAig_array_t *, np);

  for (i=0; i<np; i++) {
    Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
    bAig_array_t *visitedNodes2 = bAigArrayAlloc();
    visitedNodesArray[i] = visitedNodes2;
    postOrderAigVisitIntern(manager,Ddi_BddToBaig(f_i),visitedNodes2,-1);
    postOrderAigClearVisitedIntern(manager,visitedNodes2);
  }

  for (i=0; i<np; i++) {
    Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
    bAig_array_t *visitedNodes2;

    visitedNodes2 = visitedNodesArray[i];

    baig = Ddi_BddToBaig(f_i);
    fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                        aig2CnfId(ddm->aig.mgr,baig);
    MinisatClause1(S,lits,fCnf);

    for (j=0; j<visitedNodes2->num; j++) {
      baig = visitedNodes2->nodes[j];
      if (bAig_AuxInt(manager,baig) != -3) {
	/* new node: append to visitedNodes */
        bAigArrayWriteLast(visitedNodes,baig);
        bAig_AuxInt(manager,baig) = -3;
        nodeAuxChar(manager,baig) = 0;

	if (!bAig_isVarNode(manager,baig) && !bAig_NodeIsConstant(baig)) {
	  int f, a, b;
          bAigEdge_t right = bAig_NodeReadIndexOfRightChild(manager,baig);
          bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(manager,baig);

          Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

          /* convert AIG node to cnf clauses */
          /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
          f = aig2CnfId(manager,baig);
          a = bAig_NodeIsInverted(right) ? -aig2CnfId(manager,right) :
                                            aig2CnfId(manager,right);
          b = bAig_NodeIsInverted(left) ? -aig2CnfId(manager,left) :
                                           aig2CnfId(manager,left);

          Pdtutil_Assert (bAig_AuxRef(manager,baig) == 0, "duplicate !");
          if (bAig_AuxRef(manager,baig) == 0) {
            bAig_AuxRef(manager,baig) = 1;

            /* f -a -b */
            MinisatClause3(S,lits,f,-a,-b);
            /* -f a */
            MinisatClause2(S,lits,-f,a);
            /* -f b */
            MinisatClause2(S,lits,-f,b);
          }
        }
      }
    }
    if (nA!=NULL) {
      nA[i] = S.proof->last()+1;
    }
  }

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    if (bAig_AuxInt(manager,baig) != 1) {
      bAig_AuxInt(manager,baig) = -1;
    }
  }

  bAigArrayFree(visitedNodes);

  return (visitedNodesArray);
}
#endif

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
MinisatClauses2Solvers(
  Solver&    S,
  Solver&    S2,
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g,
  int *na,
  int genRelation
)
{
  int fCnf;
  bAigEdge_t baig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *manager = ddm->aig.mgr;
  vec<Lit> lits;
  int nABaig;
  int retVal = 0;

  bAig_array_t *visitedNodes = bAigArrayAlloc();
  bAig_array_t *visitedNodes2 = bAigArrayAlloc();
  int j;

  Pdtutil_Assert (!Ddi_BddIsConstant(f),"Invalid constant baig");

  postOrderAigVisitIntern(manager,Ddi_BddToBaig(f),visitedNodes,-1);
  postOrderAigClearVisitedIntern(manager,visitedNodes);
  nABaig = visitedNodes->num;

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    bAig_AuxInt(manager,baig) = -3;
    nodeAuxChar(manager,baig) = 0;
  }

  if (g!=NULL) {
    postOrderAigVisitIntern(manager,Ddi_BddToBaig(g),visitedNodes2,-1);
    postOrderAigClearVisitedIntern(manager,visitedNodes2);
    for (j=0; j<visitedNodes2->num; j++) {
      baig = visitedNodes2->nodes[j];
      if (bAig_AuxInt(manager,baig) == -3) {
	/* common node: mark */
        nodeAuxChar(manager,baig) = 2;
      }
      else {
	/* new node: append to visitedNodes */
        bAigArrayWriteLast(visitedNodes,baig);
        nodeAuxChar(manager,baig) = 0;
      }

    }

  }

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    if (bAig_AuxInt(manager,baig) != 1) {
      bAig_AuxInt(manager,baig) = -1;
    }
  }

  baig = f->data.aig->aigNode;
  fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                      aig2CnfId(ddm->aig.mgr,baig);

  retVal = fCnf;
  if (!genRelation) {
    /* fCnf */
    MinisatClause1(S,lits,fCnf);
    if (&S2 != &S)
      MinisatClause1(S2,lits,fCnf);

  }

  if (na!=NULL)
    *na = -1;
  for (j=0; j<visitedNodes->num; j++) {
    if (j==nABaig && (na != NULL)) {
      /* a clauses stored */
      Pdtutil_Assert(S.proof!=NULL,"Proof required in SAT manager");
      *na = S.proof->last()+1;
    }

    baig = visitedNodes->nodes[j];

#if 1
    if (j>=nABaig && (na != NULL)) {
      /* b clause: set as global var */
      Pdtutil_Assert(S.proof!=NULL,"Proof required in SAT manager");
      nodeAuxChar(manager,baig) = 1;
    }
#endif

    if (!bAig_isVarNode(manager,baig)) {
      int f, a, b;
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(manager,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(manager,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      /* convert AIG node to cnf clauses */
      /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
      f = aig2CnfId(manager,baig);
      a = bAig_NodeIsInverted(right) ? -aig2CnfId(manager,right) :
                                        aig2CnfId(manager,right);
      b = bAig_NodeIsInverted(left) ? -aig2CnfId(manager,left) :
                                       aig2CnfId(manager,left);


      if (bAig_AuxRef(manager,baig) == 0) {
        bAig_AuxRef(manager,baig) = 1;

        /* f -a -b */
        MinisatClause3(S,lits,f,-a,-b);
        /* -f a */
        MinisatClause2(S,lits,-f,a);
        /* -f b */
        MinisatClause2(S,lits,-f,b);
        if (&S2 != &S) {
          /* f -a -b */
          MinisatClause3(S2,lits,f,-a,-b);
          /* -f a */
          MinisatClause2(S2,lits,-f,a);
          /* -f b */
          MinisatClause2(S2,lits,-f,b);
	}

      }
    }

  }

  if (na!=NULL && *na < 0)
    *na = S.proof->last()+1;

  if (g!=NULL) {
    int gCnf;
    baig = g->data.aig->aigNode;
    nodeAuxChar(manager,baig) = 1;
    gCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(manager,baig) :
                                      aig2CnfId(manager,baig);

    MinisatClause1(S,lits,gCnf);
    /* gCnf */
    if (&S2 != &S)
      MinisatClause1(S2,lits,gCnf);
  }

  bAigArrayFree(visitedNodes);
  bAigArrayFree(visitedNodes2);

  return (retVal);
}

#include "Sort.h"

static int resolve1(vec<Lit>& main, vec<Lit>& other, Var x)
{
    Lit     p;
    bool    ok1 = false, ok2 = false;
    int signMain; // returns non zero if positive phase on main
    for (int i = 0; i < main.size(); i++){
        if (var(main[i]) == x){
            ok1 = true, p = main[i];
            main[i] = main.last();
            main.pop();
            break;
        }
    }

    signMain = sign(p) ? 0 : 1;

    for (int i = 0; i < other.size(); i++){
        if (var(other[i]) != x)
            main.push(other[i]);
        else{
            if (p != ~other[i])
	      fprintf(stderr,"PROOF ERROR! Resolved on variable with SAME polarity in both clauses: %d\n", x+1);
            ok2 = true;
        }
    }

    if (!ok1 || !ok2)
        fprintf(stderr,"PROOF ERROR! Resolved on missing variable: %d\n", x+1);

    sortUnique(main);

    return signMain;
}


typedef struct resClRef {
  vec<Lit>* clp;
  int id;
} resClRef_t;
    
struct compareByLits_lt { bool operator () (resClRef_t x,
                                            resClRef_t y) {
  Var t, x0=var((*(x.clp))[0]), x1=var((*(x.clp))[1]),
    y0=var((*(y.clp))[0]), y1=var((*(y.clp))[1]);
  if (x0>x1) {t=x0; x0=x1; x1=t;}
  if (y0>y1) {t=y0; y0=y1; y1=t;}
  return x0<y0 || (x0==y0)&&(x1<y1); }
};
    
struct Checker : public ProofTraverser {
    vec<vec<ClauseId> >  proofNodes;
    vec<vec<ClauseId> >  proofNodesSave;
    vec<vec<ClauseId> >  remappedNodes;
    vec<vec<Lit> >  remappedResClauses;
    vec<ClauseId>  remap;
    vec<vec<Lit> >  clauses;
    vec<vec<Lit> >  topResClauses;
    vec<vec<Lit> >  clausesSave;
    vec<vec<Lit> >  upperResolutionLits;
    vec<vec<Lit> >  resolutionClauses;
    vec<vec<Lit> >  unitResolutionClauses;
    vec<vec<Lit> >  resolutionClauses2;
    vec<vec<Lit> >  remappedRoots;
    vec<vec<Lit> > vars;
    vec<vec<Lit> > varsSave;
    vec<vec<Lit> > remappedVars;
    vec<interpolantNode_t > nodes;
    vec<vec<Lit> > coreClauses;
    vec<vec<Lit> > hintClauses;
    vec<vec<Lit> > implTable[2];
    vec<vec<int> > implTableIds[2];
    vec<Var> iteVars;
    vec<Var> dummyIteVars;
    vec<char> isRoot;
    vec<char> isRootSave;
    vec<char> isCore;
    vec<char> isCoreSave;
    vec<char> isAresCl;
    vec<char> isBresCl;
    vec<char> isAClause;
    vec<char> isBCore;
    vec<char> isFrontier;
    vec<int> lclToGlbVar;
    vec<int> nResA;
    vec<int> coreVars;
    vec<int> fatherId;
    vec<int> fatherPin;
    vec<char> usedVars;
    vec<int> usedVarsId;
    vec<char> globalVars;
    vec<int> impliedVars;
    vec<int> impliedNode;
    vec<int>  maxPivots;
    vec<Ddi_Bdd_t *>nodeBdd;

    st_table *bddTObaigTable;
    st_generator *stgen;
    Ddi_Vararray_t *auxV;
    Ddi_Bddarray_t *auxF;
    Ddi_Bddarray_t *auxConstr;
    vec<vec<Lit> >  auxConstrClauses;

    int implTableResSize;
    int rootCustomHandling;
    int nLclToGblVars;
    int live0Tot;
    int bddHashTh;
    int bddMergeNum;

    int genResolutionA;
    int genResolutionB;
    int nResCore;
    int genResolution;
    int genResolution2;
    int handleAClauses;

    int constRootsUsed;
    int useRemapped;
    int useMcmRules;
    int reverseInterpolant;
    int nRemappedRoots;
    int zeroConstId;
    int oneConstId;
    int initialAigNodes, sizeThreshold;
    int nSolverVars;
    int nAClauses;
    int nAClausesSave;
    int nAClausesRemapped;
    int nAClausesCore;
    int proofSize;
    int nAndToOr;
    int nOdcFound;
    int itpOptNum;
    int itpOptNum2;
    int itpOptNum3;
    int auxvNum;
    int computeCore;
    int learnBySat;
    int itpSaveCoreResolutions;
    int itpSaveUnitResolutions;
    bAigEdge_t careBaig;
    bAig_Manager_t *bMgr;
    Ddi_Mgr_t *ddiMgr;
    int aborted;
    int partial;
    int enItpOdc;
    int coreSize;
    int itpCalls;
    int implNodesCnt;
    int nANodes;
    int compactOnFile;
    int dontCareOpt;
    int minHintLits;
    int cntImpliedUsedVars;    
    int zeroRoots, oneRoots, literalRoots, clauseRoots;
    int enUseImplTable;

    // constructor
    Checker (Ddi_Mgr_t * ddm, int solverVars=0) {
      ddiMgr = ddm;
      hdmode = ddm->settings.aig.itpMem>=1 ? HD_MODE : MEM_MODE;
      compactOnFile = hdmode>0;
      bMgr = ddm->aig.mgr;
      nSolverVars = solverVars;
      nAClauses = -1;
      nAClausesRemapped = -1;
      proofSize = 0;
      aborted = 0;
      partial = 0;
      nOdcFound = 0;
      itpOptNum = 0;
      itpOptNum2 = 0;
      itpOptNum3 = 0;
      computeCore = 0;
      minHintLits = 0;
      itpSaveCoreResolutions = 0;
      itpSaveUnitResolutions = 0;
      auxvNum = 0;
      careBaig = bAig_NULL;
      enItpOdc = 0;
      enUseImplTable = 0;
      coreSize = 0;
      itpCalls = nItpCalls++;
      genResolutionA = 0;
      genResolutionB = 0;
      nResCore = 0;
      genResolution = 0;
      genResolution2 = 0;
      useRemapped = 0;
      itpSaveCoreResolutions = 0;
      itpSaveUnitResolutions = 0;
      reverseInterpolant = 0;
      constRootsUsed = 0;
      nANodes = 0;
      initialAigNodes = bAigFreeNodeCount(ddm->aig.mgr);
      sizeThreshold = 20000;
      useMcmRules = 1;
      handleAClauses = 0;
      auxV = NULL;
      auxF = NULL;
      auxConstr = NULL;
      dontCareOpt = ddm->settings.aig.itpUseCare;
      zeroConstId=0;
      oneConstId=1;
      rootCustomHandling=0;
    }
    
    inline ClauseId nodeId (const ClauseId id) {
      //Pdtutil_Assert(id>=0,"positive id required");
      return (abs(id));
    }
    inline int invId (const ClauseId id) {
      return (id<0);
    }
    inline int notId (const ClauseId id) {
      if (id==zeroConstId) return oneConstId;
      if (id==oneConstId) return zeroConstId;
      Pdtutil_Assert(id!=-oneConstId && id!=-zeroConstId,"error in not");
      return (-id);
    }
    inline int oneId (const ClauseId id) {
      return (invId(id) ? (id==zeroConstId) : (id==oneConstId));
    }
    inline int zeroId (const ClauseId id) {
      return (invId(id) ? (id==oneConstId) : (id==zeroConstId));
    }


    inline bAigEdge_t mergeOrClause(bAigEdge_t f, Ddi_Bdd_t *bddF) {
      Ddi_Mgr_t *ddm = Ddi_ReadMgr(bddF);
      bAig_Manager_t *bmgr = ddm->aig.mgr;
      Ddi_Bdd_t *fAig = Ddi_BddMakeAig(bddF);
      bAigEdge_t fBaig = bAig_Or(bMgr,f,Ddi_BddToBaig(fAig));
      bAig_Ref(bMgr, fBaig);
      bAig_RecursiveDeref(bMgr,f);
      Ddi_Free(fAig);
      return fBaig;
    }

    inline char isOrToAnd (Var v) {
      if (lclToGlbVar.size()>v && lclToGlbVar[v]) {
	return 1;
      }
      else return 0;
    }

    char isGlobal (Var v) {
      int vCnf;
      if (v>nSolverVars) {
	// dummy var - consider it A var (or) if odd / B var (and) if even
	return (v-nSolverVars)%2;
      }
      if (isOrToAnd(v))
	return 1;
      if (ddiMgr->cnf.solver2cnf != NULL) {
        vCnf = ddiMgr->cnf.solver2cnf[v]+1;
      }
      else {
        vCnf = v+1;
      }
      bAigEdge_t litBaig = ddiMgr->cnf.cnf2aig[vCnf];
      return (nodeAuxChar(bMgr,litBaig)>1&&nodeAuxChar(bMgr,litBaig)<4);
    }

    inline char isBVar (Var v) {
      int vCnf;
      if (v>nSolverVars) {
	// dummy var - consider it A var (or) if odd / B var (and) if even
	return (v-nSolverVars)%2;
      }
      if (isOrToAnd(v))
	return 1;
      if (ddiMgr->cnf.solver2cnf != NULL) {
        vCnf = ddiMgr->cnf.solver2cnf[v]+1;
      }
      else {
        vCnf = v+1;
      }
      bAigEdge_t litBaig = ddiMgr->cnf.cnf2aig[vCnf];
      if (reverseInterpolant) {
	// exclude B vars: take common and A vars
	return (nodeAuxChar(bMgr,litBaig)!=1);
      }
      else {
	return (nodeAuxChar(bMgr,litBaig)>0);
      }

    }

    inline char isCareVar (Var v) {
      int vCnf;
      if (v>nSolverVars) {
	// dummy var - consider it A var (or) if odd / B var (and) if even
	return 0;
      }
      if (ddiMgr->cnf.solver2cnf != NULL) {
        vCnf = ddiMgr->cnf.solver2cnf[v]+1;
      }
      else {
        vCnf = v+1;
      }
      bAigEdge_t litBaig = ddiMgr->cnf.cnf2aig[vCnf];
      return (nodeAuxChar(bMgr,litBaig)>3);
    }

    inline char isAClById (int id) {
      if (!reverseInterpolant) {
        // shared clauses go with A
        return (id < nAClauses || nAClauses<0);
      }
      else {
        // shared clauses go with B
        return (nAClauses<0 || (id >= nAClauses));
      }
    }

    char isACl (int id) {
      if (!handleAClauses) 
	return isAClById (id);
      if (isRoot[id]) {
	vec<Lit>& c0 = clauses[id];
	return isAClById (id);
	//	return (nResA[id] == c0.size());
      }
      else {
	vec<Lit>& xs_id = vars[id];
	return (nResA[id] == xs_id.size());
      }
    }

    inline char isOrRes (int id, int j, Var v) {
      if (v>nSolverVars) {
	// dummy var - consider it A var (or) if odd / B var (and) if even
	return !((v-nSolverVars)%2);
      }
      if (handleAClauses) {
	if (0 && ((j < nResA[id]) == isBVar(v))) {
	  printf("!!!\n");
	}
	return (j < nResA[id] || !isBVar(v));
      }
      else return !isBVar(v);
    }

    inline char isOrResByNres (int nRes, int j, Var v) {
      if (v>nSolverVars) {
	// dummy var - consider it A var (or) if odd / B var (and) if even
	return !((v-nSolverVars)%2);
      }
      if (handleAClauses) {
	return (j < nRes || !isBVar(v));
      }
      else return !isBVar(v);
    }

    int searchEqualRoot (const vec<Lit>& c) {
      int i;
      for (i=remappedRoots.size()-1; i>=0; i--) {
        if (equalLits(remappedRoots[i],c)) return i;
      }
      return -1;
    }

    int equalLits (const vec<Lit>& c0, const vec<Lit>& c1) {
      int i;
      if (c0.size()!=c1.size()) return 0;
      for (i=0; i<c0.size(); i++) {
        if (c0[i]!=c1[i]) return 0;
      }
      return 1;
    }

    void rootWithRemap (const int id, const int fullRemap) {
      vec<Lit>& c = clauses[id];
      int newId = remappedRoots.size();
      int isAClause = isAClById(id);

      //      int id = clauses.size();

      if (fullRemap<0) {
        remappedRoots.push();
        c.copyTo(remappedRoots.last());
      }
      else if (isAClause) {
        /* A clauses */
        vec<Lit> newC;
        newC.clear();
	if (useMcmRules) {
	  for (int i = 0; i < c.size(); i++) {
	    if (isGlobal(var(c[i]))) {
	      /* global var */
	      newC.push(c[i]);
	    }
	  }
	}
        if (newC.size()==0) {
          /* zero clause */
          newId = zeroConstId;
	  zeroRoots++;
        }
        else {
	  if (newC.size()==1) {
	    literalRoots++;
	  }
	  else {
	    clauseRoots++;
	  }
          int myId = -1; // searchEqualRoot(newC);
          if (myId>=0) {
            newId = myId;
          }
          else {
            remappedRoots.push();
            newC.copyTo(remappedRoots.last());
          }
        }
      }
      else {
        int isCareClause = 0;
        int nGlobVars = 0;
        if (dontCareOpt) {
          isCareClause = 1;
          for (int i = 0; i < c.size(); i++) {
            if (!isCareVar(var(c[i]))) {
              /* care var */
              isCareClause = 0;
            }
	    if (isGlobal(var(c[i]))) {
              nGlobVars++;
            }
          }
        }
        if (isCareClause) {
          newId = zeroConstId;
          zeroRoots++;
          if (nGlobVars>0) {
            printf("glob found\n");
          }
        }
        else {
          newId = oneConstId;
          oneRoots++;
        }
      }

      Pdtutil_Assert(remap.size()>id,"problem with remap size");
      remap[id] = newId;

    }

    void root (const vec<Lit>& c) {

        clauses.growTo(isRoot.size());
        clauses.push();
        c.copyTo(clauses.last());

	if (isRoot.size()==0) {
          initialAigNodes = bAigFreeNodeCount(bMgr);
	  sizeThreshold = 20000;
	}

	if (hdmode!=1) {
	  proofNodes.push();
	  vars.push();
	}

        isRoot.push((char)1);
        isCore.push((char)0);

        //        printf("ID: %d\n", id);

    }

    void root1 (const int id) {
        bAigEdge_t rBaig, newrBaig;
	Ddi_Bdd_t *cube=NULL;
	Ddi_Bdd_t *orClause=NULL;
        int rInterp;
        int flag;
	int size = 0;
	int nLit=0;
	int noCube=0;
	int useAuxVars = 0;
        int myId = id;
	int isAClause = isAClById(id);
	int useBddCubes = 0;

	//	if (ddiMgr->settings.aig.itpOpt != 1) nodes[id].cube=NULL;

	nodes[myId].isConst = 1;

        if (useRemapped) {
          //          myId = remap[myId];
        }

        if (useRemapped && myId==zeroConstId) {
          rBaig = bAig_Zero;
	  isAClause=1;
          bAig_Ref(bMgr, rBaig);
	  orClause = useBddCubes ? Ddi_BddMakeConst(ddiMgr,0) :
            NULL;
	  cube=NULL;
        }
        else if (useRemapped && id==oneConstId) {
	  isAClause=0;
          rBaig = bAig_One;
          bAig_Ref(bMgr, rBaig);
	  cube=NULL;
        }
        else if (isAClause && !useMcmRules) {
          rBaig = bAig_Zero;
	  isAClause=1;
          bAig_Ref(bMgr, rBaig);
	  orClause = NULL;//Ddi_BddMakeConst(ddiMgr,0);
	  cube=NULL;
	}
        else if (isAClause) {
          // vec<Lit>& c = useRemapped ? remappedRoots[myId] : clauses[id];
          vec<Lit>& c = clauses[id];
          int useBdds = 0;
          if (useBdds)
            orClause = Ddi_BddMakeConst(ddiMgr,0);
          else 
            orClause = Ddi_BddMakeConstAig(ddiMgr,0);
          for (int i = 0; i < c.size(); i++) {
	    Ddi_Bdd_t *f_i;
	    int vCnf;
            if (ddiMgr->cnf.solver2cnf != NULL) {
              vCnf = ddiMgr->cnf.solver2cnf[var(c[i])]+1;
            }
            else {
              vCnf = var(c[i])+1;
            }
            bAigEdge_t litBaig = ddiMgr->cnf.cnf2aig[vCnf];
            if (nodeAuxChar(bMgr,litBaig) || isOrToAnd(var(c[i]))) {
              /* global var */
#if 0
	      if (nodeAuxChar(bMgr,litBaig)==2) {
		printf("found\n");
	      }
#endif
	      if (impliedVars.size()>0) {
		char impl = impliedVars[var(c[i])];
		if (nodeAuxChar(bMgr,litBaig)==2) {
		  Pdtutil_Assert(1||!bAig_isVarNode(bMgr,litBaig),
				 "Common var is not in required varset (interpolant and)");
		}
		if (impl) {
		  if (!(impl<0) ^ sign(c[i])) {
		    /* same phase - lit implied */
		    Ddi_Free(orClause);
		    rBaig = bAig_One;
		    bAig_Ref(bMgr, rBaig);
		    cube=NULL;
		    isAClause=0;
		    break;
		  }
		  else {
		    /* other phase - lit skipped */
		    continue;
		  }
		}
	      }

	      if (sign(c[i])) {
                litBaig = bAig_Not(litBaig);
	      }
	      f_i = Ddi_BddMakeFromBaig(ddiMgr,litBaig);
              int isBddVar = 0;
              if (bAig_isVarNode(bMgr,litBaig)) {
                Ddi_Var_t *v =
                  (Ddi_Var_t *) bAig_VarPtr(bMgr, litBaig);
                isBddVar = v==NULL || !Ddi_VarIsAig(v);
              }

	      if (!isBddVar) {
		Ddi_BddSetAig(orClause);
	      }
	      if (Ddi_BddIsMono(orClause)) {
		if (bAig_isVarNode(bMgr,litBaig))
		  Ddi_BddSetMono(f_i);
		else {
		  Ddi_BddSetAig(orClause);
		}
	      }
	      Ddi_BddOrAcc(orClause,f_i);

	      Ddi_Free(f_i);
	      nodes[id].isConst = 0;
	      nLit++;
	    }
	  }
	  if (rBaig == bAig_Zero) {
	    //	    fprintf(dMgrO(ddm),"zero clause\n");
	  }
	  if (orClause!=NULL) {
	    if (useBddCubes && Ddi_BddIsMono(orClause)) {
	      rBaig = bAig_Zero;
	    }
	    else {
	      Ddi_BddSetAig(orClause);
	      rBaig = Ddi_BddToBaig(orClause);
	      bAig_Ref(bMgr, rBaig);
	      Ddi_Free(orClause);
	    }
	  }
	} else {
          rBaig = bAig_One;
          bAig_Ref(bMgr, rBaig);
	  cube=NULL;
	}

        //  Pdtutil_Assert(nodes[id].aig == rBaig,"wrong root1");
	nodes[id].aig = rBaig;
	nodes[id].orClause = orClause;
	//	nodes[id].aigSize = size;
        nodes[id].isOdc = 0;
	//        nodes[id].cube = cube;
        nodes[id].optimized = 0;
	nodes[id].AClause = isAClause;
        nodes[id].chainLevel = 0;

    }


    int searchEqualNode (const vec<ClauseId>& cs, const vec<Lit>& xs) {
      int i;
      for (i=remappedNodes.size()-1; i>=nRemappedRoots; i--) {
        if (equalNodes(remappedNodes[i],cs) &&
            equalVars(remappedVars[i],xs,1)) return i;
      }
      return -1;
    }

    int equalNodes (const vec<ClauseId>& cs0, const vec<ClauseId>& cs1) {
      int i;
      if (cs0.size()!=cs1.size()) return 0;
      for (i=0; i<cs0.size(); i++) {
        if (cs0[i]!=cs1[i]) return 0;
      }
      return 1;
    }

    int equalVars (const vec<Lit>& xs0, const vec<Lit>& xs1, const int glob) {
      int i;
      if (xs0.size()!=xs1.size()) return 0;
      for (i=0; i<xs0.size(); i++) {
        if (glob) {
          if (isGlobal(var(xs0[i]))!=isGlobal(var(xs1[i]))) return 0;
        }
        else if (xs0[i]!=xs1[i]) return 0;
      }
      return 1;
    }

    int chainWithRemap (const int id, const int enBddHash, vec<int>& nResA1) {
      vec<ClauseId>& cs = proofNodes[id];
      vec<Lit>& xs = vars[id];
      int newId, ret, eq=0;
      int isConst = 0;
      int joinNode = -1;
      int id0 = invId(cs[0])?notId(remap[nodeId(cs[0])]):remap[cs[0]];
      int firstTerm = 1;
      int nResAnew = 0, firstReplacedByResA = 0;

      static int cnt = 0;
      static int maxCnt = 200;

      if (remap[id]!=id) {
          return 0;
      }

      vec<ClauseId> csNew;
      vec<Lit> xsNew;

      if (zeroId(id0)) {
        isConst = -1;
      }
      else if (oneId(id0)) {
        isConst = 1;
      }

      for (int j = 0; 1 && (j < xs.size()); j++) {
        int id_j = invId(cs[j+1])?notId(remap[nodeId(cs[j+1])]):remap[cs[j+1]];
        int v = var(xs[j]);
        int remove = 0;
	int isAnd = !isOrRes(id,j,v);
	int enConstSimplify = /*(cnt++ < maxCnt) &&*/ (useMcmRules || !isGlobal(v));
        if (firstTerm) {
          if ((id_j == id0) && enConstSimplify) {
            remove = 1;
            Pdtutil_Assert(csNew.size()==0,"wrong cs size");
          }
          else if ((id_j == notId(id0)) && enConstSimplify) {
            remove = 1;
            isConst = isAnd ? -1 : 1;
            id0 = isAnd ? zeroConstId : oneConstId;
            Pdtutil_Assert(csNew.size()==0,"wrong cs size");
          }
          else {
            firstTerm=0;
          }
        }
        if (remove) {
          // skip next part
        }
        else if (isAnd && enConstSimplify) { // AND
          if ((isConst == -1 || zeroId(id_j))) {
            // const 0
            isConst = -1;
            id0 = zeroConstId;
            csNew.clear();
            xsNew.clear();
	    nResAnew=0;
            remove = 1;
          }
          else if (oneId(id_j)) {
            // remove node && keep const 1 or standard id
	    remove = 1;
          }
          else if ((isConst == 1)) {
            // set start node (not const
            id0 = id_j;
            isConst = 0;
            remove = 2;
          }
        }
        else if (!isAnd) { // not global: OR
          if (isConst == 1 || oneId(id_j)) {
            // const 0
            isConst = 1;
            id0 = oneConstId;
	    nResAnew=0;
            remove = 1;
            csNew.clear();
            xsNew.clear();
          }
          else if (zeroId(id_j)) {
            // remove node && keep const 1 or standard id
            remove = 1;
          }
          else if (isConst == -1) {
            // set start node (not const)
            id0 = id_j;
            isConst = 0;
            remove = 2;
          }
        }
	else {
	  Pdtutil_Assert(!useMcmRules,"wrong itp rule");
	  isConst = 0;
	}
#if 0
        int k;
        for (int k = 0; k<j; k++) {
          if (cs[k]==id_j) eq++;
        }
#endif
        // Pdtutil_Assert(id_j<id,"wrong proof node id");
        if (remove==1) {
          // nothing to do
        }
        else if (remove==2) {
          // nothing to do
	  if (handleAClauses && j<nResA[id]) {
	    firstReplacedByResA = 1;
	    // nResAnew++; /* just replaces previous first: do not count */
	  }
        }
        else {
          csNew.push(id_j);
          xsNew.push(xs[j]);
	  if (handleAClauses) {
	    if (j<nResA[id]) nResAnew++;
	  }
        }
      }

      if (0 && firstReplacedByResA) {
	if (nResAnew>0) nResAnew--;
      }

      ret = 1;
      newId = -1;

      if (xsNew.size()==0) {
        if (isConst==-1) newId = zeroConstId;
        else if (isConst==1) newId = oneConstId;
        else {
          newId = id0;
          //          ret = 0;
        }
      }
      else if (0 && isCore[id0]==1 && !isRoot[id0]) {
        // isCore is not updated !!!
        Pdtutil_Assert(!invId(id0),"not yet supported");
        newId = id0;
        csNew.appendTo(remappedNodes[id0]);
        xsNew.appendTo(remappedVars[id0]);
      }

      if (newId<0) {
        /* create new */
        newId = remappedNodes.size();
        remappedNodes.push();
	remappedNodes[newId].clear();
	remappedNodes[newId].push(id0);
	csNew.appendTo(remappedNodes[newId]);
        remappedVars.push();
	xsNew.copyTo(remappedVars[newId]);

	if (resolutionClauses ) {
	  remappedResClauses.push();
	  resolutionClauses[id].copyTo(remappedResClauses[newId]);
	}
	if (handleAClauses) {
	  nResA1.growTo(newId+1);
	  nResA1[newId] = nResAnew;
	}

        if (enBddHash && bddTObaigTable!=NULL) {
          vec<ClauseId>& cs1 = remappedNodes[newId];
          vec<Lit>& xs1 = remappedVars[newId];
          int myId;
          Ddi_Bdd_t *r = nodeBddEval(cs1,xs1,nResAnew);
          if (r==NULL) {
            myId = -1;
          }
          else {
            myId = nodeHashSearchBdd(r,newId);
            if (myId<0) {
              while (nodeBdd.size() <= newId) {
                nodeBdd.push();
                nodeBdd.last() = NULL;
              }
              nodeBdd[newId] = Ddi_BddDup(r);
            }
          }
          Ddi_Free(r);
          //        int myId = searchEqualNode(csNew,xsNew);
          if (myId>=0 /*&& ncall++<6132*/) {
            remappedVars.pop();
            remappedNodes.pop();
	    if (resolutionClauses) {
	      remappedResClauses.pop();
	    }
            newId = myId;
            //          ret = 1;
          }
          else {
            ret = 0;
          }
        }
        else {
          ret = 0;
        }
      }
      remap[id] = newId;
      return ret+eq;
    }

    int chainRootWithRemap (const int id) {
      vec<ClauseId>& cs = proofNodes[id];
      vec<Lit>& xs = vars[id];
      int newId, ret=0, nRA=0;
      int id0 = invId(cs[0])?notId(remap[nodeId(cs[0])]):remap[cs[0]];
      int isConst=0;
      int allRootsOr = !invId(id0) && isRoot[id0];
      int allRootsAnd = !invId(id0) && isRoot[id0] && clauses[id0].size()==1;
      int allRoots = isRoot[id0];
      int optAnd = ddiMgr->settings.aig.itpOpt>6;
      int moveToRoot = 0;
      static int maxResA = -1, cntResA = 0; 

      if (id0 == zeroConstId) {
        isConst = -1;
      }
      else if (id0 == oneConstId) {
        isConst = 1;
      }
      if (0 && (nResA[id]>0)) {
	if (++cntResA>=maxResA) {
	  nResA[id]=0;
	}
      }

      for (int j = 0; (allRootsOr || allRoots || allRootsAnd)
             && (j < xs.size()); j++) {
        //Pdtutil_Assert(!invId(cs[j+1]),"neg node");
        int id_j = invId(cs[j+1])?notId(remap[nodeId(cs[j+1])]):remap[cs[j+1]];
        int v = var(xs[j]);
	int isAnd = !isOrRes(id,j,v);
        allRootsOr &= !invId(id_j) && isRoot[id_j] && !isAnd;
        allRootsAnd &= !invId(id_j) && isRoot[id_j] && isAnd &&
          remappedRoots[nodeId(id_j)].size()==1;
        allRoots &= isRoot[nodeId(id_j)];
	if (allRootsOr) moveToRoot++;
      }

      if (optAnd && allRootsAnd) {
        int k, isEq=1;
        //        printf("root AND(%d)", cs.size());
        for (k=cs.size()-1; isEq && k>0; k--) {
          if (cs[k]==cs[0]) {
            cs.pop(); xs.pop();
          }
          else isEq=0;
        }
        if (cs.size()==1) {
          allRootsAnd = 0;
          allRootsOr = 1;
        }
        else {
          vec<Lit> newC;
          newC.clear();
          for (int j = 0; 1 && (j < cs.size()); j++) {
            Pdtutil_Assert(cs[j]>=0,"negative node");
            int id_j = remap[cs[j]];
            Pdtutil_Assert (id_j != oneConstId && id_j != zeroConstId,
                            "1const id");
            vec<Lit>& r = remappedRoots[id_j];
            Pdtutil_Assert(r.size()==1,"size 1 required");
            newC.push(~r[0]);
          }

          sortUnique(newC);
          int myId = searchEqualRoot(newC);
          if (myId>=0) {
            newId = -myId;
            remap[id] = newId;
            //            isRoot[id] = 1;
          }
          else {
            newId = remappedRoots.size();
            remappedRoots.push();
            newC.copyTo(remappedRoots[newId]);
            //            nRemappedRoots = remappedRoots.size();
            remap[id] = -newId;
            //            isRoot[id] = 1;
          }
          ret++;
        }
        //        printf("\n");
      }

      if (allRootsOr || moveToRoot>0) {
	int nMove = moveToRoot<xs.size() ? moveToRoot+1 : cs.size();
	if (allRootsOr) {
	  nMove = cs.size();
	}
        vec<Lit> newC;
        newC.clear();
	// OR-ing all root clauses: resolution 
        for (int j = 0; 1 && (j < nMove); j++) {
          int id_j = remap[cs[j]];
          if (zeroId(id_j)) continue;
          if (oneId(id_j)) {
            isConst=1;
            break;
          }
          isConst=0;
          vec<Lit>& r = remappedRoots[id_j];
          r.appendTo(newC);
	  if (j>0) {
	    int v = var(xs[j-1]);
	    if (isBVar(v)) {
	      // resolution needed: remove v literals
	      int k, l, res=0;
	      for (k=l=0; l < newC.size(); l++) {
		if (var(newC[l])!=v) {
		  newC[k++] = newC[l];
		}
		else {
		  res++;
		}
	      }
	      while (newC.size()>k) {
		newC.pop();
	      }
	      if (res>0) {
		nAndToOr++;
	      }
	    }
	  }
        }
	if (newC.size()==0) {
	  // zero
	  isConst = -1;
	}
        if (isConst==1) {
	  newId = oneConstId;
	  //          remap[id] = oneConstId;
          //          isRoot[id] = 1;
        }
        else if (isConst==-1) {
	  newId = zeroConstId;
          // remap[id] = zeroConstId;
          //          isRoot[id] = 1;
        }
        else if (1) {
          sortUnique(newC);
          int myId = searchEqualRoot(newC);
          if (myId>=0) {
            newId = myId;
            //            isRoot[id] = 1;
          }
          else if (1 || id>remappedRoots.size()) {
            newId = remappedRoots.size();
            remappedRoots.push();
            newC.copyTo(remappedRoots[newId]);
            //            nRemappedRoots = remappedRoots.size();
            //            isRoot[id] = 1;
          }
	}
	if (moveToRoot>0 && !allRootsOr) {
	  Pdtutil_Assert(moveToRoot<xs.size(),"problem with A clause move");
	  // extra node for remapping
	  // just added to remap array - not a real node
	  cs[0] = remap.size();
	  remap.push(newId);
	  for (int jj = moveToRoot; jj<xs.size(); jj++) {
	    xs[jj-moveToRoot]=xs[jj];
	    cs[jj-moveToRoot+1]=cs[jj+1];
	  }
	  xs.shrink(moveToRoot);
	  cs.shrink(moveToRoot);
	}
	else {
	  remap[id] = newId;
	}
	//	if (isRoot.size()<=newId) {
	// isRoot.growTo(newId+1);
	// }
	//	  isRoot[newId] = 1;
      }
      if (handleAClauses) {
	nResA[id] = 0;
      }

      return ret;
    }


    void resolve0(vec<Lit>& main, vec<Lit>& other, Var x, int partial) {
      Lit     p;
      bool    ok1 = false, ok2 = false;
      for (int i = 0; i < main.size(); i++){
        if (var(main[i]) == x){
	  ok1 = true, p = main[i];
	  main[i] = main.last();
	  main.pop();
	  break;
        }
      }

      for (int i = 0; i < other.size(); i++){
        if (var(other[i]) != x)
	  main.push(other[i]);
        else if (!partial) {
	  Pdtutil_Assert (p==~other[i],
            "PROOF ERROR! Resolved on var with SAME polarity");
	  ok2 = true;
        }
      }

      if (!partial) {
	Pdtutil_Assert (ok1 && ok2,
        "PROOF ERROR! Resolved on missing variable");
      }

      sortUnique(main);
    }

    void resolve(vec<Lit>& main, vec<Lit>& other, Var x, int partial) {
      Lit     p;
      bool    ok1 = false, ok2 = false;
      int i,j;
      vec<Lit> cNew;
      cNew.clear();

      Pdtutil_Assert (!partial, "partial not allowed");

      for (i=j=0; i<main.size() && j<other.size(); ){
        if (var(main[i]) == x) {
	  ok1 = true; i++;
	}
        else if (var(other[j]) == x) {
	  ok2 = true; j++;
	}
	else if (main[i]==other[j]) {
	  cNew.push(main[i]); i++; j++;
	}
	else if (main[i]<other[j]) {
	  cNew.push(main[i]); i++;
	}
	else {
	  cNew.push(other[j]); j++;
	}
      }
      for (; i<main.size(); i++){
        if (var(main[i]) == x) {
	  ok1 = true;
	}
        else {
	  cNew.push(main[i]);
	}
      }
      for (; j<other.size(); j++){
        if (var(other[j]) == x) {
	  ok2 = true;
	}
        else {
	  cNew.push(other[j]);
	}
      }

      Pdtutil_Assert (ok1 && ok2,"PROOF ERROR! Resolved on missing variable");

      main.clear();
      for (i=0; i<cNew.size(); i++){
	main.push(cNew[i]);
      }

    }

    void resolve(vec<Lit>& main, vec<Lit>& other, Var x) {
      int i,j;
      Var v;
      Pdtutil_Assert (!partial, "partial not allowed");

      for (j = 0; j < other.size(); j++) {
	// reset var usage
	v = var(other[j]);
	if (x != var_Undef && v == x) {
	  //reset array and skip
	  usedVars[v] = 0;
	  continue;
	} 
	if (usedVars[v]) {
	  assert(usedVars[v]<0 ? sign(other[j]) : !sign(other[j]));
	}
	else if (x != var_Undef) {
	  main.push(other[j]);
	}
	usedVars[v] = sign(other[j]) ? -1 : 1;
      }
    }

    int redundantResolvent(vec<Lit>& r, vec<Lit>& other, Var x) {
      int j;
      Var v;

      for (j = 0; j < other.size(); j++) {
	// reset var usage
	v = var(other[j]);
        if (!usedVars[v]) {
          return 0;
        }
        return 1;
      }
    }

    int resolveAfterSimp(vec<Lit>& main, vec<Lit>& other,
                         Var x, int doRestructProof) {
      int i,j;
      Var v;
      int res=0, foundRes=0, resetMain=0, chooseOther=0;
      int saveMainSize = main.size();
      Pdtutil_Assert (!partial, "partial not allowed");

      for (j = 0; j < other.size(); j++) {
	// reset var usage
	v = var(other[j]);
	if (x != var_Undef && v == x) {
	  //reset array and skip
          foundRes = 1;
          if (usedVars[v]) {
            assert(usedVars[v]>0 ? sign(other[j]) :
                   !sign(other[j]));
            usedVars[v] = 0;
          }
          else {
            if (doRestructProof) {
              // resolution var only in other. keep main
              resetMain = 1;
              break;
            }
          }
	  continue;
	} 
	if (usedVars[v]) {
	  if (!(usedVars[v]<0 ? sign(other[j]):!sign(other[j]))) {
            if (usedVars[x]!=0) {
              assert(0); // this is an error... multiple resolution
            }
            // change resolution var and remove lit from main
            assert(0); // this is an error... multiple resolution
#if 0
            res = 1;
            newLit = ~other[j];
            usedVars[v] = 0;
            int i,k;
            for (i=k=0; i<main.size(); i++) {
              if (var(main[i])!=v) {
                main[k++]=main[i];
              }
            }
            assert(k==(i-1));
            main.pop();
#endif
          }
        }
	else if (x != var_Undef) {
	  main.push(other[j]);
	}
	usedVars[v] = sign(other[j]) ? -1 : 1;
      }
      if (!foundRes) {
	if (x != var_Undef) {
          if (usedVars[x]) {
            // resolution var only in main, replace with other
            usedVars[x] = 0;
            chooseOther = doRestructProof;
          }
          else {
            // no resolution var, choose heuristically
            if (other.size()<saveMainSize)
              resetMain = 1;
            else
              chooseOther = 1;
          }
        }
      }
      if (resetMain) {
        res = -1;
        while (main.size()>saveMainSize) {
          v = var(main.last());
          usedVars[v] = 0;
          main.pop();
        }
      }
      else if (chooseOther) {
        for (i=0; i<main.size(); i++) {
          // reset usedVars
          v = var(main[i]);
          usedVars[v] = 0;
        }
        other.copyTo(main);
        for (i=0; i<main.size(); i++) {
          // reset usedVars
          v = var(main[i]);
          usedVars[v] = sign(main[i]) ? -1 : 1;
        }
        res = 1;
      }
      return res;
    }

    void resolveStart(void) {
      /* resize usedVars array */
      usedVars.clear();
      usedVars.growTo(nSolverVars+1);
      usedVarsId.clear();
      usedVarsId.growTo(nSolverVars+1);
      for (int i=0; i<=nSolverVars; i++) {
        usedVars[i] = 0;
        usedVarsId[i] = -1;
      }
    }

    void resolveNodeStart(vec<Lit>& c) {
      resolve(c, c, var_Undef);
    }

    void resolveNodeEnd(vec<Lit>& c) {
      int j, k;
      Var v;
      for (j = k =  0; j < c.size(); j++) {
	// reset var usage
	v = var(c[j]);
	if (usedVars[v] != 0) {
	  if (usedVars[v]<0 ? sign(c[j]) : !sign(c[j])) {
            c[k++] = c[j];
          }
          else {
            // just ignore as other phase
          }
	} 
	usedVars[v] = 0;
      }
      c.shrink(j-k);
    }

    void resolveEnd(void) {
      usedVars.clear();
      usedVarsId.clear();
    }

    void chain  (const vec<ClauseId>& cs, const vec<Lit>& xs) {

      if (hdmode!=1) {
        vars.push();
        xs.copyTo(vars.last());
        proofNodes.push();
        cs.copyTo(proofNodes.last());
        //        clauses.push();
      }

      if (partial > 0 && isCore.size() > partial){
        return;
      }

      nItpCalls++;

      isRoot.push((char)0);
      isCore.push((char)0);

    }

    void chain1  (const int id) {
      bAigEdge_t rBaig, newrBaig;
      bAigEdge_t rBaigA, newrBaigA;
      Ddi_Bdd_t *cube=NULL;
      Ddi_Bdd_t *orClause=NULL;
      int rInterp, newrInterp;
      int nodeTotCount0 = bAigFreeNodeCount(bMgr);
      int size,optDone = 0;
      int isOrCube = 0, isAndCube=0, isLiteral=0;
      int nodeCount0 = bAigFreeNodeCount(bMgr);
      int cubeOrDone=0;
      int bddSizeLimit = 500000;
      int prev = nOdcFound;
      int myId = id;
      int isAClause = 1;
      int lastAClause = -1;
      int nNodes=proofNodes.size();
      int i, i0 = 0;
      int chainLevel = 0;

      if (0 && useRemapped) {
        myId = remap[myId];
      }
      vec<ClauseId>& cs = proofNodes[id];
      vec<Lit>& xs = vars[id];
      vec<Lit>& c = clauses[id];

      Pdtutil_Assert(cs.size()-xs.size()==1,"wrong xs/cs sizes");

      if (0 && partial > 0 && isCore.size() > partial){
        return;
      }

      nItpCalls++;
      //      clauses[cs[0]].copyTo(c);

      //      if (ddiMgr->settings.aig.itpOpt != 1) nodes[id].cube=NULL;

      for (int i = xs.size()-1; i>=0; i--) {
        int vCnf;
        bAigEdge_t litBaig;
	if (impliedVars.size()>0 && var(xs[i])<impliedVars.size()) {
	  char impl = impliedVars[var(xs[i])];
	  if (impl) {
	    if (!(impl<0) ^ sign(xs[i])) {
	      /* other phase - prune lower chain */
	      i0 = i+1;
	      break;
	    }
	  } 
	}
      }

      Pdtutil_Assert(nodeId(cs[i0])<nNodes,"wrong nodeId");
      Pdtutil_Assert(isCore[nodeId(cs[i0])],"core");
      rBaig = nodes[nodeId(cs[i0])].aig;
      bAig_Ref(bMgr, rBaig);

      orClause=nodes[nodeId(cs[i0])].orClause;

      for (i = i0; i < cs.size(); i++) {
        Pdtutil_Assert(nodeId(cs[i])<nNodes,"wrong nodeId");
	if (!nodes[nodeId(cs[i])].AClause) {
	  isAClause = 0;
	  break;
	}
      }
      lastAClause = i-1;

      if (orClause != NULL) {
        orClause = Ddi_BddDup(orClause);
      }
      if (invId(cs[i0])) {
        if (orClause != NULL) {
          rBaig = mergeOrClause(rBaig,orClause);
          Ddi_Free(orClause);
        }
        rBaig = bAig_Not(rBaig);
      }

      if (bAig_NodeIsConstant(rBaig)) {
        size = 0;
      }
      else if (bAig_isVarNode(bMgr,rBaig)) {
        size = 1;
      }
      else {
	//        size = nodes[cs[0]].aigSize;
      }

      for (int i = xs.size()-1; i>=i0; i--) {
        int vCnf;
        bAigEdge_t litBaig;
	int isAnd = !isOrRes(id,i,var(xs[i]));
	int isGbl = isGlobal(var(xs[i]));

        Pdtutil_Assert(isCore[nodeId(cs[i+1])],"core");

        if (enItpOdc && useMcmRules) {
          if (nodes[nodeId(cs[i+1])].isOdc) {
            Pdtutil_Assert(i>=0,"wrong itp odc index");
            nOdcFound++;
          }
	  else if (useMcmRules && isAnd && isGbl) {
	    // just disable odc
	  }
          else if (!constRootsUsed ||
                   (nodeId(cs[i+1])!=oneConstId &&
                    nodeId(cs[i+1])!=zeroConstId)) {
            nodes[nodeId(cs[i+1])].isOdc = isAnd ? i+1 : -(i+1);
            if (invId(cs[i+1])) {
              nodes[nodeId(cs[i+1])].isOdc = -nodes[nodeId(cs[i+1])].isOdc;
            }
          }
        }
      }

      if (nodes[nodeId(cs[i0])].isOdc != 0) {
        int odc = nodes[nodeId(cs[i0])].isOdc;
        int odc_i = abs(odc)-1;
        bAig_RecursiveDeref(bMgr,rBaig);
        rBaig = (odc>0) ? bAig_One : bAig_Zero;
        if (invId(cs[i0])) rBaig = bAig_Not(rBaig);
      }
      nodes[nodeId(cs[i0])].isTreeRoot = 0;
      if (nodes[nodeId(cs[i0])].chainLevel > chainLevel) 
        chainLevel = nodes[nodeId(cs[i0])].chainLevel;


      for (int i = i0; i < xs.size(); i++) {
	int isAnd = !isOrRes(id,i,var(xs[i]));
	int isGbl = isGlobal(var(xs[i]));
        int vCnf = (ddiMgr->cnf.solver2cnf != NULL) ?
          ddiMgr->cnf.solver2cnf[var(xs[i])]+1 : var(xs[i])+1;
        bAigEdge_t litBaig = ddiMgr->cnf.cnf2aig[vCnf];
	int doResolve  = 0;
        bAigEdge_t op2;
        Ddi_Bdd_t *orClause2;
	if (!isAnd && isBVar(var(xs[i]))) {
	  nAndToOr++;
	  doResolve = 1;
	}

	if (impliedVars.size()>0 && var(xs[i])<impliedVars.size()) {
	  char impl = impliedVars[var(xs[i])];
	  if (impl) {
	    if ((impl<0) ^ sign(xs[i])) {
	      /* same phase - skip edge */
	      continue;
	    }
	  }
	}

        op2 = nodes[nodeId(cs[i+1])].aig;
        orClause2 = nodes[nodeId(cs[i+1])].orClause;
        if (invId(cs[i+1])) {
          op2 = mergeOrClause(op2,orClause2);
          orClause2 = NULL;
        }

        nodes[nodeId(cs[i+1])].isTreeRoot = 0;
        if (nodes[nodeId(cs[i+1])].chainLevel > chainLevel) 
          chainLevel = nodes[nodeId(cs[i+1])].chainLevel;

        if (nodes[nodeId(cs[i+1])].isOdc != 0) {
          int odc = nodes[nodeId(cs[i+1])].isOdc;
          int odc_i = abs(odc)-1;
          if (i<odc_i) {
            //	    bAig_RecursiveDeref(bMgr,op2);
            op2 = (odc>0) ? bAig_One : bAig_Zero;
            //	      op2 = (odc>0) ? bAig_One : op2;
            //      op2 = (odc>0) ? op2 : bAig_Zero;
          }
        }
        if (invId(cs[i+1])) op2 = bAig_Not(op2);

        if (isAnd) {
          /* global var */
          int doOr = 0; int isIte = 1;
          int termIsOne=0, evalDone=0;
          Ddi_Bdd_t *rClause = NULL, *op2Clause = NULL;
          int freeOp2Clause = 0;

          //	  bAig_Ref(bMgr, rBaig);
          bAig_Ref(bMgr, op2);

          termIsOne |= (op2 == bAig_One) && (!isGbl || useMcmRules);

          if (orClause!=NULL && orClause2!=NULL &&
	      Ddi_BddEqual(orClause,orClause2)) {
            orClause2 = NULL;
            rClause = op2Clause = NULL;
          }
          else if (1 && orClause!=NULL && orClause2==NULL && termIsOne) {
            orClause2 = NULL;
            rClause = op2Clause = NULL;
            bAig_Ref(bMgr, rBaig);
            newrBaig = rBaig;
            evalDone=1;
          }
          else if (1 && orClause==NULL && orClause2!=NULL &&
      	     (rBaig == bAig_One)) {
            orClause = Ddi_BddDup(orClause2);
            orClause2 = NULL;
            rClause = op2Clause = NULL;
            bAig_Ref(bMgr, op2);
            newrBaig = op2;
            evalDone=1;
          }
          else {
            rClause = orClause;
            op2Clause = orClause2;
            orClause = NULL;
            orClause2 = NULL;
          }

          if (rClause!=NULL) {
            Ddi_Bdd_t *rClauseAig = Ddi_BddMakeAig(rClause);
            newrBaig = bAig_Or(bMgr,rBaig,Ddi_BddToBaig(rClauseAig));
            bAig_Ref(bMgr, newrBaig);
            bAig_RecursiveDeref(bMgr,rBaig);
            rBaig = newrBaig;
            Ddi_Free(rClauseAig);
            Ddi_Free(rClause);
          }
          if (op2Clause!=NULL) {
            Ddi_Bdd_t *op2ClauseAig = Ddi_BddMakeAig(op2Clause);
            newrBaig = bAig_Or(bMgr,op2,Ddi_BddToBaig(op2ClauseAig));
            bAig_Ref(bMgr, newrBaig);
            bAig_RecursiveDeref(bMgr,op2);
            op2 = newrBaig;
            Ddi_Free(op2ClauseAig);
            if (freeOp2Clause) Ddi_Free(op2Clause);
          }

          if (!evalDone) {

            //termIsOne |= (op2 == bAig_One);
	    termIsOne |= (op2 == bAig_One) && (!isGbl || useMcmRules);

            if (!termIsOne) {
	      if (doOr) {
		newrBaig = bAig_Or(bMgr,rBaig,op2);
		bAig_Ref(bMgr, newrBaig);
	      }
	      else {
		if (!useMcmRules && isGbl) {
		  bAigEdge_t cof0, cof1;
		  if (sign(xs[i])) {
		    litBaig = bAig_Not(litBaig);
		  }
		  cof0 = bAig_Or(bMgr,op2,bAig_Not(litBaig));
		  bAig_Ref(bMgr, cof0);
		  cof1 = bAig_Or(bMgr,rBaig,litBaig);
		  bAig_Ref(bMgr, cof1);
		  newrBaig = bAig_And(bMgr,cof0,cof1);
		  bAig_Ref(bMgr, newrBaig);
		  bAig_RecursiveDeref(bMgr,cof0);
		  bAig_RecursiveDeref(bMgr,cof1);
		}
		else {
		  newrBaig = bAig_And(bMgr,rBaig,op2);
		  bAig_Ref(bMgr, newrBaig);
		}
	      }
	      //            if (freeOp2) bAig_RecursiveDeref(bMgr,op2);
            }
            else {
	      newrBaig = rBaig;
	      bAig_Ref(bMgr, newrBaig);
            }

          }

          bAig_RecursiveDeref(bMgr,op2);

        } else {
          if (orClause2!=NULL) {
            if (orClause == NULL) {
	      orClause = Ddi_BddDup(orClause2);
            }
            else {
	      if (doResolve) {
		Ddi_Var_t *v = Ddi_VarFromBaig(ddiMgr,litBaig);
		Ddi_Varset_t *sm = Ddi_VarsetMakeFromVar(v);
		Ddi_Bdd_t *orClause2b = Ddi_BddForall(orClause2,sm);
		Ddi_BddForallAcc(orClause,sm);
		Ddi_BddOrAcc(orClause,orClause2b);
		Ddi_Free(orClause2b);
		Ddi_Free(sm);
	      }
	      else {
		Ddi_BddOrAcc(orClause,orClause2);
	      }
            }
          }
          newrBaig = bAig_Or(bMgr,rBaig,op2);
          bAig_Ref(bMgr, newrBaig);
          //          if (freeOp2) bAig_RecursiveDeref(bMgr,op2);
          //          if (freeOp2) bAig_RecursiveDeref(bMgr,op2A);
        }

        if (newrBaig==bAig_One) {
          //Pdtutil_Assert((rBaig==bAig_One)||(op2==bAig_One),"ONE required");
        }
        bAig_RecursiveDeref(bMgr,rBaig);
        rBaig = newrBaig;
        rInterp = newrInterp;
        //	  if (bAigFreeNodeCount(bMgr) > nodeCount0+100 ||
        //              bAigFreeNodeCount(bMgr) > nodeTotCount0+20000) {
      }

      Pdtutil_Assert (initialAigNodes > 0,"invalid node count");

      ddiMgr->stats.aig.itpTerms++;

      if (cube==NULL || Ddi_BddIsZero(cube)) {
        isOrCube = isLiteral = isAndCube = 0;
      }

      if (cube!=NULL && !Ddi_BddIsConstant(cube)) {
        Ddi_Bdd_t *cBar = Ddi_BddNot(cube);
        Pdtutil_Assert(Ddi_BddIsCube(cBar),"wrong cube");
        Ddi_Free(cBar);
      }

      for (int i = i0; i < xs.size(); i++) {
        nodes[nodeId(cs[i+1])].isOdc = 0;
      }
      //     Pdtutil_Assert(nodes[id].aig == rBaig,"wrong chain1");

      nodes[myId].aig = rBaig;
      nodes[myId].orClause = orClause;
      //      printf("BAIG[%d] = %d\n", id, rBaig);
      // if (orClause!=NULL) DdiLogBdd(orClause,0);
      //      nodes[id].cube = cube;
      //      nodes[id].aigSize = size;
      nodes[myId].isOdc = 0;
      nodes[myId].optimized = (char)optDone;
      nodes[myId].isLiteral = isLiteral;
      nodes[myId].isOrCube = isOrCube;
      nodes[myId].isTreeRoot = 1;
      nodes[myId].chainLevel = chainLevel+1;

      nodes[myId].AClause = isAClause;
      if (isAClause) {
	nANodes++;
      }
      if (isFrontier.size()>0 && isFrontier[id]==2
	  && !bAig_NodeIsConstant(nodes[myId].aig)) {
	vec<Lit>& c = resolutionClauses[id];
	char name[100];
	Ddi_Var_t *vAux;
	Ddi_Bdd_t *fAux, *constrAux;
	bAigEdge_t newCube, baigCube = bAig_One;
	if (auxV==NULL) {
	  auxV = Ddi_VararrayAlloc(ddiMgr,0);
	  auxF = Ddi_BddarrayAlloc(ddiMgr,0);
	  auxConstr = Ddi_BddarrayAlloc(ddiMgr,0);
          auxConstrClauses.clear();
	}
        int jConstr=auxConstrClauses.size();
        Pdtutil_Assert(jConstr==Ddi_BddarrayNum(auxConstr),
                       "arrays are not aligner");
        auxConstrClauses.push();
	vec<Lit>& cConstr = auxConstrClauses[jConstr];
	for (int j = 0; j < c.size(); j++) {
	  Lit l_j = c[j];
	  int v_j = var(c[j]);
      	  if (!isGlobal(v_j) && !isBVar(v_j)) continue;
	  int signSat = sign(l_j);
          int vS0 = (ddiMgr->cnf.solver2cnf != NULL) ?
            ddiMgr->cnf.solver2cnf[v_j] : v_j;
          int vCnf = vS0+1;
	  bAigEdge_t baig = ddiMgr->cnf.cnf2aig[vCnf];
	  if (!signSat) baig = bAig_Not(baig); // take complement of lit
	  newCube = bAig_And(bMgr,baigCube,baig);
	  bAig_Ref(bMgr, newCube);
	  bAig_RecursiveDeref(bMgr,baigCube);
	  baigCube = newCube;
          // bring to original solver vars
          cConstr.push(signSat?~Lit(vS0):Lit(vS0));
	}
	sprintf(name,"ITP_AUXV_%d",Ddi_VararrayNum(auxV));
	vAux = Ddi_VarFromName(ddiMgr,name);
	if (vAux == NULL) {
	  vAux = Ddi_VarNewBaig(ddiMgr,name);
	}
	fAux = Ddi_BddMakeFromBaig(ddiMgr, nodes[myId].aig);
#if 1
	bAig_RecursiveDeref(bMgr,nodes[myId].aig);
	nodes[myId].aig = Ddi_VarToBaig(vAux);
	bAig_Ref(bMgr, nodes[myId].aig);
#endif		
	Ddi_VararrayInsertLast(auxV,vAux);
	Ddi_BddarrayInsertLast(auxF,fAux);
	Ddi_Free(fAux);

        constrAux = Ddi_BddMakeFromBaig(ddiMgr, baigCube);
	bAig_RecursiveDeref(bMgr,baigCube);
	Ddi_BddarrayInsertLast(auxConstr,constrAux);
	Ddi_Free(constrAux);
      }

    }

    void chain1a  (const int id) {
      bAigEdge_t rBaig, newrBaig;
      bAigEdge_t rBaigA, newrBaigA;
      Ddi_Bdd_t *cube=NULL;
      int rInterp, newrInterp;
      int nodeTotCount0 = bAigFreeNodeCount(bMgr);
      int size,optDone = 0;
      int isOrCube = 0, isAndCube=0, isLiteral=0;
      int nodeCount0 = bAigFreeNodeCount(bMgr);
      int cubeOrDone=0;
      int bddSizeLimit = 500000;
      int prev = nOdcFound;

      vec<ClauseId>& cs = proofNodes[id];
      vec<Lit>& xs = vars[id];
      vec<Lit>& c = clauses[id];

      if (0 && partial > 0 && isCore.size() > partial){
        return;
      }

      nItpCalls++;
      clauses[cs[0]].copyTo(c);

      //      if (ddiMgr->settings.aig.itpOpt != 1) nodes[id].cube=NULL;


      Pdtutil_Assert(isCore[cs[0]],"core");
      rBaig = nodes[cs[0]].aig;
      bAig_Ref(bMgr, rBaig);
      rBaigA = nodes[cs[0]].aig;
      bAig_Ref(bMgr, rBaigA);
      if (bAig_NodeIsConstant(rBaig)) {
        size = 0;
      }
      else if (bAig_isVarNode(bMgr,rBaig)) {
        size = 1;
      }
      else {
        // size = nodes[cs[0]].aigSize;
      }

      if (1)
        for (int i = 0; i < xs.size(); i++) {
          Pdtutil_Assert(nodes[cs[i+1]].isOdc==0,"odc itp wrong initial val");
	}

      for (int i = xs.size()-1; i>=0; i--) {
        int vCnf;
        bAigEdge_t litBaig;
        int isAnd;
        if (ddiMgr->cnf.solver2cnf != NULL) {
          vCnf = ddiMgr->cnf.solver2cnf[var(xs[i])]+1;
        }
        else {
          vCnf = var(xs[i])+1;
        }
        litBaig = ddiMgr->cnf.cnf2aig[vCnf];
        isAnd = nodeAuxChar(bMgr,litBaig)>0;

        Pdtutil_Assert(isCore[cs[i+1]],"core");
        if (enItpOdc) {
          if (nodes[cs[i+1]].isOdc) {
            Pdtutil_Assert(i>=0,"wrong itp odc index");
            nOdcFound++;
          }
          else {
            nodes[cs[i+1]].isOdc = isAnd ? i+1 : -(i+1);
          }
        }
      }

      if (nodes[cs[0]].isOdc != 0) {
        int odc = nodes[cs[0]].isOdc;
        int odc_i = abs(odc)-1;
        bAig_RecursiveDeref(bMgr,rBaig);
        rBaig = (odc>0) ? bAig_One : bAig_Zero;
      }

#if 0
      if (nodes[cs[0]].cube != NULL) {
        cube = Ddi_BddDup(nodes[cs[0]].cube);
        isOrCube = nodes[cs[0]].isOrCube;
        isAndCube = nodes[cs[0]].isAndCube;
        isLiteral = nodes[cs[0]].isLiteral;
      }
#endif
      nodes[cs[0]].isTreeRoot = 0;
      for (int i = 0; i < xs.size(); i++) {
        int vCnf = (ddiMgr->cnf.solver2cnf != NULL) ?
          ddiMgr->cnf.solver2cnf[var(xs[i])]+1 : var(xs[i])+1;
        bAigEdge_t litBaig = ddiMgr->cnf.cnf2aig[vCnf];
        bAigEdge_t op2 = nodes[cs[i+1]].aig;
        bAigEdge_t op2A = nodes[cs[i+1]].aig;
	//        Ddi_Bdd_t *cube2 = nodes[cs[i+1]].cube;
        int freeOp2=0;
        nodes[cs[i+1]].isTreeRoot = 0;

        if (nodes[cs[i+1]].isOdc != 0) {
          int odc = nodes[cs[i+1]].isOdc;
          int odc_i = abs(odc)-1;
          if (i<odc_i) {
            op2 = (odc>0) ? bAig_One : bAig_Zero;
            //	      op2 = (odc>0) ? bAig_One : op2;
            //      op2 = (odc>0) ? op2 : bAig_Zero;
          }
        }

        if (bAig_isVarNode(bMgr,op2)) {
          size += 1;
        }
        else if (!bAig_NodeIsConstant(op2)) {
	  //          size += nodes[cs[i+1]].aigSize+1;
        }

        if (nodeAuxChar(bMgr,litBaig)>0) {
          /* global var */
          int doOr = 0; int isIte = 1;
          int termIsOne=0;

          termIsOne |= (op2 == bAig_One);
	  //          termIsOne |= (cube2 != NULL && Ddi_BddIsOne(cube2));

 	  if (termIsOne) {
            itpOptNum2++;
          }

          if (!termIsOne) {
            if (doOr) {
              newrBaig = bAig_Or(bMgr,rBaig,op2);
              newrBaigA = bAig_Or(bMgr,rBaigA,op2A);
            }
            else {
              newrBaig = bAig_And(bMgr,rBaig,op2);
              newrBaigA = bAig_And(bMgr,rBaigA,op2A);
            }
            bAig_Ref(bMgr, newrBaig);
            bAig_Ref(bMgr, newrBaigA);
            if (freeOp2) bAig_RecursiveDeref(bMgr,op2);
            if (freeOp2) bAig_RecursiveDeref(bMgr,op2A);
            bAig_Deref(bMgr, newrBaig);
            bAig_Deref(bMgr, newrBaigA);
          }
          else {
            newrBaig = rBaig;
            newrBaigA = rBaigA;
          }

        } else {
          newrBaig = bAig_Or(bMgr,rBaig,op2);
          newrBaigA = bAig_Or(bMgr,rBaigA,op2A);
          bAig_Ref(bMgr, newrBaig);
          bAig_Ref(bMgr, newrBaigA);
          if (freeOp2) bAig_RecursiveDeref(bMgr,op2);
          if (freeOp2) bAig_RecursiveDeref(bMgr,op2A);
          bAig_Deref(bMgr, newrBaig);
          bAig_Deref(bMgr, newrBaigA);
        }

        bAig_Ref(bMgr, newrBaig);
        bAig_Ref(bMgr, newrBaigA);
        if (newrBaig==bAig_One) {
          //Pdtutil_Assert((rBaig==bAig_One)||(op2==bAig_One),"ONE required");
        }
        bAig_RecursiveDeref(bMgr,rBaig);
        bAig_RecursiveDeref(bMgr,rBaigA);
        rBaig = newrBaig;
        rBaigA = newrBaigA;
        rInterp = newrInterp;
        //	  if (bAigFreeNodeCount(bMgr) > nodeCount0+100 ||
        //              bAigFreeNodeCount(bMgr) > nodeTotCount0+20000) {

      }

      Pdtutil_Assert (initialAigNodes > 0,"invalid node count");

      ddiMgr->stats.aig.itpTerms++;

      if (cube==NULL || Ddi_BddIsZero(cube)) {
        isOrCube = isLiteral = isAndCube = 0;
      }

      if (cube!=NULL && !Ddi_BddIsConstant(cube)) {
        Ddi_Bdd_t *cBar = Ddi_BddNot(cube);
        Pdtutil_Assert(Ddi_BddIsCube(cBar),"wrong cube");
        Ddi_Free(cBar);
      }

      for (int i = 0; i < xs.size(); i++) {
        nodes[cs[i+1]].isOdc = 0;
      }
      //     Pdtutil_Assert(nodes[id].aig == rBaig,"wrong chain1");
      nodes[id].aig = rBaig;
      //      nodes[id].cube = cube;
      //      nodes[id].aigSize = size;
      nodes[id].isOdc = 0;
      nodes[id].optimized = (char)optDone;
      nodes[id].isLiteral = isLiteral;
      nodes[id].isOrCube = isOrCube;
      nodes[id].isTreeRoot = 1;

      if (0) {
        Ddi_Bdd_t *a = Ddi_BddMakeFromBaig(ddiMgr, rBaig);
        Ddi_Bdd_t *b = Ddi_BddMakeFromBaig(ddiMgr, rBaigA);
        Ddi_Bdd_t *c = Ddi_BddXor(a,b);
        Ddi_BddSetMono(a);
        Ddi_BddSetMono(b);
        Ddi_BddSetMono(c);
        Pdtutil_Assert(Ddi_BddIsZero(c),"wrong odc simplification");
        Ddi_Free(a);
        Ddi_Free(b);
        Ddi_Free(c);
      }
      bAig_RecursiveDeref(bMgr,rBaigA);

    }

    void getClausesFromFileNode( File& fp, int64 fpNode, int id,
                             vec<ClauseId>& cs, vec<Lit>& xs) {
      Lit l;
      uint64 tmp;
      assert(!fp.null());
      fp.seek(fpNode);
      //fp.seek(53);
      //fp.seek(53);
      tmp = getUInt(fp);
      if ((tmp & 1) == 0){
        // Root clause:
        cs.clear();
      } else {
        //Chain
        xs.clear();
        cs.clear();
        cs.push(id - (tmp >> 1));
        for(;;){
          //chain var
          tmp = getUInt(fp);
          if (tmp == 0) break;
          xs.push(l.toLit(tmp - 1));
          //chain ID
          tmp = getUInt(fp);
          cs.push(id - tmp);
        }
      }

      //return cs;

    }


    void core () {
      int i, j, n, nr, nr0, idLast;
      File fp;

      if (hdmode) {
        // Switch to read mode:
        //fp.setMode(READ);
        //fp.seek(0);
        fp.open(fileName,"r");
        assert(!fp.null());
      }

      n=nr=nr0=0;

      if (hdmode) {
        idLast = refNodeVector.size()-1;
        proofNodes.growTo(idLast+1);
        vars.growTo(idLast+1);
      }
      else
        idLast = proofNodes.size()-1;

      isCore[idLast] = 1;

      for (int i = idLast; i>=0; i--) {

	vec<ClauseId> cs1;
        vec<ClauseId> cs2;
        vec<ClauseId> cs;
        vec<Lit> xs;

        switch(hdmode) {
	case P_MODE://parallel mode
	  getClausesFromFileNode(fp,refNodeVector[i],i,cs1,xs);
          vars[i].copyTo(xs);
	  proofNodes[i].copyTo(cs2);
	  for(int h=0;h<cs2.size();h++) {
            assert(cs1[h]==cs2[h]);
          }
	  cs1.copyTo(cs);

	  break;

	case HD_MODE://HD mode
	  getClausesFromFileNode(fp,refNodeVector[i],i,cs,xs);
	  break;

	case MEM_MODE:
	default :
	  proofNodes[i].copyTo(cs);
	  vars[i].copyTo(xs);

	}

        //        vec<Lit>& xs = vars[i];

        proofNodes[i].clear();
        vars[i].clear();
        if (!isCore[i] && !isRoot[i]) {
          for (int j = 0; 1 && (j < cs.size()); j++) {
            int id = cs[j];
            if (isRoot[id] && !isCore[id]) {
              isCore[id] = -1;
            }
          }
          continue;
        }
        if (isRoot[i] && isCore[i]<0) { nr0++; continue; }
        if (isCore[i] < 1) continue;
        if (isRoot[i]) { nr++; continue; }

        if (!computeCore || genResolutionB) {
          /* this is in core - update arrays */
          xs.copyTo(vars[i]);
          cs.copyTo(proofNodes[i]);
        }

        for (int j = 0; j < cs.size(); j++) {
          int id = cs[j];
          if (isCore[id] >= 1)
            isCore[id] = 2;
          else
            isCore[id] = 1;
        }
        n++;
      }

      fp.close();

      
      nResA.clear();
      if (handleAClauses) {
	nResA.growTo(idLast+1);
	for (int i=0; i<=idLast; i++) {
	  vec<ClauseId>& cs = proofNodes[i];
	  vec<Lit>& xs = vars[i];

	  nResA[i] = 0;
	  if (isCore[i] < 1) continue;

	  if (isRoot[i]) {
	    vec<Lit>& c0 = clauses[i];

	    if (isAClById (i)) {
	      nResA[i] = c0.size();
	    }
	    continue;
	  }

	  int isA = 1;
	  for (j = 0; j < cs.size(); j++) {
	    int jj = nodeId(cs[j]);
	    if (!isACl(jj)) {
	      isA=0;
	      break;
	    }
	  }
	  nResA[i] = j==0 ? 0 : j-1;
	  assert(isA == isACl(i));
	}
      }

      int nUnitRes = 0, nUnitResA=0, nUnitResB=0, nUnitResAB=0;
      int nTwoRes = 0, nTwoResAB = 0;
      int nUnitEq = 0;      
      if (genResolution || genResolution2 || genResolutionB) {
        vec<char> unitVars;
        unitVars.clear();
        unitVars.growTo(nSolverVars+1);
        vec<Lit> c;
        for (int i=0; i<=nSolverVars; i++) {
          unitVars[i] = 0;
        }
	resolveStart();
	for (int i=0; i<=idLast; i++) {
	  vec<ClauseId>& cs = proofNodes[i];
	  vec<Lit>& xs = vars[i];
	  resolutionClauses.growTo(i+1);
	  vec<Lit>& cOld = resolutionClauses[i];
	  char isBClause=1;

	  if (isCore[i] < 1) continue;

	  if (genResolution2 || genResolutionB) {
	    isAClause.growTo(i+1);
	    isAClause[i] = (char)(1);
	  }

	  if (isRoot[i]) {
	    vec<Lit>& c0 = clauses[i];

	    if ((genResolution2 || genResolutionB) && i >= nAClauses) {
	      isAClause[i] = (char)-1;
	    }
	    else {
	      isBClause = 0;
	    }

      	    if (!genResolution && (isAClause[i]==0)) continue;

	    c0.copyTo(resolutionClauses[i]);
	    continue;
	  }

	  if (!genResolution) {
	    int again = 3;
	    for (int j = 0; again && (j < cs.size()); j++) {
	      int jj = nodeId(cs[j]);
	      switch (isAClause[jj]) {
	      case 0:
		isAClause[i] = (char)0;
		isBClause = (char)0;
		again = 0;
		break;
	      case -1:
		isAClause[i] = (char)0;
		again = again & ~0x1;
		break;
	      case 1:
		isBClause = (char)0;
		again = again & ~0x2;
		break;
	      default:
		Pdtutil_Assert(0,"wrong AB clause code");
	      }
	    }

	  }

	  Pdtutil_Assert (cs.size()>0, "null proof node");
	  c.clear();

	  if (!genResolution && isBClause) {
	    isAClause[i] = (char)(-1);
	  }

	  if (!genResolution) {
	    if (genResolution2) {
	      if (isAClause[i] < 1) 
		continue;
	    }
	    else {
	      Pdtutil_Assert(genResolutionB,"invalid resolution option");
	      if (!isAClause[i] && !isBClause) 
		continue;
	    }
	  }

	  resolutionClauses[nodeId(cs[0])].copyTo(c);
	  if (0 && (i==60543)) {
	    printf ("aaa\n");
	  }
	  resolveNodeStart(c);
	  for (int j = 0; j < xs.size(); j++) {
	    int jj = nodeId(cs[j+1]);
	    resolve(c, resolutionClauses[nodeId(cs[j+1])], var(xs[j]));
	  }
	  resolveNodeEnd(c);
          if (c.size()==1) {
            Var v = var(c[0]);
            if (isGlobal(v)) nUnitResAB++;
            else if (isBVar(v)) nUnitResB++;
            else nUnitResA++;
            nUnitRes++;
            assert(v<=nSolverVars);
            if (unitVars[v]>0) {
              nUnitEq++;
            }
            unitVars[v]++;
          }
          else if (c.size()==2) {
            Var v0 = var(c[0]);
            Var v1 = var(c[1]);
            if (isGlobal(v0)||isGlobal(v1)) nTwoResAB++;
            nTwoRes++;
          }
          else if (c.size()==0 && i<idLast) {
            printf("constant resolution clause\n");
          }
          c.copyTo(cOld);
	}
	resolveEnd();
        Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
           printf("ITP proof unit res. cl,: %d(A:%d/B:%d/AB:%d - equiv:%d)\n",
                  nUnitRes,nUnitResA,nUnitResB,nUnitResAB,nUnitEq));
        Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
           printf("ITP proof two res. cl: %d(AB:%d)\n",
                  nTwoRes,nTwoResAB));
      }

      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
       printf("ITP core: (%d,%d + %d) / %d\n",
	      nr, nr0, n, idLast+1));

    }

    void proofCore  () {
      int i, j, n=0, nn=0, nr=0, nr0=0, nDagRef2=0, idLast;
      File fp;
      idLast = proofNodes.size()-1;

      if (idLast<1) return;

      for (int i = idLast; i>=0; i--) {
        isCore[i] = 0;
	if (partial && i>= clauses.size()) 
	  isCore[i] = 1;
      }
      fatherId.growTo(idLast+1);
      fatherPin.growTo(idLast+1);
      for (int i = idLast; i>=0; i--) {
        fatherId[i] = -1;
        fatherPin[i] = -1;
      }

      if (!partial) {
	isCore[idLast] = 1;
      }
      if (constRootsUsed) {
        isCore[0] = isCore[1] = 1;
      }

      for (int i = idLast; i>=0; i--) {

	vec<ClauseId> cs1;
        vec<ClauseId> cs2;
        vec<Lit> xs;

        vec<ClauseId>& cs = proofNodes[i];

        if (!isCore[i] && !isRoot[i]) {
          for (int j = 0; 1 && (j < cs.size()); j++) {
            int id = nodeId(cs[j]);
            if (isRoot[id] && !isCore[id]) {
              isCore[id] = -1;
            }
          }
          continue;
        }
        if (isRoot[i] && isCore[i]<0) { nr0++; continue; }
        if (isCore[i] < 1) continue;
        if (isRoot[i]) { nr++; continue; }

        for (int j = cs.size()-1; j>=0; j--) {
          int id = nodeId(cs[j]);
          if (isCore[id] >= 1) {
            int f_id = fatherId[id];
            int f_i = fatherId[i];
            isCore[id] = 2; 
            if (f_id != i) {
              int ii=i;
              while (isCore[ii] == 1 && f_i >= 0 && f_i != f_id) {
                // iterate search of common node
                ii = f_i; f_i = fatherId[ii];
              }
              if (f_i >= 0 && f_i == f_id) {                
                // common found 
                if (fatherPin[id] < fatherPin[ii]) {
                  // fatherId[id] = -1; // reset/disable
                  if (1 || j==0) 
                    fatherId[id] = -1; // reset/disable
                  else
                    fatherPin[id] = fatherPin[ii]; // redirect
                }
              }
              else {
                fatherId[id] = -1; // reset
              }
            }
          }
          else {
            isCore[id] = 1;
            if (!isRoot[id]) {
              fatherId[id] = i;
              fatherPin[id] = j;
            }
          }
        }
        nn += (cs.size()-1);
        n++;
      }

      for (int i = idLast; i>=0; i--) {
        if (fatherId[i]>=0) nDagRef2++;
      }

      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
       printf("ITP proof core: (root: %d,%d + chain: %d (res: %d) - ref2: %d) / tot:%d\n",
	      nr, nr0, n, nn, nDagRef2, idLast+1));

    }

    int proofCoreReducePreprocess (int enVarReduce) {

      vec<char> mark;
      int idLast = proofNodes.size()-1;
      int cntDup = 0;
      if (idLast<1) return 0;

      vec<ClauseId>& cs = proofNodes[idLast];

      mark.clear();
      mark.growTo(idLast+1);
      for (int i = idLast; i>=0; i--) {
        mark[i] = 0;
      }
      
      cntImpliedUsedVars=0;

      // avoid cs[0]
      for (int j = 1; j < cs.size(); j++) {
        int id = nodeId(cs[j]);
        if (isCore[id] >= 1) mark[id] = 1;
      }

      for (int i = idLast; i>=0; i--) {

        if (mark[i]) {
        
          vec<ClauseId>& cs = proofNodes[i];

          cntDup += reduceNode(i, enVarReduce, NULL);

          for (int j = 0; j < cs.size(); j++) {
            int id = nodeId(cs[j]);
            assert(isCore[id]);
            mark[id] = 1;
          }

        }
      }

      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
        printf("ITP proof preproc red impl/tot: %d/%d\n",
               cntImpliedUsedVars, cntDup));
      
    }

    int topLevelImply(int id, int phase, int enRecur=1) {
      int useAnd = phase>0;
      int j, ret = 1;
      // int enRecur = 1 && (isCore[nodeId(id)]==1);
      int doRecur = enRecur || (isCore[nodeId(id)]==1);
      if (isCore[nodeId(id)]>1 && enRecur>0)
        enRecur--;
      static int nImpl = 0;
      static int nCalls = 0;
      nCalls++;

      Pdtutil_Assert(id>=0,"neg id not allowed");
      if (oneId(id) || zeroId(id)) return ret;
      if (isRoot[id]) {
        vec<Lit>& c = clauses[id];
        if (!useAnd /* || c.size()==1*/) {
          for (j = 0; j < c.size(); j++) {
            // var implied at complemented phase
            int v = var(c[j]);
            char val = sign(c[j]) ? -1 : 1;
            if (!useAnd) val = -val;
            Pdtutil_Assert(isGlobal(v),"only glob vars allowed");
            if (impliedVars[v] && (impliedVars[v]*val < 0)) {
              ret = 0;
            }
            else {
              impliedVars[v] += val;
            }
          }
        }
        return ret;
      }
      vec<ClauseId>& cs = proofNodes[id];
      vec<Lit>& xs = vars[id];
      if (xs.size()==0) return ret;
      for (j = xs.size()-1; j>=0; j--) {
        int v = var(xs[j]);
	int isAnd = !isOrRes(id,j,v);
        if (useAnd && !isAnd || !useAnd && isAnd) break;
        int id_j = cs[j+1];
        int impl = isAnd ? 1 : -1;
        if (invId(id_j)) {
          impl = -impl;
        }
        if (impliedNode[nodeId(id_j)]!=0) {
          if ((impliedNode[nodeId(id_j)] * impl) < 0) {
            impl=0;
            ret = 0;
          }
        }
	if (impl!= 0) {
	  impliedNode[nodeId(id_j)] += impl;
          if (observed>=0 && id_j==observed) {
            printf("IMPLIED> %d -> %d(+%d) cnt: %d\n", id_j, impliedNode[id_j], impl, cntDbg++);
          }
	  nImpl++;
	}
	if (doRecur) {
	  int myRet = topLevelImply(nodeId(id_j),phase,enRecur);
	  if (myRet==0) ret=0;
	}
      }
      return ret;
    }

    void topLevelUnImply(int id, int phase, int enRecur=1) {
      int useAnd = phase>0;
      int j;
      // int enRecur = 1 && (isCore[nodeId(id)]==1);
      int doRecur = enRecur || (isCore[nodeId(id)]==1);
      if (isCore[nodeId(id)]>1 && enRecur>0)
        enRecur--;

      Pdtutil_Assert(id>=0,"neg id not allowed");
      if (oneId(id) || zeroId(id)) return;

      static int nImpl = 0;

      if (isRoot[id]) {
        vec<Lit>& c = clauses[id];
        if (!useAnd /* || c.size()==1*/) {
          for (j = 0; j < c.size(); j++) {
            // var implied at complemented phase
            int v = var(c[j]);
            char val = sign(c[j]) ? -1 : 1;
            if (!useAnd) val = -val;
            if (impliedVars[v] && (impliedVars[v]*val > 0)) {
              impliedVars[v] -= val;
            }
          }
        }
        return;
      }
      vec<ClauseId>& cs = proofNodes[id];
      vec<Lit>& xs = vars[id];
      if (xs.size()==0) return;
      for (j = xs.size()-1; j>=0; j--) {
        int v = var(xs[j]);
	int isAnd = !isOrRes(id,j,v);
        if (useAnd && !isAnd || !useAnd && isAnd) break;
        int id_j = cs[j+1];
        int impl = isAnd ? 1 : -1;
        if (invId(id_j)) {
          impl = -impl;
        }
	//        impl=0;
        if (impliedNode[nodeId(id_j)]!=0) {
          if ((impliedNode[nodeId(id_j)] * impl) < 0) {
            impl=0;
          }
        }

	if (impl!= 0) {
	  if (abs(impliedNode[nodeId(id_j)])>0) {
	    impliedNode[nodeId(id_j)] -= impl;
            if (observed>=0 && id_j==observed) {
              printf("IMPLIED< %d -> %d(-%d) cnt: %d\n", id_j, impliedNode[id_j], impl, cntDbg++);
            }
	  }
	  else {
	    impliedNode[nodeId(id_j)] = 0;
            if (observed>=0 && id_j==observed) {
              printf("IMPLIED< %d -> %d cnt: %d\n", id_j, impliedNode[id_j], cntDbg++);
            }
	  }
	}
	if (doRecur) {
	  topLevelUnImply(nodeId(id_j),phase,enRecur);
	}
      }
    }

    int nodeIsImplied(int id, int doRecur=0, int phase=-1) {
      if (id == zeroConstId || id == oneConstId) return 0;

      Pdtutil_Assert(id>0,"negative id not allowed");
      if (impliedNode[id]) return impliedNode[id];
      //      return 0;
      if (isRoot[id]) {
        vec<Lit>& c = clauses[id];
        int activeLits = c.size();
        for (int j = 0; j < c.size(); j++) {
          int v = var(c[j]);
          char val = sign(c[j]) ? -1 : 1;
          if (impliedVars[v]) {
            if (impliedVars[v]*val > 0) {
              /* same phase - node implied */
              return 1;
            }
            else {
              /* other phase - literal cleared */
              activeLits--;
            }
          }
        }
        if (activeLits==0) {
          return -1;
        }
      }
      else if (doRecur>0 && isCore[id]>=2) {
        vec<ClauseId>& cs = proofNodes[id];
        vec<Lit>& xs = vars[id];
        int topRes = xs.size()-1;
        int v = var(xs[topRes]);
        int isTopOr = isOrRes(id,topRes,v);
        int j;
        if (phase>=0) {
          if (phase==1 && !isTopOr ||
              phase==0 && isTopOr) {
            return 0;
          }
        }
        for (j=topRes; j>=0; j--) {
          int next = cs[j+1];
          v = var(xs[j]);
          if (isOrRes(id,j,v) != isTopOr) {
            break;
          }
          int isImpl = nodeIsImplied(nodeId(next),doRecur-1,isTopOr);
          if (isImpl) {
            int implOne = isImpl>0;
            Pdtutil_Assert(!invId(next),"unhandled complement");
            if (isTopOr&&implOne) {
              return 1;
            }
            else if (!isTopOr&&!implOne) {
              return -1;
            }
          }
        }
      }
      return 0;
    }

    int reduceNodeOdc (int i) {
      int j, jj, v, remove, id, cntDup=0;
      int useCut = 1 && useRemapped;
      int nodeIsInv = invId(i);
      int doCompact = 0;

      static int nRedCall = 0;

      nRedCall++;

      i = nodeId(i);

      if (isCore[i] <= 0 || isCore[i] > 2) {
        return 0;
      }
      if (constRootsUsed && (i == oneConstId || i == zeroConstId)) {
        // constant: skip.
        return 0;
      }
      if (isRoot[i]) {
        // clause already in clauses array
        return 0;
      }
      else {
        vec<ClauseId>& cs = proofNodes[i];
        vec<Lit>& xs = vars[i];
	int nResSkip=0;

        for (j=xs.size()-1; j>=0; j--) {
          int next = cs[j+1], keep0 = next;
          int usedVarsSet=0, usedVarsPrev=0;
          int next1 = cs[0];
          int isAnd=0;
          remove = 0;
          if (constRootsUsed &&
              (oneId(next) || zeroId(next))) {
            // constant: skip.
            continue;
          }
          v = var(xs[j]);
	  isAnd = !isOrRes(i,j,v);
          if (nodeIsInv) isAnd = !isAnd;

          if (!remove) {
            int isImpl = nodeIsImplied(nodeId(next));
            if (isImpl) {
              int implOne = isImpl>0;
              if (invId(next)) implOne = !implOne;
              implNodesCnt++;
              if (implOne) {
                /* implied to 1 */
                if (isAnd) {
		  if (useMcmRules || !isGlobal(v)) {
		    /* and with 1: simply skip */
		    remove = 1;
		  }
                }
                else if (1&&useCut) { // otherwise no constants allowed
                  /* or with 1: force constant */
                  remove = 2;
                  keep0 = oneConstId; // root 1 constant
                }
              }
              else if (1) {
                /* implied to 0 */
                if (isAnd) {
		  if (useMcmRules || !isGlobal(v)) {
		    /* and with 0: force constant */
		    if (useCut) { // otherwise no constants allowed
		      remove = 2;
		      keep0 = zeroConstId; // root 1 constant
		    }
		  }
                }
                else {
                  /* or with 0: simply skip */
                  remove = 1;
                }
              }
            }
            isImpl = (j!=0) ? 0 : nodeIsImplied(nodeId(next1));
            if (1 && !remove && j==0 && isImpl) {
              int implOne = isImpl>0;
              if (invId(next1)) implOne = !implOne;
              implNodesCnt++;
              if (implOne) {
                /* implied to 1 */
                if (isAnd) {
		  if (useMcmRules || !isGlobal(v)) {
		    /* and with 1: replace with other node */
		    remove = 2;
		    keep0 = next;
		  }
                }
                else if (!useCut) {
                } else { // otherwise no constants allowed
                  /* or with 1: force constant by removing other node */
                  remove = 2;
                  keep0 = oneConstId; // root 1 constant
                }
              }
              else if (1) {
                /* implied to 0 */
                if (isAnd) {
		  if (useMcmRules || !isGlobal(v)) {
		    /* and with 0: force constant */
		    remove = 2;
		    keep0 = zeroConstId; // root 1 constant
		  }
                }
                else if (!useCut) {
                  remove = 1;
                }
                else {
                  /* or with 0: replace with other node */
                  remove = 2;
                  keep0 = next;
                }
              }
            }
          }
          if (!remove && (useMcmRules || !isGlobal(v))) {
            impliedNode[nodeId(next)] = isAnd ? 1 : -1;
            if (invId(next)) {
              impliedNode[nodeId(next)] = -impliedNode[nodeId(next)];
            }
          }

          if (remove==1) {
            if (usedVarsSet) {
              usedVars[v] = 0;
            }
	    else if (usedVarsPrev) {
              usedVars[v] = usedVarsPrev;
	    }
	    cs[j+1] = (isAnd) ? oneConstId : zeroConstId;
	    if (useMcmRules || !isGlobal(v)) doCompact = 1;
#if 0
            for (int jj=j+1; jj<xs.size(); jj++) {
              xs[jj-1]=xs[jj];
              cs[jj]=cs[jj+1];
            }
            xs.pop(); cs.pop();
#endif
          }
          else if (remove==2) {
            /* fanout 1 - remove */
            /* remove rest of array */
            if (usedVarsSet) {
              usedVars[v] = 0;
            }
	    else if (usedVarsPrev) {
              usedVars[v] = usedVarsPrev;
	    }
            cs[0]=keep0;
            for (int jj=j+1; jj<xs.size(); jj++) {
              xs[jj-j-1]=xs[jj];
              cs[jj-j]=cs[jj+1];
            }
            for (int jj=j; jj>=0; jj--) {
              xs.pop(); cs.pop();
            }
	    if (handleAClauses) {
	      if ((j+1)<=nResA[i]) {
		nResA[i] -= (j+1);
	      }
	      else nResA[i] = 0; // skip all
	    }

            j=0;
          }
	  else {
	    /* reset usedvars */
            if (usedVarsSet) {
              usedVars[v] = 0;
            }
	    else if (usedVarsPrev) {
              usedVars[v] = usedVarsPrev;
	    }
	  }
        }

        //        impliedNode[cs[0]] = 0;
        for (j = jj = 0; j < xs.size(); j++) {
          int next = cs[j+1];
	  if (doCompact) {
	    int isAnd = !isOrRes(i,j,var(xs[j]));
	    int enConstSimplify = (useMcmRules || !isGlobal(v));
	    if ((isAnd && (next == oneConstId) && enConstSimplify) ||
		(!isAnd && (next == zeroConstId))) {
	      // skip
	      if (handleAClauses && j<nResA[i]) {
		nResSkip++;
	      }
	      continue;
	    }
            xs[jj]=xs[j];
	    cs[++jj] = cs[j+1];
	  }
          // reset var usage
      	  Pdtutil_Assert(!useMcmRules||abs(impliedNode[nodeId(next)])==1,"missing implication");
	  impliedNode[nodeId(next)] = 0;
        }
	if (nResSkip>0) {
	  nResA[i] -= nResSkip;
	}
	while (doCompact && xs.size()>jj) {
	  xs.pop(); cs.pop();
	}
	//Pdtutil_Assert(xs.size()>0,"void chain");

      }
      isCore[i] += 2;

      return cntDup;
    }

    void filterCommonResLits(vec<Lit>& sharedLits) {
      int i,j;
      for (i=j=0; i<sharedLits.size(); i++) {
        int v = var(sharedLits[i]);
        if (usedVars[v]!=0) {
          bool samePhase = sign(sharedLits[i]) ?
            usedVars[v]<0 : usedVars[i]>0;
          if (samePhase) sharedLits[j++] = sharedLits[i];
        }
      }
      while (i>j) {
        i--; sharedLits.pop();
      }
    }

    void propagateTopRes(int i, int enVarReduce,
                         vec<Lit> *topRedLits) {
      if (isCore[i] != 2 || !enVarReduce || topRedLits==NULL)
        return;
      // node with nultiple chindren
      vec<Lit>& sharedRedLits = upperResolutionLits[i];
      if (sharedRedLits.size()==0) {
        topRedLits->copyTo(sharedRedLits);
      }
      filterCommonResLits(sharedRedLits);
    }
    
    int reduceNode (int i, int enVarReduce,
                    vec<Lit> *topRedLits) {
      int j, jj, v, remove, gid, cntDup=0;
      int useCut = 1 && useRemapped;
      int doRecur = 1;// && (ddiMgr->settings.aig.itpMem > 3);
      int enImpl = !enVarReduce; //1;
      int nodeIsInv = invId(i);
      int doCompact = 0;
      int isRootNode = i==(proofNodes.size()-1);
      vec<int> usedVarsSave;      
      int doBacktrack = !(isRootNode && rootCustomHandling);      
      int isSubTreeRoot = isCore[i]==1 || isRootNode;
      vec<Lit> *treeRedLits = topRedLits;
      static int tryDag = 0;
      static int checkRecyclePiv = 0;
      static int nRedCall = 0;

      nRedCall++;

      if (handleAClauses && enVarReduce) {
        vec<Lit>& xs = vars[i];
        for (j=0; j<xs.size() && j<nResA[i]; j++) {
          v = var(xs[j]);
	  int isAnd = !isOrRes(i,j,v);
	  if (!isAnd && isBVar(v)) {
	    enVarReduce = 0; // disable var red here
	  }
	}
      }

      i = nodeId(i);

      if (isCore[i] <= 0 || isCore[i] > 2) {
        return 0;
      }
      if (upperResolutionLits.size()>i) {
        if (upperResolutionLits[i].size()==0)
          return 0; // not reachable
      }

      if (constRootsUsed && (i == oneConstId || i == zeroConstId)) {
        // constant: skip.
        return 0;
      }
      if (isRoot[i]) {
        // clause already in clauses array
        return 0;
      }
      else {
        vec<ClauseId>& cs = proofNodes[i];
        vec<Lit>& xs = vars[i];

#if 0
        for (j = 0; j < xs.size(); j++) {
          // reset var usage
          v = var(xs[j]);
          usedVars[v] = 0;
        }
        for (j = 0; j < cs.size(); j++) {
          // reset var usage
          id = nodeId(cs[j]);
          impliedNode[id] = 0;
        }
#endif
	if (enVarReduce==1 && isSubTreeRoot && genResolution) {
	  /* enabled just on tree roots (enVarReduce i1 2 on other nodes */
          if (upperResolutionLits.size()>i) {
          Pdtutil_Assert(upperResolutionLits.size()>i,
                         "missing upper res lits");
	  vec<Lit>& c = upperResolutionLits[i];
          if (resolutionClauses.size()>i) {
            vec<Lit>& cR = resolutionClauses[i];
            Pdtutil_Assert(c.size()>=cR.size(),"missing lit");
          }
          // vec<Lit>& c = resolutionClauses[i];
	  for (int j = 0; j < c.size(); j++) {
	    int v_j = var(c[j]);
            if (usedVars[v_j]) {
              if (sign(c[j]) ?
                  usedVars[v_j]<-0:usedVars[v_j]>0) {
                usedVars[v_j] += ((sign(c[j]) ? -2 : 2));
              }
            }
            else 
              usedVars[v_j] += ((sign(c[j]) ? -2 : 2));
	  }
	  }
	}
#if 0
	else if (enVarReduce==1 && fatherId[i] >= 0) {
	  vec<Lit>& c = vars[fatherId[i]];
	  vec<ClauseId>& cs1 = proofNodes[fatherId[i]];
	  for (int j=c.size()-1; j>=0; j--) {
	    int v_j = var(c[j]);
	    if (cs1[j+1]==i) break;
            if (usedVars[v_j]==0)
	      usedVars[v_j] = sign(c[j]) ? -1 : 1;
	  }
	}
#endif

	// for (jj=xs.size()-1; jj>=0; jj--) {
	//	for (j=0; j<xs.size(); j++) {
        static int forceEarlyReset=0;
        int earlyResetUsedVars = forceEarlyReset || enImpl;
        for (j=xs.size()-1; j>=0; j--) {
          int next = cs[j+1], keep0 = next;
          int usedVarsSet=0, usedVarsPrev=0;
          int next1 = cs[0];
          int isAnd=0;
          remove = 0;
          if (constRootsUsed &&
              (oneId(next) || zeroId(next))) {
            // constant: skip.
            continue;
          }
          v = var(xs[j]);
	  isAnd = !isOrRes(i,j,v);
          if (nodeIsInv) isAnd = !isAnd;
          if (enVarReduce) {
            if (usedVars[v]) {
              // keep main if same sign as dup pivot
              int keepMain;
              if (usedVars[v]) {
                keepMain = usedVars[v]>0 && !sign(xs[j]) ||
                  usedVars[v]<0 && sign(xs[j]);
                usedVarsPrev = usedVars[v];
              }
              if (keepMain) {
                /* remove current node */
                remove=1;
                cntDup++;
                //              xs[i]=-1;
		if (checkRecyclePiv) {
		  int cntSame=0, cntOther=0;
		  for (int jj=j-1; jj>=0; jj--) {
		    if (var(xs[jj])==var(xs[j])) {
		      if (xs[jj]==xs[j]) {
			cntSame++;
		      }
		      else {
			cntOther++;
		      }
		    }
		  }
		}
              }
              else if (0) {
                /* flip phase */
                usedVarsPrev = usedVars[v];
                usedVars[v] = -usedVars[v];
		// usedVars[v] = 1;
              }
              else if (1) {
                if (1 || isCore[next]==1) {
                  remove=2;
                  if (doRecur) {
                    int doRecurHere = isCore[nodeId(next)]==1;
                    if (tryDag>0 /*&& enVarReduce*/)
                      doRecurHere |=
                        fatherId[nodeId(next)] >= 0; 
                    if (doRecurHere) {
                      if (isCore[nodeId(next)]==2 &&
                          fatherId[nodeId(next)]>=0) {
                        if (fatherId[nodeId(next)]!=i) 
                          doRecurHere = 0;
                        else if (fatherPin[nodeId(next)]!=(j+1)) 
                          doRecurHere = 0;
                      }
                    }
                    if (doRecurHere) {
                      int rec;
                      if (isCore[nodeId(next)]==2) {
                        //                        tryDag--;
                      }
                      Pdtutil_Assert(nodeId(next)<i,
                                     "wrong proof node id");
                      rec = reduceNode(next,enVarReduce ? 2:0,
                                       treeRedLits);
                      cntDup += rec;
                    }
                    else {
                      propagateTopRes(next,enVarReduce,
                                       treeRedLits);
                    }
                  }
                }
              }
            } else {
              int impl = impliedVar(v,i);
              if (impl) {
                int keepMain;
                assert(abs(impl)<=i);
                keepMain = impl>0&&!sign(xs[j])||impl<0&&sign(xs[j]);
                if (keepMain) {
                  /* replace current node with implication node*/
                  if (1&&((abs(impl)-1)==1)) {
                    remove=1;
                    cntImpliedUsedVars++;
                    cntDup++;
                  }
                  else if (1&&((abs(impl)-1)!=1)&&
                           (cs[j+1] != abs(impl)-1)) {
                    cs[j+1] = abs(impl)-1;
                    cntImpliedUsedVars++;
                    impl=0;
                  }
                  else {
                    impl=0;
                  }
                  //              xs[i]=-1;
                }
                else if (1) { 
                  if (1&&((abs(impl)-1)==1)) {
                    cntImpliedUsedVars++;
                    remove=2;
                    //break;
                  }
                  else if (1) {
                    keep0 = abs(impl)-1;
                    cntImpliedUsedVars++;
                    remove=5;
                    impl=0;
                  }
                  else {
                    impl=0;
                  }
                }
              }
              if (!impl) {
                Pdtutil_Assert(!usedVars[v],"usedvars is set");
                usedVars[v] = sign(xs[j]) ? -1 : 1;
                usedVarsId[v] = i;
                usedVarsSet=1;
                if (upperResolutionLits.size()>i) {
                  vec<Lit>& c = upperResolutionLits[i];
                  c.push(xs[j]);
                }
              }
            }
          }

          if (!remove && doRecur) {
            int doRecurHere = isCore[nodeId(next)]==1;
            int otherPin = -1;
            if (tryDag>0 /*&& enVarReduce*/)
              doRecurHere |=
                fatherId[nodeId(next)] >= 0; 
            if (doRecurHere) {
              if (isCore[nodeId(next)]==2 &&
                  fatherId[nodeId(next)]>=0) {
                if (fatherId[nodeId(next)]!=i) 
                  doRecurHere = 0;
                else if (fatherPin[nodeId(next)]!=(j+1)) {
                  if (1 && enVarReduce) {
                    otherPin = fatherPin[nodeId(next)];
                    Pdtutil_Assert(otherPin>(j+1),"wrong other pin");
                  }
                  else {
                    doRecurHere = 0;
                  }
                }
              }
            }
            if (doRecurHere) {
              int rec;
	      int save = usedVars[v];
	      int saveId = usedVarsId[v];
              if (isCore[nodeId(next)]==2) {
                //                tryDag--;
              }

              Pdtutil_Assert(nodeId(next)<i,"wrong proof node id");
              if (enVarReduce && usedVarsSet) {
                if (isCore[nodeId(next)]==1) 
                  usedVars[v] = -usedVars[v];
                else
                  usedVars[v] = 0; // dag dependency (disable edge)                  
              }
              if (otherPin>=0) {
                int jj;
                usedVarsSave.clear();
                for (jj=j; jj<otherPin; jj++) {
                  v = var(xs[jj]);
                  if (usedVarsId[v]==i && usedVars[v]!=0) {
                    usedVarsSave.push(v);
                    usedVarsSave.push(usedVars[v]);
                    usedVars[v] = 0;
                    usedVarsId[v]=-1;
                  }
                }
              }
              rec = reduceNode(next,enVarReduce ? 2:0, treeRedLits);
              cntDup += rec;
              if (otherPin>=0) {
                int jj;
                for (jj=0; jj<usedVarsSave.size(); jj+=2) {
                  v = usedVarsSave[jj];
                  usedVarsId[v]=i;
                  usedVars[v] = usedVarsSave[jj+1];
                }
              }
              if (enVarReduce && usedVarsSet) {
                usedVars[v] = save;
                usedVarsId[v] = saveId;
              }
            }
            else {
              propagateTopRes(next,enVarReduce,
                              treeRedLits);
            }
#if 0
            else if (isCore[nodeId(next)]>1) {
	      fatherId[nodeId(next)] = i;
	    }
#endif
            if (j==0 && isCore[nodeId(next1)]==1) {
              int rec;
              Pdtutil_Assert(next1<i,"wrong proof node id");
              rec = reduceNode(next1,enVarReduce ? 2:0,
                               treeRedLits);
              cntDup += rec;
            }
          }

          if (!remove && enImpl) {
            int isImpl = nodeIsImplied(nodeId(next),0);
            if (isImpl) {
              int implOne = isImpl>0;
              if (invId(next)) implOne = !implOne;
              implNodesCnt++;
              if (implOne) {
                /* implied to 1 */
                if (isAnd) {
                  /* and with 1: simply skip */
		  if (useMcmRules || !isGlobal(v))
		    remove = 1;
                }
                else if (1&&useCut) { // otherwise no constants allowed
                  /* or with 1: force constant */
                  remove = 3; // start from j+1
                  keep0 = oneConstId; // root 1 constant
                }
              }
              else if (1) {
                /* implied to 0 */
                if (isAnd) {
		  if (useMcmRules || !isGlobal(v)) {
		    /* and with 0: force constant */
		    if (useCut) { // otherwise no constants allowed
		      remove = 3; // start from j+1
		      keep0 = zeroConstId; // root 1 constant
		    }
		  }
                }
                else {
                  /* or with 0: simply skip */
                  remove = 1;
                }
              }
            }
            isImpl = (j!=0) ? 0 : nodeIsImplied(nodeId(next1),0);
            if (1 && !remove && j==0 && isImpl) {
              int implOne = isImpl>0;
              if (invId(next1)) implOne = !implOne;
              implNodesCnt++;
              if (implOne) {
                /* implied to 1 */
                if (isAnd) {
		  if (useMcmRules || !isGlobal(v)) {
		    /* and with 1: replace with other node */
		    remove = j==0 ? 3 : 2;
		    keep0 = next;
		  }
                }
                else if (!useCut) {
                } else { // otherwise no constants allowed
                  /* or with 1: force constant by removing other node */
                  remove = j==0 ? 3 : 2;
                  keep0 = oneConstId; // root 1 constant
                }
              }
              else if (1) {
                /* implied to 0 */
                if (isAnd) {
		  if (useMcmRules || !isGlobal(v)) {
		    /* and with 0: force constant */
		    remove = j==0 ? 3 : 2;
		    keep0 = zeroConstId; // root 1 constant
		  }
                }
                else if (!useCut) {
                  remove = 1;
                }
                else {
                  /* or with 0: replace with other node */
                  remove = j==0 ? 3 : 2;
                  keep0 = next;
                }
              }
            }
          }
          if (!remove && enImpl && (useMcmRules /*|| !isGlobal(v)*/)) {
            Pdtutil_Assert(impliedNode[nodeId(next)]==0,
                           "node implication missed");
            impliedNode[nodeId(next)] = isAnd ? 1 : -1;
            if (invId(next)) {
              impliedNode[nodeId(next)] = -impliedNode[nodeId(next)];
            }
            if (observed>=0 && next==observed) {
              printf("IMPLIED> %d -> %d cnt: %d\n", next, impliedNode[next], cntDbg++);
            }
            if (1&&!topLevelImply(nodeId(next),impliedNode[nodeId(next)])) {
              /* conflicting implication found: force constant */
              int constId = isAnd ? zeroConstId : oneConstId;
              if (invId(next)) {
                constId = notId(constId);
              }
	      remove = 2;
	      keep0 = (isAnd) ? zeroConstId : oneConstId;
	      //              cs[j+1] = constId;
	      topLevelUnImply(nodeId(next),impliedNode[nodeId(next)]);
	      Pdtutil_Assert(abs(impliedNode[nodeId(next)])==1,"double implication");

	      impliedNode[nodeId(next)] = 0;
              if (observed>=0 && next==observed) {
                printf("IMPLIED< %d -> %d cnt: %d\n", next, impliedNode[next], cntDbg++);
              }
            }
          }

          //          static int cntRem=0, maxRem=400;
          if (remove==1/* && cntRem<maxRem*/) {
            //cntRem++;
            if (usedVarsSet) {
              usedVars[v] = 0;
            }
	    else if (usedVarsPrev) {
              //  usedVars[v] = usedVarsPrev;
	    }
	    cs[j+1] = (isAnd) ? oneConstId : zeroConstId;
#if 1
	    if (useMcmRules || !isGlobal(v)) doCompact = 1;
#else
            for (int jj=j+1; jj<xs.size(); jj++) {
              xs[jj-1]=xs[jj];
              cs[jj]=cs[jj+1];
            }
            xs.pop(); cs.pop();
#endif
          }
          else if ((remove==2 || remove==3)) {
            /* fanout 1 - remove */
            /* remove rest of array */
            if (usedVarsSet) {
              usedVars[v] = 0;
            }
	    else if (usedVarsPrev) {
              // usedVars[v] = usedVarsPrev;
	    }
            cs[0]=keep0;
            int j0 = (remove==2) ? j : j+1;
            for (int jj=j0; jj<xs.size(); jj++) {
              xs[jj-j0]=xs[jj];
              cs[jj-j0+1]=cs[jj+1];
            }
            for (int jj=j0; jj>0; jj--) {
              xs.pop(); cs.pop();
            }
	    if (handleAClauses) {
	      if ((j+1)<=nResA[i]) {
		nResA[i] -= (j+1);
	      }
	      else nResA[i] = 0; // skip all
	    }
            j=0;
          }
          else if (remove==5) {
            /* keep j resolution - remove rest */
            /* remove rest of array */
            cs[0]=keep0;
            for (int jj=j; jj<xs.size(); jj++) {
              xs[jj-j]=xs[jj];
              cs[jj-j+1]=cs[jj+1];
            }
            for (int jj=j-1; jj>=0; jj--) {
              xs.pop(); cs.pop();
            }
            j=0;
          }
	  else if (earlyResetUsedVars) {
	    /* reset usedvars */
            if (usedVarsSet) {
              usedVars[v] = 0;
            }
	    else if (usedVarsPrev) {
              //  usedVars[v] = usedVarsPrev;
	    }
	  }
        }
        
	if (isSubTreeRoot && enVarReduce==1 && genResolution) {
	  /* enabled just on tree roots (enVarReduce i1 2 on other nodes */
	  vec<Lit>& c = resolutionClauses[i];
	  for (int j = 0; j < c.size(); j++) {
	    int v_j = var(c[j]);
            if (abs(usedVars[v_j]) > 1)
              usedVars[v_j] -= ((sign(c[j]) ? -2 : 2));
	    //	    usedVars[v_j] = 0;
            //Pdtutil_Assert(0,"NEED TO CHECK");
	  }
	}
#if 0
	else if 0 && (enVarReduce==1 && fatherId[i] >= 0) {
	  vec<Lit>& c = vars[fatherId[i]];
	  vec<ClauseId>& cs1 = proofNodes[fatherId[i]];
	  for (int j=c.size()-1; j>=0; j--) {
	    int v_j = var(c[j]);
	    if (cs1[j+1]==i) break;
	    usedVars[v_j] = 0;
	  }
	}
#endif

        //        impliedNode[cs[0]] = 0;
	int nResSkip = 0;
        for (j = jj = 0; j < xs.size(); j++) {
          int next = cs[j+1];
          // reset var usage
          v = var(xs[j]);
	  //          if (enVarReduce) usedVars[v] = 0;
	  if (doCompact) {
	    int isAnd = !isOrRes(i,j,v);
	    int enConstSimplify = (useMcmRules || !isGlobal(v));
	    if ((isAnd && (next == oneConstId) && enConstSimplify) ||
		(!isAnd && (next == zeroConstId))) {
	      // skip
	      if (handleAClauses && j<nResA[i]) {
		nResSkip++;
	      }
	      continue;
	    }
            xs[jj]=xs[j];
	    cs[++jj] = cs[j+1];
	  }

	  if (next == zeroConstId || next == oneConstId) {
	    continue;
	  }

	  if (0&&enVarReduce) {
	    Pdtutil_Assert(!usedVars[v],"usedvars has not been reset");
	  }
          if (enImpl && impliedNode[nodeId(next)]!=0 && doBacktrack) {
	    Pdtutil_Assert(impliedNode[nodeId(next)]!=0,
			   "missing implication");
	    int isNeg = impliedNode[nodeId(next)] < 0;
            topLevelUnImply(nodeId(next),impliedNode[nodeId(next)]);
	    int impl = isNeg ? -1 : 1;
	    Pdtutil_Assert(impliedNode[nodeId(next)]!=0,"missing impl");
            impliedNode[nodeId(next)] -= impl;
    if (observed>=0 && next==observed) {
      printf("IMPLIED< %d -> %d(%d) cnt: %d\n", next, impliedNode[next], impl, cntDbg++);
    }
          }
        }
        
	if (nResSkip>0) {
	  nResA[i] -= nResSkip;
	}
	while (doCompact && xs.size()>jj) {
	  xs.pop(); cs.pop();
	}
	//	Pdtutil_Assert(xs.size()>0,"void chain");
        if (!earlyResetUsedVars && doBacktrack) {
          for (j=xs.size()-1; j>=0; j--) {
            v = var(xs[j]);
            if (usedVarsId[v]==i)
              usedVars[v] = 0;
          }
        }

      }
      isCore[i] += 2;

      return cntDup;
    }

    int reduceNodeSimple (int i) {
      int j, jj, v, remove, id, cntDup=0;
      int nodeIsInv = invId(i);
      int doCompact = 0;
      int duplicated = 0;
      
      static int nRedCall = 0;

      nRedCall++;

      i = nodeId(i);

      if (isCore[i] <= 0 || isCore[i] > 2) {
        return 0;
      }
      if (constRootsUsed && (i == oneConstId || i == zeroConstId)) {
        // constant: skip.
        return 0;
      }
      if (isRoot[i]) {
        // clause already in clauses array
        return 0;
      }
      else {
        vec<ClauseId>& cs = proofNodes[i];
        vec<Lit>& xs = vars[i];

	if (resolutionClauses.size()>i) {
	  vec<Lit>& res = resolutionClauses[i];
	  for (int j = 0; j < res.size(); j++) {
	    // reset var usage
	    Var v = var(res[j]);
	    usedVars[v] = sign(res[j]) ? -2 : 2;
	  }
	}
	// for (jj=xs.size()-1; jj>=0; jj--) {
	//	for (j=0; j<xs.size(); j++) {
        for (j=xs.size()-1; j>=0; j--) {
          int next = cs[j+1], keep0 = next;
          int usedVarsSet=0, usedVarsPrev=0;
          int next1 = cs[0];
          int isAnd=0;
          remove = 0;
          if (constRootsUsed &&
              (oneId(next) || zeroId(next))) {
            // constant: skip.
            continue;
          }
          v = var(xs[j]);
	  isAnd = !isOrRes(i,j,v);
          if (nodeIsInv) isAnd = !isAnd;

          if (usedVars[v]) {
	    if (abs(usedVars[v])>1) {
              //	      printf("found\n");
              duplicated++;
	    }
	    // keep main if same sign as dup pivot
	    int keepMain = usedVars[v]>0 && !sign(xs[j]) ||
                usedVars[v]<0 && sign(xs[j]);
	    if (keepMain) {
	      /* remove current node */
	      remove=1;
	      cntDup++;
	      //              xs[i]=-1;
	    }
	    else if (1) {
	      if (isCore[next]==1) {
		remove=2;
		//break;
	      }
	    }
          }
          else {
            int impl = impliedVar(v,i);
            if (impl) {
              int keepMain;
              assert(abs(impl)<=i);
              keepMain = impl>0&&!sign(xs[j])||impl<0&&sign(xs[j]);
              if (keepMain) {
                /* replace current node with implication node*/
                if (1&&((abs(impl)-1)==1)) {
                  remove=1;
                  // propagate to possible other implications
                  Pdtutil_Assert(!usedVars[v],"usedvars is set");
                  usedVars[v] = sign(xs[j]) ? -1 : 1;
                  cntImpliedUsedVars++;
                  cntDup++;
                }
                else if (1&&((abs(impl)-1)>1)&&
                  (cs[j+1] != abs(impl)-1)) {
                  cs[j+1] = abs(impl)-1;
                  cntImpliedUsedVars++;
                  impl=0;
                }
                else {
                  impl=0;
                }
                //              xs[i]=-1;
              }
              else if (1) { 
                if (1&&((abs(impl)-1)==1)) {
                  cntImpliedUsedVars++;
                  remove=2;
                  //break;
                }
                else if (1) {
                  keep0 = abs(impl)-1;
                  cntImpliedUsedVars++;
                  remove=5;
                }
                else {
                  impl=0;
                }
              }
            }
            if (!impl) {
              Pdtutil_Assert(!usedVars[v],"usedvars is set");
              usedVars[v] = sign(xs[j]) ? -1 : 1;
              usedVarsSet=1;
            }
          }

	  if (remove==1) {
	    cs[j+1] = (isAnd) ? oneConstId : zeroConstId;
	    doCompact = 1;
	  }
          else if (remove==2) {
            /* fanout 1 - remove */
            /* remove rest of array */
            cs[0]=keep0;
            for (int jj=j+1; jj<xs.size(); jj++) {
              xs[jj-j-1]=xs[jj];
              cs[jj-j]=cs[jj+1];
            }
            for (int jj=j; jj>=0; jj--) {
              xs.pop(); cs.pop();
            }
            j=0;
          }
          else if (remove==5) {
            /* keep j resolution - remove rest */
            /* remove rest of array */
            cs[0]=keep0;
            for (int jj=j; jj<xs.size(); jj++) {
              xs[jj-j]=xs[jj];
              cs[jj-j+1]=cs[jj+1];
            }
            for (int jj=j-1; jj>=0; jj--) {
              xs.pop(); cs.pop();
            }
            j=0;
          }
	}
	  
	//        impliedNode[cs[0]] = 0;
	int nResSkip = 0;
	for (j = jj = 0; j < xs.size(); j++) {
	  int next = cs[j+1];
	  // reset var usage
	  v = var(xs[j]);
	  //          if (enVarReduce) usedVars[v] = 0;
	  usedVars[v] = 0;
	  if (doCompact) {
	    int isAnd = !isOrRes(i,j,v);
	    int enConstSimplify = (useMcmRules || !isGlobal(v));
	    if ((isAnd && (next == oneConstId) && enConstSimplify) ||
		(!isAnd && (next == zeroConstId))) {
		// skip
	      if (handleAClauses && j<nResA[i]) {
		nResSkip++;
	      }
	      continue;
	    }
	    xs[jj]=xs[j];
	    cs[++jj] = cs[j+1];
	  }
	  
	  if (next == zeroConstId || next == oneConstId) {
	    continue;
	  }
	  
	}
	
	while (doCompact && xs.size()>jj) {
	  xs.pop(); cs.pop();
	}
	if (resolutionClauses.size()>i) {
	  vec<Lit>& res = resolutionClauses[i];
	  for (int j = 0; j < res.size(); j++) {
	    // reset var usage
	    Var v = var(res[j]);
	    usedVars[v] = 0;
	  }
	}

	//	Pdtutil_Assert(xs.size()>0,"void chain");

      }
      return cntDup;
    }

    int reduceNodePba (Solver& S, vec<Lit>&  clauseActVar, int i) {
      int j, jj, v, remove, id, cntDup=0;
      int nodeIsInv = invId(i);
      int doCompact = 0;

      static int nRedCall = 0, red=0, limit = 1;

      nRedCall++;

      i = nodeId(i);

      if (isCore[i] <= 0 || isCore[i] > 2) {
        return 0;
      }
      if (constRootsUsed && (i == oneConstId || i == zeroConstId)) {
        // constant: skip.
        return 0;
      }
      if (isRoot[i]) {
        // clause already in clauses array
        return 0;
      }

      vec<ClauseId>& cs = proofNodes[i];
      vec<Lit>& xs = vars[i];

      Pdtutil_Assert(resolutionClauses.size()>i,
                     "missing resolution clause");
      vec<Lit>& res = resolutionClauses[i];
      for (int j = 0; j < res.size(); j++) {
        // reset var usage
        Var v = var(res[j]);
        usedVars[v] = sign(res[j]) ? -2 : 2;
      }

      for (j=xs.size()-1; j>0; j--) {
        int next = cs[j+1], keep0 = next;
        int usedVarsSet=0, usedVarsPrev=0;
        int next1 = cs[0];
        int isAnd=0;

        if (constRootsUsed &&
            (oneId(next) || zeroId(next))) {
          // constant: skip.
          continue;
        }
        v = var(xs[j]);
        isAnd = !isOrRes(i,j,v);
        if (nodeIsInv) isAnd = !isAnd;

        //        if (isRoot[next]) continue;
        vec<Lit>& res_k = resolutionClauses[next];
        int found = 0;
        for (int k = 0; k < res_k.size(); k++) {
          // reset var usage
          Var v_k = var(res_k[k]);
          int neg = sign(res_k[k]);
          int u = usedVars[v_k];
          found |= (u!=0);        
	}
        if (!found && (red < limit)) {
          // remove branch
          cs[j+1] = (isAnd) ? oneConstId : zeroConstId;
          red++;
          cntDup++;
        }
      }
      for (int j = 0; j < res.size(); j++) {
        // reset var usage
        Var v = var(res[j]);
        usedVars[v] = 0;
      }

      return cntDup;
    }

    int reduceNodeWithLit (int i, Lit lRes) {
      int j, jj, v, remove, id, cntDup=0;
      int useCut = 1 && useRemapped;
      int doRecur = 1;// && (ddiMgr->settings.aig.itpMem > 3);
      int nodeIsInv = invId(i);
      int doCompact = 0;
      Var vRes = var(lRes);

      static int nRedCall = 0;

      nRedCall++;

      if (handleAClauses) {
	Pdtutil_Assert(nResA[i]==0,"problem with A resolution");
      }

      i = nodeId(i);

      if (isCore[i] <= 0 || isCore[i] > 2) {
        return 0;
      }
      if (constRootsUsed && (i == oneConstId || i == zeroConstId)) {
        // constant: skip.
        return 0;
      }
      if (isRoot[i]) {
        // clause already in clauses array
        return 0;
      }
      else {
        vec<ClauseId>& cs = proofNodes[i];
        vec<Lit>& xs = vars[i];

	// for (jj=xs.size()-1; jj>=0; jj--) {
	//	for (j=0; j<xs.size(); j++) {
        for (j=xs.size()-1; j>=0; j--) {
          int next = cs[j+1], keep0 = next;
          int usedVarsSet=0, usedVarsPrev=0;
          int next1 = cs[0];
          int isAnd=0;
          remove = 0;
          if (constRootsUsed &&
              (oneId(next) || zeroId(next))) {
            // constant: skip.
            continue;
          }
          v = var(xs[j]);
	  isAnd = !isOrRes(i,j,v);
          if (nodeIsInv) isAnd = !isAnd;

	  if (v==vRes) {
	    // keep main if same sign as dup pivot
	    int keepMain = !sign(lRes) && !sign(xs[j]) ||
	      sign(lRes) && sign(xs[j]);
	    if (keepMain) {
	      /* remove current node */
	      remove=1;
	      cntDup++;
	      //              xs[i]=-1;
	    }
	    else if (1) {
	      if (isCore[next]==1) {
		remove=2;
	      }
	    }
	  }
	
	  if (remove==1) {
	    cs[j+1] = (isAnd) ? oneConstId : zeroConstId;
	    doCompact = 1;
	  }
	  else if (remove==2) {
	    /* fanout 1 - remove */
	    /* remove rest of array */
	    cs[0]=keep0;
	    for (int jj=j+1; jj<xs.size(); jj++) {
	      xs[jj-j-1]=xs[jj];
	      cs[jj-j]=cs[jj+1];
	    }
	    for (int jj=j; jj>=0; jj--) {
	      xs.pop(); cs.pop();
	    }
	    if (handleAClauses) {
	      if ((j+1)<=nResA[i]) {
		nResA[i] -= (j+1);
	      }
	      else nResA[i] = 0; // skip all
	    }
	    j=0;
	  }
	}
	
        //        impliedNode[cs[0]] = 0;
        for (j = jj = 0; j < xs.size(); j++) {
          int next = cs[j+1];
          // reset var usage
          v = var(xs[j]);
	  //          if (enVarReduce) usedVars[v] = 0;
	  if (doCompact) {
	    int isAnd = !isOrRes(i,j,v);
	    int enConstSimplify = (useMcmRules || !isGlobal(v));
	    if ((isAnd && (next == oneConstId) && enConstSimplify) ||
		(!isAnd && (next == zeroConstId))) {
	      // skip
	      continue;
	    }
            xs[jj]=xs[j];
	    cs[++jj] = cs[j+1];
	  }

	  if (next == zeroConstId || next == oneConstId) {
	    continue;
	  }

        }
	while (doCompact && xs.size()>jj) {
	  xs.pop(); cs.pop();
	}
	//	Pdtutil_Assert(xs.size()>0,"void chain");

      }
      isCore[i] += 2;

      return cntDup;
    }

    int reduceNodeByVar (int i, Var vRes, vec<char>& usedUpper) {
      int j, jj, v, remove, id, cntDup=0;
      int nodeIsInv = invId(i);
      int doCompact = 0;
      char used = usedUpper[i];
      char usedNeg = (used & 0x1) != 0;
      char usedPos = (used & 0x2) != 0;
      char usedClean = (used & 0x4) != 0;
      char doReduce = !usedClean && (usedNeg!=usedPos);
      char removed=0;

      static int tryMultiple = 0;
      static int checkRecyclePiv = 0;

      static int nRedCall = 0, maxCall = 90782;

      nRedCall++;
      //      if (nRedCall>maxCall) return 0;

      if (used==0) return 0; // not reachable

      if (0 && (nRedCall==maxCall)) {
	printf("found here\n");
      }

      if (handleAClauses) {
	Pdtutil_Assert(nResA[i]==0,"problem with A resolution");
      }

      i = nodeId(i);

      if (isCore[i] <= 0 || isCore[i] > 2) {
        return 0;
      }
      if (constRootsUsed && (i == oneConstId || i == zeroConstId)) {
        // constant: skip.
        return 0;
      }
      if (isRoot[i]) {
        // clause already in clauses array
        return 0;
      }
      else {
        vec<ClauseId>& cs = proofNodes[i];
        vec<Lit>& xs = vars[i];

	if (0 && (nRedCall==maxCall)) {
	  printf("var = %d\n", vRes);
	  for (j=cs.size()-1; j>=0; j--) {
	    printf("%2d) %d %d\n", j, cs[j], j==0 ? -1 : 
		   (sign(xs[j-1])?-1:1)*var(xs[j-1]));
	  }
	}

	// for (jj=xs.size()-1; jj>=0; jj--) {
	//	for (j=0; j<xs.size(); j++) {
        for (j=xs.size()-1; j>=0; j--) {
          int next = cs[j+1], keep0 = next;
          int usedVarsSet=0, usedVarsPrev=0;
          int next1 = cs[0];
          int isAnd=0;
	  int usedOtherPhase = 0;
          remove = 0;
          if (constRootsUsed &&
              (oneId(next) || zeroId(next))) {
            // constant: skip.
            continue;
          }
          v = var(xs[j]);
	  isAnd = !isOrRes(i,j,v);
          if (nodeIsInv) isAnd = !isAnd;

	  if (v==vRes) {
	    if (doReduce) {
	      // var is resolved upper
	      // keep main if same sign as dup pivot
	      int keepMain = usedPos && !sign(xs[j]) ||
		usedNeg && sign(xs[j]);
	      if (keepMain) {
		/* remove current node */
		remove=1;
		cntDup++;
		//              xs[i]=-1;
		if (checkRecyclePiv) {
		  int cntSame=0, cntOther=0;
		  for (int jj=j-1; jj>=0; jj--) {
		    if (var(xs[jj])==vRes) {
		      if (xs[jj]==xs[j]) {
			cntSame++;
		      }
		      else {
			cntOther++;
		      }
		    }
		  }
		}
	      }
	      else if (1) {
		if (isCore[next]==1) {
		  remove=2;
		  cntDup++;
		}
	      }
	      if (1 && tryMultiple) {
		usedOtherPhase = usedNeg ? 0x2 : 0x1;
		Pdtutil_Assert((usedOtherPhase+used)==3,"problem");
	      }
	    }
	    else if (1 || tryMultiple || !doReduce) {
	      // used upper in both phases or not used - reset it
	      usedNeg = sign(xs[j]);
	      usedPos = !usedNeg;
	      doReduce = usedNeg!=usedPos;
	      used = usedNeg ? 0x1 : 0x2;
	      usedOtherPhase = usedNeg ? 0x2 : 0x1;
	    }
	  }
		
	  if (remove==1) {
	    if (1&&tryMultiple) {
	      if (invId(keep0)) keep0 = notId(keep0);
	      Pdtutil_Assert (usedOtherPhase != 0,"problem");
	      //usedUpper[keep0] |= used;
	      usedUpper[keep0] |= usedOtherPhase;
	    }
	    else {
	      removed = 1;
	      used = 0x4; // reset after reduction
	      //	      doReduce = 0;
	    }
	    // var at this node
	    cs[j+1] = (isAnd) ? oneConstId : zeroConstId;
	    doCompact = 1;
	  }
	  else if (remove==2) {
	    /* fanout 1 - remove */
	    /* remove rest of array */
	    //	    used = 0x4; // reset after reduction
	    if (tryMultiple) {
	      for (int jj=j; jj>=0; jj--) {
		int ref = cs[jj];
		if (invId(ref)) ref = notId(ref);
		Pdtutil_Assert (usedOtherPhase != 0,"problem");
		//usedUpper[ref] |= used;
		usedUpper[ref] |= usedOtherPhase;
	      }
	    }
	    else {
	      removed = 1;
	      used = 0x4; // reset after reduction
	      //	      doReduce = 0;
	    }
	    cs[0]=keep0;
	    for (int jj=j+1; jj<xs.size(); jj++) {
	      xs[jj-j-1]=xs[jj];
	      cs[jj-j]=cs[jj+1];
	    }
	    for (int jj=j; jj>=0; jj--) {
	      xs.pop(); cs.pop();
	    }
	    if (handleAClauses) {
	      if ((j+1)<=nResA[i]) {
		nResA[i] -= (j+1);
	      }
	      else nResA[i] = 0; // skip all
	    }
	    j=0;
	  }
	  else {
	    // just propagate flags
	    if (invId(keep0)) keep0 = notId(keep0);
	    if (usedOtherPhase != 0) {
	      // var at this node
	      usedUpper[keep0] |= usedOtherPhase;
	    }
	    else {
	      usedUpper[keep0] |= used;
	    }
	  }
	  if (j==0) {
	    // propagate flags to cs[0]
	    next1 = cs[0];
	    if (invId(next1)) next1 = notId(next1);
	    usedUpper[next1] |= used;
	  }
	}
	
        //        impliedNode[cs[0]] = 0;
        for (j = jj = 0; j < xs.size(); j++) {
          int next = cs[j+1];
          // reset var usage
          v = var(xs[j]);
	  //          if (enVarReduce) usedVars[v] = 0;
	  if (doCompact) {
	    int isAnd = !isOrRes(i,j,v);
	    if ((isAnd && (next == oneConstId)) ||
		(!isAnd && (next == zeroConstId))) {
	      // skip
	      continue;
	    }
            xs[jj]=xs[j];
	    cs[++jj] = cs[j+1];
	  }

	  if (next == zeroConstId || next == oneConstId) {
	    continue;
	  }

        }
	while (doCompact && xs.size()>jj) {
	  xs.pop(); cs.pop();
	}
	//	Pdtutil_Assert(xs.size()>0,"void chain");

      }
      return cntDup;
    }

    void reduceProofOdcSimple  (void) {
      int i, j, n, v, idLast, nNodes;
      int cntDup=0;
      n=0;
      nNodes = isCore.size();
      idLast = nNodes-1;

      if (nNodes<2) return;

      implNodesCnt=0;
      proofCore();

      /* resize usedVars array */
      usedVars.growTo(nSolverVars+2+2*dummyIteVars.size());
      usedVarsId.growTo(nSolverVars+2+2*dummyIteVars.size());
      for (i=0; i<=nSolverVars+1+2*dummyIteVars.size(); i++) {
        usedVars[i] = 0;
        usedVarsId[i] = -1;
      }

      /* resize impliedNode array */
      impliedVars.clear();
      impliedVars.growTo(nSolverVars);
      for (i=0; i<nSolverVars; i++) {
        impliedVars[i] = 0;
      }
      impliedNode.clear();
      impliedNode.growTo(nNodes);
      for (i=0; i<nNodes; i++) {
        impliedNode[i] = 0;
      }


      //      fatherId.growTo(nNodes);
      //for (i=nNodes-1; i>=0; i--) {
      //	fatherId[i] = -1;
      //}

      /* resolve */

      for (i=nNodes-1; i>=0; i--) {
        cntDup += reduceNodeOdc(i);
      }
      for (i=nNodes-1; i>=0; i--) {
        if (isCore[i]>2)
          isCore[i] -= 2;
	Pdtutil_Assert(impliedNode[i]==0,"no impl reset");
      }

      impliedVars.clear();
      impliedNode.clear();
      fatherId.clear();
      fatherPin.clear();

      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
        printf("ITP proof dupv: %d - implNodesOdc: %d\n", cntDup, implNodesCnt));

    }

    void saveProof  () {
      int i;
      isCore.copyTo(isCoreSave);
      isRoot.copyTo(isRootSave);

      proofNodesSave.clear();
      proofNodesSave.growTo(proofNodes.size());
      for (i=0; i<proofNodes.size(); i++)
	proofNodes[i].copyTo(proofNodesSave[i]);

      clausesSave.clear();
      clausesSave.growTo(clauses.size());
      for (i=0; i<clauses.size(); i++)
	clauses[i].copyTo(clausesSave[i]);

      varsSave.clear();
      varsSave.growTo(vars.size());
      for (i=0; i<vars.size(); i++)
	vars[i].copyTo(varsSave[i]);

      nAClausesSave = nAClauses;
    }

    void clearProof  () {
      isCore.clear();
      isRoot.clear();
      proofNodes.clear();
      clauses.clear();
      vars.clear();
    }

    void restoreProof  () {
      int i;
      isCoreSave.copyTo(isCore); isCoreSave.clear();
      isRootSave.copyTo(isRoot); isRootSave.clear();

      proofNodes.clear();
      proofNodes.growTo(proofNodesSave.size());
      for (i=0; i<proofNodesSave.size(); i++)
	proofNodesSave[i].copyTo(proofNodes[i]);

      clauses.clear();
      clauses.growTo(clausesSave.size());
      for (i=0; i<clausesSave.size(); i++)
	clausesSave[i].copyTo(clauses[i]);

      vars.clear();
      vars.growTo(varsSave.size());
      for (i=0; i<varsSave.size(); i++)
	varsSave[i].copyTo(vars[i]);

      nAClauses = nAClausesSave;
    }

    void reduceProof  (int enVarReduce) {
      int i, j, n, v, idLast, nNodes;
      int cntDup=0;
      static int cntCalls=0;
      n=0;
      nNodes = isCore.size();
      idLast = nNodes-1;

      if (nNodes<2) return;

      cntCalls++;
      implNodesCnt=0;
      proofCore();

      /* resize usedVars array */
      usedVars.growTo(nSolverVars+2+2*dummyIteVars.size());
      usedVarsId.growTo(nSolverVars+2+2*dummyIteVars.size());
      for (i=0; i<=nSolverVars+1+2*dummyIteVars.size(); i++) {
        usedVars[i] = 0;
        usedVarsId[i] = -1;
      }

      /* resize impliedNode array */
      impliedVars.clear();
      impliedVars.growTo(nSolverVars);
      for (i=0; i<nSolverVars; i++) {
        impliedVars[i] = 0;
      }
      impliedNode.clear();
      impliedNode.growTo(nNodes);
      for (i=0; i<nNodes; i++) {
        impliedNode[i] = 0;
      }


      //      fatherId.growTo(nNodes);
      //for (i=nNodes-1; i>=0; i--) {
      //	fatherId[i] = -1;
      //}

      /* resolve */
      int saveRootCustomHandling = rootCustomHandling;
      //rootCustomHandling &= enVarReduce;
      
      if (rootCustomHandling)
        proofCoreReducePreprocess (enVarReduce);

      cntImpliedUsedVars=0;
      upperResolutionLits.growTo(nNodes);
      for (i=nNodes-1; i>=0; i--) {
        cntDup += reduceNode(i, enVarReduce,
                             &upperResolutionLits[i]);
#if 0
        for (j=0; j<nNodes; j++) {
          Pdtutil_Assert(impliedNode[j]==0,"implied flag not reset");
        }
        for (j=0; j<nSolverVars; j++) {
          Pdtutil_Assert(impliedVars[j]==0,"implied var not reset");
          Pdtutil_Assert(usedVars[j]==0,"used var not reset");
        }
#endif
      }
      upperResolutionLits.clear();
      for (i=nNodes-1; i>=0; i--) {
        if (isCore[i]>2)
          isCore[i] -= 2;
        if (rootCustomHandling)
          impliedNode[i] = 0;
	Pdtutil_Assert(impliedNode[i]==0,"no impl reset");
      }
      rootCustomHandling &= saveRootCustomHandling;

      fatherId.clear();
      fatherPin.clear();

      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
        printf("ITP proof dupv: %d [impl: %d] - implNodes: %d\n",
               cntDup, cntImpliedUsedVars, implNodesCnt));

    }

    void reduceProofPba  (void) {
      int i, j, n, v, idLast, nNodes;
      int cntDup=0, notOk=0;
      static int nCalls = 0;
      n=0;
      nNodes = isCore.size();
      idLast = nNodes-1;

      if (nNodes<2) return;

      if (resolutionClauses.size()!=nNodes)
        return;
      nCalls++;
      Solver S2;
      vec<int>  clauseActVar;
      vec<bool> coreVar;
      vec<int>  varToSolver;
      vec<int>  varFromSolver;
      while (S2.nVars()<nSolverVars) S2.newVar();
      clauseActVar.growTo(nNodes);
      coreVar.growTo(nSolverVars+nNodes);
      
      int nUnsat = 0, nRes = 0, totLit = 0, coreLit = 0,
        removed=0;
      long endTime=0, startTime=0;
      
      for (i=0; i<nNodes && S2.okay(); i++) {
        if (!isCore[i]) continue;
        vec<Lit> clNew;
        if (!isRoot[i]) {
          Pdtutil_Assert ((i==nNodes-1 ||
                          resolutionClauses[i].size()>0),
                         "missing res clause");
          vec<Lit>& c = resolutionClauses[i];
          vec<ClauseId>& cs = proofNodes[i];
          vec<Lit>& xs = vars[i];
          vec<Lit> assume, coreRes;
          assume.clear();
          totLit += c.size();
          nRes++;
          for (int k=0; k<c.size(); k++) {
            assume.push(~c[k]);
          }
          for (j=0; j<cs.size(); j++) {
            int next = cs[j];
            Var actv = clauseActVar[next];
            coreVar[actv] = false;
            assume.push(~Lit(actv));
          }
          for (j=0; j<assume.size(); j++) {
            Var v = var(assume[j]);
            Pdtutil_Assert(v<coreVar.size(),
                           "out of coreVar array bounds");
            coreVar[v] = false;
          }
          // mancano le altre clausole
          int mySat = S2.solve(assume, -1.0);
          Pdtutil_Assert (!mySat,"wrong SAT in core");
          nUnsat++;
          if (S2.conflict.size()==0) continue; // already unsat
          coreRes.clear();
          for (int k=0; k<S2.conflict.size(); k++) {
            Var v = var(S2.conflict[k]);
            Pdtutil_Assert(v<coreVar.size(),
                           "out of coreVar array bounds");
            coreVar[v] = true;
          }
          for (j=0; j<cs.size(); j++) {
            int next = cs[j];
            Var actv = clauseActVar[next];
            Pdtutil_Assert(actv<coreVar.size(),
                           "out of coreVar array bounds");
            if (j>0 && !coreVar[actv]) {
              // remove node
              v = var(xs[j-1]);
              int isAnd = !isOrRes(i,j-1,v);
              cs[j] = (isAnd) ? oneConstId : zeroConstId;
            }
            coreVar[actv] = false;
          }
          for (int k=0; k<c.size(); k++) {
            if (coreVar[var(c[k])]) {
              coreRes.push(c[k]);
            }
            coreVar[var(c[k])] = false;
          }
          
          coreLit += coreRes.size();
          if (coreRes.size()<c.size()) {
            coreRes.copyTo(c);
          }

          if (!S2.okay()) {
            notOk=1;
          }
          c.copyTo(clNew);
        }
        else {
          vec<Lit>& c = clauses[i];
          c.copyTo(clNew);
        }
        if (clNew.size()>0) {
          int actVar = S2.nVars();  S2.newVar();     
          clNew.push(Lit(actVar));
          clauseActVar[i] = actVar;
          S2.addClause(clNew);
        }
      }

      endTime = util_cpu_time();
      fprintf(dMgrO(ddiMgr),
      "Solver SAT core: %s %ld/%ld/%ld(%ld) dec./prop./confl.(small)\n",
              notOk?"(!OK":"",
          (int)S2.stats.decisions, (int)S2.stats.propagations,
          (int)S2.stats.conflicts,(int)S2.stats.smallconflicts);
      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
                           printf("SAT core reduction: %d/%d unsat/tot - %d/%d lits/tot (removed: %d)\n", nUnsat, nRes, coreLit, totLit, removed));
      fprintf(dMgrO(ddiMgr),
              "Execution time = %s)\n",
              util_print_time(endTime-startTime));

    }
    
    void reduceProofBySubsumption  (void) {
      int i, j, n, v, idLast, nNodes;
      int cntDup=0;
      vec<vec<Lit> >  newResolutionClauses;
      vec<char> subsuming;
      vec<int> remapped;
      vec<int> fanout;
      vec<int> residualFanout;
      vec<int> lastFanout;
      n=0;
      nNodes = isCore.size();
      idLast = nNodes-1;

      if (nNodes<2) return;

      if (resolutionClauses.size()!=nNodes)
        return;

      subsuming.growTo(nSolverVars);
      fanout.growTo(nNodes);
      residualFanout.growTo(nNodes);
      lastFanout.growTo(nNodes);
      remapped.growTo(nNodes);
      for (i=0; i<nSolverVars; i++) {
        subsuming[i] = 0;
      }
      int nSubs = 0, nRemapped = 0, nSubsFo1 = 0, nOpenFo = 0,
        removed=0, notOk=0;
      
      for (i=0; i<nNodes; i++) {
        fanout[i] = 0;
        if (!isCore[i] || isRoot[i]) continue;
        vec<ClauseId>& cs = proofNodes[i];
        for (int jj = 0; jj < cs.size(); jj++) {
          int node_j = nodeId(cs[jj]);
          Pdtutil_Assert(node_j<nNodes,"wrong nodeId");
          fanout[node_j]++;
          lastFanout[node_j] = i;
        }
      }
      for (i=0; i<nNodes; i++) {
        remapped[i] = i;
        residualFanout[i] = fanout[i];
        if (!isCore[i] || isRoot[i]) continue;
        vec<Lit>& c = resolutionClauses[i];
        vec<ClauseId>& cs = proofNodes[i];
        vec<Lit>& xs = vars[i];
        int nSubsLits = c.size();
        for (j=0; j<c.size(); j++) {
          Var v = var(c[j]);
          subsuming[v] = sign(c[j])?-1:1;
        }
        int jj;
        for (jj = 0; jj < cs.size(); jj++) {
          int node_j = nodeId(cs[jj]);
          residualFanout[node_j]--;
          if (remapped[node_j]>node_j && remapped[node_j]<i) {
            nRemapped++;
            node_j = remapped[node_j];
            Pdtutil_Assert(node_j<nNodes,"wrong nodeId");
            cs[jj] = node_j;
          }
          vec<Lit> *c_j = isRoot[node_j] ?
            &clauses[node_j] :
            &resolutionClauses[node_j];
          int k, cntSubs = 0;
          for (k=0; k<c_j->size(); k++) {
            Var v_k = var((*c_j)[k]);
            if (subsuming[v_k]) {
              if ((subsuming[v_k]>0) ^ sign((*c_j)[k])) {
                cntSubs++;
              }
            }
          } 
          if (cntSubs == nSubsLits) {
            // subsumed
            nSubs++;
            if (fanout[node_j]==1)
              nSubsFo1++;
            if (lastFanout[node_j]>i)
              nOpenFo++;
            remapped[node_j] = i;
          }
        }
        for (j=0; j<c.size(); j++) {
          Var v = var(c[j]);
          subsuming[v] = 0;
        }
      }
      
      Pdtutil_VerbosityMgrIf(ddiMgr, Pdtutil_VerbLevelDevMin_c) {
        fprintf(stdout, "PROOF SUBSUMED CLAUSES: %d (fo1: %d) - remapped: %d (openFo: %d)\n", nSubs, nSubsFo1, nRemapped, nOpenFo);
      }
    }

    void reduceRedundantResolvents  (void) {
      int i, j, n, v, idLast, nNodes;
      int cntDup=0;

      nNodes = isCore.size();
      idLast = nNodes-1;

      if (nNodes<2) return;

      if (resolutionClauses.size()!=nNodes)
        return;

      int nRed = 0, nTot = 0;

      resolveStart();
      for (i=0; i<nNodes; i++) {
        if (isRoot[i] || !isCore[i]) continue;
        vec<Lit>& r = resolutionClauses[i];
        vec<ClauseId>& cs = proofNodes[i];
        vec<Lit>& xs = vars[i];
        vec<ClauseId> newCs;
        vec<Lit> newXs;
        resolveNodeStart(r);
        newCs.push(cs[0]);
        for (j = 1; j < cs.size(); j++) {
          int node_j = nodeId(cs[j]);
          Var v_j = var(xs[j-1]);
          int remove=0, ret;
          nTot++;
          vec<Lit> *r_j = (isRoot[node_j]) ?
            &clauses[node_j] :
            &resolutionClauses[node_j];
          // now resolve
          remove = redundantResolvent(r, *r_j, v_j);
          if (!remove) {
            newCs.push(cs[j]);
            newXs.push(xs[j-1]);
          }
          else {
            nRed++;
          }
        }
        resolveNodeEnd(r);          
        //assert(rCl.size()<=(notResolved+r.size()));
        newCs.copyTo(cs);
        newXs.copyTo(xs);
      }
      
      Pdtutil_VerbosityMgrIf(ddiMgr, Pdtutil_VerbLevelDevMin_c) {
        fprintf(stdout, "REDUNDANT RESOLVENTS: %d/%d\n", nRed, nTot);
      }
    }

    void recomputeResolutions  (int doRestructProof) {
      int i, j, n, v, idLast, nNodes;
      int cntDup=0;
      static int cntCalls=0; cntCalls++;
      vec<int> lastFanout;
      n=0;
      nNodes = isCore.size();
      idLast = nNodes-1;

      if (nNodes<2) return;

      if (resolutionClauses.size()!=nNodes)
        return;

      
      int nOldLits=0, nNewLits=0, nOldNodes = nNodes;
      isAresCl.growTo(nNodes);
      isBresCl.growTo(nNodes);

      resolveStart();
      for (i=0; i<nNodes; i++) {
        if (isRoot[i] || !isCore[i]) continue;
        vec<Lit>& r = resolutionClauses[i];
        vec<ClauseId>& cs = proofNodes[i];
        vec<Lit>& xs = vars[i];
        vec<ClauseId> newCs;
        vec<Lit> newXs;
        vec<Lit> rCl;
        int node_0 = nodeId(cs[0]);
        int notResolved = 0;
        int isAClause=0, isBClause=0;
        newXs.clear(); newCs.clear();
        if (isRoot[node_0]) {
          clauses[node_0].copyTo(rCl);
          isAClause = isACl(node_0);
          isBClause = !isAClause;
        }
        else {
          isAClause = isAresCl[node_0];
          isBClause = isBresCl[node_0];
          resolutionClauses[node_0].copyTo(rCl);
        }
        resolveNodeStart(rCl);
        newCs.push(cs[0]);
        for (j = 1; j < cs.size(); j++) {
          int node_j = nodeId(cs[j]);
          Var v_j = var(xs[j-1]);
          Lit newL_j;
          int remove=0, ret;
          vec<Lit> *r_j = (isRoot[node_j]) ?
            &clauses[node_j] :
            &resolutionClauses[node_j];
          // now resolve
          if (isRoot[node_j]) {
            isAClause &= isACl(node_j);
            isBClause &= !isACl(node_j);
          }
          else {
            isAClause &= isAresCl[node_j];
            isBClause &= isAresCl[node_j];
          }
          ret = resolveAfterSimp(rCl, *r_j, v_j, doRestructProof);
          if (ret<0) {
            // no resolution
            remove = 1;
            notResolved++;
          }
          else if (ret>0) {
            //            xs[j-1] = newL_j;
            // simply reset as other choosen
            remove = 1;
            notResolved++;
            newCs.clear();
            newXs.clear();
            newCs.push(cs[j]);
          }
          if (!remove) {
            newCs.push(cs[j]);
            newXs.push(xs[j-1]);
          }
        }
        resolveNodeEnd(rCl);          
        //assert(rCl.size()<=(notResolved+r.size()));
        newCs.copyTo(cs);
        newXs.copyTo(xs);
        nOldLits += r.size();
        nNewLits += rCl.size();
        rCl.copyTo(r);
        isAresCl[i] = isAClause;
        isBresCl[i] = isBClause;
        if (rCl.size()==0 && i<nNodes-1) {
          //          printf("REDUCTION\n");
          nNodes = i+1;
          break;
        }
      }
      if (proofNodes.size()>nNodes) {
        int shrink = proofNodes.size()-nNodes;
        proofNodes.shrink(shrink);
        resolutionClauses.shrink(shrink);
        isRoot.shrink(shrink);
        isCore.shrink(shrink);
        isAresCl.shrink(shrink);
        isBresCl.shrink(shrink);
      }
      //assert(resolutionClauses[nNodes-1].size()==0);
      Pdtutil_VerbosityMgrIf(ddiMgr, Pdtutil_VerbLevelDevMin_c) {
        fprintf(stdout, "RECOMPUTED RESOLUTION CLAUSES: old lits %d - new lits: %d - clauses: %d->%d\n",
                nOldLits, nNewLits, nOldNodes, nNodes);
      }
    }

    void reduceProofSimple  (void) {
      int i, j, n, v, idLast, nNodes;
      int cntDup=0;
      n=0;
      nNodes = isCore.size();
      idLast = nNodes-1;

      if (nNodes<2) return;

      proofCore();

      /* resize usedVars array */
      usedVars.growTo(nSolverVars+2+2*dummyIteVars.size());
      usedVarsId.growTo(nSolverVars+2+2*dummyIteVars.size());
      for (i=0; i<=nSolverVars+1+2*dummyIteVars.size(); i++) {
        usedVars[i] = 0;
        usedVarsId[i] = -1;
      }

      /* resolve */
      cntImpliedUsedVars=0;
      for (i=nNodes-1; i>=0; i--) {
        cntDup += reduceNodeSimple(i);
      }

      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
        printf("ITP proof red Simpl (impl: %d): %d\n",
               cntImpliedUsedVars, cntDup));

    }

    void reduceProofByVar  () {
      int i, j, n, v, idLast, nNodes;
      int cntDup=0;
      Var vRes;
      vec<char> usedUpper;
      static int nCalls=0;

      nCalls++;
      n=0;
      nNodes = isCore.size();
      idLast = nNodes-1;

      if (nNodes<2) return;

      implNodesCnt=0;
      proofCore();
      countPivots(-1);

      for (int p=0; p<maxPivots.size(); p++) {
	vRes = maxPivots[p];
	
	usedUpper.clear();
	nNodes = proofNodes.size();
	usedUpper.growTo(nNodes);
	for (i=0; i<nNodes; i++) {
	  usedUpper[i] = (char)0;
	}
	usedUpper[nNodes-1] = (char)4; // set unused

	for (i=nNodes-1; i>=0; i--) {
	  cntDup += reduceNodeByVar (i, vRes, usedUpper);
	}
	if (0) {
	  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddiMgr);
	  ddiMgr->settings.verbosity = Pdtutil_VerbLevelNone_c; 
	  remapItpProof(0);
	  ddiMgr->settings.verbosity = verbosity; 
	}
      }
      fatherId.clear();
      fatherPin.clear();

      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
        printf("ITP proof reduced by %d vars: %d\n", 
	       maxPivots.size(), cntDup));

    }

    void genRootConstants  () {
      int i, j, offset=2, nRoots, nNodes;

      if (constRootsUsed) return;
      constRootsUsed = 1;

      nNodes = isCore.size();
      nRoots = clauses.size();

      isCore.push(); isCore.push();
      isRoot.push(); isRoot.push();
      if (handleAClauses) {
	nResA.push(); nResA.push();
      }
      if (genResolution || genResolution2) {
	if (genResolution2) {
	  isAClause.push(); isAClause.push();
	}
	resolutionClauses.push(); resolutionClauses.push();
      }
      clauses.push(); clauses.push();
      proofNodes.push(); proofNodes.push();
      vars.push(); vars.push();
      if (topResClauses.size()>0) {
	topResClauses.push(); topResClauses.push();
      }

      for (i=nNodes-1; i>=0; i--) {
        if (!isRoot[i]) {
          proofNodes[i].copyTo(proofNodes[i+2]);
	  if (topResClauses.size()>i)
	    topResClauses[i].copyTo(topResClauses[i+2]);
          vars[i].copyTo(vars[i+2]);
          vec<ClauseId>& cs = proofNodes[i+2];
          for (j = 0; j < cs.size(); j++) {
            cs[j]+=2;
          }
        }
        else {
          clauses[i].copyTo(clauses[i+2]);
          proofNodes[i+2].clear();
          vars[i+2].clear();
        }
        isRoot[i+2] = isRoot[i];
        isCore[i+2] = isCore[i];
	if (genResolution || genResolution2) {
	  if (genResolution2) {
	    isAClause[i+2] = isAClause[i];
	  }
          resolutionClauses[i].copyTo(resolutionClauses[i+2]);
	}
	if (handleAClauses) {
	  nResA[i+2] = nResA[i];
	}
      }

      nAClauses += 2;

      isCore[0] = isCore[1] = 1;
      isRoot[0] = isRoot[1] = 1;
      if (handleAClauses) {
	nResA[0] = nResA[1] = 0;
      }
      clauses[0].clear();
      clauses[1].clear();
      proofNodes[0].clear();
      proofNodes[1].clear();
      if (topResClauses.size()>1) {
	topResClauses[0].clear();
	topResClauses[1].clear();
      }
      vars[0].clear();
      vars[1].clear();

    }

    void topLevelMakeAllGbl  () {
      int i, j, offset=2, nRoots, nNodes;

      if (constRootsUsed) return;
      constRootsUsed = 1;

      nNodes = isCore.size();
      nRoots = clauses.size();

      isCore.push(); isCore.push();
      isRoot.push(); isRoot.push();
      if (handleAClauses) {
	nResA.push(); nResA.push();
      }
      if (genResolution || genResolution2) {
	if (genResolution2) {
	  isAClause.push(); isAClause.push();
	}
	resolutionClauses.push(); resolutionClauses.push();
      }
      clauses.push(); clauses.push();
      proofNodes.push(); proofNodes.push();
      vars.push(); vars.push();
      if (topResClauses.size()>0) {
	topResClauses.push(); topResClauses.push();
      }

      for (i=nNodes-1; i>=0; i--) {
        if (!isRoot[i]) {
          proofNodes[i].copyTo(proofNodes[i+2]);
	  if (topResClauses.size()>i)
	    topResClauses[i].copyTo(topResClauses[i+2]);
          vars[i].copyTo(vars[i+2]);
          vec<ClauseId>& cs = proofNodes[i+2];
          for (j = 0; j < cs.size(); j++) {
            cs[j]+=2;
          }
        }
        else {
          clauses[i].copyTo(clauses[i+2]);
          proofNodes[i+2].clear();
          vars[i+2].clear();
        }
        isRoot[i+2] = isRoot[i];
        isCore[i+2] = isCore[i];
	if (genResolution || genResolution2) {
	  if (genResolution2) {
	    isAClause[i+2] = isAClause[i];
	  }
          resolutionClauses[i].copyTo(resolutionClauses[i+2]);
	}
	if (handleAClauses) {
	  nResA[i+2] = nResA[i];
	}
      }

      nAClauses += 2;

      isCore[0] = isCore[1] = 1;
      isRoot[0] = isRoot[1] = 1;
      if (handleAClauses) {
	nResA[0] = nResA[1] = 0;
      }
      clauses[0].clear();
      clauses[1].clear();
      proofNodes[0].clear();
      proofNodes[1].clear();
      if (topResClauses.size()>1) {
	topResClauses[0].clear();
	topResClauses[1].clear();
      }
      vars[0].clear();
      vars[1].clear();

    }

    int updateEq(vec<int>& eqTable, Var v0, Var v1, int complV) {
      assert(eqTable.size()>v0 && eqTable.size()>v1);
      if (eqTable[v0]!=(v0+1) && eqTable[v1]!=(v1+1)) return 0;     
      if (eqTable[v1]!=(v1+1)) {
        if (isGlobal(v0)&&!isGlobal(v1)) {
          // disable now: to check and handle
          return 0;
        }
        Var t = v0; v0 = v1; v1 = t;
      }
      // now merge v1->v0
      eqTable[v1]=eqTable[v0];
      if (complV) {
        eqTable[v1] = -eqTable[v1];
      }
      return 1;
    }

    void remapImplTable(void) {
      if (!enUseImplTable || implTableIds[0].size()==0) return;
      int nOld = remap.size();
      int nNew = resolutionClauses.size();
      for (int tab = 0; tab<2; tab++) {
        for (int i=0; i<implTableIds[tab].size(); i++) {
          for (int j=0; j<implTableIds[tab][i].size(); j++) {
            int oldId = implTableIds[tab][i][j];
            int newId = remap[oldId];
            assert(newId>=0);
            if (newId >= nNew) newId = -1; // disable;
            implTableIds[tab][i][j] = newId;
          }
        }
      }
      implTableResSize = nNew;
    }
    
    void updateImpl(vec<Lit>& cl, int id) {
      Lit l0=cl[0], l1=cl[1];
      Var v0 = var(l0);
      Var v1 = var(l1);
      assert(implTable[0].size()>v0 && implTable[0].size()>v1);
      assert(implTable[1].size()>v0 && implTable[1].size()>v1);
      int s0 = sign(l0);
      int s1 = sign(l1);
      //!l0 => l1
      implTable[s0?0:1][v0].push(l1);
      implTableIds[s0?0:1][v0].push(id);
      //!l1 => l0
      implTable[s1?0:1][v1].push(l0);
      implTableIds[s1?0:1][v1].push(id);
    }

    int impliedVar(Var v, int idChain) {
      if (!enUseImplTable) return 0;
      if (!isBVar(v)) return 0;
      if (isGlobal(v)) return 0;
      int nNodes = resolutionClauses.size();
      //      idChain = 2;
      assert(implTableResSize == nNodes);
      assert(implTable[0].size()>v && implTable[1].size()>v);
      vec<Lit>& lits0 = implTable[0][v]; 
      vec<Lit>& lits1 = implTable[1][v]; 
      int ret0 = 0, ret1 = 0;
      int id=0;
      int maxId[2] = {1,idChain-1};
      for (int t = 0; t<2; t++) {
        int idMin = idChain;
        for (int i=0; i<lits0.size(); i++) {
          Lit l_i = lits0[i];
          Var v_i = var(l_i);
          if (!isBVar(v_i)) continue;
          if (!isBVar(v_i)||isGlobal(v_i)) continue;
          //          if (isGlobal(v_i)) continue;
          // v => l_i, !l_i => !v 
          if (1&&(usedVars[v_i]>0) && !sign(l_i)) {
            id = implTableIds[0][v][i];
            if (id>=0 && id<=maxId[t]) {
              assert(id>=0&&id<nNodes);
              ret0++;
              if (t==0) break;
              if (abs(id) < abs(idMin)) {
                idMin = id;
              }
            }
          }
          if (1&&(usedVars[v_i]<0) && sign(l_i)) {
            id = implTableIds[0][v][i];
            if (id>=0 && id<=maxId[t]) {
              assert(id>=0&&id<nNodes);
              ret0++;
              if (t==0) break;
              if (abs(id) < abs(idMin)) {
                idMin = id;
              }
            }
          }
        }
        if (t>0 || ret0==0) {
          for (int i=0; i<lits1.size(); i++) {
            Lit l_i = lits1[i];
            Var v_i = var(l_i);
            // !v => l_i, !l_i => v 
            if (!isBVar(v_i)||isGlobal(v_i)) continue;
            if (1&&(usedVars[v_i]>0) && !sign(l_i)) {
              id = implTableIds[1][v][i];
              if (id>=0 && id<=maxId[t]) {
                assert(id>=0&&id<nNodes);
                ret1--;
                if (t==0) break;
                if (abs(id) < abs(idMin)) {
                  idMin = id;
                  ret0=0;
                }
              }
            }
            if (1&&(usedVars[v_i]<0) && sign(l_i)) {
              id = implTableIds[1][v][i];
              if (id>=0 && id<=maxId[t]) {
                assert(id>=0&&id<nNodes);
                ret1--;
                if (t==0) break;
                if (abs(id) < abs(idMin)) {
                  idMin = id;
                  ret0=0;
                }
              }
            }
          }
          if (t==1) {
            id = idMin;
          }
        }
        if (ret0>0 && ret1==0) {
          //        if (implCalls >= 134999) {
          //          printf("found\n");
          //        }
          //        if (implCalls++ > implCallsMax) return 0;
          return 1+id;
        }
        if (ret0==0 && ret1<0) {
          //        if (implCalls >= 134999) {
          //          printf("found\n");
          //        }
          //        if (implCalls++ > implCallsMax) return 0;
          return -1-id;
        }
      }
      return 0;
      if (ret0>1) {
        printf("ret0: %d\n", ret0);
      }
      else if (ret1<-1) {
        printf("ret1: %d\n", ret1);
      }
      else if (ret0>0 && ret1<0) {
        //printf("conflict \n");
      }
      return 0;
    }
    
    void moveUnitClauses  (bool unitOnly=false) {
      int i, j, offset=2, nRoots, nNodes, nRes, nUnit, nUnitRef, nTwo, nTwoRef, nTwoRes, nTwoResRef, nTwoResGlob, nTwoResRefGlob;

      vec<char> isUnitLit;
      vec<char> isUnit;
      vec<char> isUnitA;
      vec<char> isTwo;

      nNodes = isCore.size();
      nRoots = clauses.size();
      nRes = resolutionClauses.size();
      
      isTwo.growTo(nNodes);
      isUnitLit.growTo(nSolverVars);
      isUnit.growTo(nNodes);
      isUnitA.growTo(nNodes);

      nUnit = nTwo = nTwoRes = nTwoResGlob = 0;
      for (i=0; i<nSolverVars; i++) {
        isUnitLit[i] = 0;
      }
      for (i=0; i<nNodes; i++) {
        isTwo[i] = 0;
        isUnitA[i] = 0;
        if (i>nNodes-10) continue;
        if (i<nRoots) {
          isUnit[i] = clauses[i].size()==1;
          isTwo[i] = clauses[i].size()==2;
          if (isUnit[i]) {
            Var v = var(clauses[i][0]);
            isUnitA[i] = !isGlobal(v)&&isBVar(v);
            Pdtutil_Assert(v<nSolverVars,"wrong var");
            isUnitLit[v] = sign(clauses[i][0])?-1:1;
            nUnit++;
          }
          if (isTwo[i]) {
            //            nTwo++;
          }
        }
        else if (i<nRes) {
	  vec<Lit>& c = resolutionClauses[i];
          isUnit[i] = c.size()==1;
          isTwo[i] = c.size()==2;
          if (isUnit[i]) {
            Var v = var(c[0]);
            isUnitA[i] = !isGlobal(v)&&isBVar(v);
            Pdtutil_Assert(v<nSolverVars,"wrong var");
            isUnitLit[v] = sign(c[0])?-1:1;
            nUnit++;
          }
          if (isTwo[i]) {
            nTwoRes++;
          }
        }
        else {
          isUnit[i] = 0;
        }
      }

      if (nUnit==0) return;

      nUnitRef=nTwoRef=nTwoResRef=nTwoResRefGlob=0;
      int doCompact = 0;
      for (i=nNodes-1; i>=0; i--) {
        if (!isRoot[i] && isCore[i]) {
          vec<ClauseId>& cs = proofNodes[i];
          vec<Lit>& xs = vars[i];
          int jj, jRef, maxCompact = cs.size()-2;
          for (j = jj = 0; j < cs.size(); j++) {
            jRef = nodeId(cs[j]);
            if (isTwo[jRef]) {
              if (jRef<nRoots) {
                nTwoRef++;
              }
              else {
                nTwoResRef++;
              }
            }
            if (!isUnit[jRef]) {
              if (doCompact) {
                cs[jj] = cs[j];
                if (jj>0) xs[jj-1] = xs[j-1];
                jj++;
              }
            }
            else {
              if (doCompact && (isUnit[i] || maxCompact<=0)) {
                cs[jj] = cs[j];
                if (jj>0) xs[jj-1] = xs[j-1];
                jj++;
              }
              else {
                maxCompact--;
              }
              nUnitRef++;
              if (isUnit[jRef]==1) isUnit[jRef] = 2;
            }
          }
          if (doCompact) {
            assert(jj>=0);
            while (jj<cs.size()) {
              cs.pop();
              if (xs.size()>0)
                xs.pop();
            }
          }
        }
      }

      if (nUnitRef==0) return;

      proofNodes.growTo(nNodes+1);
      isCore.push((char)1);
      isRoot.push((char)0);
      if (nRes>0)
        resolutionClauses.push();
      vec<ClauseId> cs, auxCs;
      cs.clear();
      auxCs.clear();
      vars.push();
      vec<Lit> xs, auxXs;
      auxXs.clear();
      xs.clear();
      cs.push(nNodes-1);

      int canReduce=0;
      int newImplied;
      int lastNode = nRoots, stepNodes = (nNodes-lastNode)/4+1;
      do {
        newImplied=0;
        for (i=0; i<lastNode; i++) {
          vec<Lit> *cp; 
          if (i<nRoots) {
            cp = &clauses[i];
          }
          else {
            cp = &resolutionClauses[i];
          }
          vec<Lit>& c = (*cp); 
          if (isTwo[i]>0) {
            assert(c.size()==2);
            // if (isBVar(var(c[0]))) {
            for (j=0; j<2; j++) {
              int impl = (j+1)%2;
              int v_j = var(c[j]);
              Pdtutil_Assert(v_j<nSolverVars,"wrong var");
              if (isUnitLit[v_j]!=0) {
                if (sign(c[j]) != (isUnitLit[v_j]<0)) {
                  // impl sign!!! so impl variable phase
                  int v_impl = var(c[impl]);
                  Pdtutil_Assert(v_impl<nSolverVars,"wrong var");
                  if (isUnitLit[v_impl]==0) {
                    // another implied literal
                    auxCs.push(i);
                    auxXs.push(~c[impl]);
                    isUnitLit[v_impl] = sign(c[impl])?-1:1;
                    newImplied++;
                    isUnit[i] = 1;
                    break;
                  }
                }
              }
            }
          }
          else if (!isUnit[i]) {
            int cntUnit = 0;
            int impl = -1;
            for (j=0; j<c.size(); j++) {
              int v_j = var(c[j]);
              int unit_j = 0;
              Pdtutil_Assert(v_j<nSolverVars,"wrong var");
              if (isUnitLit[v_j]!=0) {
                if (sign(c[j]) != (isUnitLit[v_j]<0)) {
                  unit_j = 1;
                }
              }
              if (unit_j) {
                cntUnit++;
              }
              else {
                impl = j;
              }
            }
            if (cntUnit == c.size()-1) {
              Pdtutil_Assert(impl>=0,"missing lit index");
              int v_impl = var(c[impl]);
              Pdtutil_Assert(v_impl<nSolverVars,"wrong var");
              if (isUnitLit[v_impl]==0) {
                // another implied literal
                canReduce++;
                auxCs.push(i);
                auxXs.push(~c[impl]);
                isUnitLit[v_impl] = sign(c[impl])?-1:1;
                newImplied++;
                isUnit[i] = 1;
              }
            }
          }
        }
        nTwo += newImplied;
        if (newImplied==0) {
          lastNode += stepNodes;
          if (lastNode > nNodes) lastNode = nNodes;
        }
      } while (newImplied>0 || lastNode < nNodes);
      
      int nEq=0, nEqG=0, nEqA=0, nEqB=0, nEqAB=0, nImpl=0;
      int nBres=0, nAres=0, nABres=0;

      if (!unitOnly) {
#if 1
  
      vec<resClRef_t> doublep;
      doublep.clear();
      vec<vec<Lit> > auxCl;
      auxCl.clear();
      vec<int> auxId;
      auxId.clear();
      vec<int> eqTable;
      eqTable.growTo(nSolverVars);
      for (i=0; i<nSolverVars; i++) {
        eqTable[i] = i+1;
      }

      for (i=0; i<nNodes; i++) {
        vec<Lit> *cp; 
        if (i<nRoots) {
          cp = &clauses[i];
        }
        else {
          cp = &resolutionClauses[i];
        }
        vec<Lit>& c = (*cp); 
        if (isTwo[i]>0 && !isUnit[i]) {
          assert(c.size()==2);
          resClRef_t clRef;
          clRef.clp = &c;
          clRef.id = i;
          doublep.push(clRef);
        }
        else if (!isUnit[i]) {
          int cntUnit = 0;
          int impl = -1;
          vec<Lit> aux;
          aux.clear();
          for (j=0; j<c.size(); j++) {
            int v_j = var(c[j]);
            int unit_j = 0;
            Pdtutil_Assert(v_j<nSolverVars,"wrong var");
            if (isUnitLit[v_j]!=0) {
              if (sign(c[j]) != (isUnitLit[v_j]<0)) {
                unit_j = 1;
              }
            }
            if (unit_j) {
              cntUnit++;
            }
            else {
              aux.push(c[j]);
              impl = j;
            }
          }
          if (cntUnit == c.size()-2) {
            Pdtutil_Assert(aux.size()==2,"mismatching clause sz");
            auxCl.push();
            aux.copyTo(auxCl.last());
            auxId.push(i);
          }
        }
      }
      for (i=0; i<1&&auxCl.size(); i++) {
        resClRef_t clRef;
        clRef.clp = &auxCl[i];
        clRef.id = auxId[i];
        doublep.push(clRef);
      }
      sort(doublep, compareByLits_lt());

      dummyIteVars.clear();
      int nIteVars=0;
      Var dummyIteVar;
      static int enableEq=0, enableImpl=0;

      if (enableImpl) {
        enableEq=0;
        enUseImplTable = 1;

        implTable[0].growTo(nSolverVars);
        implTable[1].growTo(nSolverVars);
        implTableIds[0].growTo(nSolverVars);
        implTableIds[1].growTo(nSolverVars);
        implTableResSize = resolutionClauses.size();
        for (i=0; i<nSolverVars; i++) {
          implTable[0][i].clear();
          implTable[1][i].clear();
          implTableIds[0][i].clear();
          implTableIds[1][i].clear();
        }
        for (i=0; i<doublep.size(); i++) {
          vec<Lit>& v = *(doublep[i].clp);
          int id = doublep[i].id;
          assert(id>=0&&id<nNodes);
          if (isAresCl[id] && !isBresCl[id]) {
            nAres++;
          }
          else if (!isAresCl[id] && isBresCl[id]) {
            nBres++;
          }
          else {
            nABres++;
          }

          updateImpl(v,id);
          nImpl++;

        }
        Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
          printf("ITP proof implications : %d - A:%d B:%d AB:%d\n",
                  nImpl, nAres, nBres, nABres)); 
      }

      for (i=1; enableEq && i<doublep.size(); i++) {
        vec<Lit>& v0 = *(doublep[i-1].clp);
        vec<Lit>& v1 = *(doublep[i].clp);
        int id0 = doublep[i-1].id, id1 = doublep[i].id;
        assert(id0>=0&&id0<nNodes);
        assert(id1>=0&&id1<nNodes);
        Lit l00=v0[0], l01=v0[1], l10=v1[0], l11=v1[1];
        if ((l00 == ~l10 && l01 == ~l11) ||
            (l01 == ~l10 && l00 == ~l11)) {
          int isG0 = isGlobal(var(l00));
          int isG1 = isGlobal(var(l01));
          int isB0 = isBVar(var(l00)) && !isG0;
          int isB1 = isBVar(var(l01)) && !isG1;
          int isA0 = !isB0;
          int isA1 = !isB1;
          if (isG0 && isG1) nEqG++;
          if (isA0 && isA1) {
            nEqA++;
          }
          if (isB0 && isB1) nEqB++;
          if (isA0 && isB1 || isB0 && isA1) nEqAB++;
          if (enableEq && (isB0&&isB1||isG0&&isG1||0&&!isA0&&!isA1)) {
            //   if (enableEq && (isA0&&isA1)) {
            int complVars = sign(l00) == sign(l01);
            if (updateEq(eqTable,var(l00),var(l01),complVars)) {
              for (int k=0; k<2; k++) {
                dummyIteVar = nSolverVars+2*nIteVars+1;
                if (1&&isA0)
                  dummyIteVar++;
                dummyIteVars.push(dummyIteVar);
                auxCs.push(k==0?id0:id1);
                auxXs.push(Lit(dummyIteVar));
              }
            }
          }
          nEq++;
        }
      }

      for (i=nNodes-1; i>=0; i--) {
        if (!isRoot[i] && isCore[i]) {
          vec<ClauseId>& cs = proofNodes[i];
          vec<Lit>& xs = vars[i];
          for (j = 0; j < xs.size(); j++) {
            Var v_j = var(xs[j]);
            assert(v_j<eqTable.size());
            if (eqTable[v_j]!=(v_j+1)) {
              Var newv_j = abs(eqTable[v_j])-1;
              assert(newv_j>=0 && newv_j<nSolverVars);
              Lit l_j = Lit(newv_j);
              if (eqTable[v_j]<0) l_j = ~l_j; 
              if (sign(xs[j])) l_j = ~l_j; 
              xs[j] = l_j;
            }
          }
        }
      }

#endif
      }

      for (i=auxXs.size()-1; i>=0; i--) {
        cs.push(auxCs[i]);
        xs.push(auxXs[i]);
      }
      
      for (j=0; j<2; j++) {
        for (i=0; i<nNodes; i++) {
          if (isUnit[i]>1) {
            if (j==0 && !isUnitA[i]) continue;
            if (j==1 && isUnitA[i]) continue;
            cs.push(i);
            if (i<nRoots) {
              vec<Lit>& c = clauses[i];
              assert(c.size()==1);
              xs.push(~c[0]);
            }
            else {
              vec<Lit>& c = resolutionClauses[i];
              assert(c.size()==1);
              xs.push(~c[0]);
            }
          }
        }
      }

#if 0
      if (minHintLits>0) {
        vec<Lit> h;
        hintClauses.clear();
        h.clear();
        for (i=0; i<xs.size(); i++) {
          h.push(xs[i]);
        }
        hintClauses.push();
        h.copyTo(hintClauses.last());
      }
#endif
      if (itpSaveUnitResolutions) {
        vec<Lit> h;
        unitResolutionClauses.clear();
        for (i=0; i<xs.size(); i++) {
          if (!isBVar(var(xs[i]))) continue;
          h.clear();
          h.push(~xs[i]);
          unitResolutionClauses.push();
          h.copyTo(unitResolutionClauses.last());
        }
      }
      
      assert(xs.size()>0);
      xs.copyTo(vars[nNodes]);
      cs.copyTo(proofNodes[nNodes]);
      nNodes++;

      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
        printf("ITP proof unit clauses/refs: %d/%d - Two Cl/refs(+resolution): %d+%d/%d+%d\n",
               nUnit, nUnitRef, nTwo, nTwoRes, nTwoRef, nTwoResRef)); 
      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
        printf("ITP proof has %d(%d/%d/%d/%d/%d) eq(G/A/B/AB/USED), and moved two (gbl) clauses/refs: %d/%d, impl: %d\n",
               nEq, nEqG, nEqA, nEqB, nEqAB, dummyIteVars.size()/2,
               nTwoResGlob, nTwoResRefGlob, nImpl)); 
      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
        printf("ITP proof reduced %d large (>2 lits) res clauses: %d\n",
               canReduce)); 
    }

    Ddi_Bdd_t *rootBddEval (const int id) {
      vec<Lit>& c = remappedRoots[id];
      Ddi_Bdd_t *r = Ddi_BddMakeConst(ddiMgr,0);
      if (constRootsUsed && (id == oneConstId || id == zeroConstId)) {
        if (id==oneConstId) Ddi_BddNotAcc(r);
        return r;
      }

      for (int i = 0; i < c.size(); i++) {
        Ddi_Bdd_t *r_i;
        if (isGlobal(var(c[i]))) {
          /* global var */
          int vCnf;
          if (ddiMgr->cnf.solver2cnf != NULL) {
            vCnf = ddiMgr->cnf.solver2cnf[var(c[i])]+1;
          }
          else {
            vCnf = var(c[i])+1;
          }
          bAigEdge_t litBaig = ddiMgr->cnf.cnf2aig[vCnf];
          if (sign(c[i])) {
            litBaig = bAig_Not(litBaig);
          }
          r_i = Ddi_BddMakeFromBaig(ddiMgr,litBaig);
          int isBddVar = 0;
          if (bAig_isVarNode(bMgr,litBaig)) {
            Ddi_Var_t *v =
              (Ddi_Var_t *) bAig_VarPtr(bMgr, litBaig);
            isBddVar = v==NULL || !Ddi_VarIsAig(v);
          }
          if (isBddVar && Ddi_BddIsMono(r)) {
            Ddi_BddSetMono(r_i);
          }
          else {
            Ddi_BddSetAig(r);
          }
          Ddi_BddOrAcc(r,r_i);
          Ddi_Free(r_i);
        }
      }
      return r;
    }

    Ddi_Bdd_t *nodeBddEval (const vec<ClauseId>& cs, const vec<Lit>& xs, int nResA) {
      int id0;
      Ddi_Bdd_t *r = NULL;
      if (oneId(cs[0])) {
        r = Ddi_BddMakeConst(ddiMgr,1);
      }
      else if (zeroId(cs[0])) {
        r = Ddi_BddMakeConst(ddiMgr,0);
      }
      else {
        id0 = cs[0];
        if (bddHashTh==0) {
          return NULL;
        }
        if (nodeId(id0)<nodeBdd.size() && nodeBdd[nodeId(id0)]!=NULL) {
          r = Ddi_BddDup(nodeBdd[nodeId(id0)]);
          if (invId(id0)) Ddi_BddNotAcc(r);
        }
        else {
          return NULL;
        }
      }

      for (int j = 0; r!=NULL && j < xs.size(); j++) {
        int v = var(xs[j]);
        int isAnd = !isOrResByNres(nResA,j,v);
        Ddi_Bdd_t *r_j = NULL;
        int live0 = Ddi_MgrReadLiveNodes(ddiMgr);
        int live1;
        if (oneId(cs[j+1])) {
          r_j = Ddi_BddMakeConst(ddiMgr,1);
        }
        else if (zeroId(cs[j+1])) {
          r_j = Ddi_BddMakeConst(ddiMgr,0);
        }
        else {
          int id_j = cs[j+1];
          if (nodeId(id_j)<nodeBdd.size() && nodeBdd[nodeId(id_j)]!=NULL) {
            r_j = Ddi_BddDup(nodeBdd[nodeId(id_j)]);
            if (invId(id_j)) Ddi_BddNotAcc(r_j);
          }
        }
        if (r_j != NULL) {
          if (Ddi_BddIsAig(r)) Ddi_BddSetAig(r_j);
          else if (Ddi_BddIsAig(r_j)) Ddi_BddSetAig(r);
          if (isAnd) Ddi_BddAndAcc(r,r_j);
          else Ddi_BddOrAcc(r,r_j);
          Ddi_Free(r_j);
          live1 = Ddi_MgrReadLiveNodes(ddiMgr);
          if (live1-live0Tot > bddHashTh*100) {
            Ddi_Free(r);
            bddHashTh = 0;
          }
          else if (live1-live0 > bddHashTh/2) {
            if (Ddi_BddSize(r) > bddHashTh) {
              Ddi_Free(r);
            }
          }
          live0 = live1;
        }
        else {
          Ddi_Free(r);
          return NULL;
        }
      }

      return r;

    }

    int nodeHashSearchBdd(Ddi_Bdd_t *r, int newId) {
      int ldr_i;
      //      DdNode *cuNode = Cudd_Regular (Ddi_BddToCU(r));
      DdNode *cuNode;
      if (!Ddi_BddIsMono(r)) return -1;
      cuNode = Ddi_BddToCU(r);
      if (Ddi_BddIsConstant(r) && constRootsUsed) {
        return (Ddi_BddIsOne(r) ? oneConstId : zeroConstId);
      }
      if (st_lookup_int(bddTObaigTable, (char *) cuNode, (int*)&ldr_i)) {
        /* merge node_i <-> i */
        if (0 && Ddi_BddIsComplement(r)) {
          ldr_i = -ldr_i;
        }
        bddMergeNum++;
        return ldr_i;
      }
      else {
        ldr_i = newId;
        if (0 && Ddi_BddIsComplement(r)) {
          ldr_i = -ldr_i;
        }
        Cudd_Ref(cuNode);
        st_insert(bddTObaigTable, (char *) cuNode, (char *) (long) ldr_i);
      }
      return -1;
    }

    void remapItpProof  (const int fullRemap) {
      int i, j, n, v, startRoot=0, idLast, nNodes, nRemappedNodes=0;
      int nAClausesNew, resolved2root=0, chain2root=0;
      n=0;
      nNodes = isCore.size();

      if (!useRemapped) return;
      if (nNodes<2) return;

      proofCore();

      remap.clear();
      remappedRoots.clear();
      /* zero and one */
      remappedRoots.push();
      remappedRoots.push();
      if (constRootsUsed) {
        startRoot = 2;
      }
      constRootsUsed = 1;

      remappedNodes.clear();
      remappedVars.clear();
      remappedResClauses.clear();
      /* resize usedVars array */
      remap.growTo(nNodes);

      zeroRoots=oneRoots=literalRoots=clauseRoots=0;

      /* resolve */
      nAClausesNew = -1;
      for (i=0; i<nNodes; i++) {
        if (i==nAClauses) {
          nAClausesNew = remappedRoots.size();
        }
        remap[i] = i;
        if (i>=startRoot && isRoot[i] && isCore[i]>=1) {
          rootWithRemap (i,fullRemap);
        }
	else if (genResolution2 && !isRoot[i] && isAClause[i]>0) {
          int newId = remappedRoots.size();
	  remappedRoots.push();
	  resolutionClauses[i].copyTo(remappedRoots[newId]);
	  remap[i] = newId;
	  resolved2root++;
	}
        else if ((fullRemap>2) && i>=startRoot && !isRoot[i] && isCore[i]) {
          chain2root += chainRootWithRemap(i);
        }
      }
      if (fullRemap>2 && handleAClauses) {
	for (i=0; i<nResA.size(); i++) {
	  Pdtutil_Assert(!isCore[i] || nResA[i]==0,"A res not handled");
	}
      }

      genResolution2 = 0;

      nRemappedRoots = remappedRoots.size();
      remappedNodes.growTo(remappedRoots.size());
      remappedVars.growTo(remappedRoots.size());
      if (resolutionClauses) {
	remappedResClauses.growTo(remappedRoots.size());
      }
      nAClauses = fullRemap >= 0 ? -1 : nAClausesNew;
      bddTObaigTable = NULL;

      if (nLclToGblVars==0 && fullRemap>1 && useMcmRules) {
        /* start BDD evaluation */
        Ddi_MgrSiftSuspend(ddiMgr);

        nodeBdd.growTo(remappedRoots.size());

        for (i=0; i<nRemappedRoots; i++) {
          nodeBdd[i] = rootBddEval(i);
        }

        /* start hash table */
        bddTObaigTable = st_init_table(st_numcmp, st_numhash);
        bddHashTh = 10000;
        bddMergeNum = 0;
        live0Tot = Ddi_MgrReadLiveNodes(ddiMgr);
      }

      vec<int> nResA1;
      nResA1.clear();
      for (i=startRoot; i<nNodes; i++) {
        if (!isRoot[i] && isCore[i]>=1) {
          nRemappedNodes += chainWithRemap (i, 1 && (i<nNodes-1)/* enable BDD sweep */,
                                            nResA1);
        }
      }

      int printrem = 0;
      if (printrem) {
        for (int i=0; i<remap.size(); i++) {
          if (!isCore[i]) continue;
          printf("remap[%3d] %d - core: %d - root: %d",
                 i, remap[i], isCore[i], isRoot[i]);
          if (remap[i]<remappedRoots.size()) {
            vec<Lit>& c = remappedRoots[remap[i]];
            for (int j = 0; j<c.size(); j++) {
              int s = sign(c[j]);
              int vSat = var(c[j]);
              int vCnf = (ddiMgr->cnf.solver2cnf != NULL) ?
                ddiMgr->cnf.solver2cnf[vSat]+1 : vSat+1;
              bAigEdge_t baig = ddiMgr->cnf.cnf2aig[vCnf];
              int isGlob = isGlobal(vSat);
              int isB = isBVar(vSat);
              printf(" %s%d", s?"-":"", baig/4);
              if (isGlob) printf("(G)");
              else if (isB) printf("(B)");
            }
          }
          else {
            vec<ClauseId>& cs = remappedNodes[remap[i]];
            printf (" CHAIN: ");
            for (int j = 0; j<cs.size(); j++) {
              printf (" %d", cs[j]);
            }
          }
          printf("\n");
        }
      }

      if (handleAClauses) {
	nResA1.copyTo(nResA);
      }

      if (bddTObaigTable != NULL) {
        /* stop BDD evaluation */
        DdNode *tmp;
        int ldr_i;
        for (i=0; i<nodeBdd.size(); i++) {
          Ddi_Free(nodeBdd[i]);
        }
        st_foreach_item_int(bddTObaigTable, stgen, (char**)&tmp, (int*)&ldr_i){
          // Pdtutil_Assert(tmp==Cudd_Regular(tmp),"Wrong node in st table");
          Cudd_RecursiveDeref (ddiMgr->mgrCU, tmp);
        }
        st_free_table(bddTObaigTable);
        bddTObaigTable = NULL;
        nodeBdd.clear();
        Ddi_MgrSiftResume(ddiMgr);

        if (bddMergeNum>0) {
          Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
                               printf("bdd merge: %d\n", bddMergeNum));
        }

      }

      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
        printf("ITP proof remapped roots: %d - eq nodes: %d - tot: %d\n",
               remappedRoots.size(), nRemappedNodes, remappedNodes.size()));
      Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
        printf("ROOT stats - zero: %d - one: %d - lit: %d - clause: %d\n",
               zeroRoots, oneRoots, literalRoots, clauseRoots));
      if (chain2root>0 || resolved2root>0) {
        Pdtutil_VerbosityMgr(ddiMgr, Pdtutil_VerbLevelUsrMax_c,
               printf("chain to root: %d - resolved to root; %d\n",
		      chain2root, resolved2root));
      }

      if (partial)
	nNodes = remappedNodes.size();
      else
	nNodes = remap[nNodes-1]+1;
      //      if (nNodes<2) nNodes=2;
      //      Pdtutil_Assert(nNodes>=2,"0 interpolant !!!");
      while (remappedNodes.size()>nNodes) {
        remappedNodes.pop();
        remappedVars.pop();
	if (resolutionClauses) {
	  remappedResClauses.pop();
	}
      }
      while (remappedRoots.size()>nNodes) {
        remappedRoots.pop();
      }
      nRemappedRoots = remappedRoots.size();

      remappedRoots.moveTo(clauses);
      remappedNodes.moveTo(proofNodes);
      if (resolutionClauses) {
	remappedResClauses.moveTo(resolutionClauses);
      }
      remappedVars.moveTo(vars);
      while (nResA.size()>nNodes) {
        nResA.pop();
      }

      remapImplTable();
      
      if (partial) {
	vec<vec<Lit> >  topResClauses2;
	topResClauses2.growTo(nNodes);
	for (i=0; i<remap.size() && i<topResClauses.size(); i++) {
	  int i2 = remap[i];
	  if (topResClauses[i].size()>0) {
	    if (i2<0||i2>=nNodes) {
	      Pdtutil_Assert(i2>=0 && i2<nNodes,"wrong remap");
	    }
	    topResClauses[i].copyTo(topResClauses2[i2]);
	  }
	}
	topResClauses2.moveTo(topResClauses);
      }

      isCore.clear();
      isRoot.clear();
      isCore.growTo(nNodes);
      isRoot.growTo(nNodes);
      for (i=nNodes-1; i>=0; i--) {
        isCore[i] = i<2 || i==nNodes-1;
	if (!isCore[i] && partial) {
	  isCore[i] = topResClauses[i].size()>0;
	}
      }
      for (i=nNodes-1; i>=0; i--) {
        isRoot[i] = i<clauses.size();
        if (!isRoot[i] && isCore[i]) {
          vec<ClauseId>& cs = proofNodes[i];
          for (int j = 0; j < cs.size(); j++) {
            Pdtutil_Assert(nodeId(cs[j])<nNodes,"wrong nodeId");
            isCore[nodeId(cs[j])] = 1;
          }
        }
      }
      remap.clear();
      if (0 && (nNodes<2)) {
        printf("zero\n");
      }

    }

    void printItpProof  (void) {
      int i, j, n, v, startRoot=0, idLast, nNodes, nRemappedNodes=0;
      int nAClausesNew, resolved2root=0, chain2root=0;
      n=0;
      nNodes = isCore.size();

      for (int i=0; i<nNodes; i++) {
        if (!isCore[i]) continue;
        int isAClause = isACl(i);
        printf("node[%3d] - core: %d - root %c: %d",
               i, isCore[i], isAClause?'A':'B', isRoot[i]);
        if (i<clauses.size()) {
          vec<Lit>& c = clauses[i];
          for (int j = 0; j<c.size(); j++) {
            int s = sign(c[j]);
            int vSat = var(c[j]);
            int vCnf = (ddiMgr->cnf.solver2cnf != NULL) ?
              ddiMgr->cnf.solver2cnf[vSat]+1 : vSat+1;
            bAigEdge_t baig = ddiMgr->cnf.cnf2aig[vCnf];
            int isGlob = isGlobal(vSat);
            int isB = isBVar(vSat);
            printf(" %s%d", s?"-":"", baig/4);
            if (isGlob) printf("(G)");
            else if (isB) printf("(B)");
            if (isB && !isGlob && isAClause) {
              assert(0);
              printf("problem\n");
            }
          }
        }
        else {
          vec<ClauseId>& cs = proofNodes[i];
          vec<Lit>& xs = vars[i];
          printf (" CHAIN: ");
          for (int j = 0; j<cs.size(); j++) {
            if(j>0) {
              int v = var(xs[j-1]);
              int isAnd = !isOrRes(i,j-1,v);
              printf (" %c", isAnd?'&':'|');
            }
            printf (" %d", cs[j]);
          }
        }
        printf("\n");
      }
    }

    void checkItpProof  (void) {
      int i, j, n, v, startRoot=0, idLast, nNodes,
        nRemappedNodes=0;
      int nAClausesNew, resolved2root=0, chain2root=0;
      
      vec<bool> isAvar(nSolverVars,false);
      n=0;
      nNodes = isCore.size();

      for (int i=0; i<clauses.size(); i++) {
        if (!isCore[i]) continue;
        vec<Lit>& c = clauses[i];
        int isAClause = isACl(i);
        if (!isAClause) continue;
        for (int j = 0; j<c.size(); j++) {
          int v = var(c[j]);
          isAvar[v] = true;
	  if (isBVar(v)&&!isGlobal(v)) {
	    printf("problem: i: %d - v: %d\n", i, v);
	  }
          assert(!isBVar(v)||isGlobal(v));
        }
      }
      for (int i=0; i<clauses.size(); i++) {
        if (!isCore[i]) continue;
        vec<Lit>& c = clauses[i];
        int isAClause = isACl(i);
        if (isAClause) continue;
        for (int j = 0; j<c.size(); j++) {
          int v = var(c[j]);
          if (isAvar[v]) {
            assert(isGlobal(v));
          }
          else {
            assert(isBVar(v));
          }
        }
      }
    }
    
    void iteRestructProof (const int v, Var dummyIteVar) {
      int i, nNodes, nRoots;
      int isGlob = 0 && isGlobal(v); 
      vec<char> isSplit;

      nNodes = isCore.size();
      nRoots = clauses.size();

      if (v<0) return;
      if (!useRemapped) return;
      if (nNodes<2) return;

      printf("ITE restruct Proof (size: %d - roots: %d) - var %d (%s)\n", 
	     nNodes, nRoots, v,
	     isGlobal(v)?"GLB":"LCL");

      isSplit.clear();
      remap.clear();
      /* zero and one */

      remappedNodes.clear();
      remappedVars.clear();

      remap.growTo(nNodes);
      isSplit.growTo(nNodes);
      remappedNodes.growTo(nRoots);
      remappedVars.growTo(nRoots);

      for (i=0; i<nRoots; i++) {
	Pdtutil_Assert(isRoot[i],"root node needed");
	Pdtutil_Assert(isCore[i],"core node needed");
        remap[i] = i;
        isSplit[i] = (char)0;
      }
      // add v literals

      if (isGlob) {
	remappedNodes.push();
	remappedNodes.push();
	remappedVars.push();
	remappedVars.push();
	clauses.push();
	clauses.push();
	vec<Lit>& lit0 = clauses[nRoots];
	vec<Lit>& lit1 = clauses[nRoots+1];
	lit0.push();
	lit0[0] = Lit(v);
	lit1.push();
	lit1[0] = ~Lit(v);
      }

      for (i=nRoots; i<nNodes; i++) {
	int split=0, nCof=0, v_j=-1, newI, cof0out=0;
	int id0, id1;
	vec<ClauseId>& cs = proofNodes[i];
	vec<Lit>& xs = vars[i];
	Pdtutil_Assert(!isRoot[i],"root node needed");
	Pdtutil_Assert(isCore[i],"core node needed");

	for (int j = 0; j < cs.size(); j++) {
	  Pdtutil_Assert(cs[j]>=0&&cs[j]<i,"wrong node id");
	  if (isSplit[cs[j]]) {
	    split=1;
	  }
	  if (dummyIteVar==var_Undef) {
	    int w = var(xs[j-1]);
	    if (!isBVar(w)) {
	      dummyIteVar = w;
	    }
	  }
	  if (j<xs.size() && (var(xs[j])==v)) {
	    split=1;
	    nCof++; v_j = j+1;
	    /* zero cofactor in chain. one cof cout-of-chain */
	    /* swap if other case (sign is 0: positive) */  
	    cof0out = !sign(xs[j]);
	  }
	}

	Pdtutil_Assert(nCof<2,"var twice in chain");

	isSplit[i] = (char)split;
	newI = remap[i] = remappedNodes.size();
	remappedNodes.push();
	remappedVars.push();

	if (split==0) {
	  vec<ClauseId>& csNew = remappedNodes[newI];
	  vec<Lit>& xsNew = remappedVars[newI];
	  for (int j = 0; j < cs.size(); j++) {
	    csNew.push(remap[cs[j]]);
	  }
	  xs.copyTo(xsNew);
	  continue;
	}
	remappedNodes.push();
	remappedVars.push();

	vec<ClauseId>& csNew0 = remappedNodes[newI];
	vec<Lit>& xsNew0 = remappedVars[newI];
	vec<ClauseId>& csNew1 = remappedNodes[newI+1];
	vec<Lit>& xsNew1 = remappedVars[newI+1];

        int doMerge = remappedNodes.size()>nNodes*1.1;

	if (nCof==0) {
          /* just split on referred ids */
          int cntSplit=0;
          for (int j = 0; j < cs.size(); j++) {
            id0 = id1 = remap[cs[j]];
            if (isSplit[cs[j]]) {
              id1++; cntSplit++;
            }
            csNew0.push(id0);
            csNew1.push(id1);
          }
          xs.copyTo(xsNew0);
          xs.copyTo(xsNew1);
          Pdtutil_Assert(cntSplit>0,"missing split");
          if (doMerge) {
            isSplit[i] = (char)0;
            remap[i] = newI+1;
            csNew1.push(newI);
            xsNew1.push(~Lit(v));
          }
          continue;
        }
	id0 = id1 = remap[cs[0]];
	if (isSplit[cs[0]]) id1++;
	csNew0.push(id0);
	csNew1.push(id1);

	for (int j = 1; j < cs.size(); j++) {
	  id0 = id1 = remap[cs[j]];
	  if (isSplit[cs[j]]) id1++;
	  if (j==v_j) {
	    if (cof0out) {
	      // reset cs0
	      csNew0.clear(); csNew0.push(id0);
	      xsNew0.clear();
	      // skip on cs1
	    }
	    else {
	      // reset cs1
	      csNew1.clear(); csNew1.push(id1);
	      xsNew1.clear();
	      // skip on cs0
	    }
	  }
	  else {
	    csNew0.push(id0); xsNew0.push(xs[j-1]);
	    csNew1.push(id1); xsNew1.push(xs[j-1]);
	  }
	}
	Pdtutil_Assert(csNew0.size()==(xsNew0.size()+1),
		       "array size problem");
	Pdtutil_Assert(csNew1.size()==(xsNew1.size()+1),
		       "array size problem");
      }

      int lastId = remap[nNodes-1];
      if (isSplit[nNodes-1]) {
        Pdtutil_Assert(isSplit[nNodes-1],"last node is not split");
        Pdtutil_Assert(lastId == remappedNodes.size()-2,
		     "split problem");

        if (isGlob) {
          
          remappedNodes.push();
          remappedVars.push();
          remappedNodes.push();
          remappedVars.push();
          
          vec<ClauseId>& cs_v0 = remappedNodes[lastId+2];
          vec<Lit>& xs_v0 = remappedVars[lastId+2];
          vec<ClauseId>& cs_v1 = remappedNodes[lastId+3];
          vec<Lit>& xs_v1 = remappedVars[lastId+3];
          
          cs_v0.clear(); xs_v0.clear();
          cs_v1.clear(); xs_v1.clear();
          cs_v0.growTo(2); xs_v0.push();
          cs_v1.growTo(2); xs_v1.push();
          /* cs[0] is 0 cofactor, so resolve in chain on 1 phase */
          cs_v0[0] = lastId; cs_v0[1] = nRoots;
          cs_v1[0] = lastId+1; cs_v1[1] = nRoots+1;
          //      xs[0] = ~Lit(v);
          xs_v0[0] = Lit(v);
          xs_v1[0] = Lit(v);
          lastId += 2;
          nRoots += 2;
        }
        
        remappedNodes.push();
        remappedVars.push();
        vec<ClauseId>& cs_or = remappedNodes[lastId+2];
        vec<Lit>& xs_or = remappedVars[lastId+2];
        cs_or.clear(); xs_or.clear();
        cs_or.growTo(2); xs_or.push();
        cs_or[0] = lastId; cs_or[1] = lastId+1;
        xs_or[0] = Lit(dummyIteVar);
      }
      
      remappedNodes.moveTo(proofNodes);
      remappedVars.moveTo(vars);
      nNodes = proofNodes.size();

      //      iteVars.push(v);
      isCore.clear();
      isRoot.clear();
      isCore.growTo(nNodes);
      isRoot.growTo(nNodes);
      for (i=0; i<nNodes; i++) {
        isCore[i] = 1;
        isRoot[i] = i<clauses.size();
      }
      remap.clear();

    }

#if 0
    void genCofRestructProof (Var dummyIteVar) {
      int i, nNodes, nRoots;
      vec<char> isSplit;

      nNodes = isCore.size();
      nRoots = clauses.size();

      if (!useRemapped) return;
      if (nNodes<2) return;

      printf("GENCOF restruct Proof (size: %d - roots: %d)\n", 
	     nNodes, nRoots);

      isSplit.clear();
      remap.clear();
      /* zero and one */

      remappedNodes.clear();
      remappedVars.clear();

      remap.growTo(nNodes);
      isSplit.growTo(nNodes);
      remappedNodes.growTo(nRoots);
      remappedVars.growTo(nRoots);

      for (i=0; i<nRoots; i++) {
	Pdtutil_Assert(isRoot[i],"root node needed");
	Pdtutil_Assert(isCore[i],"core node needed");
        remap[i] = i;
        isSplit[i] = (char)0;
      }
      // add v literals

      for (i=nRoots; i<nNodes; i++) {
	int split=0, nCof=0, v_j=-1, newI, cof0out=0;
	int id0, id1;
	vec<ClauseId>& cs = proofNodes[i];
	vec<Lit>& xs = vars[i];
	Pdtutil_Assert(!isRoot[i],"root node needed");
	Pdtutil_Assert(isCore[i],"core node needed");

	for (int j = 0; j < cs.size(); j++) {
	  Pdtutil_Assert(cs[j]>=0&&cs[j]<i,"wrong node id");
	  if (isSplit[cs[j]]) {
	    split=1;
	  }
	  if (j<xs.size() && (isGlobalvar(xs[j]))) {
	    int id1 = nodeId(cs[j]);
	    if (!isACl(jj)) {
	    split=1;
	    nCof++; v_j = j+1;
	    /* zero cofactor in chain. one cof cout-of-chain */
	    /* swap if other case (sign is 0: positive) */  
	    cof0out = !sign(xs[j]);
	  }
	}

	Pdtutil_Assert(nCof<2,"var twice in chain");

	isSplit[i] = (char)split;
	newI = remap[i] = remappedNodes.size();
	remappedNodes.push();
	remappedVars.push();

	if (split==0) {
	  vec<ClauseId>& csNew = remappedNodes[newI];
	  vec<Lit>& xsNew = remappedVars[newI];
	  for (int j = 0; j < cs.size(); j++) {
	    csNew.push(remap[cs[j]]);
	  }
	  xs.copyTo(xsNew);
	  continue;
	}
	remappedNodes.push();
	remappedVars.push();

	vec<ClauseId>& csNew0 = remappedNodes[newI];
	vec<Lit>& xsNew0 = remappedVars[newI];
	vec<ClauseId>& csNew1 = remappedNodes[newI+1];
	vec<Lit>& xsNew1 = remappedVars[newI+1];

	if (nCof==0) {
	  /* just split on referred ids */
	  int cntSplit=0;
	  for (int j = 0; j < cs.size(); j++) {
	    id0 = id1 = remap[cs[j]];
	    if (isSplit[cs[j]]) {
	      id1++; cntSplit++;
	    }
	    csNew0.push(id0);
	    csNew1.push(id1);
	  }
	  xs.copyTo(xsNew0);
	  xs.copyTo(xsNew1);
	  Pdtutil_Assert(cntSplit>0,"missing split");
	  continue;
	}

	id0 = id1 = remap[cs[0]];
	if (isSplit[cs[0]]) id1++;
	csNew0.push(id0);
	csNew1.push(id1);

	for (int j = 1; j < cs.size(); j++) {
	  id0 = id1 = remap[cs[j]];
	  if (isSplit[cs[j]]) id1++;
	  if (j==v_j) {
	    if (cof0out) {
	      // reset cs0
	      csNew0.clear(); csNew0.push(id0);
	      xsNew0.clear();
	      // skip on cs1
	    }
	    else {
	      // reset cs1
	      csNew1.clear(); csNew1.push(id1);
	      xsNew1.clear();
	      // skip on cs0
	    }
	  }
	  else {
	    csNew0.push(id0); xsNew0.push(xs[j-1]);
	    csNew1.push(id1); xsNew1.push(xs[j-1]);
	  }
	}
	Pdtutil_Assert(csNew0.size()==(xsNew0.size()+1),
		       "array size problem");
	Pdtutil_Assert(csNew1.size()==(xsNew1.size()+1),
		       "array size problem");
      }

      int lastId = remap[nNodes-1];
      Pdtutil_Assert(isSplit[nNodes-1],"last node is not split");
      Pdtutil_Assert(lastId == remappedNodes.size()-2,
		     "split problem");

      if (isGlob) {

	remappedNodes.push();
	remappedVars.push();
	remappedNodes.push();
	remappedVars.push();

	vec<ClauseId>& cs_v0 = remappedNodes[lastId+2];
	vec<Lit>& xs_v0 = remappedVars[lastId+2];
	vec<ClauseId>& cs_v1 = remappedNodes[lastId+3];
	vec<Lit>& xs_v1 = remappedVars[lastId+3];

	cs_v0.clear(); xs_v0.clear();
	cs_v1.clear(); xs_v1.clear();
	cs_v0.growTo(2); xs_v0.push();
	cs_v1.growTo(2); xs_v1.push();
	/* cs[0] is 0 cofactor, so resolve in chain on 1 phase */
	cs_v0[0] = lastId; cs_v0[1] = nRoots;
	cs_v1[0] = lastId+1; cs_v1[1] = nRoots+1;
	//      xs[0] = ~Lit(v);
	xs_v0[0] = Lit(v);
	xs_v1[0] = Lit(v);
	lastId += 2;
	nRoots += 2;
      }

      remappedNodes.push();
      remappedVars.push();
      vec<ClauseId>& cs_or = remappedNodes[lastId+2];
      vec<Lit>& xs_or = remappedVars[lastId+2];
      cs_or.clear(); xs_or.clear();
      cs_or.growTo(2); xs_or.push();
      cs_or[0] = lastId; cs_or[1] = lastId+1;
      xs_or[0] = Lit(dummyIteVar);

      remappedNodes.moveTo(proofNodes);
      remappedVars.moveTo(vars);
      nNodes = proofNodes.size();

      //      iteVars.push(v);
      isCore.clear();
      isRoot.clear();
      isCore.growTo(nNodes);
      isRoot.growTo(nNodes);
      for (i=0; i<nNodes; i++) {
        isCore[i] = 1;
        isRoot[i] = i<clauses.size();
      }
      remap.clear();

    }
#endif

    int countResolutions () {
      int nRes=0;
      int nNodes = proofNodes.size();

      for (int i=0; i<nNodes; i++) {
	if (isRoot[i]) continue;
	vec<Lit>& xs = vars[i];
	nRes += xs.size();
      }
      return nRes;
    }

    void iteRestructProofTot (int nIte) {
      int acceptRestruct = 1;
      Var dummyIteVar = var_Undef;
      int nNodes = proofNodes.size();
      vec<Lit>& xs = vars[nNodes-1];
      int nTop = xs.size();
      int topAnd = -1;
      if (nTop>0) {
	int vTop = var(xs[nTop-1]);
	topAnd = !isOrRes(nNodes-1,nTop-1,vTop);
      }
      if (nIte<0) {
	topAnd = 1; // force B var
      }
      //      if (proofNodes.size()<500) return;
      countPivots(topAnd); return;
      //      remapItpProof(0);
      if (maxPivots[0]==var_Undef) return;
      if (nIte<0) {
	// just take vars
	iteVars.clear();
	for (int i=0; nIte++<0 && i<maxPivots.size(); i++) {
	  iteVars.push(maxPivots[i]);
	}
	return;
      }

      if (resolutionClauses) {
	resolutionClauses.release();
	genResolution = 0;
      }

      dummyIteVars.clear();
      iteVars.clear();
      for (int i=0; i<nIte && i<maxPivots.size(); i++) {
	int nRes0, nRes01, nRes1;
	if (0) {
	  dummyIteVar = nSolverVars+2*i+1;
	  if (isGlobal(maxPivots[i]) || !isBVar(maxPivots[i]))
	    dummyIteVar++;
	  if (dummyIteVar==var_Undef) {
	    continue;
	  }
	  dummyIteVars.push(dummyIteVar);
	}
	else dummyIteVar = maxPivots[i];
	saveProof();
	nRes0 = countResolutions();
	//	if (isGlobal(maxPivots[i]))
	iteVars.push(maxPivots[i]);
	iteRestructProof(maxPivots[i], dummyIteVar); 
	nRes01 = countResolutions();
	nRes1 = countResolutions();

	printf("ITE restruct Proof #resolutions: %d -> (%d) %d\n", 
	       nRes0, nRes01, nRes1);
	acceptRestruct = 1 || nRes1<=(nRes0*1.02);
	//      clearProof();
	if (!acceptRestruct) {
	  restoreProof();
	}
	else {
	  printf("ITE restruct Proof ACCEPTED\n");
	}
      }
      maxPivots.clear(); 

      remapItpProof(0);
      reduceProof(1);
      remapItpProof(1);

    }

    void dontCareRestructProofTot (void) {
      Var dummyVar = var_Undef;
      int nNodes = proofNodes.size();
      vec<Lit>& xs = vars[nNodes-1];

      if (0 && resolutionClauses) {
	resolutionClauses.release();
	genResolution = 0;
      }

      for (int i = 0; i<nNodes; i++) {
        if (isCore[i] < 1) {
          continue;
        }
	if (!isRoot[i]) {
          int j;
	  vec<Lit>& xs = vars[i];
          if (xs.size()>1) {
	  for (j = 0; j < xs.size(); j++) {
	    int v = var(xs[j]);
            
            if (isCareVar(v)) {
              int changeToOr = 1;
              if (j>0) {
                int v0 = var(xs[j-1]);
                if (isBVar(v0)) changeToOr = 0;
              }
              if (j<xs.size()-1) {
                int v1 = var(xs[j+1]);
                if (isBVar(v1)) changeToOr = 0;
              }
              if (changeToOr) {
                // even var: A var
                dummyVar = nSolverVars+2*(v+1);
                xs[j] = sign(xs[j])?~Lit(dummyVar):Lit(dummyVar);
              }
            }
          }
          }
        }
      }

      remapItpProof(0);
      reduceProof(1);
      remapItpProof(1);

    }

    int proofMakeAndNode (const int id) {
      int start_j, prevAnd=1, prevOr=1, cntAndOr=0;
      float ratio = 0.5;
      
      vec<ClauseId>& cs = proofNodes[id];
      vec<Lit>& xs = vars[id];
      int jMin = cs.size() * (1-ratio);

      for (int j = cs.size()-1; j>jMin; j--) {
	int sorted = 0;
	ClauseId id = nodeId(cs[j]);
	int isRootNode = isRoot[id];
	int isLit = clauses[id].size()==1;
	if (j>0) {
	  int v = var(xs[j-1]);
	  int isAnd = !isOrRes(id,j-1,v);
	  if (!isAnd) {
	    cntAndOr++;
	    if (!lclToGlbVar[v]) {
	      lclToGlbVar[v] = ++nLclToGblVars;
	    }
	  }
	}
      }
      return cntAndOr;
    }

    void proofMakeAndNodes  (int thresh) {
      int nNodes = proofNodes.size();
      int i, cntAndOr=0, totAnd=0, used=0, maxAnd=nSolverVars/10;
      int nRootNodes = clauses.size();
      //      vec<char> = lclToGlbVar;
      if (maxAnd>200) maxAnd=200;
      
      if (nNodes<thresh) return;
      Pdtutil_Assert(nRootNodes>0,"invalid proof sort here");
      lclToGlbVar.growTo(nSolverVars);

      for (i=nNodes-1; totAnd<maxAnd && i>=nRootNodes; i--) {
        if (!isRoot[i] && isCore[i]>=1) {
          cntAndOr += proofMakeAndNode (i);
	  totAnd += vars[i].size();
	  used++;
        }
      }
      printf("root node OR->AND: %d/%d (used chains: %d) - lcl to glbl V: %d - TOP NODE: %d\n", 
	     cntAndOr, totAnd, used, nLclToGblVars,
             proofNodes[nNodes-1].size()-1);

    }

    void sortProofNode (const int id) {
      int start_j, prevAnd=1, prevOr=1;

      vec<ClauseId>& cs = proofNodes[id];
      vec<Lit>& xs = vars[id];

      if (1) {
	for (int j = 1; j < cs.size(); j++) {
	  int sorted = 0;
	  int v = var(xs[j-1]);
	  int isAnd = !isOrRes(id,j-1,v);
	  int isRootNode = isRoot[nodeId(cs[j])];
	  int isLit = clauses[nodeId(cs[j])].size()==1;
	  if (!isLit || !isRootNode) continue;
	  for (int k=j-1; k>=1; k--) {
	    int v_k = var(xs[k-1]);
	    int isAnd_k = !isOrRes(id,k-1,v_k);
	    int isRootNode_k = isRoot[nodeId(cs[k])];
	    int isLit_k = clauses[nodeId(cs[k])].size()==1;
	    if (isLit_k && isRootNode_k) break;
	    ClauseId tmp = cs[k]; cs[k] = cs[j]; cs[j] = tmp;
	  }
	}
      }

      start_j = 0;
      for (int j = 1; j < cs.size(); j++) {
        int sorted = 0;
        int v = var(xs[j-1]);
        int isAnd = !isOrRes(id,j-1,v);
        int same = (isAnd && prevAnd || !isAnd && prevOr);
        if (j<cs.size()-1 && same) {
          // go ahead
          prevOr = !isAnd; prevAnd = isAnd;
          continue;
        }
        int end_j = j;
        if (!same) end_j--;
	// implement counting sort
        if (end_j>start_j)
        for (int k=start_j; k<end_j; k++) {
          for (int h=k+1; h<=end_j; h++) {
            if (nodeId(cs[k])>nodeId(cs[h])) {
              ClauseId tmp = cs[k]; cs[k] = cs[h]; cs[h] = tmp;
              sorted = 1;
            }
          }
        }
        start_j = j;
        break;
        prevOr = !isAnd; prevAnd = isAnd;
      }
    }

    void sortProofNodes  () {
      int i;
      int nNodes = proofNodes.size();
      int nRootNodes = clauses.size();

      Pdtutil_Assert(nRootNodes>0,"invalid proof sort here");

      for (i=nRootNodes; i<nNodes; i++) {
        if (!isRoot[i] && isCore[i]>=1) {
          sortProofNode (i);
        }
      }

    }

    void genComposeFrontier  () {
      int i;
      int nNodes = proofNodes.size();
      int nRootNodes = clauses.size();
      int nA=0, nB=0, nAB=0, nTop=0;

      vec<char> topNode;

      Pdtutil_Assert(nRootNodes>0,"gen compose frontier problem");
      if (!genResolution) return;

      Pdtutil_Assert(resolutionClauses.size()==nNodes,
		     "gen compose frontier problem");

      isFrontier.growTo(nNodes);
      topNode.growTo(nNodes);
      nodeBdd.growTo(nNodes);

      for (i=nRootNodes; i<nNodes; i++) {
	topNode[i] = 0;
#if 0
#if 1
        if (!isRoot[i] && isCore[i]>=1) {
	  vec<Lit>& c = resolutionClauses[i];
	  if (c.size() > 4) {
	    isFrontier[i] = 3;
	  }
	}
#else
        if (!isRoot[i] && isCore[i]>=1 && i<(nRootNodes+nNodes)/2) {
	    isFrontier[i] = 3;
	}
#endif
#else
	if (i>(nRootNodes+nNodes)*3/4) continue;
        if (!isRoot[i] && isCore[i]>=1) {
	  vec<Lit>& c = resolutionClauses[i];
	  if (c.size() > 4) {
	    int aClause=1, bClause=1;
	    for (int j = 0; j < c.size(); j++) {
	      int v_j = var(c[j]);
	      if (!isGlobal(v_j) && !isBVar(v_j)) bClause=0; // A var
	      if (isBVar(v_j)) aClause=0; // B var
	    }
	    if (aClause && bClause) {
	      isFrontier[i] = 3;
	    }
	    else if (aClause) {
	      isFrontier[i] = 1;
	    }
	    else if (bClause) {
	      isFrontier[i] = 2;
	    }
	  }
	}
#endif
      }

      topNode[nNodes-1] = 1;
      for (i=nNodes-1; i>=0; i--) {
        if (isRoot[i] || isCore[i]<1) continue;
	if (isFrontier[i]>0) continue;
	if (topNode[i]==0) continue;
	nTop++;
	vec<ClauseId>& cs = proofNodes[i];

	for (int j = 0; j < cs.size(); j++) {
	  int id_j = nodeId(cs[j]);
	  if (isFrontier[id_j]>0 && isFrontier[id_j]<10) {
	    if (isFrontier[id_j]==1) {
	      nA++;
	    }
	    else if (isFrontier[id_j]==2) {
	      nB++;
	    }
	    else if (isFrontier[id_j]==3) {
	      nAB++;
	    }
	    isFrontier[id_j] += 10;
	  }
	  if (!isFrontier[id_j]) {
	    topNode[id_j] = 1;
	  }
	}
      }
      for (i=nRootNodes; i<nNodes; i++) {
	if (isFrontier[i]>10) {
	  isFrontier[i] -= 10;
	}
	else {
	  isFrontier[i] = 0;
	}
      }
      printf("compose frontier for %d chain nodes: A: %d, B: %d, AB: %d, top: %d\n",
	     nNodes-nRootNodes, nA, nB, nAB, nTop);

    }

    void genComposeFrontierByFo  () {
      int i;
      int nNodes = proofNodes.size();
      int nRootNodes = clauses.size();
      int nA=0, nB=0, nAB=0, nTop=0;
      int maxFoCnt = 0, nCut = 0, maxL;
      int splitByLevel = 1;
      
      vec<char> topNode;
      vec<int> foCnt;
      vec<int> level;

      if (nNodes<1000) return;

      Pdtutil_Assert(nRootNodes>0,"gen compose frontier problem");
      if (!genResolution) return;

      Pdtutil_Assert(resolutionClauses.size()==nNodes,
		     "gen compose frontier problem");

      isFrontier.growTo(nNodes);
      topNode.growTo(nNodes);
      foCnt.growTo(nNodes);
      level.growTo(nNodes);
      nodeBdd.growTo(nNodes);

      for (i=0; i<nRootNodes; i++) {
        level[i] = 0;
      }
      for (i=nRootNodes; i<nNodes; i++) {
	foCnt[i] =0;
        level[i] = 0;
        if (!isRoot[i] && isCore[i]>=1) {
          vec<ClauseId>& cs = proofNodes[i];
          
          for (int j = 0; j < cs.size(); j++) {
            int id_j = nodeId(cs[j]);
            if (!isRoot[id_j] && isCore[id_j]>=1) {
              foCnt[id_j]++;
              if (foCnt[id_j] > maxFoCnt && level[id_j] > 10)
                maxFoCnt = foCnt[id_j];
            }
            if (level[id_j] >= level[i]) level[i] = level[id_j]+1;
          }
        }
      }
      
      maxL = level[nNodes-1];
      
      for (i=nRootNodes; i<nNodes; i++) {
        if (splitByLevel) {
          isFrontier[i] = (level[i]>maxL/4) && (level[i]<=maxL/2)
            && (foCnt[i] > 4);
        }
        else {
          isFrontier[i] = (level[i]>5) && (foCnt[i] > maxFoCnt/10);
        }
        if (isFrontier[i]) {
          vec<ClauseId>& cs = proofNodes[i];
          int confirmed = !splitByLevel;
          for (int j = 0; j < cs.size(); j++) {
            int id_j = nodeId(cs[j]);
            if (!isRoot[id_j] && isCore[id_j]>=1 &&
                (foCnt[id_j] > 4)) {
              if (splitByLevel) {
                isFrontier[id_j] = 2;
              }
              else {
                if (!isFrontier[id_j]) confirmed = 1;
              }
            }
          }
          if (confirmed) {
            isFrontier[i] = 2;
            nCut++;
          }
        }
#if 0        
        if (i>=nNodes-10) isFrontier[i]=2;
        else
          isFrontier[i]= 0;
#endif
      }

      topNode[nNodes-1] = 1;
      for (i=nNodes-1; i>=0; i--) {
        if (isRoot[i] || isCore[i]<1) continue;
	if (isFrontier[i]>0) continue;
	if (topNode[i]==0) continue;
	nTop++;
	vec<ClauseId>& cs = proofNodes[i];

	for (int j = 0; j < cs.size(); j++) {
	  int id_j = nodeId(cs[j]);
	  if (isFrontier[id_j]>0 && isFrontier[id_j]<10) {
	    if (isFrontier[id_j]==1) {
	      nA++;
	    }
	    else if (isFrontier[id_j]==2) {
	      nB++;
	    }
	    else if (isFrontier[id_j]==3) {
	      nAB++;
	    }
            //	    isFrontier[id_j] += 10;
	  }
	  if (!isFrontier[id_j]) {
	    topNode[id_j] = 1;
	  }
	}
      }
      printf("compose frontier for %d chain nodes: A: %d, B: %d, AB: %d, top: %d - MaxFo: %d - nCut: %d - maxLev: %d\n",
	     nNodes-nRootNodes, nA, nB, nAB, nTop, maxFoCnt, nCut, level[nNodes-1]);

    }

    int proofNodeHasVar (const int id, const int v) {
      int nRootNodes = clauses.size();
      if (!isRoot[id]) {
	if (genResolution2) {
	  if ((isAClause[id]<0) && !isBVar(v)) {
	    return 0;
	  }
	  return 1;
	}
	else if (genResolution) {
	  vec<Lit>& c = resolutionClauses[id];
	  for (int j = 0; j < c.size(); j++) {
	    int v_j = var(c[j]);
	    if (v == v_j) return 1;
	  }
	}
	else {
	  return 1;
	}
      }
      else {
	Pdtutil_Assert (id < nRootNodes, "wrong root node id");
	if (genResolution2) {
	  if (!(isAClause[id]>0) && !isGlobal(v)) {
	    return 0;
	  }
	  return 1;
	}
	else {
	  vec<Lit>& c = clauses[id];
	  for (int j = 0; j < c.size(); j++) {
	    int v_j = var(c[j]);
	    if (v == v_j) return 1;
	  }
	}
      }
      return 0;
    }

    int restructProofNode (const int id) {
      int start_j;

      int nSwap = 0;
      //      static int enRestruct = 1;

      vec<ClauseId>& cs = proofNodes[id];
      vec<Lit>& xs = vars[id];

      start_j = -1;
      for (int j = 2; j < cs.size()-1; j++) {
	int k;
        int cs_j = cs[j];
        int id_j = nodeId(cs[j]);
	Lit l_j = xs[j-1];
	int v_j = var(xs[j-1]);
        int cs_j0 = cs[j-1];
        int id_j0 = nodeId(cs[j-1]);
	Lit l_j0 = xs[j-2];
	int v_j0 = var(xs[j-2]);
        int cs_j2 = cs[j+1];
        int id_j2 = nodeId(cs[j+1]);
	Lit l_j2 = xs[j];
	int v_j2 = var(xs[j]);
        int sorted = 0;
	//        int isAnd = isRoot[id_j]; // isGlobal(v_j);
        int isAnd = !isOrRes(id,j-1,v_j);
        int isAnd0 = !isOrRes(id,j-2,v_j0);
        int isAnd2 = !isOrRes(id,j,v_j2); 
	if (isAnd == isAnd0 || isAnd == isAnd2) continue;
	if (!proofNodeHasVar (id_j, v_j0) &&
	    !proofNodeHasVar (id_j0, v_j)) {
	  if (!handleAClauses || (j<nResA[id]) || (j > nResA[id]+1)) {
	    cs[j] = cs[j-1];
	    xs[j-1] = xs[j-2];
	    cs[j-1] = cs_j;
	    xs[j-2] = l_j;
	    nSwap++;
	  }
        }
	else if (!proofNodeHasVar (id_j, v_j2) &&
		 !proofNodeHasVar (id_j2, v_j)) {
	  if (!handleAClauses || (j+1<nResA[id]) || (j > nResA[id])) {
	    cs[j] = cs[j+1];
	    xs[j-1] = xs[j];
	    cs[j+1] = cs_j;
	    xs[j] = l_j;
	    nSwap++;
	  }
	}
      }
      return nSwap;
    }

    void restructProofNodes  () {
      int i;
      int nNodes = proofNodes.size();
      int nRootNodes = clauses.size();
      int nSwapTot=0;

      Pdtutil_Assert(nRootNodes>0,"invalid proof sort here");

      for (i=0; i<nNodes; i++) {
        if (!isRoot[i] && isCore[i]>=1) {
          nSwapTot += restructProofNode (i);
        }
      }
      printf("chain restruct swap: %d\n", nSwapTot);
    }

    void saveCoreResolutions () {
      int i;
      int nNodes = proofNodes.size();
      int nRootNodes = clauses.size();
      int nSwapTot=0;

      Pdtutil_Assert(nRootNodes>0,"invalid proof sort here");

      for (i=0; i<nNodes; i++) {
        if (!isRoot[i] && isCore[i]>=1) {
#if 0
          vec<ClauseId>& cs = proofNodes[i];
          vec<Lit>& xs = vars[i];

          start_j = -1;
          for (int j = 0; j < xs.size(); j++) {
            Lit l_j = xs[j];
            int v_j = var(l_j);
          }
#endif
        }
      }
      printf("chain restruct swap: %d\n", nSwapTot);
    }

    void genitp  () {
      vec<int> nRef;
      int i, j, n, idLast, nNodes;
      int refTh=0;
      int minHints = 10000;
      n=0;
      nNodes = isRoot.size();
      idLast = nNodes-1;
      //      isCore;[idLast] = 1;
      if (nodes.size()<nNodes) {
        nodes.growTo(nNodes);
      }

      if (minHintLits>0) {
        int maxRef = 0, totNodes=0;
        nRef.growTo(nNodes);
        for (int i = 0; i<nNodes; i++) {
          nRef[i]=0;
          if (isCore[i] < 1 || isRoot[i]) continue;
	  if (genResolutionB && isAClause[i]<0) continue;
          totNodes++;
          vec<ClauseId>& cs = proofNodes[i];
	  for (int j = 0; j < cs.size(); j++) {
	    int id = cs[j];
	    nRef[id]++;
            if (nRef[id]>maxRef) maxRef = nRef[id];
          }
        }
        refTh = maxRef;
        int cnt=0;
        while (refTh>2 && cnt<minHints && cnt<totNodes) {
          cnt=0;
          refTh /= 2;
          for (int i = 0; i<nNodes; i++) {
            vec<Lit>& c = resolutionClauses[i];
            if ((nRef[i] >= refTh) && (c.size()>=minHintLits)) {
              cnt++;
            }
          }
        }
      }

      if (computeCore) {
        coreClauses.clear();
        hintClauses.clear();
        coreVars.clear();
        coreVars.growTo(nSolverVars);
        for (int i = 0; i<nSolverVars; i++) {
          coreVars[i] = 0;
        }
      }

      for (int i = 0; i<nNodes; i++) {
        if (computeCore && i==nAClauses) {
          nAClausesCore = coreClauses.size();
        }
        if (isCore[i] < 1) {
          if (computeCore && isRoot[i]) {
            vec<Lit>& c = clauses[i];
            for (int j = 0; j < c.size(); j++) {
              // mark as used var
	      coreVars[var(c[j])] |= 0x4;
            }
          }
          continue;
        }
        if (computeCore) {
          if (isRoot[i]) {
            vec<Lit>& c = clauses[i];
            coreClauses.push();
            c.copyTo(coreClauses.last());
            for (int j = 0; j < c.size(); j++) {
	      if (sign(c[j])) {
		// negative lit
		coreVars[var(c[j])] |= 0x1;
	      }
	      else {
		// positive lit
		coreVars[var(c[j])] |= 0x2;
	      }
            }
          }
	  else if (genResolutionB && (isAClause[i]<0) /*&& isBCore[i]*/) {
            vec<Lit>& c = resolutionClauses[i];
            coreClauses.push();
            nResCore++;
            c.copyTo(coreClauses.last());
            for (int j = 0; j < c.size(); j++) {
	      if (sign(c[j])) {
		// negative lit
		coreVars[var(c[j])] |= 0x1;
	      }
	      else {
		// positive lit
		coreVars[var(c[j])] |= 0x2;
	      }
            }
	  }
	  else if (minHintLits>0) {
            int useRef = 1;
            vec<Lit>& c = resolutionClauses[i];
            //            if (c.size()>minHintLits||
            if (useRef ? ((nRef[i]>=refTh)&&
                (c.size()>=minHintLits)) :
                (c.size()>=minHintLits && (i>(nNodes*5)/10))) {
              // if (nRef[i]<refTh/* && i<(nNodes*9)/10*/) {
              hintClauses.push();
              c.copyTo(hintClauses.last());
            }
          }
        }
        else {
          if (isRoot[i]) {
            root1(i);
          }
          else {
            chain1(i);
            if (minHintLits>0) {
              int useRef = 1;
              vec<Lit>& c = resolutionClauses[i];
              //            if (c.size()>minHintLits||
              if (useRef ?((nRef[i]>=refTh)&&
                           (c.size()>=minHintLits)) :
                  (c.size()>=minHintLits && (i>(nNodes*5)/10))) {
                // if (nRef[i]<refTh/* && i<(nNodes*9)/10*/) {
                hintClauses.push();
                c.copyTo(hintClauses.last());
              }
            }
          }
        }
      }
                      
      //      printf("ITP core: %d\n", n);
    }

    void deleted(ClauseId c) {
      //clauses[c].clear();
	//        bAig_RecursiveDeref(bMgr,aigs[c]);
        //	nAClauses--;
    }

    void done   () {
      int itpMem = ddiMgr->settings.aig.itpMem;
      int itpOpt = ddiMgr->settings.aig.itpOpt;
      int iteOpt = 0;
      int composeOpt = 0;
      int itpAndNodes = abs(ddiMgr->settings.aig.itpTwice);
      int handleUnitClauses = rootCustomHandling && !computeCore;
      static int nCalls=0; nCalls++;
      int resolveTwice = 0;

      enUseImplTable = 0;
      
      if (1 && itpAndNodes==0 && ddiMgr->settings.aig.itpNoQuantify>0) {
	itpAndNodes = ddiMgr->settings.aig.itpNoQuantify;
      }
      
      core();

      int printVars=0;

      if (printVars) {
        int i;
        for (i=0; i<nSolverVars; i++) {
          printf("%3d) ", i);
          if (1) {
            int vCnf = ddiMgr->cnf.solver2cnf[i]+1;
            bAigEdge_t litBaig = ddiMgr->cnf.cnf2aig[vCnf];
            printf(" %8d ", litBaig/4);
          }
          if (isGlobal(i)) printf("G");
          else if (isBVar(i)) printf("B");
          else printf(" ");
          printf("\n");
        }
      }

      if (!computeCore) {

        //       if (composeOpt) useRemapped = 0;
        
	if (itpMem>4) {
	  restructProofNodes ();
	}
        genRootConstants();
        //        reduceProofPba();
        if (1 && handleUnitClauses) {
          remapItpProof(-1);
          reduceProof(1);
          remapItpProof(-1);
          recomputeResolutions(1);
          remapItpProof(-1);
          //          moveUnitClauses(true);
          //          reduceProofBySubsumption();
          remapItpProof(-1);
          if (resolveTwice) {
            moveUnitClauses();
            remapItpProof(-1);
	    reduceProofSimple();
            remapItpProof(-1);
          }
          //          recomputeResolutions(1);
          //reduceProof(1);
          //remapItpProof(-1);
          //reduceRedundantResolvents();
          moveUnitClauses();
	  if (itpAndNodes>0)
	    proofMakeAndNodes(itpAndNodes);

          int idLast = proofNodes.size()-1;
          assert(isCore[idLast]);
        }

        remapItpProof(0);
        if (itpMem>1) {
          genRootConstants();
          remapItpProof(0);
	  if (handleAClauses) {
	    remapItpProof(itpOpt);
	  }
        }
        if (itpMem>2) {
#if 0
	  reduceProofByVar();
	  remapItpProof(itpOpt);
#endif
	  if (1|| useMcmRules) {
	    reduceProof(1);
	    remapItpProof(itpOpt);
     	    reduceProofSimple();
            remapItpProof(itpOpt);
	    if (0 && iteOpt) {
	      iteRestructProofTot(iteOpt);
	      remapItpProof(itpOpt);
	    }
	  }
	  //	  proofMakeAndNodes();
	  //	  reduceProofByVar();
	  //     remapItpProof(itpOpt);
        }
        if (itpOpt>5) {
          sortProofNodes ();
        }
        if (itpMem>3) {
	  if (useMcmRules) {
	    if (!composeOpt) reduceProofOdcSimple();
	  }
          if (!composeOpt) reduceProof(0);
          if (0 && dontCareOpt) {
            dontCareRestructProofTot();
          }
          if (iteOpt) {
            iteRestructProofTot(iteOpt);
            //            remapItpProof(itpOpt);
          }
        }
        if (itpMem>5) {
          remapItpProof(itpOpt);
        }
        if (composeOpt) {
          genComposeFrontierByFo ();
          //          genComposeFrontier ();
        }
        //        rvreduceProof(0);
        //remapItpProof();
      }
      genitp();
      //      deleteTemps();
    }

    void done22   () {
      int itpMem = ddiMgr->settings.aig.itpMem;
      int itpOpt = ddiMgr->settings.aig.itpOpt;
      int iteOpt = 0;

      enUseImplTable = 0;
      if (0 && partial && itpMem>2) {
	itpMem = 2;
      }

      checkItpProof();
      //printItpProof();
      if (itpMem>4) {
	restructProofNodes ();
      }
      if (itpMem>1) {
	genRootConstants();
	remapItpProof(0);
      }
      //      printItpProof();
      if (itpMem>2) {
	reduceProofSimple();
	remapItpProof(itpOpt);
	reduceProof(1);
	remapItpProof(itpOpt);
	if (iteOpt) {
	  iteRestructProofTot(iteOpt);
	  remapItpProof(itpOpt);
	}
      }
      //      printItpProof();
      if (itpOpt>5) {
	sortProofNodes ();
      }
      if (itpMem>3) {
	reduceProofOdcSimple();
	reduceProof(0);
      }
      if (itpMem>4) {
	remapItpProof(itpOpt);
      }
      //        rvreduceProof(0);
      //remapItpProof();
      //      deleteTemps();
    }

    void countPivots(int chooseAnd){

      vec<int> counters;
      vec<int> nRef;
      vec<int> refs;
      vec<int> parent;
      vec<int> parentPin;
      int tot=0, nv=0, imax=-1;
      int i, j;
      int nNodes = vars.size();
      counters.growTo(nSolverVars);

      maxPivots.clear();
      maxPivots.growTo(1, -1);

      nRef.clear();
      nRef.growTo(nNodes, 0);
      parent.clear();
      parent.growTo(nNodes, 0);
      parentPin.clear();
      parentPin.growTo(nNodes, 0);
      
      for (int i = 0; i<nNodes; i++) {
        if (isCore[i] < 1) {
          continue;
        }
	if (!isRoot[i]) {
	  vec<Lit>& xs = vars[i];
	  for (j = 0; j < xs.size(); j++) {
	    int v = var(xs[j]);
	    tot++;
	    if (counters[v]==0) nv++;
	    counters[v]++;
          }
          vec<ClauseId>& cs = proofNodes[i];
	  for (j = 0; j < cs.size(); j++) {
	    int id = cs[j];
	    nRef[id]++;
            parent[id] = i;
            parentPin[id] = j;
          }
        }
      }

      if (nv>0) {
	printf("Avg pivot cnt (%d/%d vars): %d\n", nv, 
	       nSolverVars, tot/nv);
	for(int i = 0; i < nSolverVars; i++){
	  if (imax<0 || counters[i]>counters[imax]) {
	    imax=i;
	  }
	}
        int iMaxRef=-1;
	for(int i = 0; i < nNodes; i++){
	  if (iMaxRef<0 || nRef[i]>nRef[iMaxRef]) {
	    iMaxRef=i;
	  }
	}
	printf("Max pivot cnt [%d]: %d (res chains: %d)%s\n", 
	       imax, counters[imax], nNodes-clauses.size(),
	       isGlobal(imax)?" GBL":" LCL");
        int maxRoot = isRoot[iMaxRef];
        int sizeMax = maxRoot ? clauses[iMaxRef].size():
          proofNodes[iMaxRef].size();
	printf("Max ref cnt [%d]: %d (res chains: %d)%s: %d\n", 
	       iMaxRef, nRef[iMaxRef], nNodes-clauses.size(),
	       maxRoot?" ROOT":" CHAIN", sizeMax);               
        int visitRefs = 1;
        if (visitRefs) {
          for(int i = 0; i < nNodes; i++){
            if (isCore[i] < 1) {
              continue;
            }
            if (!isRoot[i]) {
              vec<Lit>& xs = vars[i];
              vec<ClauseId>& cs = proofNodes[i];
              for (j = 0; j < cs.size(); j++) {
                int id = cs[j];
                int v = j>0?var(xs[j-1]):var(xs[0]);
                int par1 = parent[i];
                int dom = par1, domPin = parentPin[i];
                while (dom<nNodes && nRef[dom]==1) {
                  domPin = parentPin[dom];
                  dom = parent[dom];
                }
                if (id==iMaxRef) {
                  refs.push(id);
                  printf("ID: %d - var: %d - pin: %d - fo: %d - parent: %d - dominator: %d (pin: %d)\n",
                         i, v, j, nRef[i], par1, dom, domPin);
                }
              }
            }
          }
        }

        if (chooseAnd<0) {
	  // all good - don't choose
	  maxPivots[0] = imax;
	}
	else if (chooseAnd>0) {
	  if (!isGlobal(imax) && isBVar(imax))
	    maxPivots[0] = imax;
	}
	else {
	  if (!isGlobal(imax) && !isBVar(imax))
	    maxPivots[0] = imax;
	}

	for(int i = 0; i < nSolverVars; i++) {
	  if (i==imax) continue;
	  //if (!isGlobal(i)) continue; 
	  if (chooseAnd>0) {
	    if (isGlobal(i) || !isBVar(i)) continue;
	  }
	  else if (chooseAnd==0) {
	    if (isGlobal(i) || isBVar(i)) continue;
	  }
	  if (counters[i] > counters[imax]/10) {
	    if (maxPivots[0]<0) 
	      maxPivots[0] = i;
	    else 
	      maxPivots.push(i);
	  }
	}
      }
      else {
	assert(tot==0);
      }
      if (maxPivots[0] < 0) 
	maxPivots.clear();
      else {
	imax = maxPivots[0];
	printf("Choosen pivot cnt [%d]: %d (res chains: %d)%s%s\n", 
	       imax, counters[imax], nNodes-clauses.size(),
	       isGlobal(imax)?" GBL":" LCL",isBVar(imax)?"(B)":"");
      }
    }

};

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
struct compareBySize_gt { bool operator () (vec<Lit>* x, vec<Lit>* y) { return x->size() > y->size(); } };

#if 0
class compareBySize_gt {
  public:
    compareBySize_gt (const vec<vecLit> >& t) :
  bool operator () (vec<Lit> x, vec<Lit> y) { return x.size()>y.size(); }
};
#endif
 
static void
SaveClausesAsAigs(
  Ddi_Mgr_t *ddm,
  vec<vec<Lit> > &clauses,
  float ratio 
)
{
  int i, j, n0, n1;
  bAig_array_t *baigNodes;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  vec<vec<Lit>*> cp;
  vec<Lit> *vp;
  
  cp.clear();
  for (i=0; i<clauses.size(); i++) {
    vp = &clauses[i];
    cp.push(vp);
  }
  sort(cp, compareBySize_gt());
            
  baigNodes = bAigArrayAlloc();

  n1 = clauses.size();
 
  n0 = 0;
  //  if (ratio<1) n1 = n1*ratio;
  for (i=n0; i<n1; i++) {
    int cnt=0;
    if (cp[i]->size()==0) continue;
    for (j=0; j<cp[i]->size(); j++) {
      Var vSolver = var((*cp[i])[j]);
      int cnfId = (ddm->cnf.solver2cnf != NULL) ?
	ddm->cnf.solver2cnf[vSolver]+1 : vSolver+1;
      if (cnfId<=ddm->cnf.maxCnfId) {
        Pdtutil_Assert (1||DdiCnfReadActive(ddm,cnfId)>0,
                        "wrong cnf var");
        bAigEdge_t baig = ddm->cnf.cnf2aig[cnfId];
        int isCompl = !sign((*cp[i])[j]);
        if (isCompl) baig = bAig_Not(baig);        
        cnt++;
        bAig_Ref(bmgr, baig);
        bAigArrayPush(baigNodes,baig);
      }
    }
    if (cnt>0) {
      bAigArrayPush(baigNodes,bAig_NULL);
    }
  }
  
  if (ddm->cnf.savedAigNodes != NULL) {
    bAigArrayClearDeref(bmgr, ddm->cnf.savedAigNodes);
    bAigArrayFree(ddm->cnf.savedAigNodes);
  }
  if (baigNodes->num<100) {
    bAigArrayClearDeref(bmgr, baigNodes);
    bAigArrayFree(baigNodes);
  }
  else {
    ddm->cnf.savedAigNodes = baigNodes;
  }
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/

static void
SaveVarsAsAigs(
  Ddi_Mgr_t *ddm,
  vec<Var> &vars,
  Ddi_Vararray_t *vA
)
{
  int i;
  bAig_array_t *baigNodes;
  bAig_Manager_t *bmgr = ddm->aig.mgr;

  baigNodes = bAigArrayAlloc();

  for (i=0; i<vars.size(); i++) {
    int cnfId = vars[i]/4 + 1;
    Pdtutil_Assert(DdiCnfReadActive(ddm,cnfId)>0,"problem with cnf id");
    bAigEdge_t baig = ddm->cnf.cnf2aig[cnfId];
    Pdtutil_Assert(baig!=bAig_NULL,"Null baig");
    bAig_Ref(bmgr, baig);
    bAigArrayPush(baigNodes,baig);
  }
  if (vA!=NULL)
    for (i=0; i<Ddi_VararrayNum(vA); i++) {
      Ddi_Var_t *v_i = Ddi_VararrayRead(vA,i);
      bAigEdge_t baig = Ddi_VarToBaig(v_i);
      Pdtutil_Assert(baig!=bAig_NULL,"Null baig");
      bAig_Ref(bmgr, baig);
      bAigArrayPush(baigNodes,baig);
  }
  
  if (ddm->cnf.savedAigNodes != NULL) {
    bAigArrayClearDeref(bmgr, ddm->cnf.savedAigNodes);
    bAigArrayFree(ddm->cnf.savedAigNodes);
  }
  if (baigNodes->num<100) {
    bAigArrayClearDeref(bmgr, baigNodes);
    bAigArrayFree(baigNodes);
  }
  else {
    ddm->cnf.savedAigNodes = baigNodes;
  }
}


static int countConeInCore(
  Ddi_Mgr_t *ddm,
  int id,
  bAig_array_t *baigNodes,
  vec<bool>& inCoreById,
  int *nTot
)
{
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  vec<bool> visited;
  visited.growTo(id+1,false);
  int countNodes = 0, countInCore = 0;
  if (inCoreById[id]) {
    visited[id] = true;
    int nVisited = 1;
    for (int i=id; i>=0 && nVisited>0; i--) {
      if (!visited[i]) continue;
      nVisited--;
      bAigEdge_t baig = baigNodes->nodes[i];
      countNodes++;
      if (inCoreById[i])
        countInCore++;
      if (bAig_isVarNode(bmgr,baig)) continue;
      int ir = rightChildAuxInt(bmgr,baig);
      int il = leftChildAuxInt(bmgr,baig);
      visited[ir] = true;
      visited[il] = true;
      nVisited++;
      nVisited++;
    }
  }
  *nTot = countNodes;
  return countInCore;
  
}
 
/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/

static void
AnalyzeCoreVars(
  vec<Var> &vars,
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i;
  bAig_array_t *baigNodes;
  int nFound = 0;
  vec<bool> inCore;
  vec<bool> inCoreById;
  
  baigNodes = bAigArrayAlloc();

  for (i=0; i<vars.size(); i++) {
    int cnfId = vars[i]/4 + 1;
    Pdtutil_Assert(DdiCnfReadActive(ddm,cnfId)>0,"problem with cnf id");
    bAigEdge_t baig = ddm->cnf.cnf2aig[cnfId];
    if (cnfId>=inCore.size())
      inCore.growTo(cnfId+1,false);
    inCore[cnfId] = true;
    Pdtutil_Assert(baig!=bAig_NULL,"Null baig");
  }
  Ddi_PostOrderBddAigVisitIntern(f,baigNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,baigNodes);
  inCoreById.growTo(baigNodes->num,false);
  
  bAigArrayAuxIntSetId(bmgr,baigNodes);
  for (i=0; i<baigNodes->num; i++) {
    bAigEdge_t baig = baigNodes->nodes[i];
    int cnfId = DdiAig2CnfId(bmgr,baig);
    if (inCore[cnfId]) {
      nFound++;
      inCoreById[i] = true;
    }
  }

  if (baigNodes->num > 10000) {
    int id, k;
    int sizeTot = Ddi_BddSize(f);
    Ddi_Bdd_t *fDisj = Ddi_AigPartitionTop(f,1);
    Ddi_BddPartSortBySizeAcc(fDisj, 0); //decreasing
    Ddi_Bdd_t *fConj = Ddi_AigPartitionTop(Ddi_BddPartRead(fDisj,0),0);
    Ddi_BddPartSortBySizeAcc(fConj, 0); //decreasing

    Ddi_Free(fConj);
    Ddi_Free(fDisj);
    for (k=0,id = baigNodes->num-1; id>0 && k<100; id--) {
      int nTot=0, countInCore=0;
      countInCore = countConeInCore(ddm,id,
                                    baigNodes,inCoreById,&nTot);
      if (countInCore>0 && nTot>1) {
        printf("baig id: %d - core/tot: %d/%d\n",
             id,countInCore,nTot);
        k++;
      }
    }
  }

  bAigArrayAuxIntClear(bmgr,baigNodes);

  printf("ANALYZE CORE found %d/%d in core out of %d nodes\n",
         nFound, vars.size(), baigNodes->num); 
  
  bAigArrayFree(baigNodes);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/

static void
RestoreClausesAsAigs(
  Ddi_Mgr_t *ddm,
  vec<vec<Lit> > &clauses,
  Ddi_Bdd_t *partAig
)
{
  int i, iCl, j;
  bAig_array_t *baigNodes;
  bAig_Manager_t *bmgr = ddm->aig.mgr;

  clauses.clear();
  iCl=0;
  clauses.push(); // first clause
  baigNodes = ddm->cnf.savedAigNodes;

  if (partAig!=NULL) {
    int ii;
    //    for (ii=Ddi_BddPartNum(partAig)-1; ii>=0; ii--) {
    for (ii=0; ii<Ddi_BddPartNum(partAig); ii++) {
      Ddi_Bdd_t *p_i = Ddi_BddPartRead(partAig,ii);
      bAigEdge_t baig = Ddi_BddToBaig(p_i);
      if (bAig_CnfId(bmgr,baig) != 0) {
        int isNeg = bAig_NodeIsInverted(baig);
        int lit = isNeg ? -DdiAig2CnfId(bmgr,baig) :
          DdiAig2CnfId(bmgr,baig);
        clauses[iCl].push(MinisatLit(-lit));
        clauses.push(); // first clause
        iCl++;
      }
    }
  }
  else {
    for (i=0; i<baigNodes->num; i++) {
      bAigEdge_t baig = baigNodes->nodes[i];
      if (baig == bAig_NULL && clauses[iCl].size()>0) {
        //        || clauses[iCl].size()>=100) {
        clauses.push(); // first clause
        iCl++;
        continue;
      }
      if (bAig_CnfId(bmgr,baig) != 0) {
        int isNeg = bAig_NodeIsInverted(baig);
        int lit = isNeg ? -DdiAig2CnfId(bmgr,baig) :
          DdiAig2CnfId(bmgr,baig);
        clauses[iCl].push(MinisatLit(lit));
      }
    }
  }
}

static Ddi_Bddarray_t *
RestoreSavedAigNodes(
  Ddi_Mgr_t *ddm
)
{
  int i;
  bAig_array_t *baigNodes;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bddarray_t *fA;
  Ddi_Bdd_t *f_j;
  
  baigNodes = ddm->cnf.savedAigNodes;
  fA = Ddi_BddarrayAlloc(ddm,0);

  f_j = Ddi_BddMakeConstAig(ddm,1);
  for (i=0; i<baigNodes->num; i++) {
    bAigEdge_t baig = baigNodes->nodes[i];
    if (baig == bAig_NULL && !Ddi_BddIsOne(f_j)) {
      Ddi_BddarrayInsertLast(fA,f_j);
      Ddi_Free(f_j);
      f_j = Ddi_BddMakeConstAig(ddm,1);
    }
    else {
      int isNeg = bAig_NodeIsInverted(baig);
      Ddi_Bdd_t *lit = Ddi_BddMakeFromBaig(ddm,baig);
      if (isNeg) Ddi_BddNotAcc(lit);
      Ddi_BddAndAcc(f_j,lit);
    }
  }
  if (!Ddi_BddIsOne(f_j)) {
    Ddi_BddarrayInsertLast(fA,f_j);
  }
  Ddi_Free(f_j);
  return fA;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/

static void
RestoreVarsAsAigs(
  Ddi_Mgr_t *ddm,
  Ddi_Bdd_t *auxAig,
  vec<Var>   &vars
)
{
  int i, doFree = 0;
  bAig_array_t *baigNodes;
  bAig_Manager_t *bmgr = ddm->aig.mgr;

  vars.clear();
  baigNodes = ddm->cnf.savedAigNodes;

  if (auxAig!=NULL) {
    bAig_array_t *baigNodes2 = bAigArrayAlloc();
    doFree=1;
    Ddi_PostOrderBddAigVisitIntern(auxAig,baigNodes2,-1);
    postOrderAigClearVisitedIntern(bmgr,baigNodes2);

    bAigArrayAuxIntSetId(bmgr,baigNodes2);
    for (i=0; i<baigNodes->num; i++) {
      bAigEdge_t baig = baigNodes->nodes[i];
      if (bAig_AuxInt(bmgr,baig)<0) {
        bAigArrayPush(baigNodes2,baig);
      }
    }
    bAigArrayAuxIntClear(bmgr,baigNodes2);
    baigNodes = baigNodes2;
  }
  
  for (i=0; i<baigNodes->num; i++) {
    bAigEdge_t baig = baigNodes->nodes[i];
    if (baig == bAig_NULL) {
      continue;
    }
    if (bAig_CnfId(bmgr,baig) != 0) {
      int lit = bAig_CnfId(bmgr,baig);
      vars.push(var(MinisatLit(lit)));
    }
  }
  if (doFree) {
    bAigArrayFree(baigNodes);
  }
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/

static void
MinisatInterpolant (
  Solver&    S,
  Ddi_Mgr_t *ddm,
  int nAClauses,
  int reverseItp,
  Ddi_Bdd_t **interpolantP,
  Ddi_Bdd_t **interpolantOptP,
  Ddi_Bdd_t *care,
  Ddi_Bddarray_t *partitionLits,
  vec<vec<Lit> > *partitionClausesP,
  int nSuppVars,
  int itpOdc
)
{
  Ddi_Bdd_t *interpolant;
  Ddi_Bdd_t *interpolantOpt;
  Checker trav(ddm,S.nVars());
  ClauseId goal = ClauseId_NULL;
  int partial = ddm->settings.aig.partialItp;

  trav.nAClauses = nAClauses;
  trav.nAClausesRemapped = -1;
  trav.proofSize = S.proof->last();
  trav.nLclToGblVars = 0;
  trav.dontCareOpt = ddm->settings.aig.itpUseCare;

  trav.zeroConstId=0;
  trav.oneConstId=1;

  trav.reverseInterpolant = reverseItp;
  if (trav.dontCareOpt) {
    //    trav.useMcmRules = 0;
  }
  
  ddm->stats.aig.itpPartialExist=0;
  // custom root
  trav.rootCustomHandling = 0;

  //  trav.genResolution = 1;
  if (1 && ddm->cnf.useSavedAigsForSat>1) {
    //    trav.itpSaveCoreResolutions = 1;
    trav.itpSaveUnitResolutions = 1;
    trav.genResolution = 1;
  }
  
  if (ddm->settings.aig.itpMem>2) {
    trav.useRemapped = 1;
    if (ddm->settings.aig.itpMem>4) {
      trav.genResolution2 = 1;
    }
  }
  if (ddm->settings.aig.itpOpt>3) {
    trav.handleAClauses = 1;
    //    trav.genResolution2 = 1;
  }
  if (0 || ddm->settings.aig.itpOpt>4) {
    trav.genResolution = 1;
    //    trav.genResolution2 = 1;
  }

  trav.genResolution = 1;
  if (trav.itpSaveCoreResolutions || trav.itpSaveUnitResolutions) {
    trav.genResolution = 1;
  }

  if (0 && trav.genResolution>0)
    trav.minHintLits = 4;
  
  if (care != NULL) {
    trav.careBaig = Ddi_BddToBaig(care);
  }

  ddm->stats.aig.fullAndItpTerms=0;
  ddm->stats.aig.fullOrItpTerms=0;
  ddm->stats.aig.itpTerms=0;

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),
    "computing interpolant from refutation proof of size %d (AIG nodes: %d)\n",
	    S.proof->last(), Ddi_MgrReadAigNodesNum(ddm)));

  if (partial) {
    trav.partial = 9*trav.proofSize/10;
  }

  if (nSuppVars>30 && S.proof->last() > 50000000) {
    trav.aborted = 1;
    fprintf(dMgrO(ddm)," Interpolant ABORTED for proof of size: %d\n", S.proof->last());
    fflush(dMgrO(ddm));
  }
  else {
    S.proof->traverse(trav, goal);
  }
  //  S.proof->deleteTemps();

  if (trav.minHintLits > 0) {
    SaveClausesAsAigs(ddm,trav.hintClauses,0.5);
  }
  
  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),"interpolant OPT: %d (%d,%d)\n",
      trav.itpOptNum, trav.itpOptNum2, trav.itpOptNum3);
    fprintf(dMgrO(ddm),"interpolant AUXV: %d - AIG nodes %d\n",
	    trav.auxvNum, Ddi_MgrReadAigNodesNum(ddm));
    fprintf(dMgrO(ddm),
      "interpolant stats: clause terms/a/o/ao -> %d/%d/%d/%d - A nodes: %d (and->or): %d\n",
      ddm->stats.aig.itpTerms,
      ddm->stats.aig.fullAndItpTerms,  ddm->stats.aig.fullOrItpTerms,
      ddm->stats.aig.itpTerms-
      (ddm->stats.aig.fullAndItpTerms+ddm->stats.aig.fullOrItpTerms),
	    trav.nANodes, trav.nAndToOr));
  if (trav.nOdcFound>0) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"interpolant ODC #: %d\n", trav.nOdcFound));
  }

  /*vec<Lit>& c =*/ trav.clauses.last();
#if 0
  fprintf(dMgrO(ddm),"Final clause:");
  if (c.size() == 0)
      fprintf(dMgrO(ddm)," <empty>\n");
  else{
      for (int i = 0; i < c.size(); i++)
          fprintf(dMgrO(ddm)," %s%d", sign(c[i])?"-":"", var(c[i])+1);
      fprintf(dMgrO(ddm),"\n");
  }
#endif

  if (trav.itpSaveCoreResolutions) {
    SaveClausesAsAigs(ddm,trav.resolutionClauses,0.5);
  }
  else if (trav.itpSaveUnitResolutions) {
    SaveClausesAsAigs(ddm,trav.unitResolutionClauses,1.0);
  }
  
  if (trav.partial) {
    int nTrees = 0;
    interpolant = Ddi_BddMakeConstAig(ddm,1);
    for (int i = 0; nTrees<4 && i < trav.nodes.size(); i++) {
      if (trav.nodes[i].isTreeRoot) {
	Ddi_Bdd_t *p_i = Ddi_BddMakeFromBaig(ddm, trav.nodes[i].aig);
	if (Ddi_BddSize(p_i) > 10000) {
#if 0
	  if (trav.nodes[i].cube != NULL) {
	    Ddi_Bdd_t *cube = Ddi_BddMakeAig(trav.nodes[i].cube);
	    Ddi_BddOrAcc(p_i,cube);
	    Ddi_Free(cube);
	  }
#endif
	  Ddi_BddAndAcc(interpolant,p_i);
	  Ddi_Free(p_i);
	  nTrees++;
	}
      }
    }
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"partial interpolant (%d trees), size: %d\n",
        nTrees, Ddi_BddSize(interpolant)));
  }
  else if (trav.aborted) {
    interpolant = NULL;
  }
#if 0
  else if (trav.nodes.last().isAndCube || trav.nodes.last().isOrCube) {
    interpolant = Ddi_BddMakeAig(trav.nodes.last().cube);
  }
#endif
  else {
    interpolant = Ddi_BddMakeFromBaig(ddm, trav.nodes.last().aig);
    if (trav.nodes.last().orClause != NULL) {
      Ddi_BddSetAig(trav.nodes.last().orClause);
      Ddi_BddOrAcc(interpolant,trav.nodes.last().orClause);
    }
  }
  if (0) {
    fprintf(dMgrO(ddm)," Interpolant init size: %d ", trav.nodes.size());
    fflush(dMgrO(ddm));
  }

  if (trav.isFrontier.size()>0 && partitionLits!=NULL) {
    if (Ddi_VararrayNum(trav.auxV)>0) {
      Ddi_Bdd_t *newItp;
      Ddi_Vararray_t *auxV;
      Ddi_AigarrayComposeAcc(trav.auxF,trav.auxV,trav.auxF);
      newItp = Ddi_BddMakeCompose (interpolant,NULL,trav.auxV,trav.auxF,
				   NULL,NULL,NULL);
      Ddi_Free(interpolant);
      interpolant = newItp;
      Ddi_Vararray_t *suppA = Ddi_BddSuppVararray(interpolant);
      Ddi_VararrayIntersectAcc(suppA,trav.auxV);
      Pdtutil_Assert(Ddi_VararrayNum(suppA)==0,"compose problem");
      Ddi_Free(suppA);
      auxV = Ddi_BddReadComposeVars(interpolant);
      Ddi_VararrayWriteMark (auxV,1);
      if (partitionClausesP!=NULL) {
        int np = Ddi_BddarrayNum(trav.auxF);
        partitionClausesP->clear();
        Pdtutil_Assert(trav.auxConstrClauses.size()==np,
                           "wrong aux constr clauses array");
      }
      for (int i = 0; i < Ddi_VararrayNum(trav.auxV); i++) {
	Ddi_Var_t *v_i = Ddi_VararrayRead(trav.auxV,i);
	if (Ddi_VarReadMark(v_i)) {
	  Ddi_Bdd_t *p_i = Ddi_BddDup(Ddi_BddarrayRead(trav.auxF,i));
	  Ddi_Bdd_t *cube = Ddi_BddarrayRead(trav.auxConstr,i);
	  Pdtutil_Assert(cube!=NULL,"wrong dd cube");
#if ITP_FRONTIER_COMPOSE
      	  Ddi_BddarrayInsertLast(partitionLits,cube);
          if (partitionClausesP!=NULL) {
            Pdtutil_Assert(trav.auxConstrClauses.size()>i,
                           "wrong aux constr clauses array");
            vec<Lit>& c = trav.auxConstrClauses[i];
            int j = partitionClausesP->size();
            partitionClausesP->push();
            c.copyTo((*partitionClausesP)[j]);
          }
          //          Ddi_BddNotAcc(p_i);
          //	  Ddi_BddAndAcc(p_i,cube);
#else
	  Ddi_BddAndAcc(p_i,cube);
	  Ddi_BddarrayInsertLast(partitionLits,p_i);
#endif
	  Ddi_Free(p_i);
	}
      }
      Ddi_VararrayWriteMark (auxV,0);
    }
  }
  Ddi_Free(trav.auxV);
  Ddi_Free(trav.auxF);
  Ddi_Free(trav.auxConstr);


  for (int i = 0; i < trav.nodes.size(); i++) {
    bAig_RecursiveDeref(ddm->aig.mgr,trav.nodes[i].aig);
    Ddi_Free(trav.nodes[i].orClause);
    // Ddi_Free(trav.nodes[i].cube);
  }

  if (trav.iteVars && trav.iteVars.size()>0) {
    for (int i=0; i<trav.iteVars.size(); i++) {
      Var vSolver = trav.iteVars[i];
      int vCnf = (ddm->cnf.solver2cnf != NULL) ?
	ddm->cnf.solver2cnf[vSolver]+1 : vSolver+1;
      bAigEdge_t litBaig = ddm->cnf.cnf2aig[vCnf];
      Ddi_Var_t *v = NULL;
      if (bAig_isVarNode(ddm->aig.mgr,litBaig)) {
	v = Ddi_VarFromBaig(ddm,litBaig);
      }
      Ddi_Bdd_t *l = Ddi_BddMakeFromBaig(ddm,litBaig);
      if (0 && partitionLits!=NULL) {
	if (v!=NULL) {
	  Ddi_BddarrayInsertLast(partitionLits,l);
	}
	else {
	  Ddi_BddarrayInsertLast(partitionLits,l);
	}
      }
      Ddi_Free(l);
    }
  }

  if (trav.nLclToGblVars>0) {
    ddm->stats.aig.itpPartialExist=trav.nLclToGblVars;
  }

  //  system("rm -f ./tmp/file*");

  *interpolantP = interpolant;
  *interpolantOptP = interpolantOpt;

  return;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
MinisatCore (
  Solver&    S,
  Ddi_Mgr_t *ddm,
  int nAClauses,
  vec<Var>& coreVars,
  vec<vec<Lit> >& coreClauses,
  int doFinalClean
)
{
  return MinisatCoreWithResolution (S,ddm,NULL,nAClauses,NULL,0,
				    coreVars,coreClauses,0,doFinalClean);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
MinisatCoreWithResolution (
  Solver&    S,
  Ddi_Mgr_t *ddm,
  Ddi_Bdd_t *a,
  int nAClauses,
  vec<Lit> *assumps,
  int nAssumpsA,
  vec<Var>& coreVars,
  vec<vec<Lit> >& coreClauses,
  int doResolutionB,
  int doFinalClean
)
{
  Ddi_Bdd_t *interpolant;
  Ddi_Bdd_t *interpolantOpt;
  Checker trav(ddm,S.nVars());
  ClauseId goal = ClauseId_NULL;
  int partial = ddm->settings.aig.partialItp;
  int nCoreV, nCoreC;
  int nAClausesCore=-1;
  int i, j;
  ///

  trav.computeCore = 1;
  trav.nAClauses = nAClauses;
  trav.proofSize = S.proof->last();
  trav.genResolutionB = doResolutionB;
  trav.dontCareOpt = ddm->settings.aig.itpUseCare;

  ddm->stats.aig.fullAndItpTerms=0;
  ddm->stats.aig.fullOrItpTerms=0;
  ddm->stats.aig.itpTerms=0;

  if (0 && doResolutionB>0)
    trav.minHintLits = 8;
  //  trav.genResolution = doResolutionB;
  if (1 && ddm->cnf.useSavedAigsForSat>1) {
    //    trav.itpSaveCoreResolutions = 1;
    trav.itpSaveUnitResolutions = 1;
    trav.genResolution = 1;
  }

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),
    "computing interpolant from refutation proof of size %d\n",
    S.proof->last()));

  if (assumps!=NULL) {
    if (S.conflict_id >= 0 && S.conflict_id < S.proof->last()) {
      goal = S.conflict_id;
    }
  }
  
  S.proof->traverse(trav, goal);
  if (doFinalClean) S.proof->deleteTemps();
  
  if (trav.minHintLits > 0) {
    SaveClausesAsAigs(ddm,trav.hintClauses,0.5);
  }
  else if (trav.itpSaveCoreResolutions) {
    SaveClausesAsAigs(ddm,trav.resolutionClauses,0.5);
  }
  else if (trav.itpSaveUnitResolutions) {
    SaveClausesAsAigs(ddm,trav.unitResolutionClauses,1.0);
  }

  nCoreV = 0;
  nCoreC = trav.coreClauses.size();

  if (trav.aborted) {
    return -1;
  }


  coreClauses.clear();
  coreVars.clear();
  nAClausesCore = trav.nAClausesCore;
  if (assumps!=NULL) {
    Pdtutil_Assert(nAssumpsA<=assumps->size(),
                   "wrong num of assumps");
    for (i=0; i<nAssumpsA; i++) {
      Lit lit = (*assumps)[i];
      if (trav.coreVars[var(lit)] == 0x4) {
        // unused.
        continue;
      }
      nAClausesCore++;
      trav.coreVars[var(lit)] &= 0x3;
      if (sign(lit)) {
        trav.coreVars[var(lit)] |= 0x1;
      }
      else {
        trav.coreVars[var(lit)] |= 0x2;
      }
      coreClauses.push();
      vec<Lit>& c = coreClauses.last();
      c.push(lit);
    }
    nCoreC += assumps->size();
  }
  if (a!=NULL) {
    int i;
    bAig_array_t *aigNodes = bAigArrayAlloc();
    vec<char> isAVar, isAClause;
    isAVar.growTo(S.nVars());
    isAClause.growTo(trav.coreClauses.size());
    for (i=0; i<S.nVars(); i++) isAVar[i] = 0;
    Ddi_PostOrderBddAigVisitIntern(a,aigNodes,-1);
    Ddi_PostOrderAigClearVisitedIntern(trav.bMgr,aigNodes);
    for (i=0; i<aigNodes->num; i++) {
      bAigEdge_t baig = aigNodes->nodes[i];
      int cnfId = DdiAig2CnfId(trav.bMgr,baig);
      if (cnfId>0 && cnfId <= S.nVars()) {
        isAVar[cnfId-1] = 1;
      }
    }
    bAigArrayFree(aigNodes);
    for (i=0; i<trav.coreClauses.size(); i++) {
      vec<Lit>& c = trav.coreClauses[i];
      char aClause = 1;
      isAClause[i] = 0;
      if (c.size()==0) continue;
      for (j=0; j<c.size(); j++) {
        int v =var(c[j]);
        aClause &= isAVar[v];
      }
      isAClause[i] = aClause;
    }
    // a clauses
    for (i=0; i<trav.coreClauses.size(); i++) {
      if (isAClause[i]) {
        coreClauses.push();
        trav.coreClauses[i].copyTo(coreClauses.last());
      }
    }
    // b clauses
    nAClausesCore = coreClauses.size();
    for (i=0; i<trav.coreClauses.size(); i++) {
      vec<Lit>& c = trav.coreClauses[i];
      if (c.size()==0) continue;
      if (!isAClause[i]) {
        coreClauses.push();
        trav.coreClauses[i].copyTo(coreClauses.last());
      }
    }
  }
  else { 
    for (i=0; i<trav.coreClauses.size(); i++) {
      coreClauses.push();
      trav.coreClauses[i].copyTo(coreClauses.last());
    }
  }
  if (assumps!=NULL) {
    for (i=nAssumpsA; i<assumps->size(); i++) {
      Lit lit = (*assumps)[i];
      if (trav.coreVars[var(lit)] == 0x4) {
        // unused.
        continue;
      }
      trav.coreVars[var(lit)] &= 0x3;
      if (sign(lit)) {
        trav.coreVars[var(lit)] |= 0x1;
      }
      else {
        trav.coreVars[var(lit)] |= 0x2;
      }
      coreClauses.push();
      vec<Lit>& c = coreClauses.last();
      c.push(lit);
    }
  }

  Pdtutil_Assert (trav.coreVars.size()==S.nVars(),"misaligned array");
  for (i=0; i<S.nVars(); i++) {
    if (trav.coreVars[i]) {
      if (trav.coreVars[i]!=4) {
        Pdtutil_Assert(trav.coreVars[i]<=7,"invalid core var phase");
        Pdtutil_Assert(trav.coreVars[i]>0,"invalid core var phase");
        coreVars.push((i<<2)+(trav.coreVars[i])%4);
        nCoreV++;
      }
    }
  }

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
                       fprintf(dMgrO(ddm),"core size %d vars / %d clauses (res core: %d)\n", nCoreV, nCoreC, trav.nResCore));

  /*vec<Lit>& c =*/ trav.clauses.last();

  return nAClausesCore;
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static Ddi_Bdd_t *
MinisatCoreAig (
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *share,
  vec<Var>& coreVars,
  vec<Var> *sharedVars,
  bAig_array_t *cnfMappedVars,
  int *nCutP,
  aigCnfMgr_t *aigCnfMgr,
  nnfCoreMgr_t *nnfCoreMgr,
  int monotoneExist
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *coreAig;
  int i, nNodes, nUsed=0, nCut=nCutP?*nCutP:0;
  bAig_array_t *visitedNodes;
  bAig_array_t *sharedNodes;
  char name[100];
  bAigEdge_t baig;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int tightCore = 1;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  int nSolverVars = 0;
  int printLevelInfo = 0;
  //  int cntAbstr=0;
  //  int enFilter=0;
  //  int disAbstr=206;

  //  static int maxAbstr=2;

  if (printLevelInfo) {
    int *lCnt = NULL, maxl, l;
    visitedNodes = bAigArrayAlloc();
    postOrderBddAigVisitIntern(f, visitedNodes, 0, -1);
    postOrderAigClearVisitedIntern(bmgr,visitedNodes);

    aigArrayLevelizeIntern(bmgr,visitedNodes);
    maxl = 0;
    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      l = bAig_AuxInt(bmgr,baig);
      if (l>maxl) maxl = l;
    }

    lCnt = Pdtutil_Alloc(int,maxl+1);
    for (i=0; i<=maxl; i++) {
      lCnt[i]=0;
    }

    for (i=0; i < coreVars.size(); i++) {
      int vCnf = (coreVars[i]>>2)+1;
      baig = ddm->cnf.cnf2aig[vCnf];
      // Pdtutil_Assert(bAig_AuxInt(bmgr,baig)<=0,"invalid aux int");
      bAig_AuxInt(bmgr,baig) = -1;
    }

    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      int l = bAig_AuxInt(bmgr,baig);
      if (l>=0) lCnt[l]++;
    }
    for (i=0; i<=maxl; i++) {
      if (lCnt[i]>0)
	printf("L[%d]->%d ", i, lCnt[i]);
    }
    printf("\n");
    aigArrayClearAuxIntIntern(bmgr,visitedNodes);
    bAigArrayFree(visitedNodes);

    Pdtutil_Free(lCnt);

  }

  if (nnfCoreMgr!=NULL) {
    if (nnfCoreMgr->aNodes!=NULL) {
      for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
	if (nnfCoreMgr->isCore[i]) {
	  bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
	  bAig_AuxInt(bmgr,baig) = 2;
	}
      }
    }
  }

  if (aigCnfMgr!=NULL && aigCnfLevel>1) {
    for (i=0; i<aigCnfMgr->nNodes; i++) {
      bAigEdge_t baig = aigCnfMgr->visitedNodes->nodes[i];
      if (!aigCnfMgr->aigCnfInfo[i].isRoot) {
        bAig_AuxInt(bmgr,baig) = 2;
      }
    }
  }

  for (i=0; i < coreVars.size(); i++) {
    int vCnf = (coreVars[i]>>2)+1;
    if (vCnf>ddm->cnf.maxCnfId) continue;
    baig = ddm->cnf.cnf2aig[vCnf];
    // Pdtutil_Assert(bAig_AuxInt(bmgr,baig)<=0,"invalid aux int");
    bAig_AuxInt(bmgr,baig) = 1;
  }

  if (cnfMappedVars!=NULL) {
    for (i=1; i<cnfMappedVars->num; i++) {
      bAigEdge_t baig = cnfMappedVars->nodes[i];
      if (baig != bAig_NULL) {
	bAig_AuxInt(bmgr,baig) = 2;
      }
    }
  }

  if (nnfCoreMgr!=NULL) {
    visitedNodes = nnfCoreMgr->aNodes;
  }
  else {
    visitedNodes = bAigArrayAlloc();
    postOrderBddAigVisitIntern(f, visitedNodes, 0, -1);
    postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  }

  sharedNodes = bAigArrayAlloc();
  if (share!=NULL) {
    postOrderBddAigVisitIntern(share, sharedNodes, 0, -1);
    postOrderAigClearVisitedIntern(bmgr,sharedNodes);

    for (i=0; i<sharedNodes->num; i++) {
      baig = sharedNodes->nodes[i];
      bAig_AuxInt(bmgr,baig) = 2;
    }
  }

  nNodes = visitedNodes->num;

  if (sharedVars!=NULL) {
    for (i=0; i < (*sharedVars).size(); i++) {
      int vCnf = ((*sharedVars)[i]>>2)+1;
      baig = ddm->cnf.cnf2aig[vCnf];
      // Pdtutil_Assert(bAig_AuxInt(bmgr,baig)<=0,"invalid aux int");
      bAig_AuxInt(bmgr,baig) = 2;
    }
  }
  
  if (0 && nSolverVars>0 && aigCnfLevel>1) {
    for (i=0; i<nNodes; i++) {
      int aux;
      bAigEdge_t baig1;
      baig = visitedNodes->nodes[i];

      aux = bAig_AuxInt(bmgr,baig);

      if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
	continue;
      }
      else if ((aux==0)) {
        /* used gate: set out of core */
	bAig_AuxInt(bmgr,baig)=-1;
      }
      else if ((aux<0)) {
        /* unused gate - not cnf encoded - speculate in core */
	bAig_AuxInt(bmgr,baig)=1;
      }
    }
  }

  if (0 && (aigCnfLevel > 0)) {
    /* not working: restores gates out of core */
    /* mark nodes not in core with transitive coi in core */
    for (i=0; i<nNodes; i++) {
      int aux;
      bAigEdge_t baig1;
      baig = visitedNodes->nodes[i];

      aux = bAig_AuxInt(bmgr,baig);

      if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
	continue;
      }
      else if ((aux>=0)) {
      /* in core: ignore */
	continue;
      }
      else {
	bAigEdge_t right, left;
	Pdtutil_Assert(aux==-1,"wrong out of core code");
	right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
	left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
	if (bAig_AuxInt(bmgr,right)!=-1 && bAig_AuxInt(bmgr,left)!=-1) {
	  bAig_AuxInt(bmgr,baig)=-8;
	}
      }
    }
    /* mark observed nodes not in core with transitive coi in core */
    for (i=nNodes-1; i>=0; i--) {
      int aux;
      bAigEdge_t baig1;
      baig = visitedNodes->nodes[i];

      aux = bAig_AuxInt(bmgr,baig);

      if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
	continue;
      }
      else if ((aux<0)) {
        /* not observed: ignore */
	if (bAig_AuxInt(bmgr,baig)==-8) {
	  bAig_AuxInt(bmgr,baig)=-1;
	}
	continue;
      }
      else {
	bAigEdge_t right, left;
	Pdtutil_Assert(aux==1,"wrong core code");
	right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
	left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
	if (bAig_AuxInt(bmgr,right)==-8) {
	  bAig_AuxInt(bmgr,right)=1;
	}
	if (bAig_AuxInt(bmgr,left)==-8) {
	  bAig_AuxInt(bmgr,left)=1;
	}
      }
    }


  }


  for (i=0; i<nNodes; i++) {
    int aux;
    bAigEdge_t baig1;
    baig = visitedNodes->nodes[i];

    aux = bAig_AuxInt(bmgr,baig);

    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
      bAig_AuxInt(bmgr,baig)=1;
      continue;
    }
    else if ((aux<0)) {
      /* not core: ignore */
      //  if (enFilter) cntAbstr++;
      continue;
    }
    else {
      bAigEdge_t right, left;
      Pdtutil_Assert(aux==1||aux==2||aux==3,"wrong core code");
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      if (tightCore && aux==1 &&
	  bAig_AuxInt(bmgr,right)==-1 && bAig_AuxInt(bmgr,left)==-1) {
	/* both children out: set node itself as frontier */
        // printf("U [%d]: %d\n", i, baig/4);
	bAig_AuxInt(bmgr,baig)=-2;
	nUsed++;
      }
      else {
	if (bAig_AuxInt(bmgr,right)==-1) {
	  bAig_AuxInt(bmgr,right)=-2;
          // printf("Ur [%d]: %d\n", i, right/4);
	  nUsed++;
	}
	if (bAig_AuxInt(bmgr,left)==-1) {
          // printf("Ul [%d]: %d\n", i, left/4);
	  bAig_AuxInt(bmgr,left)=-2;
	  nUsed++;
	}
      }
    }
  }

  if (Ddi_BddIsPartConj(f) || Ddi_BddIsPartDisj(f)) {
    for (i=0; i<Ddi_BddPartNum(f); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
      bAigEdge_t baig_i = Ddi_BddToBaig(f_i);
      if (bAig_AuxInt(bmgr,baig_i) == -2) {
	/* not in core, skip */
	bAig_AuxInt(bmgr,baig_i) = Ddi_BddIsComplement(f_i) ? -3 : -4;
      }
    }
  }

  if (monotoneExist) {

    if (Ddi_BddIsPartConj(f) || Ddi_BddIsPartDisj(f)) {
      for (i=0; i<Ddi_BddPartNum(f); i++) {
	Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
	bAigEdge_t baig_i = Ddi_BddToBaig(f_i);
	int val = Ddi_BddIsComplement(f_i);
	if (bAig_AuxInt1(bmgr,baig_i)>=0) {
	  Pdtutil_Assert(bAig_AuxInt1(bmgr,baig_i)==val,
			 "conflicting values in part aig");
	}
	else {
	  bAig_AuxInt1(bmgr,baig_i) = Ddi_BddIsComplement(f_i);
	}
      }
    }
    else {
      baig = Ddi_BddToBaig(f);
      Pdtutil_Assert(bAig_AuxInt1(bmgr,baig)==-1,"wrong aux int1 field");
      bAig_AuxInt1(bmgr,baig) = Ddi_BddIsComplement(f);
    }
    for (i=nNodes-1; i>=0; i--) {
      int aux, phase;
      bAigEdge_t baig1;
      bAigEdge_t right, left;
      int rightInv, leftInv;
      baig = visitedNodes->nodes[i];

      if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) continue;

      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      rightInv = bAig_NodeIsInverted(right);
      leftInv = bAig_NodeIsInverted(left);

      phase = bAig_AuxInt1(bmgr,baig);
      Pdtutil_Assert(phase>=0,"wrong node phase");

      if (phase) {
	/* complemented */
	rightInv = !rightInv;
	leftInv = !leftInv;
      }
      if (bAig_isVarNode(bmgr,right)) {
	Pdtutil_Assert(rightInv&&(monotoneExist<0)||
		       !rightInv&&(monotoneExist>0),"monotonicity error");
      }
      if (bAig_isVarNode(bmgr,left)) {
	Pdtutil_Assert(leftInv&&(monotoneExist<0)||
		       !leftInv&&(monotoneExist>0),"monotonicity error");
      }
      Pdtutil_Assert(bAig_AuxInt1(bmgr,right)==-1 ||
		     bAig_AuxInt1(bmgr,right)==rightInv,"wrong aux int1 field");
      Pdtutil_Assert(bAig_AuxInt1(bmgr,left)==-1 ||
		     bAig_AuxInt1(bmgr,left)==leftInv,"wrong aux int1 field");
      bAig_AuxInt1(bmgr,right) = rightInv;
      bAig_AuxInt1(bmgr,left) = leftInv;

    }

    for (i=0; i<nNodes; i++) {
      int aux, phase;
      bAigEdge_t baig1;
      baig = visitedNodes->nodes[i];

      if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {

	aux = bAig_AuxInt(bmgr,baig);

	if ((aux==-2)) {
	  int constant;
	  bAigEdge_t right, left;
	  int rightInv, leftInv;

	  phase = bAig_AuxInt1(bmgr,baig);
	  bAig_AuxInt(bmgr,baig)= phase ? -3 : -4;
	}
      }

      bAig_AuxInt1(bmgr,baig) = -1;

    }
  }

#define LOG_BAIG 0
 
  for (i=0; i<nNodes; i++) {
    int aux;
    bAigEdge_t baig1;
    baig = visitedNodes->nodes[i];

    aux = bAig_AuxInt(bmgr,baig);

    if (bAig_NodeIsConstant(baig)) {
      baig1 = bAig_NonInvertedEdge(baig);
    }
    else if (bAig_isVarNode(bmgr,baig)) {
      baig1 = bAig_NonInvertedEdge(baig);
    }
    else if ((aux==-1)) {
      baig1 = bAig_NonInvertedEdge(baig);
      /* not in core & not reachable */
    }
    else if ((aux==-3)) {
#if LOG_BAIG
      {
        int solverV = aig2CnfIdRead(bmgr,baig)-1;
        printf("abstracting baig: %d - solver var %d\n",
               baig/4, solverV);
      }
#endif
      baig1 = bAig_Zero;
    }
    else if ((aux==-4)) {
#if LOG_BAIG
      {
        int solverV = aig2CnfIdRead(bmgr,baig)-1;
        printf("abstracting baig: %d - solver var %d\n",
               baig/4, solverV);
      }
#endif
      baig1 = bAig_One;
    }
    else if ((aux==2)) {
      baig1 = bAig_NonInvertedEdge(baig);
      /* shared - keep in core */
    }
    else if (1 && (aux<-1)) {
      /* no core aig and used: create cut var */
      Ddi_Var_t *aV;
      sprintf(name,"PDT_AUXV_PART_%d", nCut++);
      aV = Ddi_VarFromName(ddm,name);
      if (aV == NULL) {
	aV = Ddi_VarNewBaig(ddm,name);
	//	Ddi_VarAttachName (aV, name);
      }
      baig1 = Ddi_VarBaigId(aV);
    }
    else {
      bAigEdge_t right, left, right1, left1;
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      right1 = bAig_AuxAig1(bmgr,right);
      left1 = bAig_AuxAig1(bmgr,left);
      if (bAig_NodeIsInverted(right)) {
	right1 = bAig_Not(right1);
      }
      if (bAig_NodeIsInverted(left)) {
	left1 = bAig_Not(left1);
      }
      baig1 = bAig_And(bmgr,right1,left1);
    }
    bAig_Ref(bmgr, baig1);

    bAig_AuxAig1(bmgr,baig) = baig1;
  }

  if (Ddi_BddIsPartConj(f) || Ddi_BddIsPartDisj(f)) {
    int isConj = Ddi_BddIsPartConj(f);
    coreAig = isConj ? Ddi_BddMakePartConjVoid(ddm) :
      Ddi_BddMakePartDisjVoid(ddm);
    for (i=0; i<Ddi_BddPartNum(f); i++) {
      Ddi_Bdd_t *c_i_new, *f_i = Ddi_BddPartRead(f,i);
      bAigEdge_t baig_i = Ddi_BddToBaig(f_i);
      if (bAig_AuxInt(bmgr,baig_i) < 0) {
	/* not in core, skip */
	Ddi_Bdd_t *myConst = Ddi_BddMakeConstAig(ddm,1);
	Ddi_BddPartInsertLast(coreAig,myConst);
	Ddi_Free(myConst);
	continue;
      }
      baig = bAig_AuxAig1(bmgr,baig_i);
      c_i_new = Ddi_BddMakeFromBaig(ddm,baig);
      if (Ddi_BddIsComplement(f_i)) {
	Ddi_BddNotAcc(c_i_new);
      }
      Ddi_BddPartInsertLast(coreAig,c_i_new);
      Ddi_Free(c_i_new);
    }
    Pdtutil_Assert (Ddi_BddPartNum(coreAig)>0,"problem with part core");
  }
  else {
    baig = bAig_AuxAig1(bmgr,visitedNodes->nodes[nNodes-1]);
    coreAig = Ddi_BddMakeFromBaig(ddm,baig);
    if (Ddi_BddIsComplement(f)) {
      Ddi_BddNotAcc(coreAig);
    }
  }

  if (verbosity >= Pdtutil_VerbLevelDevMin_c) {
    printf("# AIG core -> gates: %d / %d (maxCut: %d)\n",
	   Ddi_BddSize(coreAig), Ddi_BddSize(f), nCut);
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_RecursiveDeref(bmgr,bAig_AuxAig1(bmgr,baig));
    bAig_AuxAig1(bmgr,baig) = bAig_NULL;
    if (bAig_AuxInt(bmgr,baig) <= -2) {
      //      printf("-U [%d]: %d\n", i, baig/4);
      bAig_AuxInt(bmgr,baig) = -1;
      nUsed--;
    }
    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
      bAig_AuxInt(bmgr,baig) = -1;
    }
  }

  Pdtutil_Assert(nUsed==0,"problem setting/reseting used core-frontier");

  if (nnfCoreMgr!=NULL) {
    if (nnfCoreMgr->aNodes!=NULL) {
      for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
	bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
	if (bAig_AuxInt(bmgr,baig) > 0) {
	  nnfCoreMgr->isCore[i] = (char)1;
	  bAig_AuxInt(bmgr,baig) = -1;
	}
      }
    }
  }

  for (i=0; i < coreVars.size(); i++) {
    int vCnf = (coreVars[i]>>2)+1;
    if (vCnf>ddm->cnf.maxCnfId) continue;
    baig = ddm->cnf.cnf2aig[vCnf];
    Pdtutil_Assert(bAig_AuxInt(bmgr,baig)>0||tightCore,
		   "invalid aux int");
    bAig_AuxInt(bmgr,baig) = -1;
  }

  if (cnfMappedVars!=NULL) {
    for (i=1; i<cnfMappedVars->num; i++) {
      bAigEdge_t baig = cnfMappedVars->nodes[i];
      if (baig != bAig_NULL) {
	bAig_AuxInt(bmgr,baig) = -1;
      }
    }
  }

  if (aigCnfMgr!=NULL && aigCnfLevel>1) {
    for (i=0; i<aigCnfMgr->nNodes; i++) {
      bAigEdge_t baig = aigCnfMgr->visitedNodes->nodes[i];
      if (!aigCnfMgr->aigCnfInfo[i].isRoot) {
        bAig_AuxInt(bmgr,baig) = -1;
      }
    }
  }

  for (i=0; i<sharedNodes->num; i++) {
    baig = sharedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
  }
  if (sharedVars!=NULL) {
    for (i=0; i < (*sharedVars).size(); i++) {
      int vCnf = ((*sharedVars)[i]>>2)+1;
      baig = ddm->cnf.cnf2aig[vCnf];
      // Pdtutil_Assert(bAig_AuxInt(bmgr,baig)<=0,"invalid aux int");
      bAig_AuxInt(bmgr,baig) = -1;
    }
  }

  if (nnfCoreMgr==NULL) {
    bAigArrayFree(visitedNodes);
  }
  bAigArrayFree(sharedNodes);

  if (nCutP) {
    *nCutP = nCut;
  }

  return coreAig;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/

static int
aigArraySearch(
  bAig_array_t *visitedNodes,
  bAigEdge_t baig
)
{
  int k;
  for (k=0;k<visitedNodes->num;k++) {
    bAigEdge_t baig_k = visitedNodes->nodes[k];
    if (bAig_NonInvertedEdge(baig_k) == bAig_NonInvertedEdge(baig)) {
      return k;
    }
  }
  return -1;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/

static Ddi_Var_t *
newQbfVar(
  Ddi_Mgr_t *ddm,
  int idx
)
{
   Ddi_Var_t *v;
   char name[20];

   sprintf(name, "qbf_%d", idx);
   v = Ddi_VarFromName(ddm, name);
   if (v != NULL) {
      return v;
   }

   v = Ddi_VarNew(ddm);
   Ddi_VarAttachName(v, name);
   return v;
 }

/**Function********************************************************************
  Synopsis    [ Return stats on ffr into a circuit ]
  Description [ visitedNodes array stores nodes visited in postOrder. ffrSize
                gives info about ffr with size greater than ffrSize ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
dom_stats(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes,
  int *doms,
  int *occur,
  int ffrSize
)
{
  int idom, outDom;
  int changed = 1;
  int i,size=0,k,size2=0, cnt2=0;
  mincut_info *nodeInfoArray;
  int *rep,*rep2,*occ;

  for (i=0;i<visitedNodes->num;i++){
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = i;
    doms[i]=-1;
  }

  doms[visitedNodes->num-1]=visitedNodes->num-1;

  rep=Pdtutil_Alloc(int,visitedNodes->num);
  rep2=Pdtutil_Alloc(int,visitedNodes->num);
  if (occur == NULL) {
    occ = Pdtutil_Alloc(int,visitedNodes->num);
  } else {
    occ = occur;
  }
  nodeInfoArray=Pdtutil_Alloc(mincut_info,visitedNodes->num);

  for (i=0; i<visitedNodes->num; i++) {
    nodeInfoArray[i].foCnt = -1;
    nodeInfoArray[i].foIds=NULL;
    nodeInfoArray[i].fiIds[0] = nodeInfoArray[i].fiIds[1] = -1;
  }

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    nodeInfoArray[i].foCnt = 0;

    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      int ir = bAig_AuxInt(bmgr,right);
      int il = bAig_AuxInt(bmgr,left);
      Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
      Pdtutil_Assert(nodeInfoArray[ir].foCnt>=0,"fo cnt not initialized");
      Pdtutil_Assert(nodeInfoArray[il].foCnt>=0,"fo cnt not initialized");
      if (ir>=0 && il >= 0){
	nodeInfoArray[ir].foCnt++;
	nodeInfoArray[il].foCnt++;
	nodeInfoArray[i].fiIds[0]=ir;
	nodeInfoArray[i].fiIds[1]=il;
      }
    }
  }

  // alloc fanout arrays
  for (i=0; i<visitedNodes->num; i++) {
    nodeInfoArray[i].foIds = Pdtutil_Alloc(int,nodeInfoArray[i].foCnt);
  }

  // setup fanout info
  for (i=0; i<visitedNodes->num; i++) {
    int ir, il;
    bAigEdge_t baig = visitedNodes->nodes[i];

    nodeInfoArray[i].foCnt = 0;
    ir = nodeInfoArray[i].fiIds[0];
    il = nodeInfoArray[i].fiIds[1];
    if (ir>=0 && il>=0) {
      Pdtutil_Assert(nodeInfoArray[ir].foCnt>=0,"fo cnt not initialized");
      Pdtutil_Assert(nodeInfoArray[il].foCnt>=0,"fo cnt not initialized");
      nodeInfoArray[ir].foIds[nodeInfoArray[ir].foCnt]=i;
      nodeInfoArray[il].foIds[nodeInfoArray[il].foCnt]=i;
      nodeInfoArray[ir].foCnt++;
      nodeInfoArray[il].foCnt++;
    }
  }

  while(changed){
    changed = 0;
    for (k=visitedNodes->num-2;k>=0;k--){
      for(i=0;i<nodeInfoArray[k].foCnt;i++){
	if (i==0)
	  idom=nodeInfoArray[k].foIds[i];
	else { // for all other predecessors
	  if (doms[i] != -1){
	    idom=intersect(nodeInfoArray[k].foIds[i], idom, doms);
	  }
	}
      }
      if (doms[k] != idom){
	doms[k]=idom;
	changed=1;
      }
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    Pdtutil_Free(nodeInfoArray[i].foIds);
  }
  Pdtutil_Free(nodeInfoArray);


  // stats
  memcpy(rep,doms,visitedNodes->num*sizeof(int));

#if 0
  changed=1;
  while(changed){
    changed=0;
    for (i=0;i<visitedNodes->num;i++){
      if (rep[i]!=0){
	for (k=i+1;k<visitedNodes->num;k++){
	  if (rep[k] == rep[i]){
	    rep[k]=0;
	    changed=1;
	  }
	}
      }
    }
  }
#else
  {
    int *cntRep = Pdtutil_Alloc(int, visitedNodes->num);
    for (i=0;i<visitedNodes->num;i++){
      cntRep[i]=0;
    }
    for (i=0;i<visitedNodes->num;i++){
      int ir = rep[i];
      cntRep[ir]++;
    }
    for (i=visitedNodes->num-1;i>=0;i--){
      int ir = rep[i];
      if (ir!=0 && cntRep[ir]>1) {
	rep[i]=0;
	cntRep[ir]--;
      }
    }
    Pdtutil_Free(cntRep);
  }
#endif

  size=0;
  for (i=0;i<visitedNodes->num;i++){
    if(rep[i]!=0)
      rep2[size++]=rep[i];
  }

  // occurrencies array
  for (i=0;i<visitedNodes->num;i++){
    occ[i]=0;
  }

  for (i=0;i<visitedNodes->num;i++){
    occ[doms[i]]++;
  }

  size2=0;
  for(i=0;i<size;i++)
    if(occ[rep2[i]]>ffrSize){
      //     fprintf(dMgrO(ddm),"dom. node %d -> size %d\n", rep2[i], occ[rep2[i]]);
      size2++;
    }
  for (i=0;i<visitedNodes->num;i++){
    if(occ[doms[i]]>ffrSize){
      cnt2++;
    }
    else {
      doms[i] = -1;
    }
  }

#if 0
  fprintf(dMgrO(ddm),"Number of dominator nodes/number of total nodes=%.2f\n",
	 (float)size2/(float)visitedNodes->num);
  fprintf(dMgrO(ddm),"Number of number of total nodes / dominator nodes =%.2f (filtered)\n",
	 (float)cnt2/(float)size2);
  fprintf(dMgrO(ddm),"Number of number of total nodes / dominator nodes =%.2f\n",
	 (float)visitedNodes->num/(float)size);
  fprintf(dMgrO(ddm),"Number of number of nodes / filtered nodes = %d / %d\n",
	 visitedNodes->num, cnt2);
#endif

  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    bAig_AuxInt(bmgr,baig) = -1;
  }

  outDom = visitedNodes->num-1;
  for (i=0;i<visitedNodes->num;i++){
    rep2[i]=-1;
  }
  for (i=0;i<visitedNodes->num;i++){
    if(rep[i]!=0)
      rep2[rep[i]] = rep[i];
  }
  for (i=0;i<visitedNodes->num;i++){
    if(doms[i]!=outDom) {
      //     doms[i]=-1;
    }
  }

  Pdtutil_Free(rep2);
  Pdtutil_Free(rep);
  if (occur == NULL) {
    Pdtutil_Free(occ);
  }
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/

static int intersect(int b1, int b2, int *doms){
  int finger1, finger2;

  finger1=b1;
  finger2=b2;
  while(finger1 != finger2){
    while(finger1<finger2){
      finger1=doms[finger1];
    }
    while(finger2<finger1){
      finger2=doms[finger2];
    }
  }
  return finger1;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int foOptPropImpl(
  int id,
  int *workA,
  int *zeroRed,
  int *visited,
  int *nVisitedP,
  int **cutFi,
  int *cutFiNum,
  int *cutPins,
  int cutNum,
  int *nRedSameP,
  int *nRedRedP,
  int *nRedOrP,
  int *nRedFoundP,
  int isAndPin
)
{
  int jj;
  Pdtutil_Assert(zeroRed[id]!=1,"invalid sero red");

  if (zeroRed[id]==4) return 0;
  zeroRed[id] = 4;
  visited[(*nVisitedP)++] = id;

  for (jj=0; jj<cutNum; jj++) {
    int j0 = abs(cutPins[jj])-1;
    if (zeroRed[j0]==4) continue;
    if (workA[j0] != 0) {
      int samePhase = (workA[j0]>0 && cutPins[jj]>0);
      samePhase |= (workA[j0]<0 && cutPins[jj]<0);
      (*nRedFoundP)++;
      if (isAndPin && samePhase) {
	(*nRedSameP)++;
	if (abs(workA[j0])==1) {
	  workA[j0] *= 2;
	}
      }
      else if (isAndPin) {
	(*nRedRedP)++;
	return 1;
      }
      else if (cutNum==2) {
	(*nRedOrP)++;
	break;
      }
    }
    else if (isAndPin && !zeroRed[j0]) {
      int *cutPins0, isAndPin0, cutNum0;
      cutPins0 = cutFi[j0];
      isAndPin0 = cutPins[jj]>0;
      cutNum0 = cutFiNum[j0];
      if (foOptPropImpl(j0,workA,zeroRed,visited,nVisitedP,
			cutFi,cutFiNum,cutPins0,cutNum0,
			nRedSameP,nRedRedP,nRedOrP,nRedFoundP,isAndPin0)) {
	return 1;
      }
    }
  }

  return 0;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int *aigNetlistBddMerge(
  Ddi_Mgr_t *ddm,
  bAig_array_t *visitedNodes,
  Ddi_Bdd_t *careBdd,
  int *enCutVar,
  int *nRef,
  int th
)
{
  int i, num=visitedNodes->num;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  st_table *bddTObaigTable;
  st_generator *stgen;
  int nMultipleFo=0, nBdds=0, maxN=0, nMerge=0;
  int nAuxSpec = 0;
  int *eqNode, *nPendingRef;
  Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm,0);
  Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bdd_t **resBddArray;
  int liveNodes0 = Ddi_MgrReadLiveNodes(ddm);
  int maxLive = 5000000;
  int siftEn = 0, siftTh=1000000;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  int prev_i=0, prev_nMerge=0, prev_nAux=0;

  resBddArray = Pdtutil_Alloc(Ddi_Bdd_t *, num);
  eqNode = Pdtutil_Alloc(int, num);
  nPendingRef = Pdtutil_Alloc(int, num);

  Ddi_MgrSiftSuspend(ddm);

  for (i=0; i<num; i++) {
    eqNode[i]=i+1;
    nPendingRef[i]=nRef[i];
    resBddArray[i]=NULL;
  }

  bddTObaigTable = st_init_table(st_numcmp, st_numhash);

  for (i=0; i<num; i++) {

    int ir, il, enSizeChk = 0||enCutVar[i];
    Ddi_Bdd_t *resBdd=NULL, *rightBdd=NULL, *leftBdd=NULL;
    int size;
    bAigEdge_t right, left;;
    bAigEdge_t baig = visitedNodes->nodes[i];

    int liveNodes = Ddi_MgrReadLiveNodes(ddm);

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
      if (0 && (i>0) && i%1000 == 0) {
        fprintf(stdout, "BDD MERGE iter: %d - liveNodes: %d\n", i, liveNodes);
      }
    );
    if (Ddi_VararrayNum(auxV) > 5000) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
        fprintf(stdout, "BDD merge terminated - too many AUX VARS\n",
          i, Ddi_VararrayNum));
      break;
    }

    if (siftEn && (liveNodes-liveNodes0) > siftTh) {
      siftEn=0;
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c,
          Pdtutil_VerbLevelNone_c,
	  fprintf(stdout, "activating DYN ord\n"));
        Ddi_MgrSiftResume(ddm);
        Ddi_MgrReduceHeap (ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);
        Ddi_MgrSiftSuspend(ddm);
    }
    else if ((liveNodes-liveNodes0) > maxLive) {
      DdNode *tmp;
      int ldr_i;
      if (maxLive >= 10000000) {
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c,
          Pdtutil_VerbLevelNone_c,
	  fprintf(stdout, "BDD merge terminated - too many live Nodes\n",
            i, liveNodes));
	break;
      }
      maxLive+=1000000;

      if (nMerge == 0 ||
	  ((i>num/3 && nMerge < 0.05*num)) ||
	  ((i>0.5*num) && (nMerge < 1.1*prev_nMerge)) ||
	  ((i<prev_i*1.05 || Ddi_VararrayNum(auxV)<1.05*prev_nAux) &&
	   (nMerge < 1.1*prev_nMerge))) {
	Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMin_c,
			       fprintf(stdout,
          "live Node threshold reached - low improvement (iter: %d/%d)\n",
	   i, num);
	fprintf(stdout, "curr BDD MERGE: %d/%d - auxv: %d\n",
	   nMerge,num, Ddi_VararrayNum(auxV)));
	break;
      }
      prev_i = i; prev_nMerge = nMerge; prev_nAux = Ddi_VararrayNum(auxV);

      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMin_c,
	fprintf(stdout,
          "live Node threshold reached - hash cleaned (iter: %d/%d)\n",
	   i, num);
	fprintf(stdout, "curr BDD MERGE: %d/%d - auxv: %d\n",
	   nMerge,num, Ddi_VararrayNum(auxV)));
      st_foreach_item_int(bddTObaigTable, stgen, (char**)&tmp, (int*)&ldr_i){
	Pdtutil_Assert(tmp==Cudd_Regular(tmp),"Wrong node in st table");
	Cudd_RecursiveDeref (ddm->mgrCU, tmp);
      }
      st_free_table(bddTObaigTable);
      bddTObaigTable = st_init_table(st_numcmp, st_numhash);
    }

    if (bAig_NodeIsConstant(baig)) {
      DdNode *cuNode;
      int ldr_i = i+1;
      resBdd = Ddi_BddMakeConst(ddm,0);
      cuNode = Cudd_Regular (Ddi_BddToCU(resBdd));
      if (Ddi_BddIsComplement(resBdd)) {
	ldr_i = -ldr_i;
      }
      Cudd_Ref(cuNode);
      st_insert(bddTObaigTable, (char *) cuNode, (char *) (long) ldr_i);
    }
    else if (bAig_isVarNode(bmgr,baig)) {
      DdNode *cuNode;
      int ldr_i = i+1;
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      int isAig = Ddi_VarIsAig(v);
      if (!isAig) {
	resBdd = Ddi_BddMakeLiteral(v,1);
	if (careBdd!=NULL) {
	  Ddi_BddConstrainAcc(resBdd,careBdd);
	}
      }
      else {
	char name[100];
	Ddi_Var_t *aV;
        sprintf(name,"_AUXV_SPEC_%d",nAuxSpec++);
        aV = Ddi_VarFromName(ddm,name);
        if (aV == NULL) {
          aV = Ddi_VarNew(ddm);
          Ddi_VarAttachName (aV, name);
        }
	resBdd = Ddi_BddMakeLiteral(aV,1);
      }
      cuNode = Cudd_Regular (Ddi_BddToCU(resBdd));
      if (Ddi_BddIsComplement(resBdd)) {
	ldr_i = -ldr_i;
      }
      Cudd_Ref(cuNode);
      st_insert(bddTObaigTable, (char *) cuNode, (char *) (long) ldr_i);
    }
    else {
      right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);
      Pdtutil_Assert(ir>=0 && il>=0 && ir<num && il<num,"Invalid aux int");

      nPendingRef[ir]--;
      nPendingRef[il]--;

      Pdtutil_Assert(nPendingRef[ir]>=0,"Invalid pending ref");
      Pdtutil_Assert(nPendingRef[il]>=0,"Invalid pending ref");

      resBdd = NULL;
      rightBdd = Ddi_BddDup(resBddArray[ir]);
      leftBdd = Ddi_BddDup(resBddArray[il]);
      if (bAig_NodeIsInverted(right)) {
        Ddi_BddNotAcc(rightBdd);
      }
      if (bAig_NodeIsInverted(left)) {
        Ddi_BddNotAcc(leftBdd);
      }

      resBdd = Ddi_BddAnd(rightBdd,leftBdd);
      if (0&&careBdd!=NULL) {
	Ddi_BddConstrainAcc(resBdd,careBdd);
      }

      if (nRef[i]>1) {
	nMultipleFo++;
      }
      Pdtutil_Assert(resBdd!=NULL,"NULL BDD computed");

      if (1)
      {
	int ldr_i;
	DdNode *cuNode = Cudd_Regular (Ddi_BddToCU(resBdd));
	if (0) {
	  if (Cudd_IsConstant(cuNode)) {
	    printf("CONSTANT\n");
	  }
	  else if (Cudd_IsVar(cuNode)) {
	    printf("VAR\n");
	  }
	}
        if (st_lookup_int(bddTObaigTable, (char *) cuNode, (int*)&ldr_i)) {
	  /* merge node_i <-> i */
          if (Ddi_BddIsComplement(resBdd)) {
	    ldr_i = -ldr_i;
	  }
	  eqNode[i]=ldr_i;
	  nMerge++;
	  if (resBddArray[abs(ldr_i)-1]!=NULL) {
	    Ddi_Free(resBdd);
	    resBdd = Ddi_BddDup(resBddArray[abs(ldr_i)-1]);
	    if (ldr_i < 0) {
	      Ddi_BddNotAcc(resBdd);
	    }
	  }
	}
	else {
          ldr_i = i+1;
          if (Ddi_BddIsComplement(resBdd)) {
	    ldr_i = -ldr_i;
	  }
	  Cudd_Ref(cuNode);
          st_insert(bddTObaigTable, (char *) cuNode, (char *) (long) ldr_i);
	}
      }

      Ddi_Free(rightBdd);
      Ddi_Free(leftBdd);

      if (Ddi_MgrReadLiveNodes(ddm)-liveNodes > 50*th) {
	enSizeChk = 2;
      }
      if (enSizeChk) {
	size=Ddi_BddSize(resBdd);
      }
      if (th > 0 && ( (enSizeChk==1 && (size > th)) ||
		      enSizeChk==2&&(size>(50*th)) ) ) {
	char name[100];
	Ddi_Var_t *aV;
        sprintf(name,"_AUXV_%d",Ddi_VararrayNum(auxV));
        aV = Ddi_VarFromName(ddm,name);
        if (aV == NULL) {
          aV = Ddi_VarNewBeforeVar(Ddi_BddTopVar(resBdd));
          Ddi_VarAttachName (aV, name);
        }
        Ddi_BddarrayInsertLast(auxF,resBdd);
	Ddi_Free(resBdd);
	resBdd = Ddi_BddMakeLiteral(aV,1);
        Ddi_VararrayInsertLast(auxV,aV);
      }

      if (1) {
	if (nPendingRef[ir]<=0) {
	  if (0) {
	    DdNode *toFreeCU = Cudd_Regular(Ddi_BddToCU(resBddArray[ir]));
	    if (st_delete(bddTObaigTable, (char *) (&toFreeCU), NULL)) {
	      Cudd_RecursiveDeref (ddm->mgrCU, toFreeCU);
	    }
	  }
	  Ddi_Free(resBddArray[ir]);
	  nBdds--;
	}
	if (nPendingRef[il]<=0) {
	  if (0) {
	    DdNode *toFreeCU = Cudd_Regular(Ddi_BddToCU(resBddArray[il]));
	    if (st_delete(bddTObaigTable, (char *) (&toFreeCU), NULL)) {
	      Cudd_RecursiveDeref (ddm->mgrCU, toFreeCU);
	    }
	  }
	  Ddi_Free(resBddArray[il]);
	  nBdds--;
	}
      }

    }

    resBddArray[i] = resBdd;
    nBdds++;
    if (nBdds > maxN) {
      maxN = nBdds;
    }
  }

  for (i=0; i<visitedNodes->num; i++) {
    if (resBddArray[i] != NULL) {
      Ddi_Free(resBddArray[i]);
      nBdds--;
    }
  }

  Pdtutil_Assert(nBdds==0,"error counting bdds");

  if (1)
  {
    DdNode *tmp;
    int ldr_i;
    st_foreach_item_int(bddTObaigTable, stgen, (char**)&tmp, (int*)&ldr_i){
      Pdtutil_Assert(tmp==Cudd_Regular(tmp),"Wrong node in st table");
      Cudd_RecursiveDeref (ddm->mgrCU, tmp);
    }
    st_free_table(bddTObaigTable);

  }

  Pdtutil_Free(nPendingRef);
  Pdtutil_Free(resBddArray);

  if (nMerge>0) {
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMed_c) {
      fprintf(stdout, "BDD MERGE: %d/%d - auxv: %d (tot aig: %d)\n",
	      nMerge,num, Ddi_VararrayNum(auxV), Ddi_MgrReadAigNodesNum(ddm));
    }
  }

  Ddi_Free(auxV);
  Ddi_Free(auxF);

  Ddi_MgrSiftResume(ddm);

  return eqNode;

}


/**Function********************************************************************

  Synopsis    [Compute image of a disjunctively partitioned transition
    relation]

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

Ddi_Bdd_t *
Ddi_ImgDisjSat (
  Ddi_Bdd_t *TR              /* TR */,
  Ddi_Bdd_t *from            /* domain set */,
  Ddi_Bdd_t *constrain       /* range constrain */,
  Ddi_Vararray_t *psv       /* Array of present state variables */,
  Ddi_Vararray_t *nsv       /* Array of next state variables */,
  Ddi_Varset_t *smoothV     /* Variables to be abstracted */
)
{
  Ddi_Bdd_t *to, *to_i, *from_i, *TR_i, *trAig, *fromAig, *constrainAig;
  int i, endImg;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);             /* dd manager */
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Varset_t *smSupp = Ddi_BddSupp(from);
  Ddi_Varset_t *smTr = Ddi_BddSupp(TR);
  Ddi_Vararray_t *vA;
  float satPartSmoothRatio = 1.0;
  float satPartSmoothReduce = 0.8;
  Ddi_Bdd_t *cubeConstrain = Ddi_BddMakeConst(ddm,1);

  Solver S;

  srand(12345);

  Ddi_VarsetUnionAcc(smSupp,smTr);
  Ddi_Free(smTr);
  Ddi_VarsetIntersectAcc(smSupp,smoothV);

  vA = Ddi_VararrayMakeFromVarset(smSupp,1);
  Ddi_Free(smSupp);

  to = Ddi_BddMakeConst(ddm,0);
  Ddi_BddSetPartDisj(to);

  trAig = Ddi_BddMakeAig(TR);
  fromAig = Ddi_BddMakeAig(from);
  if (constrain == NULL) {
    constrainAig = Ddi_BddMakeAig(from);
  }
  else {
    constrainAig = Ddi_BddMakeAig(constrain);
  }

  aig2CnfIdInit(ddm);

  MinisatClauses(S,trAig,NULL,NULL,0);
  MinisatClauses(S,fromAig,NULL,NULL,0);
  MinisatClauses(S,constrainAig,NULL,NULL,0);

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMed_c,
    fprintf(dMgrO(ddm), "DIsj SAT IMG.\n")
  );

  for (i=endImg=0; !endImg; i++) {
    int sat, nv, j;
    Ddi_Bdd_t *cex = NULL, *myConstrain;
    int nsm=0;
    int timeLimit=10;
    vec<Lit> assumps;
    int undef = 0;

    nv = Ddi_VararrayNum(vA);
    int max = 100, pct = max*satPartSmoothRatio;
    assumps.clear();

    if (!S.okay()) {
      sat = 0;
    }
    else {
      sat = S.solve(timeLimit);
    }
    if (S.undefined()) {
      endImg=undef=1;
      if (S.undefined()) {
        Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
          fprintf(dMgrO(ddm), "\nUNDEF SAT\n",
	    i, nsm, nv);fflush(dMgrO(ddm))
        );
      }
    }
    else if (!sat) {
      endImg=1;
      if (S.undefined()) {
        Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
          fprintf(dMgrO(ddm), "\nUNDEF SAT - UNSAT speculated\n",
	    i, nsm, nv);fflush(dMgrO(ddm))
        );
      }
      break;
    }

    cex = Ddi_BddMakeConst(ddm,1);
    from_i = Ddi_BddDup(from);
    TR_i = Ddi_BddDup(TR);

    if (!undef) {
      for (j=nv-1; j>=0; j--) {
	int r = rand();
	//      if (r%max < pct) {
	//      if (j+satPartSmoothRatio*nv>nv) {
	if (j < satPartSmoothRatio*nv) {
	  /* use var */
	  Ddi_Var_t *v = Ddi_VararrayRead(vA,j);
	  bAigEdge_t varIndex = Ddi_VarBaigId(v);
	  int vCnf = aig2CnfId(bmgr,varIndex);
	  int vS = vCnf - 1;

	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteral(v,1);
	  if (S.model[vS]!=l_True) {
	    Ddi_BddNotAcc(lit);
	  }
	  Ddi_BddAndAcc(cex,lit);
	  Ddi_Free(lit);
	  nsm++;
	}
      }
    }
    else {
      Ddi_BddConstrainAcc(from_i,cubeConstrain);
      Ddi_BddConstrainAcc(TR_i,cubeConstrain);
    }
    Ddi_BddConstrainAcc(from_i,cex);
    Ddi_BddConstrainAcc(TR_i,cex);
    Ddi_BddDiffAcc(cubeConstrain,cex);
    Ddi_Free(cex);

    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm), "\nPart[%d] - %d/%d vars constrained.\n",
	      i, nsm, nv);fflush(dMgrO(ddm))
    );
    myConstrain = Ddi_BddNot(to);
    to_i = Ddi_ImgConjPartTr (TR_i,from_i,myConstrain,smoothV);
    Ddi_Free(myConstrain);

    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMed_c,
      fprintf(dMgrO(ddm), "|To[%d]|=%d.\n", i, Ddi_BddSize(to_i))
    );

    if (Ddi_BddIsMeta(from)) {
      Ddi_BddOrAcc (to, to_i);
    }
    else {
      Ddi_BddSetMono(to_i);
      Ddi_BddPartInsertLast (to, to_i);
    }

    Ddi_BddSetAig(to_i);
    Ddi_BddNotAcc(to_i);
    MinisatClauses(S,to_i,NULL,NULL,0);

    Ddi_Free (to_i);

    if (nv*satPartSmoothRatio > 4)
      satPartSmoothRatio *= satPartSmoothReduce;

  }

  aig2CnfIdClose(ddm);

  /* Swap present state variables (PS) next state variables (NS) */
  if (Ddi_BddIsPartConj(to)) {
    Ddi_BddSwapVarsAcc(to,nsv,psv);
  }
  else {
    Ddi_BddSubstVarsAcc(to,nsv,psv);
  }
  Ddi_BddSetMono(to);

  Ddi_Free(cubeConstrain);
  Ddi_Free(vA);
  Ddi_Free(trAig);
  Ddi_Free(fromAig);
  Ddi_Free(constrainAig);
  return (to);
}




/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static aigCnfInfo_t *
genAigCnfInfo(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes,
  Ddi_Bddarray_t *roots,
  Ddi_Vararray_t *flowV,
  Ddi_AigAbcInfo_t *aigAbcInfo,
  int useCnfActive,
  int makeRel
)
{
  Ddi_Mgr_t *ddm = (Ddi_Mgr_t *)bmgr->owner;
  aigCnfInfo_t *aigCnfInfo = Pdtutil_Alloc(aigCnfInfo_t,visitedNodes->num);
  int j, last;

  last = visitedNodes->num-1;
  for (j=0; j<visitedNodes->num; j++) {
    bAigEdge_t baig = visitedNodes->nodes[j];
    bAig_AuxInt(bmgr,baig) = j;
    aigCnfInfo[j].foCnt=0;
    aigCnfInfo[j].ref0=0;
    aigCnfInfo[j].ref1=0;
    aigCnfInfo[j].isRoot=1;
    aigCnfInfo[j].level=0;
    aigCnfInfo[j].actVar=-1;
    aigCnfInfo[j].isVarFlow=0;
    aigCnfInfo[j].isCutFrontier=0;
    aigCnfInfo[j].isCnfActive=0;
    aigCnfInfo[j].implied=0;
    aigCnfInfo[j].ldr=j;
    aigCnfInfo[j].ca = new (vec<vec<Lit> >);
    if (useCnfActive) {
      int cnf = aig2CnfIdRead(bmgr,baig);
      if (cnf>0 && cnfReadActive(ddm,cnf)) {
        aigCnfInfo[j].isCnfActive = 1;
      }
    }
    if (!aigCnfInfo[j].isCnfActive &&
        !bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
      int ir, il, level = 0;
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);
      aigCnfInfo[ir].foCnt++;
      aigCnfInfo[il].foCnt++;
      if (aigCnfInfo[ir].level>=level) level = aigCnfInfo[ir].level+1;
      if (aigCnfInfo[il].level>=level) level = aigCnfInfo[il].level+1;
      aigCnfInfo[j].level = level;
    }
  }
  if (flowV!=NULL) {
    for (j=0; j<Ddi_VararrayNum(flowV); j++) {
      Ddi_Var_t *v_j = Ddi_VararrayRead(flowV,j);
      bAigEdge_t fBaig = Ddi_VarToBaig(v_j);
      int i = bAig_AuxInt(bmgr,fBaig);
      if (bAig_NodeIsConstant(fBaig)) continue;
      if (i<0) continue;
      Pdtutil_Assert(i>=0&&i<visitedNodes->num,"wrong array index");
      aigCnfInfo[i].isVarFlow=1;
    }
  }
  if (roots!=NULL) {
    for (j=0; j<Ddi_BddarrayNum(roots); j++) {
      Ddi_Bdd_t *f_j = Ddi_BddarrayRead(roots,j);
      bAigEdge_t fBaig = Ddi_BddToBaig(f_j);
      int i = bAig_AuxInt(bmgr,fBaig);
      if (bAig_NodeIsConstant(fBaig)) continue;
      Pdtutil_Assert(i>=0&&i<visitedNodes->num,"wrong array index");
      aigCnfInfo[i].isRoot=2;
      if (!makeRel) {
	aigCnfInfo[i].ref0 = Ddi_BddIsComplement(f_j);
	aigCnfInfo[i].ref1 = !aigCnfInfo[i].ref0;
      }
    }
  }

  Pdtutil_Assert(aigCnfInfo[last].foCnt==0,"wrong fanout cnt");

  if (!makeRel) {
    for (j=visitedNodes->num-1; j>=0; j--) {
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (!aigCnfInfo[j].isCnfActive &&
          !bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
	int ir, il, funcBlkFound;
	bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
	bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
	int ref0, ref1;

	Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

	ir = bAig_AuxInt(bmgr,right);
	il = bAig_AuxInt(bmgr,left);

	if (!bAig_isVarNode(bmgr,right) && !bAig_NodeIsConstant(right)) {
	  if (bAig_NodeIsInverted(right)) {
	    if (aigCnfInfo[j].ref1>0) aigCnfInfo[ir].ref0++;
	    if (aigCnfInfo[j].ref0>0) aigCnfInfo[ir].ref1++;
	  }
	  else {
	    if (aigCnfInfo[j].ref0>0) aigCnfInfo[ir].ref0++;
	    if (aigCnfInfo[j].ref1>0) aigCnfInfo[ir].ref1++;
	  }
	}
	if (!bAig_isVarNode(bmgr,left) && !bAig_NodeIsConstant(left)) {
	  if (bAig_NodeIsInverted(left)) {
	    if (aigCnfInfo[j].ref1>0) aigCnfInfo[il].ref0++;
	    if (aigCnfInfo[j].ref0>0) aigCnfInfo[il].ref1++;
	  }
	  else {
	    if (aigCnfInfo[j].ref0>0) aigCnfInfo[il].ref0++;
	    if (aigCnfInfo[j].ref1>0) aigCnfInfo[il].ref1++;
	  }
	}
      }
    }
  }

  for (j=0; j<visitedNodes->num; j++) {
    bAigEdge_t baig = visitedNodes->nodes[j];
    if (!aigCnfInfo[j].isCnfActive &&
        !bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
      int ir, il, funcBlkFound;
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);
      aigCnfInfo[j].isVarFlow = aigCnfInfo[il].isVarFlow ||
	aigCnfInfo[ir].isVarFlow;

      funcBlkFound = aigAbcInfo==NULL &&
	findIteOrXor(bmgr,visitedNodes,aigCnfInfo,baig,right,left,j,ir,il);
      if (!funcBlkFound) {
	if (!bAig_isVarNode(bmgr,right) && !bAig_NodeIsConstant(right)) {
	  if (aigCnfInfo[ir].foCnt==1 && !bAig_NodeIsInverted(right)) {
	    if (aigCnfInfo[ir].isRoot==1) aigCnfInfo[ir].isRoot=0;
	  }
	}
	if (!bAig_isVarNode(bmgr,left) && !bAig_NodeIsConstant(left)) {
	  if (aigCnfInfo[il].foCnt==1 && !bAig_NodeIsInverted(left)) {
	    if (aigCnfInfo[il].isRoot==1) aigCnfInfo[il].isRoot=0;
	  }
	}
      }
    }
  }
  Pdtutil_Assert(aigCnfInfo[last].isRoot,"wrong root info");

  for (j=visitedNodes->num-1; j>=0; j--) {
    bAigEdge_t baig = visitedNodes->nodes[j];
    if (!aigCnfInfo[j].isCnfActive &&
        !bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
      Ddi_Clause_t *cl=NULL;
      int ir, il, ldr;
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      ir = bAig_AuxInt(bmgr,right);
      il = bAig_AuxInt(bmgr,left);

      if (aigCnfInfo[j].isRoot>2) continue; /* skip xor/ITE */

      if (aigCnfInfo[j].isRoot) {
	int f = DdiAig2CnfId(bmgr,baig);
        vec<Lit> lits;
	Pdtutil_Assert(aigCnfInfo[j].ldr == j,"wrong leader");
	aigCnfInfo[j].ca->push();
	aigCnfInfo[j].ca->last().clear();
	aigCnfInfo[j].ca->last().push(MinisatLit(f));
      }
      if (!aigCnfInfo[ir].isRoot) {
	Pdtutil_Assert (aigCnfInfo[ir].foCnt==1,"wrong root info");
	ldr = aigCnfInfo[ir].ldr = aigCnfInfo[j].ldr;
      }
      if (!aigCnfInfo[il].isRoot) {
	Pdtutil_Assert (aigCnfInfo[il].foCnt==1,"wrong root info");
	ldr = aigCnfInfo[il].ldr = aigCnfInfo[j].ldr;
      }
    }
  }

  return aigCnfInfo;
}


/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_MinisatAigCnfMgr_t *
DdiMinisatAigCnfMgrAlloc(
  Ddi_Mgr_t *ddm,
  int nNodes
)
{
  return aigCnfMgrAlloc(ddm,nNodes);
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
DdiMinisatAigCnfMgrFree(
  Ddi_MinisatAigCnfMgr_t *aigCnfMgr
)
{
  aigCnfMgrFree(aigCnfMgr);
}


/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static aigCnfMgr_t *
aigCnfMgrAlloc(
  Ddi_Mgr_t *ddm,
  int nNodes
)
{
  aigCnfMgr_t *aigCnfMgr = Pdtutil_Alloc(aigCnfMgr_t,1);
  aigCnfMgr->ddiMgr = ddm;
  aigCnfMgr->aigCnfInfo = NULL;
  aigCnfMgr->aigAbcInfo=NULL;
  aigCnfMgr->visitedNodes = NULL;
  aigCnfMgr->cutFrontier = Pdtutil_Alloc(int,nNodes);
  aigCnfMgr->nNodes = 0;
  aigCnfMgr->nRef = 0;
  aigCnfMgr->aigCnfLevel = 0;
  aigCnfMgr->phFilter = 0;
  return aigCnfMgr;
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
aigCnfMgrFree(
  aigCnfMgr_t *aigCnfMgr
)
{
  if (aigCnfMgr->aigAbcInfo != NULL)
    Ddi_AigAbcInfoFree (aigCnfMgr->aigAbcInfo);

  if (aigCnfMgr->aigCnfInfo != NULL) {
    int j;
    for (j=0; j<aigCnfMgr->nNodes; j++) {
      if (aigCnfMgr->aigCnfInfo[j].ca != NULL) {
        delete aigCnfMgr->aigCnfInfo[j].ca;
      }
    }
    Pdtutil_Free(aigCnfMgr->aigCnfInfo);
  }
  if (aigCnfMgr->visitedNodes != NULL) {
    bAigArrayFree(aigCnfMgr->visitedNodes);
  }
  if (aigCnfMgr->cutFrontier != NULL) Pdtutil_Free(aigCnfMgr->cutFrontier);

  Pdtutil_Free(aigCnfMgr);

}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static nnfCoreMgr_t *
nnfCoreMgrNew(
  Ddi_Bdd_t *fNnf,
  Ddi_Vararray_t *rV,
  Ddi_Vararray_t *aV0,
  Ddi_Vararray_t *aV1,
  Ddi_Bdd_t *nnfConstr,
  int storeGateType,
  int leftFirstOrLevelize
)
{
  nnfCoreMgr_t *nnfCoreMgr = Pdtutil_Alloc(nnfCoreMgr_t,1);
  nnfCoreMgr->randRefinePeriod = 0;
  nnfCoreMgr->aNodes = NULL;
  nnfCoreMgr->isCore = NULL;
  nnfCoreMgr->gateType = NULL;

  if (fNnf != NULL) {
    int i;
    Ddi_Mgr_t *ddm = Ddi_ReadMgr(fNnf);
    bAig_Manager_t *bmgr = ddm->aig.mgr;
    nnfCoreMgr->aNodes = bAigArrayAlloc();
    if (leftFirstOrLevelize==1) {
      postOrderBddAigVisitInternReversed(fNnf,nnfCoreMgr->aNodes,0,-1);
    }
    else {
      Ddi_PostOrderBddAigVisitIntern(fNnf,nnfCoreMgr->aNodes,-1);
    }
    Ddi_PostOrderAigClearVisitedIntern(ddm->aig.mgr,nnfCoreMgr->aNodes);
    if (leftFirstOrLevelize>1) {
      bAigArraySortByLevel(ddm,nnfCoreMgr->aNodes,bAig_NULL,-1);
    }
    nnfCoreMgr->isCore = Pdtutil_Alloc(char,nnfCoreMgr->aNodes->num);
    for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
      nnfCoreMgr->isCore[i] = (char)0;
    }
    if (storeGateType) {
      bAigEdge_t baig;
      int n = nnfCoreMgr->aNodes->num;
      nnfCoreMgr->gateType = Pdtutil_Alloc(char,n);

      bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
      bAigArrayAuxIntSetId(bmgr,nnfCoreMgr->aNodes);

      nnfCoreMgr->gateType[n-1] = Ddi_BddIsComplement(fNnf) ? 'O': 'A';
      baig = nnfCoreMgr->aNodes->nodes[n-1];
      //Pdtutil_Assert (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig),
      //		      "const or var baig");

      for (i=n-1; i>=0; i--) {
	baig = nnfCoreMgr->aNodes->nodes[i];
	if (bAig_NodeIsConstant(baig) || bAig_isVarNode(bmgr,baig)) {
	  nnfCoreMgr->gateType[i] = 'I';
	  continue;
	}
	bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
	bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
	int ir = bAig_AuxInt(bmgr,right);
	int il = bAig_AuxInt(bmgr,left);
	Pdtutil_Assert(ir>=0 && il>=0,"Invalid aux int");
	if (nnfCoreMgr->gateType[i] == 'O') {
	  nnfCoreMgr->gateType[ir] = bAig_NodeIsInverted(right) ? 'A': 'O';
	  nnfCoreMgr->gateType[il] = bAig_NodeIsInverted(left) ? 'A': 'O';
	}
	else {
	  nnfCoreMgr->gateType[ir] = bAig_NodeIsInverted(right) ? 'O': 'A';
	  nnfCoreMgr->gateType[il] = bAig_NodeIsInverted(left) ? 'O': 'A';
	}
      }
      bAigArrayAuxIntClear(bmgr,nnfCoreMgr->aNodes);
    }
  }

  nnfCoreMgr->rV = (rV==NULL) ? NULL : Ddi_VararrayDup(rV);
  nnfCoreMgr->aV0 = (aV0==NULL) ? NULL : Ddi_VararrayDup(aV0);
  nnfCoreMgr->aV1 = (aV1==NULL) ? NULL : Ddi_VararrayDup(aV1);
  nnfCoreMgr->nnfConstr = Ddi_BddDup(nnfConstr);
  return nnfCoreMgr;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
nnfCoreMgrFree(
  nnfCoreMgr_t *nnfCoreMgr
)
{
  if (nnfCoreMgr==NULL) return;
  bAigArrayFree(nnfCoreMgr->aNodes);
  Pdtutil_Free(nnfCoreMgr->isCore);
  Pdtutil_Free(nnfCoreMgr->gateType);
  Ddi_Free(nnfCoreMgr->rV);
  Ddi_Free(nnfCoreMgr->aV0);
  Ddi_Free(nnfCoreMgr->aV1);
  Ddi_Free(nnfCoreMgr->nnfConstr);

  Pdtutil_Free(nnfCoreMgr);
}

static int
aigCnfMgrGenActLits(
  aigCnfMgr_t *aigCnfMgr
)
{
  Ddi_Mgr_t *ddm = aigCnfMgr->ddiMgr;
  bAig_Manager_t *manager = ddm->aig.mgr;
  aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;
  bAig_array_t *visitedNodes = aigCnfMgr->visitedNodes;
  int aigCnfLevel = aigCnfMgr->aigCnfLevel;
  bAigEdge_t baig;
  int j, nAct = 0;

  Pdtutil_Assert(DdiAig2CnfIdIsOpen(ddm),"aig2cnfId is closed");
  
  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    if (bAig_isVarNode(manager,baig) || bAig_NodeIsConstant(baig))
      continue;
    //    if (aigCnfInfo[j].level > 1) continue;
    int act = aigCnfInfo[j].actVar = aig2CnfNewIdIntern(ddm);
    vec<vec<Lit> > *ca = aigCnfInfo[j].ca;
    for (int ii=0; ii<ca->size(); ii++) {
      if ((*ca)[ii].size()>0) {
        (*ca)[ii].push(MinisatLit(-act));
      }
    }
    nAct++;
  }
  return nAct;
}
 
/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
genAigCnfGenClauses(
  aigCnfMgr_t *aigCnfMgr
)
{
  Ddi_Mgr_t *ddm = aigCnfMgr->ddiMgr;
  bAig_Manager_t *manager = ddm->aig.mgr;
  aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;
  bAig_array_t *visitedNodes = aigCnfMgr->visitedNodes;
  int aigCnfLevel = aigCnfMgr->aigCnfLevel;
  int phFilter = aigCnfMgr->phFilter;
  bAigEdge_t baig;
  int j, merged = 0;

  for (j=0; j<visitedNodes->num; j++) {

    int f, a, b, ir, il;
    bAigEdge_t right, left, baig = visitedNodes->nodes[j];

    if (bAig_AuxRef(manager,baig) != 0) continue;

    if (bAig_isVarNode(manager,baig) || bAig_NodeIsConstant(baig)) continue;

    right = bAig_NodeReadIndexOfRightChild(manager,baig);
    left = bAig_NodeReadIndexOfLeftChild(manager,baig);

    Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

    ir = bAig_AuxInt(manager,right);
    il = bAig_AuxInt(manager,left);

    bAig_AuxRef(manager,baig) = 1;

    if (aigCnfLevel==0) {
      /* standard tseitin transformation */
      /* convert AIG node to cnf clauses */
      /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
      f = aig2CnfId(manager,baig);
      a = bAig_NodeIsInverted(right) ? -aig2CnfId(manager,right) :
        aig2CnfId(manager,right);
      b = bAig_NodeIsInverted(left) ? -aig2CnfId(manager,left) :
        aig2CnfId(manager,left);

      /* f !a !b */
      aigCnfInfo[j].ca->push();
      (*aigCnfInfo[j].ca)[0].push(MinisatLit(f));
      (*aigCnfInfo[j].ca)[0].push(MinisatLit(-a));
      (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
      /* !f a */
      aigCnfInfo[j].ca->push();
      (*aigCnfInfo[j].ca)[1].push(MinisatLit(-f));
      (*aigCnfInfo[j].ca)[1].push(MinisatLit(a));
      /* !f b */
      aigCnfInfo[j].ca->push();
      (*aigCnfInfo[j].ca)[2].push(MinisatLit(-f));
      (*aigCnfInfo[j].ca)[2].push(MinisatLit(b));
    }
    else {
      if (aigCnfInfo[j].isRoot == 3) {
        /* Xor */
        int iA = aigCnfInfo[j].opIds[0];
        int iB = aigCnfInfo[j].opIds[1];
        bAigEdge_t baigA = visitedNodes->nodes[abs(iA)-1];
        bAigEdge_t baigB = visitedNodes->nodes[abs(iB)-1];
        f = DdiAig2CnfId(manager,baig);
        a = (iA<0) ? -DdiAig2CnfId(manager,baigA) :
          DdiAig2CnfId(manager,baigA);
        b = (iB<0) ? -DdiAig2CnfId(manager,baigB) :
          DdiAig2CnfId(manager,baigB);
        Pdtutil_Assert(aigCnfInfo[j].ca->size()==0,"wrong clause array");
        /* !f !a !b */
        aigCnfInfo[j].ca->push();
        (*aigCnfInfo[j].ca)[0].push(MinisatLit(-f));
        (*aigCnfInfo[j].ca)[0].push(MinisatLit(-a));
        (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
        /* !f a b */
        aigCnfInfo[j].ca->push();
        (*aigCnfInfo[j].ca)[1].push(MinisatLit(-f));
        (*aigCnfInfo[j].ca)[1].push(MinisatLit(a));
        (*aigCnfInfo[j].ca)[1].push(MinisatLit(b));
        /* f a !b */
        aigCnfInfo[j].ca->push();
        (*aigCnfInfo[j].ca)[2].push(MinisatLit(f));
        (*aigCnfInfo[j].ca)[2].push(MinisatLit(a));
        (*aigCnfInfo[j].ca)[2].push(MinisatLit(-b));
        /* f !a b */
        aigCnfInfo[j].ca->push();
        (*aigCnfInfo[j].ca)[3].push(MinisatLit(f));
        (*aigCnfInfo[j].ca)[3].push(MinisatLit(-a));
        (*aigCnfInfo[j].ca)[3].push(MinisatLit(b));
      }
      else if (aigCnfInfo[j].isRoot == 4) {
        /* ITE */
        int s;
        int iS = aigCnfInfo[j].opIds[0];
        int iA = aigCnfInfo[j].opIds[1];
        int iB = aigCnfInfo[j].opIds[2];
        bAigEdge_t baigS = visitedNodes->nodes[abs(iS)-1];
        bAigEdge_t baigA = visitedNodes->nodes[abs(iA)-1];
        bAigEdge_t baigB = visitedNodes->nodes[abs(iB)-1];
        f = DdiAig2CnfId(manager,baig);
        s = (iS<0) ? -DdiAig2CnfId(manager,baigS) :
          DdiAig2CnfId(manager,baigS);
        a = (iA<0) ? -DdiAig2CnfId(manager,baigA) :
          DdiAig2CnfId(manager,baigA);
        b = (iB<0) ? -DdiAig2CnfId(manager,baigB) :
          DdiAig2CnfId(manager,baigB);
        Pdtutil_Assert(aigCnfInfo[j].ca->size()==0,"wrong clause array");
        /* s f !b */
        aigCnfInfo[j].ca->push();
        (*aigCnfInfo[j].ca)[0].push(MinisatLit(s));
        (*aigCnfInfo[j].ca)[0].push(MinisatLit(f));
        (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
        /* s !f b */
        aigCnfInfo[j].ca->push();
        (*aigCnfInfo[j].ca)[1].push(MinisatLit(s));
        (*aigCnfInfo[j].ca)[1].push(MinisatLit(-f));
        (*aigCnfInfo[j].ca)[1].push(MinisatLit(b));
        /* !s f !a */
        aigCnfInfo[j].ca->push();
        (*aigCnfInfo[j].ca)[2].push(MinisatLit(-s));
        (*aigCnfInfo[j].ca)[2].push(MinisatLit(f));
        (*aigCnfInfo[j].ca)[2].push(MinisatLit(-a));
        /* !s !f a */
        aigCnfInfo[j].ca->push();
        (*aigCnfInfo[j].ca)[3].push(MinisatLit(-s));
        (*aigCnfInfo[j].ca)[3].push(MinisatLit(-f));
        (*aigCnfInfo[j].ca)[3].push(MinisatLit(a));
      }
      else if (aigCnfInfo[ir].isRoot || aigCnfInfo[il].isRoot) {
        /* cut gate, i.e. not an internal one */
        int ldr = aigCnfInfo[j].ldr;
        if (aigCnfInfo[ldr].isRoot < 3) {
          bAigEdge_t baigLdr = visitedNodes->nodes[ldr];
          Pdtutil_Assert(aigCnfInfo[ldr].isRoot,"wrong leader");
          f = DdiAig2CnfId(manager,baigLdr);
          if (aigCnfInfo[ir].isRoot) {
            int last = aigCnfInfo[ldr].ca->size();
            Pdtutil_Assert(last>0,"missing clause array");
            a = bAig_NodeIsInverted(right) ? -DdiAig2CnfId(manager,right) :
              DdiAig2CnfId(manager,right);
            if (phFilter && (aigCnfInfo[ir].isRoot<3)) {
              if (aigCnfInfo[ir].ref0==1 && aigCnfInfo[ir].ref1==0) {
                merged ++;
              }
            }
            /* -f a */
            aigCnfInfo[ldr].ca->push();
            (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(-f));
            (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(a));
            /* f -a ... */
            Pdtutil_Assert(ldr>=ir,"wrong leader");
            (*aigCnfInfo[ldr].ca)[0].push(MinisatLit(-a));
          }
          if (aigCnfInfo[il].isRoot) {
            int last = aigCnfInfo[ldr].ca->size();
            Pdtutil_Assert(last>0,"missing clause array");
            b = bAig_NodeIsInverted(left) ? -DdiAig2CnfId(manager,left) :
              DdiAig2CnfId(manager,left);
            if (phFilter && (aigCnfInfo[il].isRoot<3)) {
              if (aigCnfInfo[il].ref0==1 && aigCnfInfo[il].ref1==0) {
                merged ++;
              }
            }
            /* -f b */
            aigCnfInfo[ldr].ca->push();
            (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(-f));
            (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(b));
            /* f -b ... */
            Pdtutil_Assert(ldr>=ir,"wrong leader");
            (*aigCnfInfo[ldr].ca)[0].push(MinisatLit(-b));
          }
        }
      }

    }
  }

  return merged;
}


/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
genAigCnfSolverFrontierVars(
  aigCnfMgr_t *aigCnfMgr,
  int j,
  bAig_array_t *refinementFrontier
)
{
  Ddi_Mgr_t *ddm = aigCnfMgr->ddiMgr;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;
  int phFilter = aigCnfMgr->phFilter;
  int en0 = 0, en1 = 0;
  int jj, k, nRef=0;

  Pdtutil_Assert (aigCnfInfo[j].isRoot && aigCnfInfo[j].ca->size() > 0,
                  "wrong frontier gate");

  if (!phFilter || aigCnfInfo[j].isRoot>2 || aigCnfInfo[j].ref0>0) {
    en0=1;
  }
  if (!phFilter || aigCnfInfo[j].isRoot>2 || aigCnfInfo[j].ref1>0) {
    en1=1;
  }

  for (k=0; k<aigCnfInfo[j].ca->size(); k++) {
    if ((*aigCnfInfo[j].ca)[k].size()==0) continue;
    if (k==0 && !en0) continue;
    if (k>0 && !en1) break;

    for (jj=0; jj<(*aigCnfInfo[j].ca)[k].size(); jj++) {
      int vSat = var(((*aigCnfInfo[j].ca)[k])[jj]);
      int vCnf = vSat+1;
      bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
      int id = bAig_AuxInt(bmgr,baig);
      Pdtutil_Assert(id>=0&&id<aigCnfMgr->visitedNodes->num,
                         "missing aux int");
      int isCut = aigCnfInfo[id].isCutFrontier;
      if (isCut < 2/* not in core vSat */) {
        if (isCut == 0/* not in refinement frontier vSat */) {
          if (!bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
            /* add to refinement frontier */
            aigCnfInfo[id].isCutFrontier = 1;
            bAigArrayPush(refinementFrontier,baig);
	    nRef++;
          }
        }
      }
    }
  }
  return nRef;
}


/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
genAigCnfFileClauses(
  aigCnfMgr_t *aigCnfMgr,
  FILE *fp,
  int j,
  int *clauseNp
)
{
  aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;
  int phFilter = aigCnfMgr->phFilter;

  if (aigCnfInfo[j].isRoot && aigCnfInfo[j].ca->size() > 0) {
    if (!phFilter || aigCnfInfo[j].isRoot>2 || aigCnfInfo[j].ref0>0) {
      FileStoreClause(fp,(*aigCnfInfo[j].ca)[0]);
      (*clauseNp)++;
    }
    if (!phFilter || aigCnfInfo[j].isRoot>2 || aigCnfInfo[j].ref1>0) {
      int k;
      for (k=1; k<aigCnfInfo[j].ca->size(); k++) {
        if ((*aigCnfInfo[j].ca)[k].size()==0) continue;
        //Pdtutil_Assert((*aigCnfInfo[j].ca)[k].size()>=2,
        //               "wrong n. lits");
        FileStoreClause(fp,(*aigCnfInfo[j].ca)[k]);
        //      	    aigCnfInfo[j].ca)[k].clear(true);
	(*clauseNp)++;
      }
    }
  }
}


/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
genAigCnfFlowRefine(
  aigCnfMgr_t *aigCnfMgr,
  Solver *S,
  Solver *S1
)
{
  int refinementOK=0;
  Ddi_Mgr_t *ddm = aigCnfMgr->ddiMgr;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;
  bAig_array_t *visitedNodes = aigCnfMgr->visitedNodes;
  int *cutFrontier = aigCnfMgr->cutFrontier;
  int j, sat;

  vec<Lit> cexClause, cexCube;

  cexClause.clear();

  for (j=0; j<visitedNodes->num; j++) {
    bAigEdge_t baig = visitedNodes->nodes[j];
    if (aigCnfInfo[j].isCutFrontier ||
        (bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig))) {
      int fCnf = aig2CnfId(bmgr,baig);
      if (abs(fCnf)>S1->nVars()) {
        Pdtutil_Assert(!aigCnfInfo[j].isCutFrontier,"non shared var needed");
      }
      else {
        if (S->model[abs(fCnf)-1]==l_False) {
          fCnf = -fCnf;
        }
        cexCube.push(MinisatLit(fCnf));
      }
    }
  }

  sat = S1->solve(cexCube,-1);
  cexCube.clear();
  cexClause.clear();
  if (!sat) {
    for (j=0; j<S1->conflict.size(); j++) {
      Ddi_Bdd_t *lit;
      Lit kLit = S1->conflict[j];
      int fSat = var(kLit);
      int signSat = sign(kLit);
      int fCnf = fSat+1;
      bAigEdge_t baig = ddm->cnf.cnf2aig[fCnf];
      int jj = bAig_AuxInt(bmgr,baig);
      cexClause.push(MinisatLit(-fCnf));
      cexCube.push(MinisatLit(fCnf));
    }
    /* generalization */
    if (1)
    for (j=cexCube.size()-1; j>=0; j--) {
      vec<Lit> auxCube;
      cexCube.copyTo(auxCube);
      auxCube.remove(j);
      if (!S1->solve(auxCube,-1)) {
        cexCube.remove(j);
        cexClause.remove(j);
      }
    }
    for (j=cexCube.size()-1; j>=0; j--) {
      Ddi_Bdd_t *lit;
      Lit kLit = cexCube[j];
      int fSat = var(kLit);
      int fCnf = fSat+1;
      bAigEdge_t baig = ddm->cnf.cnf2aig[fCnf];
      int jj = bAig_AuxInt(bmgr,baig);
      if (bAig_isVarNode(bmgr,baig)) continue;
      Pdtutil_Assert(jj>=0&&jj<visitedNodes->num,"error in solver final");
      Pdtutil_Assert(!aigCnfInfo[jj].isVarFlow,"out of flow gate expected");
      //      aigCnfInfo[jj].isVarFlow = 1;
      aigCnfInfo[jj].isCutFrontier = -1;
      // genAigCnfSolverClauses(aigCnfMgr,S,NULL,jj);
    }
    //    S->addClause(cexClause);
    aigCnfMgr->nRef++;
  }
  else {
    refinementOK = 1;
  }

  genAigCnfFlowFrontier(aigCnfMgr,S,0);

  return (refinementOK);
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
genAigCnfFlowFrontier(
  aigCnfMgr_t *aigCnfMgr,
  Solver *S,
  int mode
)
{
  Ddi_Mgr_t *ddm = aigCnfMgr->ddiMgr;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;
  bAig_array_t *visitedNodes = aigCnfMgr->visitedNodes;
  int j, *cutFrontier = aigCnfMgr->cutFrontier;

  aigCnfMgr->cutFrontierNum=0;
  aigCnfMgr->nFlow=0;
  aigCnfMgr->nNoFlow=0;

  if (mode == 1) {
    for (j=visitedNodes->num-1; j>=0; j--) {
      int ldr;
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (!bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
        if ((ldr = aigCnfInfo[j].ldr) != j) {
          if (!aigCnfInfo[j].isVarFlow) {
            aigCnfInfo[j].isVarFlow = aigCnfInfo[ldr].isVarFlow;
          }
        }
      }
    }
    for (j=visitedNodes->num-1; j>=0; j--) {
      int ldr;
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (!bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
        if (aigCnfInfo[j].isVarFlow) {
          /* this is a gat with flow: check fanins with no flow */
          int ir, il;
          bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
          bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

          Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

          ir = bAig_AuxInt(bmgr,right);
          il = bAig_AuxInt(bmgr,left);
          if (!aigCnfInfo[ir].isVarFlow) {
            if (!bAig_isVarNode(bmgr,right) && !bAig_NodeIsConstant(right)) {
              aigCnfInfo[ir].isCutFrontier = 1;
            }
          }
          if (!aigCnfInfo[il].isVarFlow) {
            if (!bAig_isVarNode(bmgr,left) && !bAig_NodeIsConstant(left)) {
              aigCnfInfo[il].isCutFrontier = 1;
            }
          }
        }
        if (aigCnfInfo[j].isCutFrontier) {
          cutFrontier[aigCnfMgr->cutFrontierNum++] = j;

        }
        if (aigCnfInfo[j].isVarFlow) {
          aigCnfMgr->nFlow++;
        }
        else {
          aigCnfMgr->nNoFlow++;
        }
      }
    }
  }
  else {
    Pdtutil_Assert(S!=NULL,"missing solver");
    for (j=visitedNodes->num-1; j>=0; j--) {
      int ldr;
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (bAig_isVarNode(bmgr,baig) || bAig_NodeIsConstant(baig)) continue;
      if (aigCnfInfo[j].isCutFrontier == -1) {
        /* this is a gat with flow: check fanins with no flow */
        int ir, il;
        bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
        bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

        Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

        aigCnfInfo[j].isCutFrontier = 0;
        aigCnfInfo[j].isVarFlow = 1;
        genAigCnfSolverClauses(aigCnfMgr,S,NULL,NULL,j);

        ir = bAig_AuxInt(bmgr,right);
        il = bAig_AuxInt(bmgr,left);
        if (!aigCnfInfo[ir].isVarFlow) {
          if (!bAig_isVarNode(bmgr,right) && !bAig_NodeIsConstant(right)) {
            aigCnfInfo[ir].isCutFrontier = -1;
          }
        }
        if (!aigCnfInfo[il].isVarFlow) {
          if (!bAig_isVarNode(bmgr,left) && !bAig_NodeIsConstant(left)) {
            aigCnfInfo[il].isCutFrontier = -1;
          }
        }
      }
      if (aigCnfInfo[j].isCutFrontier) {
        cutFrontier[aigCnfMgr->cutFrontierNum++] = j;
      }
      if (aigCnfInfo[j].isVarFlow) {
        aigCnfMgr->nFlow++;
      }
      else {
        aigCnfMgr->nNoFlow++;
      }
    }

    for (j=visitedNodes->num-1; j>=0; j--) {
      int ldr;
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (!bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
        if ((ldr = aigCnfInfo[j].ldr) != j) {
          if (!aigCnfInfo[j].isVarFlow) {
            aigCnfInfo[j].isVarFlow = aigCnfInfo[ldr].isVarFlow;
          }
        }
      }
    }
  }
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
genAigCnfPropImplications(
  aigCnfMgr_t *aigCnfMgr
)
{
  Ddi_Mgr_t *ddm = aigCnfMgr->ddiMgr;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;
  bAig_array_t *visitedNodes = aigCnfMgr->visitedNodes;
  int j, totImpl=0, loopImpl;

  if (aigCnfMgr->aigAbcInfo!=NULL) return 1;

  do {
    loopImpl=0;
    for (j=visitedNodes->num-1; j>=0; j--) {
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (!bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
        if (aigCnfInfo[j].implied > 0) {
          /* this is an AND node implied at 1: imply fanin gates */
          int ir, il, implR, implL;
          bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
          bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

          Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

          ir = bAig_AuxInt(bmgr,right);
          il = bAig_AuxInt(bmgr,left);
          implR = bAig_NodeIsInverted(right) ? -1 : 1;
          implL = bAig_NodeIsInverted(left) ? -1 : 1;
          if (aigCnfInfo[ir].implied) {
            if (aigCnfInfo[ir].implied != implR) {
	      return 0;
	    }
          }
          if (aigCnfInfo[il].implied) {
            if (aigCnfInfo[il].implied != implL) {
	      return 0;
	    }
          }
          if (aigCnfInfo[ir].implied==0) {
            aigCnfInfo[ir].implied = implR;
            loopImpl++;
          }
          if (aigCnfInfo[il].implied==0) {
            aigCnfInfo[il].implied = implL;
            loopImpl++;
          }
        }
      }
    }
    if (0)
    for (j=0; j<visitedNodes->num; j++) {
      bAigEdge_t baig = visitedNodes->nodes[j];
      if (!bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
        int ir, il, implR, implL;
        bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
        bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

        Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

        ir = bAig_AuxInt(bmgr,right);
        il = bAig_AuxInt(bmgr,left);
        implR = aigCnfInfo[ir].implied;
        implL = aigCnfInfo[il].implied;
        if (implR && bAig_NodeIsInverted(right)) {
          implR = -implR;
        }
        if (implL && bAig_NodeIsInverted(left)) {
          implL = -implL;
        }
        if (implR < 0 || implL < 0) {
          /* 0 implication! */
          if (aigCnfInfo[j].implied > 0) return 0;
          if (aigCnfInfo[j].implied == 0) {
            aigCnfInfo[j].implied = -1;
            loopImpl++;
          }
        }
        else if (implR > 0 || implL > 0) {
          /* 1 implication! */
          if (aigCnfInfo[j].implied < 0) return 0;
          if (aigCnfInfo[j].implied == 0) {
            aigCnfInfo[j].implied = 1;
            loopImpl++;
          }
        }
      }

    }
    totImpl += loopImpl;

  } while (loopImpl>0);
  return 1;
}


/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigIsXorOrXnor(
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;

  if (Ddi_BddIsAig(f)) {
    bAigEdge_t baig = Ddi_BddToBaig(f);
    return baigIsXorOrXnor(bmgr,baig);
  }
  return 0;
}


/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
baigIsXorOrXnor(
  bAig_Manager_t *bmgr,
  bAigEdge_t baig
)
{

  bAigEdge_t right, left,  rr, rl, lr, ll, tmp;
  char isInvR, isInvL, isInvRr, isInvRl, isInvLr, isInvLl;
  int enIte = 1;

  if (bAig_isVarNode(bmgr,baig) || bAig_NodeIsConstant(baig)) {
    return 0;
  }
  right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
  left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

  if (bAig_isVarNode(bmgr,right) || bAig_NodeIsConstant(right)) return 0;
  if (bAig_isVarNode(bmgr,left) || bAig_NodeIsConstant(left)) return 0;
  if (!bAig_NodeIsInverted(right)) return 0;
  if (!bAig_NodeIsInverted(left)) return 0;

  rr=rl=lr=ll = bAig_NULL;
  isInvR = isInvL = isInvRr = isInvRl = isInvLr = isInvLl = 0;

  /* negation taken to account for OR = !AND(! ,! ) */
  rr = bAig_Not(bAig_NodeReadIndexOfRightChild(bmgr,right));
  rl = bAig_Not(bAig_NodeReadIndexOfLeftChild(bmgr,right));
  lr = bAig_Not(bAig_NodeReadIndexOfRightChild(bmgr,left));
  ll = bAig_Not(bAig_NodeReadIndexOfLeftChild(bmgr,left));

  if (bAig_NonInvertedEdge(rr) > bAig_NonInvertedEdge(rl)) {
    tmp = rr; rr = rl; rl = tmp;
  }
  if (bAig_NonInvertedEdge(lr) > bAig_NonInvertedEdge(ll)) {
    tmp = lr; lr = ll; ll = tmp;
  }

  isInvRr = bAig_NodeIsInverted(rr);
  isInvRl = bAig_NodeIsInverted(rl);
  isInvLr = bAig_NodeIsInverted(lr);
  isInvLl = bAig_NodeIsInverted(ll);

  if (rr == bAig_Not(lr) && rl == bAig_Not(ll)) {
    /* xnor (rr + rl) (!rr + !rl) */
    return 1;
  }
  else if (rr == lr && rl == ll) {
    /* xor (rr + !rl) (!rr + rl) */
    return 1;
  }

  return 0;
}


/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
baigSplitXorOrXnor(
  bAig_Manager_t *bmgr,
  bAigEdge_t baig,
  bAigEdge_t *baig0P,
  bAigEdge_t *baig1P,
  int doXor
)
{

  bAigEdge_t right, left,  rr, rl, lr, ll, tmp;
  char isInvR, isInvL, isInvRr, isInvRl, isInvLr, isInvLl;
  int enIte = 1;

  if (bAig_isVarNode(bmgr,baig) || bAig_NodeIsConstant(baig)) {
    return 0;
  }

  if (bAig_NodeIsInverted(baig)) doXor = !doXor;

  right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
  left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

  if (bAig_isVarNode(bmgr,right) || bAig_NodeIsConstant(right)) return 0;
  if (bAig_isVarNode(bmgr,left) || bAig_NodeIsConstant(left)) return 0;
  if (!bAig_NodeIsInverted(right)) return 0;
  if (!bAig_NodeIsInverted(left)) return 0;

  rr=rl=lr=ll = bAig_NULL;
  isInvR = isInvL = isInvRr = isInvRl = isInvLr = isInvLl = 0;

  /* negation taken to account for OR = !AND(! ,! ) */
  rr = bAig_Not(bAig_NodeReadIndexOfRightChild(bmgr,right));
  rl = bAig_Not(bAig_NodeReadIndexOfLeftChild(bmgr,right));
  lr = bAig_Not(bAig_NodeReadIndexOfRightChild(bmgr,left));
  ll = bAig_Not(bAig_NodeReadIndexOfLeftChild(bmgr,left));

  if (bAig_NonInvertedEdge(rr) > bAig_NonInvertedEdge(rl)) {
    tmp = rr; rr = rl; rl = tmp;
  }
  if (bAig_NonInvertedEdge(lr) > bAig_NonInvertedEdge(ll)) {
    tmp = lr; lr = ll; ll = tmp;
  }

  isInvRr = bAig_NodeIsInverted(rr);
  isInvRl = bAig_NodeIsInverted(rl);
  isInvLr = bAig_NodeIsInverted(lr);
  isInvLl = bAig_NodeIsInverted(ll);

  if (rr == bAig_Not(lr) && rl == bAig_Not(ll)) {
    /* xor (rr + rl) (!rr + !rl) */
    *baig0P = rr; *baig1P = doXor ? rl : ll;
    return 1;
  }
  else if (rr == lr && rl == ll) {
    Pdtutil_Assert(0,"wrong XOR decomp");
    /* xor (rr + !rl) (!rr + rl) */
    *baig0P = rr; *baig1P = doXor ? ll : rl;
    return 1;
  }

  return 0;
}


/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
findIteOrXor(
  bAig_Manager_t *bmgr,
  bAig_array_t *visitedNodes,
  aigCnfInfo_t *aigCnfInfo,
  bAigEdge_t baig,
  bAigEdge_t right,
  bAigEdge_t left,
  int i,
  int ir,
  int il
)
{

  bAigEdge_t rr, rl, lr, ll, tmp;
  int irr, irl, ilr, ill;
  char isInvR, isInvL, isInvRr, isInvRl, isInvLr, isInvLl;
  int enIte = 1;

  if (bAig_isVarNode(bmgr,baig) || bAig_NodeIsConstant(baig)) {
    Pdtutil_Assert(0,"var of const node in func check");
  }

  if (bAig_isVarNode(bmgr,right) || bAig_NodeIsConstant(right)) return 0;
  if (bAig_isVarNode(bmgr,left) || bAig_NodeIsConstant(left)) return 0;
  if (!bAig_NodeIsInverted(right)) return 0;
  if (!bAig_NodeIsInverted(left)) return 0;

  rr=rl=lr=ll = bAig_NULL;
  isInvR = isInvL = isInvRr = isInvRl = isInvLr = isInvLl = 0;

  /* negation taken to account for OR = !AND(! ,! ) */
  rr = bAig_Not(bAig_NodeReadIndexOfRightChild(bmgr,right));
  rl = bAig_Not(bAig_NodeReadIndexOfLeftChild(bmgr,right));
  lr = bAig_Not(bAig_NodeReadIndexOfRightChild(bmgr,left));
  ll = bAig_Not(bAig_NodeReadIndexOfLeftChild(bmgr,left));

  if (bAig_NonInvertedEdge(rr) > bAig_NonInvertedEdge(rl)) {
    tmp = rr; rr = rl; rl = tmp;
  }
  if (bAig_NonInvertedEdge(lr) > bAig_NonInvertedEdge(ll)) {
    tmp = lr; lr = ll; ll = tmp;
  }

  isInvRr = bAig_NodeIsInverted(rr);
  isInvRl = bAig_NodeIsInverted(rl);
  isInvLr = bAig_NodeIsInverted(lr);
  isInvLl = bAig_NodeIsInverted(ll);
  irr = bAig_AuxInt(bmgr,rr);
  irl = bAig_AuxInt(bmgr,rl);
  ilr = bAig_AuxInt(bmgr,lr);
  ill = bAig_AuxInt(bmgr,ll);
  if (aigCnfInfo[irr].isRoot==0 || aigCnfInfo[irl].isRoot==0 ||
      aigCnfInfo[ilr].isRoot==0 || aigCnfInfo[ill].isRoot==0 ) return 0;
  if (aigCnfInfo[irr].isRoot==2 || aigCnfInfo[irl].isRoot==2 ||
      aigCnfInfo[ilr].isRoot==2 || aigCnfInfo[ill].isRoot==2 ) return 0;

#if 1
  if (rr == bAig_Not(lr) && rl == bAig_Not(ll)) {
    /* xnor (rr + rl) (!rr + !rl) */
    aigCnfInfo[i].isRoot = 3;
    aigCnfInfo[i].opIds[0] = ((isInvRr)?-1:1)*(irr+1);
    aigCnfInfo[i].opIds[1] = ((isInvRl)?-1:1)*(irl+1);
    if (aigCnfInfo[irr].isRoot<=1) aigCnfInfo[irr].isRoot=2;
    if (aigCnfInfo[irl].isRoot<=1) aigCnfInfo[irl].isRoot=2;
  }
#endif
#if 1
    else
    if (rr == bAig_Not(lr)) {
    /*  ite(rr,rl,ll) */
    if (enIte) {
    aigCnfInfo[i].isRoot = 4;
    aigCnfInfo[i].opIds[0] = ((isInvRr)?-1:1)*(irr+1);
    aigCnfInfo[i].opIds[2] = ((isInvRl)?-1:1)*(irl+1);
    aigCnfInfo[i].opIds[1] = ((isInvLl)?-1:1)*(ill+1);
    if (aigCnfInfo[irr].isRoot<=1) aigCnfInfo[irr].isRoot=2;
    if (aigCnfInfo[irl].isRoot<=1) aigCnfInfo[irl].isRoot=2;
    if (aigCnfInfo[ill].isRoot<=1) aigCnfInfo[ill].isRoot=2;
    }
  }
  else if (rr == bAig_Not(ll)) {
    /*  ite(rr,rl,lr) */
    aigCnfInfo[i].isRoot = 4;
    aigCnfInfo[i].opIds[0] = ((isInvRr)?-1:1)*(irr+1);
    aigCnfInfo[i].opIds[2] = ((isInvRl)?-1:1)*(irl+1);
    aigCnfInfo[i].opIds[1] = ((isInvLr)?-1:1)*(ilr+1);
    if (aigCnfInfo[irr].isRoot<=1) aigCnfInfo[irr].isRoot=2;
    if (aigCnfInfo[irl].isRoot<=1) aigCnfInfo[irl].isRoot=2;
    if (aigCnfInfo[ilr].isRoot<=1) aigCnfInfo[ilr].isRoot=2;
  }
  else if (rl == bAig_Not(lr)) {
    /*  ite(rl,rr,ll) */
    aigCnfInfo[i].isRoot = 4;
    aigCnfInfo[i].opIds[0] = ((isInvRl)?-1:1)*(irl+1);
    aigCnfInfo[i].opIds[2] = ((isInvRr)?-1:1)*(irr+1);
    aigCnfInfo[i].opIds[1] = ((isInvLl)?-1:1)*(ill+1);
    if (aigCnfInfo[irl].isRoot<=1) aigCnfInfo[irl].isRoot=2;
    if (aigCnfInfo[irr].isRoot<=1) aigCnfInfo[irr].isRoot=2;
    if (aigCnfInfo[ill].isRoot<=1) aigCnfInfo[ill].isRoot=2;
  }
  else if (rl == bAig_Not(ll)) {
    /*  ite(rl,rr,lr) */
    aigCnfInfo[i].isRoot = 4;
    aigCnfInfo[i].opIds[0] = ((isInvRl)?-1:1)*(irl+1);
    aigCnfInfo[i].opIds[2] = ((isInvRr)?-1:1)*(irr+1);
    aigCnfInfo[i].opIds[1] = ((isInvLr)?-1:1)*(ilr+1);
    if (aigCnfInfo[irr].isRoot<=1) aigCnfInfo[irr].isRoot=2;
    if (aigCnfInfo[irl].isRoot<=1) aigCnfInfo[irl].isRoot=2;
    if (aigCnfInfo[ilr].isRoot<=1) aigCnfInfo[ilr].isRoot=2;
  }
#endif
  if (aigCnfInfo[i].isRoot > 2) {
    if (aigCnfInfo[ir].isRoot != 2 && aigCnfInfo[ir].foCnt==1) {
      aigCnfInfo[ir].isRoot = 0;
      aigCnfInfo[ir].ldr = i;
    }
    if (aigCnfInfo[il].isRoot != 2 && aigCnfInfo[il].foCnt==1) {
      aigCnfInfo[il].isRoot = 0;
      aigCnfInfo[il].ldr = i;
    }
    return 1;
  }

  return 0;
}


/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_DeltaFindEqSpecs(
  Ddi_Bddarray_t *delta,
  Ddi_Vararray_t *ps,
  Ddi_Var_t *pvarPs,
  Ddi_Var_t *cvarPs,
  Ddi_Bdd_t *partSpec,
  int *nPartP,
  int doConstr,
  int speculate
)
{
  Ddi_Mgr_t *ddiMgr = Ddi_ReadMgr(delta);
  bAig_Manager_t *bmgr = ddiMgr->aig.mgr;

  int i, j, size, iProp=-1, iConstr=-1, nstate = Ddi_VararrayNum(ps);
  Ddi_Bdd_t *deltaProp, *deltaPropRef, *deltaConstr=NULL, *saveProp=NULL;
  int doRetimeEq = 0;
  int sizeProp;
  int nLatchEq = 0;
  int nStructEq=0;
  int npart, np, np0=0, nNonEq=0;
  int neq=0;
  int *eqArray, *nonEq;
  Ddi_Bddarray_t *reprs=NULL, *equals=NULL, *miters=NULL;
  Ddi_Bdd_t *newEqProp=NULL, *newProp=Ddi_BddMakeConstAig(ddiMgr,1);

  Ddi_Varset_t *psv = Ddi_VarsetMakeFromArray(ps);
  Ddi_Bdd_t *pinv;
  int chk = 0;

  bAig_array_t *visitedNodes = bAigArrayAlloc();
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddiMgr,1);

  for (i=0; i<nstate; i++) {
    Ddi_Var_t *v_i = Ddi_VararrayRead(ps,i);
    if (v_i == pvarPs) {
      iProp = i;
    }
    else if (v_i == cvarPs) {
      iConstr = i;
    }
  }

  Pdtutil_Assert(iProp>=0 && iProp<nstate,
                 "PDT_BDD_INVARSPEC_VAR$PS var not found");
  deltaPropRef = Ddi_BddDup(Ddi_BddarrayRead(delta,iProp));
  deltaConstr = Ddi_BddarrayRead(delta,iConstr);
  deltaProp = Ddi_BddCofactor(Ddi_BddarrayRead(delta,iProp),pvarPs,1);
  Ddi_BddSetAig(deltaProp);
  if (iConstr>=0) {
    Ddi_BddCofactorAcc(deltaProp,cvarPs,1);
  }
  sizeProp = Ddi_BddSize(deltaProp);

  if (speculate) {
    Ddi_BddarrayWrite(delta,iProp,myOne);
  }
  Ddi_Free(myOne);

  for (i=0; i<nstate; i++) {
    Ddi_Bdd_t *d_i = Ddi_BddarrayRead(delta,i);
    //    Ddi_Var_t *v_i = Ddi_VararrayRead(ps,i);
    bAigEdge_t baig = Ddi_BddToBaig(d_i);
    postOrderAigVisitIntern(bmgr,baig,visitedNodes,-1);
    //    baig = Ddi_VarToBaig(v_i);
    //    postOrderAigVisitIntern(bmgr,baig,visitedNodes,-1);
  }
  postOrderAigVisitIntern(bmgr,Ddi_BddToBaig(deltaProp),visitedNodes,-1);
  aigArrayClearVisitedIntern(bmgr,visitedNodes);

  bAigArraySortByLevel(ddiMgr, visitedNodes, bAig_NULL, -1);

  eqArray = Pdtutil_Alloc(int,visitedNodes->num);
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    Pdtutil_Assert(bAig_AuxInt(bmgr,baig)<0,"invalid aux int");
    bAig_AuxInt(bmgr,baig) = i;
    eqArray[i] = i+1;
  }

  if (partSpec!=NULL && Ddi_BddIsPartConj(partSpec)) {
    Pdtutil_Assert(Ddi_BddIsPartConj(partSpec),"conj part needed");
    pinv = Ddi_BddDup(partSpec);
    if (doConstr>0) {
      saveProp = Ddi_BddMakeConstAig(ddiMgr,1);
      for (i=0; i<doConstr; i++) {
	Ddi_Bdd_t *d_0 = Ddi_BddPartExtract(pinv,0);
	Ddi_BddAndAcc(saveProp,d_0);
	Ddi_Free(d_0);
      }
    }
  }
  else {
    pinv = Ddi_AigPartitionTop(deltaProp,0);
  }
  npart=Ddi_BddPartNum(pinv);

  nonEq = Pdtutil_Alloc(int,npart);
  for (i=0; i<npart; i++) {
    nonEq[i] = 1;
  }

  if (sizeProp > 1 && pinv != NULL && npart>1) {

    for (i=npart-1; 1 && i>=0; i--) {
      int j, l;
      Ddi_Bdd_t *p_i = Ddi_BddPartRead(pinv,i);
      Ddi_Varset_t *si = NULL;
      int nsupp = 0;

      if (nonEq[i] && !Ddi_BddIsComplement(p_i)) {
        if (checkEqGate(ddiMgr,psv,Ddi_BddToBaig(p_i),
            bAig_NULL,bAig_NULL,visitedNodes,eqArray,NULL,NULL,0)) {
          neq++;
          nonEq[i] = 0;
          break; /* disable further checks */
        }
      }

      si = Ddi_BddSupp(p_i);
      nsupp = Ddi_VarsetNum(si);

      for (j=i-1; j>=0; j--) {
        Ddi_Bdd_t *p_j = Ddi_BddPartRead(pinv,j);
        Ddi_Varset_t *sj = Ddi_BddSupp(p_j);
        Ddi_VarsetDiffAcc(sj,si);
        if (Ddi_VarsetIsVoid(sj)) {
          if (checkEqGate(ddiMgr,psv,bAig_NULL,
                          Ddi_BddToBaig(p_i),Ddi_BddToBaig(p_j),
                          visitedNodes,eqArray,NULL,NULL,0)) {
            neq++;
            nonEq[i] = nonEq[j] = 0;
	  }
        }
        Ddi_Free(sj);
      }
      Ddi_Free(si);
    }

    for (i=0; i<npart; i++) {
      int j;
      Ddi_Bdd_t *p_i = Ddi_BddPartRead(pinv,i);
      if (nonEq[i]) {
        nNonEq++;
        Ddi_BddAndAcc(newProp,p_i);
      }
    }

    for (i=0; i<visitedNodes->num; i++) {
      eqArray[i] = eqGateFindLdr(eqArray,visitedNodes->num,i);
    }

    reprs = Ddi_BddarrayAlloc(ddiMgr,0);
    equals = Ddi_BddarrayAlloc(ddiMgr,0);

    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = bAig_NonInvertedEdge(visitedNodes->nodes[i]);
      if (abs(eqArray[i]-1) != i) {
        int ldr = eqArray[i];
        int iLdr = abs(ldr)-1;
        int eqNeg = (ldr<0);
        bAigEdge_t baigLdr = bAig_NonInvertedEdge(visitedNodes->nodes[iLdr]);
        Ddi_Bdd_t *rep = Ddi_BddMakeFromBaig(ddiMgr,baigLdr);
        Ddi_Bdd_t *eq = Ddi_BddMakeFromBaig(ddiMgr,baig);
        if (eqNeg) {
          Ddi_BddNotAcc(eq);
        }
        Ddi_BddarrayInsertLast(reprs,rep);
        Ddi_BddarrayInsertLast(equals,eq);
        Ddi_Free(eq);
        Ddi_Free(rep);
      }
      bAig_AuxInt(bmgr,baig) = -1;
    }

    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      bAig_AuxInt(bmgr,baig) = -1;
    }

    if (speculate && Ddi_BddarrayNum(reprs)>0) {

      printf("compacting deltas (EQ prop): %d -> ", Ddi_BddarraySize(delta));
      Ddi_AigarrayOptByEquiv(delta, reprs, equals);
      printf("%d\n", Ddi_BddarraySize(delta));

      miters = Ddi_BddarrayAlloc(ddiMgr,Ddi_BddarrayNum(reprs)*2);
      for (i=0; i<Ddi_BddarrayNum(reprs); i++) {
        Ddi_BddarrayWrite(miters,2*i,Ddi_BddarrayRead(reprs,i));
        Ddi_BddarrayWrite(miters,2*i+1,Ddi_BddarrayRead(equals,i));
      }
      printf("compacting miters (EQ prop): %d -> ", Ddi_BddarraySize(miters));
      Ddi_AigarrayOptByEquivFwd(miters, reprs, equals, NULL, 0);
      printf("%d\n", Ddi_BddarraySize(miters));
      newEqProp = Ddi_BddMakePartConjVoid(ddiMgr);
      for (i=0; i<Ddi_BddarrayNum(reprs); i++) {
        Ddi_Bdd_t *eq_i = Ddi_BddXnor(
          Ddi_BddarrayRead(miters,2*i),Ddi_BddarrayRead(miters,2*i+1));

        // Pdtutil_Assert(Ddi_BddIncluded(deltaProp,eq_i),"wrong eq prop");

        Ddi_BddPartInsertLast(newEqProp,eq_i);
        Ddi_Free(eq_i);
      }

      Ddi_BddSetAig(newEqProp);
      if (0 && saveProp != NULL) {
        Ddi_DataCopy(newProp,newEqProp);
      }
      else {
        Ddi_BddAndAcc(newProp,newEqProp);
      }

      Ddi_Free(newEqProp);

      Ddi_Free(miters);
    }
    Ddi_Free(reprs);
    Ddi_Free(equals);

    if (neq>0 && speculate) {
      /* restore prop with PDT* literals */
      Ddi_Bdd_t *litProp = Ddi_BddMakeLiteralAig(pvarPs, 1);
      Ddi_Bdd_t *litConstrNeg = Ddi_BddMakeLiteralAig(cvarPs, 0);

      if (chk && saveProp==NULL) {
        Ddi_Bdd_t *diff = Ddi_BddXor(deltaProp,newProp);
        Pdtutil_Assert(!Ddi_AigSat(diff),"error re-building prop");
        Ddi_Free(diff);
      }


      if (saveProp != NULL) {
	Ddi_BddAndAcc(deltaConstr, newProp);
	Ddi_BddAndAcc(saveProp, litProp);
	Ddi_BddOrAcc(saveProp, litConstrNeg);
	Ddi_DataCopy(deltaPropRef,saveProp);
      }
      else {
	Ddi_BddAndAcc(newProp, litProp);
	Ddi_BddOrAcc(newProp, litConstrNeg);
	Ddi_DataCopy(deltaPropRef,newProp);
      }

      Ddi_Free(litProp);
      Ddi_Free(litConstrNeg);

    }

  }

  if (speculate) {
    Pdtutil_Assert(iProp>0, "problem locating prop delta");
    Ddi_BddarrayWrite(delta,iProp,deltaPropRef);
  }

  Ddi_Free(saveProp);
  Ddi_Free(pinv);
  Ddi_Free(psv);
  Ddi_Free(newProp);
  Ddi_Free(deltaPropRef);
  Ddi_Free(deltaProp);

  bAigArrayAuxIntClear(bmgr,visitedNodes);
  
  bAigArrayFree(visitedNodes);
  Pdtutil_Free(eqArray);
  Pdtutil_Free(nonEq);

  if (nPartP!=NULL) {
    *nPartP = neq+nNonEq;
  }

  return neq;
}

typedef struct {
  int fo, i0, i1, o, eq0, eq1;
  int foAndEq;
  int checkedCnt;
  char isEq;
  char isEqInternal;
  char isAndEq;
  char mapVarOnlyInFi;
  char doReturn;
  vec<int> foNodes;
} aigInfoForXorCheck_t;

/**Function********************************************************************
  Synopsis    [Looks for ITE constructs and tracks ENABLE signals]
  Description [Looks for ITE constructs and tracks ENABLE signals]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigFindXors(
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *mapVars,
  int topEqOnly
) {
  Ddi_Bddarray_t *xors;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm, 1);
  Ddi_BddarrayWrite(fA,0,f);
  xors = Ddi_AigarrayFindXors(fA,mapVars,topEqOnly);
  Ddi_Free(fA);
  return xors;
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigarrayFindXors(
  Ddi_Bddarray_t *fA,
  Ddi_Vararray_t *mapVars,
  int topEqOnly
)
{
  Ddi_Mgr_t *ddiMgr = Ddi_ReadMgr(fA);
  bAig_Manager_t *bmgr = ddiMgr->aig.mgr;
  Ddi_Bddarray_t *xorArray=NULL;
  
  int i, nf=Ddi_BddarrayNum(fA);
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddiMgr,1);
  if (mapVars!=NULL) {
    Ddi_VararrayWriteMarkWithIndex (mapVars,1);
  }

  for (i=0; i<nf; i++) {
    Ddi_Bdd_t *d_i = Ddi_BddarrayRead(fA,i);
    //    Ddi_Var_t *v_i = Ddi_VararrayRead(ps,i);
    bAigEdge_t baig = Ddi_BddToBaig(d_i);
    postOrderAigVisitIntern(bmgr,baig,visitedNodes,-1);
    //    baig = Ddi_VarToBaig(v_i);
    //    postOrderAigVisitIntern(bmgr,baig,visitedNodes,-1);
  }
  aigArrayClearVisitedIntern(bmgr,visitedNodes);
  bAigArraySortByLevel(ddiMgr, visitedNodes, bAig_NULL, -1);
  bAigArrayAuxIntClear(bmgr,visitedNodes);
  bAigArrayAuxIntSetId(bmgr,visitedNodes);

  int nv = visitedNodes->num;
  vec<aigInfoForXorCheck_t> nodeInfo;
  nodeInfo.growTo(nv);
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    nodeInfo[i].fo=0;
    nodeInfo[i].o=-1;
    nodeInfo[i].i0=-1;
    nodeInfo[i].i1=-1;
    nodeInfo[i].eq0=-1;
    nodeInfo[i].eq1=-1;
    nodeInfo[i].foAndEq=0;
    nodeInfo[i].isEq=0;
    nodeInfo[i].isEqInternal=0;
    nodeInfo[i].isAndEq=0;
    nodeInfo[i].mapVarOnlyInFi = 0;
    nodeInfo[i].doReturn = 0;
    nodeInfo[i].checkedCnt=0;
    nodeInfo[i].foNodes.clear();
    if (!bAig_NodeIsConstant(baig) && !bAig_isVarNode(bmgr,baig)) {      
      int ir = rightChildAuxInt(bmgr,baig);
      int il = leftChildAuxInt(bmgr,baig);
      nodeInfo[ir].fo++;
      nodeInfo[il].fo++;
      nodeInfo[ir].foNodes.push(i);
      nodeInfo[il].foNodes.push(i);
      nodeInfo[i].mapVarOnlyInFi =
	nodeInfo[ir].mapVarOnlyInFi && nodeInfo[il].mapVarOnlyInFi;
    }
    else if (!bAig_NodeIsConstant(baig) && bAig_isVarNode(bmgr,baig)) {
      // var
      Ddi_Var_t *v = Ddi_VarFromBaig(ddiMgr,baig);
      if (Ddi_VarReadMark(v)>0) {
	nodeInfo[i].mapVarOnlyInFi = 1;
      }
    }
  }
  for (i=0; i<nf; i++) {
    Ddi_Bdd_t *d_i = Ddi_BddarrayRead(fA,i);
    bAigEdge_t baig = Ddi_BddToBaig(d_i);
    int id = bAig_AuxInt(bmgr,baig);
    nodeInfo[id].o=i;
  }

  int nEqInternal=0;
  int nSelfMapped=0;
  int nEqOnVars=0, nCheckedVars=0, nCheckedVarsNoFo=0, nEqNoFoVars=0;
  for (i=0; i<visitedNodes->num; i++) {
    bAigEdge_t eq0, eq1, baig = visitedNodes->nodes[i];
    if (bAig_isVarNode(bmgr,baig)) continue;
    int isEq = Ddi_AigCheckEqGate(ddiMgr, baig,
				  NULL, NULL, &eq0, &eq1, 0);
    int ir = rightChildAuxInt(bmgr,baig);
    int il = leftChildAuxInt(bmgr,baig);
    nodeInfo[i].i0=ir;
    nodeInfo[i].i1=il;
    if (isEq) {
      int eq0i = bAig_AuxInt(bmgr,eq0);
      int eq1i = bAig_AuxInt(bmgr,eq1);
      Ddi_Var_t *v0 = NULL, *v1=NULL;
      nodeInfo[i].eq0=eq0i;
      nodeInfo[i].eq1=eq1i;
      nEqInternal++;
      nodeInfo[i].isEq=1;
      if (nodeInfo[ir].fo==1)
	nodeInfo[ir].isEqInternal=1;
      else 
	nodeInfo[ir].isEqInternal=2;
      if (nodeInfo[il].fo==1)
	nodeInfo[il].isEqInternal=1;
      else 
	nodeInfo[il].isEqInternal=2;
      nodeInfo[eq0i].checkedCnt++;
      nodeInfo[eq1i].checkedCnt++;
      if (nodeInfo[eq0i].fo<=2 && nodeInfo[eq0i].isEq) {
	// one cheched node internal
	nodeInfo[i].doReturn = 1;
      }
      if (nodeInfo[eq1i].fo<=2 && nodeInfo[eq1i].isEq) {
	// one cheched node internal
	nodeInfo[i].doReturn = 1;
      }
      if (bAig_isVarNode(bmgr,eq0)) {
	v0 = Ddi_VarFromBaig(ddiMgr,eq0);
	nCheckedVars++;
	if (nodeInfo[eq0i].fo==2)
	  nCheckedVarsNoFo++; 
      }
      if (bAig_isVarNode(bmgr,eq1)) {
	v1 = Ddi_VarFromBaig(ddiMgr,eq1);
	nCheckedVars++;
	if (nodeInfo[eq1i].fo==2)
	  nCheckedVarsNoFo++; 
      }
      if (bAig_isVarNode(bmgr,eq0) && bAig_isVarNode(bmgr,eq1)) {
	nEqOnVars++;
	if (nodeInfo[eq0i].fo==2 && nodeInfo[eq1i].fo==2)
	  nCheckedVarsNoFo++; 
      }
      if (nodeInfo[i].o >= 0) {
	if (v0!=NULL) {
	  int index = Ddi_VarReadMark(v0)-1;
	  if (index==nodeInfo[i].o) {
	    nSelfMapped++;
	  }
	}
	if (v1!=NULL) {
	  int index = Ddi_VarReadMark(v1)-1;
	  if (index==nodeInfo[i].o) {
	    nSelfMapped++;
	  }
	}
      }
    }
  } 
  if (nEqInternal>0) {
    int nCompared = 0, nEqConfirmed = 0, nComparedEq = 0, nAndEq = 0;
    int nFoInAnd=0, nEqFoInAnd=0, nFo0Eq=0, nOnlyChecked=0, eqAndNotAnded=0;
    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      if (bAig_isVarNode(bmgr,baig)) continue;
      nEqConfirmed += nodeInfo[i].isEq;
      nCompared += nodeInfo[i].checkedCnt;
      if (nodeInfo[i].checkedCnt>0 && nodeInfo[i].isEq)
	nComparedEq++;
    }
    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      if (bAig_isVarNode(bmgr,baig)) continue;
      if (!nodeInfo[i].isEq && !nodeInfo[i].isEqInternal) {
	int ir = rightChildAuxInt(bmgr,baig);
	int il = leftChildAuxInt(bmgr,baig);
	if (!nodeInfo[ir].isEq && !nodeInfo[ir].isAndEq) continue;
	if (!nodeInfo[il].isEq && !nodeInfo[il].isAndEq) continue;
	nodeInfo[i].isAndEq = 1;
	nodeInfo[ir].foAndEq++;
	nodeInfo[il].foAndEq++;
	nAndEq++;
      }
    }
    for (i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      if (bAig_isVarNode(bmgr,baig)) continue;
      if (nodeInfo[i].isEq && nodeInfo[i].fo==0) {
	nFo0Eq++;
      }
      if (nodeInfo[i].checkedCnt==1 && nodeInfo[i].fo==2) {
	nOnlyChecked++;
      }
      if (nodeInfo[i].isAndEq && !nodeInfo[i].foAndEq) {
	eqAndNotAnded++;
      }
      if (nodeInfo[i].foAndEq > 0) {
	if (nodeInfo[i].foAndEq == nodeInfo[i].fo) {
	  nFoInAnd++;
	  if (nodeInfo[i].isEq) {
	    nEqFoInAnd++;
	  }
	}
      }
    }
    Pdtutil_VerbosityMgrIf(ddiMgr, Pdtutil_VerbLevelUsrMin_c) {
      printf("%d internal eq nodes found\n", nEqInternal);
      printf("%d confirmed eq nodes - %d compared nodes - %d self mapped\n",
	     nEqConfirmed, nCompared, nSelfMapped);
      printf("%d comp+eq - %d and eq - %d only checked - %d top eqAnd\n",
	     nComparedEq, nAndEq, nOnlyChecked, eqAndNotAnded);
      printf("%d full fo in and (%d full fo anded eq) - %d fo0 eq\n",
	     nFoInAnd, nEqFoInAnd, nFo0Eq);
      printf("%d chkd vars (%d no fo v. - %d no fo v. in eq) - %d eq on v.\n",
	     nCheckedVars, nCheckedVarsNoFo, nEqNoFoVars, nEqOnVars);
    }

    xorArray = Ddi_BddarrayAlloc(ddiMgr,0);
    for (i=0; i<visitedNodes->num; i++) {
      //      if (!nodeInfo[i].mapVarOnlyInFi) continue;
      //      if (nodeInfo[i].doReturn && nodeInfo[i].fo>0) {
      int doInsert = nodeInfo[i].isAndEq && !nodeInfo[i].foAndEq;
      if (!topEqOnly)
        doInsert |= nodeInfo[i].checkedCnt>0;
      if (doInsert) {
        // if (nodeInfo[i].isAndEq && nodeInfo[i].fo>0) {
	bAigEdge_t baig = visitedNodes->nodes[i];
	Ddi_Bdd_t *eq = Ddi_BddMakeFromBaig(ddiMgr,baig);
	Ddi_BddarrayInsertLast(xorArray,eq);
	Ddi_Free(eq);
      }
    }
  }
  bAigArrayAuxIntClear(bmgr,visitedNodes);

  Ddi_Free(myOne);
  bAigArrayFree(visitedNodes);
  if (mapVars!=NULL) {
    Ddi_VararrayWriteMark (mapVars,0);
  }

  return xorArray;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
eqGateFindLdr (
  int *eqArray,
  int n,
  int i
)
{
  int eqNeg=0, ldr, iLdr;

  Pdtutil_Assert(i>=0 && i<n,"wrong array index");

  ldr = eqArray[i];
  iLdr = abs(ldr)-1;

  if (iLdr == i) {
    Pdtutil_Assert(ldr>0,"complemented eq not valid for self eq");
    return ldr;
  }

  while (abs(eqArray[iLdr]) != iLdr+1) {
    eqNeg = eqNeg ^ (ldr<0);
    ldr = eqArray[iLdr];
    iLdr = abs(ldr)-1;
  }
  //  wrong: last complement already accounted by ldr
  //  eqNeg = eqNeg ^ (ldr<0);
  return (eqNeg ? -ldr : ldr);
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
checkEqGate (
  Ddi_Mgr_t *ddiMgr,
  Ddi_Varset_t *psv,
  bAigEdge_t baig,
  bAigEdge_t right,
  bAigEdge_t left,
  bAig_array_t *visitedNodes,
  int *eqArray,
  bAigEdge_t *baigEq0P,
  bAigEdge_t *baigEq1P,
  int chkDiff
)
{
  bAig_Manager_t *bmgr = ddiMgr->aig.mgr;
  int ret=0;

  Pdtutil_Assert(eqArray==NULL || visitedNodes!=NULL,
                   "wrong eqarray & visitednodes setup");

  if (baig==bAig_NULL) {
    Pdtutil_Assert(right!=bAig_NULL && left!=bAig_NULL,
                   "wrong parameters for check eq gate");
  }
  else {
    if (bAig_NodeIsConstant(baig)) {
      return 0;
    }
    if (bAig_isVarNode(bmgr,baig)) {
      int isInv = bAig_NodeIsInverted(baig);
      if (chkDiff) isInv = !isInv;
      if (baigEq0P!=NULL) {
        *baigEq0P = bAig_NonInvertedEdge(baig);
      }
      if (baigEq1P!=NULL) {
        *baigEq1P = isInv ? bAig_Zero : bAig_One;
      }
      return 1;
    }
    if (chkDiff>1) {
      /* check implication: or required ! */
      if (!bAig_NodeIsInverted(baig)) {
        return 0;
      }
    }
    else if (bAig_NodeIsInverted(baig)) {
      chkDiff = !chkDiff;
    }
    right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
    left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);
    if (chkDiff>1) {
      right = bAig_Not(right);
      left = bAig_Not(left);
      if (baigEq0P!=NULL) {
        *baigEq0P = right;
      }
      if (baigEq1P!=NULL) {
        *baigEq1P = left;
      }
      return 1;
    }
  }

  if (bAig_NodeIsInverted(right) && bAig_NodeIsInverted(left) &&
      !bAig_NodeIsConstant(right) && !bAig_isVarNode(bmgr,right) &&
      !bAig_NodeIsConstant(left) && !bAig_isVarNode(bmgr,left) ) {

    bAigEdge_t rr = bAig_NodeReadIndexOfRightChild(bmgr,right);
    bAigEdge_t rl = bAig_NodeReadIndexOfLeftChild(bmgr,right);
    bAigEdge_t lr = bAig_NodeReadIndexOfRightChild(bmgr,left);
    bAigEdge_t ll = bAig_NodeReadIndexOfLeftChild(bmgr,left);
    /* take complement of left terms */
    lr = bAig_Not(lr);
    ll = bAig_Not(ll);
    if (((rr==lr) && (rl==ll)) || ((rr==ll) && (rl==lr))) {
      if (psv==NULL) {
        ret=1;
      }
      else {
        Ddi_Bdd_t *a = Ddi_BddMakeFromBaig(ddiMgr,rr);
        Ddi_Bdd_t *b = Ddi_BddMakeFromBaig(ddiMgr,ll);
        Ddi_Varset_t *s_ab;
        Ddi_Varset_t *s_a = Ddi_BddSupp(a);
        Ddi_Varset_t *s_b = Ddi_BddSupp(b);
        Ddi_VarsetIntersectAcc(s_a,psv);
        Ddi_VarsetIntersectAcc(s_b,psv);
        s_ab = Ddi_VarsetUnion(s_a,s_b);
        Ddi_VarsetIntersectAcc(s_a,s_b);
        ret = Ddi_VarsetNum(s_a) <= Ddi_VarsetNum(s_ab)/10;
        Ddi_Free(s_a);
        Ddi_Free(s_b);
        Ddi_Free(s_ab);
        Ddi_Free(a);
        Ddi_Free(b);
      }
      if (ret) {
        if (baigEq0P!=NULL) {
          *baigEq0P = rr;
        }
        if (baigEq1P!=NULL) {
          *baigEq1P = chkDiff ? rl : bAig_Not(rl);
        }
      }
      if (ret && eqArray!=NULL) {
        int n=visitedNodes->num;
        int ir = bAig_AuxInt(bmgr,rr);
        int il = bAig_AuxInt(bmgr,rl);
        int ldr0 = eqArray[ir] = eqGateFindLdr(eqArray,visitedNodes->num,ir);
        int ldr1 = eqArray[il] = eqGateFindLdr(eqArray,visitedNodes->num,il);
        bAigEdge_t baigEq0 = rr;
        bAigEdge_t baigEq1 = chkDiff ? rl : bAig_Not(rl);
        int neg0 = bAig_NodeIsInverted(baigEq0);
        int neg1 = bAig_NodeIsInverted(baigEq1);
        int negEq = neg0!=neg1;
        if (negEq) ldr0 = -ldr0;
        Pdtutil_Assert(abs(ldr1)>0 && abs(ldr1)<=n,"wrong ldr index");
        if (abs(ldr0)==abs(ldr1)) {
          /* redundant equiv: skip */
          Pdtutil_Assert(ldr0==ldr1,"phase problem with redundant equiv");
          ret = 2;
        }
        else {
          if (abs(ldr0)>abs(ldr1)) {
            int t = ldr1;
            ldr1 = ldr0;
            ldr0 = t;
          }
          /* union: set ldr0 as leader of ldr1 */
          eqArray[abs(ldr1)-1] = ldr1>0 ? ldr0 : -ldr0;
          //            printf("EQ= %d<->%d (%d %d)\n", rr/4, rl/4, ldr0, ldr1);
          //            printf("NS equiv 01\n");
        }
      }
    }
  }

  return ret;

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigCheckEqGate (
  Ddi_Mgr_t *ddiMgr,
  bAigEdge_t baig,
  bAigEdge_t right,
  bAigEdge_t left,
  bAigEdge_t *baigEq0P,
  bAigEdge_t *baigEq1P,
  int chkDiff
)
{
  return checkEqGate (ddiMgr, NULL, baig, right, left, NULL, NULL,
                      baigEq0P, baigEq1P, chkDiff);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigCheckImplGate (
  Ddi_Mgr_t *ddiMgr,
  bAigEdge_t baig,
  bAigEdge_t right,
  bAigEdge_t left,
  bAigEdge_t *baigEq0P,
  bAigEdge_t *baigEq1P)
{
  return checkEqGate (ddiMgr, NULL, baig, right, left, NULL, NULL,
                      baigEq0P, baigEq1P, 2);
}



/**Function*******************************************************************
  Synopsis    []   DV, for FMSD2015 and related stuff
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/

int
Ddi_AigSingleInterpolantCompaction(
  Ddi_Mgr_t *ddm,
  char *filename,
  char *outFilename,
  int method
){

  Ddi_Bddarray_t *benchArray;
  Ddi_Bdd_t *f, *care;
  Ddi_Bdd_t *myCare = NULL;
  long startTime, endTime;
  int size, sizeNew;
  int wSize;
  int enBddOpt;
  int  itpSize;
  char fileOut[1000];
  char *c = NULL;

  int itpStructOdcTh = ddm->settings.aig.itpStructOdcTh;

  int doPart=1;
  int doMonotone = 0;
  int decomp = 0;
  int doItp;
  //int doLoad, doCompute;

  if(method > 0){
    //compute itp again and then compact it
    //doCompute = 1;
    //doLoad = 0;
    doItp = 1;
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c, printf("Computing a new ITP, starting from A and B read from file %s\n",filename) );
  }else{
    //load itp and just compact it
    Pdtutil_Assert( method<0  ,"Unexpected value");
    //doCompute = 0;
    //doLoad = 1;
    doItp = 0;
    method = -method;
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c, printf("Loading ITP from file %s and compacting\n",filename) );
  }

  benchArray = Ddi_AigarrayNetLoadAiger(ddm,NULL,filename);
  Pdtutil_Assert( benchArray != NULL  ,"Unexpected NULL pointer");

  Ddi_Bdd_t *itp = Ddi_BddDup(Ddi_BddarrayRead(benchArray,0));
  Pdtutil_Assert( benchArray != NULL  ,"Unexpected NULL pointer");

  Ddi_Varset_t *suppITP = Ddi_BddSupp(itp);
  int itpCoreTh = ddm->settings.aig.itpAigCore;
  int nba = Ddi_BddarrayNum(benchArray);
 Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c, printf("Initial AIG size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP)) );

  if (nba>3) {
    myCare = Ddi_BddDup(Ddi_BddarrayRead(benchArray,3));
  } else {
    myCare = Ddi_BddMakeConstAig(ddm,1);
  }

  if ( !doItp ) {
    if (itp!=NULL && Ddi_BddSize(itp) > itpStructOdcTh ) {
      Ddi_AigStructRedRemAcc (itp,NULL);
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c, printf("TOT aig after struct rr: %d)\n", Ddi_MgrReadAigNodesNum(ddm)) );
    }

    if (itp!=NULL && Ddi_MgrReadAigAbcOptLevel(ddm)>0) {
      ddiAbcOptAcc (itp,-1);
      printf("ABC opt size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));
    }
  }

  Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
  Ddi_MgrSetSiftThresh (ddm, 100000);

  if ( doItp ) {
    Pdtutil_Assert( nba>2  ,"Unexpected value");

    Ddi_Bdd_t *A = Ddi_BddarrayRead(benchArray,1);
    Ddi_Bdd_t *B = Ddi_BddarrayRead(benchArray,2);

    int sat;
    Ddi_Varset_t *suppInterpolant;
    Ddi_Varset_t *suppA = Ddi_BddSupp(A);
    Ddi_Varset_t *suppB = Ddi_BddSupp(B);
    Ddi_Varset_t *glob = Ddi_VarsetIntersect(suppA,suppB);
    Ddi_Vararray_t *gv = Ddi_VararrayMakeFromVarset(  suppB , 1);

    Ddi_Bdd_t *interpolant;
    int i, itpPart = 0;

    for (i=0; i<Ddi_VararrayNum(gv); i++) {
    if (strstr(Ddi_VarName(Ddi_VararrayRead(gv,i)),"$NS")!=NULL)
      Ddi_VarsetAddAcc(glob,Ddi_VararrayRead(gv,i));
     }

    startTime = util_cpu_time();
    printf("\nComputing interpolant!!!\n");
    interpolant = Ddi_AigSatAndWithInterpolant(A,B,glob,NULL,myCare,NULL,
					       NULL,NULL,
					       &sat,itpPart,1,-1.0);
    endTime = util_cpu_time();
    Pdtutil_Assert(interpolant!=NULL,"non null itp required");
    printf("ITP(%d,%d,%d) -> %d\n", Ddi_BddSize(A),Ddi_BddSize(B),care==NULL?0:Ddi_BddSize(care), Ddi_BddSize(interpolant));
    fprintf(dMgrO(ddm),"Execution time = %s)\n", util_print_time(endTime-startTime));

    //Ddi_AigStructRedRemAcc (interpolant,NULL);
    //Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c, printf("TOT aig after struct rr: %d)\n", Ddi_MgrReadAigNodesNum(ddm)) );

    //ddiAbcOptAcc (interpolant,-1);
    //suppInterpolant = Ddi_BddSupp(interpolant);
    //printf("ABC opt size: %d - supp: %d\n", Ddi_BddSize(interpolant), Ddi_VarsetNum(suppInterpolant) );
    //Ddi_Free(suppInterpolant);

    if (method == 1){

      suppInterpolant = Ddi_BddSupp(interpolant);
      printf("Final AIG size: %d - supp: %d\n", Ddi_BddSize(interpolant), Ddi_VarsetNum(suppInterpolant));
      Ddi_Free(suppInterpolant);

      if (outFilename != NULL) {
	//basic output filename management
	if( strrchr(outFilename,'.') !=NULL ){
	  strcpy(fileOut,outFilename);
	  c=strrchr(fileOut,'.');
	  strcpy(c,"_AIGOUT.aig");
	}else{
	  sprintf(fileOut, "%s_AIGOUT.aig", outFilename);
	}

	//for benchmarking only, iff the first run is just for storing and the second for heavy compaction //old IBM custom
	FILE* fpt_aigout;
	fpt_aigout=fopen(fileOut, "r");
	if( fpt_aigout!=NULL ){
	  c=strrchr(fileOut,'.');
	  strcpy(c,"_OPT.aig");
	  fclose(fpt_aigout);
	}

	assert(interpolant != NULL);
	Ddi_BddarrayWrite(benchArray,0,interpolant);
	Ddi_AigarrayNetStoreAiger(benchArray, 0, fileOut);
	printf("Final ITP written in %s\n",fileOut);
      }

      Ddi_Free(benchArray);
      Ddi_Free(f);
      Ddi_Free(care);
      Ddi_Free(itp);
      Ddi_Free(suppITP);
      Ddi_Free(myCare);
      Ddi_Free(interpolant);
      Ddi_Free(suppInterpolant);
      Ddi_Free(suppA);
      Ddi_Free(suppB);
      Ddi_Free(glob);
      Ddi_Free(gv);

      return 1;

    }else{
      //method >=2
      Pdtutil_Assert( method >= 2  ,"Unexpected value");
      Ddi_Free(itp);
      itp =  Ddi_BddDup(interpolant);

      Ddi_Free(suppInterpolant);
      Ddi_Free(interpolant);

      Ddi_Free(suppA);
      Ddi_Free(suppB);
      Ddi_Free(glob);
      Ddi_Free(gv);
    }

  }

  //method >=2

  Ddi_BddSetAig(itp);

  if (1) {
    Ddi_Varset_t *suppTMP = Ddi_BddSupp(itp);
    enBddOpt = Ddi_VarsetNum(suppTMP) <= Ddi_MgrReadAigBddOptLevel (ddm)*60;
    Ddi_Free(suppTMP);
  }

  int bddDone = 0;
  if (enBddOpt) {
    bddDone = Ddi_AigOptByBdd(itp,-1,500000) > 0;
  }
  if (!bddDone) {
    Ddi_AigOptByFoCntTop(itp, NULL, 0);
  }

  if (itp != NULL && itpCoreTh>0 && ((itpSize = Ddi_BddSize(itp)) > itpCoreTh)) {
    Ddi_Bdd_t *b = Ddi_BddarrayRead(benchArray,2);
    Ddi_AigOptByMonotoneCoreAcc (itp,b,myCare,0,-1.0);
  }

  //too heavy and might be useles
  if (method >= 3 ){
    Ddi_MgrSiftEnable (ddm, Ddi_ReorderingMethodString2Enum("sift"));
    Ddi_MgrSetSiftThresh (ddm, 100000);
    Ddi_BddSetMono(myCare);
    AigOptByBddWithThresh(itp,myCare,1000000,1000.0,10000000);
    Ddi_AigOptByBddWithCare(itp,myCare,200.0,-1);
    printf("AIG size (after bdd opt): %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));
  }

  Ddi_Free(suppITP);
  suppITP = Ddi_BddSupp(itp);
  printf("Final AIG size: %d - supp: %d\n", Ddi_BddSize(itp), Ddi_VarsetNum(suppITP));

  if (outFilename != NULL) {
    //basic output filename management
    if( strrchr(outFilename,'.') !=NULL ){
      strcpy(fileOut,outFilename);
      c=strrchr(fileOut,'.');
      strcpy(c,"_AIGOUT.aig");
    }else{
      sprintf(fileOut, "%s_AIGOUT.aig", outFilename);
    }

    //for benchmarking only, iff the first run is just for storing and the second for heavy compaction
    FILE* fpt_aigout;
    fpt_aigout=fopen(fileOut, "r");
    if( fpt_aigout!=NULL ){
      c=strrchr(fileOut,'.');
      strcpy(c,"_OPT.aig");
      fclose(fpt_aigout);
    }

    Ddi_AigNetStoreAiger(itp,1/*bad*/,fileOut);
  }

  printf("Final AIG written in %s\n",fileOut);

  Ddi_Free(benchArray);
  Ddi_Free(f);
  Ddi_Free(care);

  Ddi_Free(itp);
  Ddi_Free(suppITP);
  Ddi_Free(myCare);

  return 0;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
bAigSetAuxCharForInterpolant(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g
)
{
  bAigEdge_t baig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *manager = ddm->aig.mgr;
  int nA=0, currItpCut=0;
  int retVal = 0;
  int merged=0;
  bAig_array_t *visitedNodes2 = bAigArrayAlloc();
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  bAig_array_t *visitedNodesL = bAigArrayAlloc();
  int i, j;

  postOrderBddAigVisitIntern(f, visitedNodes, 0, -1);
  postOrderAigClearVisitedIntern(manager,visitedNodes);

  Pdtutil_Assert(g!=NULL, "Nissin second aig");

  postOrderBddAigVisitIntern(g, visitedNodes2, 0, -1);
  postOrderAigClearVisitedIntern(manager,visitedNodes2);

  nA = visitedNodes->num;

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    bAig_AuxInt(manager,baig) = -3;
    nodeAuxChar(manager,baig) = 0;
  }

  for (j=0; j<visitedNodes2->num; j++) {
    baig = visitedNodes2->nodes[j];
    if (bAig_AuxInt(manager,baig) == -3) {
      /* common node: mark */
      nodeAuxChar(manager,baig) = 2;
    }
    else {
      /* new node: append to visitedNodes */
      bAigArrayWriteLast(visitedNodes,baig);
      nodeAuxChar(manager,baig) = 1;
    }  
  }

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    if (bAig_AuxInt(manager,baig) != 1) {
      bAig_AuxInt(manager,baig) = -1;
    }
  }

  return (nA);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
MinisatClausesWithSuppFlow(
  Ddi_IncrSatMgr_t *incrSat,
  Solver&    S,
  void *S22,
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g,
  Ddi_Varset_t *flowVars,
  int *na,
  int *aigShared,
  aigCnfMgr_t **aigCnfMgrP,
  int genRelation,
  int genRelationG,
  int genActLits,
  int nItpCuts
)
{
  int fCnf;
  bAigEdge_t baig;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *manager = ddm->aig.mgr;
  vec<Lit> lits;  int nA=0, currItpCut=0;
  int retVal = 0;
  int merged=0;
  bAig_array_t *visitedNodes2 = bAigArrayAlloc();
  bAig_array_t *visitedNodes = bAigArrayAlloc();
  bAig_array_t *visitedNodesL = bAigArrayAlloc();
  int i, j;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  aigCnfInfo_t *aigCnfInfo=NULL;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int phFilter = !genRelation && aigCnfLevel == 2;
  int genVarFlow = !genRelation && aigCnfLevel > 6;
  int circSat;
  int circImpl = 0;
  int incrementalSat = incrSat!=NULL;
  int dfsLevelized = 0 && !incrementalSat;
  int bfsLevelized = 0 && !incrementalSat;
  int sortByLevel = 3;
  int useAbc=0, maxAbcCnf=-1;
  Ddi_AigAbcInfo_t *aigAbcInfo=NULL;
  int doGenAigCnfInfo = 1;
  int doLoadSolver = 1; // aigCnfMgrP!=NULL;
  Ddi_Bddarray_t *sharedAigs = Ddi_BddarrayAlloc(ddm,0);
  int totClausesNum=0;
  LGL *lgl=NULL;

  int disNA = 0;
  int maxAbcSize=5000000;

  if (incrSat!=NULL) lgl = incrSat->lgl;

  if (nItpCuts>1 || (g!=NULL && Ddi_BddIsPartConj(g))) {
    dfsLevelized = bfsLevelized = sortByLevel = 0;
  }

  //  static int ncalls=0;
  //  ncalls++;

  if (aigCnfLevel > 4) {
    useAbc=1;
  }
  else if (aigCnfLevel == 4) {
    circImpl = 1;
  }
  else if (aigCnfLevel > 4) {
    circImpl = (aigCnfLevel-2);
    aigCnfLevel -= 2;
    phFilter = !genRelation && aigCnfLevel == 2;
  }

  if (dfsLevelized) {
    postOrderBddAigVisitIntern(f, visitedNodesL, incrementalSat, -1);
    if (g!=NULL) {
      postOrderBddAigVisitIntern(g, visitedNodesL, incrementalSat, -1);
    }
    postOrderAigClearVisitedIntern(manager,visitedNodesL);
    aigArrayLevelizeIntern(manager,visitedNodesL);
  }

  if (dfsLevelized) {
    postOrderBddAigByAuxIntVisitIntern(f, visitedNodes, NULL, -1);
  }
  else {
    postOrderBddAigVisitIntern(f, visitedNodes, incrementalSat, -1);
  }
  postOrderAigClearVisitedIntern(manager,visitedNodes);

  if (!incrementalSat && sortByLevel>2) {
    bAigArraySortByLevel(ddm, visitedNodes, bAig_NULL, -1);
  }

  if (g!=NULL) {
    if (dfsLevelized) {
      postOrderBddAigByAuxIntVisitIntern(g, visitedNodes2, NULL, -1);
    }
    else {
      postOrderBddAigVisitIntern(g, visitedNodes2, incrementalSat, -1);
    }
    postOrderAigClearVisitedIntern(manager,visitedNodes2);
    if (incrSat==NULL && sortByLevel>2) {
      bAigArraySortByLevel(ddm, visitedNodes2, bAig_NULL, -1);
    }
  }

  aigArrayClearAuxIntIntern(manager,visitedNodesL);
  bAigArrayFree(visitedNodesL);

  nA = visitedNodes->num;

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    bAig_AuxInt(manager,baig) = -3;
    if (g!=NULL)
      nodeAuxChar(manager,baig) = 0;
  }

  if (g!=NULL) {

    if (aigShared!=NULL) {
      *aigShared = 0;
    }
    for (j=0; j<visitedNodes2->num; j++) {
      baig = visitedNodes2->nodes[j];
      if (bAig_AuxInt(manager,baig) == -3) {
	Ddi_Bdd_t *s_i = Ddi_BddMakeFromBaig(ddm,baig);
	Ddi_BddarrayInsertLast(sharedAigs,s_i);
	Ddi_Free(s_i);
	/* common node: mark */
	// Pdtutil_Assert(bAig_isVarNode(manager,baig),"NON var common baig");
	if (aigShared!=NULL && !bAig_isVarNode(manager,baig)) {
	  *aigShared++;
	}
	if (S22==NULL || na!=NULL) {
	  nodeAuxChar(manager,baig) = 2;
	}
      }
      else {
	/* new node: append to visitedNodes */
        bAigArrayWriteLast(visitedNodes,baig);
        nodeAuxChar(manager,baig) = 0;
      }

    }

  }

  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    if (bAig_AuxInt(manager,baig) != 1) {
      bAig_AuxInt(manager,baig) = -1;
    }
  }

  if (bfsLevelized) {
    bAig_array_t *visitedNodesBfs = bAigArrayAlloc();
    if (g!=NULL) {
      bfsOrderBddAigVisitIntern(g, visitedNodesBfs);
    }
    bfsOrderBddAigVisitIntern(f, visitedNodesBfs);
    bfsOrderAigClearVisitedIntern(manager,visitedNodesBfs);
    for (j=0; j<visitedNodesBfs->num; j++) {
      baig = visitedNodesBfs->nodes[j];
      fCnf = aig2CnfId(ddm->aig.mgr,baig);
    }
    bAigArrayFree(visitedNodesBfs);
  }
  else if (sortByLevel>0) {
    int fCnf;
    for (j=visitedNodes2->num-1; j>=0; j--) {
      //    for (j=0; j<visitedNodes2->num; j++) {
      baig = visitedNodes2->nodes[j];
      fCnf = aig2CnfId(ddm->aig.mgr,baig);
    }
    for (j=visitedNodes->num-1; j>=0; j--) {
    //    for (j=0; j<visitedNodes->num; j++) {
      baig = visitedNodes->nodes[j];
      fCnf = aig2CnfId(ddm->aig.mgr,baig);
    }
  }

  if (visitedNodes->num > maxAbcSize) {
    if (aigCnfLevel > 4) {
      aigCnfLevel = 4;
      useAbc=0;
    }
  }


  if (doGenAigCnfInfo) {
    //    Ddi_Bddarray_t *fA = Ddi_BddarrayMakeFromBddPart(f);
    Ddi_Bddarray_t *fA = Ddi_BddarrayMakeFromBddRoots(f);
    Ddi_Vararray_t *vA = NULL;
    if (g!=NULL) {
      if (Ddi_BddIsPart(g)) {
        Ddi_Bddarray_t *gA = Ddi_BddarrayMakeFromBddPart(g);
        Ddi_BddarrayAppend(fA,gA);
        Ddi_Free(gA);
      }
      else {
        Ddi_BddarrayInsertLast(fA,g);
      }
    }
    if (genVarFlow && flowVars!=NULL) {
      vA = Ddi_VararrayMakeFromVarset(flowVars,1);
    }

    if (useAbc) {
      Ddi_Vararray_t *pIs = incrementalSat ? NULL:Ddi_BddarraySuppVararray(fA);
      Ddi_Bddarray_t *fA2 = Ddi_BddarrayDup(fA);
      Ddi_BddarrayAppend(fA2,sharedAigs);
      Ddi_AbcLock ();
      aigAbcInfo = Ddi_BddarrayToAbcCnfInfo (fA2, pIs, visitedNodes);
      Ddi_Free(pIs);
      Ddi_Free(fA2);
      maxAbcCnf = Ddi_AigAbcCnfMaxId(aigAbcInfo);
    }

    aigCnfInfo = genAigCnfInfo(manager,visitedNodes,fA,vA,
			       aigAbcInfo,incrementalSat,genRelation);
    if (vA!=NULL) {
      int j, nFlow=0;
      for (j=nA; j<visitedNodes->num; j++) {
	if (aigCnfInfo[j].isVarFlow) nFlow++;
      }
      printf("VAR FLOW: %d/%d\n",nFlow, (visitedNodes->num-nA));
    }
    Ddi_Free(fA);
    Ddi_Free(vA);
  }

  if (Ddi_BddIsPartDisj(f)) {
    Pdtutil_Assert(lgl==NULL,"LGL not supported with disj part g");
    //Pdtutil_Assert(genRelation == 1, "relation needed by part disj");
    int ii;
    //    Pdtutil_Assert(S22==NULL,"minisat 2 not supported here");
  }

  vec<Lit> dpartClause;
  for (i=0; i<Ddi_BddPartNum(f); i++) {
    Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
    if (Ddi_BddIsPartConj(f_i)) {
      int ii;
      for (ii=0; ii<Ddi_BddPartNum(f_i); ii++) {
        Ddi_Bdd_t *f_ii = Ddi_BddPartRead(f_i,ii);
        baig = f_ii->data.aig->aigNode;
        fCnf = DdiAig2CnfIdSigned(ddm->aig.mgr,baig);
        
        if (S22==NULL) {
          while (abs(fCnf) > S.nVars()) S.newVar();
        }
        else {
          Minisat22NewVars(S22,abs(fCnf));
        }
        
        retVal = fCnf;
        if (genRelation == 0) {
          /* fCnf */
          Pdtutil_Assert(!Ddi_BddIsPartDisj(f),"unsupported decomp");
          j = bAig_AuxInt(manager,baig);
          aigCnfInfo[j].implied = fCnf<0 ? -1 : 1;
          
          if (S22==NULL) {
            MinisatClause1(S,lits,fCnf);
          }
          else {
            Minisat22Clause1(S22,fCnf);
          }
        }
      }
    }
    else {
      baig = f_i->data.aig->aigNode;
      fCnf = DdiAig2CnfIdSigned(ddm->aig.mgr,baig);
      
      if (lgl) {
        // nothing to do
        //	lglfreeze(lgl,abs(fCnf));
      }
      else if (S22==NULL) {
        while (abs(fCnf) > S.nVars()) S.newVar();
      }
      else {
        Minisat22NewVars(S22,abs(fCnf));
      }
      
      retVal = fCnf;
      if (genRelation == 0) {
        if (Ddi_BddIsPartDisj(f)) {
          Lit l = MinisatLit(fCnf);
          dpartClause.push(l);
        }
        else {
          /* fCnf */
          j = bAig_AuxInt(manager,baig);
          aigCnfInfo[j].implied = fCnf<0 ? -1 : 1;
          
          if (lgl) {
            LglClause1(lgl,fCnf);
          }
          else if (S22==NULL) {
            MinisatClause1(S,lits,fCnf);
          }
          else {
            Minisat22Clause1(S22,fCnf);
          }
        }
      }
    }
  }
  if (genRelation == 0 && Ddi_BddIsPartDisj(f)) {
    if (S22==NULL) {
      MinisatSolverAddClause(S,dpartClause);
    }
    else {
      Minisat22Clause(S22,dpartClause);
    }
  }

  if (na!=NULL)
    *na = -1;

  aigCnfMgr = aigCnfMgrAlloc(ddm,visitedNodes->num);
  aigCnfMgr->aigCnfInfo = aigCnfInfo;
  aigCnfMgr->aigAbcInfo = aigAbcInfo;
  aigCnfMgr->visitedNodes = visitedNodes;
  //  aigCnfMgr->cutFrontier = NULL;
  aigCnfMgr->nNodes = visitedNodes->num;
  aigCnfMgr->aigCnfLevel = aigCnfLevel;
  aigCnfMgr->phFilter = phFilter;

  circSat = genAigCnfPropImplications(aigCnfMgr);

  if ((g!=NULL && S22==NULL || na!=NULL) && (disNA|| incrSat!=NULL)) {
    bAig_array_t *visitedNodesA = bAigArrayAlloc();
    bAig_array_t *visitedNodesB = bAigArrayAlloc();
    nA = -1;
    postOrderBddAigVisitIntern(g, visitedNodesB, 0, -1);
    for (j=0; j<visitedNodesB->num; j++) {
      baig = visitedNodesB->nodes[j];
      if (nodeAuxChar(manager,baig) == 0) {
	nodeAuxChar(manager,baig) = 1;
      }
    }
    postOrderAigClearVisitedIntern(manager,visitedNodesB);
    postOrderBddAigVisitIntern(f, visitedNodesA, 0, -1);
    for (j=0; j<visitedNodesA->num; j++) {
      baig = visitedNodesA->nodes[j];
      if (nodeAuxChar(manager,baig) == 1) {
        // common node
	nodeAuxChar(manager,baig) = 2;
      }
    }
    postOrderAigClearVisitedIntern(manager,visitedNodesA);
    bAigArrayFree(visitedNodesB);
    bAigArrayFree(visitedNodesA);
  }
  
  for (j=0; j<visitedNodes->num; j++) {
    if (j==nA && (na != NULL) && (aigCnfLevel==0)) {
      Pdtutil_Assert(nItpCuts<=1,
		     "itp cuts > 1 not supported with aigCnfLevel=0");
      /* a clauses stored */
      Pdtutil_Assert(lgl==NULL,"LGL not supported with proof");
      if (S22==NULL) {
	Pdtutil_Assert(S.proof!=NULL,"Proof required in SAT manager");
	*na = S.proof->last()+1;
      }
      else {
	/* GpC: take max id of A clauses */
	/* How with incremental SAT ? */
	*na = Minisat22nClauses(S22);
      }
    }

    baig = visitedNodes->nodes[j];

#if 1
    if (j>=nA && (na != NULL)) {
      /* b clause: set as global var */
      Pdtutil_Assert(lgl==NULL,"LGL not supported with proof");
      if (S22==NULL) {
	Pdtutil_Assert(S.proof!=NULL,"Proof required in SAT manager");
      }
      if ((S22==NULL || na!=NULL) && !disNA && incrSat==NULL) {
	nodeAuxChar(manager,baig) = 1;
      }
    }
#endif

    if (bAig_NodeIsConstant(baig)) {
    }
    else if (bAig_isVarNode(manager,baig) || aigCnfInfo[j].isCnfActive) {
      int a = DdiAig2CnfId(manager,baig);
      if (useAbc) {
	int abcCnfId = Ddi_AigAbcCnfId(aigAbcInfo,j);

	Pdtutil_Assert(abcCnfId>0,"wrong abc cnf id");
	Pdtutil_Assert(abcCnfId<=maxAbcCnf,"wrong abc cnf id");
	Ddi_AigAbcCnfSetAbc2PdtMap(aigAbcInfo,abcCnfId,a);
      }
      cnfSetActive(ddm,a,1);
    }
    else {
      int f, a, b, ir, il;
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(manager,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(manager,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      if (bAig_AuxRef(manager,baig) != 0) continue;

      ir = bAig_AuxInt(manager,right);
      il = bAig_AuxInt(manager,left);

      bAig_AuxRef(manager,baig) = 1;

      if (aigCnfLevel==0) {
	/* standard tseitin transformation */
	/* convert AIG node to cnf clauses */
	/* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
	f = aig2CnfId(manager,baig);
	a = bAig_NodeIsInverted(right) ? -aig2CnfId(manager,right) :
                                          aig2CnfId(manager,right);
	b = bAig_NodeIsInverted(left) ? -aig2CnfId(manager,left) :
                                         aig2CnfId(manager,left);

	if (lgl!=NULL) {
	  LglClause3(lgl,f,-a,-b);
	  LglClause2(lgl,-f,a);
	  LglClause2(lgl,-f,b);
	}
        else if (S22!=NULL) { 
	  /* f -a -b */
	  Minisat22Clause3(S22,f,-a,-b);
	  /* -f a */
	  Minisat22Clause2(S22,-f,a);
	  /* -f b */
	  Minisat22Clause2(S22,-f,b);
        }
	else {
	  /* f -a -b */
	  MinisatClause3(S,lits,f,-a,-b);
	  /* -f a */
	  MinisatClause2(S,lits,-f,a);
	  /* -f b */
	  MinisatClause2(S,lits,-f,b);
	}
	cnfSetActive(ddm,f,1);

      }
      else if (aigCnfLevel==1) {
	/* standard tseitin transformation */
	/* convert AIG node to cnf clauses */
	/* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
	f = aig2CnfId(manager,baig);
	a = bAig_NodeIsInverted(right) ? -aig2CnfId(manager,right) :
                                          aig2CnfId(manager,right);
	b = bAig_NodeIsInverted(left) ? -aig2CnfId(manager,left) :
                                         aig2CnfId(manager,left);

	aigCnfInfo[j].isRoot = 2;

	aigCnfInfo[j].ca->clear();
	aigCnfInfo[j].ca->push();
	(*aigCnfInfo[j].ca)[0].push(MinisatLit(f));
	(*aigCnfInfo[j].ca)[0].push(MinisatLit(-a));
	(*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
	/* !f a b */
	aigCnfInfo[j].ca->push();
	(*aigCnfInfo[j].ca)[1].push(MinisatLit(-f));
	(*aigCnfInfo[j].ca)[1].push(MinisatLit(a));
	/* f a !b */
	aigCnfInfo[j].ca->push();
	(*aigCnfInfo[j].ca)[2].push(MinisatLit(-f));
	(*aigCnfInfo[j].ca)[2].push(MinisatLit(b));
        
	cnfSetActive(ddm,f,1);

      }
      else {

	if (useAbc) {

	  int ii, a = DdiAig2CnfId(manager,baig);
	  int abcCnfId = Ddi_AigAbcCnfId(aigAbcInfo,j);
          Ddi_ClauseArray_t *ca;

	  Pdtutil_Assert(abcCnfId<=maxAbcCnf,"wrong abc cnf id");
	  if (aigCnfInfo[j].isRoot != 2) {
	    aigCnfInfo[j].isRoot = 1;
	  }

	  if (abcCnfId == 0) {
	    if (aigCnfInfo[j].isRoot != 2,"wrong abc root");
	    aigCnfInfo[j].isRoot = 0;
	  }

	  aigCnfInfo[j].ca->clear();

	  if (!aigCnfInfo[j].isRoot) continue;

	  Ddi_AigAbcCnfSetAbc2PdtMap(aigAbcInfo,abcCnfId,a);
          cnfSetActive(ddm,a,1);

          ca = Ddi_AigClausesFromAbcCnf (aigAbcInfo,j);

	  totClausesNum += ca->nClauses;

	  for (ii=0; ii<ca->nClauses; ii++) {
	    int jj;
	    Ddi_Clause_t *cl = ca->clauses[ii];
	    aigCnfInfo[j].ca->push();
	    Pdtutil_Assert(aigCnfInfo[j].ca->size()==ii+1,
			   "wrong clause array num");
	    for (jj=0; jj<cl->nLits; jj++) {
	      int lit = (cl)->lits[jj];
	      if (lit==0) continue;
	      (*aigCnfInfo[j].ca)[ii].push(MinisatLit(lit));
	    }
	  }

	  Ddi_ClauseArrayFree(ca);

	  continue;
	}

	if (aigCnfInfo[j].isRoot == 3) {
	  /* Xor */
	  int iA = aigCnfInfo[j].opIds[0];
	  int iB = aigCnfInfo[j].opIds[1];
	  bAigEdge_t baigA = visitedNodes->nodes[abs(iA)-1];
	  bAigEdge_t baigB = visitedNodes->nodes[abs(iB)-1];
	  f = DdiAig2CnfId(manager,baig);
          cnfSetActive(ddm,f,1);
	  a = (iA<0) ? -DdiAig2CnfId(manager,baigA) :
	                DdiAig2CnfId(manager,baigA);
	  b = (iB<0) ? -DdiAig2CnfId(manager,baigB) :
	                DdiAig2CnfId(manager,baigB);
	  Pdtutil_Assert(aigCnfInfo[j].ca->size()==0,"wrong clause array");
          if (0 && circImpl && (aigCnfInfo[j].implied > 0)) {
#if 0
            int iaImpl = aigCnfInfo[abs(iA)-1].implied * (iA>0 ? 1 : -1);
            int ibImpl = aigCnfInfo[abs(iB)-1].implied * (iB>0 ? 1 : -1);
            if (iaImpl > 0) {
              /* !b */
              aigCnfInfo[j].ca->push();
              (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
            }
            else if (iaImpl < 0) {
              /* b */
              aigCnfInfo[j].ca->push();
              (*aigCnfInfo[j].ca)[0].push(MinisatLit(b));
            }
            else if (ibImpl > 0) {
              /* !a */
              aigCnfInfo[j].ca->push();
              (*aigCnfInfo[j].ca)[0].push(MinisatLit(-a));
            }
            else if (a < 0) {
              /* a */
              aigCnfInfo[j].ca->push();
              (*aigCnfInfo[j].ca)[0].push(MinisatLit(a));
            }
            else
#endif
            {
              /* a = !b */
              /* !a !b */
              aigCnfInfo[j].ca->push();
              (*aigCnfInfo[j].ca)[0].push(MinisatLit(-a));
              (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
              /* a b */
              aigCnfInfo[j].ca->push();
              (*aigCnfInfo[j].ca)[1].push(MinisatLit(a));
              (*aigCnfInfo[j].ca)[1].push(MinisatLit(b));
            }
            if (bAig_isVarNode(manager,baigA)&&!bAig_isVarNode(manager,baigB)) {
              bAigEdge_t t = baigA; baigA = baigB; baigB = t;
              int tI = iA; iA = iB; iB = tI; t = a; a = b; b = t;
            }
            if (circImpl>1 &&
                bAig_isVarNode(manager,baigB)&&!bAig_isVarNode(manager,baigA)) {
              int k;
	      for (k=0; k<aigCnfInfo[abs(iA)-1].ca->size(); k++) {
                Lit lit = (*aigCnfInfo[abs(iA)-1].ca)[k][0];
                int v = var(lit);
                if ((v+1)==abs(a)) {
                  int isCompl = 1; /* this is a!=B */
                  if (sign(lit) ^ a<0) {
                    /* literal different from a */
                    isCompl = !isCompl;
                  }
                  (*aigCnfInfo[abs(iA)-1].ca)[k][0]=
                    (isCompl ? MinisatLit(-b) : MinisatLit(b));
                }
	      }
            }
          }
          else if (0 && circImpl && (aigCnfInfo[j].implied < 0)) {
            /* a = b */
            /* a !b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[0].push(MinisatLit(a));
            (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
            /* !a b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[1].push(MinisatLit(-a));
            (*aigCnfInfo[j].ca)[1].push(MinisatLit(b));
            if (bAig_isVarNode(manager,baigA)&&!bAig_isVarNode(manager,baigB)) {
              bAigEdge_t t = baigA; baigA = baigB; baigB = t;
              int tI = iA; iA = iB; iB = tI; t = a; a = b; b = t;
            }
            if (circImpl>1 &&
                bAig_isVarNode(manager,baigB)&&!bAig_isVarNode(manager,baigA)) {
              int k;
	      for (k=0; k<aigCnfInfo[abs(iA)-1].ca->size(); k++) {
                Lit lit = (*aigCnfInfo[abs(iA)-1].ca)[k][0];
                int v = var(lit);
                if ((v+1)==abs(a)) {
                  int isCompl = 0; /* this is a==B */
                  if (sign(lit) ^ a<0) {
                    /* literal different from a */
                    isCompl = !isCompl;
                  }
                  (*aigCnfInfo[abs(iA)-1].ca)[k][0]=
                    (isCompl ? MinisatLit(-b) : MinisatLit(b));
                }
	      }
            }
          }
          else {
            /* !f !a !b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[0].push(MinisatLit(-f));
            (*aigCnfInfo[j].ca)[0].push(MinisatLit(-a));
            (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
            /* !f a b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[1].push(MinisatLit(-f));
            (*aigCnfInfo[j].ca)[1].push(MinisatLit(a));
            (*aigCnfInfo[j].ca)[1].push(MinisatLit(b));
            /* f a !b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[2].push(MinisatLit(f));
            (*aigCnfInfo[j].ca)[2].push(MinisatLit(a));
            (*aigCnfInfo[j].ca)[2].push(MinisatLit(-b));
            /* f !a b */
            aigCnfInfo[j].ca->push();
            (*aigCnfInfo[j].ca)[3].push(MinisatLit(f));
            (*aigCnfInfo[j].ca)[3].push(MinisatLit(-a));
            (*aigCnfInfo[j].ca)[3].push(MinisatLit(b));
          }
	}
	else if (aigCnfInfo[j].isRoot == 4) {
	  /* ITE */
	  int s;
	  int iS = aigCnfInfo[j].opIds[0];
	  int iA = aigCnfInfo[j].opIds[1];
	  int iB = aigCnfInfo[j].opIds[2];
	  bAigEdge_t baigS = visitedNodes->nodes[abs(iS)-1];
	  bAigEdge_t baigA = visitedNodes->nodes[abs(iA)-1];
	  bAigEdge_t baigB = visitedNodes->nodes[abs(iB)-1];
	  f = DdiAig2CnfId(manager,baig);
          cnfSetActive(ddm,f,1);
	  s = (iS<0) ? -DdiAig2CnfId(manager,baigS) :
	                DdiAig2CnfId(manager,baigS);
	  a = (iA<0) ? -DdiAig2CnfId(manager,baigA) :
	                DdiAig2CnfId(manager,baigA);
	  b = (iB<0) ? -DdiAig2CnfId(manager,baigB) :
	                DdiAig2CnfId(manager,baigB);
	  Pdtutil_Assert(aigCnfInfo[j].ca->size()==0,"wrong clause array");
	  /* s f !b */
	  aigCnfInfo[j].ca->push();
	  (*aigCnfInfo[j].ca)[0].push(MinisatLit(s));
	  (*aigCnfInfo[j].ca)[0].push(MinisatLit(f));
	  (*aigCnfInfo[j].ca)[0].push(MinisatLit(-b));
	  /* s !f b */
	  aigCnfInfo[j].ca->push();
	  (*aigCnfInfo[j].ca)[1].push(MinisatLit(s));
	  (*aigCnfInfo[j].ca)[1].push(MinisatLit(-f));
	  (*aigCnfInfo[j].ca)[1].push(MinisatLit(b));
	  /* !s f !a */
	  aigCnfInfo[j].ca->push();
	  (*aigCnfInfo[j].ca)[2].push(MinisatLit(-s));
	  (*aigCnfInfo[j].ca)[2].push(MinisatLit(f));
	  (*aigCnfInfo[j].ca)[2].push(MinisatLit(-a));
	  /* !s !f a */
	  aigCnfInfo[j].ca->push();
	  (*aigCnfInfo[j].ca)[3].push(MinisatLit(-s));
	  (*aigCnfInfo[j].ca)[3].push(MinisatLit(-f));
	  (*aigCnfInfo[j].ca)[3].push(MinisatLit(a));
#if 1
	  /* redundant: !f a b */
	  aigCnfInfo[j].ca->push();
	  (*aigCnfInfo[j].ca)[4].push(MinisatLit(-f));
	  (*aigCnfInfo[j].ca)[4].push(MinisatLit(a));
	  (*aigCnfInfo[j].ca)[4].push(MinisatLit(b));
	  /* redundant: f -a -b */
	  aigCnfInfo[j].ca->push();
	  (*aigCnfInfo[j].ca)[5].push(MinisatLit(f));
	  (*aigCnfInfo[j].ca)[5].push(MinisatLit(-a));
	  (*aigCnfInfo[j].ca)[5].push(MinisatLit(-b));
#endif
	}
	else if (aigCnfInfo[ir].isRoot || aigCnfInfo[il].isRoot) {
	  /* cut gate, i.e. not an internal one */
	  int ldr = aigCnfInfo[j].ldr;
	  if (aigCnfInfo[ldr].isRoot < 3) {
	    bAigEdge_t baigLdr = visitedNodes->nodes[ldr];
	    Pdtutil_Assert(aigCnfInfo[ldr].isRoot,"wrong leader");
	    f = DdiAig2CnfId(manager,baigLdr);
            cnfSetActive(ddm,f,1);
	    if (aigCnfInfo[ir].isRoot) {
	      int last = aigCnfInfo[ldr].ca->size();
	      Pdtutil_Assert(last>0,"missing clause array");
	      a = bAig_NodeIsInverted(right) ? -DdiAig2CnfId(manager,right) :
		DdiAig2CnfId(manager,right);
	      if (phFilter && (aigCnfInfo[ir].isRoot<3)) {
		if (aigCnfInfo[ir].ref0==1 && aigCnfInfo[ir].ref1==0) {
		  merged ++;
		}
	      }
	      /* -f a */
              if ((aigCnfInfo[ldr].implied == 0)) {
                aigCnfInfo[ldr].ca->push();
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(-f));
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(a));
              }
              else  if ((aigCnfInfo[ldr].implied > 0)) {
                aigCnfInfo[ldr].ca->push();
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(-f));
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(a));
              }
	      /* f -a ... */
	      Pdtutil_Assert(ldr>=ir,"wrong leader");
              if ((circImpl<=2) || (aigCnfInfo[ldr].implied < 1)) {
                (*aigCnfInfo[ldr].ca)[0].push(MinisatLit(-a));
              }
	    }
	    if (aigCnfInfo[il].isRoot) {
	      int last = aigCnfInfo[ldr].ca->size();
	      Pdtutil_Assert(last>0,"missing clause array");
	      b = bAig_NodeIsInverted(left) ? -DdiAig2CnfId(manager,left) :
		DdiAig2CnfId(manager,left);
	      if (phFilter && (aigCnfInfo[il].isRoot<3)) {
		if (aigCnfInfo[il].ref0==1 && aigCnfInfo[il].ref1==0) {
		  merged ++;
		}
	      }
	      /* -f b */
              if ((aigCnfInfo[ldr].implied == 0)) {
                aigCnfInfo[ldr].ca->push();
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(-f));
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(b));
              }
              else  if ((aigCnfInfo[ldr].implied > 0)) {
                aigCnfInfo[ldr].ca->push();
                (*aigCnfInfo[ldr].ca)[last].push(MinisatLit(b));
              }
	      /* f -b ... */
	      Pdtutil_Assert(ldr>=ir,"wrong leader");
              if ((circImpl<=2) ||(aigCnfInfo[ldr].implied < 1)) {
                (*aigCnfInfo[ldr].ca)[0].push(MinisatLit(-b));
              }
	    }
	  }
	}

      }
    }

  }

  //  printf("\nTOT ABC CLAUSES: %d\n", totClausesNum);

  if (genActLits && aigCnfMgr!=NULL) {
    Pdtutil_Assert(aigCnfLevel>0,"genActLits needs aigcnflevel>0");
    aigCnfMgrGenActLits(aigCnfMgr);
  }
  
  if ((aigCnfLevel > 0) && doLoadSolver) {
    int currPartG=0, gPartId=-1;
    int phFilter = aigCnfMgr->phFilter;
    if ((aigCnfLevel == 1) && !genRelation) {
      aigCnfMgr->phFilter = 1;
    }

    for (j=0; j<visitedNodes->num; j++) {
      if (j==nA && (na != NULL)) {
        /* a clauses stored */
	Pdtutil_Assert(lgl==NULL,"LGL not supported with proof");
	if (S22==NULL) {
	  Pdtutil_Assert(S.proof!=NULL,"Proof required in SAT manager");
	  *na = S.proof->last()+1;
	}
	else {
	  /* GpC: take max id of A clauses */
	  /* How with incremental SAT ? */
	  *na = Minisat22nClauses(S22);
	}
      }

      baig = visitedNodes->nodes[j];

      genAigCnfSolverClauses(aigCnfMgr,&S,S22,lgl,j);

      if (0&&sortByLevel>1) {
	int act = aigCnfMgr->aigCnfInfo[j].foCnt;
	int vCnf = aig2CnfId(manager,baig);
        if (act>1 && S.nVars()>=vCnf) {
	  S.varBumpActivityExternal(MinisatLit(vCnf),act);
	}
      }

    }

    if (0 && g!=NULL && Ddi_BddIsPartConj(g)) {
      Pdtutil_Assert(genRelationG==0,
		       "relation not supported by part conj");
      Pdtutil_Assert(lgl==NULL,"LGL not supported with g part");
      for (j=0; j<Ddi_BddPartNum(g); j++) {
        Ddi_Bdd_t *g_i = Ddi_BddPartRead(g,currPartG++);
        baig = g_i->data.aig->aigNode;
        int currId = bAig_AuxInt(manager,baig);
        int gCnf = DdiAig2CnfIdSigned(ddm->aig.mgr,baig);
	Pdtutil_Assert(currId>=nA,"error in g partitions");
        MinisatClause1(S,lits,gCnf);

      }
    }

    aigCnfMgr->phFilter = phFilter;
  }

  if (na!=NULL && *na < 0 && !disNA && incrSat==NULL) {
    Pdtutil_Assert(lgl==NULL,"LGL not supported with proof");
    if (S22==NULL) {
      Pdtutil_Assert(S.proof!=NULL,"Proof required in SAT manager");
      *na = S.proof->last()+1;
    }
    else {
      /* GpC: take max id of A clauses */
      /* How with incremental SAT ? */
      *na = Minisat22nClauses(S22);
    }
  }

  if (g!=NULL) {
    int j, gCnf;
    if (Ddi_BddIsAig(g)) {
      baig = g->data.aig->aigNode;
      if (S22==NULL || na!=NULL) {
	nodeAuxChar(manager,baig) = 1;
      }
      gCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(manager,baig) :
        aig2CnfId(manager,baig);

      /* gCnf */
      if (genRelationG == 0) {
	if (lgl) {
	  LglClause1(lgl,gCnf);
	}
	else if (S22==NULL) {
	  MinisatClause1(S,lits,gCnf);
	}
	else {
	  Minisat22Clause1(S22,gCnf);
	}
      }
    }
    else if (Ddi_BddIsPartConj(g)) {
      int prevId = -1;
      Pdtutil_Assert(genRelationG==0,"relation not supported by part conj");
      int ii;
      for (ii=0; ii<Ddi_BddPartNum(g); ii++) {
        Ddi_Bdd_t *f_i = Ddi_BddPartRead(g,ii);
        baig = f_i->data.aig->aigNode;
	int currId = bAig_AuxInt(manager,baig);
	Pdtutil_Assert(1 || currId>prevId,"wrong sharing in partitioned g");
	prevId = currId;

        gCnf = DdiAig2CnfIdSigned(ddm->aig.mgr,baig);
	if (lgl) {
	  LglClause1(lgl,gCnf);
	}
	else if (S22==NULL) {
	  MinisatClause1(S,lits,gCnf);
	}
	else {
	  Minisat22Clause1(S22,gCnf);
	}
      }
    }
    else if (Ddi_BddIsPartDisj(g) && (genRelationG==0)) {
      Pdtutil_Assert(lgl==NULL,"LGL not supported with disj part g");
      int ii;
      vec<Lit> partTargets;
      partTargets.clear();
      for (ii=0; ii<Ddi_BddPartNum(g); ii++) {
        Ddi_Bdd_t *f_i = Ddi_BddPartRead(g,ii);
        baig = f_i->data.aig->aigNode;
        fCnf = DdiAig2CnfIdSigned(ddm->aig.mgr,baig);

        while (abs(fCnf) > S.nVars()) S.newVar();
        partTargets.push(MinisatLit(fCnf));

      }
      if (S22==NULL) {
        MinisatSolverAddClause(S,partTargets);
      }
      else {
        Minisat22Clause(S22,partTargets);
      }
    }

  }


  for (j=0; j<visitedNodes->num; j++) {
    baig = visitedNodes->nodes[j];
    bAig_AuxInt(manager,baig) = -1;
    bAig_AuxRef(manager,baig) = 0;
  }

  if (aigCnfMgrP != NULL) {
    *aigCnfMgrP = aigCnfMgr;
  }
  else {
    aigCnfMgrFree(aigCnfMgr);
  }

  if (useAbc) {
    Ddi_AbcUnlock ();
  }

  bAigArrayFree(visitedNodes2);
  Ddi_Free(sharedAigs);

  return (retVal);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
bAigArrayMinisatClausesWithNum(
  Ddi_Mgr_t *ddm,
  Solver&    S,
  bAig_array_t *visitedNodes,
  int i0,
  int N
)
{
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  vec<Lit> lits;
  int i;

  if (i0<0) i0=0;
  if (N<=0 || N>visitedNodes->num) N=visitedNodes->num;

  for (i=i0; i<N; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];

    if (bAig_isVarNode(bmgr,baig)) {
      /* just gen aig2cnf code */
      int f = DdiAig2CnfId(bmgr,baig);
    }
    else if (bAig_NodeIsConstant(baig)) {
      /* do nothing */
    }
    else {
      int f, a, b;
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      /* convert AIG node to cnf clauses */
      /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
      f = DdiAig2CnfId(bmgr,baig);
      a = bAig_NodeIsInverted(right) ? -DdiAig2CnfId(bmgr,right) :
                                        DdiAig2CnfId(bmgr,right);
      b = bAig_NodeIsInverted(left) ? -DdiAig2CnfId(bmgr,left) :
                                       DdiAig2CnfId(bmgr,left);

      /* f -a -b */
      MinisatClause3(S,lits,f,-a,-b);
      /* -f a */
      MinisatClause2(S,lits,-f,a);
      /* -f b */
      MinisatClause2(S,lits,-f,b);
      
      cnfSetActive(ddm,f,1);
    }

  }

}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
bAigArrayMinisatClauses(
  Ddi_Mgr_t *ddm,
  Solver&    S,
  bAig_array_t *visitedNodes,
  int i0
)
{
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  vec<Lit> lits;
  int i;

  if (i0<0) i0=0;

  for (i=i0; i<visitedNodes->num; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];

    if (bAig_isVarNode(bmgr,baig)) {
      /* just gen aig2cnf code */
      int f = DdiAig2CnfId(bmgr,baig);
    }
    else if (bAig_NodeIsConstant(baig)) {
      /* do nothing */
    }
    else {
      int f, a, b;
      bAigEdge_t right = bAig_NodeReadIndexOfRightChild(bmgr,baig);
      bAigEdge_t left = bAig_NodeReadIndexOfLeftChild(bmgr,baig);

      Pdtutil_Assert(left!=bAig_NULL && right!=bAig_NULL,"NULL child");

      /* convert AIG node to cnf clauses */
      /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
      f = DdiAig2CnfId(bmgr,baig);
      a = bAig_NodeIsInverted(right) ? -DdiAig2CnfId(bmgr,right) :
                                        DdiAig2CnfId(bmgr,right);
      b = bAig_NodeIsInverted(left) ? -DdiAig2CnfId(bmgr,left) :
                                       DdiAig2CnfId(bmgr,left);

      /* f -a -b */
      MinisatClause3(S,lits,f,-a,-b);
      /* -f a */
      MinisatClause2(S,lits,-f,a);
      /* -f b */
      MinisatClause2(S,lits,-f,b);
      
      cnfSetActive(ddm,f,1);
    }

  }

}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatMinisatWithCexAndAbortIncremental
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *filterVars,
  float timeLimit,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat, fCnf;
  Ddi_Bdd_t *cexAig = NULL;
  Solver      *S = incrSat->S;
  vec<Lit> assumps, blocking;
  assumps.clear();
  blocking.clear();

  if (Ddi_BddIsZero(f)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(f)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  MinisatClausesIncr(incrSat,f,NULL,NULL,1);
  if (Ddi_BddIsPartConj(f)) {
    int i;
    for (i=0; i<Ddi_BddPartNum(f); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
      if (!Ddi_BddIsOne(f_i)) {
        bAigEdge_t baig = f_i->data.aig->aigNode;
        fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                      aig2CnfId(ddm->aig.mgr,baig);
        Pdtutil_Assert(abs(fCnf) <= S->nVars(),"missing solver var");
        assumps.push(MinisatLit(fCnf));
        blocking.push(MinisatLit(-fCnf));
      }
    }
  }
  else {
    if (!Ddi_BddIsOne(f)) {
      bAigEdge_t baig = f->data.aig->aigNode;
      fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
        aig2CnfId(ddm->aig.mgr,baig);
      Pdtutil_Assert(abs(fCnf) <= S->nVars(),"missing solver var");
      assumps.push(MinisatLit(fCnf));
      blocking.push(MinisatLit(-fCnf));
    }
  }

  if (pAbort) *pAbort = 0;

  if (!S->okay()) {
    cexAig = NULL;
    sat = 0;
  }
  else {
    // printf("solving CNF instance: v: %d, c: %d\n", S->nVars(), S->nClauses());
    sat = S->solve(assumps,(double)timeLimit);
    //    sat = S->okay();
  }
  if (S->undefined()) {
    sat = -1;
    if (pAbort) *pAbort = 1;
  }
  else if (sat==0) {
    /* add blocking clause */
    if (blocking.size()>0) {
      S->addClause(blocking);
    }
  }

  if (sat>0)
  {
    int i;
    cexAig = Ddi_BddMakeConstAig(ddm,1);

    if (filterVars!=NULL) {
      for (i=0; i<Ddi_VararrayNum(filterVars); i++) {
	Ddi_Var_t *v_i = Ddi_VararrayRead(filterVars,i);
	bAigEdge_t varIndex = Ddi_VarToBaig(v_i);
	int vCnf = aig2CnfId(bmgr,varIndex);
	int id = vCnf-1;
        if (S->model[id] != l_Undef) {
          Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v_i,1);
          if (S->model[id]!=l_True) {
            Ddi_BddNotAcc(lit);
          }
          Ddi_BddAndAcc(cexAig,lit);
          Ddi_Free(lit);
        }
      }
    }
    else {
      for (i=0; i<S->nVars(); i++) {
        if (S->model[i] != l_Undef) {
          int vCnf = i+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          if (bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
            Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
            Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
            if (S->model[i]!=l_True) {
              Ddi_BddNotAcc(lit);
            }
            Ddi_BddAndAcc(cexAig,lit);
            Ddi_Free(lit);
          }
        }
      }
    }
  }

  return (cexAig);
}


/**Function********************************************************************
  Synopsis    [Create an incremental SAT mgr]
  Description [Create an incremental SAT mgr]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_IncrSatMgrSuspend(
  Ddi_IncrSatMgr_t *mgr
)
{
  int nMapOld = 0;
  int vSat, vCnf, nSatVars;
  bAigEdge_t baig;

  if (mgr==NULL) return;

  Pdtutil_Assert(DdiAig2CnfIdIsOpen(mgr->ddiMgr),"aig2cnf closed");
  Pdtutil_Assert(!mgr->suspended,"incr mgr already suspended");

  if (mgr->cnfMappedVars==NULL) {
    mgr->cnfMappedVars=bAigArrayAlloc();
    /* dummy var */
    bAigArrayWriteLast(mgr->cnfMappedVars,bAig_NULL);
    Pdtutil_Assert(mgr->cnfMappedVars->num==1, "missing dummy 0 var");
  }
  nMapOld = mgr->cnfMappedVars->num-1;

  if (mgr->S22!=NULL) {
    nSatVars = Minisat22nVars(mgr->S22);
  }
  else if (mgr->S!=NULL) {
    nSatVars = mgr->S->nVars();
  }
  else if (mgr->ddiS!=NULL) {
    nSatVars = mgr->ddiS->S->nVars();
  }

  for (vSat=nMapOld; vSat<nSatVars; vSat++) {
    vCnf = vSat+1;
    baig = mgr->ddiMgr->cnf.cnf2aig[vCnf];
    if (DdiCnfReadActive(mgr->ddiMgr,vCnf)==0) 
      baig = bAig_NULL;
    bAigArrayWriteLast(mgr->cnfMappedVars,baig);
    if (baig != bAig_NULL) {
      bAig_Ref(mgr->ddiMgr->aig.mgr, baig);
    }

  }
  Pdtutil_Assert(mgr->cnfMappedVars->num==nSatVars+1, 
		 "missing dummy 0 var");

  aig2CnfIdClose(mgr->ddiMgr);
  mgr->suspended = 1;

}


/**Function********************************************************************
  Synopsis    [Create an incremental SAT mgr]
  Description [Create an incremental SAT mgr]
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_IncrSatMgrResume(
  Ddi_IncrSatMgr_t *mgr
)
{
  int nMap;
  int vSat, vCnf, nSatVars;
  bAigEdge_t baig;

  if (mgr==NULL) return;

  Pdtutil_Assert(!DdiAig2CnfIdIsOpen(mgr->ddiMgr),"aig2cnf open");

  if (mgr->suspended) {
    Pdtutil_Assert(mgr->cnfMappedVars!=NULL,"missing aig-cnf mapping");
    nMap = mgr->cnfMappedVars->num-1;

    if (mgr->S22!=NULL) {
      nSatVars = Minisat22nVars(mgr->S22);
    }
    else if (mgr->S!=NULL) {
      nSatVars = mgr->S->nVars();
    }
    else if (mgr->ddiS!=NULL) {
      nSatVars = mgr->ddiS->S->nVars();
    }
    
    Pdtutil_Assert (nMap==nSatVars,"solver var mapping not aligned");
    
    aig2CnfIdInit(mgr->ddiMgr);
    aig2CnfIdLoad(mgr->ddiMgr,mgr->cnfMappedVars,1/*set active*/);
  }
  else {
    aig2CnfIdInit(mgr->ddiMgr);
  }

  mgr->suspended = 0;

}


#include "minisat22/coreDir/Solver.h"
#include "minisat22/coreDir/TraceProofVisitor.h"
#include "minisat22/coreDir/PdtLink.h"
#include "minisat22/simp/SimpSolver.h"

#define l_True22  (Minisat::lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
#define l_False22 (Minisat::lbool((uint8_t)1))
#define l_Undef22 (Minisat::lbool((uint8_t)2))

static void Minisat22PrintClauses(
    Minisat::vec< Minisat::vec<Minisat::Lit> >& clauses,
    int l, int r)
{
  if (r<0) r=0;
  if (r>(clauses.size()-1)) r = clauses.size()-1;
  for (int i=l; i<=r; i++) {
    printf("[%2d] ",i);
    Minisat22PrintClause(clauses[i]);
  }
}

static void Minisat22SolverPrintClauses(
   Minisat::Solver &S  
)
{
  int i;
  for (int i=0; i<S.nClauses(); i++) {
    const Minisat::Clause& cl = S.getClause2 (i);
    Minisat::CRef r = S.getClauseCRef(i);
    Minisat::vec<Minisat::Lit> c;
    for(int j=0;j<cl.size();j++) {
      c.push(cl[j]);
    }
    printf("%c ", cl.core()?'c':' ', i);
    printf("%c [%2d] ", S.isAttached(r) ?'a':' ', i);
    Minisat22PrintClause(c);
  }
}
 
static void Minisat22SolverPrintValues(
   Minisat::Solver &S  
)
{
  int i;
  for (int i=0; i<S.nVars(); i++) {
    Minisat::Var v = i;
    int val = toInt(S.value(v));
    if (val != 2) {
      if (S.getReason(v) == Minisat::CRef_Undef) {
        printf("[%3d]: v: %c - NO reason\n", i, (val == 0)?'1':'0');

      }
      else {
        printf("[%3d]: v: %c - reason %d - ", i, (val == 0)?'1':'0',
             S.getReason(v));
        const Minisat::Clause& cl = S.getClause (S.getReason(v));
        Minisat::vec<Minisat::Lit> c;
        for(int j=0;j<cl.size();j++) {
          c.push(cl[j]);
        }
        Minisat22PrintClause(c);
      }
    }
  }
}
 
/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
genAigCnfSolverClauses(
  aigCnfMgr_t *aigCnfMgr,
  Solver *pS,
  void *pS22void,
  LGL *lgl, 
  int j
)
{
  aigCnfInfo_t *aigCnfInfo = aigCnfMgr->aigCnfInfo;
  int phFilter = aigCnfMgr->phFilter;
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;
  Minisat::vec<Minisat::Lit> lits22;

  if (aigCnfInfo[j].isRoot && aigCnfInfo[j].ca->size() > 0) {
    if (!phFilter || aigCnfInfo[j].isRoot>2 || aigCnfInfo[j].ref0>0) {
      // check if size > 1 otherwise skip (due to impl)
      if (lgl!=NULL) {
	LglAddClause(lgl,(*aigCnfInfo[j].ca)[0]);
      }
      if (pS22!=NULL) {
        Minisat22SolverAddClause(pS22,(*aigCnfInfo[j].ca)[0],lits22);
	//	printf("S22 #vclauses: %d\n", pS22->nClauses());
      }
      else {
        MinisatSolverAddClause((*pS),(*aigCnfInfo[j].ca)[0]);
      }
    }
    if (!phFilter || aigCnfInfo[j].isRoot>2 || aigCnfInfo[j].ref1>0) {
      int k;
      for (k=1; k<aigCnfInfo[j].ca->size(); k++) {
        if ((*aigCnfInfo[j].ca)[k].size()==0) continue;
        //Pdtutil_Assert((*aigCnfInfo[j].ca)[k].size()>=2,
        //               "wrong n. lits");
	if (lgl!=NULL) {
	  LglAddClause(lgl,(*aigCnfInfo[j].ca)[k]);
	}
        if (pS22!=NULL) {
          Minisat22SolverAddClause(pS22,(*aigCnfInfo[j].ca)[k],lits22);
	  //	  printf("S22b #vclauses: %d\n", pS22->nClauses());
        }
        else {
          MinisatSolverAddClause((*pS),(*aigCnfInfo[j].ca)[k]);
        }
        //      	    aigCnfInfo[j].ca)[k].clear(true);
      }
    }
  }
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void *
Minisat22NewSolverVoidP(
  void
)
{
  Minisat22Solver *pS22 = new Minisat22Solver();
  return (void *)pS22;
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
Minisat22FreeSolverVoidP(
  void *pS22void
)
{
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;
  delete pS22;
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
Minisat22AndOrClauses(
  void *pS22void,
  bAig_Manager_t *bmgr,
  int isAnd,
  bAigEdge_t fbaig,
  bAigEdge_t *cutBaigs,
  int n,
  int nicePhase
)
{
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;
  //  nicePhase = 0;
  /* f = a&b --> (f+!a+!b)(!f+a)(!f+b) */
  int i;
  int f = aig2CnfId(bmgr,fbaig);

  int negF = !isAnd;

  Minisat::vec<Minisat::Lit> lits;
  lits.clear();

  if (negF) {
    Pdtutil_Assert(!isAnd,"wrong gate type");
    f = -f;
  }

  for (i=0; i<n; i++) {
    bAigEdge_t baig_i = cutBaigs[i];
    int f_i = aig2CnfId(bmgr,baig_i);
    int neg_i = bAig_NodeIsInverted(baig_i);
    if (neg_i) f_i = -f_i;
    if (isAnd) {
      Minisat22Clause2(pS22void,f_i,-f);
      if (!nicePhase) {
	while (abs(f_i)>pS22->nVars()) pS22->newVar();
	lits.push(Minisat22Lit(-f_i));
      }
    }
    else {
      while (abs(f_i)>pS22->nVars()) pS22->newVar();
      lits.push(Minisat22Lit(f_i));
      if (!nicePhase)
	Minisat22Clause2(pS22void,-f_i,f);
    }
  }

  if (isAnd) {
    if (!nicePhase) {
      Pdtutil_Assert(lits.size()>0,"problem with clause encoding");
      while (abs(f)>pS22->nVars()) pS22->newVar();
      lits.push(Minisat22Lit(f));
      pS22->addClause(lits);
    }
  }
  else {
    Pdtutil_Assert(lits.size()>0,"problem with clause encoding");
    while (abs(f)>pS22->nVars()) pS22->newVar();
    lits.push(Minisat22Lit(-f));
    pS22->addClause(lits);
  }

}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
Minisat22nClauses(
  void *pS22void
)
{
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;

  return pS22->nClauses();
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
Minisat22nVars(
  void *pS22void
)
{
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;

  return pS22->nVars();
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
Minisat22NewVars(
  void *pS22void,
  int maxv
)
{
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;

  while (maxv>pS22->nVars()) pS22->newVar();
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
Minisat22Clause(
  void *pS22void,
  vec<Lit>& lits
)
{
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;
  Minisat::vec<Minisat::Lit> lits22;
  Minisat22SolverAddClause(pS22,lits,lits22);
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
Minisat22Clause1(
  void *pS22void,
  int l
)
{
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;
  Minisat::vec<Minisat::Lit> lits22;
  vec<Lit> lits;

  while (abs(l)>pS22->nVars()) pS22->newVar();
  lits.clear();
  lits.push(MinisatLit(l));
  Minisat22SolverAddClause(pS22,lits,lits22);
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
Minisat22Clause2(
  void *pS22void,
  int l0,
  int l1
)
{
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;
  Minisat::vec<Minisat::Lit> lits22;
  vec<Lit> lits;

  while (abs(l0)>pS22->nVars()) pS22->newVar();
  while (abs(l1)>pS22->nVars()) pS22->newVar();
  lits.clear();
  lits.push(MinisatLit(l0));
  lits.push(MinisatLit(l1));
  Minisat22SolverAddClause(pS22,lits,lits22);
}

/**Function********************************************************************
  Synopsis    [refine state eq classes]
  Description [refine state eq classes]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
Minisat22Clause3(
  void *pS22void,
  int l0,
  int l1,
  int l2
)
{
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;
  Minisat::vec<Minisat::Lit> lits22;
  vec<Lit> lits;

  while (abs(l0)>pS22->nVars()) pS22->newVar();
  while (abs(l1)>pS22->nVars()) pS22->newVar();
  while (abs(l2)>pS22->nVars()) pS22->newVar();
  lits.clear();
  lits.push(MinisatLit(l0));
  lits.push(MinisatLit(l1));
  lits.push(MinisatLit(l2));
  Minisat22SolverAddClause(pS22,lits,lits22);
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigAbstrVarsForInterpolant22 (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Vararray_t *aVars,
  Ddi_Vararray_t *bVars,
  Ddi_Vararray_t *auxVars,
  char *wfileName,
  unsigned char *enAbstr,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int i, j;
  Ddi_Bdd_t *a2;
  Ddi_Bdd_t *lit;
  Ddi_Bddarray_t *abstrVarLit;
  Ddi_Vararray_t *vSubst, *abVars;
  Ddi_Varset_t *aSupp, *bSupp, *abSupp, *aVarsSet, *bVarsSet;
  int abstrCnt=0, nInitialAbstr=0;
  int nVars = Ddi_VararrayNum(aVars), nSuppVars;
  unsigned char *doAbstr = Pdtutil_Alloc(unsigned char, nVars);
  Ddi_Bddarray_t *eqRelArray=NULL;
  Minisat22Solver S;
  Minisat::vec<Minisat::Lit> lits;
  Minisat::vec<Minisat::Lit> assumps, possibleAssumps, totAssumps, assumpsReverse;
  FILE *fp=NULL;
  Var *minisatAV, *minisatBV;
  int strategy = Ddi_MgrReadAigDynAbstrStrategy(ddm);
  int enableTimeout = 0 || ddm->settings.aig.satTimeout;
  int doEval=1, doEvalAbstr=0;
  long cpuTime, startTime;
  double timeLimit=-1.0;
  double totTimeLimit=30.0;
  int satIncremental = ddm->settings.aig.satIncremental;
  int doAbort = 0, sizeA, sizeB;
  Ddi_Bdd_t *aa=NULL;

  if (pAbort != NULL) *pAbort = 0;

  Pdtutil_Assert(nVars==Ddi_VararrayNum(bVars),"Wrong var array size");
  Pdtutil_Assert(nVars==Ddi_VararrayNum(auxVars),"Wrong var array size");

  if (Ddi_BddIsZero(a) || Ddi_BddIsZero(b)) {
    return (Ddi_BddDup(a));
  }
  if (Ddi_BddIsOne(a) && Ddi_BddIsOne(b)) {
    return (Ddi_BddDup(a));
  }
  if (0 && !Ddi_AigSat(b)) { // @@@@@ try better tuning - expensive in some cases
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  minisatAV = Pdtutil_Alloc(Var, nVars);
  minisatBV = Pdtutil_Alloc(Var, nVars);

  aSupp = Ddi_BddSupp(a);
  bSupp = Ddi_BddSupp(b);

  aVarsSet = Ddi_VarsetMakeFromArray(aVars);
  bVarsSet = Ddi_VarsetMakeFromArray(bVars);

  Ddi_VarsetIntersectAcc(aSupp,aVarsSet);
  Ddi_VarsetIntersectAcc(bSupp,bVarsSet);

  Ddi_Free(aVarsSet);
  Ddi_Free(bVarsSet);

  nSuppVars = Ddi_VarsetNum(aSupp);

  Ddi_VarsetSetArray(aSupp);
  Ddi_VarsetSetArray(bSupp);

  abSupp = Ddi_VarsetUnion(aSupp,bSupp);
  abVars = Ddi_VararrayMakeFromVarset(abSupp,1);

  aa = Ddi_AigPartitionTop(a,0);

  sizeA = Ddi_BddSize(aa);
  sizeB = Ddi_BddSize(b);
  aig2CnfIdInitDecr(ddm,2*(sizeA+sizeB)/3);
  //  aig2CnfIdInit(ddm);

  if (sizeA>0) {
    Minisat22Clauses((void *)&S,aa,NULL,NULL,0);
  }
  else {
    Pdtutil_Assert(!Ddi_BddIsZero(a),"zero from in dyn abstr");
  }
  Minisat22Clauses((void *)&S,b,NULL,NULL,0);

  assumps.clear();
  eqRelArray = Ddi_BddarrayAlloc(ddm,0);

  for (i=0; i<nVars; i++) {
    Ddi_Bdd_t *wire, *eqRel;
    Ddi_Var_t *aV = Ddi_VararrayRead(aVars,i);
    Ddi_Var_t *bV = Ddi_VararrayRead(bVars,i);
    Ddi_Var_t *auxV = Ddi_VararrayRead(auxVars,i);
    doAbstr[i] = 1;
    if (!(Ddi_VarInVarset(aSupp,aV)&&Ddi_VarInVarset(bSupp,bV))) {
      nInitialAbstr++;
      continue;
    }
    doAbstr[i] = 0;
    lit = Ddi_BddMakeLiteralAig(bV,1);
    wire = Ddi_BddMakeLiteralAig(aV,1);
    eqRel = Ddi_BddMakeLiteralAig(auxV,1);
    Ddi_BddXnorAcc(wire,lit);
    Ddi_Free(lit);
    Ddi_BddXnorAcc(eqRel,wire);
    Ddi_Free(wire);
    Ddi_BddarrayInsertLast(eqRelArray,eqRel);
    Minisat22Clauses((void *)&S,eqRel,NULL,NULL,0);
    {
      int id = aig2CnfId(bmgr,Ddi_VarToBaig(auxV));
      Minisat::Lit l = Minisat22Lit(id);
      assumps.push(l);
      id = aig2CnfId(bmgr,Ddi_VarToBaig(aV));
      minisatAV[i]=Minisat::var(Minisat22Lit(id));
      id = aig2CnfId(bmgr,Ddi_VarToBaig(bV));
      minisatBV[i]=Minisat::var(Minisat22Lit(id));
    }
    Ddi_Free(eqRel);
  }

  Ddi_Free(eqRelArray);
  Ddi_Free(aa);

  if (enableTimeout < 0) {
    enableTimeout *= -1;
    cpuTime = 10000.0;
  }
  else {
    int sat;
    if ((sat = S.okay())) {
      startTime = util_cpu_time ();
      sat = S.solve(assumps);
      cpuTime = util_cpu_time () - startTime;
    }
    if (sat>0) {
      doEval=0;
    }
    else if (sat<0) {
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c,
        fprintf(dMgrO(ddm),"DYN ABSTR ABORTED\n"));
      doAbort=1;
    }
    else if (strategy > 0) {
      int j;
      int nkeep = 0;
      doEval = 0;
      doEvalAbstr = 1;
      for (i=j=0; i<nVars; i++) {
        if (! doAbort && !doAbstr[i] && (enAbstr==NULL || enAbstr[i])) {
          int sat, k;
          Minisat::Lit lit;

          lit = assumps[j++];
	  doAbstr[i]=1;
	  for (k=0; k<S.conflict.size(); k++) {
            Minisat::Lit kLit = S.conflict[k];
	    if (Minisat::var(kLit) == Minisat::var(lit)) {
	      nkeep++;
	      doAbstr[i]=0;
	      break;
	    }
	  }
	}
      }
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMin_c,
        fprintf(dMgrO(ddm),"DYN ABSTR (M22) KEPT %d/%d vars (time: %s)\n",
                nkeep, assumps.size(), util_print_time(cpuTime)));
    }
  }


  aig2CnfIdClose(ddm);


  if (doEvalAbstr) {

    abstrVarLit = Ddi_BddarrayAlloc(ddm,0);
    vSubst = Ddi_VararrayAlloc(ddm,0);

    //    	printf("\n");
    for (i=nVars-1; !doAbort && i>=0; i--) {
      Ddi_Var_t *aV = Ddi_VararrayRead(aVars,i);
      Ddi_Var_t *bV = Ddi_VararrayRead(bVars,i);
      if (!doAbstr[i]) {
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(bV,1);
        Ddi_BddarrayInsertLast(abstrVarLit,lit);
        Ddi_Free(lit);
        Ddi_VararrayInsertLast(vSubst,aV);
	//    	printf("%s ",Ddi_VarName(bV));
      }
      else {
        if (fp!=NULL) {
    	fprintf(fp,"%s\n",Ddi_VarName(bV));
        }
      }
    }

    //    	printf("\n");
    if (fp!=NULL) {
      fclose(fp);
    }

    a2 = Ddi_BddCompose(a,vSubst,abstrVarLit);

    Ddi_Free(vSubst);
    Ddi_Free(abstrVarLit);
  }
  else {
    a2=NULL;
  }


  Ddi_Free(aSupp);
  Ddi_Free(abSupp);
  Ddi_Free(abVars);
  Ddi_Free(bSupp);
  Pdtutil_Free(doAbstr);
  Pdtutil_Free(minisatAV);
  Pdtutil_Free(minisatBV);


  return(a2);

}



/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatMinisatLoadClausesIncremental
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *g
)
{
  if (Ddi_BddIsZero(f)) {
    return (0);
  }
  if (Ddi_BddIsOne(f)) {
    return (0);
  }

  MinisatClausesIncr(incrSat,f,g,NULL,1);

  return 1;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
void
Ddi_AigarrayLockTopClauses
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bddarray_t *fA
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  int i;
  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    Ddi_Bdd_t *f_i = Ddi_BddarrayRead(fA,i);
    if (!Ddi_BddIsConstant(f_i)) {
      bAigEdge_t baig = Ddi_BddToBaig(f_i);
      int fCnf = aig2CnfId(ddm->aig.mgr,baig);
      if (incrSat->lgl!=NULL) 
	lglfreeze(incrSat->lgl,abs(fCnf));
      else if (incrSat->S22!=NULL) {
	Minisat22FreezeCnfVar(incrSat->S22,abs(fCnf));
      }
    }
  }
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
void
Ddi_AigLockTopClauses
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *fA;
  if (Ddi_BddIsPart(f)) {
    fA = Ddi_BddarrayMakeFromBddRoots(f);
  }
  else {
    fA = Ddi_BddarrayAlloc(ddm, 1);
    Ddi_BddarrayWrite(fA,0,f);
  }
  Ddi_AigarrayLockTopClauses(incrSat,fA);
  Ddi_Free(fA);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatMinisatLoadBddarrayClausesIncremental
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bddarray_t *fA
)
{
  int i, doLoad=0;
  Ddi_Bdd_t *fPart;

  for (i=0; i<Ddi_BddarrayNum(fA); i++) {
    if (!Ddi_BddIsConstant(Ddi_BddarrayRead(fA,i))) {
      doLoad = 1; break;
    }
  }
  if (!doLoad) return 0;

  fPart = Ddi_BddMakePartConjFromArray(fA);

  MinisatClausesIncr(incrSat,fPart,NULL,NULL,1);

  Ddi_Free(fPart);

  return 1;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatMinisatLoadClausesIncrementalAsserted
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *f
)
{
  if (Ddi_BddIsZero(f)) {
    return (0);
  }
  if (Ddi_BddIsOne(f)) {
    return (0);
  }

  MinisatClausesIncr(incrSat,f,NULL,NULL,0);

  return 1;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_IncrSatPrintStats
(
  Ddi_Mgr_t *ddm,
  Ddi_IncrSatMgr_t *incrSat,
  int doProof
)
{
  if (incrSat==NULL) return;
  Minisat22Solver *S = (Minisat22Solver *)incrSat->S22;

  if (incrSat->lgl!=NULL) {
    lglstats (incrSat->lgl);
    return;
  }

  if (doProof) {
    FILE *f = fopen ((const char*) "proof22.txt", "w");
    Minisat::vec<Minisat::Lit> dummy;
    //    Minisat::lbool ret = S->solveLimited(dummy);
    Minisat::TraceProofVisitor v(*S, stdout);

    S->validate(v);

    //TEST MINISAT 22 CORE
    // vec< vec<Lit> > coreClauses;
    // vec<Var> coreVars;
    // Minisat22Core(incrSat, ddm, coreVars, coreClauses);
    // fprintf(dMgrO(ddm), "Solver 22 stats: %ld/%ld core vars/core clauses\n", coreVars.size(), coreClauses.size());

    S->replay(v);
    fclose(f);
  }
  if (S==NULL) S = (Minisat::SimpSolver *)incrSat->S22simp;

  if (S==NULL) {
    Solver *S0 = incrSat->S;
    fprintf(dMgrO(ddm),
	 "Solver stats: %ld/%ld vars/clauses\n",
	  S0->nVars(), S0->nClauses());
    fprintf(dMgrO(ddm),
	 "Solver stats: %ld/%ld/%ld dec./prop./confl.\n",
	 (int)S0->stats.decisions, (int)S0->stats.propagations,
	 (int)S0->stats.conflicts);
    return;
  }
  
  int nVars = S->nVars(), nElim=0, nElimC=0;
#if USE_SIMP
  //  nVars -= S->nEliminated();
  nElim = S->eliminated_vars;
  nElimC = S->eliminated_clauses;
  nVars -= nElim;
#endif
  fprintf(dMgrO(ddm),
	 "Solver 22 stats: %ld/%ld vars/clauses (elimv(v/cl): %d/%d)\n",
	  nVars, S->nClauses(), nElim, nElimC);
  fprintf(dMgrO(ddm),
	 "Solver 22 stats: %ld/%ld/%ld dec./prop./confl.\n",
	 (int)S->decisions, (long int)S->propagations,
	 (int)S->conflicts);

}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Ddi_AigSatMinisat22Solve
(
  Ddi_Mgr_t *ddm,
  Ddi_IncrSatMgr_t *incrSat
)
{
  Minisat22Solver *S = (Minisat22Solver *)incrSat->S22;

  return S->solve();
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Ddi_IncrSolverFreezeVars
(
  Ddi_Mgr_t *ddm,
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Vararray_t *vars
)
{
  int i;

  if (incrSat->lgl!=NULL) {
    for (i=0; i<Ddi_VararrayNum(vars); i++) {
      Ddi_Var_t *v_i = Ddi_VararrayRead(vars,i);
      bAigEdge_t baig = Ddi_VarToBaig(v_i);
      int fCnf = aig2CnfId(ddm->aig.mgr,baig);
      lglfreeze(incrSat->lgl,abs(fCnf));
    }
  }
  else {
    Minisat22Solver *S = (Minisat22Solver *)incrSat->S22;
    Minisat22FreezeVars (S,ddm,vars);
  }
}



/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int Minisat22Solve
(
  void *pS22void
)
{
  Minisat22Solver *S = (Minisat22Solver *)pS22void;

  return S->solve();
}


int DdiSolverReadModel22(Ddi_SatSolver_t *solver, int var) {
  Minisat22Solver *S22 = (Minisat22Solver *)(solver->S22);
  lbool res;
  if (S22->model[var] == l_True22)
    return 1;
  if (S22->model[var] == l_False22)
    return -1;
  
  return 0;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatMinisat22WithCexRefinedIncremental
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *filterVars,
  int asserted,
  float timeLimit,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat, fCnf;
  Ddi_Bdd_t *cexAig = NULL;

  static int ncalls=0;
  ncalls++;

  vec<Lit> assumps, blocking;

  Minisat22Solver *S22;
  Minisat22SolverPdt *pdtS=NULL;
  if (incrSat!=NULL) {
    S22 = (Minisat22Solver *)incrSat->S22;
    Pdtutil_Assert(S22!=NULL,"missing solver");
    if (!S22->okay()) {
      sat = 0;
      return (NULL);
    }
    pdtS = (Minisat22SolverPdt *)incrSat->S22aux;
    if (pdtS==NULL) {
      pdtS = new Minisat22SolverPdt();
      incrSat->S22aux = pdtS;
    }
  }
  else {
    S22 = new Minisat22Solver();
    aig2CnfIdInit(ddm);
  }

  assumps.clear();
  blocking.clear();

  if (Ddi_BddIsZero(f)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(f)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  if (incrSat!=NULL) {
    MinisatClausesIncr(incrSat,f,NULL,NULL,!asserted);
  }
  else {
    Minisat22Clauses((void *)S22,f,NULL,NULL,!asserted);
  }

  if (!asserted) {
    if (Ddi_BddIsPartConj(f)) {
      int i;
      for (i=0; i<Ddi_BddPartNum(f); i++) {
	Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
	if (!Ddi_BddIsOne(f_i)) {
	  bAigEdge_t baig = f_i->data.aig->aigNode;
	  fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
	    aig2CnfId(ddm->aig.mgr,baig);
	  Pdtutil_Assert(abs(fCnf) <= S22->nVars(),"missing solver var");
	  assumps.push(MinisatLit(fCnf));
	  blocking.push(MinisatLit(-fCnf));
	}
      }
    }
    else {
      if (!Ddi_BddIsOne(f)) {
	bAigEdge_t baig = f->data.aig->aigNode;
	fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
	  aig2CnfId(ddm->aig.mgr,baig);
	Pdtutil_Assert(abs(fCnf) <= S22->nVars(),"missing solver var");
	assumps.push(MinisatLit(fCnf));
	blocking.push(MinisatLit(-fCnf));
      }
    }
  }

  if (pAbort) *pAbort = 0;

  if (!S22->okay()) {
    cexAig = NULL;
    sat = 0;
  }
  else {
    Minisat::vec<Minisat::Lit> assumps22;
    MinisatTo22(assumps22,assumps);
    //    printf("solving CNF instance: v: %d, c: %d\n", S22->nVars(), S22->nClauses());
    if (timeLimit >= 0) {
      S22->setTimeBudget((double)timeLimit);
      sat = S22->solveLimitedInt(assumps22);
    }
    else {
      sat = S22->solve(assumps22);
    }
    //    sat = S->okay();
#if USE_SIMP
    if (sat == -1) {
      //      sat = S22->solveWithRefinement(assumps22,pdtS);
      sat = S22->solveWithLearntsAndSimplify(assumps22,pdtS);
    }
#endif
  }


  if (sat==0) {
    /* add blocking clause */
    if (blocking.size()>0) {
      Minisat::vec<Minisat::Lit> blocking22;
      MinisatTo22(blocking22,blocking);
      S22->addClause(blocking22);
    }
  }

  if (sat>0)
  {
    int i;
    cexAig = Ddi_BddMakeConstAig(ddm,1);

    if (filterVars!=NULL) {
      for (i=0; i<Ddi_VararrayNum(filterVars); i++) {
	Ddi_Var_t *v_i = Ddi_VararrayRead(filterVars,i);
	bAigEdge_t varIndex = Ddi_VarToBaig(v_i);
	int vCnf = aig2CnfId(bmgr,varIndex);
	int id = vCnf-1;
        if (S22->model[id] != l_Undef22) {
          Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v_i,1);
          if (S22->model[id]!=l_True22) {
            Ddi_BddNotAcc(lit);
          }
          Ddi_BddAndAcc(cexAig,lit);
          Ddi_Free(lit);
        }
      }
    }
    else {
      for (i=0; i<S22->nVars(); i++) {
        if (S22->model[i] != l_Undef22) {
          int vCnf = i+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          if (bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
            Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
            Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
            if (S22->model[i]!=l_True22) {
              Ddi_BddNotAcc(lit);
            }
            Ddi_BddAndAcc(cexAig,lit);
            Ddi_Free(lit);
          }
        }
      }
    }
  }

  if (incrSat==NULL) {
    aig2CnfIdClose(ddm);
    delete S22;
  }

  return (cexAig);
}

static void lglPdtLearnClause(
  void *learned123void,
  int l0,
  int l1,
  int l2
) {
  vec<int> *learned123p = (vec<int> *)learned123void;
  assert(l0!=0);
  learned123p->push(l0);
  learned123p->push(l1);
  if (l1!=0) {
    learned123p->push(l2);
    if (l2!=0) {
      learned123p->push(0);
    }
  }
}

static void lglRegisterLearning(
  LGL *lgl,
  vec<int> *learned123,
  int restart
)
{
  if (learned123==NULL) return;
  if (restart)
    learned123->clear();
  lglsetpdtlearn (lgl, lglPdtLearnClause, (void *)learned123);
}

static int getLglLearning(
  Ddi_Mgr_t *ddm,
  LGL *lgl,
  vec<int> *learned123p,
  vec<vec<Lit> >& learned,
  int maxSize
)
{
  typedef struct Stk { int * start, * top, * end; } Stk;
  int notalit;
  Stk *s = (Stk *)lglPdtGetInfo(lgl,"red", &notalit);
  Stk *sCl = (Stk *)lglPdtGetInfo(lgl,"irr", &notalit);
  int i, j, nLits, nClauses=0, *litArray, doExport=0;
  vec<Lit> cl;
  if (s==NULL) return 0;

  for (j=-2; j<MAXGLUE; j++) {
    if (j==-2) {
      if (learned123p==NULL) continue;
      litArray = &((*learned123p)[0]);
      nLits = learned123p->size();
      doExport = 0;
    }
    else if (j==-1) {
      doExport = 1;
      nLits = sCl->top-sCl->start;
      litArray = sCl->start;
    }
    else {
      doExport = 1;
      nLits = s[j].top-s[j].start;
      litArray = s[j].start;
    }
    for (i=0, cl.clear(); i<nLits; i++) {
      int l = litArray[i];
      if (l>=notalit) continue;
      if (l==0) {
        if (cl.size()>0) {
          if (cl.size()<=maxSize) {
            learned.push();
            cl.copyTo(learned.last());
            nClauses++;
          }
          cl.clear();
        }
      }
      else {
        // l!=0
        if (doExport)
          l = lglpdtextlit(lgl,l);
        cl.push(MinisatLit(l));
      }
    }
    assert(cl.size()==0);
  }
  return nClauses;
}


static int updateVarEq(vec<int>& eqTable, Var v0, Var v1, int complV) {
  assert(eqTable.size()>v0 && eqTable.size()>v1);
  if (eqTable[v0]!=(v0+1) && eqTable[v1]!=(v1+1)) return 0;     
  if (eqTable[v1]!=(v1+1)) {
    Var t = v0; v0 = v1; v1 = t;
  }
  // now merge v1->v0
  eqTable[v1]=eqTable[v0];
  if (complV) {
    eqTable[v1] = -eqTable[v1];
  }
  return 1;
}

static int getEquivFromClauses(
  vec<vec<Lit> >& clauses,
  vec<vec<Lit> >& equiv
)
{
  int i, j, maxVar, nVars,nEq=0;

  vec<resClRef_t> doublep;
  doublep.clear();

  vec<int> eqTable;
  if (clauses.size()==0) return 0;
  
  for (i=0, maxVar=-1; i<clauses.size(); i++) {
    if (clauses[i].size()==2) {
      resClRef_t clRef;
      vec<Lit>& c = clauses[i]; 
      clRef.clp = &c;
      clRef.id = i;
      doublep.push(clRef);
      for (j=0; j<c.size(); j++) {
        Var v = var(c[j]);
        if (v>maxVar)
          maxVar = v;
      }
    }
  }
  assert(maxVar>=0);
  nVars = maxVar+1;

  eqTable.growTo(nVars);

  for (i=0; i<nVars; i++) {
    eqTable[i] = i+1;
  }
  
  sort(doublep, compareByLits_lt());

  for (i=1; i<doublep.size(); i++) {
    vec<Lit>& v0 = *(doublep[i-1].clp);
    vec<Lit>& v1 = *(doublep[i].clp);
    int id0 = doublep[i-1].id, id1 = doublep[i].id;
    assert(id0>=0&&id0<clauses.size());
    assert(id1>=0&&id1<clauses.size());
    Lit l00=v0[0], l01=v0[1], l10=v1[0], l11=v1[1];
    if ((l00 == ~l10 && l01 == ~l11) ||
        (l01 == ~l10 && l00 == ~l11)) {
      int complVars = sign(l00) == sign(l01);
      if (updateVarEq(eqTable,var(l00),var(l01),complVars)) {
          nEq++;
      }
    }
  }
  
  for (j=0; j<nVars; j++) {
    if (eqTable[j]!=(j+1)) {
      Var v_j = j;
      Var v_eq = abs(eqTable[j])-1; 
      int isCompl = eqTable[j]<0;
      assert(v_eq>=0 && v_eq<nVars);
      Lit l_j = Lit(v_j), l_eq = Lit(v_eq);
      if (eqTable[v_j]<0) l_eq = ~l_eq; 
      vec<Lit> newEq;
      newEq.push(l_j);
      newEq.push(l_eq);
      equiv.push();
      newEq.copyTo(equiv.last());
#if 0
      newEq.clear();
      newEq.push(~l_j);
      newEq.push(l_eq);
      equiv.push();
      newEq.copyTo(equiv.last());
#endif
    }
  }

}

 
/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
void
Ddi_AigSatInitLearningIncremental
(
  Ddi_IncrSatMgr_t *incrSat,
  int restart
)
{
  if (incrSat==NULL) return;
  if (incrSat->lgl!=NULL) {
    incrSat->enLglLearn = 1;
    if (incrSat->lglLearned123==NULL) {
      incrSat->lglLearned123 = new vec<int>;
    }
    lglRegisterLearning(incrSat->lgl,incrSat->lglLearned123,restart);
  }
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
void
Ddi_AigSatStopLearningIncremental
(
  Ddi_IncrSatMgr_t *incrSat
)
{
  if (incrSat==NULL) return;
  if (incrSat->lgl!=NULL) {
    incrSat->enLglLearn = 0;
    lglclearpdtlearn (incrSat->lgl);
    Ddi_Free(incrSat->implied);
    Ddi_Free(incrSat->refA);
    Ddi_Free(incrSat->eqA);
  }
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static Ddi_Bdd_t *
aigFromCnfLit (
  Ddi_Mgr_t *ddm,
  Lit l
)
{
  Ddi_Bdd_t *aig = NULL;
  Var v_i = var(l);
  int isNeg = sign(l); 
  int vCnf;
  if (ddm->cnf.solver2cnf != NULL) {
    vCnf = ddm->cnf.solver2cnf[v_i]+1;
  }
  else {
    vCnf = v_i+1;
  }
  bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
  if (baig != bAig_NULL) {
    aig = Ddi_BddMakeFromBaig(ddm, baig);
    if (isNeg) Ddi_BddNotAcc(aig);
  }
  return aig;
}
 
/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static Ddi_Bdd_t *
aigFromClause (
  Ddi_Mgr_t *ddm,
  vec<Lit> &c
)
{
  Ddi_Bdd_t *aig = Ddi_BddMakeConstAig(ddm,0);
  int i;
  for (i=0; i<c.size(); i++) {
    Ddi_Bdd_t *lit = aigFromCnfLit(ddm,c[i]);
    if (lit==NULL) {
      Ddi_Free(aig);
      return NULL;
    }
    Ddi_BddOrAcc(aig,lit);
    Ddi_Free(lit);
  }
  if (Ddi_BddIsZero(aig))
    return NULL;
  return aig;
 }
 
/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bddarray_t *
Ddi_AigSatImpliedLearningIncremental
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *assume,
  Ddi_Bddarray_t *auxF,
  Ddi_Bddarray_t *refA,
  Ddi_Bddarray_t *eqA
)
{
  Ddi_Mgr_t *ddm;
  bAig_Manager_t *bmgr;
  Ddi_Bddarray_t *fA=NULL;
  vec<vec<Lit> > learned;
  vec<char > isUnitLit;
  int i, j, nSolverVars=0, iter;
  
  if (incrSat==NULL) return NULL;
  ddm = incrSat->ddiMgr;
  bmgr = ddm->aig.mgr;
  learned.clear();
  if (incrSat->lgl!=NULL) {
    int maxSize = 4;
    nSolverVars = lglmaxvar(incrSat->lgl)+1;
    getLglLearning(ddm,incrSat->lgl,incrSat->lglLearned123,
                   learned,maxSize);    
  }
  if (learned.size()>0) {
    int again = 0;
    fA = Ddi_BddarrayAlloc(ddm, 0);
    isUnitLit.growTo(nSolverVars);
    for (i=0; i<nSolverVars; i++) {
      isUnitLit[i] = 0;
    }
    iter = 0;
    if (1 && (assume!=NULL)) {
      Pdtutil_Assert(Ddi_BddIsAig(assume)||
                     Ddi_BddIsPartConj(assume),"wrong assume format");
      for (i=0; i<Ddi_BddPartNum(assume); i++) {
        Ddi_Bdd_t *a_i = Ddi_BddPartRead(assume,i);
        int aCnf = DdiAig2CnfIdSigned(bmgr,Ddi_BddToBaig(a_i));
        if (abs(aCnf)<nSolverVars) {
          isUnitLit[abs(aCnf)-1] = aCnf<0? -1 : 1;
        }
      }
    }
    do {
      again = 0;
      iter++;
      for (i=0; i<learned.size(); i++) {
        if (learned[i].size()>1) {
          int cntUnit = 0;
          int unit_j;
          Lit unitLit;
          vec<Lit>& c = learned[i];
          for (j=0; j<c.size(); j++) {
            int v_j = var(c[j]);
            if (v_j>=nSolverVars) {
              // deleted - skip clause
              c.clear();
              cntUnit = 0;
              break;
            }
            Pdtutil_Assert(v_j<nSolverVars,"wrong var");
            unit_j = 0;
            if (isUnitLit[v_j]!=0) {
              if (sign(c[j]) != (isUnitLit[v_j]<0)) {
                unit_j = 1;
              }
            }
            if (unit_j) {
              cntUnit++;
            }
            else {
              unitLit = c[j];
            }
          }
          if (1 && (cntUnit == c.size()-1)) {
            c.clear();
            c.push(unitLit);
          }
        }
        if (learned[i].size()==1) {
          Var v_i = var(learned[i][0]);
          int isNeg = sign(learned[i][0]); 
          Ddi_Bdd_t *impl = aigFromCnfLit(ddm,learned[i][0]);
          if (impl!=NULL) {
            again = 1;
            Ddi_BddarrayInsertLast(fA,impl);
            learned[i].clear();
            Ddi_Free(impl);
          }
          isUnitLit[v_i] = isNeg ? -1 : 1;
        }
        else if (auxF != NULL && (iter == 1)) {
          Ddi_Bdd_t *impl = aigFromClause(ddm,learned[i]);
          if (impl!=NULL)
            Ddi_BddarrayInsertLast(auxF,impl);
          Ddi_Free(impl);
        }
      }
    } while (again);
    if (0 && auxF==NULL) {
      for (i=0; i<learned.size(); i++) {
        if (learned[i].size()>3) {
          Ddi_Bdd_t *impl = aigFromClause(ddm,learned[i]);
          if (impl!=NULL)
            Ddi_BddarrayInsertLast(fA,impl);
          Ddi_Free(impl);
        }
      }
    }
    if (Ddi_BddarrayNum(fA)==0) Ddi_Free(fA);
    vec<vec<Lit> > equivClasses;
    equivClasses.clear();
    getEquivFromClauses(learned,equivClasses);
    printf("FOUND %d equivalences\n", equivClasses.size()/2);
    if (refA!=NULL && eqA!=NULL) {
      for (i=0; i<equivClasses.size(); i++) {
        assert(equivClasses[i].size()==2);
        Ddi_Bdd_t *l0 = aigFromCnfLit(ddm,equivClasses[i][0]);
        Ddi_Bdd_t *l1 = aigFromCnfLit(ddm,equivClasses[i][1]);
        if (l0!=NULL && l1!=NULL) {
          Ddi_BddarrayInsertLast(eqA,l0);
          Ddi_BddarrayInsertLast(refA,l1);
        }
        Ddi_Free(l0);
        Ddi_Free(l1);
      }
    }
  }
  return fA;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatMinisat22WithCexAndAbortIncremental
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *filterVars,
  int asserted,
  float timeLimit,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat, fCnf;
  Ddi_Bdd_t *cexAig = NULL;
  int enEliminate = 0;

  static int ncalls=0;
  ncalls++;

  vec<Lit> assumps, blocking;

  Minisat22Solver *S22;
  Minisat::SimpSolver *S22s;
  if (incrSat!=NULL) {
    Ddi_IncrSatMgrLockAig(incrSat,f);
    enEliminate = incrSat->enSimplify;
    S22 = (Minisat22Solver *)incrSat->S22;
    if (S22==NULL) {
      S22s = (Minisat::SimpSolver *)incrSat->S22simp;
      if (S22s!=NULL) {
	if (!S22s->okay()) {
	  sat = 0;
	  return (NULL);
	}
      }
      else if (incrSat->lgl!=NULL) {
	sat = 0;
      }
    }
    else {
      Pdtutil_Assert(S22!=NULL,"missing solver");
      if (!S22->okay()) {
	sat = 0;
	return (NULL);
      }
    }
  }
  else {
    S22 = new Minisat22Solver();
    aig2CnfIdInit(ddm);
  }

  assumps.clear();
  blocking.clear();

  if (Ddi_BddIsZero(f)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(f)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  if (incrSat!=NULL) {
    MinisatClausesIncr(incrSat,f,NULL,NULL,!asserted);
  }
  else {
    Minisat22Clauses((void *)S22,f,NULL,NULL,!asserted);
  }

  if (!asserted) {
    if (Ddi_BddIsPartConj(f)) {
      int i;
      for (i=0; i<Ddi_BddPartNum(f); i++) {
	Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
	if (!Ddi_BddIsOne(f_i)) {
	  bAigEdge_t baig = f_i->data.aig->aigNode;
	  fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
	    aig2CnfId(ddm->aig.mgr,baig);
	  if (S22!=NULL)
	    Pdtutil_Assert(abs(fCnf) <= S22->nVars(),"missing solver var");
	  assumps.push(MinisatLit(fCnf));
	  blocking.push(MinisatLit(-fCnf));
	}
      }
    }
    else {
      if (!Ddi_BddIsOne(f)) {
	bAigEdge_t baig = f->data.aig->aigNode;
	fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
	  aig2CnfId(ddm->aig.mgr,baig);
	if (S22!=NULL)
	  Pdtutil_Assert(abs(fCnf) <= S22->nVars(),"missing solver var");
	assumps.push(MinisatLit(fCnf));
	blocking.push(MinisatLit(-fCnf));
      }
    }
  }

  if (pAbort) *pAbort = 0;

  if (incrSat!=NULL && incrSat->lgl!=NULL) {
    int lglAssump, i, res, startFreeze;
    for (i=0; i<assumps.size(); i++) {
      lglAssump = var(assumps[i])+1;
      lglfreeze(incrSat->lgl,lglAssump);
      if (sign(assumps[i])) lglAssump = -lglAssump;
      lglassume (incrSat->lgl, lglAssump);
    }
    startFreeze = incrSat->lglMaxFrozen+1;
    for (i=startFreeze; i<=lglmaxvar(incrSat->lgl); i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (!bAig_isVarNode(bmgr,baig)) continue;
      if (cnfReadActive(ddm,i)) {
	lglfreeze(incrSat->lgl,i);
      }
    }
    incrSat->lglMaxFrozen = lglmaxvar(incrSat->lgl);
    //    LGL *clone = lglclone(incrSat->lgl);
    res = lglsat (incrSat->lgl);
    //    lglunclone (incrSat->lgl, clone);
    //    lglrelease (clone);
    if (incrSat->enLglLearn) {
      Ddi_Free(incrSat->refA);
      Ddi_Free(incrSat->eqA);
      incrSat->refA = Ddi_BddarrayAlloc(ddm, 0);
      incrSat->eqA = Ddi_BddarrayAlloc(ddm, 0);
      incrSat->implied =
        Ddi_AigSatImpliedLearningIncremental(incrSat,
              f,NULL/*auxImplDup*/,incrSat->refA,incrSat->eqA);
    }    
    for (i=1; i<=lglmaxvar(incrSat->lgl); i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (bAig_isVarNode(bmgr,baig)) continue;
      if (cnfReadActive(ddm,i)) {
	if (!lglreusable (incrSat->lgl, i)) {
	  cnfId2AigClear(ddm, incrSat->cnfMappedVars, i);
	}
	else {
	  lglreuse (incrSat->lgl, i);
	}
      }
    }

    switch (res) {
    case 10: sat=1; break;
    case 20: sat=0; break;
    case 0: 
    default: sat=-1; break;
    }
  }
  else if (!S22->okay()) {
    cexAig = NULL;
    sat = 0;
  }
  else {
    Minisat::vec<Minisat::Lit> assumps22;
    if (enEliminate) Minisat22FreezeAig (S22,f);
    MinisatTo22(assumps22,assumps);
    //    printf("solving CNF instance: v: %d, c: %d\n", S22->nVars(), S22->nClauses());
    if (timeLimit >= 0) {
      S22->setTimeBudget((double)timeLimit);
      Ddi_Vararray_t *vA = Ddi_BddSuppVararray(f);
      if (enEliminate) Minisat22FreezeVars (S22,ddm,NULL);
      if (enEliminate) S22->eliminate(false);
      sat = S22->solveLimitedInt(assumps22);
      if (enEliminate) Minisat22ReleaseEliminatedVars (S22,ddm,
				  incrSat?incrSat->cnfMappedVars:NULL);
      Ddi_Free(vA);
    }
    else {
      Ddi_Vararray_t *vA = Ddi_BddSuppVararray(f);
      if (enEliminate) Minisat22FreezeVars (S22,ddm,NULL);
      if (enEliminate) S22->eliminate(false);
      sat = S22->solve(assumps22,false,true);
      if (enEliminate) Minisat22ReleaseEliminatedVars (S22,ddm,
				  incrSat?incrSat->cnfMappedVars:NULL);
      Ddi_Free(vA);
    }
    //    sat = S->okay();
  }
  if (sat == -1) {
    if (pAbort) *pAbort = 1;
  }
  else if (0 && (sat==0)) {
    /* add blocking clause */
    if (blocking.size()>0) {
      if (incrSat->lgl!=NULL) {
	LglAddClause(incrSat->lgl,blocking);
      }
      else {
	Minisat::vec<Minisat::Lit> blocking22;
	MinisatTo22(blocking22,blocking);
	S22->addClause(blocking22);
      }
    }
  }

  if (sat>0)
  {
    int i;
    cexAig = Ddi_BddMakeConstAig(ddm,1);

    if (incrSat && incrSat->lgl!=NULL) {
      for (i=1; i<=lglmaxvar(incrSat->lgl); i++) {
	int vCnf = i;
	bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	if (bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
	  int val = lglderef (incrSat->lgl, vCnf);
	  Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
	  if (val<=0) {
	    Ddi_BddNotAcc(lit);
	  }
	  Ddi_BddAndAcc(cexAig,lit);
	  Ddi_Free(lit);
	}
      }
    }
    else if (filterVars!=NULL) {
      for (i=0; i<Ddi_VararrayNum(filterVars); i++) {
	Ddi_Var_t *v_i = Ddi_VararrayRead(filterVars,i);
	bAigEdge_t varIndex = Ddi_VarToBaig(v_i);
	int vCnf = aig2CnfId(bmgr,varIndex);
	int id = vCnf-1;
        if (S22->model[id] != l_Undef22) {
          Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v_i,1);
          if (S22->model[id]!=l_True22) {
            Ddi_BddNotAcc(lit);
          }
          Ddi_BddAndAcc(cexAig,lit);
          Ddi_Free(lit);
        }
      }
    }
    else {
      for (i=0; i<S22->nVars(); i++) {
        if (S22->model[i] != l_Undef22) {
          int vCnf = i+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          if (bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
            Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
            Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
            if (S22->model[i]!=l_True22) {
              Ddi_BddNotAcc(lit);
            }
            Ddi_BddAndAcc(cexAig,lit);
            Ddi_Free(lit);
          }
        }
      }
    }
  }

  if (incrSat==NULL) {
    aig2CnfIdClose(ddm);
    delete S22;
  }

  return (cexAig);
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatMinisat22SubsetWithCexIncremental
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *forSubs,
  float subsetRatio,
  int asserted,
  float timeLimit,
  int *pAbort,
  Ddi_Mgr_t *ddmAux
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat, fCnf;
  Ddi_Bdd_t *cexAig = NULL;
  int enEliminate = 0;

  static int ncalls=0;
  ncalls++;

  vec<Lit> assumps, blocking;

  Minisat22Solver *S22;
  Minisat::SimpSolver *S22s;
  if (incrSat!=NULL) {
    //    Ddi_IncrSatMgrLockAig(incrSat,f);
    enEliminate = incrSat->enSimplify;
    S22 = (Minisat22Solver *)incrSat->S22;
    if (S22==NULL) {
      S22s = (Minisat::SimpSolver *)incrSat->S22simp;
      if (S22s!=NULL) {
	if (!S22s->okay()) {
	  sat = 0;
	  return (NULL);
	}
      }
      else if (incrSat->lgl!=NULL) {
	sat = 0;
      }
    }
    else {
      Pdtutil_Assert(S22!=NULL,"missing solver");
      if (!S22->okay()) {
	sat = 0;
	return (NULL);
      }
    }
  }
  else {
    S22 = new Minisat22Solver();
    aig2CnfIdInit(ddm);
  }

  assumps.clear();
  blocking.clear();

  if (Ddi_BddIsZero(f)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(f)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  if (incrSat!=NULL) {
    MinisatClausesIncr(incrSat,f,NULL,NULL,!asserted);
  }
  else {
    Minisat22Clauses((void *)S22,f,NULL,NULL,!asserted);
  }

  if (!asserted) {
    if (Ddi_BddIsPartConj(f)) {
      int i;
      for (i=0; i<Ddi_BddPartNum(f); i++) {
	Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
	if (!Ddi_BddIsOne(f_i)) {
	  bAigEdge_t baig = f_i->data.aig->aigNode;
	  fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
	    aig2CnfId(ddm->aig.mgr,baig);
	  if (S22!=NULL)
	    Pdtutil_Assert(abs(fCnf) <= S22->nVars(),"missing solver var");
	  assumps.push(MinisatLit(fCnf));
	  blocking.push(MinisatLit(-fCnf));
	}
      }
    }
    else {
      if (!Ddi_BddIsOne(f)) {
	bAigEdge_t baig = f->data.aig->aigNode;
	fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
	  aig2CnfId(ddm->aig.mgr,baig);
	if (S22!=NULL)
	  Pdtutil_Assert(abs(fCnf) <= S22->nVars(),"missing solver var");
	assumps.push(MinisatLit(fCnf));
	blocking.push(MinisatLit(-fCnf));
      }
    }
  }

  if (pAbort) *pAbort = 0;

  if (incrSat!=NULL && incrSat->lgl!=NULL) {
    int lglAssump, i, res, startFreeze;
    for (i=0; i<assumps.size(); i++) {
      lglAssump = var(assumps[i])+1;
      lglfreeze(incrSat->lgl,lglAssump);
      if (sign(assumps[i])) lglAssump = -lglAssump;
      lglassume (incrSat->lgl, lglAssump);
    }
    startFreeze = incrSat->lglMaxFrozen+1;
    for (i=startFreeze; i<=lglmaxvar(incrSat->lgl); i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (!bAig_isVarNode(bmgr,baig)) continue;
      if (cnfReadActive(ddm,i)) {
	lglfreeze(incrSat->lgl,i);
      }
    }
    incrSat->lglMaxFrozen = lglmaxvar(incrSat->lgl);
    //    LGL *clone = lglclone(incrSat->lgl);
    res = lglsat (incrSat->lgl);
    //    lglunclone (incrSat->lgl, clone);
    //    lglrelease (clone);
    if (incrSat->enLglLearn) {
      Ddi_Free(incrSat->refA);
      Ddi_Free(incrSat->eqA);
      incrSat->refA = Ddi_BddarrayAlloc(ddm, 0);
      incrSat->eqA = Ddi_BddarrayAlloc(ddm, 0);
      incrSat->implied =
        Ddi_AigSatImpliedLearningIncremental(incrSat,
              f,NULL/*auxImplDup*/,incrSat->refA,incrSat->eqA);
    }    
    for (i=1; i<=lglmaxvar(incrSat->lgl); i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (bAig_isVarNode(bmgr,baig)) continue;
      if (cnfReadActive(ddm,i)) {
	if (!lglreusable (incrSat->lgl, i)) {
	  cnfId2AigClear(ddm, incrSat->cnfMappedVars, i);
	}
	else {
	  lglreuse (incrSat->lgl, i);
	}
      }
    }

    switch (res) {
    case 10: sat=1; break;
    case 20: sat=0; break;
    case 0: 
    default: sat=-1; break;
    }
  }
  else if (!S22->okay()) {
    cexAig = NULL;
    sat = 0;
  }
  else {
    Minisat::vec<Minisat::Lit> assumps22;
    if (enEliminate) Minisat22FreezeAig (S22,f);
    MinisatTo22(assumps22,assumps);
    //    printf("solving CNF instance: v: %d, c: %d\n", S22->nVars(), S22->nClauses());
    if (timeLimit >= 0) {
      S22->setTimeBudget((double)timeLimit);
      Ddi_Vararray_t *vA = Ddi_BddSuppVararray(f);
      if (enEliminate) Minisat22FreezeVars (S22,ddm,NULL);
      if (enEliminate) S22->eliminate(false);
      sat = S22->solveLimitedInt(assumps22);
      if (enEliminate) Minisat22ReleaseEliminatedVars (S22,ddm,
				  incrSat?incrSat->cnfMappedVars:NULL);
      Ddi_Free(vA);
    }
    else {
      Ddi_Vararray_t *vA = Ddi_BddSuppVararray(f);
      if (enEliminate) Minisat22FreezeVars (S22,ddm,NULL);
      if (enEliminate) S22->eliminate(false);
      sat = S22->solve(assumps22,false,true);
      if (enEliminate) Minisat22ReleaseEliminatedVars (S22,ddm,
				  incrSat?incrSat->cnfMappedVars:NULL);
      Ddi_Free(vA);
    }
    //    sat = S->okay();
  }
  if (sat == -1) {
    if (pAbort) *pAbort = 1;
  }
  else if (0 && (sat==0)) {
    /* add blocking clause */
    if (blocking.size()>0) {
      if (incrSat->lgl!=NULL) {
	LglAddClause(incrSat->lgl,blocking);
      }
      else {
	Minisat::vec<Minisat::Lit> blocking22;
	MinisatTo22(blocking22,blocking);
	S22->addClause(blocking22);
      }
    }
  }

  if (sat>0)
  {
    int i;
    cexAig = Ddi_BddMakeConstAig(ddm,1);
    Ddi_BddSetPartConj(cexAig);

    bAig_array_t *visitedNodes = bAigArrayAlloc();
    Ddi_PostOrderBddAigVisitIntern(forSubs,visitedNodes,-1);
    postOrderAigClearVisitedIntern(bmgr,visitedNodes);
    aigArrayClearAuxAigIntern(bmgr,visitedNodes);
    bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,-1);

    int cnt=0;
    int maxCnt = 0;
    static int doChk = 0;
    Ddi_Bdd_t *cexPi = Ddi_BddMakeConstAig(ddm, 1);
    
    for (int i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
        int vBaig = aig2CnfId(bmgr,baig);
        int vSat = vBaig-1;
        bAigEdge_t baigNI = bAig_NonInvertedEdge(baig);
        int val;
        if (incrSat && incrSat->lgl!=NULL) {
          val = lglderef (incrSat->lgl, vBaig);
        }
        else {
          val = 0;
          if (S22->model[vSat] == l_True22) {
            val = 1;
          }
          else if (S22->model[vSat] == l_False22) {
            val = -1;
          }
          assert(val!=0);
        }
        if (val>0)
          bAig_AuxAig0(bmgr,baig) = bAig_One; 
        else
          bAig_AuxAig0(bmgr,baig) = bAig_Zero; 
        if (doChk) {
          Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
          Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,val>0);
          Ddi_BddAndAcc(cexPi,lit);
          Ddi_Free(lit);
        }
        continue;
      }
      maxCnt++;
    }
    maxCnt *= subsetRatio;

    newAigEvalIntern(ddm,visitedNodes);

    for (int i0=0; i0<visitedNodes->num; i0++) {
      int i=visitedNodes->num-1-i0;
      bAigEdge_t baig = visitedNodes->nodes[i];
      if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
        continue;
      }
      if (cnt++>maxCnt) break;
      
      bAigEdge_t baigNI = bAig_NonInvertedEdge(baig);
      bAigEdge_t val = bAig_AuxAig0(bmgr,baig);
      Ddi_Bdd_t *f_i = Ddi_BddMakeFromBaig(ddm,baigNI);
      if (val==bAig_Zero) {
        Ddi_BddNotAcc(f_i);
      }
      Ddi_BddPartInsertLast(cexAig,f_i);
      Ddi_Free(f_i);
    }

    bAigArrayClearFreeAuxAig(bmgr,visitedNodes);
    bAigArrayFree(visitedNodes);

    if (doChk) {
      Ddi_Bdd_t *w =
        Ddi_AigSatMinisat22WithCexAndAbortIncremental(incrSat,
          cexAig, 0, 0, -1, NULL);
      if (w==NULL) {
        printf("found UNSAT\n");
      }
      Ddi_Free(w);
      Ddi_Bdd_t *fCof = Ddi_BddCopy(ddmAux,f);
      Ddi_Bdd_t *cexPiAux = Ddi_BddCopy(ddmAux,cexPi);
      Ddi_AigConstrainCubeAcc(fCof,cexPiAux);
      for (int i=Ddi_BddPartNum(fCof)-1; i>0; i--) {
        Ddi_Bdd_t *f_i = Ddi_BddPartRead(fCof,i);
        if (!Ddi_AigSat(f_i)) {
          printf("found UNSAT part: %d\n", i);
        }
        Ddi_BddPartQuickRemove(fCof,i);
        if (Ddi_AigSat(fCof)) {
          printf("found SAT: %d\n", i);
        }
      }
      Ddi_Free(fCof);
      Ddi_Free(cexPiAux);
    }
    Ddi_Free(cexPi);

    Ddi_Bdd_t *aux = Ddi_BddMakeAig(forSubs);
    Ddi_BddPartInsertLast(cexAig,aux);
    Ddi_Free(aux);
    Ddi_AigStructRedRemAcc(cexAig, NULL);
    Ddi_BddSetAig(cexAig);
  }

  return (cexAig);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatMinisat22WithAbortAndFinal
(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *constrCube,
  int doGen,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat, constrCubeNum = 0, isCube=1;
  Minisat22Solver S22;
  vec<Lit> assumps;

  if (Ddi_BddIsConstant(f)) {
    return(Ddi_BddIsOne(f));
  }

  isCube = Ddi_BddIsCube(constrCube);

  aig2CnfIdInit(ddm);
  Minisat22Clauses((void *)&S22,f,NULL,NULL,0);

  assumps.clear();

  if (constrCube != NULL) {
    isCube = Ddi_BddIsCube(constrCube);
    Ddi_Bdd_t *constrPart = Ddi_AigPartitionTop(constrCube,0);
    int j;
    constrCubeNum = Ddi_BddPartNum(constrPart);
    if (!isCube) {
      Minisat22Clauses((void *)&S22,constrPart,NULL,NULL,1);
    }
    for (j=0; j<Ddi_BddPartNum(constrPart); j++) {
      Ddi_Bdd_t *c_j = Ddi_BddPartRead(constrPart,j);
      bAigEdge_t baig = Ddi_BddToBaig(c_j);
      int cCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(bmgr,baig) :
	aig2CnfId(bmgr,baig);
      while (abs(cCnf) > S22.nVars()) S22.newVar();
      assumps.push(MinisatLit(cCnf));
    }
    Ddi_Free(constrPart);
  }
  if (!S22.okay()) {
    aig2CnfIdClose(ddm);
    return 0;
  }

  Minisat::vec<Minisat::Lit> assumps22;
  MinisatTo22(assumps22,assumps);

  if (timeLimit >= 0) {
    S22.setTimeBudget((double)timeLimit);
    sat = S22.solveLimitedInt(assumps22);
  }
  else {
    sat = S22.solve(assumps22,false,true);
  }

  if (sat == -1) {
  }
  else if (!sat && (constrCube != NULL)) {
    Ddi_Bdd_t *constrFinal = Ddi_BddMakeConstAig(ddm, 1);
    int k;

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMax_c) {
      printf("solver final selected %d/%d vars\n", S22.conflict.size(),
	   constrCubeNum);
    }
    Minisat::vec<Minisat::Lit> conflict;
    Minisat::vec<Minisat::Lit> conflict2;
    Minisat::vec<Minisat::Lit> assumps2;
    Minisat::vec<Minisat::Lit> assumps3;
    for (k=0; k<S22.conflict.size(); k++) {
      Minisat::Lit kLit = S22.conflict[k];
      conflict.push(kLit);
      assumps2.push(~kLit);
    }
    assert(!S22.solve(assumps2,false,true));
    for (k=0; k<conflict.size(); k++) {
      Ddi_Bdd_t *lit;
      Minisat::Lit kLit = conflict[k];
      int vSat = var(kLit);
      int signSat = sign(kLit);
      int vCnf = vSat+1;
      bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];

      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      int useLit = 1;
      if (doGen) {
        assumps2.clear();
        conflict[k] = Minisat::lit_Undef;
        for (int k1=0; k1<conflict.size(); k1++) {
          if (conflict[k1] != Minisat::lit_Undef) {
            assumps2.push(~conflict[k1]);              
          }
        }
	S22.setTimeBudget((double)0.05);
	int sat2 = S22.solveLimitedInt(assumps2);
        if (sat2<0 || sat2) {
          // undo remove lit
          conflict[k] = kLit;
          conflict2.push(kLit);
          assumps3.push(~kLit);
        }
        else {
          useLit = 0;
        }
      }
      if (useLit) {
        if (v!=NULL) {
          /* conflict has complemented literals w.r.t. assump !!! */
          lit = Ddi_BddMakeLiteralAig(v,signSat);
          Ddi_BddAndAcc(constrFinal,lit);
          Ddi_Free(lit);

        }
        else {
          Ddi_Bdd_t *e = Ddi_BddMakeFromBaig(ddm,baig);
          Ddi_BddAndAcc(constrFinal,e);
          Ddi_Free(e);
        }
      }
    }
    Ddi_DataCopy(constrCube,constrFinal);

    Ddi_Free(constrFinal);
  }

  aig2CnfIdClose(ddm);

  return sat;
}
/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatMinisat22RemoveCoreFinal
(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *constr,
  int doGen,
  float timeLimit,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat, constrNum = 0, isCube=1;
  Minisat22Solver S22;
  vec<Lit> assumps;

  if (Ddi_BddIsConstant(f) && constr==NULL) {
    return(Ddi_BddDup(f));
  }

  isCube = Ddi_BddIsCube(constr);

  aig2CnfIdInit(ddm);
  Minisat22Clauses((void *)&S22,f,NULL,NULL,0);

  assumps.clear();

  Ddi_Bdd_t *constrPart = NULL;
  if (constr != NULL) {
    isCube = Ddi_BddIsCube(constr);
    constrPart = Ddi_AigPartitionTop(constr,0);
    int j;
    constrNum = Ddi_BddPartNum(constrPart);
    if (!isCube) {
      Minisat22Clauses((void *)&S22,constrPart,NULL,NULL,1);
    }
    for (j=0; j<Ddi_BddPartNum(constrPart); j++) {
      Ddi_Bdd_t *c_j = Ddi_BddPartRead(constrPart,j);
      bAigEdge_t baig = Ddi_BddToBaig(c_j);
      int cCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(bmgr,baig) :
	aig2CnfId(bmgr,baig);
      while (abs(cCnf) > S22.nVars()) S22.newVar();
      assumps.push(MinisatLit(cCnf));
    }
  }
  if (!S22.okay()) {
    aig2CnfIdClose(ddm);
    Ddi_Free(constrPart);
    return NULL;
  }

  Minisat::vec<Minisat::Lit> assumps22;
  MinisatTo22(assumps22,assumps);

  if (timeLimit >= 0) {
    S22.setTimeBudget((double)timeLimit);
    sat = S22.solveLimitedInt(assumps22);
  }
  else {
    sat = S22.solve(assumps22,false,true);
  }

  Ddi_Bdd_t *constrNoFinal = Ddi_BddMakePartConjVoid(ddm);
  Ddi_Bdd_t *constrFinal = NULL;

  if (sat == -1) {
    Ddi_Free(constrNoFinal);
  }
  else if (sat > 0) {
    Ddi_Free(constrNoFinal);
    constrNoFinal = Ddi_BddDup(constrPart);
  }
  else if (!sat && (constr != NULL)) {
    bAig_array_t *finalNodes = bAigArrayAlloc();
    int k;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMax_c) {
      printf("solver final selected %d/%d vars\n", S22.conflict.size(),
	   constrNum);
    }
    Minisat::vec<Minisat::Lit> conflict;
    Minisat::vec<Minisat::Lit> conflict2;
    Minisat::vec<Minisat::Lit> assumps2;
    Minisat::vec<Minisat::Lit> assumps3;
    for (k=0; k<S22.conflict.size(); k++) {
      Minisat::Lit kLit = S22.conflict[k];
      conflict.push(kLit);
      assumps2.push(~kLit);
    }
    assert(!S22.solve(assumps2,false,true));
    for (k=0; k<conflict.size(); k++) {
      Ddi_Bdd_t *lit;
      Minisat::Lit kLit = conflict[k];
      int vSat = var(kLit);
      int signSat = sign(kLit);
      int vCnf = vSat+1;
      int useLit = 1;
      if (doGen) {
        assumps2.clear();
        conflict[k] = Minisat::lit_Undef;
        for (int k1=0; k1<conflict.size(); k1++) {
          if (conflict[k1] != Minisat::lit_Undef) {
            assumps2.push(~conflict[k1]);              
          }
        }
	S22.setTimeBudget((double)0.05);
	int sat2 = S22.solveLimitedInt(assumps2);
        if (sat2<0 || sat2) {
          // undo remove lit
          conflict[k] = kLit;
          conflict2.push(kLit);
          assumps3.push(~kLit);
        }
        else {
          useLit = 0;
        }
      }
      if (useLit) {
        bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
        bAigArrayPush(finalNodes,baig);
        bAig_AuxInt(bmgr,baig) = 1;
      }
    }
    constrFinal = Ddi_BddMakePartConjVoid(ddm);
    for (int i=0; i<Ddi_BddPartNum(constrPart); i++) {
      Ddi_Bdd_t *c_i = Ddi_BddPartRead(constrPart,i);
      bAigEdge_t baig = Ddi_BddToBaig(c_i);
      if (bAig_AuxInt(bmgr,baig)<=0) {
        Ddi_BddPartInsertLast(constrNoFinal,c_i);
      }
      else {
        Ddi_BddPartInsertLast(constrFinal,c_i);
      }
    }
    Ddi_AigArrayClearAuxInt(bmgr,finalNodes);
    if (Ddi_BddPartNum(constrFinal)==0) {
      Ddi_Free(constrFinal);
    }
    else 
      Ddi_DataCopy(constr,constrNoFinal);
  }
  
  Ddi_Free(constrPart);
  aig2CnfIdClose(ddm);

  return constrFinal;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSatMinisat22WithCexAigAndAbortIncremental
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *f,
  int nSatVars,
  int asserted,
  float timeLimit,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat, fCnf;
  Ddi_Bdd_t *cexAig = NULL;
  int enEliminate = 0;

  static int ncalls=0;
  ncalls++;

  vec<Lit> assumps, blocking;
  Pdtutil_Assert(incrSat==NULL || incrSat->lgl==NULL,"lgl not yet supported");

  Minisat22Solver *S22;
  Minisat::SimpSolver *S22s;
  if (incrSat!=NULL) {
    Ddi_IncrSatMgrLockAig(incrSat,f);
    enEliminate = incrSat->enSimplify;
    S22 = (Minisat22Solver *)incrSat->S22;
    if (S22==NULL) {
      S22s = (Minisat::SimpSolver *)incrSat->S22simp;
      if (S22s!=NULL) {
	if (!S22s->okay()) {
	  sat = 0;
	  return (NULL);
	}
      }
      else if (incrSat->lgl!=NULL) {
	sat = 0;
      }
    }
    else {
      Pdtutil_Assert(S22!=NULL,"missing solver");
      if (!S22->okay()) {
	sat = 0;
	return (NULL);
      }
    }
  }
  else {
    S22 = new Minisat22Solver();
    aig2CnfIdInit(ddm);
  }

  assumps.clear();
  blocking.clear();

  if (Ddi_BddIsZero(f)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(f)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  if (incrSat!=NULL) {
    MinisatClausesIncr(incrSat,f,NULL,NULL,!asserted);
  }
  else {
    Minisat22Clauses((void *)S22,f,NULL,NULL,!asserted);
  }

  if (!asserted) {
    if (Ddi_BddIsPartConj(f)) {
      int i;
      for (i=0; i<Ddi_BddPartNum(f); i++) {
	Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
	if (!Ddi_BddIsOne(f_i)) {
	  bAigEdge_t baig = f_i->data.aig->aigNode;
	  fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
	    aig2CnfId(ddm->aig.mgr,baig);
	  if (S22!=NULL)
	    Pdtutil_Assert(abs(fCnf) <= S22->nVars(),"missing solver var");
	  assumps.push(MinisatLit(fCnf));
	  blocking.push(MinisatLit(-fCnf));
	}
      }
    }
    else {
      if (!Ddi_BddIsOne(f)) {
	bAigEdge_t baig = f->data.aig->aigNode;
	fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
	  aig2CnfId(ddm->aig.mgr,baig);
	if (S22!=NULL)
	  Pdtutil_Assert(abs(fCnf) <= S22->nVars(),"missing solver var");
	assumps.push(MinisatLit(fCnf));
	blocking.push(MinisatLit(-fCnf));
      }
    }
  }

  if (pAbort) *pAbort = 0;
  
  if (incrSat!=NULL && incrSat->lgl!=NULL) {
    int lglAssump, i, res, startFreeze;
    for (i=0; i<assumps.size(); i++) {
      lglAssump = var(assumps[i])+1;
      lglfreeze(incrSat->lgl,lglAssump);
      if (sign(assumps[i])) lglAssump = -lglAssump;
      lglassume (incrSat->lgl, lglAssump);
    }
    startFreeze = incrSat->lglMaxFrozen+1;
    for (i=startFreeze; i<=lglmaxvar(incrSat->lgl); i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (!bAig_isVarNode(bmgr,baig)) continue;
      if (cnfReadActive(ddm,i)) {
	lglfreeze(incrSat->lgl,i);
      }
    }
    incrSat->lglMaxFrozen = lglmaxvar(incrSat->lgl);
    //    LGL *clone = lglclone(incrSat->lgl);
    res = lglsat (incrSat->lgl);
    //    lglunclone (incrSat->lgl, clone);
    //    lglrelease (clone);
    if (incrSat->enLglLearn) {
      Ddi_Free(incrSat->refA);
      Ddi_Free(incrSat->eqA);
      incrSat->refA = Ddi_BddarrayAlloc(ddm, 0);
      incrSat->eqA = Ddi_BddarrayAlloc(ddm, 0);
      incrSat->implied =
        Ddi_AigSatImpliedLearningIncremental(incrSat,
              f,NULL/*auxImplDup*/,incrSat->refA,incrSat->eqA);
    }    
    for (i=1; i<=lglmaxvar(incrSat->lgl); i++) {
      bAigEdge_t baig = ddm->cnf.cnf2aig[i];
      if (bAig_isVarNode(bmgr,baig)) continue;
      if (cnfReadActive(ddm,i)) {
	if (!lglreusable (incrSat->lgl, i)) {
	  cnfId2AigClear(ddm, incrSat->cnfMappedVars, i);
	}
	else {
	  lglreuse (incrSat->lgl, i);
	}
      }
    }

    switch (res) {
    case 10: sat=1; break;
    case 20: sat=0; break;
    case 0: 
    default: sat=-1; break;
    }
  }
  else if (!S22->okay()) {
    cexAig = NULL;
    sat = 0;
  }
  else {
    Minisat::vec<Minisat::Lit> assumps22;
    if (enEliminate) Minisat22FreezeAig (S22,f);
    MinisatTo22(assumps22,assumps);
    //    printf("solving CNF instance: v: %d, c: %d\n", S22->nVars(), S22->nClauses());
    S22->enableVarDecisions();
    
    if (timeLimit >= 0) {
      S22->setTimeBudget((double)timeLimit);
      Ddi_Vararray_t *vA = Ddi_BddSuppVararray(f);
      if (enEliminate) Minisat22FreezeVars (S22,ddm,NULL);
      if (enEliminate) S22->eliminate(false);
      sat = S22->solveLimitedInt(assumps22);
      if (enEliminate) Minisat22ReleaseEliminatedVars (S22,ddm,
				  incrSat?incrSat->cnfMappedVars:NULL);
      Ddi_Free(vA);
    }
    else {
      Ddi_Vararray_t *vA = Ddi_BddSuppVararray(f);
      if (enEliminate) Minisat22FreezeVars (S22,ddm,NULL);
      if (enEliminate) S22->eliminate(false);
      sat = S22->solve(assumps22,false,true);
      if (enEliminate) Minisat22ReleaseEliminatedVars (S22,ddm,
				  incrSat?incrSat->cnfMappedVars:NULL);
      Ddi_Free(vA);
    }
    //    sat = S->okay();
  }
  if (sat == -1) {
    if (pAbort) *pAbort = 1;
  }
  else if (sat==0) {
    /* add blocking clause */
    if (blocking.size()>0) {
      if (incrSat->lgl!=NULL) {
	LglAddClause(incrSat->lgl,blocking);
      }
      else {
	Minisat::vec<Minisat::Lit> blocking22;
	MinisatTo22(blocking22,blocking);
	S22->addClause(blocking22);
      }
    }
  }

  if (sat>0)
  {
    int i;
    cexAig = Ddi_BddMakeConstAig(ddm,1);

    if (incrSat && incrSat->lgl!=NULL) {
      for (i=1; i<=lglmaxvar(incrSat->lgl); i++) {
	int vCnf = i;
	bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	if (bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
	  int val = lglderef (incrSat->lgl, vCnf);
	  Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
	  if (val<=0) {
	    Ddi_BddNotAcc(lit);
	  }
	  Ddi_BddAndAcc(cexAig,lit);
	  Ddi_Free(lit);
	}
      }
    }
    else {
      int ii;
      Minisat::vec<Minisat::Var> topv22;
      Minisat::vec<int> topd;
      Minisat::vec<double> topa;
      int mind = 10;
      double mina = 0.0;
      //      S22->topVarDecisions(topv22, topd, ddm->cnf.cnf2aig, nSatVars, mind);
      S22->topVarActivity(topv22, topa, ddm->cnf.cnf2aig, nSatVars, mina);
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        fprintf(dMgrO(ddm),"Top solver activity vars:");
        for (ii=0; ii<topa.size(); ii++) {
          fprintf(dMgrO(ddm)," %g", topa[ii]);
        }
        fprintf(dMgrO(ddm),"\n");
      }
      for (ii=0; ii<topv22.size(); ii++) {
        int i = (int)topv22[ii];
        if (S22->model[i] != l_Undef22) {
          int vCnf = i+1;
          bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          // Pdtutil_Assert(baig!=bAig_NULL,"Null baig");
          if (bAig_isVarNode(bmgr,baig) && !bAig_NodeIsConstant(baig)) {
            Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
            Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v,1);
            if (S22->model[i]!=l_True22) {
              Ddi_BddNotAcc(lit);
            }
            Ddi_Free(lit);
          }
          else if (baig != bAig_NULL) {
            Ddi_Bdd_t *lit = Ddi_BddMakeFromBaig(ddm, baig);
            if (S22->model[i]!=l_True22) {
              Ddi_BddNotAcc(lit);
            }
            Ddi_BddAndAcc(cexAig,lit);
            Ddi_Free(lit);
          }
        }
      }
    }
  }

  if (incrSat==NULL) {
    aig2CnfIdClose(ddm);
    delete S22;
  }

  return (cexAig);
}



/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
int
Ddi_AigSatMinisat22WithAbortIncremental
(
  Ddi_IncrSatMgr_t *incrSat,
  Ddi_Bdd_t *f,
  Ddi_Vararray_t *filterVars,
  float timeLimit,
  int *pAbort
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int sat, fCnf;

  static int ncalls=0;
  ncalls++;

  Minisat22Solver *S22 = (Minisat22Solver *)incrSat->S22;
  vec<Lit> assumps, blocking;
  assumps.clear();
  blocking.clear();

  Pdtutil_Assert(S22!=NULL,"missing solver");

  if (Ddi_BddIsZero(f)) {
    return 0;
  }
  if (Ddi_BddIsOne(f)) {
    return (1);
  }

  MinisatClausesIncr(incrSat,f,NULL,NULL,1);
  if (Ddi_BddIsPartConj(f)) {
    int i;
    for (i=0; i<Ddi_BddPartNum(f); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
      if (!Ddi_BddIsOne(f_i)) {
        bAigEdge_t baig = f_i->data.aig->aigNode;
        fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                      aig2CnfId(ddm->aig.mgr,baig);
        Pdtutil_Assert(abs(fCnf) <= S22->nVars(),"missing solver var");
        assumps.push(MinisatLit(fCnf));
        blocking.push(MinisatLit(-fCnf));
      }
    }
  }
  else {
    if (!Ddi_BddIsOne(f)) {
      bAigEdge_t baig = f->data.aig->aigNode;
      fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
        aig2CnfId(ddm->aig.mgr,baig);
      Pdtutil_Assert(abs(fCnf) <= S22->nVars(),"missing solver var");
      assumps.push(MinisatLit(fCnf));
      blocking.push(MinisatLit(-fCnf));
    }
  }

  if (pAbort) *pAbort = 0;

  if (!S22->okay()) {
    sat = 0;
  }
  else {
    Minisat::vec<Minisat::Lit> assumps22;
    MinisatTo22(assumps22,assumps);
    //    printf("solving CNF instance: v: %d, c: %d\n", S22->nVars(), S22->nClauses());

    sat = S22->solve(assumps22);
    //    sat = S->okay();
  }
  if (0/*S22->undefined()*/) {
    sat = -1;
    if (pAbort) *pAbort = 1;
  }
  else if (0 && (sat==0)) {
    /* add blocking clause */
    if (blocking.size()>0) {
      Minisat::vec<Minisat::Lit> blocking22;
      MinisatTo22(blocking22,blocking);
      S22->addClause(blocking22);
    }
  }

  return (sat);
}
/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
aigSatGetActLiterals
(
  Ddi_Bdd_t *f,
  vec<Lit>& lits
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int n=0;

  if (Ddi_BddIsPartConj(f)) {
    int i, fCnf;
    for (i=0; i<Ddi_BddPartNum(f); i++) {
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(f,i);
      if (!Ddi_BddIsOne(f_i)) {
        bAigEdge_t baig = f_i->data.aig->aigNode;
        fCnf = bAig_NodeIsInverted(baig) ? -aig2CnfId(ddm->aig.mgr,baig) :
                                      aig2CnfId(ddm->aig.mgr,baig);
        lits.push(MinisatLit(fCnf));
	n++;
      }
    }
  }
  else {
    if (!Ddi_BddIsOne(f)) {
      bAigEdge_t baig = f->data.aig->aigNode;
      int fCnf = bAig_NodeIsInverted(baig) ? 
	-aig2CnfId(ddm->aig.mgr,baig) :
        aig2CnfId(ddm->aig.mgr,baig);
      lits.push(MinisatLit(fCnf));
      n++;
    }
  }

  return (n);
}


/**Function********************************************************************
  Synopsis    [Extract core clauses from Minisat 2.2]
  Description [Extract core clauses from Minisat 2.2]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
Minisat22Core (
  void *S22void,
  Ddi_Mgr_t *ddm,
  vec<Var>& coreVars,
  vec<vec<Lit> >& coreClauses
)
{
  int i, j;
  Minisat22Solver* S = (Minisat22Solver *)S22void;

  //Traverse proof
  Minisat::TraceProofVisitor v(*S, stdout);
  S->validate(v);

  //Extract core clauses
  Minisat::vec< Minisat::vec<Minisat::Lit> > coreClauses22;
  Minisat::vec<Minisat::Var> coreVars22;
  S->getCore(coreClauses22, coreVars22);

  //Transfer core clauses to minisat 1.14 vector
  for (i = 0; i < coreClauses22.size(); ++i){
    coreClauses.push();
    for(j=0; j<coreClauses22[i].size(); ++j){
      Lit lit(Minisat::var(coreClauses22[i][j]), Minisat::sign(coreClauses22[i][j]));
      coreClauses[i].push(lit);
    }
  }

  //Transfer core variables to minisat 1.1.4 vector
  for(i = 0; i < coreVars22.size(); ++i){
    coreVars.push(coreVars22[i]);
  }

  //Output
  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
     fprintf(dMgrO(ddm),"core size %d vars / %d clauses\n", coreVars.size(), coreClauses.size()));

  return coreClauses.size();
}


/**Function********************************************************************
  Synopsis    [Extract core clauses from Minisat 2.2]
  Description [Extract core clauses from Minisat 2.2]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
nnfAndFindOdc(
  void *pS22void,
  Ddi_Mgr_t *ddm,
  bAigEdge_t *cutBaigs,
  int nPin,
  long *unsatTimeP
)
{
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;
  int i, pin, f_i, neg_i, nRed=0;
  long unsatTime;
  Minisat::vec<Minisat::Lit> assume;

  for (pin=0; pin<nPin; pin++) {
    int sat;
    assume.clear();

    for (i=0; i<nPin; i++) {
      bAigEdge_t baig_i = cutBaigs[i];
      if (baig_i == bAig_NULL) {
	Pdtutil_Assert(i!=pin,"wrong NULL baig");
	continue;
      }
      f_i = aig2CnfId(bmgr,baig_i);
      neg_i = bAig_NodeIsInverted(baig_i);
      if (neg_i) f_i = -f_i;

      if (i==pin) f_i = -f_i; 

      assume.push(Minisat22Lit(f_i));
    }
    unsatTime = util_cpu_time();
    sat = pS22->solve(assume);
    if (!sat) {
      // redundancy found - disable pin
      cutBaigs[pin] = bAig_NULL;
      if (unsatTimeP!=NULL) {
	unsatTime = util_cpu_time() - unsatTime;
	*unsatTimeP += unsatTime;
      }
      nRed++;
    }

  }

  return nRed;
}

/**Function********************************************************************
  Synopsis    [Extract core clauses from Minisat 2.2]
  Description [Extract core clauses from Minisat 2.2]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
nnfAndFindOdcIncr(
  void *pS22void,
  Ddi_Mgr_t *ddm,
  bAigEdge_t *cutBaigs,
  int nPin,
  long *unsatTimeP
)
{
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;
  int i, pin, f_i, a_i, o_i, neg_i, nRed=0;
  long unsatTime;
  Minisat::vec<Minisat::Lit> assume;
  Minisat::vec<Minisat::Lit> aLits;
  Minisat::vec<Minisat::Lit> oLits;
  Minisat::vec<char> enabled;

  aLits.clear();
  oLits.clear();
  enabled.clear();

  int a_0 = 0;
  for (i=0; i<nPin; i++, a_0=a_i) {
    enabled.push((char)1);
    bAigEdge_t baig_i = cutBaigs[i];
    Pdtutil_Assert (baig_i != bAig_NULL, "Null baig in cut");
    neg_i = bAig_NodeIsInverted(baig_i);
    f_i = aig2CnfId(bmgr,baig_i);
    if (neg_i) f_i = -f_i;
    if (i==0) {
      a_i = f_i;
    }
    else {
      a_i = aig2CnfNewIdIntern(ddm);
      o_i = aig2CnfNewIdIntern(ddm);
      Pdtutil_Assert(a_0!=0,"no prev_a_i found");
      // !a_0 -> !a_i
      Minisat22Clause2(pS22,a_0,-a_i);
      // !f_i -> !a_i
      Minisat22Clause2(pS22,f_i,-a_i);
      // a_0&f_i -> a_i
      Minisat22Clause3(pS22,-a_0,-f_i,a_i);
      aLits.push(Minisat22Lit(a_i));
      // o_i -> a_0|f_i 
      Minisat22Clause3(pS22,a_0,f_i,-o_i);
      oLits.push(Minisat22Lit(o_i));
    }
  }
  oLits.copyTo(assume); // assume all ORs set
  assume.push(~aLits[nPin-2]); // assume final AND = 0

  int nIter=0, nEn = enabled.size();
  while (nEn>0) {
    int sat;
    nIter++;
    unsatTime = util_cpu_time();
    sat = pS22->solve(assume);
    if (nIter>nPin) Pdtutil_Assert(!sat,"unsat needed at last round");
    if (!sat) {
      // redundancy found - disable pin
      if (unsatTimeP!=NULL) {
	unsatTime = util_cpu_time() - unsatTime;
	*unsatTimeP += unsatTime;
      }

      for (i=0; i<nPin; i++) {
	if (enabled[i]) {
	  int j, cnt1 = 0, jlit=i==0?0:i-1;
	  Minisat::vec<Minisat::Lit> assumeAux;
	  cutBaigs[i] = bAig_NULL;
	  nRed++;
	  enabled[i] = (char)0;
	  nEn--;
#if 0
	  assumeAux.clear();
	  for (j=0; j<assume.size(); j++) {
	    if (assume[j]!=oLits[jlit]) {
	      assumeAux.push(assume[j]);
	    }
	    else {
	      cnt1++;
	    }
	  }
	  assumeAux.copyTo(assume);
	  Pdtutil_Assert(cnt1<=1,"missing or constrainr");
#endif
	  break;
	}
      }
      break;
    }
    else {
      // find the single zero
      int cnt=0;
      for (i=0; i<nPin; i++) {
	if (enabled[i]>0) {
	  bAigEdge_t baig_i = cutBaigs[i];
	  f_i = aig2CnfId(bmgr,baig_i);
	  neg_i = bAig_NodeIsInverted(baig_i);
	  if (pS22->model[f_i-1] == (neg_i ? l_True22 : l_False22)) {
	    cnt++;
	    if (neg_i) f_i = -f_i;
	    assume.push(Minisat22Lit(f_i));
	    enabled[i] = (char)0;
	    nEn--;
	  }
	}
      }
      Pdtutil_Assert(cnt==1,"multiple 0");
    }

  }

  return nRed;
}



/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_ItpWeakenByRefinement (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *care
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *a2;
  Ddi_Bdd_t *aPart, *a2Part;
  int i,n,frontier,nRem;
  int sizeTot = Ddi_BddSize(a);
  int chkRes = 0;
  Ddi_IncrSatMgr_t *ddiS = NULL;

  long unsatTime=0, startTime = util_cpu_time();

  aPart = Ddi_AigPartitionTop(a,0);
  n = Ddi_BddPartNum(aPart);
  if (n<5) {
    Ddi_Free(aPart);
    return Ddi_BddDup(a);
  }

  a2Part = Ddi_BddMakePartConjVoid(ddm);

  // decreasing
  Ddi_BddPartSortBySizeAcc(aPart, 0);

  for (frontier = n/2; frontier>8; frontier /= 2) {
    while (Ddi_BddPartNum(aPart)>frontier) {
      int np = Ddi_BddPartNum(aPart);
      Ddi_Bdd_t *p = Ddi_BddPartExtract(aPart,np-1);
      Ddi_BddPartInsertLast(a2Part,p);
      Ddi_Free(p);
    }
    if (Ddi_BddSize(a2Part) > sizeTot/4) break;
  }

  DdiAig2CnfIdInit(ddm);
  ddiS = Ddi_IncrSatMgrAlloc(NULL,1/*useMinisat22*/, 0,0);
  Ddi_AigSatMinisatLoadClausesIncrementalAsserted(ddiS,a2Part);
  Ddi_AigSatMinisatLoadClausesIncrementalAsserted(ddiS,b);
  if (care!=NULL) {
    Ddi_AigSatMinisatLoadClausesIncrementalAsserted(ddiS,care);
  }

  int found = 0, nSatCalls=0;
  while (!found) {
    Ddi_Bdd_t *cex = Ddi_AigSatMinisat22WithCexAndAbortIncremental(
		       ddiS,a2Part, NULL, 0,-1.0, NULL);
    nSatCalls++;
    /*
    Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(a2Part,b,care,
						  NULL,-1,NULL);
    */
    if (cex!=NULL) {
      int np = Ddi_BddPartNum(aPart);
      int i;
      for (i=np-1; i>=0; i--) {
	Ddi_Bdd_t *p_i = Ddi_BddDup(Ddi_BddPartRead(aPart,i));
	Ddi_AigConstrainCubeAcc(p_i, cex);
	int sat = Ddi_AigSat(p_i);
	Ddi_Free(p_i);
	if (!sat) {
	  // take it
	  p_i = Ddi_BddPartExtract(aPart,i);
	  Ddi_BddPartInsertLast(a2Part,p_i);
	  Ddi_AigSatMinisatLoadClausesIncrementalAsserted(ddiS,p_i);
	  Ddi_Free(p_i);
	  break;
	}
      }
      Pdtutil_Assert(i>=0,"unsat partition not found");
    }
    else {
      found = 1;
    }
  }

  Ddi_IncrSatMgrQuit(ddiS);
  DdiAig2CnfIdCloseNoCheck(ddm);
    
#if 0
  void *S22 = Minisat22NewSolverVoidP();


  aig2CnfIdInit(ddm);

  if (care!=NULL) {
    // do it incremental ???
    Minisat22Clauses(S22,care,NULL,NULL,0);
  }
#endif
  
  a2 = Ddi_BddMakeAig(a2Part);
  nRem = Ddi_BddPartNum(aPart); 
  Ddi_Free(a2Part);
  Ddi_Free(aPart);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    long elapsedTime = util_cpu_time() - startTime;

    fprintf(dMgrO(ddm),
     "ITP WEAKEN BY REFINEMENT #red: %d - s %d->%d ()#SAT calls: %d Time: %s\n", 
	    nRem, sizeTot, Ddi_BddSize(a2), nSatCalls,
	    util_print_time(elapsedTime));
  }

  if (chkRes) {
    Pdtutil_Assert(Ddi_AigSatAnd(a2,b,care),"error in ITP WEAKEN BY REF");
  }

  return(a2);
}



#if 1



/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]<
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSat22AndWithInterpolantPart (
  Ddi_IncrSatMgr_t *incrSat, 
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Varset_t *globalVars,
  Ddi_Varset_t *domainVars,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *prevItp, // *itpPlus,
  int *psat,
  int itpPart,
  int itpOdc,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Bdd_t *itp_i, *itpTot = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *careTot = Ddi_BddMakeConstAig(ddm,1);
  int i, chkres = 0, thVars = itpPart>8 ? 8*itpPart : 1<<itpPart;

  Pdtutil_Assert(itpPart>0,"itpPart required");

  if (optCare!=NULL) {
    Ddi_BddAndAcc(careTot,optCare);
  }

  for (i=0; i<itpPart; i++) {
    Ddi_Bdd_t *myB;
    if (i==itpPart-1) {
      myB = Ddi_BddDup(b);
    }
    else {
      myB = Ddi_AigSatCore(b, careTot,
			   NULL, globalVars, thVars, -1, 4, 0);
      if (thVars>2) thVars /= 2;
    }

    if (myB==NULL) {
      break;
    }

    printf("Itp Part #: %d/%d\n", i, itpPart);
    itp_i =
      Ddi_AigSat22AndWithInterpolant(incrSat,a,myB,NULL,
				     globalVars, domainVars,NULL,0,
				     optCare,NULL,
				     psat, 0, itpOdc, 0, timeLimit);
    Ddi_Free(myB);

    if (itp_i != NULL) {
      Ddi_BddAndAcc(itpTot, itp_i);
      Ddi_BddAndAcc(careTot, itp_i);
      Ddi_Free(itp_i);
    }
    else {
      Ddi_Free(itpTot);
      break;
    }

  }

  Ddi_Free(careTot);
  
  if (chkres && itpTot!=NULL) {
    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,b,optCare),"wrong part itp");
    Ddi_BddNotAcc(itpTot);
    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,a,optCare),"wrong part itp");
    Ddi_BddNotAcc(itpTot);
  }
  else if (chkres && psat!=NULL && *psat) {
    Pdtutil_Assert(Ddi_AigSatAnd(itpTot,b,optCare),"wrong itp sat");
  }

  return itpTot;
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSat22AndWithInterpolantPartNnf (
  Ddi_IncrSatMgr_t *incrSat, 
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *bSplit,
  Ddi_Varset_t *globalVars,
  Ddi_Varset_t *domainVars,
  Ddi_Vararray_t **tfPiVars,
  int tfPiNum,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *itpPlus,
  int *psat,
  int itpPart,
  int itpOdc,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Bdd_t *itp_i=NULL, *itpTot = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *careTot = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *careTotForCex = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *bDup = Ddi_BddDup(b);
  int i, chkresSat=0, 
    chkres = 0, thVars = itpPart>8 ? 8*itpPart : 1<<itpPart;
  int tryCexCore = 0;
  int doForall = 0;
  long startTime, cexTime;
  int mark = Ddi_BddReadMark(b);
  int isSat=0, preSplit=1;
  int nnfSubset = 0, genClauses=0;
  int genCubes = 1;
  int doItpFromGenClauses = 1;

  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitCare = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Varset_t *splitVars = NULL;
  Ddi_Bdd_t *residualSpace = NULL;
  
  if (Ddi_BddReadComposeF(b)!=NULL) {
    splitB = Ddi_BddDup(Ddi_BddReadComposeF(b));
    splitCare = Ddi_BddDup(Ddi_BddReadComposeCare(b));
    splitU = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(b));
    splitV = Ddi_VararrayDup(Ddi_BddReadComposeVars(b));
    splitRel = Ddi_BddRelMakeFromArray(splitU,splitV);
    splitVars = Ddi_VarsetMakeFromArray(splitV);
    Ddi_BddSetAig(splitRel);
  }


  if (mark>0 && mark < tfPiNum) {
    tfPiNum = mark;
  }

  Pdtutil_Assert(itpPart>0,"itpPart required");

  if (optCare!=NULL) {
    Ddi_BddAndAcc(careTot,optCare);
    Ddi_BddAndAcc(careTotForCex,optCare);
  }

  for (i=0; i<itpPart; i++) {
    Ddi_Bdd_t *myB, *myBforCex, *cex;
    myB = Ddi_BddDup(bDup);
    myBforCex = Ddi_BddDup(bDup);

    if (splitB!=NULL) {
      Ddi_Free(myBforCex);
      myBforCex = Ddi_BddDup(splitB);
      if (splitCare!=NULL) {
	Ddi_BddAndAcc(careTotForCex,splitCare);
      }
      itpPlus = NULL;
    }
    if (i==2 && preSplit && splitRel) {
      genClauses=1; genCubes=0;
    }

    nnfSubset = 0 && (i>=itpPart/3) && (i<itpPart-1);

    if (residualSpace!=NULL) {
      itpPart = i+1;
      Ddi_BddAndAcc(myB,residualSpace);
      Ddi_AigStructRedRemAcc (myB,0);
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("last ITP partition in residual space: %d\n",
               Ddi_BddSize(residualSpace));
      }
      Ddi_Free(residualSpace);
    }
    
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("ITP part%s: %d/%d\n", splitB?"(split)":"", i, itpPart);
    }
    if (i==itpPart) {
      //      handle final part
      itp_i =
	Ddi_AigSat22AndWithInterpolant(incrSat,a,myB,NULL,
				       globalVars, domainVars,NULL,0,
				       itpTot,NULL,
				       psat, 0, itpOdc, 0, timeLimit);
    }
    else {
      Ddi_Bdd_t *itpSplit = NULL; int itpSplitDone=0;
      startTime = util_cpu_time();
      if (i==itpPart-1) {
	/* let as it is */
	if (preSplit && splitRel!=NULL) {
	  Ddi_Free(myB);
	  myB = Ddi_BddDup(myBforCex);
	  Ddi_BddAndAcc(myB,careTotForCex);
	  Ddi_BddComposeAcc(myB,splitV,splitU);
	  preSplit = 0;
	}
	Ddi_Bdd_t *bFromItp = Ddi_BddNot(itpTot);
        //	Ddi_BddOrAcc(myB,bFromItp);
	Ddi_Free(bFromItp);
      }
      else if (nnfSubset) {
	Ddi_Bdd_t *myBSubs = Ddi_AigSatNnfSubset(myBforCex,
						 careTotForCex,itpPlus);
	if (myBSubs == NULL) {
	  Ddi_Free(myB);
	  Ddi_Free(myBforCex);
	  break;
	}
	Ddi_Free(myBforCex);
	myBforCex = myBSubs;
      }
      else if (genClauses) {
	int maxIter = 500;
	int res=0;
	Pdtutil_Assert (preSplit && splitRel!=NULL,"wrong setting");
	Ddi_Bdd_t *aSplit = Ddi_BddAnd(a,splitRel);
	Ddi_Vararray_t *v1=NULL,*v2=NULL, *glbA=NULL;
     
	v1 = Ddi_VararrayMakeFromVarset(splitVars,1);
	v2 =
	  Ddi_VararrayMakeNewAigVars(v1, "shadow", NULL);
	glbA = Ddi_VararrayDup(v1);
	if (genCubes) {
 	  itpSplit =
 	    Ddi_AigInterpolantByGenClauses(aSplit,myBforCex,careTotForCex,
					 NULL, 
					 v2, v1, NULL, glbA, 
					 NULL, NULL, NULL, maxIter, 
					 0, &res);
	  if (res==0) {
	    genCubes=0;
	    Ddi_Free(itpSplit);
	  }
	}
	if (!genCubes) {
 	  itpSplit =
 	    Ddi_AigInterpolantByGenClauses(myBforCex,aSplit,careTotForCex,
					 NULL, 
					 v2, v1, NULL, glbA, 
					 NULL, NULL, NULL, maxIter, 
					 0, &res);
	  Ddi_BddNotAcc(itpSplit);
	}
	itpSplitDone=1;
	Ddi_Free(v1);
	Ddi_Free(v2);
	Ddi_Free(glbA);
	if (Ddi_BddIsOne(itpSplit)) {
	  Ddi_Free(myB);
	  Ddi_Free(myBforCex);
	  Ddi_Free(itpSplit);
	  break;
	}
      }
      else {
        int enCex = 1;
        if (incrSat!=NULL) {
          Ddi_Mgr_t *ddmDup = incrSat->ddiMgr;
          Pdtutil_Assert(ddmDup!=NULL,"missing ddi mgr");
          Ddi_Bdd_t *cexDup;
          Ddi_Bdd_t *check = Ddi_BddCopy(ddmDup,careTotForCex);
          Ddi_Bdd_t *bDup = Ddi_BddCopy(ddmDup,b);  
          Ddi_BddSetPartConj(check);
          if (myBforCex!=NULL) {
            Ddi_Bdd_t *tmp = Ddi_BddCopy(ddmDup,myBforCex);  
            Ddi_BddPartInsertLast(check,tmp);
            Ddi_Free(tmp);
          }
          if (itpPlus!=NULL) {
            Ddi_Bdd_t *itpPlusDup = Ddi_BddCopy(ddmDup,itpPlus); 
            Ddi_BddPartInsertLast(check,itpPlusDup);
            Ddi_Free(itpPlusDup);
          }
          //          Ddi_AigSatMinisatLoadClausesIncrementalAsserted(incrSat,bDup);
          //Ddi_IncrSatMgrLockAig(incrSat,bDup);
          Ddi_AigSatMinisatLoadClausesIncremental(incrSat,check,NULL);
          Ddi_AigSatInitLearningIncremental(incrSat,0);
          cexDup =
            Ddi_AigSatMinisat22WithCexAndAbortIncremental(
		       incrSat,check, NULL, 0,-1.0, NULL);
          Ddi_Bddarray_t *learnedDup=NULL, *eqDup=NULL,
            *refDup=NULL;
          if (incrSat->implied!=NULL) {
            learnedDup = Ddi_BddarrayDup(incrSat->implied);
            refDup = Ddi_BddarrayDup(incrSat->refA);
            eqDup = Ddi_BddarrayDup(incrSat->eqA);
          }
          Ddi_AigSatStopLearningIncremental(incrSat);
          Ddi_IncrSatPrintStats(ddmDup,incrSat,0);    
          cex=NULL;
          int enChk=0;
          if (cexDup!=NULL) {
            Ddi_Bddarray_t *auxImplDup = Ddi_BddarrayAlloc(ddmDup, 0);
            cex = Ddi_BddCopy(ddm,cexDup); 
            if (enChk && learnedDup!=NULL && Ddi_BddarrayNum(learnedDup)>0) {
              Ddi_Bdd_t *chk = Ddi_BddDup(myBforCex); 
              Ddi_Bddarray_t *auxImpl = Ddi_BddarrayCopy(ddm,
                                learnedDup);
              //              Ddi_BddAndAcc(chk,careTotForCex);
              if (itpPlus!=NULL) {
                Ddi_BddAndAcc(chk,itpPlus);
              }
              int j;
              for (j=0; j<Ddi_BddarrayNum(auxImpl); j++) {
                Ddi_Bdd_t *a_i = Ddi_BddarrayRead(auxImpl,j);
                if (!Ddi_BddIncluded(chk,a_i)) {
                  printf("not included\n");
                }
              }
              Ddi_Free(chk);
              Ddi_Free(auxImpl);
            }
            Ddi_Free(auxImplDup);

            if (learnedDup!=NULL) {
              Ddi_Bddarray_t *learned = Ddi_BddarrayCopy(ddm,
                                learnedDup);
              Ddi_Bddarray_t *refA = Ddi_BddarrayCopy(ddm,
                                refDup);
              Ddi_Bddarray_t *eqA = Ddi_BddarrayCopy(ddm,
                                eqDup);
              Ddi_Bdd_t *b2 = Ddi_BddMakePartConjFromArray(learned);
              //residualSpace = Ddi_BddNot(b2);
              // Ddi_BddNotAcc(b2);
              Ddi_BddPartInsertLast(b2, myB);
              Ddi_BddSetAig(b2);
#if 1
              Ddi_AigStructRedRemAcc (b2,0);
#else
              // problems due to sharing!!! Increases size
              Ddi_Bdd_t *myB2 = Ddi_AigComposeFunc (b2,refA,eqA);
              Ddi_AigStructRedRemAcc (myB2,0);
              Ddi_DataCopy(b2,myB2);
              Ddi_Free(myB2);
#endif
              if (1 && (Ddi_BddSize(b2)<Ddi_BddSize(myB)*3)) {
                //Ddi_BddSetAig(residualSpace);
                Pdtutil_VerbosityMgrIf(ddm,
                  Pdtutil_VerbLevelUsrMax_c) {
                  fprintf(dMgrO(ddm),
                    "Reduced b by learning (%d impl): %d->%d\n",
                          Ddi_BddarrayNum(learned),
                          Ddi_BddSize(myB),Ddi_BddSize(b2));
                }
                Ddi_DataCopy(myB,b2);
                enCex = 0;
              }
              else {
                Ddi_Free(residualSpace);
              }
              Ddi_Free(b2);
              Ddi_Free(learned);
              Ddi_Free(refA);
              Ddi_Free(eqA);
            }
            Ddi_Free(learnedDup);
            Ddi_Free(eqDup);
            Ddi_Free(refDup);
          }
          Ddi_Free(bDup);
          Ddi_Free(cexDup);
          Ddi_Free(learnedDup);
          Ddi_Free(check);
        }
        else {
          cex = Ddi_AigSatAndWithCexAndAbort(myBforCex,careTotForCex,
					 itpPlus,NULL,-1,NULL);
        }
        cexTime = util_cpu_time() - startTime;
	Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	  fprintf(dMgrO(ddm),"CEX time%s = %s\n",
                  cex==NULL? " (unsat)":"",
                  util_print_time (cexTime));
	}
	if (cex==NULL) {
	  Ddi_Free(myB);
	  Ddi_Free(myBforCex);
	  break;
	}
        if (enCex) {
          Ddi_BddExistAcc(cex,globalVars);
          if (splitVars!=NULL) {
            Ddi_BddExistAcc(cex,splitVars);
          }
          if (tfPiVars!=NULL && tfPiNum>0) {
            int j;
            //	  for (j=0; j<i && j<tfPiNum; j++) {
            for (j=0; j<2*tfPiNum/4; j++) {
              Ddi_Varset_t *smPi = Ddi_VarsetMakeFromArray(tfPiVars[j]);
              Ddi_BddExistAcc(cex,smPi);
              Ddi_Free(smPi);
            }
          }
          Ddi_AigConstrainCubeAcc(myB, cex);
          Ddi_AigConstrainCubeAcc(myBforCex, cex);
        }
        Ddi_Free(cex);
      }
      if (preSplit && splitRel!=NULL) {
	Ddi_Bdd_t *aSplit = Ddi_BddAnd(a,splitRel);
	int checkTime=0;
	if (optCare!=NULL) {
	  Ddi_BddAndAcc(aSplit,optCare);
	}
	if (!itpSplitDone) {
	  itpSplit =
	    Ddi_AigSat22AndWithInterpolant(incrSat,aSplit,myBforCex,NULL,
				       splitVars, NULL,NULL,0,
				       NULL,NULL,
                                         psat, 0, itpOdc, 1, timeLimit);
	}
	else if (doItpFromGenClauses && (itpSplit!=NULL)) {
	  Ddi_Free(myBforCex);
	  myBforCex = Ddi_BddNot(itpSplit);
	  Ddi_Free(itpSplit);
	  itpSplit =
	    Ddi_AigSat22AndWithInterpolant(incrSat,aSplit,myBforCex,NULL,
				       splitVars, NULL,NULL,0,
				       NULL,NULL,
                                         psat, 0, itpOdc, 1, timeLimit);
	}
	if (itpSplit!=NULL) {
          printf("SPLIT ITP: %d\n", Ddi_BddSize(itpSplit));
        }
	if (itpSplit!=NULL) {
	  Ddi_Bdd_t *myB2;
	  Ddi_AigOptByMonotoneCoreAcc(itpSplit,aSplit,careTotForCex,
				    1,-1.0);
	  myB2 = Ddi_BddNot(itpSplit);
	  Ddi_BddAndAcc(careTotForCex, itpSplit);
	  Ddi_BddComposeAcc(myB2,splitV,splitU);
	  itp_i =
	    Ddi_AigSat22AndWithInterpolant(incrSat,a,myB2,NULL,
				       globalVars, domainVars,NULL,0,
				       optCare,NULL,
                                           psat, 0, itpOdc, 0, timeLimit);
	  Pdtutil_Assert(itp_i!=NULL,"NULL itpSplit");
	  Ddi_Free(itpSplit);
	  Ddi_Free(aSplit);
	  Ddi_Free(myB2);
	}
	else {
	  itp_i = NULL;
	}
      }
      else {
#if 1
	itp_i =
	  Ddi_AigSat22AndWithInterpolant(incrSat,a,myB,NULL,
				       globalVars, domainVars,NULL,0,
				       optCare,NULL,
                                         psat, 0, itpOdc, 0, timeLimit);
#else
	itp_i = Ddi_BddNot(myB);
#endif
      }

      Ddi_Free(itpSplit);
      Ddi_Free(myB);
      if ((itp_i!=NULL)&&
	  (Ddi_AigOptByMonotoneCoreAcc(itp_i,a,careTot,1,-1.0)==NULL)) {
	// SAT
	Ddi_Free(itp_i);
      }  
    }

    if (itp_i != NULL && i<itpPart-1) {
      if (splitRel==NULL) {
	Ddi_BddAndAcc(careTotForCex, itp_i);
      }
      else if (!preSplit) {
	Ddi_Bdd_t *itpSplit, *aSplit = Ddi_BddAnd(itp_i,splitRel);
	int checkTime=0;
	if (optCare!=NULL) {
	  Ddi_BddAndAcc(aSplit,optCare);
	}
	itpSplit =
	  Ddi_AigSat22AndWithInterpolant(incrSat,aSplit,myBforCex,NULL,
				       splitVars, NULL,NULL,0,
				       NULL,NULL,
                                         psat, 0, itpOdc, 0, timeLimit);
	Pdtutil_Assert(itpSplit!=NULL,"NULL itpSplit");
	Ddi_AigOptByMonotoneCoreAcc(itpSplit,aSplit,careTotForCex,
				    1,-1.0);
	if (checkTime) {
	  long time0, time1;
	  Ddi_Bdd_t *itp2, *bSplit = Ddi_BddAnd(itpSplit,splitRel);
	  time0 = util_cpu_time();

	  itp2 =
	  Ddi_AigSat22AndWithInterpolant(incrSat,a,bSplit,NULL,
				       splitVars, NULL,NULL,0,
				       optCare,NULL,
                                         psat, 0, itpOdc, 0, timeLimit);
	  time1 = util_cpu_time() - time0;
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    fprintf(dMgrO(ddm),"ITP2 time = %s\n", util_print_time (time1));
	  }
	  Ddi_Free(bSplit);
	  Ddi_Free(itp2);
	}

	Ddi_BddAndAcc(careTotForCex, itpSplit);
	Ddi_Free(itpSplit);
	Ddi_Free(aSplit);
      }
    }

    Ddi_Free(myB);
    Ddi_Free(myBforCex);

    if (itp_i != NULL) {
      Ddi_BddAndAcc(itpTot, itp_i);
      Ddi_BddAndAcc(careTot, itp_i);
      Ddi_Free(itp_i);
    }
    else {
      Ddi_Free(itpTot);
      break;
    }

  }
#if 0
  }
#endif

  Ddi_Free(residualSpace);
 
  Ddi_Free(splitB);
  Ddi_Free(splitCare);
  Ddi_Free(splitU);
  Ddi_Free(splitV);
  Ddi_Free(splitRel);
  Ddi_Free(splitVars);

  Ddi_Free(bDup);
  Ddi_Free(careTot);
  Ddi_Free(careTotForCex);
  if (itpTot!=NULL && !Ddi_BddIsConstant(itpTot)) {
    Ddi_AigOptByMonotoneCoreAcc (itpTot,a,careTot,1,-1.0);
  }
  
  if (chkres && itpTot!=NULL) {
    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,b,optCare),"wrong part itp");
    Ddi_BddNotAcc(itpTot);
    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,a,optCare),"wrong part itp");
    Ddi_BddNotAcc(itpTot);
  }
  else if (chkresSat && itpTot!=NULL && psat!=NULL && *psat) {
    Pdtutil_Assert(Ddi_AigSatAnd(itpTot,b,optCare),"wrong itp sat");
  }

  return itpTot;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSat22AndWithInterpolantPartNnfA (
  Ddi_IncrSatMgr_t *incrSat, 
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bddarray_t *bwdRings,
  Ddi_Bdd_t *prevA,
  Ddi_Varset_t *globalVars,
  Ddi_Varset_t *domainVars,
  Ddi_Vararray_t *globalVarsA,
  Ddi_Vararray_t **tfPiVars,
  int tfPiNum,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *itpPlus,
  int *psat,
  int itpPart,
  int itpOdc,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Bdd_t *itp_i=NULL, *itpTot = NULL, *itp0 = NULL;
  Ddi_Bdd_t *careTot = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *careTotForCex = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *careFinal = Ddi_BddMakeConstAig(ddm,1);
  int i, chkresSat=0, 
    chkres = 0, thVars = itpPart>8 ? 8*itpPart : 1<<itpPart;
  int tryCexCore = 0;
  int doForall = 0;
  long startTime, cexTime;
  int isSat=0, preSplit=1;
  int nnfSubset = 0, genClauses=0;
  int genCubes = 1;
  int doItpFromGenClauses = 1;
  int markUp, mark = Ddi_BddReadMark(b);

  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitCare = NULL,
    *splitCone = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Vararray_t *splitRefV = NULL;
  Ddi_Varset_t *splitVars = NULL;
  Ddi_Bdd_t *aSplit = NULL;
  Ddi_Varset_t *itpVars=NULL;
  Ddi_Bddarray_t *en=NULL;
  int enFoMin = 10;
  int useEnables = 1;

  if (Ddi_BddReadComposeF(b)!=NULL) {
    splitB = Ddi_BddDup(Ddi_BddReadComposeF(b));
    splitCare = Ddi_BddDup(Ddi_BddReadComposeCare(b));
    splitCone = Ddi_BddDup(Ddi_BddReadComposeCone(b));
    splitU = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(b));
    splitV = Ddi_VararrayDup(Ddi_BddReadComposeVars(b));
    splitRefV = Ddi_VararrayDup(Ddi_BddReadComposeRefVars(b));
    splitRel = Ddi_BddRelMakeFromArray(splitU,splitV);
    splitVars = Ddi_VarsetMakeFromArray(splitV);
    Ddi_BddSetAig(splitRel);
    if (splitCone!=NULL) {
      Ddi_BddOrAcc(splitRel,splitCone);
    }
  }

  if (mark>0 && mark < tfPiNum) {
    tfPiNum = mark;
  }

  Ddi_Varset_t *smVars = Ddi_BddSupp(a);

  Ddi_Varset_t *splitRelSupp = Ddi_BddSupp(splitRel);
  Ddi_Vararray_t *splitRelSuppA = NULL;
  int stepAddVars, totAddVars;
  int subsetA = 0, computeItp0=0;

  if (computeItp0) subsetA=1;

  if (subsetA) {
    Ddi_Free(smVars);
    smVars = Ddi_VarsetDup(domainVars);
  }

  Ddi_VarsetSetArray(splitRelSupp);
  Ddi_VarsetSetArray(smVars);
  Ddi_VarsetSetArray(globalVars);

  Ddi_VarsetUnionAcc(smVars,globalVars);
  if (splitVars!=NULL) {
    Ddi_VarsetSetArray(splitVars);
    Ddi_VarsetUnionAcc(smVars,splitVars);
  }

  if (subsetA) {
    Ddi_VarsetUnionAcc(smVars,splitRelSupp);
    Ddi_Free(splitRelSupp);
    splitRelSupp = Ddi_BddSupp(a);
    Ddi_VarsetSetArray(splitRelSupp);
  }

  Ddi_VarsetDiffAcc(splitRelSupp,smVars);

  totAddVars = Ddi_VarsetNum(splitRelSupp);
  stepAddVars = totAddVars/itpPart;
  splitRelSuppA = Ddi_VararrayMakeFromVarset(splitRelSupp,1);

  Pdtutil_Assert(itpPart>0,"itpPart required");

  Ddi_Bdd_t *bRing = NULL;
  if (bwdRings!=NULL) {
    markUp = Ddi_BddReadMark(splitB);
    int bwdRing_j = markUp;
    if (Ddi_BddarrayNum(bwdRings)<=bwdRing_j ||
	Ddi_BddarrayRead(bwdRings,bwdRing_j)==NULL) {
      bRing = Ddi_BddMakeConstAig(ddm,1);
      Ddi_BddarrayWrite(bwdRings,bwdRing_j,bRing);
      Ddi_Free(bRing);
    }
    bRing = Ddi_BddDup(Ddi_BddarrayRead(bwdRings,bwdRing_j));
  }
  else if (prevA!=NULL) {
    bRing = Ddi_BddNot(prevA);
  }

  if (bRing!=NULL) {
    Ddi_BddAndAcc(careTot,bRing);
    Ddi_BddAndAcc(careTotForCex,bRing);
  }
  if (splitRefV!=NULL) {
    Ddi_BddSubstVarsAcc(careTotForCex,splitRefV,splitV);
    Ddi_BddSubstVarsAcc(careTot,splitRefV,splitV);
  }
  Ddi_Free(bRing);

  Ddi_Bdd_t *myB = Ddi_BddDup(b);

  if (splitB!=NULL) {
    Ddi_Free(myB);
    myB = Ddi_BddDup(splitB);
    if (splitCare!=NULL) {
      Ddi_BddAndAcc(myB,splitCare);
    }
    itpPlus = NULL;
    itpVars = splitVars;
  }
  else {
    itpVars = globalVars;
  }

  for (i=0; i<itpPart; i++) {
    Ddi_Bdd_t *myA, *myA0, *myAforCex, *cex, *itpCare;
    Ddi_Bdd_t *enConstr=NULL;
    myA = Ddi_BddDup(a);
    myA0 = Ddi_BddDup(myA);
    myAforCex = Ddi_BddDup(a);
    if (optCare!=NULL) {
      Ddi_BddAndAcc(myA,optCare);
      Ddi_BddAndAcc(myAforCex,optCare);
    }
    Ddi_BddAndAcc(myA,careFinal);
    //    itpCare = optCare;
    itpCare=NULL;
    if (splitRel!=NULL) {
      Ddi_BddAndAcc(myA,splitRel);
      Ddi_BddAndAcc(myAforCex,splitRel);
      if (splitCare!=NULL) {
	Ddi_BddAndAcc(careTotForCex,splitCare);
	Ddi_BddAndAcc(myA,splitCare);
      }
    }

    if (1) {
      Ddi_Bdd_t *partA = Ddi_AigPartitionTop(myA, 0);
      Ddi_Free(myA);
      myA = partA;
    }

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("ITP part A: %d/%d - cone depth(split): %d(%d)\n", 
	     i, itpPart,mark,markUp);
    }
    startTime = util_cpu_time();
    en=NULL;
    if (i==itpPart-1) {
      /* let as it is */
      //      Ddi_BddOrAcc(myA,itpTot);
    }
    else {
      cex = Ddi_AigSatAndWithCexAndAbort(myAforCex,careTotForCex,
					 itpPlus,NULL,-1,NULL);
      cexTime = util_cpu_time() - startTime;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	fprintf(dMgrO(ddm),"CEX time = %s (%sSAT)\n", 
		util_print_time (cexTime), cex==NULL?"UN":"");
      }
      if (cex==NULL) {
	Ddi_Free(myA);
	Ddi_Free(myAforCex);
	Ddi_Free(itpTot);
	itpTot = Ddi_BddNot(careTot);
	break;
      }
      //      Ddi_BddExistProjectAcc(cex,domainVars);
      if (useEnables) {
	//	Ddi_BddSetAig(myA);
	//	Ddi_BddSetAig(myA0);
	int nEn;
	if (en==NULL) {
	  en = Ddi_FindAigIte(splitRel, enFoMin);
	}
	else {
	  nEn = Ddi_BddarrayNum(en);
	  if (nEn>20) {
	    enFoMin++;
	    Ddi_Free(en);
	    en = Ddi_FindAigIte(splitRel, enFoMin);
	  }
	  else {
	    Ddi_BddarrayRemove(en,nEn-1);
	  }
	}
	Ddi_Bdd_t *a2 = Ddi_AigSubsetWithCexOnControl (myA,cex,en);
	nEn = Ddi_BddarrayNum(en);
	Ddi_DataCopy(myA,a2);
	Ddi_Free(a2);
	enConstr = Ddi_AigSubsetWithCexConstr (cex,en);
	Ddi_Free(cex);
      }
      else {
	Ddi_AigCubeExistAcc (cex,smVars);
	Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	  fprintf(dMgrO(ddm),"Constraining A&splitRel with CEX of %d vars\n", 
		  Ddi_BddSize(cex)/2);
	}	
	Ddi_AigConstrainCubeAcc(myA, cex);
	Ddi_AigConstrainCubeAcc(myA0, cex);
	// add new smooth vars
	int j;
	for (j=0; j<stepAddVars && 
	       Ddi_VararrayNum(splitRelSuppA)>totAddVars/10; j++) {
	  int iTop = Ddi_VararrayNum(splitRelSuppA)-1;
	  Ddi_Var_t *vSm = Ddi_VararrayExtract(splitRelSuppA,iTop);
	  Ddi_VarsetAddAcc(smVars,vSm);
	}
	if (stepAddVars<totAddVars/4)
	  stepAddVars *= 1.1;
      }
    }
    int myItpAigCore = ddm->settings.aig.itpAigCore;
    ddm->settings.aig.itpAigCore = 0;
    itp_i =
      Ddi_AigSat22AndWithInterpolant(incrSat,myA,myB,NULL,
				     itpVars, domainVars,NULL,0,
				     itpCare,NULL,
				     psat, 0, itpOdc, 0, timeLimit);
    ddm->settings.aig.itpAigCore = myItpAigCore;
    if (itp_i!=NULL) {
      Ddi_AigOptByMonotoneCoreAcc(itp_i,myA,careTot,1,-1.0);
      Ddi_AigOptByMonotoneCoreAcc(itp_i,myB,careTot,0,-1.0);
      if (i<itpPart-1) {
	if (cex!=NULL) {
	}
	else {
	  int sat;
	  Pdtutil_Assert(enConstr!=NULL,"missing enables");
	  Ddi_Bdd_t *prod = Ddi_BddNot(itp_i);
	  Ddi_BddAndAcc(prod,a);
	  Ddi_BddAndAcc(prod,careTot);
	  if (splitRel!=NULL) {
	    Ddi_BddAndAcc(prod,splitRel);
	    if (splitCare!=NULL) {
	      Ddi_BddAndAcc(prod,splitCare);
	    }
	  }
	  sat = Ddi_AigSatMinisatWithAbortAndFinal(prod,enConstr,-1.0,1);
	  Ddi_BddSetAig(enConstr);
	  Pdtutil_Assert(!sat,"unsat required");
	  Ddi_BddDiffAcc(careFinal,enConstr);
	  Ddi_Free(enConstr);
	  Ddi_Free(prod);
	}
      }
    }

    Ddi_Free(enConstr);
    Ddi_Free(cex);
    Ddi_Free(myA);
    Ddi_Free(myAforCex);

    if (itp_i != NULL) {
      if (itpTot==NULL) {
	//	itpTot = Ddi_BddMakeConstAig(ddm,0);
	itpTot = Ddi_BddNot(careTot);
      }
      Ddi_BddOrAcc(itpTot, itp_i);
      Ddi_BddDiffAcc(careTot, itp_i);
      Ddi_BddDiffAcc(careTotForCex, itp_i);
      if (computeItp0) {
	Ddi_Bdd_t *myB0 = NULL, *itp0_i=NULL;
	if (1 || itp0==NULL) {
	  myB0 = Ddi_BddDup(careTot);
	  itp0 = Ddi_BddMakeConstAig(ddm,0);
	}
	else {
	  myB0 = Ddi_BddNot(itp_i);
	}
	if (splitCare!=NULL) {
	  Ddi_BddAndAcc(myB0,splitCare);
	}
	Ddi_BddComposeAcc(myB0,splitV,splitU);
	itp0_i =
	  Ddi_AigSat22AndWithInterpolant(incrSat,myA0,myB0,NULL,
				     globalVars, domainVars,NULL,0,
				     optCare,NULL,
				     psat, 0, itpOdc, 0, timeLimit);
	Pdtutil_Assert(itp0_i!=NULL,"NULL interpolant");
	Ddi_BddOrAcc(itp0,itp0_i);
	Ddi_BddDiffAcc(careTotForCex, itp0_i);
	Ddi_Free(itp0_i);
	Ddi_Free(myB0);
      }

      Ddi_Free(itp_i);
    }
    else {
      Pdtutil_Assert(Ddi_AigSatAnd(a,b,optCare),"unsound part itp");
      Ddi_Free(itpTot);
      break;
    }
    Ddi_Free(myA0);
  }

  Ddi_Free(myB);
  if (itpTot!=NULL && splitB!=NULL) {

    if (bwdRings!=NULL) {
      markUp = Ddi_BddReadMark(splitB);
      int bwdRing_j = markUp;
      Ddi_Bdd_t *bRingRef = Ddi_BddDup(itpTot);
      if (splitCare!=NULL) {
	Ddi_BddAndAcc(bRingRef,splitCare);
      }
      if (splitRefV!=NULL) 
	Ddi_BddSubstVarsAcc(bRingRef,splitV,splitRefV);
      Ddi_BddNotAcc(bRingRef);

      Pdtutil_Assert (Ddi_BddarrayNum(bwdRings)>bwdRing_j,
		      "Missing bwd ring");
      bRing = Ddi_BddarrayRead(bwdRings,bwdRing_j);
      Ddi_BddAndAcc(bRing,bRingRef);
      Ddi_Free(bRingRef);
    }

    if (0 && itp0!=NULL) {
      itpTot = Ddi_BddDup(itp0);
    }
    else {
      Ddi_BddNotAcc(itpTot);
      if (splitCare!=NULL) {
	Ddi_BddAndAcc(itpTot,splitCare);
      }
      myB = Ddi_BddCompose(itpTot,splitV,splitU);
      if (splitCone!=NULL) {
	Ddi_BddOrAcc(myB,splitCone);
      }
      itpTot = NULL;
      itpTot =
	Ddi_AigSat22AndWithInterpolant(incrSat,a,myB,NULL,
				       globalVars, domainVars,NULL,0,
				       optCare,NULL,
				       psat, 0, itpOdc, 0, timeLimit);
      Pdtutil_Assert(itpTot!=NULL,"unsound itp");
    }
  }

  Ddi_Free(en);
  Ddi_Free(itp0);
  Ddi_Free(splitRelSupp);
  Ddi_Free(splitRelSuppA);
  Ddi_Free(splitB);
  Ddi_Free(splitCare);
  Ddi_Free(splitCone);
  Ddi_Free(splitU);
  Ddi_Free(splitV);
  Ddi_Free(splitRel);
  Ddi_Free(splitVars);
  Ddi_Free(aSplit);

  Ddi_Free(careTot);
  Ddi_Free(careTotForCex);
  Ddi_Free(careFinal);
  Ddi_Free(smVars);

  if (itpTot!=NULL && !Ddi_BddIsConstant(itpTot)) {
    Ddi_AigOptByMonotoneCoreAcc (itpTot,a,careTot,1,-1.0);
  }
  
  if (chkres && itpTot!=NULL) {
    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,b,optCare),"wrong part itp");
    Ddi_BddNotAcc(itpTot);
    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,a,optCare),"wrong part itp");
    Ddi_BddNotAcc(itpTot);
  }
  else if (chkresSat && itpTot!=NULL && psat!=NULL && *psat) {
    Pdtutil_Assert(Ddi_AigSatAnd(itpTot,b,optCare),"wrong itp sat");
  }

  return itpTot;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSat22AndWithInterpolantPartNnf0 (
  Ddi_IncrSatMgr_t *incrSat, 
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *bSplit,
  Ddi_Varset_t *globalVars,
  Ddi_Varset_t *domainVars,
  Ddi_Vararray_t **tfPiVars,
  int tfPiNum,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *itpPlus,
  int *psat,
  int itpPart,
  int itpOdc,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Bdd_t *itp_i=NULL, *itpTot = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *careTot = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *careTotForCex = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *bDup = Ddi_BddDup(b);
  int i, chkresSat=0, 
    chkres = 0, thVars = itpPart>8 ? 8*itpPart : 1<<itpPart;
  int tryCexCore = 0;
  int tryForallCore = 0, doForall = 0;
  long startTime, cexTime;
  int mark = Ddi_BddReadMark(b);
  int isSat=0, preSplit=1;
  int nnfSubset = 0;

  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitCare = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Varset_t *splitVars = NULL;

  if (Ddi_BddReadComposeF(b)!=NULL) {
    splitB = Ddi_BddDup(Ddi_BddReadComposeF(b));
    splitCare = Ddi_BddDup(Ddi_BddReadComposeCare(b));
    splitU = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(b));
    splitV = Ddi_VararrayDup(Ddi_BddReadComposeVars(b));
    splitRel = Ddi_BddRelMakeFromArray(splitU,splitV);
    splitVars = Ddi_VarsetMakeFromArray(splitV);
    Ddi_BddSetAig(splitRel);
  }

  if (mark>0 && mark < tfPiNum) {
    tfPiNum = mark;
  }

  Pdtutil_Assert(itpPart>0,"itpPart required");

  if (optCare!=NULL) {
    Ddi_BddAndAcc(careTot,optCare);
    Ddi_BddAndAcc(careTotForCex,optCare);
  }
#if 0
  Ddi_Bdd_t *myB0 = Ddi_BddDup(b);
  Ddi_BddNotAcc(myB0);
  Ddi_Varset_t *smooth = Ddi_BddSupp(myB0);
  Ddi_VarsetDiffAcc(smooth,globalVars);

  DdiAigExistOverAcc (myB0,smooth,NULL);

  Ddi_Free(smooth);

  if (Ddi_AigOptByMonotoneCoreAcc (myB0,a,careTot,1,-1.0)==NULL) {
    Ddi_Free(itpTot);
    Ddi_Free(myB0);
  }
  else {
  Ddi_BddAndAcc(itpTot,myB0);
  Ddi_BddAndAcc(careTot,myB0);
  Ddi_Free(myB0);
#endif

  if (tryForallCore && (tfPiNum>20)) {
    int size0 = Ddi_BddSize(bDup);
    Ddi_Bdd_t *myB0 = Ddi_BddDup(bDup);
    Ddi_Bdd_t *cex = Ddi_AigSatWithCex(bDup);
    if (cex!=NULL) {
    Ddi_Bdd_t *litCex = Ddi_AigPartitionTop(cex, 0);
    int k, corePeriod = tfPiNum / 5;

    for (i=0; i<Ddi_BddPartNum(litCex); i++) {
      Ddi_Bdd_t *lit = Ddi_BddPartRead(litCex,i);
      Ddi_Var_t *v = Ddi_BddTopVar(lit);
      int sign = Ddi_BddIsComplement(lit) ? -1 : 1;
      Ddi_VarWriteMark(v,sign);
    }

    for (k=1, i=tfPiNum-1; i>=tryForallCore; i--, k++) {
      Ddi_Bdd_t *myB1 = Ddi_BddDup(myB0);
      if (doForall) {
	Ddi_Varset_t *smPi = Ddi_VarsetMakeFromArray(tfPiVars[i]);
	Ddi_BddNotAcc(myB1);
	DdiAigExistOverAcc (myB1,smPi,NULL);
	Ddi_BddNotAcc(myB1);
	Ddi_Free(smPi);
      }
      else {
	Ddi_Bdd_t *cubeConstr = Ddi_BddMakeConstAig(ddm,1);
	Ddi_Vararray_t *smPiA = tfPiVars[i];
	int j, nl;
	for (j=nl=0; j<Ddi_VararrayNum(smPiA); j++) {
	  Ddi_Var_t *v = Ddi_VararrayRead(smPiA,j);
	  int sign = Ddi_VarReadMark(v);
	  if (sign!=0) {
	    Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, sign==1 ? 1 : 0);
	    Ddi_BddAndAcc(cubeConstr,lit);
	    Ddi_Free(lit);
	    nl++;
	  }
	}
	if (nl>0) {
	  Ddi_AigConstrainCubeAcc(myB1, cubeConstr);
	}
	Ddi_Free(cubeConstr);
      }
      if (Ddi_BddSize(myB1)>size0/10) {
	Ddi_Free(myB0); myB0 = Ddi_BddDup(myB1);
	if (k%corePeriod == 0) {
	  Ddi_BddOrAcc(myB1,bDup);
	  if (Ddi_BddSize(myB1)>size0*1.25) {
	    Ddi_Free(myB1);
	    break;
	  }
	  else {
	    Ddi_Free(bDup); bDup = myB1;
	    k--;
	  }
	}
      }
      else {
	Ddi_Free(myB1);
	break;
      }
    }

    for (i=0; i<Ddi_BddPartNum(litCex); i++) {
      Ddi_Bdd_t *lit = Ddi_BddPartRead(litCex,i);
      Ddi_Var_t *v = Ddi_BddTopVar(lit);
      Ddi_VarWriteMark(v,0);
    }

    Ddi_Free(cex);
    Ddi_Free(litCex);

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("FORALL CORE: %d+%d = %d\n", size0, 
	   Ddi_BddSize(myB0), Ddi_BddSize(bDup));
    }
    }
    Ddi_Free(myB0);
  }

  if (tryCexCore) {
    Ddi_Bdd_t *cex = Ddi_AigSatWithCex(bDup);
    int nCore=0;
    if (cex!=NULL) {
      int j, res;
      Ddi_Varset_t *vars = Ddi_BddSupp(cex);
      Ddi_Bdd_t *cexPart = Ddi_AigPartitionTop(cex,0);

      for (j=0; j<Ddi_BddPartNum(cexPart); j++) {
	Ddi_Bdd_t *p_j = Ddi_BddPartRead(cexPart,j);
	Ddi_BddNotAcc(p_j);
	if (!Ddi_AigSatAnd(b,p_j,NULL)) {
	  nCore++;
	}
      }

      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("CEX CORE: %d/%d\n", nCore, Ddi_BddPartNum(cexPart));
      }
      Ddi_Free(cex);
      Ddi_Free(vars);
      Ddi_Free(cexPart);
    }
  }

  for (i=0; i<itpPart; i++) {
    Ddi_Bdd_t *myB, *myBforCex, *cex;
    myB = Ddi_BddDup(bDup);
    myBforCex = Ddi_BddDup(bDup);

    if (splitB!=NULL) {
      Ddi_Free(myBforCex);
      myBforCex = Ddi_BddDup(splitB);
      if (splitCare!=NULL) {
	Ddi_BddAndAcc(careTotForCex,splitCare);
      }
      itpPlus = NULL;
    }

    nnfSubset = 0 && (i>=itpPart/3) && (i<itpPart-1);

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("ITP part%s: %d/%d\n", splitB?"(split)":"", i, itpPart);
    }
    if (i==itpPart) {
      //      handle final part
      itp_i =
	Ddi_AigSat22AndWithInterpolant(incrSat,a,myB,NULL,
				       globalVars, domainVars,NULL,0,
				       itpTot,NULL,
				       psat, 0, itpOdc, 0, timeLimit);
    }
    else {
      startTime = util_cpu_time();
      if (i==itpPart-1) {
	/* let as it is */
	if (preSplit && splitRel!=NULL) {
	  Ddi_Free(myB);
	  myB = Ddi_BddDup(myBforCex);
	  Ddi_BddAndAcc(myB,careTotForCex);
	  Ddi_BddComposeAcc(myB,splitV,splitU);
	  preSplit = 0;
	}
	Ddi_Bdd_t *bFromItp = Ddi_BddNot(itpTot);
	Ddi_BddOrAcc(myB,bFromItp);
	Ddi_Free(bFromItp);
      }
      else if (nnfSubset) {
	Ddi_Bdd_t *myBSubs = Ddi_AigSatNnfSubset(myBforCex,
						 careTotForCex,itpPlus);
	if (myBSubs == NULL) {
	  Ddi_Free(myB);
	  Ddi_Free(myBforCex);
	  break;
	}
	Ddi_Free(myBforCex);
	myBforCex = myBSubs;
      }
      else {
	cex = Ddi_AigSatAndWithCexAndAbort(myBforCex,careTotForCex,
					 itpPlus,NULL,-1,NULL);
	cexTime = util_cpu_time() - startTime;
	Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	  fprintf(dMgrO(ddm),"CEX time = %s\n", util_print_time (cexTime));
	}
	if (cex==NULL) {
	  Ddi_Free(myB);
	  Ddi_Free(myBforCex);
	  break;
	}
	Ddi_BddExistAcc(cex,globalVars);
	if (splitVars!=NULL) {
	  Ddi_BddExistAcc(cex,splitVars);
	}
	if (tfPiVars!=NULL && tfPiNum>0) {
	  int j;
	  for (j=0; j<i && j<tfPiNum; j++) {
	    Ddi_Varset_t *smPi = Ddi_VarsetMakeFromArray(tfPiVars[j]);
	    Ddi_BddExistAcc(cex,smPi);
	    Ddi_Free(smPi);
	  }
	}
	Ddi_AigConstrainCubeAcc(myB, cex);
	Ddi_AigConstrainCubeAcc(myBforCex, cex);
	Ddi_Free(cex);
      }
      if (preSplit && splitRel!=NULL) {
	Ddi_Bdd_t *itpSplit, *aSplit = Ddi_BddAnd(a,splitRel);
	int checkTime=0;
	if (optCare!=NULL) {
	  Ddi_BddAndAcc(aSplit,optCare);
	}
	itpSplit =
	  Ddi_AigSat22AndWithInterpolant(incrSat,aSplit,myBforCex,NULL,
				       splitVars, NULL,NULL,0,
				       NULL,NULL,
                                         psat, 0, itpOdc, 1, timeLimit);
	if (itpSplit!=NULL) {
          printf("SPLIT ITP: %d\n", Ddi_BddSize(itpSplit));
        }
	if (itpSplit!=NULL) {
	  Ddi_Bdd_t *myB2;
	  Ddi_AigOptByMonotoneCoreAcc(itpSplit,aSplit,careTotForCex,
				    1,-1.0);
	  myB2 = Ddi_BddNot(itpSplit);
	  Ddi_BddAndAcc(careTotForCex, itpSplit);
	  Ddi_BddComposeAcc(myB2,splitV,splitU);
	  itp_i =
	    Ddi_AigSat22AndWithInterpolant(incrSat,a,myB2,NULL,
				       globalVars, domainVars,NULL,0,
				       optCare,NULL,
                                           psat, 0, itpOdc, 0, timeLimit);
	  Pdtutil_Assert(itp_i!=NULL,"NULL itpSplit");
	  Ddi_Free(itpSplit);
	  Ddi_Free(aSplit);
	  Ddi_Free(myB2);
	}
	else {
	  itp_i = NULL;
	}
      }
      else {
#if 1
	itp_i =
	  Ddi_AigSat22AndWithInterpolant(incrSat,a,myB,NULL,
				       globalVars, domainVars,NULL,0,
				       optCare,NULL,
                                         psat, 0, itpOdc, 0, timeLimit);
#else
	itp_i = Ddi_BddNot(myB);
#endif
      }

      Ddi_Free(myB);
      if ((itp_i!=NULL)&&
	  (Ddi_AigOptByMonotoneCoreAcc(itp_i,a,careTot,1,-1.0)==NULL)) {
	// SAT
	Ddi_Free(itp_i);
      }  
    }

    if (itp_i != NULL && i<itpPart-1) {
      if (splitRel==NULL) {
	Ddi_BddAndAcc(careTotForCex, itp_i);
      }
      else if (!preSplit) {
	Ddi_Bdd_t *itpSplit, *aSplit = Ddi_BddAnd(itp_i,splitRel);
	int checkTime=0;
	if (optCare!=NULL) {
	  Ddi_BddAndAcc(aSplit,optCare);
	}
	itpSplit =
	  Ddi_AigSat22AndWithInterpolant(incrSat,aSplit,myBforCex,NULL,
				       splitVars, NULL,NULL,0,
				       NULL,NULL,
                                         psat, 0, itpOdc, 0, timeLimit);
	Pdtutil_Assert(itpSplit!=NULL,"NULL itpSplit");
	Ddi_AigOptByMonotoneCoreAcc(itpSplit,aSplit,careTotForCex,
				    1,-1.0);
	if (checkTime) {
	  long time0, time1;
	  Ddi_Bdd_t *itp2, *bSplit = Ddi_BddAnd(itpSplit,splitRel);
	  time0 = util_cpu_time();

	  itp2 =
	  Ddi_AigSat22AndWithInterpolant(incrSat,a,bSplit,NULL,
				       splitVars, NULL,NULL,0,
				       optCare,NULL,
                                         psat, 0, itpOdc, 0, timeLimit);
	  time1 = util_cpu_time() - time0;
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    fprintf(dMgrO(ddm),"ITP2 time = %s\n", util_print_time (time1));
	  }
	  Ddi_Free(bSplit);
	  Ddi_Free(itp2);
	}

	Ddi_BddAndAcc(careTotForCex, itpSplit);
	Ddi_Free(itpSplit);
	Ddi_Free(aSplit);
      }
    }

    Ddi_Free(myB);
    Ddi_Free(myBforCex);

    if (itp_i != NULL) {
      Ddi_BddAndAcc(itpTot, itp_i);
      Ddi_BddAndAcc(careTot, itp_i);
      Ddi_Free(itp_i);
    }
    else {
      Ddi_Free(itpTot);
      break;
    }

  }
#if 0
  }
#endif

  Ddi_Free(splitB);
  Ddi_Free(splitCare);
  Ddi_Free(splitU);
  Ddi_Free(splitV);
  Ddi_Free(splitRel);
  Ddi_Free(splitVars);

  Ddi_Free(bDup);
  Ddi_Free(careTot);
  Ddi_Free(careTotForCex);
  if (itpTot!=NULL && !Ddi_BddIsConstant(itpTot)) {
    Ddi_AigOptByMonotoneCoreAcc (itpTot,a,careTot,1,-1.0);
  }
  
  if (chkres && itpTot!=NULL) {
    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,b,optCare),"wrong part itp");
    Ddi_BddNotAcc(itpTot);
    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,a,optCare),"wrong part itp");
    Ddi_BddNotAcc(itpTot);
  }
  else if (chkresSat && itpTot!=NULL && psat!=NULL && *psat) {
    Pdtutil_Assert(Ddi_AigSatAnd(itpTot,b,optCare),"wrong itp sat");
  }

  return itpTot;
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSat22AndWithInterpolant (
  Ddi_IncrSatMgr_t *incrSat, 
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *bAbstr,
  Ddi_Varset_t *globalVars,
  Ddi_Varset_t *domainVars,
  Ddi_Vararray_t **tfPiVars,
  int tfPiNum,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *itpPlus, // *prevItp,
  int *psat,
  int itpPart,
  int itpOdc,
  int tryRevItp,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *interpolant=NULL, *reverseInterpolant=NULL,
    *interpolantOpt;
  Minisat22Solver *S22 = NULL; 
  Minisat22Solver *S22b = NULL; 
  int nACl, i, checkVars = 0, dynAbstr = 0;
  Ddi_Vararray_t *vA;
  Ddi_Bdd_t *a2=NULL, *b2=NULL;
  Ddi_Varset_t *myGlobalVars, *suppB, *suppAB;
  int nSuppVars;
  static int itpStoreId=0, storeItp=0;
  int undefined = 0;
  int optLevel = Ddi_MgrReadAigBddOptLevel (ddm);
  long startTime, cpuTime, itpSatTime=-1;
  int enItpBddOpt = 0 && (optLevel > 0); // GC: disabled for HWMCC2015
  int enItpTernary = 0;
  int doSatPart = (itpPart==2), doSatPart2 = (itpPart>2), satPartMaxPart=64;
  float satPartSmoothRatio = 1.0;
  int doSatPart3 = 0;
  int ddmid =  ddm->currNodeId;
  char *splitVarFile = "splitVarFile.txt";
  int itpPartTh = Ddi_MgrReadAigItpPartTh(ddm);
  int itpIteOptTh = ddm->settings.aig.itpIteOptTh;
  int itpStructOdcTh = ddm->settings.aig.itpStructOdcTh;
  int itpStoreTh = ddm->settings.aig.itpStoreTh;
  int nActiveVar=0;
  //  itpOdc=0;
  int forcePart=0;
  int sizeA, sizeB;
  int computeCore = ddm->settings.aig.itpCore;
  int computeCoreAig = computeCore < 0;
  int itpAbc = Ddi_MgrReadAigItpAbc(ddm);
  Ddi_Bdd_t *bCore = NULL;
  Ddi_Bdd_t *aCore = NULL;
  int coreByRefinement=0, itpCoreTh = ddm->settings.aig.itpAigCore, itpSize;
  int itpTwiceTh = ddm->settings.aig.itpTwice;
  int saveBCore=0, bshared=0;
  int doIncrItp=0;
  int addReverseItp = 0;
  Ddi_Bdd_t *prevItp=NULL;
  Ddi_Bdd_t *itpInvar=NULL;
  Solver Sdummy;
  int doDupSolver = 0;
  vec<Lit> assumps;
  vec<vec<Lit> > coreBClauses;
  bAig_array_t *cnfMappedVars=NULL;
  bool success = true;
  int noOK=0, no22 = ddm->settings.aig.itpDrup==0;
  int checkInterpolant = ddm->settings.aig.itpDrup>0 &&
    ddm->settings.aig.itpDrup%2==0;

  static int nCalls = 0;
  int tryPartial = 0;

  if (ddm->settings.aig.itpDrup>2)
    itpCoreTh = 0;
  
  tryRevItp = 0;

  if (itpPart>0) {
    if (tryPartial) {
      float myTimeLimit=50.0;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("DOING PARTIAL interpolant\n");
      }
      Ddi_Bdd_t *itp = Ddi_AigSat22AndWithInterpolant(
			 incrSat,a,b,NULL,
			 globalVars, domainVars,
			 tfPiVars,tfPiNum,
			 optCare,itpPlus,
			 psat, 0, itpOdc,0, 
			 myTimeLimit);
      if (itp!=NULL) {
	if (*psat==-2) {
	  int doAnd=0, doItp=1;
	  Ddi_Bdd_t *itp2 = itp;
	  Ddi_Bdd_t *myB = Ddi_BddDup(itp);
	  if (doItp) {
	    Ddi_BddNotAcc(myB);
	    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	      printf("DOING PARTIAL A-ITP interpolant\n");
	    }
	    itp = Ddi_AigSat22AndWithInterpolant(
			 incrSat,a,myB,NULL,
			 globalVars, domainVars,
			 tfPiVars,tfPiNum,
			 optCare,itpPlus,
			 psat, 0, itpOdc,0, 
			 timeLimit);
	    Ddi_Free(myB);
	    myB = Ddi_BddDup(itp);
	    Ddi_Free(itp2);
	    itp2 = itp;
	  }
	  if (doAnd)
	    Ddi_BddAndAcc(myB,b);
	  else {
	    Ddi_BddNotAcc(myB);
	    Ddi_BddOrAcc(myB,b);
	  }
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    printf("DOING PARTIAL A-B interpolant\n");
	  }
	  itp = Ddi_AigSat22AndWithInterpolant(
			 incrSat,a,myB,NULL,
			 globalVars, domainVars,
			 tfPiVars,tfPiNum,
			 optCare,itpPlus,
			 psat, 0, itpOdc,0, 
			 2*myTimeLimit);
	  Ddi_Free(myB);

	  if (itp!=NULL) {
	    if (doAnd || *psat<0)
	      Ddi_BddAndAcc(itp,itp2);
	    Ddi_Free(itp2);
	    if (*psat==-2) {
	      itp2 = itp;
	      myB = Ddi_BddDup(itp);
	      if (doItp) {
		Ddi_BddNotAcc(myB);
		Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
		  printf("DOING PARTIAL A-ITP interpolant (2)\n");
		}
		itp = Ddi_AigSat22AndWithInterpolant(
						     incrSat,a,myB,NULL,
						     globalVars, domainVars,
						     tfPiVars,tfPiNum,
						     optCare,itpPlus,
						     psat, 0, itpOdc,0, 
						     timeLimit);
		Ddi_Free(myB);
		myB = Ddi_BddDup(itp);
		Ddi_Free(itp2);
		itp2 = itp;
	      }
	      if (doAnd)
		Ddi_BddAndAcc(myB,b);
	      else {
		Ddi_BddNotAcc(myB);
		Ddi_BddOrAcc(myB,b);
	      }
	      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
		printf("DOING PARTIAL A-B interpolant (2)\n");
	      }
	      itp = Ddi_AigSat22AndWithInterpolant(
						   incrSat,a,myB,NULL,
						   globalVars, domainVars,
						   tfPiVars,tfPiNum,
						   optCare,itpPlus,
						   psat, 0, itpOdc,0, 
						   timeLimit);
	      Ddi_Free(myB);
	      if (doAnd)
		Ddi_BddAndAcc(itp,itp2);
	      Ddi_Free(itp2);
	    }
	  }
	  return (itp);
	}
	else if (*psat==-3) {
	  int doAnd=0;
	  Ddi_Bdd_t *itp2 = itp;
	  Ddi_Bdd_t *myA = Ddi_BddDup(itp);
	  if (doAnd)
	    Ddi_BddDiffAcc(myA,a);
	  else {
	    Ddi_BddOrAcc(myA,a);
	  }
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    printf("DOING PARTIAL A-B interpolant\n");
	  }
	  itp = Ddi_AigSat22AndWithInterpolant(
			 incrSat,myA,b,NULL,
			 globalVars, domainVars,
			 tfPiVars,tfPiNum,
			 optCare,itpPlus,
			 psat, 0, itpOdc,0, 
			 timeLimit);
	  Ddi_Free(myA);
	  if (doAnd)
	    Ddi_BddOrAcc(itp,itp2);
	  Ddi_Free(itp2);
	  return (itp);
	}
	if (*psat==-1) {
	  Ddi_Bdd_t *myB = Ddi_BddAnd(b,itp);
	  Ddi_Free(itp);
	  itp = Ddi_AigSat22AndWithInterpolant(
			 incrSat,a,myB,NULL,
			 globalVars, domainVars,
			 tfPiVars,tfPiNum,
			 optCare,itpPlus,
			 psat, 0, itpOdc,0, 
			 timeLimit);
	  Ddi_Free(myB);
	  if (itp!=NULL) {
	    myB = Ddi_BddAnd(b,itp);
	    Ddi_Bdd_t *itp2 = Ddi_AigSat22AndWithInterpolant(
			 incrSat,a,myB,NULL,
			 globalVars, domainVars,
			 tfPiVars,tfPiNum,
			 optCare,itpPlus,
			 psat, 0, itpOdc,0, 
			 timeLimit);
	    if (itp2 != NULL) {
	      Ddi_BddAndAcc(itp,itp2);
	      Ddi_Free(itp2);
	    }
	    else {
	      Ddi_Free(itp);
	    }
	    Ddi_Free(myB);
	    return (itp);
	  }
	}
	else {
	  return (itp);
	}
      }
    }

    if (Ddi_BddSize(b)>itpPartTh) {
      return Ddi_AigSat22AndWithInterpolantPartNnf(incrSat,a,b,NULL,
					      globalVars, domainVars,
					      tfPiVars,tfPiNum,
					      optCare,itpPlus,
					      psat, itpPart, itpOdc, 
					      timeLimit);
    }
  }
  itpPlus = NULL;

  sizeA = Ddi_BddSize(a);
  sizeB = Ddi_BddSize(b);
  //if (sizeA<10 || sizeB<10) no22=1;

  if(no22) {
    Ddi_Bdd_t *itpRet;
    //    static int nC=0;
    //    nC++;
    int tryAgain = 0;
    if (tryAgain) {
      ddm->cnf.useSavedAigsForSat = 2;
    }
    if (0) {
      Ddi_Vararray_t *gbl = Ddi_BddSuppVararray(a);
      Ddi_Vararray_t *gblB = Ddi_BddSuppVararray(b);
      vec<Var> dummy;
      Ddi_VararrayIntersectAcc(gbl,gblB);
      SaveVarsAsAigs(ddm,dummy,gbl);
      Ddi_Free(gbl);
      Ddi_Free(gblB);
      ddm->cnf.useSavedAigsForSat = 0;
    }
    if (ddm->settings.aig.itpReverse) {
      int saveItpNnfAbstrAB = ddm->settings.aig.itpNnfAbstrAB;
      // set just B
      ddm->settings.aig.itpNnfAbstrAB = 3;
      Ddi_Bdd_t *myB = Ddi_BddDup(b);
      if (optCare!=NULL) {
        Ddi_BddNotAcc(optCare);
        Ddi_BddOrAcc(myB,optCare);
        Ddi_BddNotAcc(optCare);
      }
      ddm->settings.aig.itpReverse = 0;
      itpRet =  Ddi_AigSatAndWithInterpolant(myB, a,
			globalVars, domainVars, NULL,
					       NULL,NULL,NULL,
                        psat, itpPart, itpOdc, timeLimit);
      Ddi_Free(myB);
      ddm->settings.aig.itpNnfAbstrAB = saveItpNnfAbstrAB;
      if (itpRet!=NULL) {
        Ddi_BddNotAcc(itpRet);
      }
      ddm->settings.aig.itpReverse = 1;
    }
    else {
      itpRet =  Ddi_AigSatAndWithInterpolant(a, b,
			globalVars, domainVars, optCare,
					       prevItp,NULL,NULL,
                        psat, itpPart, itpOdc, timeLimit);
    }
    if (tryAgain && (itpRet != NULL)) {
      if (ddm->cnf.useSavedAigsForSat==0 &&
          ddm->cnf.savedAigNodes != NULL) {
        Ddi_Bdd_t *itpRet2=NULL; 
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("***** RECOMPUTING ITP with unit clauses *****\n");
        }
        Ddi_Bddarray_t *constrA = RestoreSavedAigNodes(ddm);
        if (Ddi_BddarrayNum(constrA)>0) {
          Ddi_Bdd_t *b2 = Ddi_BddMakePartConjFromArray(constrA);
          int k, cntOK=0;
          Ddi_Bdd_t *bTry=Ddi_BddDup(b);
          int enable = 1;
          for (k=0; k<Ddi_BddarrayNum(constrA); k++) {
            Ddi_Bdd_t *c_j = Ddi_BddarrayRead(constrA,k);
            if (Ddi_AigSatAnd(bTry,c_j,NULL)) {
              Ddi_BddAndAcc(bTry,c_j);
              cntOK++;
            }
          }
          printf("non zero found from unit cl: %d/%d\n", cntOK,
                 Ddi_BddarrayNum(constrA));
              //              break;
          Ddi_Free(b2);
          b2 = bTry;
          if (enable) {
            //            Ddi_BddPartInsertLast(b2,b);
            Ddi_AigStructRedRemAcc (b2,0);
            Ddi_BddSetAig(b2);
            itpRet2 =  Ddi_AigSatAndWithInterpolant(a, b2,
			globalVars, domainVars, optCare,
                        prevItp,NULL,NULL,
                        psat, itpPart, itpOdc, timeLimit);
            Ddi_Free(b2);
            bAigArrayClearDeref(bmgr, ddm->cnf.savedAigNodes);
            bAigArrayFree(ddm->cnf.savedAigNodes);
            if (Ddi_BddSize(itpRet2) < Ddi_BddSize(itpRet)) {
              Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
                printf("** RECOMPUTED ITP wins: %d->%d **\n",
                       Ddi_BddSize(itpRet), Ddi_BddSize(itpRet2));
              }
              Ddi_DataCopy(itpRet,itpRet2);
            }
          }
        }
        Ddi_Free(constrA);
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("***** END RECOMPUTING ITP *****\n");
        }
        Ddi_Free(itpRet2);
      }
      if (ddm->cnf.useSavedAigsForSat &&
          ddm->cnf.savedAigNodes != NULL) {
        Ddi_Bdd_t *itpRet2; 
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("***** RECOMPUTING ITP with core vars *****\n");
        }
        ddm->cnf.useSavedAigsForSat = -1;
        itpRet2 =  Ddi_AigSatAndWithInterpolant(a, b,
			globalVars, domainVars, optCare,
					       prevItp,NULL,NULL,
                        psat, itpPart, itpOdc, timeLimit);
        bAigArrayClearDeref(bmgr, ddm->cnf.savedAigNodes);
        bAigArrayFree(ddm->cnf.savedAigNodes);
        if (Ddi_BddSize(itpRet2) < Ddi_BddSize(itpRet)) {
          Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
            printf("** RECOMPUTED ITP wins: %d->%d **\n",
                   Ddi_BddSize(itpRet), Ddi_BddSize(itpRet2));
          }
          Ddi_DataCopy(itpRet,itpRet2);
        }
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("***** END RECOMPUTING ITP *****\n");
        }
        Ddi_Free(itpRet2);
      }
    }
    ddm->cnf.useSavedAigsForSat = 0;
    return itpRet;
  }


  if (itpCoreTh < 0) {
    itpCoreTh *= -1;
    saveBCore = -1;
  }

  if (itpPart==1) {
    itpPart=0;
    doIncrItp=1;
  }

  nCalls++;

  if (computeCore<0) {
    computeCore = -computeCore;
  }

  if (itpPart<0) {
    forcePart=1;
    itpPart *= -1;
    doSatPart = (itpPart==2);
    doSatPart2 = (itpPart>2);
  }

  if (Ddi_BddIsZero(b)) {
    *psat = 0;
    return (Ddi_BddMakeConstAig(ddm,1));
  }
  if (Ddi_BddIsZero(a)) {
    *psat = 0;
    return (Ddi_BddMakeConstAig(ddm,0));
  }
  if (/*Ddi_BddIsOne(a) &&*/ Ddi_BddIsOne(b)) {
    *psat = 1;
    //    return (Ddi_BddMakeConstAig(ddm,1));
    return (NULL);
  }

  myGlobalVars = Ddi_BddSupp(a); /* @@@ */
  suppAB = Ddi_BddSupp(b);
  Ddi_VarsetSetArray(suppAB);

  if (globalVars==NULL) {
    Ddi_VarsetSetArray(myGlobalVars);
    Ddi_VarsetIntersectAcc(myGlobalVars,suppAB);
  }
  else {
    if (Ddi_VarsetIsArray(globalVars)) {
      Ddi_VarsetSetArray(myGlobalVars);
    }
    Ddi_VarsetIntersectAcc(myGlobalVars,globalVars);
  }
  Ddi_VarsetSetArray(myGlobalVars);

  Ddi_VarsetUnionAcc(suppAB,myGlobalVars);
  Ddi_Free(suppAB);

  nSuppVars = Ddi_VarsetNum(myGlobalVars);

  if (nSuppVars==0) {
    Ddi_Free(myGlobalVars);
    if (Ddi_AigSatAnd(b,optCare,NULL)
        &&Ddi_AigSat(a)) {
      *psat = 1;
    }
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  vA = Ddi_VararrayMakeFromVarset(myGlobalVars,1);
  Ddi_Free(myGlobalVars);

  if (Ddi_BddIsPartConj(a)) {
    a2 = Ddi_BddDup(a);
  }
  else {
    a2 = Ddi_AigPartitionTopWithXor(a,0,1);
  }
  b2 = Ddi_BddDup(b);

  if (1 && optCare != NULL && !Ddi_BddIsOne(optCare)) {
    Ddi_BddAndAcc(b2,optCare);
  }
  if (Ddi_BddIsZero(b2) /*|| !Ddi_AigSat(b2)*/) {
    Ddi_Free(a2); Ddi_Free(b2); 
    Ddi_Free(vA);
    *psat = 0;
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  if (itpAbc) {
    Ddi_Free(vA);
    interpolant = Ddi_AbcInterpolant (a2,b2,
                                      globalVars,domainVars,psat,timeLimit);
    undefined = *psat < 0;
  }

  sizeA = Ddi_BddSize(a2);
  sizeB = Ddi_BddSize(b2);

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
                       fprintf(dMgrO(ddm),"ITP (|A|=%d,|B|=%d)\n",sizeA,sizeB));

  //  aig2CnfIdInitDecr(ddm,2*(sizeA+sizeB)/3);
  Pdtutil_Assert(incrSat==NULL,"incr sat not allowed across itps");

  int doIncrSat = Ddi_BddIsPartDisj(b2); int doRealIncrSat = 1,
      incrLoad = 0; // incr SAT ok, incr load no for proof
  if (doIncrSat) {
    incrSat = Ddi_IncrSatMgrAlloc(NULL, 1/*useMinisat22*/, 0,0);
  }
  if (incrSat!=NULL) {
    S22 = (Minisat22Solver *)incrSat->S22;
  }
  else {
    S22 = new Minisat22Solver();
  }
  S22->proofLogging(1);
  S22->proofRestart();
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  if (verbosity >= Pdtutil_VerbLevelUsrMin_c)
    S22->proofPdt.setVerbosity(1);
  if (verbosity >= Pdtutil_VerbLevelDevMax_c)
    S22->proofPdt.setVerbosity(2);

  aig2CnfIdInit(ddm);

  if (computeCoreAig) {
    int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
    ddm->settings.aig.aigCnfLevel = 0;
    MinisatClausesWithSuppFlow(NULL,Sdummy,(void *)S22,a2,b2,globalVars,&nACl,NULL,NULL,0,0,0,1);
    ddm->settings.aig.aigCnfLevel = aigCnfLevel;
  }
  else if (doIncrSat) {
    Ddi_AigSatMinisatLoadClausesIncrementalAsserted(incrSat,a2);
    nACl = S22->nClauses();
  }
  else {
    MinisatClausesWithSuppFlow(NULL,Sdummy,(void *)S22,a2,b2,globalVars,&nACl,&bshared,NULL,0,0,0,1);
  }
  assumps.clear();

  startTime = util_cpu_time();

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    printf("ITP time limit: %d\n", (int)timeLimit);
  }

  if (doDupSolver) {
    Minisat::vec<Minisat::Lit> cl22;
    S22b = new Minisat22Solver();
    S22b->proofLogging(1);
    Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
    if (verbosity >= Pdtutil_VerbLevelUsrMin_c)
      S22b->proofPdt.setVerbosity(1);
    if (verbosity >= Pdtutil_VerbLevelDevMax_c)
      S22b->proofPdt.setVerbosity(2);

    for (i=0; i<=S22->nVars(); i++) {
      S22b->newVar();
    }
    for (i=0; i<S22->nClauses(); i++) {
      const Minisat::Clause& cl = S22->getClause2(i);
      cl22.clear();
      for(int j=0; j<cl.size(); ++j){
	cl22.push(cl[j]);
      }
      S22b->addClause(cl22);
    }
  }

  if (ddm->settings.aig.satVarActivity < 0) {
    int nCommon=0;
    int act = -ddm->settings.aig.satVarActivity;
    for (i=0; i<Ddi_VararrayNum(vA); i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
      bAigEdge_t varIndex = Ddi_VarToBaig(v);
      Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
      int vCnf = aig2CnfId(bmgr,varIndex);
      Minisat::Var v22 = vCnf-1;
      S22->varBumpActivityExternal  (v22, (double) act);
    }
  }

  if ((*psat = S22->okay())) {
    if (incrSat!=NULL) {
      int tryAssume = 0;
      Ddi_Bdd_t *bPart = Ddi_BddDup(b2);
      if (tryAssume) {
        incrLoad = 1;
        doRealIncrSat = 0;
      }
      Ddi_BddPartSortBySizeAcc(bPart, 1);    // incr. size
      int np = Ddi_BddPartNum(bPart);
      Ddi_BddPartInsertLast(bPart,b2); // just done to mark everything
      int nA = bAigSetAuxCharForInterpolant(a2,bPart);
      int isSat = 0;
      int doRev=0;
      Ddi_BddPartRemove(bPart,np);
      if (!incrLoad) {
        Ddi_AigSatMinisatLoadClausesIncrementalAsserted(incrSat,b2);
        //Ddi_AigSatMinisatLoadClausesIncremental(incrSat,bPart,NULL);
        Ddi_IncrSatMgrLockAig(incrSat,b2);
        //        Ddi_IncrSatMgrLockAig(incrSat,bPart);
      }
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
            fprintf(dMgrO(ddm),
            "Running incremental SAT with %d partitions: ", np));
      for (int i=0; i<np; i++) {
        Ddi_Bdd_t *b_i = Ddi_BddPartRead(bPart,doRev?(np-i-1):i);
        if (incrLoad) {
          if (tryAssume && i<(np-2)) {
            Ddi_BddNotAcc(b_i);
            Ddi_AigSatMinisatLoadClausesIncrementalAsserted(incrSat,b_i);
            Ddi_BddNotAcc(b_i);
          }
          else
            Ddi_AigSatMinisatLoadClausesIncremental(incrSat,b_i,NULL);
          Ddi_IncrSatMgrLockAig(incrSat,b_i);
        }
        if (!S22->okay()){
          isSat = 0;
          noOK = 1;
          break;
        }
        Ddi_Bdd_t *cex = !doRealIncrSat ? NULL :
            Ddi_AigSatMinisat22WithCexAndAbortIncremental(incrSat,
                                b_i, NULL, 0,-1.0, NULL);
        Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
                             (fprintf(dMgrO(ddm)," %d", i),
                              fflush(dMgrO(ddm))));
        if (cex!=NULL) {
          Ddi_Free(cex);
          isSat = 1;
          break;
        }
      }
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
            fprintf(dMgrO(ddm),"\n"));
      Ddi_Free(bPart);
      *psat = isSat;
      if (incrLoad && !isSat && !noOK) {
        Ddi_AigSatMinisatLoadClausesIncrementalAsserted(incrSat,
                                                          b2);
        Ddi_IncrSatMgrLockAig(incrSat,b2);
        if (!S22->okay()) noOK = 1;
      }
    }
    noOK = 0;
    if (!noOK) {
      Minisat::vec<Minisat::Lit> assumps22;
      MinisatTo22(assumps22,assumps);
      
      Minisat22FreezeVars (S22,ddm,vA);
      //    S22->eliminate(false);
      if (timeLimit >= 0) {
        S22->setTimeBudget((double)timeLimit);
        Ddi_Bddarray_t *actAigs = ddm->aig.actVars;
        if (actAigs!=NULL) {
          int na0 = assumps22.size();
          Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
            printf("DOING INCR SAT based on %d active Vars\n",
                   Ddi_BddarrayNum(actAigs));
          }
          for (int i=0; i<Ddi_BddarrayNum(actAigs); i++) {
            Ddi_Bdd_t *a_i = Ddi_BddarrayRead(actAigs,i);
            int aCnf = DdiAig2CnfId(bmgr,Ddi_BddToBaig(a_i));
            int v = aCnf-1;
            if (v<S22->nVars()) {
              Minisat::Lit l = Minisat::mkLit(v,Ddi_BddIsComplement(a_i));
              assumps22.push(l);
            }
          }
          *psat = 0;
          while (S22->okay() && assumps22.size()>na0) {
            *psat = S22->solveLimitedInt(assumps22);
            if (assumps22.size()>na0) assumps22.pop();
            if (*psat) break;
          }
          if (!(*psat) && S22->okay()) {
            *psat = S22->solveLimitedInt(assumps22);
          }
        }
        else {
          *psat = S22->solveLimitedInt(assumps22);
        }
      }
      else {
        *psat = S22->solve(assumps22);
      }
    }
  }
  else {
    noOK = 1;
    // fprintf(dMgrO(ddm),"UNSAT\n");
  }


  cpuTime = itpSatTime = util_cpu_time () - startTime;

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),"Solver stats: %ld/%ld vars/clauses (elim v/cl:%d/%d)\n",
 	    S22->nVars(), S22->nClauses(), S22->eliminated_vars, S22->eliminated_clauses);
    fprintf(dMgrO(ddm),
      "Solver stats: %ld/%ld/%ld dec./prop./confl.\n",
      (int)S22->decisions, (int)S22->propagations,
       (int)S22->conflicts);
    fprintf(dMgrO(ddm),"Solver stats: time = %s\n", util_print_time (cpuTime)));

  if (0 && (cpuTime > 40000)) {
    Minisat::vec<Minisat::Lit> topLits22;
    S22->getLearntsTopLits(topLits22,100);
    vec<Lit> topLits;
    MinisatFrom22(topLits22,topLits);
    Ddi_Bddarray_t *topA = aigArrayMakeFromMinisatLits(ddm, topLits);
    Ddi_Free(topA);
  }

  if (*psat < 0) {
    int ncl, i;
    int enTopLitConstr = 1;
    int returnConstr = 1;
    undefined = 1;

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"Solver result UNDEFINED\n"));

    if (bAbstr!=NULL) {
      Minisat22Solver *S22itp = NULL; 
      S22itp = new Minisat22Solver();
      S22itp->proofLogging(1);
      if ((nACl = Minisat22ConstrainSolverWithAbstrCex((void *)S22,(void *)S22itp,
						       ddm,bAbstr,assumps,nACl))) {
	Minisat::vec<Minisat::Lit> assumps22;
	MinisatTo22(assumps22,assumps);
	if (S22itp->okay()) 
	  *psat = S22itp->solve(assumps22);
	else
	  *psat = 0;
	delete S22;
	S22 = S22itp;
	undefined = 0;
      }
      else {
	delete S22itp;
      }
    }
    else if (enTopLitConstr && returnConstr) {
      Ddi_Bdd_t *constrFull = Minisat22InterpolantUndefTopLits ((void *)S22, ddm, 200);
      interpolant = constrFull;
      aig2CnfIdClose(ddm);
    }
    else if (enTopLitConstr) {
      Ddi_Bdd_t *constrFull = Minisat22InterpolantUndefTopLits ((void *)S22, ddm, 10);
      aig2CnfIdClose(ddm);
      Ddi_Bdd_t *constrA = Ddi_BddPartFilter (constrFull,a2);
      Ddi_Bdd_t *constrB = Ddi_BddPartFilter (constrFull,b2);
      Ddi_Bdd_t *myA = Ddi_BddDup(a2);
      Ddi_Bdd_t *myB = Ddi_BddDup(b2);
      int useAconstr = Ddi_BddPartNum(constrA) > Ddi_BddPartNum(constrB);
      int abort;
      if (!useAconstr) {
        int again = 0;
        do {
          Ddi_Bdd_t *newConstrB = Ddi_BddDup(constrB);
          Ddi_Bdd_t *constrFinal = Ddi_AigSatMinisat22RemoveCoreFinal(myB,newConstrB,
                                                                      1,(double)timeLimit,&abort);
          again = 0;
          if (constrFinal != NULL) {
            Ddi_Free(constrFinal);
            again = 1;
            Ddi_DataCopy(constrB, newConstrB);
          }
          Ddi_Free(newConstrB);
        } while (again);
        Ddi_BddSetPartConj(myB);
        Ddi_BddPartInsertLast(myB,constrB);
        Ddi_BddSetFlattened(myB);
        useAconstr = 0;
      }
      if (useAconstr) {
        int again = 0;
        do {
          Ddi_Bdd_t *newConstrA = Ddi_BddDup(constrA);
          Ddi_Bdd_t *constrFinal = Ddi_AigSatMinisat22RemoveCoreFinal(myA,newConstrA,
                                                                      1,(double)timeLimit,&abort);
          again = 0;
          if (constrFinal != NULL) {
            Ddi_Free(constrFinal);
            again = 1;
            Ddi_DataCopy(constrA, newConstrA);
          }
          Ddi_Free(newConstrA);
        } while (again);
        Ddi_BddSetPartConj(myA);
        Ddi_BddPartInsertLast(myA,constrA);
        Ddi_BddSetFlattened(myA);
      }
      Ddi_Bdd_t *constr = useAconstr?constrA:constrB;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nConstrained interpolant with %s constraint of size %d (%d entries)\n",
               useAconstr?"A":"B", Ddi_BddSize(constr), Ddi_BddPartNum(constr));
      }
      Ddi_Bdd_t *itp2_1 = Ddi_AigSat22AndWithInterpolant(
			 incrSat,myA,myB,NULL,
			 globalVars, domainVars,
			 tfPiVars,tfPiNum,
			 NULL,NULL,
			 psat, 0, itpOdc,0, 
			 -1);
      interpolant = itp2_1;
      for (int i=0; i<Ddi_BddPartNum(constr); i++) {
        Ddi_Bdd_t *myA_i = Ddi_BddDup(a2);
        Ddi_Bdd_t *myB_i = Ddi_BddDup(b2);
        Ddi_Bdd_t *c_i = Ddi_BddPartRead(constr,i);
        if (useAconstr)
          Ddi_BddDiffAcc(myA_i,c_i);
        else
          Ddi_BddDiffAcc(myB_i,c_i);

        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("\nConstrained interpolant with constraint [%d] of size %d\n",
                 i, Ddi_BddSize(c_i));
        }

        Ddi_Bdd_t *itp2_i = Ddi_AigSat22AndWithInterpolant(
                         incrSat,myA_i,myB_i,NULL,
			 globalVars, domainVars,
			 tfPiVars,tfPiNum,
			 NULL,NULL,
			 psat, 0, itpOdc,0, 
			 -1);
        Ddi_Free(myA_i);
        Ddi_Free(myB_i);
        if (itp2_i==NULL) {
          Ddi_Free(interpolant);
          break;
        }
        if (useAconstr)
          Ddi_BddOrAcc(interpolant,itp2_i);
        else
          Ddi_BddAndAcc(interpolant,itp2_i);
        Ddi_Free(itp2_i);
      }
      Ddi_Free(a2);
      Ddi_Free(b2);

      Ddi_Free(myA);
      Ddi_Free(myB);
      Ddi_Free(constrA);
      Ddi_Free(constrB);
      Ddi_Free(constrFull);
    }
    else if (globalVars!=NULL) { 
      int useB = 1;
      success = Minisat22InterpolantUndef ((void *)S22, ddm, a2, globalVars, 
				    0, &interpolant,
				    optCare, nSuppVars,itpOdc,1,nACl,useB);
      aig2CnfIdClose(ddm);
      //    S22->deleteProofTemps();
      if (!incrSat!=NULL) {
	delete S22;
      }
      else {
        Ddi_IncrSatMgrQuitKeepDdi(incrSat);
      }
      Ddi_Free(vA);
      Ddi_Bdd_t *itp2 = NULL;
      if (interpolant!=NULL && Ddi_BddIsPartConj(interpolant)) {
	int tryProjectA = 0;
	Ddi_Bdd_t *myA, *myB;
	Ddi_Bdd_t *itpA = Ddi_BddDup(Ddi_BddPartRead(interpolant,0));
	Ddi_Bdd_t *itpB = Ddi_BddDup(Ddi_BddPartRead(interpolant,1));
	Ddi_Bdd_t *itpGA = Ddi_BddDup(Ddi_BddPartRead(interpolant,2));
	Ddi_Bdd_t *itpGB = Ddi_BddDup(Ddi_BddPartRead(interpolant,3));
	Ddi_Free(interpolant);
	Ddi_AigStructRedRemAcc (itpA,0);
      	Ddi_AigStructRedRemAcc (itpB,0);
	// Ddi_NnfClustSimplifyAcc(itpA,0);
	//	Ddi_NnfClustSimplifyAcc(itpB,0);
	if (tryProjectA) {
	  Ddi_Bdd_t *cex=Ddi_AigSatAndWithCexAndAbort(itpA,itpB,
                      NULL,NULL,-1,NULL);
	  if (cex==NULL) {
	    myB = Ddi_BddDup(itpB);
	  }
	  else {
	    Ddi_BddExistAcc(cex,globalVars);
	    Ddi_Bdd_t *b2Min = Ddi_BddDup(b2);
	    Ddi_AigConstrainCubeAcc(b2Min,cex);
	    Ddi_Free(cex);
	    Ddi_Bdd_t *itp2 = Ddi_AigSat22AndWithInterpolant(
			 incrSat,a2,b2Min,NULL,
			 globalVars, domainVars,
			 tfPiVars,tfPiNum,
			 NULL,NULL,
			 psat, 0, itpOdc,0, 
			 -1);
	    Ddi_Free(itpB);
	    itpB = itp2;
	    if (itpB!=NULL)
	      Ddi_BddNotAcc(itpB);
	    myB = Ddi_BddOr(b2,itpB);
	  }
	  myA = Ddi_BddAnd(a2,itpA);
	}
	else {
      	  myA = Ddi_BddAnd(a2,itpA);
	  //	  myA = Ddi_BddDup(a2);
	  if (itpB!=NULL)
	    myB = Ddi_BddAnd(b2,itpB);
	  else
	    myB = Ddi_BddDup(b2);
	}
	interpolant = Ddi_AigSat22AndWithInterpolant(
			 incrSat,myA,myB,NULL,
			 globalVars, domainVars,
			 tfPiVars,tfPiNum,
			 optCare,itpPlus,
			 psat, 0, itpOdc,0, 
			 timeLimit*2);
	Ddi_Free(itpA);
	Ddi_Free(itpB);
	Ddi_Free(itpGA);
	Ddi_Free(itpGB);
	Ddi_Free(myA);
	Ddi_Free(myB);
	return interpolant;

      }
      else if (interpolant!=NULL && Ddi_BddIsPartDisj(interpolant)) {
	Ddi_Bdd_t *itp0 = Ddi_BddDup(Ddi_BddPartRead(interpolant,0));
	Ddi_Bdd_t *itp1 = Ddi_BddDup(Ddi_BddPartRead(interpolant,1));
	Ddi_Free(interpolant);
	Ddi_AigStructRedRemAcc (itp0,0);
	Ddi_AigStructRedRemAcc (itp1,0);
	Ddi_NnfClustSimplifyAcc(itp0,0);
	Ddi_NnfClustSimplifyAcc(itp1,0);
	interpolant = itp0;
	Ddi_Free(itp1);
      }
      if (interpolant!=NULL) {
	if (itp2!=NULL) {
	  Ddi_BddAndAcc(interpolant,itp2);
	}
	Ddi_AigStructRedRemAcc (interpolant,NULL);
	Ddi_BddSetAig(interpolant);
	Ddi_NnfClustSimplifyAcc(interpolant,0);
	Ddi_Bdd_t *itpRet;
	if (useB) 
	  itpRet = Ddi_AigOptByMonotoneCoreAcc (interpolant,
			      a2,optCare,1,-1.0);
	else 
	  itpRet = Ddi_AigOptByMonotoneCoreAcc (interpolant,
			      b2,optCare,0,-1.0);
	if (itpRet!=NULL) {
	  // A included
	  *psat = useB ? -2 : -3;
	}
      }
      Ddi_Free(a2);
      Ddi_Free(b2);


      return interpolant;
    }

  }

  if (undefined) {
    *psat = 0;
  }

  if (*psat || (undefined && !itpPart)) {
    if (DdiAig2CnfIdIsOpen(ddm))
      aig2CnfIdClose(ddm);

    Ddi_Free(a2);
    Ddi_Free(b2);
    //    S22->deleteProofTemps();
    if (!incrSat!=NULL) {
      delete S22;
    }
    else {
      Ddi_IncrSatMgrQuitKeepDdi(incrSat);
    }
    Ddi_Free(vA);
    if (undefined) {
      *psat = -1;
      return interpolant;
    }
    return NULL;
  }

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
    nodeAuxChar(bmgr,varIndex) = 3;
  }

  if (noOK) {
    success = false;
  }
  else if (undefined) {
    interpolant = Ddi_BddMakeConstAig(ddm, 1);
  }
  else {

    success = Minisat22Interpolant ((void *)S22, ddm, a2, b2,
                                    nACl, globalVars, 
				    0, &interpolant, &interpolantOpt,
				    optCare, nSuppVars,itpOdc,1);

    if (0 && interpolant != NULL && Ddi_BddIsOne(interpolant)) {
      // problem! Force a fix with old minisat
      fprintf(dMgrO(ddm)," Minisat 22 Interpolant ABORTED as = 1\n");
      Ddi_Free(interpolant);
      success = false;
    }

    if (interpolant != NULL && itpCoreTh>0 &&
      ((itpSize = Ddi_BddSize(interpolant)) > itpCoreTh)) {
      //      addReverseItp=1;
      if (itpSize > 10*sizeB) addReverseItp=0;
    }

    if (addReverseItp || tryRevItp) {
      Minisat22Interpolant ((void *)S22, ddm, a2, b2, 0, globalVars, 1,
                          &reverseInterpolant,
                          &interpolantOpt,
			    optCare, nSuppVars,itpOdc,0);
    }
    if (tryRevItp && interpolant!=NULL) {
      int sizeR = Ddi_BddSize(reverseInterpolant);
      itpSize = Ddi_BddSize(interpolant);
      if (sizeR < itpSize) {
        Ddi_Bdd_t *tmp = reverseInterpolant;
        reverseInterpolant = interpolant;
        interpolant = tmp;
        Ddi_BddNotAcc(interpolant);
        Ddi_BddNotAcc(reverseInterpolant);
        Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c,
          printf("Swapping direct/rev ITP: %d/%d)\n", 
                itpSize, sizeR));
        itpSize = sizeR;
      }
      if (!addReverseItp) {
        Ddi_Free(reverseInterpolant);
      }
    }
  }

  if (S22b!=NULL && success==true) {
    int pivot = S22->maxPivot(0);
    if (pivot>=0) {
      int na = assumps.size();
      int sat;
      Minisat::vec<Minisat::Lit> assumps22;
      MinisatTo22(assumps22,assumps);
      
      assumps22.push();
      
      startTime = util_cpu_time ();

      assumps22[na] = Minisat::mkLit(pivot,0);
      
      sat = S22b->solve(assumps22);
      cpuTime = util_cpu_time () - startTime;
      fprintf(dMgrO(ddm),"Solver2 split time 0 = %s)\n", 
	    util_print_time(cpuTime));
      fprintf(dMgrO(ddm),
	 "Solver 22 stats: %ld/%ld/%ld dec./prop./confl.\n",
	 (int)S22b->decisions, (int)S22b->propagations,
	 (int)S22b->conflicts);

      assumps22[na] = Minisat::mkLit(pivot,1);
      
      startTime = util_cpu_time ();

      sat = S22b->solve(assumps22);

      cpuTime = util_cpu_time () - startTime;
      fprintf(dMgrO(ddm),"Solver2 split time 1 = %s)\n", 
	    util_print_time(cpuTime));
      fprintf(dMgrO(ddm),
	 "Solver 22 stats: %ld/%ld/%ld dec./prop./confl.\n",
	 (int)S22b->decisions, (int)S22b->propagations,
	 (int)S22b->conflicts);


    }
    delete S22b;
  }

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v);
    Pdtutil_Assert(varIndex != bAig_NULL,"NULL variable");
    nodeAuxChar(bmgr,varIndex) = 0;
  }

  Ddi_Free(vA);

  if (doIncrSat) {
    Ddi_IncrSatMgrQuitKeepDdi(incrSat);
  }
  aig2CnfIdClose(ddm);

  if (0 && (reverseInterpolant!=NULL)) {
    printf("checking ITP <-> ITPR: %d - %d\n",
           Ddi_BddSize(interpolant),Ddi_BddSize(reverseInterpolant));
    Pdtutil_Assert(!Ddi_AigSatAnd(interpolant,reverseInterpolant,0),"wrong reverse ITP");
    //    Ddi_Free(reverseInterpolant);
  }

  if (!incrSat!=NULL && S22!=NULL) {
    delete S22;
  }

  if (success==false) {
    int itpCore = ddm->settings.aig.itpCore;
    // need to check global vars adfter core, missing some.
    //ddm->settings.aig.itpCore = 0;
    interpolant = Ddi_AigSatAndWithInterpolant(a, b,
			globalVars, domainVars, optCare,
					       prevItp,NULL,NULL,
                        psat, itpPart, itpOdc, timeLimit);
    ddm->settings.aig.itpCore = itpCore;
  }

  if (interpolant != NULL && checkInterpolant>1 && !undefined) {
    Ddi_BddSetAig(a);
    Ddi_Bdd_t *tmp = Ddi_BddDiff(a,interpolant);
    {
      Pdtutil_Assert(!Ddi_AigSatAnd(tmp,optCare,NULL), "invalid interpolant (A)");
      Ddi_Free(tmp);
      Pdtutil_Assert(!Ddi_AigSatAnd(interpolant,b,optCare), "invalid interpolant");
    }
    Ddi_Free(tmp);
  }

  if (interpolant!=NULL && ddm->settings.aig.itpStore != NULL &&
      Ddi_BddSize(interpolant) > itpStoreTh) {
    Ddi_Bddarray_t *benchArray;
    char filename[100];
    benchArray = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_BddarrayInsertLast(benchArray, interpolant);
    if (Ddi_BddIsPartConj(a)) {
      Ddi_Bdd_t *aAig = Ddi_BddMakeAig(a);
      Ddi_BddarrayInsertLast(benchArray, aAig);
      Ddi_Free(aAig);
    }
    else {
      Ddi_BddarrayInsertLast(benchArray, a);
    }
    Ddi_BddarrayInsertLast(benchArray, b);
#if 1
    if (optCare != NULL && !Ddi_BddIsOne(optCare)) {
      Ddi_BddarrayInsertLast(benchArray, optCare);
    }
    if (prevItp != NULL && !Ddi_BddIsOne(prevItp)) {
      Ddi_BddarrayInsertLast(benchArray, prevItp);
    }
#if 0
    else {
      optCare = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_BddarrayInsertLast(benchArray, optCare);
      Ddi_Free(optCare);
      optCare = NULL;
    }
#endif
#endif
    if (Ddi_BddReadComposeF(b)!=NULL) {
      Ddi_Bddarray_t *litsAndSubst =
        Ddi_BddarrayMakeLiteralsAig(Ddi_BddReadComposeVars(b), 1);
      Ddi_BddarrayInsertLast(benchArray, Ddi_BddReadComposeF(b));
      Ddi_BddarrayAppend(benchArray,litsAndSubst);
      Ddi_BddarrayAppend(benchArray,Ddi_BddReadComposeSubst(b));
      Ddi_Free(litsAndSubst);
    }

    //sprintf(filename, "%s_%d.bench", ddm->settings.aig.itpStore, ++benchCount);
    //Ddi_AigarrayNetStore(benchArray, filename, NULL, Pdtutil_Aig2BenchLocalId_c);

    sprintf(filename, "%s_%03d.aig", ddm->settings.aig.itpStore, ++benchCount);
    Ddi_AigarrayNetStoreAiger(benchArray, 0, filename);
    Ddi_Free(benchArray);
  }

  if (interpolant!=NULL && Ddi_BddSize(interpolant) > itpStructOdcTh ) {
    int sizeRef = 0;
    Ddi_AigStructRedRemAcc (interpolant,NULL);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMed_c,
      printf("TOT aig after struct rr: %d)\n", Ddi_MgrReadAigNodesNum(ddm))
    );
    if (1) {
      Ddi_Bdd_t *saveI = Ddi_BddDup(interpolant);
      ddiAbcOptAcc (saveI,-1);
      sizeRef = Ddi_BddSize(saveI);
      Ddi_Free(saveI);
    }
    Ddi_NnfClustSimplifyAcc(interpolant,0);
    if (sizeRef > 0) {
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelDevMin_c,
	 printf("ABC / nnf simp: %d/%d\n", 
		sizeRef, Ddi_BddSize(interpolant)));
    }

    int doNnfOdcSimplify = 0;
    if (doNnfOdcSimplify) {
      Ddi_NnfOdcSimplifyAcc (interpolant,b2,1);
    }

  }

  if (interpolant!=NULL && ddm->settings.aig.itpAbortTh<-1 &&
      Ddi_BddSize(interpolant) > -ddm->settings.aig.itpAbortTh) {
    Ddi_Free(interpolant);
  }

  if ((itpTwiceTh > 0) && (interpolant != NULL) &&
      (Ddi_BddSize(interpolant) > itpTwiceTh)) {
    int mySat, itpAbortTh = ddm->settings.aig.itpAbortTh;
    int myItpAigCore = ddm->settings.aig.itpAigCore;
    Ddi_Bdd_t *newB = Ddi_BddNot(interpolant);
    Ddi_Free(interpolant);
    ddm->settings.aig.itpTwice = 0;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("ITP twice\n");
    }
    // negative for early check
    ddm->settings.aig.itpAbortTh = -Ddi_BddSize(newB);
    ddm->settings.aig.itpAigCore = 0;
    interpolant = Ddi_AigSatAndWithInterpolant (a,newB,
       NULL,NULL,optCare,NULL,NULL,NULL,&mySat,0,0,2*itpSatTime/1000.0);
    ddm->settings.aig.itpAbortTh = itpAbortTh;
    ddm->settings.aig.itpTwice = itpTwiceTh;
    ddm->settings.aig.itpAigCore = myItpAigCore;
    Pdtutil_Assert(interpolant==NULL||!mySat,"error recomputing itp");
    if ((interpolant==NULL) ||
        (Ddi_BddSize(newB)<Ddi_BddSize(interpolant))) {
      Ddi_Free(interpolant);
      interpolant = Ddi_BddNot(newB);
    }
    else {
      itpCoreTh = 0;
    }
    Ddi_Free(newB);
  }

  if (storeItp && interpolant!=NULL) {
    Ddi_Bddarray_t *benchArray;
    char filename[100];
    sprintf(filename, "itpOpt%02d.bench", benchCount);
    benchArray = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_BddarrayInsertLast(benchArray, interpolant);
    if (optCare != NULL) {
      Ddi_BddarrayInsertLast(benchArray, optCare);
    } else {
      optCare = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_BddarrayInsertLast(benchArray, optCare);
      Ddi_Free(optCare);
      optCare = NULL;
    }
    Ddi_AigarrayNetStore(benchArray, filename, NULL, Pdtutil_Aig2BenchLocalId_c);
    Ddi_Free(benchArray);
  }

  if (interpolant != NULL) {
    Ddi_Vararray_t *vA = Ddi_AigDFSOrdVars(interpolant);
    vararray2AigActivity(vA, 1.0);
    Ddi_Free(vA);
  }

  if (interpolant != NULL && checkInterpolant && !undefined) {
    Ddi_BddSetAig(a);
    Ddi_Bdd_t *tmp = Ddi_BddDiff(a,interpolant);
    if (optCare!=NULL) {
      Pdtutil_Assert(!Ddi_AigSatAnd(tmp,optCare,NULL),
		     "invalid interpolant (A)");
    }
    else {
      Pdtutil_Assert(!Ddi_AigSat(tmp), "invalid interpolant (A)");
    }
    Ddi_Free(tmp);
    Pdtutil_Assert(!Ddi_AigSatAnd(interpolant,b,optCare),
		   "invalid interpolant");
    Ddi_Free(tmp);
  }

  if (interpolant != NULL)
  {
    int size0, size1, size2, sizeLast, sizeOK;
    Ddi_Varset_t *supp = interpolant != NULL ? Ddi_BddSupp(interpolant) : NULL;
    int bddSizeLimit=500000;
    int sizeTh = (!itpPart || (itpIteOptTh < itpPartTh/2)) ?
      itpIteOptTh : itpPartTh/2;
    //    Pdtutil_Assert(Ddi_AigSat(interpolant),"ZERO interpolant");
    nSuppVars = supp!=NULL ? Ddi_VarsetNum(supp): 0;
    Ddi_Free(supp);

    if (enItpBddOpt) {
      if (nSuppVars > 60*optLevel) enItpBddOpt = 0;
    }

    do {

      int sizeBIG = 100000000;
      int itpSizeOptTh = itpPartTh;
      int abcDone = 0;
      if (!forcePart) {

      if (nSuppVars < 60) {
	itpSizeOptTh /= 2;
      }

      if ((size0=Ddi_BddSize(interpolant)) > 20000 && size0<50000) {
        ddiAbcOptAcc (interpolant,-1);
	abcDone = 1;
	//	DdiAigRedRemovalOdcAcc (interpolant,NULL,5000,-1.0);
	//	Ddi_AigSift(interpolant,optCare);
      }

      size0 = size2 = Ddi_BddSize(interpolant);
      sizeOK = 0;
      sizeOK |= nSuppVars < 30 && Ddi_BddSize(interpolant) < sizeTh*2;
      sizeOK |= nSuppVars < 60 && Ddi_BddSize(interpolant) < sizeTh;
      sizeOK |= nSuppVars < 120 && Ddi_BddSize(interpolant) < sizeTh;
      sizeOK |= Ddi_BddSize(interpolant) < sizeTh;
      sizeOK |= itpPart && (Ddi_BddSize(interpolant) <= itpSizeOptTh);

      }

      if (!forcePart && !undefined && (sizeOK || !itpPart)) {
	int bddDone = 0;
	size1=Ddi_BddSize(interpolant);
	if (0&&Ddi_BddSize(interpolant) < 300000) {
	  Ddi_AigOptTop(interpolant,0,1);
	}
	if ((size1=Ddi_BddSize(interpolant)) > 20000) {
	  abcDone || ddiAbcOptAcc (interpolant,-1);
	  size2=Ddi_BddSize(interpolant);
	  size1=Ddi_BddSize(interpolant);
	}
        Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
  	  fprintf(stdout, "itp opt: %d -> %d\n", size0, size2));

	bddDone = 0;
	if (enItpBddOpt) {
	  bddDone = Ddi_AigOptByBdd(interpolant,timeLimit/5,bddSizeLimit) > 0;
	}
	if (!bddDone && !itpPart && size1 > itpIteOptTh &&
                  ddm->settings.aig.enBddFoConOpt) {
	  Ddi_AigOptByFoCntTop(interpolant, NULL, 0);
	}

	size2=Ddi_BddSize(interpolant);
      }

      if (!forcePart && itpPart && size2 > itpSizeOptTh && size2 < 3000000) {
	  int bddDone = 0;
	  fprintf(dMgrO(ddm),"try opt: %d -> %d\n", size0,
            Ddi_BddSize(interpolant));
	  abcDone || DdiAigRedRemovalAcc (interpolant,optCare,-1,60.0);
	  if (enItpBddOpt) {
  	    bddDone = Ddi_AigOptByBdd(interpolant,timeLimit/5,bddSizeLimit)>0;
	  }
	  if (!bddDone && ddm->settings.aig.enBddFoConOpt) {
	    Ddi_AigOptByFoCntTop(interpolant, NULL, 0);
	  }

	  size2=Ddi_BddSize(interpolant);
      }

      if (interpolant != NULL) {
	sizeLast = Ddi_BddSize(interpolant);
	// Pdtutil_Assert(Ddi_AigSat(interpolant),"ZERO interpolant");
      }
    } while (interpolant != NULL && !itpPart && sizeLast < size0*0.9);
  }


  if (interpolant != NULL && itpCoreTh>0 &&
      ((itpSize = Ddi_BddSize(interpolant)) > itpCoreTh)) {
    int aFirst = 1, tryA=1;
    Ddi_Bdd_t *myA = Ddi_BddDup(a);
    Ddi_Bdd_t *myB = Ddi_BddDup(b);
    Ddi_Bdd_t *myCare = optCare?Ddi_BddDup(optCare):NULL;
    Ddi_Bddarray_t *iteItp = NULL; // Ddi_AigPartitionTopIte(interpolant,1);
    Ddi_Bdd_t *iteConstr=NULL, *iteElse=NULL;
    if (iteItp!=NULL) {
      Ddi_Free(interpolant);
      interpolant = Ddi_BddDup(Ddi_BddarrayRead(iteItp,1));
      iteConstr = Ddi_BddDup(Ddi_BddarrayRead(iteItp,0));
      Ddi_Free(iteItp);
      Ddi_AigConstrainCubeAcc(myA,Ddi_BddPartRead(iteConstr,0));
      Ddi_AigConstrainCubeAcc(myB,Ddi_BddPartRead(iteConstr,0));
      if (myCare!=NULL) {
        myCare = Ddi_BddDup(Ddi_BddPartRead(iteConstr,1));
      }
      else {
        Ddi_BddAndAcc(myCare,Ddi_BddPartRead(iteConstr,1));
      }
      Ddi_AigAndCubeAcc(myCare,Ddi_BddPartRead(iteConstr,0));
    }

    if (0&&(!Ddi_BddIsComplement(interpolant))) {
      aFirst = 1;
    }
    if (reverseInterpolant!=NULL || prevItp!=NULL) {
      aFirst = 1;
    }
    // Ddi_BddNotAcc(interpolant);
    // Pdtutil_Assert(!Ddi_AigSatAnd(a,interpolant,optCare),"wrong itp");
    // Ddi_BddNotAcc(interpolant);
#if 0
    Ddi_AigStructRedRemAcc (interpolant,NULL);
    Ddi_NnfIteSimplifyAcc (interpolant,myA,1,myCare);
#endif

    if (aFirst) {
      Ddi_Bdd_t *myA2 = Ddi_BddDup(myA);
      if (prevItp!=NULL) {
	Ddi_BddDiffAcc(myA2,prevItp);
      }
      Ddi_AigOptByMonotoneCoreAcc (interpolant,myA2,myCare,1,-1.0);
      if (prevItp!=NULL) {
	Ddi_BddOrAcc(interpolant,prevItp);
	Ddi_AigOptByMonotoneCoreAcc (interpolant,myA,myCare,1,-1.0);
      }
      Ddi_Free(myA2);
    }

    if (reverseInterpolant != NULL) {
      Ddi_AigStructRedRemAcc (reverseInterpolant,NULL);
      Ddi_NnfClustSimplifyAcc(reverseInterpolant,0);
      ddiAbcOptAcc (reverseInterpolant,-1);
      if (Ddi_BddSize(reverseInterpolant)>Ddi_BddSize(myB)*2) {
	Ddi_Free(reverseInterpolant);
      }
    }
    if (reverseInterpolant != NULL) {
      printf("using reverse ITP <-> ITPR: %d - %d\n",
           Ddi_BddSize(interpolant),Ddi_BddSize(reverseInterpolant));
      Ddi_BddNotAcc(reverseInterpolant);
#if 0
      Ddi_Bdd_t *myA2 = Ddi_BddDup(myA);
      Ddi_AigOptByMonotoneCoreAcc (reverseInterpolant,myA2,
                                   myCare,1,-1.0);
      Ddi_Free(myA2);
      if (Ddi_BddSize(reverseInterpolant)<0.5*Ddi_BddSize(interpolant)) {
        Ddi_DataCopy(interpolant,reverseInterpolant);
      }
      else
#endif
      {
        Ddi_BddNotAcc(reverseInterpolant);
	if (coreByRefinement) {
	  if (Ddi_AigOptByMonotoneCoreByRefinementAcc (interpolant,
                                     reverseInterpolant,
					 myCare,0,-1.0) == NULL) {
	    Ddi_Free(reverseInterpolant);
	  }
	}
	else {
	  if (Ddi_AigOptByMonotoneCoreAcc (interpolant,
                                     reverseInterpolant,
					 myCare,0,-1.0) == NULL) {
	    Ddi_Free(reverseInterpolant);
	  }
	}
      }
    }


#if 1
    if (reverseInterpolant!=NULL) {
      Ddi_Free(reverseInterpolant);
    }
    else {
    if (saveBCore) {
      Pdtutil_Assert(cnfMappedVars!=NULL,"cnf mapped needed");
      aigOptByMonotoneCoreAcc (interpolant,myB,myCare,
			       &coreBClauses,NULL,
                               NULL,cnfMappedVars,0,0,0,-1.0);
    }
    else {
      //  Ddi_AigOptByMonotoneCoreDualAcc (interpolant,myA,myB,myCare,-1.0);

      if (0 && itpSize > itpCoreTh*10) {
	Ddi_AigOptByMonotoneCorePartAcc0 (interpolant,myB,myCare,
					 NULL,NULL,NULL,8,0,-1.0);
      }
      else {
	if (coreByRefinement) {
	  Ddi_AigOptByMonotoneCoreByRefinementAcc (interpolant,
						   myB,myCare,0,-1.0);
	}
	else {
	  Ddi_AigOptByMonotoneCoreAcc (interpolant,myB,myCare,0,-1.0);
	}
      }
    }
    }
#else
    Ddi_AigOptByMonotoneCorePartAcc (interpolant,myB,myCare,
				     NULL,NULL,NULL,8,0,-1.0);
    Pdtutil_Assert(!Ddi_AigSatAnd(myB,interpolant,myCare),"wrong itp");
    Ddi_BddNotAcc(interpolant);
    Pdtutil_Assert(!Ddi_AigSatAnd(myA,interpolant,myCare),"wrong itp");
    Ddi_BddNotAcc(interpolant);
#endif
    if (tryA) {
      if (aFirst) {
	Ddi_AigOptByMonotoneCoreAcc (interpolant,myA,myCare,1,-1.0);
	Ddi_AigStructRedRemAcc (interpolant,NULL);
	ddiAbcOptAcc (interpolant,-1);
	if (Ddi_BddSize(interpolant)>itpCoreTh*10) {
	  Ddi_AigOptByMonotoneCoreAcc (interpolant,myB,myCare,0,-1.0);
	}
      }
      else {
	if (Ddi_BddSize(interpolant)>itpCoreTh) {
	  Ddi_AigOptByMonotoneCoreAcc (interpolant,myA,myCare,1,-1.0);
	}
      }
    }
    if (Ddi_BddSize(interpolant)>itpCoreTh) {
      Ddi_AigOptByFoCntTop(interpolant, NULL, 0);
    }

    if (iteConstr!=NULL) {
      Ddi_Bdd_t *newItp = Ddi_BddIte(iteConstr,interpolant,iteElse);
      Ddi_Free(interpolant);
      interpolant = newItp;
    }

    Ddi_Free(myA);
    Ddi_Free(myB);
    Ddi_Free(myCare);
    Ddi_Free(iteConstr);
    Ddi_Free(iteElse);

  }

  Ddi_Free(reverseInterpolant);
  Ddi_Free(a2);
  Ddi_Free(b2);

  if (cnfMappedVars!=NULL) bAigArrayFree(cnfMappedVars);

  //  Ddi_MgrConsistencyCheck (ddm);

  if (interpolant!=NULL && ddm->settings.aig.itpAbortTh>0 &&
      Ddi_BddSize(interpolant) > ddm->settings.aig.itpAbortTh) {
    Ddi_Free(interpolant);
  }

  return(interpolant);
}


 
/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
proof22toChecker(
  Minisat::vec< Minisat::vec<Minisat::Lit> >& clauses, 
  Minisat::vec< Minisat::vec<int> >& proofNodes,
  Minisat::vec< Minisat::vec<Minisat::Lit> >& pivots,
  Minisat::vec< Minisat::vec<Minisat::Lit> > *topResClauses,
  struct Checker *travP,
  int nACl,
  int *remapClauseIds
)
{
  Ddi_Mgr_t *ddm = travP->ddiMgr;
  int i, j, nCl = 0;
  vec<Lit> cl;
  vec<int> chain;

  travP->nAClauses = nACl;
  assert(nACl>=0);
  
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    printf("# A cl: %d/%d\n", nACl, clauses.size());
  }

  travP->clauses.clear();
  travP->topResClauses.clear();
  travP->proofNodes.clear();
  travP->vars.clear();

  if (remapClauseIds!=NULL) {
    nCl = nACl;
  }
  else {
    nCl = clauses.size();
  }
  
  travP->clauses.growTo(nCl);
  travP->isRoot.growTo(nCl);
  travP->isCore.growTo(nCl);

  // A clauses (and B clauses if no remap)
  for (i=0; i<clauses.size(); i++) {
    j = remapClauseIds==NULL ? i : remapClauseIds[i];
    if (j<0) continue;
    Pdtutil_Assert(j>=0 && j<nCl,"wrong clause id");
    Pdtutil_Assert(clauses[i].size(),"void clause");
    //Minisat22PrintClause(clauses[i]);
    MinisatFrom22(clauses[i],cl);
    cl.copyTo(travP->clauses[j]);
    travP->isRoot[j] = (char)1;
    travP->isCore[j] = (char)1;
    nCl++;
  }
  if (remapClauseIds!=NULL) {
    // B clauses if remap
    for (i=0; i<clauses.size(); i++) {
      if (remapClauseIds[i] >= 0) continue;
      remapClauseIds[i] = nCl++;
      travP->clauses.push();
      MinisatFrom22(clauses[i],cl);
      cl.copyTo(travP->clauses.last());
      travP->isRoot.push((char)1);
      travP->isCore.push((char)1);
    }
  }
  else {
    nCl = clauses.size();
  }
  
  Pdtutil_Assert(nCl==clauses.size(),"clause num mismatch");
  for (i=0; i<proofNodes.size(); i++) {
    travP->proofNodes.push();
    if (proofNodes[i].size()>0) {
      chain.clear();
      for (j=0; j<proofNodes[i].size(); j++) {
	int id = (proofNodes[i])[j];
	if (id < nCl) {
	  // clause id - remap
	  id = remapClauseIds==NULL ? id : remapClauseIds[id];
	}
	chain.push (id);
      }
      chain.copyTo(travP->proofNodes.last());
      travP->isRoot.push((char)0);
      travP->isCore.push((char)1);
    }
  }

  if (topResClauses!=NULL && topResClauses->size()>0) {
    travP->topResClauses.growTo(topResClauses->size());
    for (i=0; i<topResClauses->size(); i++) {
      if ((*topResClauses)[i].size()>0) {
	MinisatFrom22((*topResClauses)[i],cl);
	cl.copyTo(travP->topResClauses[i]);
      }
    }
  }

  for (i=0; i<pivots.size(); i++) {
    travP->vars.push();
    if (pivots[i].size()>0) {
      MinisatFrom22(pivots[i],cl);
      cl.copyTo(travP->vars.last());
    }
  }

}


static int
trySatClauseArray(
  Minisat::vec< Minisat::vec<Minisat::Lit> > *clauses1,
  int s1,
  int n1,
  Minisat::vec< Minisat::vec<Minisat::Lit> > *clauses2,
  int s2,
  int n2,
  Ddi_Bdd_t *f
)
{
  Minisat22Solver S;
  Minisat::vec< Minisat::vec<Minisat::Lit> > *clauses[2];
  int s[2]={s1,s2};
  int n[2]={n1,n2};
  assert(clauses1!=NULL || f!=NULL);

  clauses[0]=clauses1;
  clauses[1]=clauses2;
  
  for (int j=0; j<2 && clauses[j]!=NULL; j++) {
    if (n[j]<=0 || n[j]>clauses[j]->size())
      n[j] = clauses[j]->size();
    if (s[j]<0 || s[j]>=clauses[j]->size())
      s[j] = 0;
    for (int i=s[j]; i<n[j]; i++) {
      Minisat::vec<Minisat::Lit>& c = (*clauses[j])[i];
      Minisat::vec<Minisat::Lit> lits22;
      for (int k=0; k<c.size(); k++) {
        int v = Minisat::var(c[k]);
        while (v >= S.nVars()) S.newVar();
        lits22.push(c[k]);
      }
      S.addClause(lits22);
    }
  }
  if (f!=NULL) {
    Minisat22Clauses((void *)&S,f,NULL,NULL,0);
  }
  int ret = S.solve();
  return ret;
}

static Ddi_Bdd_t *
Minisat22NnfAbstrPba(
  Ddi_Bdd_t *f,
  Minisat::vec< Minisat::vec<Minisat::Lit> >& clauses,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  int useTwoRails = 0;
  Minisat22Solver S;
  static int nCalls = 0;
  nCalls ++;

  S.proofLogging(1);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  if (verbosity >= Pdtutil_VerbLevelUsrMin_c)
    S.proofPdt.setVerbosity(1);
  if (verbosity >= Pdtutil_VerbLevelDevMax_c)
    S.proofPdt.setVerbosity(2);
  S.eliminate(true); // run off simplification

  assert(f!=NULL);

  S.pdtAddClauses(clauses);

  Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV0 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV1 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);

  Ddi_Bdd_t *fNnf = Ddi_AigNnf (f,NULL,constr,rV,aV0,
                                useTwoRails?aV1:NULL);

  Minisat22Clauses((void *)&S,constr,NULL,NULL,0);
  S.simplify();
  int nClausesNoF = S.nClauses();
  S.proofEndAClauses();
  
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  ddm->settings.aig.aigCnfLevel = 1;
  Minisat22Clauses((void *)&S,fNnf,NULL,NULL,0);
  ddm->settings.aig.aigCnfLevel = aigCnfLevel;

  if (0)
  for (int i=0; i<Ddi_VararrayNum(rV); i++) {
    Ddi_Var_t *r_i = Ddi_VararrayRead(rV,i);
    Ddi_Var_t *a0_i = Ddi_VararrayRead(aV0,i);
    Ddi_Var_t *a1_i = Ddi_VararrayRead(aV1,i);
    int vr = aig2CnfId(bmgr,Ddi_VarToBaig(r_i))-1;
    int va0 = aig2CnfId(bmgr,Ddi_VarToBaig(a0_i))-1;
    int va1 = aig2CnfId(bmgr,Ddi_VarToBaig(a1_i))-1;
    while (vr>S.nVars()) S.newVar();
    while (va0>S.nVars()) S.newVar();
    while (va1>S.nVars()) S.newVar();
    assert(vr<=S.nVars()&&va0<=S.nVars()&&va1<=S.nVars());
    // vr -> !va0: !vr + !va0
    Minisat22Clause2(&S,-vr,-va0);
    // vr -> va1: !vr + va1
    Minisat22Clause2(&S,-vr,va1);
    // vr <- !va0: !vr + !va0
    Minisat22Clause2(&S,-vr,-va0);
    // vr <- va1: !vr + va1
    Minisat22Clause2(&S,-vr,va1);
  }
  
  Ddi_Bdd_t *fAbstr=NULL;
  long cpuTime=0, startTime=0;

  startTime = util_cpu_time ();
  int ret=0;
  if (timeLimit >= 0) {
    Minisat::vec<Minisat::Lit> assumps22;
    S.setTimeBudget((double)timeLimit);
    ret = S.solveLimitedInt(assumps22);
  }
  else {
    ret = S.solve(false,true);
  }
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"NNF PBA Solver time%s = %s)\n", 
            ret<0?" (undefined)":"", util_print_time(cpuTime));
    fprintf(dMgrO(ddm),
          "NNF PBA Solver stats: %ld/%ld/%ld dec./prop./confl.\n",
	 (int)S.decisions, (int)S.propagations,
	 (int)S.conflicts);
  }
  //  assert (!ret);
  
  if (!ret) {
    int nCut=0;

    //    if (cpuTime > 5000) {
    //      S.printLearntsLitStats();
    //    }
    
    Minisat::TraceProofVisitor v(S, stdout);
    startTime = util_cpu_time ();
    S.validate(v);
    cpuTime = util_cpu_time () - startTime;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"NNF PBA Solver Validation time = %s)\n", 
              util_print_time(cpuTime));
    }
    static int genProof = 0;

    if (genProof) {
      startTime = util_cpu_time ();
      S.replay(v);
      cpuTime = util_cpu_time () - startTime;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
        fprintf(dMgrO(ddm),"NNF PBA Solver Replay time = %s)\n", 
                util_print_time(cpuTime));
        
        fprintf(dMgrO(ddm),"NNF Solver res: %d\n", 
                S.proofPdt.resNodes.size());
      }
    }
    
    if (1) {
      //assert(nClausesNoF>0);
      int nAClCore=0;
      int nAbstrCand=0;
      //      S.printProof(1);

      if (genProof) {
        S.proofClassifyNodes(-1,false);
        S.proofSetupVars();
      }
      S.proofSetupProofVars();

      // S.printProof(1);
      vec<Var> coreVars;
      vec<Var> sharedVars;
      vec<bool> usedVar(S.nVars(),false); // all used
#if 0
      for (int i=0; i<clauses.size(); i++) {
        Minisat::vec<Minisat::Lit>& cl = clauses[i];
        for(int j=0;j<cl.size();j++) {
          int v = Minisat::var(cl[j]);
          //assert(usedVar[v]);
          usedVar[v] = true; // set vars in core
          S.proofPdt.setAvar(v,true);
          if (S.proofPdt.Bvar(v)) {
            S.proofPdt.setGlobal(v,true);
          }
        }
      }
#endif
      int logVars = 0;
      for (int i=0; i<S.nVars(); i++) {
        if (!S.proofPdt.UsedVar(i)) {
          // these are vars not apearing in clauses
          coreVars.push(i<<2);
        }
        else if (S.proofPdt.Global(i)) {
          //          assert(usedVar[i]);
          sharedVars.push(i<<2);
          if (logVars) {
            printf("var: %d - pdtv: %d - baig: %d",
                   i, i+1, ddm->cnf.cnf2aig[i+1]/4);
            printf(" G var\n");
          }
        }
        else if (S.proofPdt.Bvar(i)) {
	  //          assert (!usedVar[i]);
          coreVars.push(i<<2);
          // assert(usedVar[i]);
          if (logVars) {
            printf("var: %d - pdtv: %d - baig: %d",
                   i, i+1, ddm->cnf.cnf2aig[i+1]/4);
            printf(" B var\n");
          }
        }
        else if (1 && S.proofPdt.Avar(i)) {
          coreVars.push(i<<2);
          if (logVars) {
            printf("var: %d - pdtv: %d - baig: %d",
                 i, i+1, ddm->cnf.cnf2aig[i+1]/4);
            printf(" A var\n");
          }
        }
      }

      for (int i=S.nVars(); i<ddm->cnf.maxCnfId; i++) {
        sharedVars.push(i<<2);
      }

      fAbstr = MinisatCoreAig(fNnf,NULL,coreVars,&sharedVars,NULL,
                              &nCut,NULL,NULL,1);

      if (1 || nCut>0) {
        int check = 0;
        if (1 && check) {
          // inclusion
          Ddi_Bdd_t *chk = Ddi_BddDup(fNnf);
          Ddi_BddDiffAcc(chk,fAbstr);
          int mySat = !Ddi_BddIsZero(chk) &&
            trySatClauseArray(NULL,0,0,NULL,0,0,chk);
          assert(!mySat);      
          Ddi_Free(chk);
#if 0
          Ddi_BddSetAig(constr);
          chk = Ddi_BddAnd(fAbstr,constr);
          mySat = trySatClauseArray(&clauses,0,0,NULL,0,0,chk);
          assert(!mySat);      
          Ddi_Free(chk);
#endif
        }
        
        
        Ddi_Bddarray_t *rLits;
        rLits = Ddi_BddarrayMakeLiteralsAig(rV, 0);
        Ddi_BddComposeAcc(fAbstr,aV0,rLits);
        Ddi_Free(rLits);
        if (useTwoRails) {
          rLits = Ddi_BddarrayMakeLiteralsAig(rV, 1);
          Ddi_BddComposeAcc(fAbstr,aV1,rLits);
          Ddi_Free(rLits);
        }

        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
          fprintf(dMgrO(ddm),"NNF PBA size: %d -> %d\n", 
                  Ddi_BddSize(f), Ddi_BddSize(fAbstr));
        }

        if (check) {
          // inclusion
          Ddi_Bdd_t *chk = Ddi_BddDup(f);
          Ddi_BddDiffAcc(chk,fAbstr);
          int mySat = !Ddi_BddIsZero(chk) &&
            trySatClauseArray(NULL,0,0,NULL,0,0,chk);
          assert(!mySat);      
          Ddi_Free(chk);
          // sound abstraction
          mySat = trySatClauseArray(&clauses,0,0,NULL,0,0,fAbstr);
          assert(!mySat);      
        }
      }
      else {
	Ddi_Free(fAbstr);
	fAbstr = Ddi_BddDup(f);
      }
    }
  }
  else {
    fAbstr = Ddi_BddDup(f);
  }

  Ddi_Free(fNnf);
  Ddi_Free(constr);
  Ddi_Free(rV);
  Ddi_Free(aV0);
  Ddi_Free(aV1);

  return fAbstr;
}

 
/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
remapProofVars(
  void    *Svoid,
  Ddi_Mgr_t *ddm,
  Ddi_Vararray_t *auxV,
  Ddi_Bddarray_t *auxF,
  Minisat::vec<int>& remapAuxv,
  vec<int>& saveCnfIds,
  vec<bAigEdge_t>& saveAuxChars,
  vec<char>& saveAuxCharVal
)
{
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  Minisat::ProofPdt& proofPdt = S22->proofPdt;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  char name[100];
  int nSolverVars = S22->nVars(), nSV0 = nSolverVars; 

  remapAuxv.clear();
  remapAuxv.growTo(nSolverVars,var_Undef);

  // save old 
  for (int v=0; v<nSV0; v++) {
    bAigEdge_t baig = ddm->cnf.cnf2aig[v+1];
    int cnfId = DdiAig2CnfId(bmgr,baig);
    char auxc = (char) 0;
    if (proofPdt.Global(v)) {
      if (bAig_isVarNode(bmgr,baig)) {
        Ddi_Var_t *vv = Ddi_VarFromBaig(ddm,baig);
      }
      else {
  	Ddi_Var_t *vAux;
	Ddi_Bdd_t *fAux;
  	sprintf(name,"ITP_AUXV_%d",Ddi_VararrayNum(auxV));
	vAux = Ddi_VarFromName(ddm,name);
	if (vAux == NULL) {
	  vAux = Ddi_VarNewBaig(ddm,name);
	}
	fAux = Ddi_BddMakeFromBaig(ddm, baig);
	Ddi_VararrayInsertLast(auxV,vAux);
	Ddi_BddarrayInsertLast(auxF,fAux);
	Ddi_Free(fAux);
        // replace baig
        baig = Ddi_VarToBaig(vAux);
        cnfId = DdiAig2CnfId(bmgr,baig);
        remapAuxv[v] = cnfId-1;
      }
    }
    DdiCnfSetActive(ddm,cnfId,1);
    if (proofPdt.Global(v)) {
      DdiCnfSetActive(ddm,cnfId,3);
      auxc = 3;
    }
    else if (proofPdt.Avar(v)) {
      DdiCnfSetActive(ddm,cnfId,2);
      auxc = 0;
    }
    else {
      // B var
      auxc = 1;
    }
    saveAuxChars.push(baig);
    char oldc = nodeAuxChar(bmgr,baig);
    saveAuxCharVal.push(oldc);
    saveCnfIds.push(cnfId);
    nodeAuxChar(bmgr,baig) = auxc;

    if ((cnfId)>nSolverVars)
      nSolverVars = cnfId;
  }
  return nSolverVars;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static Ddi_Bdd_t *
getAuxProof22(
  void    *Svoid,
  Ddi_Mgr_t *ddm
)
{
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  long cpuTime=0, startTime=0;
  int nAClausesCore = 0;
  Ddi_Bdd_t *auxItp=NULL;
  
  Minisat::vec< Minisat::vec<int> > proofNodes1;
  Minisat::vec< Minisat::vec<Minisat::Lit> > pivots1;
  Minisat::vec< Minisat::vec<Minisat::Lit> > clauses1;

  int nACl1;
  int useBClausesCovered = 1;
  Minisat::vec< Minisat::vec<Minisat::Lit> > rootClauses;
  Minisat::vec< Minisat::vec<Minisat::Lit> > coveredBClauses;

  int genActLits = ddm->settings.aig.itpActiveVars;
  Minisat::vec<Minisat::Lit> actLits;
  if (genActLits>0) {
    S22->genProofActLitsFromBres(actLits, genActLits);
    if (ddm->aig.actVars!=NULL) {
      Ddi_Unlock(ddm->aig.actVars);
      Ddi_Free(ddm->aig.actVars);
    }
    Ddi_Bddarray_t *actAigs = Ddi_BddarrayAlloc(ddm,0);
    ddm->aig.actVars = actAigs;
    Ddi_Lock(ddm->aig.actVars);
    for (int i=0; i<genActLits; i++) {
      Minisat::Lit l = actLits[i];
      int v = Minisat::var(l);
      int vCnf = v+1;
      bAigEdge_t actBaig = ddm->cnf.cnf2aig[vCnf];
      Ddi_Bdd_t *actAig = Ddi_BddMakeFromBaig(ddm, actBaig);
      if (sign(l)) Ddi_BddNotAcc(actAig);
      Ddi_BddarrayInsertLast(actAigs,actAig);
      Ddi_Free(actAig);
    }
  }

  //S22->printProof(NULL,NULL,1);
  int added = S22->proofMoveNodesToA(0.7);

  Minisat::vec<bool> isAvar, isGlobal;
  Minisat::vec<int> remapAuxv;
  vec<int> saveCnfIds;
  vec<bAigEdge_t> saveAuxChars;
  vec<char> saveAuxCharVal;


  Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm,0);

  int nSolverVars = remapProofVars(S22,ddm,auxV,auxF,
        remapAuxv,saveCnfIds,saveAuxChars,saveAuxCharVal);
  //  S22->printProof(&isAvar,&isGlobl);


  Checker trav(ddm,nSolverVars);
  int nAClCore;
  int reverse = 0; // need to be checked: not working yet
  if (reverse)
    S22->proofReverseAB();

  S22->remapProofVars(remapAuxv);

  // S22->proofClassifyNodes(nSolverACl);
  //S22->printProof(&isAvar,&isGlobal);
  S22->getProof(clauses1, nAClCore, proofNodes1,
		pivots1, NULL);

  Ddi_Bdd_t *itp=NULL;
  if (nAClCore==clauses1.size()) {
    // A is zero - No B clauses needed for unsat
    itp = Ddi_BddMakeConstAig(ddm, 0);
    Ddi_Free(auxF);
    Ddi_Free(auxV);
    return (itp);
  }
  else if (nAClCore==0) {
    // B is zero - No A clauses needed for unsat
    itp = Ddi_BddMakeConstAig(ddm, 1);
    Ddi_Free(auxF);
    Ddi_Free(auxV);
    return (itp);
  }
  else {
    //Minisat::vec< Minisat::vec<Minisat::Lit> > clauses1; 
      
    proof22toChecker(clauses1,proofNodes1,pivots1,NULL,
                 &trav,nAClCore,NULL);


    trav.nAClauses = nAClCore;
    trav.nAClausesRemapped = -1;
    //  trav.proofSize = S.proof->last();
    trav.nLclToGblVars = 0;
    trav.dontCareOpt = 0;
    trav.zeroConstId=0;
    trav.oneConstId=1;
    ddm->stats.aig.itpPartialExist=0;
    trav.rootCustomHandling = 0;
    if (ddm->settings.aig.itpMem>2) {
      trav.useRemapped = 1;
    }
    if (reverse) {
      for (int v=0; v<S22->nVars(); v++) {
        if (!S22->proofPdt.Global(v)) {
          bAigEdge_t baig = ddm->cnf.cnf2aig[v+1];
          int isA = S22->proofPdt.Avar(v);
          nodeAuxChar(bmgr,baig) = isA ? 0 : 1;
        }
      }
    }
    
    trav.done22();
    trav.genitp();

    if (reverse) {
      for (int v=0; v<S22->nVars(); v++) {
        if (!S22->proofPdt.Global(v)) {
          bAigEdge_t baig = ddm->cnf.cnf2aig[v+1];
          int isA = S22->proofPdt.Avar(v);
          nodeAuxChar(bmgr,baig) = isA ? 1 : 0;
        }
      }
    }

    itp = Ddi_BddMakeFromBaig(ddm, trav.nodes.last().aig);

    if (trav.nodes.last().orClause != NULL) {
      Ddi_BddSetAig(trav.nodes.last().orClause);
      Ddi_BddOrAcc(itp,trav.nodes.last().orClause);
    }
    Ddi_AigStructRedRemAcc (itp,NULL);
    Ddi_NnfClustSimplifyAcc(itp,0);
  }
  //  Ddi_AigOptByFoCntTop(itp, NULL, 0);
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    printf("RERUN PARTIAL ITP SIZE: %d - %d auxv used\n\n",
         Ddi_BddSize(itp), Ddi_VararrayNum(auxV));
  }

  if (reverse) Ddi_BddNotAcc(itp);
  
  int checkB = 0;
  if (checkB) {
    Minisat::SimpSolver S22checkB;
    while (S22checkB.nVars()<nSolverVars)
      S22checkB.newVar(); 
    for (int i=nAClCore; i<clauses1.size(); i++) {
      Minisat::vec<Minisat::Lit>& c = clauses1[i];
      Minisat::vec<Minisat::Lit> cRem;
      c.copyTo(cRem);
      S22checkB.addClause(cRem);
    }
    Minisat22Clauses((void *)&S22checkB,itp,NULL,NULL,0);    
    int mySat = S22checkB.solve(false,true);
    Pdtutil_Assert(!mySat,"UNSAT needed for ITP partial");
  }

  Minisat::SimpSolver S22check;
  S22check.proofLogging(1);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  if (verbosity >= Pdtutil_VerbLevelUsrMin_c)
    S22check.proofPdt.setVerbosity(1);
  if (verbosity >= Pdtutil_VerbLevelDevMax_c)
    S22check.proofPdt.setVerbosity(2);
  else
    S22check.proofPdt.setVerbosity(0);
    
  while (S22check.nVars()<nSolverVars)
    S22check.newVar();
  // nAClauses = 0;
  assert(nAClCore<=clauses1.size());

  int nSolverCheckACl = 0;
  

  Minisat::vec< Minisat::vec<Minisat::Lit> > ClA;
  Minisat::vec< Minisat::vec<Minisat::Lit> > ClB;
  Minisat::vec< Minisat::vec<Minisat::Lit> > ClAorig;
  Minisat::vec< Minisat::vec<Minisat::Lit> > ClAfromB;
  Minisat::vec< Minisat::vec<Minisat::Lit> > ClAfromRes;
  
  S22->getProofClausesAfterMove(ClA,ClB,
				ClAorig,ClAfromB,ClAfromRes);

  // load original A clauses
  S22check.pdtAddClauses(ClAorig);
  S22check.proofEndAClauses();
  //  nSolverCheckACl = S22check.nClauses();
  // load A clauses from B
  S22check.pdtAddClauses(ClAfromB);
  // load A clauses from res
  //S22check.pdtAddClauses(ClAfromRes);
  int useItp = S22->proofPdt.B2AvarActive();
  float genAuxClRatio = 0.0; 
  int useBClauses = useItp? 0 : 1;
  // int useBClauses = useItp? 0 : 2;

  if (genAuxClRatio > 0.1) {
    useItp=0;
    useBClauses = 1;
  }
  
  if (useBClauses>1) {
    int sign, nUnate=0, nRed=0;
    int size0 = Ddi_BddSize(itp);
    for (int v=0; v<S22->nVars(); v++) {
      float randRate = 0.1;
      if (S22->proofPdt.GlobalUnateA(v, sign)) {
        nUnate++;
        if (rand()%100 < randRate*100) {
          bAigEdge_t baig = ddm->cnf.cnf2aig[v+1];
          Ddi_Var_t *vAig = Ddi_VarFromBaig(ddm,baig);
          Ddi_BddCofactorAcc(itp,vAig,!sign);
          nRed++;
        }
      }
    }
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"Unate red (%d/%d vars) size %d -> %d\n", 
              nRed, nUnate, size0, Ddi_BddSize(itp));
    }
    if (nRed>0) {
      Minisat22Clauses((void *)&S22check,itp,NULL,NULL,0);    
    }
    S22check.pdtAddClauses(ClB);
  }
  else if (useItp && !useBClauses) {
    Ddi_BddNotAcc(itp);
    Minisat22Clauses((void *)&S22check,itp,NULL,NULL,0);    
  }
  else if (useBClauses==1) {
    S22check.pdtAddClauses(ClB);
  }
  startTime = util_cpu_time ();
  int mySat=0, okay = S22check.okay() && !Ddi_BddIsZero(itp);

  okay = okay && S22check.okay();
  if (genActLits>0 && !useItp) {
    if (okay) {
      while (actLits.size()>0) {
        mySat = S22check.solve(actLits,false,true);
        actLits.pop();
      } 
    }
    if (okay) {
      mySat = S22check.solve(false,true);
    }    
  }
  else if (genAuxClRatio > 0.1) {
    Minisat::vec< Minisat::vec<Minisat::Lit> > ClBaux;
    Minisat::vec<Minisat::Lit> actLits;
    Minisat::vec<Minisat::Lit> actClause;
    S22->genProofAuxClausesFromBres(ClBaux,actLits,actClause,
                                    genAuxClRatio);
    if (ClBaux.size()>0) {
      for (int i=0; i<actClause.size(); i++) {
        int v = Minisat::var(actClause[i]);
        Minisat22FreezeCnfVar (&S22check,v+1);
      }
      S22check.pdtAddClauses(ClBaux);
      S22check.addClause(actClause);
      okay = okay && S22check.okay();
      if (okay) {
        mySat = S22check.solve(actLits,false,true);
      } 
      okay = okay && S22check.okay();
    }
    if (okay) {
      mySat = S22check.solve(false,true);
    }    
  }
  else {
    if (okay)
      mySat = S22check.solve(false,true);
  }

  Pdtutil_Assert(!mySat,"UNSAT needed for solver RRERUN2");
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"Solver RERUN1 with partial itp time = %s)\n", 
	    util_print_time(cpuTime));
    fprintf(dMgrO(ddm),"Solver RERUN1 stats: %ld/%ld vars/clauses\n",
      S22check.nVars(), S22check.nClauses());
    fprintf(dMgrO(ddm),
            "RERUN1 proof has size size %d\n",
	    S22check.proofSize());
    fprintf(dMgrO(ddm),
            "Solver RERUN1 stats: %ld/%ld/%ld dec./prop./confl.\n\n",
	 (int)S22check.decisions, (int)S22check.propagations,
	 (int)S22check.conflicts);
  }

  for (int i = 0; i < trav.nodes.size(); i++) {
    bAig_RecursiveDeref(ddm->aig.mgr,trav.nodes[i].aig);
    trav.nodes[i].aig=bAig_NULL;
    Ddi_Free(trav.nodes[i].orClause);
    //    Ddi_Free(trav.nodes[i].cube);
    trav.nodes[i].isOdc = 0;
    trav.nodes[i].optimized = 0;
    trav.nodes[i].AClause = 0;
    trav.nodes[i].isLiteral = 0;
  }

  for (int i=0; i<saveCnfIds.size(); i++) {
    int cnfId = saveCnfIds[i];
    DdiCnfSetActive(ddm,cnfId,0);
  }
  for (int i=0; i<saveAuxChars.size(); i++) {
    bAigEdge_t baig = saveAuxChars[i];
    nodeAuxChar(bmgr,baig) = saveAuxCharVal[i];
  }

  int itpAgain = okay;
  float itp2TimeLimit = -1.0;
  if (itpAgain) {

    Minisat::TraceProofVisitor v(S22check, stdout);
    startTime = util_cpu_time ();
    S22check.validate(v);
    cpuTime = util_cpu_time () - startTime;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"CHECK Solver Validation time = %s)\n", 
              util_print_time(cpuTime));
    }
    itp2TimeLimit = 8*(float)cpuTime/1000;
    if (itp2TimeLimit < ddm->settings.aig.satTimeLimit)
      itp2TimeLimit = ddm->settings.aig.satTimeLimit;
                           
    startTime = util_cpu_time ();
    bool okReplay = S22check.replay(v);
    cpuTime = util_cpu_time () - startTime;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"RERUN Solver Replay time = %s)\n", 
              util_print_time(cpuTime));
    }
    if (!okReplay) {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
        fprintf(dMgrO(ddm),"CHECK Solver replay failed\n", 
                util_print_time(cpuTime));
      }
    }
    else {
     int nResolvents = 0;
     for (int i=0; i<S22check.proofPdt.resNodes.size(); i++) {
       if (!S22check.proofPdt.resNodes[i].isOriginal())
         nResolvents++;
     }
     Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
       fprintf(dMgrO(ddm),"RERUN Solver res: %d - resolvents: %d\n", 
              S22check.proofPdt.resNodes.size(), nResolvents);
     }
     
     Minisat::vec< Minisat::vec<int> > proofNodes2;
     Minisat::vec< Minisat::vec<Minisat::Lit> > pivots2;
     Minisat::vec< Minisat::vec<Minisat::Lit> > clauses2;
     
     Checker trav2(ddm,S22check.nVars());
     int nAClCore = 0;
     //    assert(nSolverCheckACl>0);
     //    S22check.proofClassifyNodes(nSolverCheckACl,true);
     bool enSimplify = true;
     S22check.proofClassifyNodes(-1,enSimplify);
     S22check.getProof(clauses2, nAClCore, proofNodes2,
                       pivots2,NULL);
     //    S22->printProof(NULL,NULL);
     proof22toChecker(clauses2,proofNodes2,pivots2,NULL,
                      &trav2,nAClCore,NULL);
     
     
     trav2.nAClauses = nAClCore;
     trav2.nAClausesRemapped = -1;
     //  trav.proofSize = S.proof->last();
     trav2.nLclToGblVars = 0;
     trav2.dontCareOpt = 0;
     trav2.zeroConstId=0;
     trav2.oneConstId=1;
     ddm->stats.aig.itpPartialExist=0;
     trav2.rootCustomHandling = 0;
     if (ddm->settings.aig.itpMem>2) {
       trav2.useRemapped = 1;
     }
     
     if (useItp) {
       bAig_array_t *visitedNodes = bAigArrayAlloc();
       postOrderBddAigVisitIntern(itp, visitedNodes, NULL, -1);
       postOrderAigClearVisitedIntern(bmgr,visitedNodes);
       saveAuxChars.clear();
       saveAuxCharVal.clear();
       int n = visitedNodes->num; 
       for (int i=0; i<n; i++) {
         bAigEdge_t baig = visitedNodes->nodes[i];
         if (nodeAuxChar(bmgr,baig) == 0) {
           nodeAuxChar(bmgr,baig) = 1; // B node
           saveAuxChars.push(baig);
         }
       }
       bAigArrayFree(visitedNodes);
     }
     if (useBClauses) {
       saveAuxChars.clear();
       saveAuxCharVal.clear();
       for (int i=0; i<ClB.size(); i++) {
         Minisat::vec<Minisat::Lit>& c = ClB[i];
         for (int j=0; j<c.size(); j++) {
           int v = Minisat::var(c[j]);
           bAigEdge_t baig = ddm->cnf.cnf2aig[v+1];
           if (nodeAuxChar(bmgr,baig) == 0) {
             nodeAuxChar(bmgr,baig) = 1; // B node
             saveAuxChars.push(baig);
           }
         }
       }
       for (int i=nAClCore; i<clauses2.size(); i++) {
         Minisat::vec<Minisat::Lit>& c = clauses2[i];
         for (int j=0; j<c.size(); j++) {
           int v = Minisat::var(c[j]);
           bAigEdge_t baig = ddm->cnf.cnf2aig[v+1];
           assert (nodeAuxChar(bmgr,baig) > 0);
         }
       }
     }
     
     for (int i=0; i<Ddi_VararrayNum(auxV); i++) {
       Ddi_Var_t *v = Ddi_VararrayRead(auxV,i);
       bAigEdge_t varIndex = Ddi_VarToBaig(v);
       nodeAuxChar(bmgr,varIndex) = 3; // common node
       saveAuxChars.push(varIndex);
     }
     
     trav2.done22();
     trav2.genitp();
     
     for (int i=0; i<saveAuxChars.size(); i++) {
       bAigEdge_t baig = saveAuxChars[i];
       nodeAuxChar(bmgr,baig) = 0;
     }
     
     Ddi_Bdd_t *itp2 = Ddi_BddMakeFromBaig(ddm, trav2.nodes.last().aig);
     if (trav2.nodes.last().orClause != NULL) {
       Ddi_BddSetAig(trav2.nodes.last().orClause);
       Ddi_BddOrAcc(itp2,trav2.nodes.last().orClause);
     }
     for (int i = 0; i < trav2.nodes.size(); i++) {
       bAig_RecursiveDeref(ddm->aig.mgr,trav2.nodes[i].aig);
       trav2.nodes[i].aig=bAig_NULL;
       Ddi_Free(trav2.nodes[i].orClause);
       //    Ddi_Free(trav.nodes[i].cube);
       trav2.nodes[i].isOdc = 0;
       trav2.nodes[i].optimized = 0;
       trav2.nodes[i].AClause = 0;
       trav2.nodes[i].isLiteral = 0;
     }
     
     if (useBClauses>1) { // check this....
       Ddi_BddAndAcc(itp2,itp);
     }
    
     int checkItp2=0;
     if (checkItp2) {
       int mySat = trySatClauseArray(&clauses2,nAClCore,0,0,0,0,itp2);
       assert(!mySat);      
       Ddi_BddNotAcc(itp2);
       mySat = trySatClauseArray(&clauses2,0,nAClCore,0,0,0,itp2);
       assert(!mySat);      
       Ddi_BddNotAcc(itp2);
     }
    
     Ddi_AigStructRedRemAcc (itp2,NULL);
     Ddi_NnfClustSimplifyAcc(itp2,0);
     //  Ddi_AigOptByFoCntTop(itp, NULL, 0);
     Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
       printf("RERUN PARTIAL ITP2 SIZE: %d\n\n",
            Ddi_BddSize(itp2));
     }
     int tryNnfAbstr = 1;
     if (tryNnfAbstr) {
       S22check.proofSave();
       if (1)
         S22check.getProofClausesAfterMove(ClA,ClB,
                                   ClAorig,ClAfromB,ClAfromRes);
#if 0
       Ddi_BddNotAcc(itp2);
       Ddi_Bdd_t *itp2AbstrA = Minisat22NnfAbstrPba(itp2,ClA,-1.0);
       Ddi_BddNotAcc(itp2);
       Ddi_BddNotAcc(itp2AbstrA);
#else
       Ddi_Bdd_t *itp2AbstrA = Ddi_BddDup(itp2);
#endif
       Ddi_Bdd_t *itp2Abstr = Minisat22NnfAbstrPba(itp2AbstrA,ClB,itp2TimeLimit);
       Ddi_Free(itp2AbstrA);
       assert (itp2Abstr!=NULL);
       Ddi_Free(itp2);
       itp2 = itp2Abstr;
     }
    
     if (Ddi_VararrayNum(auxV) > 0) {
       Ddi_BddComposeAcc(itp2,auxV,auxF);
     }
     auxItp = itp2;
     //    Ddi_Free(itp2);
    }
  }
  

  Ddi_Free(itp);
  
  Ddi_Free(auxF);
  Ddi_Free(auxV);
  return auxItp;
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
getAuxNewProof22(
  void    *Svoid,
  Ddi_Mgr_t *ddm,
  Minisat::vec< Minisat::vec<Minisat::Lit> >& clauses,
  int nACl,
  int nSolverACl,
  int nACl0
)
{
  Minisat22Solver* S22aux = (Minisat22Solver *)Svoid;
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  long cpuTime=0, startTime=0;

  startTime = util_cpu_time ();
  int mySat = S22aux->solve(false,true);
  Pdtutil_Assert(!mySat,"UNSAT needed for solver RERUN");
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"Solver RERUN with partial pro time = %s)\n", 
	    util_print_time(cpuTime));
    fprintf(dMgrO(ddm),"Solver RERUN stats: %ld/%ld vars/clauses\n",
      S22aux->nVars(), S22aux->nClauses());
    fprintf(dMgrO(ddm),
            "RERUN proof has size size %d\n",
	    S22aux->proofSize());
    fprintf(dMgrO(ddm),
            "Solver RERUN stats: %ld/%ld/%ld dec./prop./confl.\n",
	 (int)S22aux->decisions, (int)S22aux->propagations,
	 (int)S22aux->conflicts);
  }

  Minisat::TraceProofVisitor v(*(Minisat::Solver *)S22aux, stdout);
  startTime = util_cpu_time ();
  S22aux->validate(v);
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"RERUN Solver Validation time = %s)\n", 
	    util_print_time(cpuTime));
  }

  startTime = util_cpu_time ();
  S22aux->replay(v);
  int nResolvents = 0;
  for (int i=0; i<S22aux->proofPdt.resNodes.size(); i++) {
    if (!S22aux->proofPdt.resNodes[i].isOriginal())
      nResolvents++;
  }
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"RERUN Solver Replay time = %s)\n", 
	  util_print_time(cpuTime));
    fprintf(dMgrO(ddm),"RERUN Solver res: %d - resolvents: %d\n", 
            S22aux->proofPdt.resNodes.size(), nResolvents);
  }

  Minisat::vec<bool> isAvar, isGlobal;
  Minisat::vec<int> remapAuxv;
  vec<int> saveCnfIds;
  vec<bAigEdge_t> saveAuxChars;
  vec<char> saveAuxCharVal;

  //  remapAuxv.growTo(S22aux->nVars());
  // get global vars
  int nSolverVars = S22aux->nVars();

  Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm,0);

  remapProofVars(S22aux,ddm,auxV,auxF,remapAuxv,
                 saveCnfIds,saveAuxChars,saveAuxCharVal);

  Checker trav(ddm,nSolverVars);
  int nAClCore;

  Minisat::vec< Minisat::vec<int> > proofNodes1;
  Minisat::vec< Minisat::vec<Minisat::Lit> > pivots1;
  Minisat::vec< Minisat::vec<Minisat::Lit> > clauses1;

  S22aux->remapProofVars(remapAuxv);
  assert(0); // need to check parameter true below
  S22aux->proofClassifyNodes(nSolverACl,true);
  //  S22aux->printProof(&isAvar,&isGlobal);
  S22aux->getProof(clauses1, nAClCore, proofNodes1,
		   pivots1,NULL);

  //Minisat::vec< Minisat::vec<Minisat::Lit> > clauses1; 
  proof22toChecker(clauses1,proofNodes1,pivots1,NULL,
                   &trav,nAClCore,NULL);


  trav.nAClauses = nAClCore;
  trav.nAClausesRemapped = -1;
  //  trav.proofSize = S.proof->last();
  trav.nLclToGblVars = 0;
  trav.dontCareOpt = 0;
  trav.zeroConstId=0;
  trav.oneConstId=1;
  ddm->stats.aig.itpPartialExist=0;
  trav.rootCustomHandling = 0;
  if (ddm->settings.aig.itpMem>2) {
    trav.useRemapped = 1;
  }
  

  trav.done22();
  trav.genitp();
#if 1

  Ddi_Bdd_t *itp = Ddi_BddMakeFromBaig(ddm, trav.nodes.last().aig);
  if (trav.nodes.last().orClause != NULL) {
    Ddi_BddSetAig(trav.nodes.last().orClause);
    Ddi_BddOrAcc(itp,trav.nodes.last().orClause);
  }
  Ddi_AigStructRedRemAcc (itp,NULL);
  Ddi_NnfClustSimplifyAcc(itp,0);
  //  Ddi_AigOptByFoCntTop(itp, NULL, 0);
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    printf("RERUN PARTIAL ITP SIZE: %d - %d auxv used\n\n",
         Ddi_BddSize(itp), Ddi_VararrayNum(auxV));
  }

  Minisat::SimpSolver S22check;
  S22check.proofLogging(1);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  if (verbosity >= Pdtutil_VerbLevelUsrMax_c)
    S22check.proofPdt.setVerbosity(1);
  else if (verbosity >= Pdtutil_VerbLevelDevMax_c)
    S22check.proofPdt.setVerbosity(2);
  else
    S22check.proofPdt.setVerbosity(0);
    
  while (S22check.nVars()<nSolverVars)
    S22check.newVar();
  // nAClauses = 0;
  assert(nAClCore<=clauses1.size());

  for (int i=0; i<nAClCore; i++) {
    Minisat::vec<Minisat::Lit>& c = clauses1[i];
    Minisat::vec<Minisat::Lit> cRem;
    c.copyTo(cRem);
    S22check.addClause(cRem);
  }

  Ddi_BddNotAcc(itp);
  Minisat22Clauses((void *)&S22check,itp,NULL,NULL,0);    
  startTime = util_cpu_time ();
  mySat = S22check.solve(false,true);
  Pdtutil_Assert(!mySat,"UNSAT needed for solver RRERUN2");
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"Solver RERUN2 with partial itp time = %s)\n", 
	    util_print_time(cpuTime));
    fprintf(dMgrO(ddm),"Solver RERUN2 stats: %ld/%ld vars/clauses\n",
      S22check.nVars(), S22check.nClauses());
    fprintf(dMgrO(ddm),
            "RERUN2 proof has size size %d\n",
	    S22check.proofSize());
    fprintf(dMgrO(ddm),
            "Solver RERUN2 stats: %ld/%ld/%ld dec./prop./confl.\n\n",
	 (int)S22check.decisions, (int)S22check.propagations,
	 (int)S22check.conflicts);
  }
  Ddi_Free(itp);
#endif

  for (int i = 0; i < trav.nodes.size(); i++) {
    bAig_RecursiveDeref(ddm->aig.mgr,trav.nodes[i].aig);
    trav.nodes[i].aig=bAig_NULL;
    Ddi_Free(trav.nodes[i].orClause);
    //    Ddi_Free(trav.nodes[i].cube);
    trav.nodes[i].isOdc = 0;
    trav.nodes[i].optimized = 0;
    trav.nodes[i].AClause = 0;
    trav.nodes[i].isLiteral = 0;
  }

  for (int i=0; i<saveCnfIds.size(); i++) {
    int cnfId = saveCnfIds[i];
    DdiCnfSetActive(ddm,cnfId,0);
  }
  for (int i=0; i<saveAuxChars.size(); i++) {
    bAigEdge_t baig = saveAuxChars[i];
    nodeAuxChar(bmgr,baig) = saveAuxCharVal[i];
  }
  
  Ddi_Free(auxF);
  Ddi_Free(auxV);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
markProofVars(
  void    *Svoid,
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  Minisat::vec< Minisat::vec<Minisat::Lit> > clauses; 

  if (b==NULL) return;
  if (Ddi_BddReadComposeF(b)==NULL) return;

  Ddi_Bddarray_t *bFirstFrames = Ddi_BddReadComposeSubst(b);
  assert(bFirstFrames!=NULL);
 
  bAig_array_t *aigNodes = bAigArrayAlloc();
  for (int i=0; i<Ddi_BddarrayNum(bFirstFrames); i++) {
    Ddi_Bdd_t *bf_i = Ddi_BddarrayRead(bFirstFrames,i);
    Ddi_PostOrderBddAigVisitIntern(bf_i,aigNodes,-1);
  }
  Ddi_PostOrderAigClearVisitedIntern(bmgr,aigNodes);
  for (int i=0; i<aigNodes->num; i++) {
    bAigEdge_t baig = aigNodes->nodes[i];
    int cnfId = DdiAig2CnfId(bmgr,baig);
    Minisat::Var v = cnfId-1;
    S22->proofPdt.varSetB2A(v);
  }
 
}
 
/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static Ddi_Bdd_t *
getProof22(
  void    *Svoid,
  struct Checker *travP,
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  int nAClauses,
  Ddi_Varset_t *globalvars,
  int computeAuxItp
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  Minisat::vec< Minisat::vec<Minisat::Lit> > clauses; 
  Minisat::vec< Minisat::vec<int> > proofNodes;
  Minisat::vec< Minisat::vec<Minisat::Lit> > pivots;
  Minisat::vec< Minisat::vec<Minisat::Lit> > topResCl;
  Minisat::vec< Minisat::vec<Minisat::Lit> > *topResClP=NULL;
  
  vec<Lit> cl;
  vec<int> chain;
  int *remapClauseIds=NULL;
  int i, j, nCl;
  int doPartialRerunSolver = 0;
  int doPartialOnSameProof = computeAuxItp;
  Ddi_Bdd_t *auxItp=NULL;
  
  Minisat::SimpSolver S22aux;
  long cpuTime=0, startTime=0;
  int nAClausesCore = 0;
  S22aux.proofLogging(1);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
    S22->proofPdt.setVerbosity(1);
    S22aux.proofPdt.setVerbosity(1);
  }
  else if (verbosity >= Pdtutil_VerbLevelDevMax_c) {
    S22->proofPdt.setVerbosity(2);
    S22aux.proofPdt.setVerbosity(2);
  }
  else {
    S22->proofPdt.setVerbosity(0);
    S22aux.proofPdt.setVerbosity(0);
  }
  //  nAClauses = 0;

  if (S22->proofPdt.solverUndef) {
    topResClP = &topResCl;
  }
  
  int checkClauses=0;
  if (checkClauses) {
    Minisat::vec< Minisat::vec<Minisat::Lit> > clausesAux; 
    S22->getProofClauses(clausesAux);
    int res = trySatClauseArray(&clausesAux,0,0,NULL,0,0,NULL);
    assert(!res);
  }
  
  markProofVars(S22,a,b);
  S22->proofClassifyNodes(nAClauses,true);
  //S22->printProof(NULL,NULL);
  int constItp = S22->getProof(clauses, nAClausesCore, proofNodes,
			       pivots, topResClP);

  if (clauses.size()==0) {
    doPartialOnSameProof = doPartialOnSameProof = 0;
    assert(constItp>=0);
    auxItp = Ddi_BddMakeConstAig(ddm, constItp);
  }
  if (auxItp==NULL && clauses.size()>100) {
    if (doPartialOnSameProof) {
      auxItp = getAuxProof22(S22,ddm);
    }

    if (doPartialRerunSolver) {
      int mynAC, mynSolverAC;
      Minisat::vec< Minisat::vec<Minisat::Lit> > clausesPartial; 
      S22->getPartialNewProof(clausesPartial, nAClauses, mynAC,
                              mynSolverAC, &S22aux, 0.5);
      printf("total: %d - solver: %d - A: %d - Acore: %d - AsolverCore %d\n",
             clausesPartial.size(), S22aux.nClauses(),
             nAClauses, mynAC, mynSolverAC);
      if (S22aux.okay()) {
        getAuxNewProof22(&S22aux,ddm,clausesPartial,mynAC,
                         mynSolverAC,nAClausesCore);
      }
    }
  
    nCl = nAClausesCore;
    
    bAig_array_t *aigNodes = bAigArrayAlloc();
  
    Ddi_PostOrderBddAigVisitIntern(a,aigNodes,-1);
    Ddi_PostOrderAigClearVisitedIntern(travP->bMgr,aigNodes);
    for (i=0; i<aigNodes->num; i++) {
      bAigEdge_t baig = aigNodes->nodes[i];
      int cnfId = DdiAig2CnfId(travP->bMgr,baig);
      if (DdiCnfReadActive(travP->ddiMgr,cnfId)==1) {
        // if cnfActive==0 aig node NOT used in cnf clauses
        DdiCnfSetActive(travP->ddiMgr,cnfId,2);
      }
    }
    //  printf("Global vars: ");
    if (globalvars!=NULL) {
      Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(globalvars,1);
      for (i=0; i<Ddi_VararrayNum(vA); i++) {
        Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
        bAigEdge_t varIndex = Ddi_VarToBaig(v);
        int cnfId = DdiAig2CnfId(travP->bMgr,varIndex);
        //      printf(" %d", cnfId-1);
        if (DdiCnfReadActive(travP->ddiMgr,cnfId)>0) {
          DdiCnfSetActive(travP->ddiMgr,cnfId,3);
        }
      }
      Ddi_Free(vA);
    }
    //  printf("\n");

    bAigArrayFree(aigNodes);

    if ((nAClausesCore < 0)) {
      remapClauseIds = Pdtutil_Alloc(int,clauses.size());
      for (i=0; i<clauses.size(); i++) {
        remapClauseIds[i] = -1;
      }
      // A clauses
      int myNCl = 0;
      for (i=0; i<clauses.size(); i++) {
        int cnt = 0;
        if (clauses[i].size()==0) continue;
        for (j=0; j<clauses[i].size(); j++) {
          int cnfId = Minisat::var((clauses[i])[j]) + 1;
          if (DdiCnfReadActive(travP->ddiMgr,cnfId)>1) {
            cnt++;
          }
        }
        if (cnt == clauses[i].size()) {
          remapClauseIds[i] = myNCl;
          myNCl++;
        }
      }
      nCl = myNCl;
    }
    else if ((nAClausesCore == 0)) {
      if (auxItp==NULL) {
        auxItp = Ddi_BddMakeConstAig(ddm, 1);
      }
    }
    else {
      proof22toChecker(clauses,proofNodes,pivots,topResClP,
                     travP,nCl,remapClauseIds);
    }
    Pdtutil_Free(remapClauseIds);
  }
  else if (auxItp==NULL) {
    if ((nAClausesCore == 0)) {
      if (auxItp==NULL) {
        auxItp = Ddi_BddMakeConstAig(ddm, 1);
      }
    }
    else {
      proof22toChecker(clauses,proofNodes,pivots,topResClP,
                     travP,nAClausesCore,remapClauseIds);
    }
  }
  
  return auxItp;
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
printTopResClauses22(
  struct Checker *travP
)
{
  int i, nTopC=0;

  for (i=0; i<travP->topResClauses.size(); i++) {
    if (travP->topResClauses[i].size()>0) {
      nTopC++;
      printf("%d - size: %d\n",i, travP->topResClauses[i].size());
    }
  }
  printf("total top res cl found: %d\n", nTopC);

}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
Minisat22GetTopLearningLits (
  void    *Svoid,
  Minisat::TraceProofVisitor &v,
  Ddi_Mgr_t *ddm,
  Ddi_Varset_t *globalVars,
  int useB
)
{
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  Minisat::vec<Minisat::Var> filterVars;
  Minisat::vec<Minisat::Var> filter2Vars;
  int i, ncl;

  Pdtutil_Assert(globalVars!=NULL,"global vars needed");

  filterVars.clear();
  filter2Vars.clear();

  for (i=0; i<S22->nVars(); i++) {
    int vCnf = i+1;
    Minisat::Var v22 = i;
    if (ddm->cnf.solver2cnf != NULL) {
      vCnf = ddm->cnf.solver2cnf[i]+1;
    }
    bAigEdge_t litBaig = ddm->cnf.cnf2aig[vCnf];
    int isB = nodeAuxChar(bmgr,litBaig)>0;
    int isGlob = nodeAuxChar(bmgr,litBaig)>1;
    if (!useB) isB = !isB;
    if (isB)
      filter2Vars.push(v22);
    if (isGlob)
      filterVars.push(v22);
  }	
  v.genUndefTopClauses(filterVars, filter2Vars);
  ncl = v.nTopClauses();
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    printf("# learnt clauses on itp VARS: %d\n", ncl);
  }

#if 0
  Ddi_Bdd_t *learntAig = Ddi_BddMakeConstAig(ddm, 1);
  for (i=0; i<learntClauses.size(); i++) {
    int j;
    Ddi_Bdd_t *clauseAig = Ddi_BddMakeConstAig(ddm, 0);
    Minisat::vec<Minisat::Lit>& c = learntClauses[i];
    for (j=0; j<c.size(); j++) {
      int v = Minisat::var(c[j]);
      bAigEdge_t baig = ddm->cnf.cnf2aig[v+1];
      int s = Minisat::sign(c[j]);
      Ddi_Bdd_t *litAig = Ddi_BddMakeFromBaig(ddm, baig);
      if (s) Ddi_BddNotAcc(litAig);
      Ddi_BddOrAcc(clauseAig,litAig);
      Ddi_Free(litAig);
    }
    Ddi_BddAndAcc(learntAig,clauseAig);
    Ddi_Free(clauseAig);
  }
  Ddi_BddNotAcc(learntAig);
#endif

  return ncl;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
Minisat22GetUndefTopClauses (
  void    *Svoid,
  Minisat::TraceProofVisitor &v,
  Ddi_Mgr_t *ddm,
  Ddi_Varset_t *globalVars,
  int useB
)
{
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  Minisat::vec<Minisat::Var> filterVars;
  Minisat::vec<Minisat::Var> filter2Vars;
  int i, ncl;

  Pdtutil_Assert(globalVars!=NULL,"global vars needed");

  filterVars.clear();
  filter2Vars.clear();

  for (i=0; i<S22->nVars(); i++) {
    int vCnf = i+1;
    Minisat::Var v22 = i;
    if (ddm->cnf.solver2cnf != NULL) {
      vCnf = ddm->cnf.solver2cnf[i]+1;
    }
    bAigEdge_t litBaig = ddm->cnf.cnf2aig[vCnf];
    int isB = nodeAuxChar(bmgr,litBaig)>0;
    int isGlob = nodeAuxChar(bmgr,litBaig)>1;
    if (!useB) isB = !isB;
    if (isB)
      filter2Vars.push(v22);
    if (isGlob)
      filterVars.push(v22);
  }	
  v.genUndefTopClauses(filterVars, filter2Vars);
  ncl = v.nTopClauses();
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    printf("# learnt clauses on itp VARS: %d\n", ncl);
  }

#if 0
  Ddi_Bdd_t *learntAig = Ddi_BddMakeConstAig(ddm, 1);
  for (i=0; i<learntClauses.size(); i++) {
    int j;
    Ddi_Bdd_t *clauseAig = Ddi_BddMakeConstAig(ddm, 0);
    Minisat::vec<Minisat::Lit>& c = learntClauses[i];
    for (j=0; j<c.size(); j++) {
      int v = Minisat::var(c[j]);
      bAigEdge_t baig = ddm->cnf.cnf2aig[v+1];
      int s = Minisat::sign(c[j]);
      Ddi_Bdd_t *litAig = Ddi_BddMakeFromBaig(ddm, baig);
      if (s) Ddi_BddNotAcc(litAig);
      Ddi_BddOrAcc(clauseAig,litAig);
      Ddi_Free(litAig);
    }
    Ddi_BddAndAcc(learntAig,clauseAig);
    Ddi_Free(clauseAig);
  }
  Ddi_BddNotAcc(learntAig);
#endif

  return ncl;
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
Minisat22FreezeAig (
  void    *Svoid,
  Ddi_Bdd_t *f
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  int i, n;

  bAig_array_t *visitedNodes = bAigArrayAlloc();

  postOrderBddAigVisitIntern(f, visitedNodes, NULL, -1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  n = visitedNodes->num; 
  for (i=0; i<n; i++) {
    bAigEdge_t baig = visitedNodes->nodes[i];
    int fCnf = aig2CnfId(bmgr,baig);
    Minisat::Var v22 = abs(fCnf)-1;
    S22->setFrozen(v22,true);
  }
  bAigArrayFree(visitedNodes);

  return n;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
Minisat22FreezeVars (
  void    *Svoid,
  Ddi_Mgr_t *ddm,
  Ddi_Vararray_t *vA
)
{
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  int i, n=0;

  if (vA!=NULL) {
    for (i=0; i<Ddi_VararrayNum(vA); i++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
      bAigEdge_t baig = Ddi_VarToBaig(v);
      int fCnf = aig2CnfId(bmgr,baig);
      Minisat::Var v22 = abs(fCnf)-1;
      S22->setFrozen(v22,true);
    }
  }
  else {
    for (i=0; i<S22->nVars(); i++) {
      //  for (i=0; i<=ddm->cnf.maxCnfId; i++) {
      int vCnf = i+1;
      Minisat::Var v22 = i;
      bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
      if (bAig_isVarNode(bmgr,baig)) {
#if 1
	S22->setFrozen(v22,true);
#endif
	n++;
      }
    }
  }	

  return n;
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static int
Minisat22ReleaseEliminatedVars (
  void    *Svoid,
  Ddi_Mgr_t *ddm,
  bAig_array_t *cnfMappedVars
)
{
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  int i, n=0;

  for (i=0; i<S22->nVars(); i++) {
    int vCnf = i+1;
    Minisat::Var v22 = i;
    bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
    if (baig!=bAig_NULL && !bAig_isVarNode(bmgr,baig)) {
      if (S22->isEliminated(v22)) {
	cnfId2AigClear(ddm, cnfMappedVars, vCnf);
	n++;
      }
    }
  }	

  return n;
}



/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
Minisat22FreezeCnfVar (
  void    *Svoid,
  int cnfV
)
{
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;

  Minisat::Var v22 = cnfV-1;
  while (S22->nVars()<=v22) S22->newVar();
  S22->setFrozen(v22,true);
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static void
Minisat22Eliminate (
  void    *Svoid
)
{
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;

  S22->eliminate(true);
}


static Ddi_Bddarray_t *
aigArrayMakeFromMinisatLits(
  Ddi_Mgr_t *ddm,
  vec<Lit>& lits
)
{
  int j;
  Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm,0);
  for (j=0; j<lits.size(); j++) {
    Lit l = lits[j];
    int vSat = var(l);
    int signSat = sign(l);
    int vCnf = vSat+1;
    bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
    Ddi_Bdd_t *aig = NULL;
    if (bAig_isVarNode(ddm->aig.mgr,baig)) {
      Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
      Pdtutil_Assert (v!=NULL, "Null var");
      aig = Ddi_BddMakeLiteralAig(v,signSat?0:1);
    }
    else {
      aig = Ddi_BddMakeFromBaig(ddm, baig);
      if (signSat) Ddi_BddNotAcc(aig);
    }
    Ddi_BddarrayInsertLast(fA,aig);
    Ddi_Free(aig);
  }
  return fA;
}


/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static bool
Minisat22InterpolantUndef (
  void    *Svoid,
  Ddi_Mgr_t *ddm,
  Ddi_Bdd_t *a,
  Ddi_Varset_t *globalvars,
  int reverseItp,
  Ddi_Bdd_t **interpolantP,
  Ddi_Bdd_t *care,
  int nSuppVars,
  int itpOdc,
  int genProof,
  int nACl,
  int useB
)
{
  Ddi_Bdd_t *interpolant=NULL;
  Ddi_Bdd_t *interpolantOpt=NULL;
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  long cpuTime=0, startTime=0;
  int validateWithGlobalVars = 0;
  int useMaxPivots = 0;
  Checker trav(ddm,S22->nVars());
  ClauseId goal = ClauseId_NULL;
  bool success = true;
  int useABnodes=0;


  if (ddm->settings.aig.itpMem>2) {
    trav.useRemapped = 1;
    // trav.genResolution = 1;
  }
  if (ddm->settings.aig.itpOpt>3) {
    trav.handleAClauses = 1;
    //    trav.genResolution2 = 1;
  }
  if (ddm->settings.aig.itpOpt>4) {
    trav.genResolution = 1;
    //    trav.genResolution2 = 1;
  }

  if (care != NULL) {
    trav.careBaig = Ddi_BddToBaig(care);
  }

  ddm->stats.aig.fullAndItpTerms=0;
  ddm->stats.aig.fullOrItpTerms=0;
  ddm->stats.aig.itpTerms=0;

  
  Minisat::TraceProofVisitor v(*S22, stdout);

  // take all clauses
  //  Minisat22GetUndefTopClauses ((void *)S22,v,ddm,globalvars,useB);
  v.doUndef = true;
  S22->proofPdt.setSolverUndef();
  
  startTime = util_cpu_time ();
  S22->validate(v);
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"Solver Validation time = %s)\n", 
	    util_print_time(cpuTime));
  }

  startTime = util_cpu_time ();
  success = S22->replay(v);
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"Solver Replay time = %s)\n", 
	  util_print_time(cpuTime));
  }
  //  S22->printCore();

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),
    "computing interpolant from refutation proof of size %d (AIG nodes: %d)\n",
	    S22->proofSize(), Ddi_MgrReadAigNodesNum(ddm)));

  if (success == false) {
    trav.partial = 1;
    fprintf(dMgrO(ddm)," Minisat 22 Partial Interpolant computed\n");
    fflush(dMgrO(ddm));
  }

  getProof22((void *)S22,&trav,a,NULL,nACl,globalvars,0);
  trav.done22();
  trav.genitp();
  //  S.proof->deleteTemps();

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),"interpolant OPT: %d (%d,%d)\n",
      trav.itpOptNum, trav.itpOptNum2, trav.itpOptNum3);
    fprintf(dMgrO(ddm),"interpolant AUXV: %d - AIG nodes %d\n",
	    trav.auxvNum, Ddi_MgrReadAigNodesNum(ddm));
    fprintf(dMgrO(ddm),
      "interpolant stats: clause terms/a/o/ao -> %d/%d/%d/%d - A nodes: %d (and->or): %d\n",
      ddm->stats.aig.itpTerms,
      ddm->stats.aig.fullAndItpTerms,  ddm->stats.aig.fullOrItpTerms,
      ddm->stats.aig.itpTerms-
      (ddm->stats.aig.fullAndItpTerms+ddm->stats.aig.fullOrItpTerms),
	    trav.nANodes, trav.nAndToOr));
  if (trav.nOdcFound>0) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"interpolant ODC #: %d\n", trav.nOdcFound));
  }

  /*vec<Lit>& c =*/ trav.clauses.last();

  if (trav.partial) {
    int nTrees = 0, nTreeA=0, nTreeB=0, nTreeGbl=0, nSkip=0, nTopC=0;
    int aMax = 32, bMax = 32;
    interpolant = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Vararray_t *gblA = Ddi_VararrayMakeFromVarset(globalvars,1);
    Ddi_VararrayWriteMark (gblA, 1);
    Ddi_Bdd_t *itpPlusA = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Bdd_t *itpPlusB = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Bdd_t *itpGblA = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Bdd_t *itpGblB = Ddi_BddMakeConstAig(ddm,1);
    for (int i = 0; i < trav.nodes.size(); i++) {
      int enTree = trav.nodes[i].chainLevel>3;
      if (!enTree) {
	nSkip++;
	continue;
      }
      if (trav.nodes[i].isTreeRoot && trav.topResClauses[i].size()>0) {
	Ddi_Bdd_t *p_i = Ddi_BddMakeFromBaig(ddm, trav.nodes[i].aig);
	Ddi_Bdd_t *p_iAnd = NULL;
	Ddi_Bdd_t *aClause = Ddi_BddMakeConstAig(ddm,0);
	Ddi_Bdd_t *bClause = Ddi_BddMakeConstAig(ddm,0);
	int j;
	int isGbl = 1, hasGbl = 0, nA=0, nB=0;
	vec<Lit>& c = trav.topResClauses[i];
	for (j=0; j<c.size(); j++) {
	  Lit l = c[j];
	  int vSat = var(l);
	  int signSat = sign(l);
	  int vCnf = vSat+1;
	  bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
          int isGlob = nodeAuxChar(ddm->aig.mgr,baig) == 3;
	  int isB = !isGlob && (nodeAuxChar(ddm->aig.mgr,baig)>0);
	  int isA = !isGlob && !isB;
	  int used=0;
	  //	  int isGlob = nodeAuxChar(ddm->aig.mgr,baig)>1;
	  Ddi_Bdd_t *aig = NULL;
	  if (bAig_isVarNode(ddm->aig.mgr,baig)) {
	    Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
	    Pdtutil_Assert (v!=NULL, "Null var");
	    aig = Ddi_BddMakeLiteralAig(v,signSat?0:1);
	    if (isA) isGbl = 0;
	  }
	  else {
	    aig = Ddi_BddMakeFromBaig(ddm, baig);
	    if (signSat) Ddi_BddNotAcc(aig);
	    isGbl = 0;
	  }
	  if (isGlob || isA)
	    nA++, Ddi_BddOrAcc(aClause,aig);
	  if (isGlob || isB)
	    nB++, Ddi_BddOrAcc(bClause,aig);
	  if (isGlob) hasGbl = 1;
	}
	if (trav.nodes[i].orClause != NULL) {
	  Ddi_BddSetAig(trav.nodes[i].orClause);
	  Ddi_BddOrAcc(p_i,trav.nodes[i].orClause);
	}
	Ddi_BddOrAcc(aClause,p_i);
	Ddi_BddNotAcc(p_i);
	Ddi_BddOrAcc(bClause,p_i);
	if (isGbl) {
	  nTreeGbl++; 
	  Ddi_BddAndAcc(itpGblA,aClause);
	  Ddi_BddAndAcc(itpGblB,bClause);
	}
	if (nA>=aMax) {
	  nTreeA++;
	  Ddi_BddAndAcc(itpPlusA,aClause);
	}
	if (nB>=bMax) {
	  nTreeB++;
	  Ddi_BddAndAcc(itpPlusB,bClause);
	}
	nTrees++;
	Ddi_Free(aClause);
	Ddi_Free(bClause);
	Ddi_Free(p_i);
	if (trav.topResClauses[i].size()>0) {
	  nTopC++;
	//	printf("%d - size: %d\n",i, trav.topResClauses[i].size());
	}
      }
    }
    Ddi_DataCopy(interpolant,itpPlusA);
    Ddi_BddSetPartConj(interpolant);
    Ddi_BddPartInsertLast(interpolant,itpPlusB);
    Ddi_BddPartInsertLast(interpolant,itpGblA);
    Ddi_BddPartInsertLast(interpolant,itpGblB);
    Ddi_Free(itpPlusA);
    Ddi_Free(itpPlusB);
    Ddi_Free(itpGblA);
    Ddi_Free(itpGblB);
    Ddi_VararrayWriteMark (gblA, 0);
    Ddi_Free(gblA);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),
	      "partial interpolant: (%d trees, %d A, %d B, %d G, %d topSkip, %d topC, size: %d\n",
	      nTrees, nTreeA, nTreeB, nTreeGbl, nSkip, nTopC, Ddi_BddSize(interpolant)));
  }

  for (int i = 0; i < trav.nodes.size(); i++) {
    bAig_RecursiveDeref(ddm->aig.mgr,trav.nodes[i].aig);
    Ddi_Free(trav.nodes[i].orClause);
    //    Ddi_Free(trav.nodes[i].cube);
  }

  *interpolantP = interpolant;
  // system("rm -f ./tmp/file*");

  return success;
}

/**Function********************************************************************
  Synopsis    [Literals appearing in highest number of learned clauses]
  Description [Literals appearing in highest number of learned clauses. The result is a conjunct of aigs. Phase: complemented w.r.t. literals in clauses]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
Minisat22InterpolantUndefTopLits (
  void    *Svoid,
  Ddi_Mgr_t *ddm,
  int maxn
)
{
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  long cpuTime=0, startTime=0;
  Ddi_Bdd_t *topLitConstr;
 
  Minisat::vec<Minisat::Lit> topLits22;
  S22->getLearntsTopLits(topLits22,maxn,0);
  vec<Lit> topLits;
  MinisatFrom22(topLits22,topLits);
  Ddi_Bddarray_t *topA = aigArrayMakeFromMinisatLits(ddm, topLits);
  topLitConstr = Ddi_BddMakePartDisjFromArray(topA);
  Ddi_BddNotAcc(topLitConstr);
  Ddi_Free(topA);

  return topLitConstr;
}

/**Function********************************************************************
  Synopsis    [Convert a DDI AIG to a monolitic BDD]
  Description [Convert a DDI AIG to a monolitic BDD]
  SideEffects []
  SeeAlso     [Ddi_BddMakeFromCU]
******************************************************************************/
static bool
Minisat22Interpolant (
  void    *Svoid,
  Ddi_Mgr_t *ddm,
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  int nAClauses,
  Ddi_Varset_t *globalvars,
  int reverseItp,
  Ddi_Bdd_t **interpolantP,
  Ddi_Bdd_t **interpolantOptP,
  Ddi_Bdd_t *care,
  int nSuppVars,
  int itpOdc,
  int genProof
)
{
  Ddi_Bdd_t *interpolant=NULL;
  Ddi_Bdd_t *interpolantOpt=NULL;
  Minisat22Solver* S22 = (Minisat22Solver *)Svoid;
  long cpuTime=0, startTime=0;
  int validateWithGlobalVars = 0;
  int useMaxPivots = 0;
  Checker trav(ddm,S22->nVars());
  ClauseId goal = ClauseId_NULL;
  bool success = true;
  Ddi_Bdd_t *auxItp=NULL;
  int compareWithStndardItp = 0;
  
  if (ddm->settings.aig.itpMem>2) {
    trav.useRemapped = 1;
    // trav.genResolution = 1;
  }
  if (ddm->settings.aig.itpOpt>3) {
    trav.handleAClauses = 1;
    //    trav.genResolution2 = 1;
  }
  if (ddm->settings.aig.itpOpt>4) {
    trav.genResolution = 1;
    //    trav.genResolution2 = 1;
  }

  if (care != NULL) {
    trav.careBaig = Ddi_BddToBaig(care);
  }

  ddm->stats.aig.fullAndItpTerms=0;
  ddm->stats.aig.fullOrItpTerms=0;
  ddm->stats.aig.itpTerms=0;

  Minisat::TraceProofVisitor v(*(Minisat::Solver *)S22, stdout);

  if (genProof) {

    startTime = util_cpu_time ();
    if (validateWithGlobalVars) {
      int i;
      S22->clearGlobals();
      S22->initGlobals();
      for (i=0; i<S22->nVars(); i++) {
	if (trav.isGlobal(i)) {
	  S22->setGlobal(i);
	}
      }
    }
    bool coreFirst = ddm->settings.aig.itpDrup>4;
    success = S22->validate(v,coreFirst);
    if (!success) {
      fprintf(dMgrO(ddm)," Minisat 22 Interpolant ABORTED for failed validation\n");
    }

    cpuTime = util_cpu_time () - startTime;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"Solver Validation time = %s - prop:%d\n", 
              util_print_time(cpuTime), S22->propagations);
    }
  }

  startTime = util_cpu_time ();
  success = success && S22->replay(v);
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"Solver Replay time = %s - prop: %d\n", 
            util_print_time(cpuTime), S22->propagations);
  }
  //S22->printCore();

#if 1

  bool computeAuxItp = ddm->settings.aig.itpDrup>2;

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),
    "computing interpolant from refutation proof of size %d (AIG nodes: %d)\n",
	    S22->proofSize(), Ddi_MgrReadAigNodesNum(ddm)));

  //  useMaxPivots = 1;

  if (success == false) {
    trav.aborted = 1;
    fprintf(dMgrO(ddm)," Minisat 22 Interpolant ABORTED for failed replay\n");
    fflush(dMgrO(ddm));
  }
  else if (nSuppVars>30 && S22->proofSize() > 50000000) {
    trav.aborted = 1;
    fprintf(dMgrO(ddm)," Interpolant ABORTED for proof of size: %d\n", S22->proofSize());
    fflush(dMgrO(ddm));
  }
  else if (!useMaxPivots) {
    auxItp =
      getProof22((void *)S22,&trav,a,NULL,nAClauses,globalvars,
                 computeAuxItp);
    if (auxItp!=NULL) {
      interpolant = auxItp;
      auxItp=NULL;
    }
    else {
      trav.done22();
      trav.genitp();
    }
  }
  else {
    /* partition using most active pivots */
    Ddi_Bdd_t *itp0=NULL, *itp1=NULL, *pLit, *itpRef=NULL;
    int pivot = S22->maxPivot(0);
    int pCnf, i;
    bAigEdge_t pBaig;

    trav.impliedVars.clear();
    trav.impliedVars.growTo(trav.nSolverVars);
    for (i=0; i<trav.nSolverVars; i++) {
      trav.impliedVars[i] = 0;
    }

    auxItp =
      getProof22((void *)S22,&trav,a,b,nAClauses,globalvars,
                 computeAuxItp);
    /* use first cofactor */
    if (auxItp!=NULL &&
        (!compareWithStndardItp || Ddi_BddIsConstant(auxItp))) {
      interpolant = Ddi_BddDup(auxItp);
    }
    else {
      trav.done22();
      //    trav.countPivots(0);

      pivot = trav.maxPivots.size()>0 ? trav.maxPivots[0] : -1;

      if (pivot>=0) {

        if (ddm->cnf.solver2cnf != NULL) {
          pCnf = ddm->cnf.solver2cnf[pivot]+1;
        }
        else {
          pCnf = pivot+1;
        }
        pBaig = ddm->cnf.cnf2aig[pCnf];
        
        trav.impliedVars[pivot] = -1;
        trav.genitp();
        
        itp0 = Ddi_BddMakeFromBaig(ddm, trav.nodes.last().aig);
        if (trav.nodes.last().orClause != NULL) {
          Ddi_BddSetAig(trav.nodes.last().orClause);
          Ddi_BddOrAcc(itp0,trav.nodes.last().orClause);
        }

        for (int i = 0; i < trav.nodes.size(); i++) {
          bAig_RecursiveDeref(ddm->aig.mgr,trav.nodes[i].aig);
          trav.nodes[i].aig=bAig_NULL;
          Ddi_Free(trav.nodes[i].orClause);
          //    Ddi_Free(trav.nodes[i].cube);
          trav.nodes[i].isOdc = 0;
          trav.nodes[i].optimized = 0;
          trav.nodes[i].AClause = 0;
          trav.nodes[i].isLiteral = 0;
        }

        trav.impliedVars[pivot] = 1;
        trav.genitp();

        itp1 = Ddi_BddMakeFromBaig(ddm, trav.nodes.last().aig);
        if (trav.nodes.last().orClause != NULL) {
          Ddi_BddSetAig(trav.nodes.last().orClause);
          Ddi_BddOrAcc(itp1,trav.nodes.last().orClause);
        }
        
        for (int i = 0; i < trav.nodes.size(); i++) {
          bAig_RecursiveDeref(ddm->aig.mgr,trav.nodes[i].aig);
          trav.nodes[i].aig=bAig_NULL;
          Ddi_Free(trav.nodes[i].orClause);
          //    Ddi_Free(trav.nodes[i].cube);
          trav.nodes[i].isOdc = 0;
          trav.nodes[i].optimized = 0;
          trav.nodes[i].AClause = 0;
          trav.nodes[i].isLiteral = 0;
        }
        
        trav.impliedVars[pivot] = 0;
      }
      
      trav.genitp();
      
      itpRef = Ddi_BddMakeFromBaig(ddm, trav.nodes.last().aig);
      if (trav.nodes.last().orClause != NULL) {
        Ddi_BddSetAig(trav.nodes.last().orClause);
        Ddi_BddOrAcc(itpRef,trav.nodes.last().orClause);
      }
      
      for (int i = 0; i < trav.nodes.size(); i++) {
        bAig_RecursiveDeref(ddm->aig.mgr,trav.nodes[i].aig);
        trav.nodes[i].aig=bAig_NULL;
        Ddi_Free(trav.nodes[i].orClause);
      }
      trav.nodes.clear();
      
      if (pivot < 0) {
        interpolant = Ddi_BddDup(itpRef);
      }
      else {
        int isGlobalV = trav.isGlobal(pivot);
        int isAnd = trav.isBVar(pivot);
        
        pLit = Ddi_BddMakeFromBaig(ddm,pBaig);
        if (0 || 1 && isGlobalV) {
          //      Pdtutil_Assert(!isAnd,"wrong global/and setting");
          interpolant = Ddi_BddIte(pLit,itp1,itp0);
	  //     	interpolant = Ddi_BddDup(itpRef);
        }
        else if (1 && isAnd) {
          interpolant = Ddi_BddAnd(itp1,itp0);
        }
        else {
          interpolant = Ddi_BddOr(itp1,itp0);
        }
        printf("%s |itpRef|=%d - |itpPivot|=%d\n", 
               isGlobalV?"ITE":(isAnd?"AND":"OR"), 
               Ddi_BddSize(itpRef),
               Ddi_BddSize(interpolant));
        Ddi_Free(pLit);
        
        Ddi_AigStructRedRemAcc (itpRef,NULL);
        ddiAbcOptAcc (itpRef,-1);
      }
    }
    
    Ddi_Free(itp0);
    Ddi_Free(itp1);
    Ddi_Free(itpRef);
  }
  //  S.proof->deleteTemps();

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),"interpolant OPT: %d (%d,%d)\n",
      trav.itpOptNum, trav.itpOptNum2, trav.itpOptNum3);
    fprintf(dMgrO(ddm),"interpolant AUXV: %d - AIG nodes %d\n",
	    trav.auxvNum, Ddi_MgrReadAigNodesNum(ddm));
    fprintf(dMgrO(ddm),
      "itp stats: clause terms/a/o/ao -> %d/%d/%d/%d - A nodes: %d (and->or): %d\n",
      ddm->stats.aig.itpTerms,
      ddm->stats.aig.fullAndItpTerms,  ddm->stats.aig.fullOrItpTerms,
      ddm->stats.aig.itpTerms-
      (ddm->stats.aig.fullAndItpTerms+ddm->stats.aig.fullOrItpTerms),
	    trav.nANodes, trav.nAndToOr));
  if (trav.nOdcFound>0) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"interpolant ODC #: %d\n", trav.nOdcFound));
  }

  /*vec<Lit>& c =*/ trav.clauses.last();
#if 0
  fprintf(dMgrO(ddm),"Final clause:");
  if (c.size() == 0)
      fprintf(dMgrO(ddm)," <empty>\n");
  else{
      for (int i = 0; i < c.size(); i++)
          fprintf(dMgrO(ddm)," %s%d", sign(c[i])?"-":"", var(c[i])+1);
      fprintf(dMgrO(ddm),"\n");
  }
#endif

  if (trav.partial) {
    int nTrees = 0;
    interpolant = Ddi_BddMakeConstAig(ddm,1);
    for (int i = 0; nTrees<4 && i < trav.nodes.size(); i++) {
      if (trav.nodes[i].isTreeRoot) {
	Ddi_Bdd_t *p_i = Ddi_BddMakeFromBaig(ddm, trav.nodes[i].aig);
	if (Ddi_BddSize(p_i) > 10000) {
#if 0
	  if (trav.nodes[i].cube != NULL) {
	    Ddi_Bdd_t *cube = Ddi_BddMakeAig(trav.nodes[i].cube);
	    Ddi_BddOrAcc(p_i,cube);
	    Ddi_Free(cube);
	  }
#endif
	  Ddi_BddAndAcc(interpolant,p_i);
	  Ddi_Free(p_i);
	  nTrees++;
	}
      }
    }
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"partial interpolant (%d trees), size: %d\n",
        nTrees, Ddi_BddSize(interpolant)));
  }
  else if (trav.aborted) {
    interpolant = NULL;
  }
  else if (interpolant == NULL) {
    interpolant = Ddi_BddMakeFromBaig(ddm, trav.nodes.last().aig);
    if (trav.nodes.last().orClause != NULL) {
      Ddi_BddSetAig(trav.nodes.last().orClause);
      Ddi_BddOrAcc(interpolant,trav.nodes.last().orClause);
    }
  }

  for (int i = 0; i < trav.nodes.size(); i++) {
    bAig_RecursiveDeref(ddm->aig.mgr,trav.nodes[i].aig);
    Ddi_Free(trav.nodes[i].orClause);
    //    Ddi_Free(trav.nodes[i].cube);
  }

  // system("rm -f ./tmp/file*");
  if (auxItp!=NULL) {
    Ddi_AigStructRedRemAcc (interpolant,NULL);
    Ddi_NnfClustSimplifyAcc(interpolant,0);
    if (Ddi_BddSize(auxItp)<Ddi_BddSize(interpolant)) {
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
         fprintf(dMgrO(ddm),
         "\n<<< taking AUX ITP of size: %d (replacing %d)>>>\n\n",
                 Ddi_BddSize(auxItp), Ddi_BddSize(interpolant)));
      Ddi_Free(interpolant);
      interpolant = auxItp;
    }
    else {
      Ddi_Free(auxItp);
    }
  }
  
  *interpolantP = interpolant;
  *interpolantOptP = interpolantOpt;
#endif

  return success;
}



/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSat22NnfSubset (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  int *psat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *aCore=NULL, *b2=NULL;
  Minisat22Solver* S22;
  Solver Sdummy;
  Minisat::vec<Minisat::Lit> assumps22;
  int sizeA, sizeB, undefined = 0;
  long startTime, cpuTime;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, n, chkRes=0, nRed=0, nRed1=0;
  int again, iter;

  *psat = 0;

  if (Ddi_BddIsZero(a)) {
    return (Ddi_BddMakeConstAig(ddm,0));
  }
  sizeA = Ddi_BddSize(a);
  if (sizeA < 4) {
    return Ddi_BddDup(a);
  }
  if (optCare != NULL) {
    b2 = Ddi_BddDup(optCare);
    Ddi_BddAndAcc(b2,b);
  }
  else {
    b2 = Ddi_BddDup(b);
  }
  sizeB = Ddi_BddSize(b2);
  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
		       fprintf(dMgrO(ddm),"AIG NNF SUBSET (|A|=%d,|B|=%d)\n",sizeA,sizeB));

  aig2CnfIdInit(ddm);
  //  aig2CnfIdInitDecr(ddm,3*(sizeA+sizeB)/3);

  S22 = new Minisat22Solver();

  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  ddm->settings.aig.aigCnfLevel = 1;
  Minisat22Clauses((void *)S22,a,b2,NULL,0);
  ddm->settings.aig.aigCnfLevel = aigCnfLevel;

  startTime = util_cpu_time();

  /* get array of baig nodes */
  nnfCoreMgr_t *nnfCoreMgr = nnfCoreMgrNew(a,NULL,NULL,NULL,NULL,1,0);
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    if (rand()%100!=0) {
      nnfCoreMgr->isCore[i] = 1;
    }
  }

  for (again=1, iter=0; again; iter++) {

    assumps22.clear();

    /* collect assumptions */
    for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
      if (!nnfCoreMgr->isCore[i]) {
        if (nnfCoreMgr->gateType[i] != 'I') {
	  bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
	  int fCnf = aig2CnfId(bmgr,baig);
	  if (nnfCoreMgr->gateType[i] == 'O') fCnf = -fCnf;
	  Minisat::Lit kLit = Minisat22Lit(fCnf);
	  assumps22.push(~kLit); // complemented lit
	}
      }
    }

    if ((*psat = S22->okay())) {
      *psat = S22->solve(assumps22);
    }
    else {
      *psat = 0;
      //    fprintf(dMgrO(ddm),"UNSAT\n");
    }

    if (*psat) {
      break;
    }
    else {
      int k, nc, nc2;
      for (k=nc=0; k<S22->conflict.size(); k++) {
	Minisat::Lit kLit = S22->conflict[k];
	int vSat = Minisat::var(kLit);
	int vCnf = vSat+1;
	bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
	//printf("C var: %d, cnf: %d, baig: %d\n", vSat, vCnf, baig/4);
	nodeAuxChar(bmgr,baig) = 1;
        nc++;
      }
      Pdtutil_Assert(nc<=assumps22.size(),"too many conflict literals");

      for (i=nc2=0; i<nnfCoreMgr->aNodes->num; i++) {
	if (!nnfCoreMgr->isCore[i]) {
	  if (nnfCoreMgr->gateType[i] != 'I') {
	    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
	    if (nodeAuxChar(bmgr,baig)) {
	      nodeAuxChar(bmgr,baig) = 0;
	      nnfCoreMgr->isCore[i] = 1;
	      nc2++;
	    }
	  }
	}
      }
      again = nc!=0;
      Pdtutil_Assert(nc==nc2,"confl lit num mismatch");
    }

    /* get core & modify assumptions */
  }


  if (!*psat || undefined) {
    aig2CnfIdClose(ddm);
    Ddi_Free(b2);
    delete S22;
    nnfCoreMgrFree(nnfCoreMgr);
    if (undefined) *psat = -1;
    if (chkRes) {
      Pdtutil_Assert(!Ddi_AigSatAnd(a,b,optCare),"error in sat nnf subset");
    }
    return NULL;
  }

  nRed = assumps22.size();
  int en=1;
  if (en)
  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    if (!nnfCoreMgr->isCore[i]) {
      if (nnfCoreMgr->gateType[i] != 'I') {
	int val = nnfCoreMgr->gateType[i] == 'A' ? 0 : 1;
	bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
	Pdtutil_Assert(nodeAuxChar(bmgr,baig)==0,"aux char not clean");
	nodeAuxChar(bmgr,baig) = (char) ((val==0) ? -1 : 1);
	nRed1++;
      }
    }
  }

  newAigEvalIntern(ddm,nnfCoreMgr->aNodes);
  n = nnfCoreMgr->aNodes->num;
  bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[n-1];
  aCore = Ddi_BddMakeFromBaig(ddm,bAig_AuxAig0(bmgr,baig));
  if (bAig_NodeIsInverted(baig)) {
    Ddi_BddNotAcc(aCore);
  }

  for (i=0; i<nnfCoreMgr->aNodes->num; i++) {
    bAigEdge_t baig = nnfCoreMgr->aNodes->nodes[i];
    nodeAuxChar(bmgr,baig) = (char) 0;
    bAig_AuxAig0(bmgr,baig) = bAig_NULL;
  }

  nnfCoreMgrFree(nnfCoreMgr);

  cpuTime = util_cpu_time () - startTime;

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),"Solver stats: %ld/%ld vars/clauses\n",
      S22->nVars(), S22->nClauses());
    fprintf(dMgrO(ddm),
      "Solver stats: %ld/%ld/%ld dec./prop./confl.\n",
      (int)S22->decisions, (int)S22->propagations,
       (int)S22->conflicts);
    fprintf(dMgrO(ddm),"Solver stats: time = %s\n", util_print_time (cpuTime)));

  if (undefined) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"Solver result UNDEFINED\n"));
    *psat = -1;
  }

  aig2CnfIdClose(ddm);

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
	     fprintf(dMgrO(ddm),"AIG NNF SUBSET #red: %d - size %d->%d\n", 
		     nRed1, sizeA, Ddi_BddSize(aCore)));
  delete S22;

  if (chkRes && *psat==1) {
    Pdtutil_Assert(Ddi_BddIncluded(aCore,a),"error in AIG SAT SUBSET");
    Pdtutil_Assert(Ddi_AigSatAnd(aCore,b,optCare),"error in AIG SAT SUBSET");

  }

  Ddi_Free(b2);

  return(aCore);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSat22AndWithAigCore (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  nnfCoreMgr_t *nnfCoreMgr,
  vec<vec<Lit> > *coreBClauses,
  bAig_array_t *cnfMappedVars,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *aCore=NULL, *b2=NULL;
  Minisat22Solver* S22;
  Solver Sdummy;
  Minisat::vec<Minisat::Lit> assumps22;
  Ddi_Vararray_t *vA=NULL, *vATot;
  int sizeA, sizeB, undefined = 0;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  vec<Var> coreVars;
  vec<vec<Lit> > coreClauses;
  int nACore, nCut=0, nACl;
  long startTime, cpuTime;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, chkRes=0 || 0 && (cnfMappedVars!=NULL), chkSat=0;
  int baseCtrl = -1;

  *psat = 0;

  if (coreBClauses==NULL) {
    if (Ddi_BddIsZero(b)) {
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    if (Ddi_BddIsZero(a) || Ddi_BddIsOne(b)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }

    //  Ddi_BddSetAig(a2);
    b2 = Ddi_BddDup(b);
    if (1 && optCare != NULL) {
      Ddi_BddAndAcc(b2,optCare);
    }

    if (Ddi_BddIsZero(b2)) {
      Ddi_Free(b2);
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    sizeA = Ddi_BddSize(a);
    sizeB = Ddi_BddSize(b2);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));
  }
  else {
    if (Ddi_BddIsZero(a)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }
    if (optCare != NULL) {
      b2 = Ddi_BddDup(optCare);
    }
    sizeA = Ddi_BddSize(a);
    sizeB = coreBClauses->size();
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG/CNF CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));
  }

  aig2CnfIdInit(ddm);
  //  aig2CnfIdInitDecr(ddm,3*(sizeA+sizeB)/3);

  S22 = new Minisat22Solver();

  if (cnfMappedVars!=NULL) {
    aig2CnfIdLoad(ddm,cnfMappedVars,0);
  }
  if (coreBClauses!=NULL) {
    Minisat::vec<Minisat::Lit> lits22;
    Pdtutil_Assert(cnfMappedVars!=NULL,"missing cnf var mapping");
    for (i=0; i<=cnfMappedVars->num; i++) {
      S22->newVar();
    }
    for (i=0; i<coreBClauses->size(); i++) {
      vec<Lit>& c = (*coreBClauses)[i];
      Minisat22SolverAddClause(S22,c,lits22);
    }
  }

  //  MinisatClausesWithSuppFlow(NULL,*S,NULL,a,b2,NULL,&nACl,NULL,&aigCnfMgr,0,0,0);
  MinisatClausesWithSuppFlow(NULL,Sdummy,(void *)S22,a,b2,NULL,&nACl,NULL,NULL,0,0,0,0);

  Pdtutil_Assert (nnfCoreMgr!=NULL,"missing nnf core mgr");

  assumps22.clear();

  if (1) {
    int nv = Ddi_VararrayNum(nnfCoreMgr->rV);

    for (i=0; i<nv; i++) {
      Ddi_Var_t *r_i = Ddi_VararrayRead(nnfCoreMgr->rV,i);
      Ddi_Var_t *a0_i = Ddi_VararrayRead(nnfCoreMgr->aV0,i);
      Ddi_Var_t *a1_i = Ddi_VararrayRead(nnfCoreMgr->aV1,i);
      bAigEdge_t vR = Ddi_VarToBaig(r_i);
      bAigEdge_t vA0 = Ddi_VarToBaig(a0_i);
      bAigEdge_t vA1 = Ddi_VarToBaig(a1_i);
      int rCnf = aig2CnfId(bmgr,vR);
      int a0Cnf = aig2CnfId(bmgr,vA0);
      int a1Cnf = aig2CnfId(bmgr,vA1);
      Minisat22NewVars(S22,rCnf);
      Minisat22NewVars(S22,a0Cnf);
      Minisat22NewVars(S22,a1Cnf);     
    }

    baseCtrl = S22->nVars()+1; 

    for (i=0; i<nv; i++) {
      Ddi_Var_t *r_i = Ddi_VararrayRead(nnfCoreMgr->rV,i);
      Ddi_Var_t *a0_i = Ddi_VararrayRead(nnfCoreMgr->aV0,i);
      Ddi_Var_t *a1_i = Ddi_VararrayRead(nnfCoreMgr->aV1,i);
      bAigEdge_t vR = Ddi_VarToBaig(r_i);
      bAigEdge_t vA0 = Ddi_VarToBaig(a0_i);
      bAigEdge_t vA1 = Ddi_VarToBaig(a1_i);
      int rCnf = aig2CnfId(bmgr,vR);
      int a0Cnf = aig2CnfId(bmgr,vA0);
      int a1Cnf = aig2CnfId(bmgr,vA1);
      vec<Lit> lits;

      int ctrlV0 = baseCtrl + 2*i;
      int ctrlV1 = baseCtrl + 2*i+1;

      /* r -> !a0 */
      Minisat22Clause3(S22,-ctrlV0,-rCnf,-a0Cnf);
      /* !r -> !a1 */
      Minisat22Clause3(S22,-ctrlV1,rCnf,-a1Cnf);

      assumps22.push(Minisat22Lit(ctrlV0));
      assumps22.push(Minisat22Lit(ctrlV1));
      
    }
  }


  startTime = util_cpu_time();

  if ((*psat = S22->okay())) {
    if (timeLimit >= 0) {
      *psat = S22->solve(assumps22);
    }
    else {
      *psat = S22->solve(assumps22);
    }
  }
  else {
    //    fprintf(dMgrO(ddm),"UNSAT\n");
  }
  cpuTime = util_cpu_time () - startTime;

  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm),"Solver stats: %ld/%ld vars/clauses\n",
      S22->nVars(), S22->nClauses());
    fprintf(dMgrO(ddm),
      "Solver stats: %ld/%ld/%ld dec./prop./confl.\n",
      (int)S22->decisions, (int)S22->propagations,
       (int)S22->conflicts);
    fprintf(dMgrO(ddm),"Solver stats: time = %s\n", util_print_time (cpuTime)));

  if (undefined) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelUsrMin_c, Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm),"Solver result UNDEFINED\n"));
    *psat = -1;
  }

  if (*psat || undefined) {
    aig2CnfIdClose(ddm);
    Ddi_Free(b2);
    delete S22;
    Ddi_Free(vA);
    if (undefined) *psat = -1;
    return NULL;
  }
  else {
    int k, nc;
    int nv = Ddi_VararrayNum(nnfCoreMgr->rV);
    Ddi_Bddarray_t *A0Const = Ddi_BddarrayMakeConst(ddm,nv, 1);
    Ddi_Bddarray_t *A1Const = Ddi_BddarrayMakeConst(ddm,nv, 1);

    for (k=nc=0; k<S22->conflict.size(); k++) {
      Minisat::Lit kLit = S22->conflict[k];
      int vSat = Minisat::var(kLit);
      int vCnf = vSat+1;
      int id = (vCnf-baseCtrl)/2;
      int phase = (vCnf-baseCtrl)%2;
      Ddi_Bdd_t *myLit;
      Ddi_Var_t *v = NULL;
      nc++;
      Pdtutil_Assert((id>=0)&&(id<nv),"problem with core map");
      if (phase) {
        v = Ddi_VararrayRead(nnfCoreMgr->aV1,id);
	myLit = Ddi_BddMakeLiteralAig(v, 1);
	Ddi_BddarrayWrite(A1Const,id,myLit);
      }
      else {
        v = Ddi_VararrayRead(nnfCoreMgr->aV0,id);
	myLit = Ddi_BddMakeLiteralAig(v, 1);
	Ddi_BddarrayWrite(A0Const,id,myLit);
      }
      Ddi_Free(myLit);
    }
    Pdtutil_Assert(nc<=assumps22.size(),"too many conflict literals");

    aCore = Ddi_BddCompose(a,nnfCoreMgr->aV0,A0Const);
    Ddi_BddComposeAcc(aCore,nnfCoreMgr->aV1,A1Const);

    Ddi_Free(A0Const);
    Ddi_Free(A1Const);

  }

  if (aigCnfMgr!=NULL) {
    aigCnfMgrFree(aigCnfMgr);
  }
  aig2CnfIdClose(ddm);

  delete S22;

  Ddi_Free(b2);

  return(aCore);
}

#if 1
/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSat22AndWithAigCoreByProof (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  nnfCoreMgr_t *nnfCoreMgr,
  vec<vec<Lit> > *coreBClauses,
  bAig_array_t *cnfMappedVars,
  int useMonotone,
  int *psat,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *aCore=NULL, *b2=NULL;
  Minisat22Solver* S22;
  Solver Sdummy;
  Ddi_Vararray_t *vA=NULL, *vATot;
  int sizeA, sizeB, undefined = 0;
  int nACore, nCut=0, nACl;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, chkRes=0 || 0 && (cnfMappedVars!=NULL), chkSat=0;
  int baseCtrl = -1;

  *psat = 0;

  if (coreBClauses==NULL) {
    if (Ddi_BddIsZero(b)) {
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    if (Ddi_BddIsZero(a) || Ddi_BddIsOne(b)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }

    //  Ddi_BddSetAig(a2);
    b2 = Ddi_BddDup(b);
    if (1 && optCare != NULL) {
      Ddi_BddAndAcc(b2,optCare);
    }

    if (Ddi_BddIsZero(b2)) {
      Ddi_Free(b2);
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    sizeA = Ddi_BddSize(a);
    sizeB = Ddi_BddSize(b2);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));
  }
  else {
    if (Ddi_BddIsZero(a)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }
    if (optCare != NULL) {
      b2 = Ddi_BddDup(optCare);
    }
    sizeA = Ddi_BddSize(a);
    sizeB = coreBClauses->size();
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG/CNF CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));
  }

  aig2CnfIdInit(ddm);
  //  aig2CnfIdInitDecr(ddm,3*(sizeA+sizeB)/3);

  S22 = new Minisat22Solver();
  S22->proofLogging(1);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  if (verbosity >= Pdtutil_VerbLevelUsrMin_c)
    S22->proofPdt.setVerbosity(1);
  if (verbosity >= Pdtutil_VerbLevelDevMax_c)
    S22->proofPdt.setVerbosity(2);

  S22->eliminate(true); // rutn off simplification

  if (cnfMappedVars!=NULL) {
    aig2CnfIdLoad(ddm,cnfMappedVars,0);
  }
  if (coreBClauses!=NULL) {
    Minisat::vec<Minisat::Lit> lits22;
    Pdtutil_Assert(cnfMappedVars!=NULL,"missing cnf var mapping");
    for (i=0; i<=cnfMappedVars->num; i++) {
      S22->newVar();
    }
    for (i=0; i<coreBClauses->size(); i++) {
      vec<Lit>& c = (*coreBClauses)[i];
      Minisat22SolverAddClause(S22,c,lits22);
    }
  }

  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  ddm->settings.aig.aigCnfLevel = 1;
  Minisat22Clauses((void *)S22,b2,NULL,NULL,0);
  S22->simplify();
  int nClausesNoF = S22->nClauses();
  S22->proofEndAClauses();
  
  Minisat22Clauses((void *)S22,a,NULL,NULL,0);
  ddm->settings.aig.aigCnfLevel = aigCnfLevel;

  long cpuTime=0, startTime=0;
  int ret;
  startTime = util_cpu_time ();
  if (!S22->okay()) {
    ret = 0;
  }
  else {    
    Minisat::vec<Minisat::Lit> assumps22;
    if (timeLimit >= 0) {
      S22->setTimeBudget((double)timeLimit);
      ret = S22->solveLimitedInt(assumps22);
    }
    else {
      ret = S22->solve(false,true);
    }
  }
  cpuTime = util_cpu_time () - startTime;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"NNF PBA Solver time = %s)\n", 
            util_print_time(cpuTime));
    fprintf(dMgrO(ddm),
          "NNF PBA Solver stats: %ld/%ld/%ld dec./prop./confl.\n",
	 (int)S22->decisions, (int)S22->propagations,
	 (int)S22->conflicts);
  }

  if (ret<0) {
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"NNF PBA Solver result UNDEFINED\n");
    }
    aCore = Ddi_BddDup(a);
  }
  else {
    assert (!ret);

    Minisat::TraceProofVisitor v(*S22, stdout);
    startTime = util_cpu_time ();
    S22->validate(v);
    cpuTime = util_cpu_time () - startTime;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
      fprintf(dMgrO(ddm),"NNF PBA Solver Validation time = %s)\n", 
              util_print_time(cpuTime));
    }

    int nAClCore=0;
    int nAbstrCand=0;

    vec<Var> coreVars;
    vec<Var> sharedVars;
    int logVars = 0;

    S22->proofSetupProofVars();

    for (int i=0; i<S22->nVars(); i++) {
      if (!S22->proofPdt.UsedVar(i)) {
        // these are vars not apearing in clauses
        coreVars.push(i<<2);
      }
      else if (S22->proofPdt.Global(i)) {
        sharedVars.push(i<<2);
      }
      else if (S22->proofPdt.Bvar(i)) {
        coreVars.push(i<<2);
      }
      else if (1 && S22->proofPdt.Avar(i)) {
        coreVars.push(i<<2);
      }
    }
  
    for (int i=S22->nVars(); i<ddm->cnf.maxCnfId; i++) {
      sharedVars.push(i<<2);
    }

    aCore = MinisatCoreAig(a,NULL,coreVars,&sharedVars,NULL,
                           &nCut,NULL,NULL,1);
  }

  if (aigCnfMgr!=NULL) {
    aigCnfMgrFree(aigCnfMgr);
  }
  aig2CnfIdClose(ddm);

  delete S22;

  Ddi_Free(b2);

  return(aCore);
}

#endif
/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
aigSat22RedBySimplify (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *optCare,
  nnfCoreMgr_t *nnfCoreMgr,
  vec<vec<Lit> > *coreBClauses,
  bAig_array_t *cnfMappedVars,
  int useMonotone
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *aCore=NULL, *b2=NULL;
  Minisat22Solver* S22;
  Solver Sdummy;
  Ddi_Vararray_t *vA=NULL, *vATot;
  int sizeA, sizeB, undefined = 0;
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  vec<Var> coreVars;
  vec<vec<Lit> > coreClauses;
  Minisat::vec<Minisat::Lit> assumps22;
  int nACore, nCut=0, nACl;
  long startTime, cpuTime;
  aigCnfMgr_t *aigCnfMgr=NULL;
  int i, chkRes=0 || 0 && (cnfMappedVars!=NULL), chkSat=0;
  int baseCtrl = -1;

  if (coreBClauses==NULL) {
    if (Ddi_BddIsZero(b)) {
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    if (Ddi_BddIsZero(a) || Ddi_BddIsOne(b)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }

    //  Ddi_BddSetAig(a2);
    b2 = Ddi_BddDup(b);
    if (1 && optCare != NULL) {
      Ddi_BddAndAcc(b2,optCare);
    }

    if (Ddi_BddIsZero(b2)) {
      Ddi_Free(b2);
      return (Ddi_BddMakeConstAig(ddm,1));
    }
    sizeA = Ddi_BddSize(a);
    sizeB = Ddi_BddSize(b2);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));
  }
  else {
    if (Ddi_BddIsZero(a)) {
      return (Ddi_BddMakeConstAig(ddm,0));
    }
    if (optCare != NULL) {
      b2 = Ddi_BddDup(optCare);
    }
    sizeA = Ddi_BddSize(a);
    sizeB = coreBClauses->size();
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm),"AIG/CNF CORE (|A|=%d,|B|=%d)\n",sizeA,sizeB));
  }

  aig2CnfIdInit(ddm);

  S22 = new Minisat22Solver();

  if (cnfMappedVars!=NULL) {
    aig2CnfIdLoad(ddm,cnfMappedVars,0);
  }
  if (coreBClauses!=NULL) {
    Minisat::vec<Minisat::Lit> lits22;
    Pdtutil_Assert(cnfMappedVars!=NULL,"missing cnf var mapping");
    for (i=0; i<=cnfMappedVars->num; i++) {
      S22->newVar();
    }
    for (i=0; i<coreBClauses->size(); i++) {
      vec<Lit>& c = (*coreBClauses)[i];
      Minisat22SolverAddClause(S22,c,lits22);
    }
  }

  MinisatClausesWithSuppFlow(NULL,Sdummy,(void *)S22,a,b2,NULL,&nACl,NULL,NULL,0,0,0,0);

  Pdtutil_Assert (nnfCoreMgr!=NULL,"missing nnf core mgr");

  assumps22.clear();

  if (0) {
    int nv = Ddi_VararrayNum(nnfCoreMgr->rV);

    for (i=0; i<nv; i++) {
      Ddi_Var_t *r_i = Ddi_VararrayRead(nnfCoreMgr->rV,i);
      Ddi_Var_t *a0_i = Ddi_VararrayRead(nnfCoreMgr->aV0,i);
      Ddi_Var_t *a1_i = Ddi_VararrayRead(nnfCoreMgr->aV1,i);
      bAigEdge_t vR = Ddi_VarToBaig(r_i);
      bAigEdge_t vA0 = Ddi_VarToBaig(a0_i);
      bAigEdge_t vA1 = Ddi_VarToBaig(a1_i);
      int rCnf = aig2CnfId(bmgr,vR);
      int a0Cnf = aig2CnfId(bmgr,vA0);
      int a1Cnf = aig2CnfId(bmgr,vA1);
      Minisat22NewVars(S22,rCnf);
      Minisat22NewVars(S22,a0Cnf);
      Minisat22NewVars(S22,a1Cnf);     
    }

    baseCtrl = S22->nVars()+1; 

    for (i=0; i<nv; i++) {
      Ddi_Var_t *r_i = Ddi_VararrayRead(nnfCoreMgr->rV,i);
      Ddi_Var_t *a0_i = Ddi_VararrayRead(nnfCoreMgr->aV0,i);
      Ddi_Var_t *a1_i = Ddi_VararrayRead(nnfCoreMgr->aV1,i);
      bAigEdge_t vR = Ddi_VarToBaig(r_i);
      bAigEdge_t vA0 = Ddi_VarToBaig(a0_i);
      bAigEdge_t vA1 = Ddi_VarToBaig(a1_i);
      int rCnf = aig2CnfId(bmgr,vR);
      int a0Cnf = aig2CnfId(bmgr,vA0);
      int a1Cnf = aig2CnfId(bmgr,vA1);
      vec<Lit> lits;

      int ctrlV0 = baseCtrl + 2*i;
      int ctrlV1 = baseCtrl + 2*i+1;

      /* r -> !a0 */
      Minisat22Clause3(S22,-ctrlV0,-rCnf,-a0Cnf);
      /* !r -> !a1 */
      Minisat22Clause3(S22,-ctrlV1,rCnf,-a1Cnf);

      assumps22.push(Minisat22Lit(ctrlV0));
      assumps22.push(Minisat22Lit(ctrlV1));
      
    }
  }

  startTime = util_cpu_time();
  bAigEdge_t baig = Ddi_BddToBaig(a);
  int fCnf = aig2CnfId(bmgr,baig);
  //  Minisat22FreezeCnfVar(S22,abs(fCnf));

  Minisat22FreezeAig (S22,b2);
  //  Minisat22FreezeVars (S22,ddm,NULL);
  S22->eliminate(false);
  //  int sat = S22->solve(assumps22);

  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelDevMin_c) {
    fprintf(dMgrO(ddm),"Solver stats: %ld/%ld vars/clauses - eliminated v/c: %d/%d\n",
	    S22->nVars(), S22->nClauses(),
	    S22->eliminated_vars, S22->eliminated_clauses);
  }

  coreVars.clear();
  int nElim=0;
  for (i=0; i<S22->nVars(); i++) {
    int vCnf = i+1;
    Minisat::Var v22 = i;
    bAigEdge_t baig = ddm->cnf.cnf2aig[vCnf];
    if (baig!=bAig_NULL) {
      if (!cnfReadActive(ddm,vCnf) || !S22->isEliminated(v22)) {
        coreVars.push((i<<2));
      }
      else {
	nElim++;
      }
    }
  }	
  /* process core vars */
  aCore = MinisatCoreAig(a,b2,coreVars,NULL,cnfMappedVars,
			 &nCut,aigCnfMgr,NULL,useMonotone);

  if (aigCnfMgr!=NULL) {
    aigCnfMgrFree(aigCnfMgr);
  }
  aig2CnfIdClose(ddm);

  delete S22;

  Ddi_Free(b2);

  return(aCore);
}



#endif

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
Minisat22ConstrainSolverWithAbstrCex(
  void *pS22void,
  void *pS22itpVoid,
  Ddi_Mgr_t *ddm,
  Ddi_Bdd_t *bAbstr,
  vec<Lit>& assumps,
  int nAClauses
) {
  bAig_array_t *bNodes;
  bAig_Manager_t *manager = ddm->aig.mgr;
  Minisat22Solver *pS22 = (Minisat22Solver *)pS22void;
  Minisat22Solver *pS22itp = (Minisat22Solver *)pS22itpVoid;
  int j, i;

  bNodes = bAigArrayAlloc();

  Ddi_PostOrderBddAigVisitIntern(bAbstr,bNodes,-1);
  postOrderAigClearVisitedIntern(manager,bNodes);

  Minisat::vec<bool> bVar;
  bVar.growTo(pS22->nVars(),false);
  
  for (j=0; j<bNodes->num; j++) {
    bAigEdge_t baig = bNodes->nodes[j];
    if (bAig_NodeIsConstant(baig) || bAig_isVarNode(manager,baig)) {
      continue;
    }
    int vCnf = aig2CnfId(manager,baig);
    int vSat = vCnf-1;
    assert(vSat<pS22->nVars());
    bVar[vSat] = true;
  }
  bAigArrayFree(bNodes);

  Minisat22Solver S22aux;
  pS22->copyAllClausesToSolverIfHaveNoVars (&S22aux,bVar);
  Minisat::vec<Minisat::Lit> assumps22;

  // aux solver
  int sat = S22aux.solve(assumps22);
  Minisat::vec<Minisat::Var> topv22;
  Minisat::vec<int> topd;
  Minisat::vec<double> topa;
  int mind = 10;
  double mina = 0.0;
  int nv = 20;
  //      S22->topVarDecisions(topv22, topd, ddm->cnf.cnf2aig, nSatVars, mind);
  Minisat::vec<bool> aVar;
  aVar.growTo(pS22->nVars(),false);
  
  Minisat::vec<Minisat::Lit> cl22;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity (ddm);
  if (verbosity >= Pdtutil_VerbLevelUsrMin_c)
    pS22itp->proofPdt.setVerbosity(1);
  if (verbosity >= Pdtutil_VerbLevelDevMax_c)
    pS22itp->proofPdt.setVerbosity(2);

  for (i=0; i<=pS22->nVars(); i++) {
    pS22itp->newVar();
  }
  for (i=0; i<nAClauses; i++) {
    const Minisat::Clause& cl = pS22->getClause2(i);
    cl22.clear();
    for(int j=0; j<cl.size(); ++j){
      cl22.push(cl[j]);
      aVar[Minisat::var(cl[j])] = true;
    }
    pS22itp->addClause(cl22);
  }

  //  pS22->topFilteredVarActivity(topv22, topa, bVar, nv);
  pS22->topFilteredVarActivity(topv22, topa, aVar, nv);

  for (int ii=0; ii<topa.size(); ii++) {
    int lit = topv22[ii]-1;    
    if (pS22itp->value(topv22[ii]) != l_Undef22)
      continue;
    if (S22aux.model[topv22[ii]] == l_False22) {
      lit = -lit;
    }
    Minisat22Clause1(pS22itp,lit);
    //    assumps.push(MinisatLit(lit));
  }
  int nAClausesNew = pS22itp->nClauses();
  for (i=nAClauses; i<pS22->nClauses(); i++) {
    const Minisat::Clause& cl = pS22->getClause2(i);
    cl22.clear();
    for(int j=0; j<cl.size(); ++j){
      cl22.push(cl[j]);
    }
    pS22itp->addClause(cl22);
  }

  return nAClausesNew;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSat22Constrain0(
  Ddi_Bdd_t *F,
  Ddi_Bdd_t *C,
  Ddi_Bdd_t *aForItp
) {
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(F);
  int again = 1;
  Ddi_Bdd_t *myConstr = Ddi_BddDup(C);
  Ddi_Bdd_t *myF = Ddi_BddMakeConstAig(ddm,0);
  Ddi_Bdd_t *notF = Ddi_BddNot(F);
  Ddi_Bdd_t *constr = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Vararray_t *rV = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV0 = Ddi_VararrayAlloc(ddm,0);
  Ddi_Vararray_t *aV1 = Ddi_VararrayAlloc(ddm,0);

  Ddi_Bdd_t *notFnnf = Ddi_AigNnf (notF,NULL,constr,rV,aV0,aV1);
  Ddi_BddSetAig(constr);
  Ddi_BddAndAcc(myConstr,constr);
  
  for (int i=0; again; i++) {
    int sat = 0;
    Ddi_Bdd_t *subsetF = sat22ConstrainIntern(notF,
                                              myConstr,aForItp,1000,&sat,1,1.0);
    Ddi_BddSubstVarsAcc(subsetF,aV0,rV);
    Ddi_BddSubstVarsAcc(subsetF,aV1,rV);

    if (0) {
      Ddi_Varset_t *fSupp = Ddi_BddSupp(F);
      Ddi_Varset_t *sSupp = Ddi_BddSupp(subsetF);
      Ddi_VarsetSetArray(fSupp);
      Ddi_VarsetSetArray(sSupp);
      Ddi_VarsetDiffAcc(sSupp,fSupp);
      Ddi_BddExistAcc(subsetF,sSupp);
      int i = Ddi_BddIncluded(notF,subsetF);
      printf("incl: %d\n", i);
    }
    Ddi_BddNotAcc(subsetF);
    if (!sat) again = 0;
    if (0) {
      Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(subsetF,aForItp,
                      NULL,NULL,-1,NULL);
      if (cex!=NULL) {
        Ddi_Varset_t *aSupp = Ddi_BddSupp(aForItp);
        Ddi_Varset_t *sSupp = Ddi_BddSupp(subsetF);
        Ddi_VarsetSetArray(aSupp);
        Ddi_VarsetSetArray(sSupp);
        Ddi_VarsetIntersectAcc(aSupp,sSupp);
        Ddi_AigCubeExistProjectAcc (cex,aSupp);
        Ddi_Free(aSupp);
        Ddi_Free(sSupp);
        Ddi_Free(cex);
      }
    }
    Ddi_Bdd_t *itpF;
    itpF = Ddi_AigSat22AndWithInterpolant(NULL,aForItp,subsetF,
                                          NULL,NULL,NULL,NULL,0,
                                          NULL,NULL,
                                          &sat,0,1,0,-1.0);
    Ddi_Free(subsetF);
    if (sat) {
      Ddi_Free(myF);
      myF = NULL;
      again = 0;
    }
    else {
      Ddi_BddNotAcc(itpF);
      Ddi_BddOrAcc(myF,itpF);
      Ddi_BddDiffAcc(myConstr,itpF);
    }
    Ddi_Free(itpF);
    
  }
  Ddi_Free(myConstr);
  Ddi_Free(notF);
  Ddi_Free(constr);
  Ddi_Free(notFnnf);
  Ddi_Free(aV0);
  Ddi_Free(aV1);
  Ddi_Free(rV);

  return myF;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSat22Constrain(
  Ddi_Bdd_t *F,
  Ddi_Bdd_t *C,
  Ddi_Bdd_t *aForItp
) {
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(F);
  int again = 1, i;
  Ddi_Bdd_t *myConstr = Ddi_BddDup(C);
  Ddi_Bdd_t *myF = Ddi_BddMakeConstAig(ddm,0);
  
  for (i=0; again; i++) {
    int sat = 0;
    float subsetRatio = 2/(float)(i+3);

    Ddi_Bdd_t *subsetF = sat22ConstrainIntern(F,
                           myConstr,aForItp,10,&sat,0,subsetRatio);
    if (!sat) {
      again = 0;
      Ddi_Free(subsetF);
      break;
    }
    Ddi_Bdd_t *itpF;
    itpF = Ddi_AigSat22AndWithInterpolant(NULL,aForItp,subsetF,
                                          NULL,NULL,NULL,NULL,0,
                                          NULL,NULL,
                                          &sat,0,1,0,-1.0);
    Ddi_Free(subsetF);
    if (sat) {
      Ddi_Free(myF);
      myF = NULL;
      again = 0;
    }
    else {
      Ddi_BddNotAcc(itpF);
      Ddi_BddOrAcc(myF,itpF);
      Ddi_BddDiffAcc(myConstr,itpF);
    }
    Ddi_Free(itpF);
    printf("Minisat22 constrain subset iteration %d done - ratio: %.2f\n", i, subsetRatio);
    
  }
  Ddi_Free(myConstr);
  printf("Minisat22 constrain subset done in %d iter\n", i);

  return myF;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Ddi_AigSat22Constrain1(
  Ddi_Bdd_t *F,
  Ddi_Bdd_t *C,
  Ddi_Bdd_t *aForItp
) {
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(F);
  Ddi_Bdd_t *myF;
  int sat;

  myF = sat22ConstrainIntern(F,C,aForItp,-1,&sat,0,1.0);

  if (!Ddi_AigSatAnd(F,aForItp,C)) {
    Pdtutil_Assert(!Ddi_AigSatAnd(myF,aForItp,C),"wrong sat22constr");
  }
             
  return myF;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with aig core generation]
  Description [Satisfiability Check on a&b with aig core generation.
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
sat22ConstrainIntern(
  Ddi_Bdd_t *F,
  Ddi_Bdd_t *C,
  Ddi_Bdd_t *A,
  int maxIter,
  int *res,
  int doTernary,
  float subsetRatio
) {

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(F);
  bAig_Manager_t *bmgr = ddm->aig.mgr;
  Ddi_Bdd_t *fConstr = NULL;
  int doSubset = !doTernary && maxIter>0;
  static int myDbg = 0;
  static int nCalls = 0, maxCnt = -1;
  nCalls++;
  int cnt=0;

  int sizeF = Ddi_BddSize(F);

  Ddi_Var_t *pv = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
  Ddi_Bdd_t *p = Ddi_BddMakeLiteralAig(pv, 1);
  bAigEdge_t pBaig = Ddi_VarToBaig(pv);

  if (Ddi_BddIsZero(F)) {
    return (NULL);
  }
  if (Ddi_BddIsOne(F) || Ddi_BddIsZero(C)) {
    return (Ddi_BddMakeConstAig(ddm,1));
  }

  Minisat22Solver S22, S22bAux, S22b, S22a;

  aig2CnfIdInit(ddm);

  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  ddm->settings.aig.aigCnfLevel = 0;
  Minisat22Clauses((void *)&S22bAux,F,NULL,NULL,1);
  Minisat22Clauses((void *)&S22,F,C,NULL,0);
  Minisat22Clauses((void *)&S22a,A,NULL,NULL,0);
  ddm->settings.aig.aigCnfLevel = aigCnfLevel;

  int fCnf = DdiAig2CnfIdSigned(bmgr,Ddi_BddToBaig(F));
  Minisat::Lit lit22F = Minisat22Lit(fCnf);
  Minisat::Lit lit22notF = Minisat22Lit(-fCnf);

  if (!S22.okay()) {
    aig2CnfIdClose(ddm);
    return NULL;
  }

  Ddi_Vararray_t *fVars = Ddi_BddSuppVararray(F);
  Minisat::vec<Minisat::Var> freeVars22;
  Minisat::vec<Minisat::Var> actVars22;

  for (int i=0; i<Ddi_VararrayNum(fVars); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(fVars,i);
    bAigEdge_t vBaig = Ddi_VarToBaig(v);
    int vCnf = aig2CnfId(bmgr,vBaig);
    if (myDbg>1)
      printf("baig: %d - v: %d\n", vBaig/4, vCnf-1);
    freeVars22.push(vCnf-1);
  }
  for (int i=0; i<=S22bAux.nVars(); i++) {
    S22b.newVar();
  }
  while (S22a.nVars() < S22b.nVars()) {
    S22a.newVar();
  }
  while (S22b.nVars() < S22a.nVars()) {
    S22b.newVar();
  }
  Minisat::vec<Minisat::Lit> cl22;
  int currAct = S22b.nVars();
  int actClauseOffset = currAct;
  int nVarsF0 = S22b.nVars();
  int nA = S22bAux.nAssigns();
  for (int i=0; i<nA; i++) {
    const Minisat::Lit& l = S22bAux.getAssign(i);
    int v = Minisat::var(l);
    int s = Minisat::sign(l);
    int litCnf = s?-(v+1):(v+1);
    Minisat22Clause1(&S22b,litCnf);
  }

  if (myDbg) {

    int pSat = aig2CnfId(bmgr,pBaig);
    printf("property sat var: %d\n", pSat-1);
  }
  
  if (myDbg>1) {

    printf("solver 1 clauses:\n");
    for (int i=0; i<S22.nClauses(); i++) {
      const Minisat::Clause& cl = S22.getClause2(i);
      for(int j=0; j<cl.size(); ++j){
        int v = Minisat::var(cl[j]);
        int s = Minisat::sign(cl[j]);
        printf("%s%d ",s?"-":"",v);
      }
      printf("\n");
    }
  }

  if (myDbg>1)
    printf("solver 2 clauses:\n");
  for (int i=0; i<S22bAux.nClauses(); i++) {
    const Minisat::Clause& cl = S22bAux.getClause2(i);
    cl22.clear();
    for(int j=0; j<cl.size(); ++j){
      int v = Minisat::var(cl[j]);
      int s = Minisat::sign(cl[j]);
      cl22.push(cl[j]);
      if (myDbg>1)
        printf("%s%d ",s?"-":"",v);
    }
    if (myDbg>1)
      printf(" - ACT: -%d\n", currAct);
    actVars22.push(currAct);
    cl22.push(Minisat22Lit(-(currAct+1)));
    currAct++;
    S22b.newVar();
    S22b.addClause(cl22);
    S22a.newVar();
    S22a.addClause(cl22);
  }
  Minisat22Clauses((void *)&S22b,C,NULL,NULL,0);
  Minisat22Clauses((void *)&S22a,C,NULL,NULL,0);
  
  int i;
  int sat=1;
  int nNew = 0, nRef = 0;
  int nVarsF = S22b.nVars();
  vec<bool> posLit, negLit, actVar, freeVar, actVarConst;
  posLit.growTo(nVarsF,false);
  actVar.growTo(nVarsF,false);
  actVarConst.growTo(nVarsF,false);
  freeVar.growTo(nVarsF,false);
  negLit.growTo(nVarsF,false);
  for (int i=0; i<actVars22.size(); i++) {
    int v = actVars22[i];
    actVar[v]=true;
  }
  for (int i=0; i<freeVars22.size(); i++) {
    int v = freeVars22[i];
    freeVar[v]=true;
  }
  for (int i=0; i<nA; i++) {
    const Minisat::Lit& l = S22bAux.getAssign(i);
    int v = Minisat::var(l);
    int s = Minisat::sign(l);
    if (s) {
      negLit[v] = true; nNew++;
      posLit[v] = true; nNew++;
    }
    else {
      posLit[v] = true; nNew++;
      negLit[v] = true; nNew++;
    }
  }
  
  Minisat::vec<Minisat::Lit> assumps22;
  Minisat::vec<Minisat::Lit> blocking22;
  Minisat::vec<Minisat::Lit> prevBlocking22;

  static int doChk = 0;
  int doFlip = 0;
  int useAbstr = doFlip, nextAbstr = 0;
  blocking22.clear();
  for (i=0; sat && (maxIter<0 || i<maxIter);
       i++, useAbstr = nextAbstr) {
    Minisat22Solver *S22model = &S22;
    if (doFlip) nextAbstr = !nextAbstr;
    assumps22.clear();
    if (useAbstr) { 
      S22model = &S22a;
      assumps22.push(lit22F);
      for (int i=0; i<actVars22.size(); i++) {
        int v = actVars22[i];
        if (actVarConst[v]) {
          assumps22.push(Minisat22Lit((v+1))); // act lit = 1
        }
      }
    }
    sat = S22model->solve(assumps22);
    
    if (sat) {
      // take core
      Minisat::vec<Minisat::Lit> cex22;
      cex22.clear();
      cex22.push(useAbstr?lit22F:lit22notF);

      for (int i=0; i<blocking22.size(); i++) {
        int v = Minisat::var(blocking22[i]);
        int s = Minisat::sign(blocking22[i]);
        if (S22model->model[v] == l_True22 && !s) {
          //          printf("blocking ok\n");
          nNew++;
          assert(!posLit[v]);
          posLit[v] = true;
        }
        else if (S22model->model[v] == l_False22 && s) {
          //          printf("blocking ok\n");
          nNew++;
          assert(!negLit[v]);
          negLit[v] = true;
        }
      }
      blocking22.clear();

      if (myDbg)
        printf("CEX: ");
      Ddi_Bdd_t *cexAig = Ddi_BddMakeConstAig(ddm,1); 

      for (int i=0; i<freeVars22.size(); i++) {
        int v = freeVars22[i];
        Ddi_Bdd_t *litAig = NULL;
        Ddi_Var_t *vAig = Ddi_VararrayRead(fVars,i);

        if (S22model->model[v] == l_True22) {
          cex22.push(Minisat22Lit((v+1)));
          if (myDbg) printf("%d ",v);
          if (myDbg) litAig = Ddi_BddMakeLiteralAig(vAig, 1);
        }
        else if (S22model->model[v] == l_False22) {
          cex22.push(Minisat22Lit(-(v+1)));
          if (myDbg) printf("-%d ",v);
          if (myDbg) litAig = Ddi_BddMakeLiteralAig(vAig, 0);
        }
        if (litAig!=NULL) Ddi_BddAndAcc(cexAig,litAig);
        Ddi_Free(litAig);
      }

      Ddi_Free(cexAig);

      if (myDbg) printf("\n");
      for (int i=0; i<actVars22.size(); i++) {
        int v = actVars22[i];
        cex22.push(Minisat22Lit((v+1))); // act lit = 1
      }
      
      int sat2 = S22b.solve(cex22);
      if (sat2) {
        sat = 1;
        break;
      }
      assert(!sat2);
      for (int k=0; k<S22b.conflict.size(); k++) {
        Minisat::Lit kLit = S22b.conflict[k];
        int vSat = Minisat::var(kLit);
        int s = Minisat::sign(kLit);
        if (!actVar[vSat]) {
          if (freeVar[vSat] && !nextAbstr) {
            if (!s) {
              blocking22.push(Minisat22Lit((vSat+1)));
            }
            else {
              blocking22.push(Minisat22Lit(-(vSat+1)));
            }
          }
          continue;
        }
        int clause_i = vSat - actClauseOffset;
        if (!actVarConst[vSat]) {
          actVarConst[vSat] = true; // refine
          nRef++;
        }
        assert (clause_i>=0);
        int found = 0;
        const Minisat::Clause& cl = S22b.getClause2(clause_i);
        for(int j=0; j<cl.size(); ++j){
          int v_j = Minisat::var(cl[j]);
          int s_j = Minisat::sign(cl[j]);
          if (v_j==vSat) {found=1; continue; }
          if ((useAbstr || S22model->model[v_j] == l_True22)
              && !s_j && !posLit[v_j]) {
            nNew++;
            posLit[v_j] = true;
          }
          else if ((useAbstr || S22model->model[v_j] == l_False22)
                   && s_j && !negLit[v_j]) {
            nNew++;
            negLit[v_j] = true;
          }
        }
        assert(found);
      }
      assert(nNew>0);
      if (!nextAbstr)
        S22.addClause(blocking22);
      blocking22.clear();
      if (myDbg) printf("BLOCKING: ");
      for (int v=0; v<nVarsF; v++) {
        if (!negLit[v] && posLit[v]) {
          blocking22.push(Minisat22Lit(-(v+1)));
          if (myDbg) printf("-%d ",v);
        }
        else if (negLit[v] && !posLit[v]) {
          blocking22.push(Minisat22Lit((v+1)));
          if (myDbg) printf("%d ",v);
        }
      }
      if (myDbg) printf("\n");
      S22.addClause(blocking22);
      if (0 && (prevBlocking22.size()==blocking22.size())) {
        int cntd=0;
        for (int j=0; j<blocking22.size(); j++) {
          if (blocking22[j]!=prevBlocking22[j]) {
            cntd++;
          }
        }
        if (cntd>0)
          printf("iter %d - found %d diff\n", i, cntd);
      }
      blocking22.copyTo(prevBlocking22);
      if (i%1000 == 0)
      printf("iteration: %d - blocking size: %d\n",
             i, blocking22.size());
    }
  }

  *res = sat;
  if (sat && (maxIter<0 || i<maxIter)) {
    Ddi_Free(p);
    Ddi_Free(fVars);
    aig2CnfIdClose(ddm);
    return NULL;
  }
  if (!sat && (i==1)) {
    Ddi_Free(p);
    Ddi_Free(fVars);
    aig2CnfIdClose(ddm);
    return NULL;
  }
  
  int countLits0=0, countLits1=0, countLits01=0;
  for (int v=0; v<nVarsF; v++) {
    if (posLit[v]) {
      countLits1++;
      if (negLit[v]) countLits01++;
    }
    if (negLit[v]) {
      countLits0++;
    }
  }
  printf("Minisat22 constrain iterations: %d\n", i);
  printf("Minisat22 constrain found %d+%d=%d (common v: %d) / %d lits active\n",
         countLits0, countLits1, countLits0+countLits1,
         countLits01, 2*nVarsF0); 


  bAig_array_t *visitedNodes = bAigArrayAlloc();
  Ddi_PostOrderBddAigVisitIntern(F,visitedNodes,-1);
  postOrderAigClearVisitedIntern(bmgr,visitedNodes);
  aigArrayClearAuxAigIntern(bmgr,visitedNodes);

  Ddi_Bdd_t *subsetConstr = NULL;
  if (doSubset) {
    subsetConstr = Ddi_BddMakePartConjVoid(ddm);
  }

  char name[100];
  int nCut = 0;
  bAigArraySortByLevel(ddm,visitedNodes,bAig_NULL,-1);

  if (doSubset) {
    for (int i=0; i<visitedNodes->num; i++) {
      bAigEdge_t baig = visitedNodes->nodes[i];
      if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
        continue;
      }
      int vBaig = aig2CnfId(bmgr,baig);
      int vSat = vBaig-1;
      if (posLit[vSat] && !negLit[vSat] ||
          !posLit[vSat] && negLit[vSat]) {
        cnt++;
      }
    }
  }

  if (doSubset) maxCnt = cnt*subsetRatio;
  cnt=0;
  
  for (int i0=0; i0<visitedNodes->num; i0++) {
    int i=doSubset?visitedNodes->num-1-i0:i0;
    //    int i=i0;
    bAigEdge_t baig = visitedNodes->nodes[i];
    if (bAig_NodeIsConstant(baig)||bAig_isVarNode(bmgr,baig)) {
      continue;
    }
    int vBaig = aig2CnfId(bmgr,baig);
    int vSat = vBaig-1;
    if (doSubset) {
      bAigEdge_t baigNI = bAig_NonInvertedEdge(baig);
      if (posLit[vSat] && !negLit[vSat]) {
        cnt++;
        if (maxCnt>=0 && cnt>maxCnt) continue;
        Ddi_Bdd_t *f_i = Ddi_BddMakeFromBaig(ddm,baigNI);
        Ddi_BddPartInsertLast(subsetConstr,f_i);
        Ddi_Free(f_i);
      }
      else if (!posLit[vSat] && negLit[vSat]) {
        cnt++;
        if (maxCnt>=0 && cnt>maxCnt) continue;
        Ddi_Bdd_t *f_i = Ddi_BddMakeFromBaig(ddm,baigNI);
        Ddi_BddNotAcc(f_i);
        Ddi_BddPartInsertLast(subsetConstr,f_i);
        Ddi_Free(f_i);
      }
    }
    else {
#if 1
      if (!posLit[vSat] && !negLit[vSat]) {
        // zero constant: abstract
        //      bAig_AuxAig1(bmgr,baig) = bAig_Zero; 
        cnt++;
        if (maxCnt>=0 && cnt>maxCnt) continue;
        if (doTernary) {
          bAig_AuxAig0(bmgr,baig) = bAig_One; 
          bAig_AuxAig1(bmgr,baig) = bAig_One; 
        }
        else {
          Ddi_Var_t *aV;
          sprintf(name,"_CUT_AUXV_%d", nCut++);
          aV = Ddi_VarFindOrAdd(ddm, name, 0);
          bAigEdge_t baigNew = Ddi_VarToBaig(aV);
          bAig_AuxAig0(bmgr,baig) = baigNew;
        }
      }
#else 
      if (!posLit[vSat]) {
        // zero constant: abstract
        //      bAig_AuxAig1(bmgr,baig) = bAig_Zero; 
        bAig_AuxAig1(bmgr,baig) = bAig_One; 
      }
      if (!negLit[vSat]) {
        // zero constant: abstract
        //      bAig_AuxAig0(bmgr,baig) = bAig_One; 
        bAig_AuxAig0(bmgr,baig) = bAig_One; 
      }
#endif
    }
  }
  aig2CnfIdClose(ddm);
  Ddi_Free(p);
  Ddi_Free(fVars);

  Ddi_Bdd_t *newfAig = NULL;
  if (doSubset) {
    Ddi_BddPartInsertLast(subsetConstr,F);
    Ddi_AigStructRedRemAcc(subsetConstr, NULL);
    newfAig = Ddi_BddMakeAig(subsetConstr);
    Ddi_Free(subsetConstr);
  }
  else {
    bAigEdge_t fBaig = Ddi_BddToBaig(F);
    if (doTernary) {
      ternaryEvalIntern(ddm,visitedNodes,bAig_NULL,-1);
      bAigEdge_t newfBaig = bAig_AuxAig1(bmgr,fBaig);
      if (bAig_NodeIsInverted(fBaig)) {
        newfBaig = bAig_AuxAig0(bmgr,fBaig);
      }
      newfAig = Ddi_BddMakeFromBaig(ddm,newfBaig);
    }
    else {
      newAigEvalIntern(ddm,visitedNodes);
      bAigEdge_t newfBaig = bAig_AuxAig0(bmgr,fBaig);
      newfAig = Ddi_BddMakeFromBaig(ddm,newfBaig);
      if (bAig_NodeIsInverted(fBaig)) {
        Ddi_BddNotAcc(newfAig);
      }
    }

    bAigArrayClearFreeAuxAig(bmgr,visitedNodes);
    //  Pdtutil_Assert(Ddi_BddIncluded(newfAig,F),"wrong abstraction");  
    Pdtutil_Assert(!myDbg || Ddi_BddIncluded(F,newfAig),"wrong abstraction");  
  }

  printf("Minisat22 constrain cuts; %d/%d\n", cnt,
         visitedNodes->num);
  bAigArrayFree(visitedNodes);

  return newfAig;
}

