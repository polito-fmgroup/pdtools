/**CFile**********************************************************************

  FileName    [travSat.c]

  PackageName [trav]

  Synopsis    [Aig/SAT based verif/traversal routines]

  Description []

  SeeAlso   []

  Author    [Gianpiero Cabodi]

  Copyright [This file was created at the Politecnico di Torino,
    Torino, Italy.
    The  Politecnico di Torino makes no warranty about the suitability of
    this software for any purpose.
    It is presented on an AS IS basis.
  ]

  Revision  []

******************************************************************************/

#include "travInt.h"
#include "ddiInt.h"
#include "baigInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

typedef enum {
  igrRefineSide_0_c,
  igrRefineSide_1_c,
  igrRefineSide_2_c,
  igrRefineNormal_c,
  igrRefineNone_c
} igrRefineState_e;

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*--------------------------------------------------------------------------s-*/

//int TravAigPartial = 0;

//Ddi_Var_t *constraintGuard=NULL;
//Ddi_Var_t *constraintGuard2=NULL;
Ddi_Bddarray_t *save2=NULL;

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

#define dMgrO(ddiMgr) ((ddiMgr)->settings.stdout)
#define IGR_BWD_FORCE_EXPAND_BWD 1

/**AutomaticStart*************************************************************/

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int itpAbstrRefCurrAbstrSetup(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t * kCone
);
static int itpAbstrRefBddarrayRefine(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t * fA,
  Ddi_Bddarray_t * abstrSelect,
  int refineAndAbstr
);
static int itpAbstrRefCurrAbstrDeltaSetup(
  Trav_ItpMgr_t * itpMgr
);
static int itpAbstrRefCurrAbstrDeltaCheck(
  Trav_ItpMgr_t * itpMgr
);
static int itpAbstrRefApplyCurrAbstr(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * f
);
static int itpAbstrRefCurrAbstrNnfJoinCtrl(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t * abstrSelect
);
static int abstrRefCompact(
  Trav_ItpMgr_t * itpMgr
);
static int interpolantInnerLoop(
  Trav_Mgr_t * travMgr,
  Ddi_Bdd_t * kCone,
  Ddi_Bdd_t * kConeOld,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * careBwd,
  Ddi_Bdd_t * careBwdBdd,
  Ddi_Bdd_t * rOut,
  Ddi_Bdd_t * careOut,
  Ddi_Bddarray_t * kConeOldAuxLits,
  Trav_ItpMgr_t * itpMgr,
  int *pAbort,
  int optLevel,
  int firstIter,
  int maxIter,
  unsigned long time_limit
);
static void interpolantTernaryAbstr(
  Trav_Mgr_t * travMgr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * cone,
  Ddi_Bdd_t * care,
  Ddi_Varset_t * nsvars,
  Ddi_Varset_t * noTernaryVars,
  Ddi_Varset_t * ternarySmooth,
  int dynAbstr,
  int enDynAbstrOpt,
  int phase
);
static Ddi_Bdd_t *interpolantSatApprImg(
  Trav_ItpMgr_t * itpMgr,
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * care,
  int *exactP,
  int partSize,
  int apprLevel
);
static Ddi_Varset_t *interpolantDynAbstrFrom(
  Ddi_Bdd_t * fromAndTr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * cone,
  Ddi_Bdd_t * care,
  Ddi_Bdd_t * invar,
  Ddi_Vararray_t * ns,
  Ddi_Varset_t * nsvars,
  Ddi_Vararray_t * noAbstr,
  Ddi_Vararray_t * dynAbstrCut,
  Ddi_Vararray_t * dynAbstrAux,
  Ddi_Bddarray_t * dynAbstrCutLits,
  Ddi_Bddarray_t * trArray,
  unsigned char *enAbstr,
  unsigned char *abstrMask,
  int doSimplifyTr,
  int *nAbstrP
);
static int interpolantStructAbstrFrom(
  Ddi_Bdd_t * fromAndTr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * cone,
  Ddi_Vararray_t * ns,
  Ddi_Varset_t * nsvars,
  Ddi_Bddarray_t * trArray
);
static Trav_TimeFrameInfo_t *timeFrameInfoInit(
  Ddi_Mgr_t * ddiMgr,
  int initSize
);
static void timeFrameInfoFree(
  Trav_TimeFrameInfo_t * timeFrames
);
static void timeFrameInfoPush(
  Trav_TimeFrameInfo_t * timeFrames,
  Ddi_Bddarray_t * lits,
  Ddi_Vararray_t * vars,
  Ddi_Bddarray_t * piLits,
  Ddi_Vararray_t * piVars,
  Ddi_Varset_t * coi
);
static void
itpMgrFindOrAddTimeFrames(
  Trav_ItpMgr_t * itpMgr,
  int nFrames,
  int timeShift,
  int useNsVars
);
static int timeFrameFindOrAdd(
  Trav_TimeFrameInfo_t * timeFrames,
  Ddi_Vararray_t * pi,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * ns,
  Ddi_Varset_t * psVars,
  int i,
  int enableloopFree,
  int useAigVars
);
static Trav_ItpTravMgr_t *itpTravMgrInit(
  Trav_Mgr_t * travMgr,
  Trav_ItpMgr_t * itpMgr
);
static void itpTravMgrFree(
  Trav_ItpTravMgr_t * itpTravMgr
);
static int itpAbstrRefInit(
  Trav_ItpMgr_t * itpMgr
);
static int itpHintsInit(
  Trav_ItpMgr_t * itpMgr
);
static void timeFrameAddAcc(
  Ddi_Bdd_t * f,
  Ddi_Vararray_t * pi,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * ns,
  Ddi_Varset_t * psVars,
  Ddi_Vararray_t * composeVars,
  Ddi_Bddarray_t * composeFuncs,
  Trav_TimeFrameInfo_t * timeFrames,
  int useAigVars
);
static void timeFrameShiftAcc(
  Ddi_Bdd_t * f,
  Ddi_Vararray_t ** timeFrameVars,
  Ddi_Bddarray_t ** timeFrameLits,
  int nTimeFrames
);
static void timeFrameShiftBackAcc(
  Ddi_Bdd_t * f,
  Ddi_Vararray_t ** timeFrameVars,
  Ddi_Bddarray_t ** timeFrameLits,
  int nTimeFrames
);
static void timeFrameShiftKAcc(
  Ddi_Bdd_t * f,
  Ddi_Vararray_t ** timeFrameVars,
  Ddi_Bddarray_t ** timeFrameLits,
  int nTimeFrames,
  int k
);
static Ddi_Bddarray_t *genLemmas(
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * spec,
  Ddi_Bdd_t * careBdd,
  int bound,
  int simulDepth,
  int maxLemmaLevel,
  int *result
);
static Ddi_Bddarray_t *genLemmaClasses(
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bddarray_t * initStub,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * spec,
  Ddi_Bdd_t * careBdd,
  Ddi_Bddarray_t * constants,
  int bound,
  int do_compaction,
  int do_implication,
  int do_heavy,
  int *result,
  int max_false,
  Ddi_Bddarray_t * false_lemmas
);
static Ddi_Bddarray_t *lemmaApproxTrav(
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bddarray_t * initStub,
  Ddi_Bdd_t * invar,
  int bound,
  int do_implication,
  int timeLimit
);
static Ddi_Bddarray_t *fsmOptByEquiv(
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bddarray_t * reprs,
  Ddi_Bddarray_t * equals,
  Ddi_Bddarray_t * lemmaArray,
  Ddi_Bdd_t * careBdd,
  Ddi_Bdd_t * spec
);
static Ddi_Vararray_t **composeRelationalWithNewTimeFrameVars(
  Ddi_Bdd_t * f,
  Ddi_Bdd_t * invar,
  Ddi_Vararray_t * ps,
  Ddi_Bddarray_t * delta,
  Ddi_Vararray_t * pi,
  Ddi_Varset_t * psIn,
  char *piNamePrefix,
  char *psNamePrefix,
  int frameSuffix,
  int doRel
);
static void *refineRelationalTimeFrames(
  Ddi_Bdd_t * conePart,
  Ddi_Varset_t * psIn,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * pi,
  Ddi_Bddarray_t * delta,
  Ddi_Vararray_t ** timeFramePsVars,
  Ddi_Vararray_t ** timeFramePiVars,
  char *varNamePrefix,
  int cegar
);
static Ddi_Bdd_t *InductiveImgPlus(
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * inductiveTo
);
static Ddi_Bdd_t *InductiveImgInf(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * toPlus,
  Ddi_Bdd_t * currRplus,
  Ddi_Bdd_t * tr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * cone
);
static Ddi_Vararray_t *newTimeFrameVars(
  Ddi_Vararray_t * baseVars,
  char *nameSuffix
);
static int checkFixPoint0(
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * oldCheck,
  Ddi_Bdd_t * check
);
static int checkFixPoint(
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * oldCheck,
  Ddi_Bdd_t * check,
  Ddi_Bdd_t * care
);
static int checkRingIsFixPoint(
  Ddi_Vararray_t *ps,
  Ddi_Vararray_t *ns,
  Ddi_Bddarray_t *delta,
  Ddi_Bdd_t * ring
);
static int checkFixPointByInterpolant(
  Trav_ItpMgr_t * itpMgr,
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * check,
  Ddi_Bdd_t * oldCheck,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * care,
  Ddi_Bdd_t * careBdd,
  Ddi_Bdd_t * rOut,
  Ddi_Bdd_t * careOut,
  Ddi_Bddarray_t * oldCheckAuxLits,
  int optLevel,
  int *pabort,
  unsigned long time_limit,
  int coneDepth,
  int firstIter,
  int maxIter,
  Trav_TimeFrameInfo_t * timeFrames
);
static int checkFixPoint1(
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * oldCheck,
  Ddi_Bdd_t * check,
  Ddi_Bdd_t * care
);
static int checkFixPoint2(
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * oldCheck,
  Ddi_Bdd_t * check,
  Ddi_Bdd_t * care,
  int maxIter
);
static Ddi_Bdd_t *imgBddAigAppr(
  Tr_Mgr_t * trMgr /* Tr Manager */ ,
  Ddi_Bdd_t * tr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * care,
  Ddi_Varset_t * coreVars,
  Ddi_Varset_t * satVars,
  int maxSupp,
  int apprLevel
);
static Ddi_Bdd_t *imgBddAig(
  Tr_Mgr_t * trMgr /* Tr Manager */ ,
  Ddi_Bdd_t * tr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * care
);
static Ddi_Bdd_t *imgBddAigSat(
  Tr_Mgr_t * trMgr /* Tr Manager */ ,
  Ddi_Bdd_t * tr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * care,
  Ddi_Varset_t * coreVars,
  Ddi_Varset_t * satVars,
  int maxSupp,
  int apprLevel
);
static int trLinearSquaring(
  Ddi_Bdd_t * tr,
  Ddi_Vararray_t * ps,
  Ddi_Bddarray_t * delta,
  Ddi_Vararray_t * pi,
  Ddi_Bdd_t * care,
  int nFrames
);
static Ddi_Varsetarray_t *computeFsmCoiVars(
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * p,
  int maxIter
);
static void fsmCoiReduction(
  Fsm_Mgr_t * fsmMgr,
  Ddi_Varset_t * coiVars
);
static Ddi_Bdd_t *bmcItpSeqCegarCheck(
  Trav_Mgr_t * travMgr,
  Ddi_Bddarray_t * delta,
  Ddi_Bdd_t * cone,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * extInvar,
  Ddi_Bdd_t * coneAndInit,
  Ddi_Bddarray_t * initStub,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * ns,
  Ddi_Vararray_t * pi,
  int maxBound,
  float seqSerial,
  int cegar,
  int fwdBwdFP,
  int seqReverse,
  int seqGroup
);
static int itpSequenceStep(
  Ddi_Bddarray_t * delta,
  Ddi_Bdd_t * checkPart,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * cone0,
  Ddi_Bdd_t * invar,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * ns,
  Ddi_Bddarray_t * psSubstLits,
  Ddi_Bddarray_t * psLits,
  Ddi_Vararray_t * psNew,
  Ddi_Bdd_t * rPart,
  Ddi_Bdd_t * rPartB,
  Ddi_Vararray_t * assumeEqVars,
  Ddi_Bddarray_t * assumeEqSubst,
  int i,
  int seqK,
  int seqGroup,
  float seqSerial,
  int reverse
);
static Ddi_Varset_t *refineRelationalPartWithCex(
  Ddi_Bdd_t * checkPart,
  Ddi_Bdd_t * cex,
  Ddi_Varset_t * psOut,
  char *prefix,
  int cegar
);
static int igrAbstrRef(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * myConeAbstr,
  int start_j,
  int useEqRings,
  Ddi_Bdd_t *abstrCex,
  int enPrio,
  float timeLimit,
  int *cexUsedP
);
static Ddi_Bdd_t *
genRefiningTrConstr(
  Trav_ItpMgr_t * itpMgr,
  int start_j
);
static int igrAbstrRefByItp(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * myConeAbstr,
  int start_j,
  int useEqRings,
  Ddi_Bdd_t *abstrCex,
  int enPrio,
  float timeLimit,
  int *cexUsedP
);
static Ddi_Bdd_t *
itpPreimg(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *from,
  Ddi_Bdd_t *toPlus,
  int k,
  int fwd_j
);
static Ddi_Bdd_t *
itpPreimgOnFwdRings(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone,
  int k,
  int img_j,
  int fwd_j,
  int useToPlusAsCare,
  int *toPlusRefined);
static Ddi_Bdd_t *
itpPreimgK(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *from,
  Ddi_Bdd_t *toPlus,
  int k,
  int bwd_k
);
static int igrBwdRef(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone0,
  int bwdCone_j,
  int fwd_j,
  int start_j,
  int useEqRings,
  int doTrav,
  int *resP
);
static int
igrRefineRingsBwd(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone0,
  int bwdCone_k,
  int fwd_j,
  int start_j,
  int useEqRings,
  int doTrav,
  int *resP
);
static int
igrChkReachable(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone,
  int fwd_j,
  int start_j,
  int useEqRings,
  int psnsSubst
);
static Ddi_Bdd_t *growConeBwd0(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int boundK
);
static Ddi_Bdd_t *growConeBwd(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int andWithRing_i,
  int boundK
);
static Ddi_Bdd_t *
growConeBwdSubsetByTarget(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  Ddi_Bddarray_t *observedGates,
  int doSubsetByTarget,
  int useRingConstr,
  int andWithRing_i,
  int boundK
);
static Ddi_Bdd_t *
growConeBwdForRingCheck(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int andWithRing_i,
  int boundK
);
static Ddi_Bdd_t *growConeBwdDecomp(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  int split_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int andWithRing_i,
  int boundK
);
static Ddi_Bdd_t *growUnrollRelation(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Vararray_t * nsSupp,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int andWithRingForced_i,
  int boundK,
  int initMark
);
static void itpSimplifyRingsBwdFwd(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int maxIter,
  Ddi_Bddarray_t * delta,
  int maxFail,
  int useRingConstr,
  int *enItpP,
  int boundK
);
static void itpWeakenRingsBwd(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  int maxFail,
  int useRingConstr,
  int boundK
);
static int
itpStrengthenRingsByBmc(
  Trav_ItpMgr_t * itpMgr,
  int useTarget,
  int fwd_j,
  int kBound,
  int subsetBound,
  int maxSubsetIter
);
static void itpStrengthenRingsFwd(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  int maxFail,
  int useRingConstr,
  int *enItpP,
  int boundK,
  int useItp
);
static void itpStrengthenRingsBwd(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  int maxFail,
  int useRingConstr,
  int *enItpP,
  int boundK,
  int useItp
);
static void
itpStrengthenRingsBwdByBmc(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int end_i,
  int step_i,
  Ddi_Bddarray_t * delta,
  int maxK,
  int useRingConstr,
  int boundK,
  int useItp
);
static int
itpStrengthenReachedGfp(
  Trav_ItpTravMgr_t * itpTravMgr,
  int *lastRingP,
  int enUpdateFromRings,
  int enUpdateConstr,
  int useInvarConstr,
  int useGen
);
static int
itpCheckRingsFwd(
  Trav_ItpMgr_t * itpMgr,
  int i0,
  int i1,
  int checkFp
);
static int
itpCheckTr(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t *trA,
  Ddi_Bddarray_t *delta
);
static int
itpCheckConeAtRing(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *ring,
  Ddi_Bdd_t *cone, 
  int iRing,
  int k,
  int boundK
);
static int
itpStrengthenBwdRing(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *splitCone
);
static int
itpLookaheadRingsFwd(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t * kCone,
  int start_i,
  int step,
  int useRingConstr,
  int boundK
);
static Ddi_Bdd_t *coneJoinWithSubset(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  Ddi_Bddarray_t * unrollSplit,
  int subsetLevel
);
static Ddi_Bdd_t *splitAndSubsetCone(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  Ddi_Bddarray_t * delta,
  int start_i,
  int end_i,
  int split_i,
  int subsetLevel
);
static void itpMgrGenSplitCex(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cex,
  int start_i,
  int end_i
);
static Ddi_Bdd_t *
genComposedTr(
  Trav_ItpMgr_t * itpMgr,
  int nFrames,
  int timeShift,
  Ddi_Vararray_t *filterVars
);
static void
itpMgrApplyRingEq(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *f,
  Ddi_Bddarray_t *fA,
  Ddi_Vararray_t *suppVars,
  int i,
  int applyEqConstr
);
static void
itpTravMgrConstrainWithSplitCex(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * kConeRings,
  int step
);
static Ddi_Bdd_t *
findBwdRingConstr(
  Trav_ItpMgr_t * itpMgr,
  int andWithRing_i,
  int *andWithBwdRing_iP,
  int end_i,
  int start_i
);
static Ddi_Bdd_t *
timeFrameConstr(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * c0,
  int tf0,
  int tf1
);
static Ddi_Bdd_t *
timeFrameConstrWithEnablingVars(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t *cA,
  int tf0,
  int tf1,
  int end_i,
  Ddi_Bddarray_t * initStub,
  Ddi_Vararray_t *enVars
);
static Ddi_Bdd_t *growConeBwdSplit(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  int split_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int boundK,
  int assumeBound,
  Ddi_Bddarray_t * unrollSplit,
  Ddi_Vararray_t * varsSplit,
  Ddi_Bdd_t * careSplit,
  Ddi_Bdd_t * constrSplit,
  Ddi_Bdd_t * coneSplit,
  Ddi_Bdd_t *customConstr,
  Ddi_Bddarray_t *observedGates,
  int *andWithRingP,
  int useSplitUnrollConstr,
  int useForImage
);
static Ddi_Bdd_t *
coneNearestNeighbourConstr(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone
);
static Ddi_Bdd_t *growConeBwdRelational(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int boundK
);
static int chkConeBmc(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  Ddi_Bdd_t * from,
  Ddi_Bddarray_t * fromRings,
  Ddi_Bddarray_t * initStub,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  int useRingConstr,
  int boundK,
  int split
);
static void itpImgTrSetup(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * cone
);
static void
testCones(
  Trav_ItpMgr_t *itpMgr,
  Ddi_Bdd_t *cone,
  int maxk
);
static Ddi_Bdd_t *
itpImgConeSubsetTopAcc(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * cone,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t *coneCare,
  int step
);
static Ddi_Bddarray_t *
optTrConstr(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t *trConstrA0,
  int nFrames
);
static Ddi_Bddarray_t *
optTrConstrForBmcCone(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t *trConstrA,
  int nFrames,
  int doItp
);
static Ddi_Bddarray_t *
genTrConstrFromBmcCone(
  Trav_ItpMgr_t * itpMgr,
  int first,
  int last,
  int bmcBound
);
static Ddi_Bddarray_t *
genTrConstrFromItpRings(
  Trav_ItpMgr_t * itpMgr,
  int first,
  int last,
  int nFrames
);
static void
getConeWithTrAbstrItp(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone,
  Ddi_Bdd_t *from,
  int start_i,
  int end_i,
  int split_i,
  int boundk
);
static Ddi_Bdd_t *itpImgGetCone(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * kCone,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t *coneCare,
  int step,
  int phase,
  int doSplit,
  int doLookahead,
  int doSubset,
  int assumeSafeBound,
  int coneRelational
);
static Ddi_Bdd_t *
partitionByWitnessVars(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b
);
static Ddi_Bdd_t *
itpImgPartItpByDomainCubes (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  int invertAB,
  int itpReverse,
  int maxIter,
  Ddi_Varset_t *globalVars,
  Ddi_Vararray_t *domainA,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *itpPlus,
  Ddi_Bdd_t *toPlusCube,
  int *psat,
  int itpPart,
  int itpOdc,
  float timeLimit
);
static int
itpImgPartItpByDomainCubesFwdBwd (
  Ddi_Bdd_t *from,
  Ddi_Bdd_t *a0,
  Ddi_Bdd_t *a1,
  Ddi_Bdd_t *coneTop,
  Ddi_Bdd_t *coneMiddle,
  Ddi_Bdd_t *bwd0,
  Ddi_Bdd_t *bwd1,
  Ddi_Bdd_t *fwd0,
  Ddi_Bdd_t *fwd1,
  int maxIter,
  Ddi_Vararray_t *ps,
  Ddi_Vararray_t *ns,
  Ddi_Vararray_t *psAux,
  Ddi_Vararray_t *constrHintsVars,
  int noSplit,
  float timeLimit
);
static Ddi_Bdd_t *
itpImgPart (
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * kCone,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *prevTo,
  int step,
  int doSplit,
  Ddi_Varset_t *globalVars,
  Ddi_Varset_t *domainVars,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *itpPlus,
  Ddi_Bdd_t *toPlusCube,
  int *psat,
  int itpPart,
  int itpOdc,
  float timeLimit
);
static int itpImg(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * kCone,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t * kConeOld,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * careOut,
  int *pAbort,
  int optLevel,
  int maxIter
);
static int itpFilterFreeNsVars(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Vararray_t * coneSupp
);
static int
itpTrAbstrWithItp(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * cone
);
static int
itpTrAbstrWithItpRefineWithRings(
  Trav_ItpMgr_t * itpMgr,
  int first,
  int last
);
static Ddi_Bdd_t *itpTfSplitCex(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cex,
  int maxTf
);
static int itpOutOfLimits(
  Trav_ItpMgr_t * itpMgr
);
int
igrHintsUpdateRingsAndConstr(
  Trav_ItpMgr_t *itpMgr
);
static int igrTravIntern(
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * itpCone,
  Ddi_Bdd_t * itpCare,
  Ddi_Bdd_t * rOut,
  Ddi_Bdd_t * careOut,
  int bwdK,
  int recLevel,
  int *itpBmcBoundP,
  int *abortP,
  int *satP
);
static int
substStalledLatches(
  Trav_ItpMgr_t *itpMgr,
  Ddi_Bdd_t *f
);
static Ddi_Bdd_t *
subsByOrSelect(
  Ddi_Bdd_t *myTarget,
  Ddi_Bdd_t *cex,
  int minPart
);
static Ddi_Bddarray_t *
findOrTerms(
  Ddi_Bdd_t *f,
  int minNumTerms
);
static int proofHandlePhaseAbstr(
  Fsm_Fsm_t *fsmFsm,
  Ddi_Bdd_t *invar,
  int phAbstr
);
static int proofHandleInitStub(
  Fsm_Fsm_t *fsmFsmRef,
  Ddi_Bdd_t *target,
  int iSteps
);



/**AutomaticEnd***************************************************************/

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
TravTravTrAbstrLoad(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  int *nfp
)
{
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  char *trConstrLoad = travMgr->settings.aig.trAbstrItpLoad;
  int trConstrNumFrames;
  if (trConstrLoad==NULL) return NULL;
  Ddi_Bddarray_t *trConstrA;
  Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelUsrMed_c) {
    fprintf(dMgrO(ddm), "Reading TR abstraction from file %s\n",trConstrLoad);
  }

  trConstrA = Ddi_AigarrayNetLoadAiger(ddm,NULL,trConstrLoad);
  Pdtutil_Assert(trConstrA != NULL  ,"Unexpected NULL pointer");

  int nc = Ddi_BddarrayNum(trConstrA);

  char *s = strstr(trConstrLoad,".aig");
  Pdtutil_Assert (s!=NULL,"missing .aig extension");
  while (*s!='_') s--;
  sscanf(s, "_%d.aig", nfp);
  return (trConstrA);
}

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Trav_TravSatBckVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * care,
  int maxIter,
  int doApprox,
  int lemmasSteps
)
{
  Ddi_Vararray_t *pi, *ps, *ns; //, *newPi;
  Ddi_Varset_t *pivars, *over, *smooth, *psvars, *corevars; //, *newPiVars;
  Ddi_Bddarray_t *delta;        //, *newPiLit;
  Ddi_Bdd_t *reached, *from, *myInvarspec;
  int again, step = 0, i, fail = 0, cntR = 0;
  long startTime, currTime;
  int noCheck = 1 && doApprox, nPsVars;
  Ddi_Bddarray_t *lemmas = NULL;
  Ddi_Bdd_t *rPlus = NULL;      //, *subAig;

  //int keepPi = 1;
  Ddi_Bdd_t *myCare = NULL, *lemmasInvar = NULL;;
  int maxLemmas = 1;
  int doComposeExist = 0;
  int TravAigPartial = 0;
  int doNnfExist = 0;
  int doRelationalOpt = 0;

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);

  myInvarspec = Ddi_BddDup(invarspec);

  if (care != NULL) {
    myCare = Ddi_BddDup(care);
  } else {
    myCare = Ddi_BddMakeConstAig(ddm, 1);
  }

  if (travMgr->settings.aig.targetEn > 0) {
    int nIter = travMgr->settings.aig.targetEn;

    travMgr->settings.aig.targetEn = 0;
#if 0
    Ddi_Bdd_t *r = Trav_TravSatBckAllSolVerif(travMgr, fsmMgr,
      init, myInvarspec, invar, travMgr->settings.aig.targetEn);
#else
    Ddi_Bdd_t *r = Trav_TravSatBckVerif(travMgr, fsmMgr,
      init, myInvarspec, invar, NULL, nIter, 0, 0);
#endif
    Ddi_Free(myInvarspec);
    Ddi_BddNotAcc(r);
    myInvarspec = r;
  }


  if (lemmasSteps > 0) {
    int result = 0;

#if 1
    lemmas = genLemmaClasses(travMgr, fsmMgr,
      init, NULL, invar, myInvarspec, myCare, NULL, lemmasSteps,
      1, 0, 0, &result, 0, NULL);
    if (0) {
      int nRed;

      do {
        nRed = Fsm_RetimePeriferalLatches(fsmMgr);
      } while (nRed > 0);
    }
#else
    lemmas = genLemmaClasses(travMgr, fsmMgr, init, NULL, invar, myInvarspec,
      myCare, NULL, lemmasSteps > 2 ? 2 : lemmasSteps, 1, 0, 0, &result, 0,
      NULL);
    Ddi_Free(lemmas);
    if (!result) {
      lemmas = genLemmaClasses(travMgr, fsmMgr, init, NULL, invar,
        myInvarspec, myCare, NULL, lemmasSteps - 1, 1, 1, 0, &result, 0, NULL);
    }
    //exit(32);
#endif

    if (lemmas != NULL) {
      lemmasInvar = Ddi_BddMakeConstAig(ddm, 1);
      for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
        Ddi_BddAndAcc(lemmasInvar, Ddi_BddarrayRead(lemmas, i));
      }
    }
    Ddi_Free(lemmas);

    if (0) {
      Ddi_Vararray_t *pi, *ps, *ns;
      Ddi_Bdd_t *s0;
      Ddi_Bddarray_t *delta, *lambda;

      pi = Fsm_MgrReadVarI(fsmMgr);
      ps = Fsm_MgrReadVarPS(fsmMgr);
      ns = Fsm_MgrReadVarNS(fsmMgr);
      s0 = Fsm_MgrReadInitBDD(fsmMgr);
      delta = Fsm_MgrReadDeltaBDD(fsmMgr);
      lambda = Fsm_MgrReadLambdaBDD(fsmMgr);

      Ddi_AigFsmStore(pi, ps, ns, s0, delta, lambda,
        (char *)"xxx.blif", NULL, Pdtutil_Aig2Blif_c);
    }
  }

  ns = Fsm_MgrReadVarNS(fsmMgr);
  ps = Fsm_MgrReadVarPS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  nPsVars = Ddi_VararrayNum(ps);

  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c,
    fprintf(tMgrO(travMgr),
      "\nAIG Backward Verification (%d PIs, %d Latches).\n",
      Ddi_VararrayNum(pi), Ddi_VararrayNum(ps))
    );

  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  pivars = Ddi_VarsetMakeFromArray(pi);
  psvars = Ddi_VarsetMakeFromArray(ps);
  over = Ddi_VarsetDup(pivars);

  // DdiAigarrayExistNnfAcc (delta,NULL,psvars, ps, ns);

  for (i = 0; i < Ddi_VararrayNum(ps); i++) {
    Ddi_VarsetAddAcc(over, Ddi_VararrayRead(ps, i));
  }
#if 0
  for (i = 0; i < Ddi_VararrayNum(ps); i++) {
    Ddi_BddSetMono(Ddi_BddarrayRead(delta, i));
    Ddi_BddSetAig(Ddi_BddarrayRead(delta, i));
  }
#endif
#if 0
  for (i = 0; i < Ddi_VararrayNum(ps); i++) {
    Ddi_AigOptByBdd(Ddi_BddarrayRead(delta, i), -1.0);
  }
#endif


  smooth = pivars;

  //  for (i=0; i<Ddi_VararrayNum(ps); i++) {
  //  Ddi_BddExistAcc(Ddi_BddarrayRead(delta,i),smooth);
  // }

  if (travMgr->settings.clk != NULL) {
    Ddi_Varset_t *ck =
      Ddi_VarsetMakeFromVar(Ddi_VarFromName(ddm, travMgr->settings.clk));
    Ddi_VarsetDiffAcc(psvars, ck);
    Ddi_Free(ck);
  }

  from = Ddi_BddNot(myInvarspec);
  /* Ddi_BddSetMono(from); */
  Ddi_BddExistAcc(from, pivars);
  reached = Ddi_BddDup(from);

  startTime = util_cpu_time();

  if (0 && care != NULL) {
    for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
      DdiAigRedRemovalAcc(Ddi_BddarrayRead(delta, i), myCare, -1, -1.0);
    }
  }
  //  DdiAigArrayRedRemovalAcc (delta,myCare,-1,-1.0);


  int doRangeOpt = 1;
  Ddi_Bdd_t *careRange=NULL;
  if (doRangeOpt) {
    Ddi_Vararray_t *newPiVars =
      Ddi_VararrayMakeNewVars(pi, "PDT_RANGE_PI",
                              NULL, 1);
    Ddi_Vararray_t *newPsVars =
      Ddi_VararrayMakeNewVars(ps, "PDT_RANGE_PS",
                              NULL, 1);
    Ddi_Bddarray_t *delta2 = Ddi_BddarrayDup(delta);
    Ddi_BddarraySubstVarsAcc(delta2, pi, newPiVars);
    Ddi_BddarraySubstVarsAcc(delta2, ps, newPsVars);
    careRange = Ddi_BddRelMakeFromArray(delta2, ps);
    Ddi_BddSetAig(careRange);
    Ddi_Free(delta2);
    Ddi_Free(newPiVars);
    Ddi_Free(newPsVars);
  }

  do {
    int sizeAig;
    Ddi_Bdd_t *checkInit;
    Ddi_Bdd_t *fromAig, *over;
    Ddi_Bdd_t *careAig;         //, *plus;

    checkInit = Ddi_BddAnd(from, init);
    if ((!noCheck) && (Ddi_AigSat(checkInit) == 1)) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "Verification Result: FAIL.\n")
        );
      fail = 1;
      Ddi_Free(checkInit);
      Ddi_Free(from);
      break;
    }
    Ddi_Free(checkInit);

    if (maxIter > 0 && step >= maxIter) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr),
          "Maximum Iteration Reached on Backward Verification.\n")
        );
      Ddi_Free(from);
      break;
    }

    if (1 || Ddi_BddSize(from) < 10000) {
      fromAig = Ddi_BddDup(from);
    } else {
      fromAig = Ddi_AigSuperset(from, (90 * Ddi_BddSize(from)) / 100, 1);
    }

    careAig = Ddi_BddNot(reached);
    if (myCare != NULL) {
      Ddi_BddAndAcc(careAig, myCare);
    }

    Ddi_Free(from);

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "\nAIG Traversal Iteration %d.\n", step)
      );


    if (lemmasSteps > 0 && (Ddi_BddSize(reached) > 100) && --maxLemmas > 0) {
      int result = 0;

      lemmas = genLemmaClasses(travMgr, fsmMgr,
        init, NULL, invar, myInvarspec, myCare, NULL, lemmasSteps,
        1, 0, 0, &result, 0, NULL);
      if (lemmas != NULL) {
        if (lemmasInvar == NULL)
          lemmasInvar = Ddi_BddMakeConstAig(ddm, 1);
        for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
          Ddi_BddAndAcc(lemmasInvar, Ddi_BddarrayRead(lemmas, i));
        }
      }

      Ddi_Free(lemmas);
    }

    if (0) {
      Ddi_Varset_t *suppd = Ddi_BddSupp(fromAig);
      Ddi_Bddarray_t *d2 = Ddi_BddarrayAlloc(ddm, 0);
      int k;

      for (i = 0; i < Ddi_VararrayNum(ps); i++) {
        if (Ddi_VarInVarset(suppd, Ddi_VararrayRead(ps, i))) {
          Ddi_BddarrayInsertLast(d2, Ddi_BddarrayRead(delta, i));
        }
      }
      if (Ddi_BddarrayNum(d2) > 0) {
        Ddi_AigArrayExistPartialAcc(d2, pivars, careAig);
      }
      for (i = 0, k = 0; i < Ddi_VararrayNum(ps); i++) {
        if (Ddi_VarInVarset(suppd, Ddi_VararrayRead(ps, i))) {
          Ddi_BddarrayWrite(delta, i, Ddi_BddarrayRead(d2, k++));
        }
      }
      Pdtutil_Assert(k == Ddi_BddarrayNum(d2), "Wrong K in d2");
      Ddi_Free(suppd);
      Ddi_Free(d2);
    }
    if (0 && Ddi_BddSize(reached) > 5000) {
      Ddi_Varset_t *suppd = Ddi_BddSupp(fromAig);

      for (i = 0; i < Ddi_VararrayNum(ps); i++) {
        if (Ddi_VarInVarset(suppd, Ddi_VararrayRead(ps, i))) {
          DdiAigRedRemovalAcc(Ddi_BddarrayRead(delta, i), careAig, -1, -1.0);
        }
      }
      Ddi_Free(suppd);
    }
    sizeAig = Ddi_BddarraySize(delta);
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "Aig trav iteration %d (|delta|=%d.\n", step,
        sizeAig)
      );

    corevars = Ddi_BddSupp(fromAig);

#if 0
    {
      /* NXR added */
      Ddi_Bdd_t *subAig;

      //Ddi_AigPrintStats(fromAig);
      Ddi_AigPrintNodeStats(fromAig, Ddi_VararrayNum(ps));
      //subAig = Ddi_AigSubset(fromAig, (85*Ddi_BddSize(fromAig))/100, 1);
      subAig = Ddi_AigSubsetNode(fromAig, Ddi_VararrayNum(ps), 1);

      if (0 && Ddi_BddSize(subAig) > 5) {
        Ddi_Free(fromAig);
        fromAig = subAig;
      } else {
        Ddi_Free(subAig);
      }
    }
#endif

    sizeAig = Ddi_BddSize(fromAig);

    if (careRange!=NULL) {
#if 0
      Ddi_Bdd_t *save = careAig;
      careAig = Ddi_BddDup(careRange);
      Ddi_BddPartInsertLast(careAig,save);
      Ddi_Free(save); 
#endif
      Ddi_BddAndAcc(careAig,careRange);
    }
    if (doRelationalOpt && step>0) {
      Ddi_Vararray_t *newPiVars =
            Ddi_VararrayMakeNewVars(pi, "PDT_REL_PI",
            NULL, 1);
      Ddi_Bdd_t *from2 = Ddi_BddDup(fromAig);
      Ddi_Bddarray_t *delta2 = Ddi_BddarrayDup(delta);
      Ddi_Bddarray_t *psLits = Ddi_BddarrayMakeLiteralsAig(ps, 1);
      Ddi_BddComposeAcc(from2, ps, delta);
      Ddi_BddSubstVarsAcc(from2, pi, newPiVars);
      for (i=0; i<Ddi_BddarrayNum(delta); i++) {
	Ddi_Bdd_t *l_i = Ddi_BddarrayRead(psLits,i);
	Ddi_Bdd_t *d_i = Ddi_BddarrayRead(delta2,i);
	Ddi_BddDiffAcc(d_i,from2);
	Ddi_BddDiffAcc(l_i,from2);
      }
      Ddi_AigarrayNetStoreAiger(delta, 0, "itp-delta.aig");
      Ddi_BddarrayComposeAcc(delta, ps, psLits);
      Ddi_AigNetStoreAiger(fromAig, 0, "itp-from.aig");
      Ddi_AigarrayNetStoreAiger(delta, 0, "itp-delta1.aig");
      Ddi_AigarrayNetStoreAiger(delta2, 0, "itp-delta2.aig");
      Ddi_Free(from2);
      Ddi_Free(newPiVars);
      Ddi_Free(psLits);
      Ddi_Free(delta2);
    }
    if (!doComposeExist) {
      Ddi_BddComposeAcc(fromAig, ps, delta);
      sizeAig = Ddi_BddSize(fromAig);
      if (0 && lemmasInvar != NULL) {
        Ddi_BddAndAcc(fromAig, lemmasInvar);
      }
    }
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "Aig trav iteration %d (|fromAig|=%d.\n", step++,
        sizeAig)
      );

    /* Ddi_BddSetMono(fromAig); */

    if (0 && Ddi_BddSize(fromAig) > 3000) {
      Ddi_Bdd_t *tmp1 = Ddi_BddDup(fromAig);    //, *over2;

      over = Ddi_BddDup(fromAig);
#if 1
      if (travMgr->settings.clk != NULL) {
        Ddi_Varset_t *ck =
          Ddi_VarsetMakeFromVar(Ddi_VarFromName(ddm, travMgr->settings.clk));
        Ddi_BddExistAcc(over, ck);
        Ddi_Free(ck);
      }

      DdiAigExistOverAcc(over, smooth, careAig);
      //       DdiAigExistOverPartialAcc (over,smooth,careAig,Ddi_BddSize(over)/2);
      //       Ddi_AigExistAcc (over,smooth,careAig,0,0);

      DdiAigRedRemovalAcc(over, careAig, -1, -1.0);
      Ddi_BddAndAcc(careAig, over);
#if 0
      DdiAigRedRemovalAcc(fromAig, careAig, -1, -1.0);
      //      Ddi_AigExistAcc (fromAig,pivars,careAig,1,1);
      over2 = Ddi_BddDup(fromAig);
      Ddi_AigExistAcc(over2, pivars, careAig, 1, 1, -1.0);
      Ddi_AigExistAcc(over2, pivars, careAig, 0, 0, -1.0);
#if 1
      {
        Ddi_Varset_t *supp = Ddi_BddSupp(over2);
        Ddi_Var_t *topV;

        Ddi_VarsetIntersectAcc(supp, pivars);
        topV = Ddi_VarsetTop(supp);
        Ddi_Free(supp);
        if (topV != NULL) {
          supp = Ddi_VarsetMakeFromVar(topV);
          DdiAigExistOverAcc(over2, supp, careAig);
          Ddi_Free(supp);
          Ddi_AigExistAcc(over2, pivars, careAig, 0, 0, -1.0);
          Ddi_BddAndAcc(careAig, over2);
          Ddi_BddAndAcc(over, over2);
        }
      }
#else
      Ddi_BddAndAcc(careAig, over2);
      Ddi_BddAndAcc(over, over2);
#endif
      Ddi_Free(over2);
#endif
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "approx: %d.\n", Ddi_BddSize(over))
        );
#else
      {
        Ddi_Varset_t *supp = Ddi_BddSupp(over);
        Ddi_Bddarray_t *d2 = Ddi_BddarrayAlloc(ddm, 0);
        int k, i;

        for (i = k = 0; i < Ddi_VararrayNum(ps); i++) {
          if (Ddi_VarInVarset(supp, Ddi_VararrayRead(ps, i))) {
            Ddi_Varset_t *sm = Ddi_VarsetMakeFromVar(Ddi_VararrayRead(ps, i));

            DdiAigExistOverAcc(over, sm, careAig);
            Ddi_Free(sm);
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "approx[%d]: %d.\n", k++,
                Ddi_BddSize(over))
              );
          }
        }
        Ddi_Free(supp);
      }
#endif

#if 0
      Ddi_BddSetMono(over);
      Ddi_BddSetMono(tmp1);
      Ddi_BddExistAcc(tmp1, pivars);
      Pdtutil_Assert(Ddi_BddIncluded(tmp1, over),
        "Wrong result of AIG OVER EX.");
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "approx factor = %g.\n",
          Ddi_BddCountMinterm(tmp, Ddi_VararrayNum(ps)) /
          Ddi_BddCountMinterm(tmp1, Ddi_VararrayNum(ps)))
        );
#endif
      Ddi_Free(tmp1);
    } else {
      over = Ddi_BddMakeConstAig(ddm, 1);
    }
    if (doApprox && (!Ddi_BddIsOne(over)) /*&& Ddi_BddSize(over) > 50 */ ) {
      Ddi_Free(fromAig);
      fromAig = Ddi_BddDup(over);
    } else {
      Ddi_Bdd_t *careOne = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_Bdd_t *myOver = NULL;
      Ddi_Varset_t *outOfCore = Ddi_VarsetDiff(psvars, corevars);

      //      Ddi_BddAndAcc(careAig,over);
      //DdiAigRedRemovalAcc (fromAig,careAig,-1);
      //      Ddi_AigExistAcc(fromAig,pivars,careAig,1,TravAigPartial*2);

#if 0
      myOver = Ddi_BddDup(fromAig);
      Ddi_AigExistAcc(myOver, smooth, careAig, 1, 0, -1.0);
      Ddi_AigExistAcc(myOver, outOfCore, careAig, 1, 2, -1.0);
      Ddi_AigExistAcc(myOver, smooth, careAig, 0, 0, -1.0);
      Ddi_BddAndAcc(careAig, myOver);
      DdiAigRedRemovalAcc(fromAig, careAig, -1, -1.0);

      if (Ddi_BddSize(myOver) > 1) {
        Ddi_Free(fromAig);
        fromAig = Ddi_BddDup(myOver);
      } else
#endif
#if 1
      {
#if 1
	if (doNnfExist) {
	  //	  Ddi_BddAndAcc(fromAig,careAig);
          DdiAigExistNnfAcc(fromAig, smooth, NULL);
	}
        else if (doComposeExist) {
          Ddi_Bddarray_t *nsLits = Ddi_BddarrayMakeLiteralsAig(ns, 1);

          Ddi_BddComposeAcc(fromAig, ps, nsLits);
          Ddi_AigComposeExistAcc(fromAig, ns, delta,
            smooth, 5, careAig, 0, TravAigPartial * 2, -1.0);
          Ddi_Free(nsLits);
        } else if (Ddi_VarsetNum(smooth) > 0) {
          Ddi_AigExistAcc(fromAig, smooth, careAig, 0, TravAigPartial * 2,
            -1.0);
        }
        //        Ddi_AigOptByBdd(fromAig,-1.0);
#else
        Ddi_BddSetMono(fromAig);
        Ddi_BddExistAcc(fromAig, smooth);
        Ddi_BddSetAig(fromAig);
#endif
        DdiAigRedRemovalAcc(fromAig, careAig, 300, -1.0);
        if (myOver != NULL) {
          Ddi_BddAndAcc(fromAig, myOver);
        }
      }
#else
      {
        Ddi_Bdd_t *to, *auxUnreach, *auxFrom = Ddi_BddDup(fromAig);
        Ddi_Varset_t *vars = Ddi_BddSupp(auxFrom);
        int sat;

        Ddi_AigExistAcc(fromAig, smooth, careAig, 0, TravAigPartial * 2, -1.0);
        DdiAigRedRemovalAcc(fromAig, careAig, -1, -1.0);

        Ddi_VarsetDiffAcc(vars, smooth);
        auxUnreach = Ddi_BddNot(fromAig);
        if (careAig != NULL) {
          Ddi_BddAndAcc(auxUnreach, careAig);
        }
        to = Ddi_AigSatAndWithInterpolant(auxFrom, auxUnreach, vars,
          NULL, NULL, 0, 0, &sat);
        Pdtutil_Assert(!sat, "interpolant on SAT instance!");
        Ddi_Free(vars);
        if (Ddi_BddSize(to) < Ddi_BddSize(fromAig)) {
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "Int[%d->%d].\n", Ddi_BddSize(fromAig),
              Ddi_BddSize(to))
            );
          Ddi_Free(fromAig);
          fromAig = to;
        } else {
          Ddi_Free(to);
        }
        Ddi_Free(auxFrom);
        Ddi_Free(auxUnreach);
        Ddi_Free(vars);

        if (myOver != NULL) {
          Ddi_BddAndAcc(fromAig, myOver);
        }
      }
#endif

      Ddi_BddAndAcc(fromAig, over);
      Ddi_Free(myOver);
      Ddi_Free(outOfCore);
      Ddi_Free(careOne);
    }

    if (0) {
      Ddi_Bddarray_t *benchArray;
      char filename[100];

      sprintf(filename, "image%02d.bench", step);
      benchArray = Ddi_BddarrayAlloc(ddm, 0);
      Ddi_BddarrayInsertLast(benchArray, fromAig);
      Ddi_BddarrayInsertLast(benchArray, careAig);
      Ddi_AigarrayNetStore(benchArray, filename, NULL,
        Pdtutil_Aig2BenchLocalId_c);
      Ddi_Free(benchArray);
    }

    Ddi_Free(careAig);
    Ddi_Free(over);
#if 0
    from = Ddi_BddMakeMono(fromAig);
#else
    from = Ddi_BddDup(fromAig);
#endif

    Ddi_BddDiffAcc(from, reached);

#if 0
    again = !Ddi_BddIsZero(from);
#else
    again = Ddi_AigSat(from) == 1;
#endif
#if 1
    Ddi_Free(from);
    from = fromAig;
#if 0
    Ddi_BddNotAcc(from);
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "# RED-R: ")
      );
    DdiAigRedRemovalAcc(reached, from, -1, -1.0);
    Ddi_BddNotAcc(from);
#endif
#endif

    if (0) {
      Ddi_Bddarray_t *benchArray;
      char filename[100];

      sprintf(filename, "reached%02d.bench", step);
      benchArray = Ddi_BddarrayAlloc(ddm, 0);
      Ddi_BddarrayInsertLast(benchArray, reached);
      Ddi_BddNotAcc(from);
      Ddi_BddarrayInsertLast(benchArray, from);
      Ddi_BddNotAcc(from);
      Ddi_AigarrayNetStore(benchArray, filename, NULL,
        Pdtutil_Aig2BenchLocalId_c);
      Ddi_Free(benchArray);
    }

    Ddi_BddOrAcc(reached, from);

    if (cntR) {
      Ddi_Bdd_t *r = Ddi_BddMakeMono(reached);

      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "# Reached states = %g.\n",
          Ddi_BddCountMinterm(r, Ddi_VararrayNum(ps)))
        );
      Ddi_Free(r);
    } else {
      Ddi_Varset_t *rSupp = Ddi_BddSupp(reached);

      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "#Reached Supp Variables = %d/%d.\n",
          Ddi_VarsetNum(rSupp), nPsVars)
        );
      Ddi_Free(rSupp);
    }
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "#Reached States = %g; |Reached| = %d.\n",
        Ddi_BddCountMinterm(reached, Ddi_VararrayNum(ps)),
        Ddi_BddSize(reached));
      currTime = util_cpu_time();
      fprintf(tMgrO(travMgr),
        "merge/checks: [1]%d/%d + [2]%d/%d(%d/%d)[diff: %d,%d] - Time: %s.\n",
        ddm->stats.aig.n_merge_1, ddm->stats.aig.n_check_1,
        ddm->stats.aig.n_merge_2, ddm->stats.aig.n_check_2,
        ddm->stats.aig.n_merge_3, ddm->stats.aig.n_check_3,
        ddm->stats.aig.n_diff, ddm->stats.aig.n_diff_1,
        util_print_time(currTime - startTime))
      );

    Ddi_Free(corevars);

  } while (again);

  Ddi_BddNotAcc(reached);
  if (Ddi_AigSat(reached) != 1) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "REACHED=1.\n")
      );
  }
  Ddi_BddNotAcc(reached);

  if (!fail) {
    if (maxIter == 0 || step < maxIter) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "Verification Result: PASS.\n")
        );
    }
  }
  Trav_MgrSetAssertFlag(travMgr, fail);

  Ddi_Free(careRange);
  Ddi_Free(lemmasInvar);
  Ddi_Free(myCare);
  Ddi_Free(myInvarspec);
  Ddi_Free(from);
  Ddi_Free(over);
  Ddi_Free(pivars);
  Ddi_Free(psvars);
  Ddi_Free(rPlus);

  return (reached);

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatFwdVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * care,
  int noCheck,
  int initBound,
  int lemmaSteps,
  int lemmaSimulDepth,
  int lemmaMaxLevel
)
{
  Ddi_Varset_t *smooth;
  Ddi_Varset_t *totPiVars;
  Ddi_Bddarray_t *delta;
  Ddi_Bdd_t *reached, *from, *bad, *to,
    *kCone, *kConeAbstr, *myInit, *myInvarspec;
  Ddi_Bdd_t *kConeLastLevel = NULL;
  int again, i, j;
  long startTime;               //, currTime;
  int cntR = 0, sat, k;
  int activeIterOffset;
  int retVal = 0, verificationDone = 0;
  Ddi_Bdd_t *myCare = NULL;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Bddarray_t *lemmas = NULL;
  Ddi_Bddarray_t *trArray;

  int dynAbstr = Trav_MgrReadDynAbstr(travMgr);
  int abstrRef = Trav_MgrReadAbstrRef(travMgr);
  int abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  int redRem = Ddi_MgrReadAigRedRemLevel(ddm);
  int abcOpt = Ddi_MgrReadAigAbcOptLevel(ddm);
  int useAbstrTr = 1;
  int coneOpt = 0;

  Ddi_Bdd_t *saveFrom;
  Trav_ItpMgr_t *itpMgr;

  if (care == NULL) {
    myCare = Ddi_BddMakeConstAig(ddm, 1);
  } else {
    myCare = Ddi_BddDup(care);
  }

  if (lemmaSteps > 0) {
    int result = 0;
    Ddi_Bddarray_t *repr, *eqts, *tmp;
    Ddi_Bdd_t *rp;

    repr = Ddi_BddarrayAlloc(ddm, 0);
    eqts = Ddi_BddarrayAlloc(ddm, 0);
    lemmas =
      genLemmaClasses(travMgr, fsmMgr, init, NULL, invar, invarspec, myCare,
      NULL, lemmaSteps, 1, 0, 0, &result, 0, NULL);
    Ddi_Free(repr);
    Ddi_Free(eqts);
#if 0
    tmp =
      lemmaApproxTrav(travMgr, fsmMgr, init, NULL, invar, lemmaSteps, 0, 1200);
    rp = Ddi_BddMakePartDisjFromArray(tmp);
    Ddi_BddSetAig(rp);
    Ddi_BddNotAcc(invarspec);
    if (Ddi_AigSatAnd(invarspec, rp, NULL)) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "Property not Proved. |Rsize|=%d.\n",
          Ddi_BddSize(rp))
        );
    } else {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "Property OK; |Rsize|=%d.\n", Ddi_BddSize(rp))
        );
    }
    Ddi_Free(rp);
    Ddi_Free(tmp);
    exit(10);
#endif
    if (0) {
      Ddi_Vararray_t *pi, *ps, *ns;
      Ddi_Bdd_t *s0;
      Ddi_Bddarray_t *delta, *lambda;

      pi = Fsm_MgrReadVarI(fsmMgr);
      ps = Fsm_MgrReadVarPS(fsmMgr);
      ns = Fsm_MgrReadVarNS(fsmMgr);
      s0 = Fsm_MgrReadInitBDD(fsmMgr);
      delta = Fsm_MgrReadDeltaBDD(fsmMgr);
      lambda = Fsm_MgrReadLambdaBDD(fsmMgr);

      Ddi_AigFsmStore(pi, ps, ns, s0, delta, lambda,
        (char *)"xxx.blif", NULL, Pdtutil_Aig2Blif_c);
    }

  }

  itpMgr = Trav_ItpMgrInit(travMgr, fsmMgr, NULL, NULL, 0, 1);

  smooth = Ddi_VarsetMakeFromArray(itpMgr->ps);
  Ddi_VarsetUnionAcc(smooth, itpMgr->pivars);
  totPiVars = Ddi_VarsetMakeFromArray(itpMgr->pi);

  Ddi_MgrSetOption(ddm, Pdt_DdiLazyRate_c, fnum, 1.1);
  myInvarspec = Ddi_BddDup(invarspec);

  if (travMgr->settings.aig.targetEn > 0) {
    Ddi_Bdd_t *r = Trav_TravSatBckAllSolVerif(travMgr, fsmMgr,
      init, invarspec, invar, travMgr->settings.aig.targetEn);

    Ddi_Free(myInvarspec);
    Ddi_BddNotAcc(r);
    myInvarspec = r;
  }


  bad = Ddi_BddNot(myInvarspec);
  Ddi_Free(myInvarspec);

  Ddi_BddComposeAcc(bad, itpMgr->ps, itpMgr->nsLit);
  kCone = Ddi_BddDup(bad);
  kConeAbstr = Ddi_BddDup(bad);
  myInit = Ddi_BddCompose(init, itpMgr->ps, itpMgr->nsLit);

  startTime = util_cpu_time();

  activeIterOffset = 0;

  if (lemmas != NULL) {
    Ddi_Bdd_t *myCheck;

    for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
      Ddi_BddAndAcc(myCare, Ddi_BddarrayRead(lemmas, i));
      Ddi_BddAndAcc(itpMgr->tr, Ddi_BddarrayRead(lemmas, i));
    }
    Ddi_Free(lemmas);
    myCheck = Ddi_BddAnd(myCare, bad);
    if (Ddi_AigSat(myCheck) != 1) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "Verification Result: PASS (lemmas).\n")
        );
      verificationDone = 1;
      retVal = 1;
    }
    Ddi_Free(myCheck);
  }

  for (k = 0; !verificationDone; k++) {

    Ddi_Bddarray_t *delta_i;
    Ddi_Bddarray_t *newPiLit;
    Ddi_Bdd_t *checkBad, *kConeOver = NULL;
    int abort = 0, step = 0;

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr),
        "AIG Interpolant Main Iteration: %d (o:%d|%d|).\n", k,
        activeIterOffset, Ddi_BddSize(kCone)););

    checkBad = Ddi_BddAnd(myInit, kCone);
    if ((!noCheck) && (Ddi_AigSat(checkBad) == 1)) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "Verification Result: FAIL.\n")
        );
      Ddi_Free(checkBad);
      break;
    }
    Ddi_Free(checkBad);

    if (initBound >= 0 && k < initBound || activeIterOffset > 0) {
      abort = 1;
      if (activeIterOffset) {
        activeIterOffset--;
      }
    } else {

      Ddi_Bdd_t *trAux = NULL;

      if (abcOpt > 0) {
        ddiAbcOptAcc(kCone, -1.0);
      }

      if (abstrRef) {

        Ddi_Varset_t *abstrVars = NULL;
        int size0 = Ddi_BddSize(kCone), nAbstr = 0;
        Ddi_Bddarray_t *abstrRefTmpConst =
          Ddi_BddarrayDup(itpMgr->abstrDoRefine);
        /* abstraction refinement */
        Ddi_Bdd_t *c0 = Ddi_BddMakeConstAig(ddm, 0);

        checkBad = Ddi_BddAnd(myInit, kConeAbstr);
#if 1
        abstrVars = Ddi_AigAbstrVarsIncremental(checkBad,
          itpMgr->abstrRefCtrl);
        for (j = 0; j < Ddi_VararrayNum(itpMgr->ns); j++) {
          if (Ddi_BddIsOne(Ddi_BddarrayRead(itpMgr->abstrDoAbstr, j))) {
            Ddi_Var_t *ctrl = Ddi_VararrayRead(itpMgr->abstrRefCtrl, j);

            if (Ddi_VarInVarset(abstrVars, ctrl)) {
              nAbstr++;
              Ddi_BddNotAcc(Ddi_BddarrayRead(abstrRefTmpConst, j));
            } else {
              /* invalid abstraction */
              Ddi_BddNotAcc(Ddi_BddarrayRead(itpMgr->abstrDoAbstr, j));
              Ddi_BddarrayWrite(itpMgr->abstrRefFilter, j, c0);
            }
          }
        }
        Ddi_Free(abstrVars);
#else
        for (j = 0; j < Ddi_VararrayNum(ns); j++) {
          if (Ddi_BddIsOne(Ddi_BddarrayRead(abstrDoAbstr, j))) {
            Ddi_Bdd_t *myCheck = NULL;

            Ddi_BddNotAcc(Ddi_BddarrayRead(abstrRefTmpConst, j));
            Pdtutil_Assert(Ddi_BddIsOne(Ddi_BddarrayRead(abstrRefTmpConst, j)),
              "1 required");
            myCheck = Ddi_BddCompose(checkBad, abstrRefCtrl, abstrRefTmpConst);
            if (Ddi_AigSat(myCheck) == 1) {
              /* invalid abstraction */
              Ddi_BddNotAcc(Ddi_BddarrayRead(abstrRefTmpConst, j));
              Ddi_BddNotAcc(Ddi_BddarrayRead(abstrDoAbstr, j));
              Ddi_BddarrayWrite(abstrRefFilter, j, c0);
            } else {
              nAbstr++;
            }
            Ddi_Free(myCheck);
          }
        }
#endif
        Ddi_Free(kCone);
        Ddi_Free(c0);
        kCone = Ddi_BddCompose(kConeAbstr,
          itpMgr->abstrRefCtrl, itpMgr->abstrDoAbstr);
        //  Ddi_BddComposeAcc(trAbstr,abstrRefCtrl,abstrRefFilter);
        Ddi_Free(abstrRefTmpConst);
        Ddi_Free(checkBad);

        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "Cone Abstract: %d -> %d(na:%d).\n",
            size0, Ddi_BddSize(kCone), nAbstr)
          );
      }

      /* INTERPOLANT INNER LOOP */

      activeIterOffset = interpolantInnerLoop(travMgr,
        kCone, NULL, NULL, myInit, myCare, NULL, NULL, NULL, NULL,
        itpMgr, &abort, -1, 0, 0, ~0);

      /* END INTERPOLANT INNER LOOP */

    }

    if (abort) {

      Ddi_Bdd_t *kConeOld = NULL;
      Ddi_Varset_t *newPiVars = Ddi_VarsetVoid(ddm);
      int j;

      Ddi_VararrayAppend(itpMgr->shiftPiVars, itpMgr->saveNewPiVars);

      newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(itpMgr->pi));
      for (j = 0; j < Ddi_VararrayNum(itpMgr->pi); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->pi, j);
        Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), k);
        Ddi_VarAttachName(newv, name);
        Ddi_VarsetAddAcc(totPiVars, newv);
        Ddi_VarsetAddAcc(smooth, newv);
        Ddi_VarsetAddAcc(newPiVars, newv);
        Ddi_VararrayWrite(itpMgr->saveNewPiVars, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newPiLit, j, newvLit);
        Ddi_Free(newvLit);
      }

      Ddi_BddarrayAppend(itpMgr->shiftPiLits, newPiLit);

      delta_i = Ddi_BddarrayDup(itpMgr->delta);
      for (j = 0; j < Ddi_BddarrayNum(delta_i); j++) {
        Ddi_BddComposeAcc(Ddi_BddarrayRead(delta_i, j), itpMgr->pi, newPiLit);
      }

      if (kConeLastLevel == NULL) {
        kConeLastLevel = Ddi_BddDup(kCone);
      }

      if (abstrRef) {
        kConeOld = Ddi_BddCompose(kConeAbstr,
          itpMgr->shiftPiVars, itpMgr->shiftPiLits);
        Ddi_Free(kConeAbstr);
        kConeAbstr = Ddi_BddCompose(kConeLastLevel, itpMgr->ns, delta_i);
      } else {
        kConeOld = Ddi_BddCompose(kCone,
          itpMgr->shiftPiVars, itpMgr->shiftPiLits);
        Ddi_Free(kCone);
        kCone = Ddi_BddCompose(kConeLastLevel, itpMgr->ns, delta_i);
      }

      Ddi_Free(delta_i);
      if (myCare != NULL) {
        Ddi_Bdd_t *c = Ddi_BddCompose(myCare, itpMgr->pi, newPiLit);

        if (abstrRef) {
          Ddi_BddAndAcc(kConeAbstr, c);
        } else {
          Ddi_BddAndAcc(kCone, c);
        }
        Ddi_Free(c);
      }


      Ddi_Free(newPiLit);
      if (abstrRef) {
        Ddi_BddComposeAcc(kConeAbstr, itpMgr->ps, itpMgr->nsLit);
      } else {
        Ddi_BddComposeAcc(kCone, itpMgr->ps, itpMgr->nsLit);
      }

      //      Ddi_AigExistAcc (kCone,totPiVars,NULL,2,0);


      //      DdiAigRedRemovalAcc (kCone,NULL,-1);
      //      Ddi_AigOptByBdd(kCone);

      Ddi_BddNotAcc(kConeOld);
      //      DdiAigRedRemovalAcc (kCone,kConeOld,-1);

      if (coneOpt) {
        Ddi_AigExistAcc(kCone, totPiVars, kConeOld, 0, 1, -1.0);
        DdiAigRedRemovalAcc(kCone, kConeOld, 2 * Ddi_BddSize(itpMgr->tr),
          -1.0);
      }
      Ddi_BddNotAcc(kConeOld);

      Ddi_Free(kConeLastLevel);
      if (abstrRef) {
        kConeLastLevel = Ddi_BddDup(kConeAbstr);
        //        Ddi_BddOrAcc(kConeAbstr,kConeOld);
        Ddi_Free(kCone);
        //         Ddi_BddComposeAcc(kConeAbstr,abstrRefCtrl,abstrRefFilter);
        kCone = Ddi_BddCompose(kConeAbstr,
          itpMgr->abstrRefCtrl, itpMgr->abstrDoRefine);
      } else {
        kConeLastLevel = Ddi_BddDup(kCone);
        //   Ddi_BddOrAcc(kCone,kConeOld);
      }


      Ddi_Free(kConeOld);
      Ddi_Free(newPiVars);

      if (dynAbstr > 1) {
        Ddi_AigExistAcc(kCone, totPiVars, NULL, 1, 1, -1.0);
      }
      if (abcOpt > 3) {
        ddiAbcOptAcc(kCone, -1.0);
      }

    } else {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "Verification Result: PASS.\n")
        );
      retVal = 1;
      break;
    }

  }

  Trav_ItpMgrQuit(itpMgr);

  Ddi_Free(myCare);

  Ddi_Free(bad);
  Ddi_Free(kConeAbstr);
  Ddi_Free(kCone);
  Ddi_Free(kConeLastLevel);
  Ddi_Free(myInit);
  Ddi_Free(totPiVars);

  Ddi_Free(smooth);

  Trav_MgrSetAssertFlag(travMgr, !retVal);

  return retVal;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatFwdExactVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * care,
  int noCheck,
  int initBound,
  int lemmaSteps,
  int lemmaSimulDepth,
  int lemmaMaxLevel
)
{
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Varset_t *pivars, *smooth, *nsvars;
  Ddi_Varset_t *totPiVars;
  Ddi_Bddarray_t *delta, *myDelta, *psLit, *nsLit;
  Ddi_Bdd_t *tr, *trAbstr = NULL, *reached, *from, *bad, *to,
    *kCone, *kConeAbstr, *myInit, *myInvarspec;
  Ddi_Bdd_t *kConeLastLevel = NULL;
  int again, i, j, nState;
  long startTime;               //, currTime;
  int cntR = 0, sat, k;
  int activeIterOffset;
  int retVal = 0, verificationDone = 0;
  Ddi_Bdd_t *myCare = NULL;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Vararray_t *dynAbstrAux = NULL, *dynAbstrCut = NULL;
  Ddi_Vararray_t *abstrRefCtrl = NULL, *abstrRefInp = NULL;
  Ddi_Bddarray_t *dynAbstrCutLits = NULL;
  Ddi_Bddarray_t *shiftPiLits = NULL;
  Ddi_Vararray_t *shiftPiVars = NULL, *saveNewPiVars = NULL;
  Ddi_Bddarray_t *abstrDoAbstr = NULL;
  Ddi_Bddarray_t *abstrRefFilter = NULL;
  Ddi_Bddarray_t *abstrDoRefine = NULL;
  unsigned char *enAbstr = NULL;

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Bddarray_t *lemmas = NULL;
  Ddi_Bddarray_t *trArray;
  int dynAbstr = Trav_MgrReadDynAbstr(travMgr);
  int abstrRef = Trav_MgrReadAbstrRef(travMgr);
  int abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  int redRem = Ddi_MgrReadAigRedRemLevel(ddm);
  int abcOpt = Ddi_MgrReadAigAbcOptLevel(ddm);
  int useAbstrTr = 1;
  int coneOpt = 0;
  Ddi_Bdd_t *saveFrom;

  if (care == NULL) {
    myCare = Ddi_BddMakeConstAig(ddm, 1);
  } else {
    myCare = Ddi_BddDup(care);
  }

  if (lemmaSteps > 0) {
    int result = 0;
    Ddi_Bddarray_t *repr, *eqts;

    repr = Ddi_BddarrayAlloc(ddm, 0);
    eqts = Ddi_BddarrayAlloc(ddm, 0);
    lemmas =
      genLemmaClasses(travMgr, fsmMgr, init, NULL, invar, invarspec, myCare,
      NULL, lemmaSteps, 1, 0, 0, &result, 0, NULL);
    Ddi_Free(repr);
    Ddi_Free(eqts);

    if (0) {
      Ddi_Vararray_t *pi, *ps, *ns;
      Ddi_Bdd_t *s0;
      Ddi_Bddarray_t *delta, *lambda;

      pi = Fsm_MgrReadVarI(fsmMgr);
      ps = Fsm_MgrReadVarPS(fsmMgr);
      ns = Fsm_MgrReadVarNS(fsmMgr);
      s0 = Fsm_MgrReadInitBDD(fsmMgr);
      delta = Fsm_MgrReadDeltaBDD(fsmMgr);
      lambda = Fsm_MgrReadLambdaBDD(fsmMgr);

      Ddi_AigFsmStore(pi, ps, ns, s0, delta, lambda,
        "xxx.blif", NULL, Pdtutil_Aig2Blif_c);
    }

  }

  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  nState = Ddi_BddarrayNum(delta);
  psLit = Ddi_BddarrayAlloc(ddm, nState);
  nsLit = Ddi_BddarrayAlloc(ddm, nState);

  nsvars = Ddi_VarsetMakeFromArray(ns);
  pivars = Ddi_VarsetMakeFromArray(pi);
  smooth = Ddi_VarsetMakeFromArray(ps);
  Ddi_VarsetUnionAcc(smooth, pivars);
  totPiVars = Ddi_VarsetMakeFromArray(pi);
  trArray = Ddi_BddarrayAlloc(ddm, nState);

  shiftPiVars = Ddi_VararrayAlloc(ddm, 0);
  shiftPiLits = Ddi_BddarrayAlloc(ddm, 0);

  Ddi_MgrSetOption(ddm, Pdt_DdiLazyRate_c, fnum, 1.1);
  myInvarspec = Ddi_BddDup(invarspec);

  // StQ 06.09.2006
  if (0) {
    static int flag = 0;
    Ddi_Vararray_t *pi, *ps, *ns;
    Ddi_Bdd_t *s0;
    Ddi_Bddarray_t *delta, *lambda;

    if (!flag) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "Scarico (0/1): ")
        );
      scanf("%d", &flag);
    }

    if (flag) {
      // Li ho ma li ricreo ...
      pi = Fsm_MgrReadVarI(fsmMgr);
      ps = Fsm_MgrReadVarPS(fsmMgr);
      ns = Fsm_MgrReadVarNS(fsmMgr);
      s0 = Fsm_MgrReadInitBDD(fsmMgr);
      delta = Fsm_MgrReadDeltaBDD(fsmMgr);
      lambda = Fsm_MgrReadLambdaBDD(fsmMgr);

      Ddi_AigFsmStore(pi, ps, ns, s0, delta, lambda,
        "xxx.blif", NULL, Pdtutil_Aig2Blif_c);

      exit(1);
    }
  }

  if (travMgr->settings.aig.targetEn > 0) {
#if 1
    Ddi_Bdd_t *r = Trav_TravSatBckAllSolVerif(travMgr, fsmMgr,
      init, invarspec, invar, travMgr->settings.aig.targetEn);
#else
    Ddi_Bdd_t *r = Trav_TravSatBckVerif(travMgr, fsmMgr,
      init, invarspec, invar, travMgr->settings.aig.targetEn, 0, 0);
#endif
    Ddi_Free(myInvarspec);
    Ddi_BddNotAcc(r);
    myInvarspec = r;
  }

  if (dynAbstr) {
    dynAbstrAux = Ddi_VararrayAlloc(ddm, nState);
    dynAbstrCut = Ddi_VararrayAlloc(ddm, nState);
    dynAbstrCutLits = Ddi_BddarrayAlloc(ddm, nState);
    enAbstr = Pdtutil_Alloc(unsigned char,
      nState
    );

    for (j = 0; j < Ddi_VararrayNum(ps); j++) {
      Ddi_Bdd_t *lit;
      char name[1000];
      Ddi_Var_t *v = Ddi_VararrayRead(ps, j);
      Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);

      sprintf(name, "dynAbstrAux_%s", Ddi_VarName(v));
      Ddi_VarAttachName(newv, name);
      Ddi_VararrayWrite(dynAbstrAux, j, newv);
      newv = Ddi_VarNewBeforeVar(v);
      sprintf(name, "dynAbstrCut_%s", Ddi_VarName(v));
      Ddi_VarAttachName(newv, name);
      Ddi_VararrayWrite(dynAbstrCut, j, newv);
      lit = Ddi_BddMakeLiteralAig(newv, 1);
      Ddi_BddarrayWrite(dynAbstrCutLits, j, lit);
      Ddi_Free(lit);
      enAbstr[j] = 1;
    }

  }

  myDelta = Ddi_BddarrayDup(delta);

  if (abstrRef) {
    abstrRefFilter = Ddi_BddarrayAlloc(ddm, nState);
    abstrDoAbstr = Ddi_BddarrayAlloc(ddm, nState);
    abstrDoRefine = Ddi_BddarrayAlloc(ddm, nState);
    abstrRefInp = Ddi_VararrayAlloc(ddm, nState);
    abstrRefCtrl = Ddi_VararrayAlloc(ddm, nState);

    for (j = 0; j < Ddi_VararrayNum(ps); j++) {
      Ddi_Bdd_t *inpLit, *ctrlLit, *d_i, *c1;
      char name[1000];
      Ddi_Var_t *v = Ddi_VararrayRead(ps, j);
      Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);

      sprintf(name, "abstrRefInp_%s", Ddi_VarName(v));
      Ddi_VarAttachName(newv, name);
      Ddi_VararrayWrite(abstrRefInp, j, newv);
      inpLit = Ddi_BddMakeLiteralAig(newv, 1);
      newv = Ddi_VarNewBeforeVar(v);
      sprintf(name, "abstrRefCtrl_%s", Ddi_VarName(v));
      Ddi_VarAttachName(newv, name);
      Ddi_VararrayWrite(abstrRefCtrl, j, newv);
      ctrlLit = Ddi_BddMakeLiteralAig(newv, 1);
      d_i = Ddi_BddIte(ctrlLit, inpLit, Ddi_BddarrayRead(delta, j));
      Ddi_BddarrayWrite(myDelta, j, d_i);
      Ddi_BddarrayWrite(abstrRefFilter, j, ctrlLit);
      c1 = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_BddarrayWrite(abstrDoAbstr, j, c1);
      Ddi_BddNotAcc(c1);
      Ddi_BddarrayWrite(abstrDoRefine, j, c1);
      Ddi_Free(c1);
      Ddi_Free(d_i);
      Ddi_Free(inpLit);
      Ddi_Free(ctrlLit);
    }
    Ddi_VararrayAppend(pi, abstrRefInp);
  }

  saveNewPiVars = Ddi_VararrayDup(pi);

#if 1
  tr = Ddi_BddMakeConstAig(ddm, 1);
#else
  tr = Ddi_BddMakeConst(ddm, 1);
#endif
  for (i = 0; i < Ddi_BddarrayNum(myDelta); i++) {
    Ddi_Bdd_t *tr_i, *psLit_i, *nsLit_i;

#if 1
    nsLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);
#else
    nsLit_i = Ddi_BddMakeLiteral(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteral(Ddi_VararrayRead(ps, i), 1);
    Ddi_BddSetMono(Ddi_BddarrayRead(delta, i));
#endif
    Ddi_BddarrayWrite(nsLit, i, nsLit_i);
    Ddi_BddarrayWrite(psLit, i, psLit_i);
    tr_i = Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(myDelta, i));
    Ddi_BddAndAcc(tr, tr_i);
    //    Ddi_BddSetMono(tr_i);
    Ddi_BddarrayWrite(trArray, i, tr_i);
    Ddi_Free(tr_i);
    Ddi_Free(psLit_i);
    Ddi_Free(nsLit_i);
  }

  if (abcOpt > 2) {
    ddiAbcOptAcc(tr, -1.0);
  }


  if (abstrRef) {
    trAbstr = Ddi_BddDup(tr);
    Ddi_BddComposeAcc(tr, abstrRefCtrl, abstrDoRefine);
  }

  bad = Ddi_BddNot(myInvarspec);
  Ddi_Free(myInvarspec);

#if 0
  Ddi_BddSetMono(tr);
  Ddi_BddSetMono(from);
  Ddi_BddSetMono(bad);
#endif

  Ddi_BddComposeAcc(bad, ps, nsLit);
  kCone = Ddi_BddDup(bad);
  kConeAbstr = Ddi_BddDup(bad);
  myInit = Ddi_BddCompose(init, ps, nsLit);

  startTime = util_cpu_time();

  activeIterOffset = 0;


  if (lemmas != NULL) {
    Ddi_Bdd_t *myCheck;

    for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
      Ddi_BddAndAcc(myCare, Ddi_BddarrayRead(lemmas, i));
      Ddi_BddAndAcc(tr, Ddi_BddarrayRead(lemmas, i));
    }
    Ddi_Free(lemmas);
    myCheck = Ddi_BddAnd(myCare, bad);
    if (Ddi_AigSat(myCheck) != 1) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "Verification OK (lemmas).\n")
        );
      verificationDone = 1;
      retVal = 1;
    }
    Ddi_Free(myCheck);
  }

  for (k = 0; !verificationDone; k++) {

    Ddi_Bddarray_t *delta_i;
    Ddi_Bddarray_t *newPiLit;
    Ddi_Bdd_t *checkBad, *kConeOver = NULL;
    int abort = 0, step = 0;

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr),
        "AIG Interpolant Main Iteration: %d (o:%d|%d|).\n", k,
        activeIterOffset, Ddi_BddSize(kCone)););

#if 0
    kConeOver = Ddi_BddMakeConstAig(ddm, 1);
    for (j = 0; j < Ddi_VararrayNum(ns); j++) {
      Ddi_Var_t *v = Ddi_VararrayRead(ns, j);
      Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, 1);
      Ddi_Bdd_t *chk = Ddi_BddDiff(kCone, lit);

      if (Ddi_AigSat(chk) != 1) {
        /* kCone Included in lit */
        Ddi_BddAndAcc(kConeOver, lit);
        Ddi_Free(chk);
      } else {
        Ddi_Free(chk);
        Ddi_BddNotAcc(lit);
        chk = Ddi_BddDiff(kCone, lit);
        if (Ddi_AigSat(chk) != 1) {
          /* kCone Included in lit */
          Ddi_BddAndAcc(kConeOver, lit);
        }
        Ddi_Free(chk);
      }
      Ddi_Free(lit);
    }
    if (!Ddi_BddIsOne(kConeOver)) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "CONE LIT Overappr: %d.\n",
          Ddi_BddSize(kConeOver))
        );
    }
    Ddi_Free(kConeOver);
#endif

    checkBad = Ddi_BddAnd(myInit, kCone);
    if ((!noCheck) && (Ddi_AigSat(checkBad) == 1)) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "Verification Result: FAIL.\n")
        );
      Ddi_Free(checkBad);
      break;
    }
    Ddi_Free(checkBad);

    if (initBound >= 0 && k < initBound || activeIterOffset > 0) {
      abort = 1;
      if (activeIterOffset) {
        activeIterOffset--;
      }
    } else {

      Ddi_Bdd_t *trAux = NULL;

      if (abcOpt > 0) {
        ddiAbcOptAcc(kCone, -1.0);
      }

      if (abstrRef) {

        Ddi_Varset_t *abstrVars = NULL;
        int size0 = Ddi_BddSize(kCone), nAbstr = 0;
        Ddi_Bddarray_t *abstrRefTmpConst = Ddi_BddarrayDup(abstrDoRefine);

        /* abstraction refinement */
        Ddi_Bdd_t *c0 = Ddi_BddMakeConstAig(ddm, 0);

        checkBad = Ddi_BddAnd(myInit, kConeAbstr);
#if 1
        abstrVars = Ddi_AigAbstrVarsIncremental(checkBad, abstrRefCtrl);
        for (j = 0; j < Ddi_VararrayNum(ns); j++) {
          if (Ddi_BddIsOne(Ddi_BddarrayRead(abstrDoAbstr, j))) {
            Ddi_Var_t *ctrl = Ddi_VararrayRead(abstrRefCtrl, j);

            if (Ddi_VarInVarset(abstrVars, ctrl)) {
              nAbstr++;
              Ddi_BddNotAcc(Ddi_BddarrayRead(abstrRefTmpConst, j));
            } else {
              /* invalid abstraction */
              Ddi_BddNotAcc(Ddi_BddarrayRead(abstrDoAbstr, j));
              Ddi_BddarrayWrite(abstrRefFilter, j, c0);
            }
          }
        }
        Ddi_Free(abstrVars);
#else
        for (j = 0; j < Ddi_VararrayNum(ns); j++) {
          if (Ddi_BddIsOne(Ddi_BddarrayRead(abstrDoAbstr, j))) {
            Ddi_Bdd_t *myCheck = NULL;

            Ddi_BddNotAcc(Ddi_BddarrayRead(abstrRefTmpConst, j));
            Pdtutil_Assert(Ddi_BddIsOne(Ddi_BddarrayRead(abstrRefTmpConst, j)),
              "1 required");
            myCheck = Ddi_BddCompose(checkBad, abstrRefCtrl, abstrRefTmpConst);
            if (Ddi_AigSat(myCheck) == 1) {
              /* invalid abstraction */
              Ddi_BddNotAcc(Ddi_BddarrayRead(abstrRefTmpConst, j));
              Ddi_BddNotAcc(Ddi_BddarrayRead(abstrDoAbstr, j));
              Ddi_BddarrayWrite(abstrRefFilter, j, c0);
            } else {
              nAbstr++;
            }
            Ddi_Free(myCheck);
          }
        }
#endif
        Ddi_Free(kCone);
        Ddi_Free(c0);
        kCone = Ddi_BddCompose(kConeAbstr, abstrRefCtrl, abstrDoAbstr);
        //         Ddi_BddComposeAcc(trAbstr,abstrRefCtrl,abstrRefFilter);
        Ddi_Free(abstrRefTmpConst);
        Ddi_Free(checkBad);

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "Cone Abstract: %d -> %d(na:%d).\n",
            size0, Ddi_BddSize(kCone), nAbstr)
          );
      }

      if (useAbstrTr && abstrRef) {
        trAux = Ddi_BddCompose(trAbstr, abstrRefCtrl, abstrDoAbstr);
      } else {
        trAux = Ddi_BddDup(tr);
      }

      /* INTERPOLANT INNER LOOP */

      reached = Ddi_BddDup(myInit);
      from = Ddi_BddDup(reached);

      do {
        int sizeAig;
        Ddi_Bdd_t *over = NULL;
        Ddi_Bdd_t *careAig;
        Ddi_Bdd_t *from0;

        //    careAig = Ddi_BddNot(reached);

        Ddi_BddComposeAcc(from, ns, psLit);
        from0 = Ddi_BddDup(from);
        Ddi_BddAndAcc(from, trAux);

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr),
            "\nAIG Interpolant Inner Iteration: %d\n\n (|From|=%d -> ", step,
            Ddi_BddSize(from)););
        step++;
        careAig = Ddi_BddNot(reached);
        if (myCare != NULL) {
          Ddi_BddAndAcc(careAig, myCare);
          Ddi_BddAndAcc(from, myCare);
        }

        if (redRem > 1) {
          DdiAigRedRemovalAcc(from, careAig, 1000, -1.0);
        }
        //        Ddi_AigExistAcc(from,smooth,careAig,1,0);

#if 0
        over = Ddi_BddDup(from);
        DdiAigExistOverAcc(over, smooth, NULL);
#endif

        saveFrom = Ddi_BddDup(from);
        if (dynAbstr) {
          int j;
          char wfile[100];
          Ddi_Varset_t *fromVars;
          Ddi_Bdd_t *auxFrom = Ddi_BddCompose(from, ns, dynAbstrCutLits);

          Ddi_Free(from);
          sprintf(wfile, "INTERP_DYN_ABSTR_%d_%d", k, step);
          from = Ddi_AigAbstrVarsForInterpolant(auxFrom, kCone,
            dynAbstrCut, ns, dynAbstrAux, NULL, enAbstr, NULL);
          if (from != NULL) {
            fromVars = Ddi_BddSupp(from);
            Ddi_VarsetIntersectAcc(fromVars, nsvars);

            for (j = 0; j < Ddi_VararrayNum(ns); j++) {
              if (Ddi_VarInVarset(fromVars, Ddi_VararrayRead(ns, j))) {
                Ddi_Bdd_t *tr_j = Ddi_BddarrayRead(trArray, j);

                //              Ddi_BddPartInsertLast(toBdd,tr_j);
                Ddi_BddAndAcc(from0, tr_j);
              }
            }
            Ddi_Free(from);
            from = Ddi_BddDup(from0);
            //  from = Ddi_BddExistProject(toBdd,nsvars);
            Ddi_BddSetAig(from);

            if (myCare != NULL) {
              Ddi_BddAndAcc(from, myCare);
            }
            Ddi_Free(fromVars);
          }
          Ddi_Free(auxFrom);
        }
        //        Ddi_BddAndAcc(from,careAig);

        if (from == NULL) {
          to = NULL;
          sat = 1;
        } else {
          if (abstrRef) {
            if (useAbstrTr) {
              Ddi_BddComposeAcc(from, abstrRefCtrl, abstrDoAbstr);
            } else {
              Ddi_BddComposeAcc(from, abstrRefCtrl, abstrDoRefine);
            }
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "(Abstr -> %d)", Ddi_BddSize(from))
              );
          }

          if (0) {
            Ddi_Varset_t *mySm = Ddi_BddSupp(from);
            Ddi_Bdd_t *toAndkCone;

            Ddi_VarsetDiffAcc(mySm, nsvars);
            to = Ddi_BddDup(from);
            Ddi_AigExistProjectAcc(to, nsvars, NULL, 3, 0, -1.0);
            Ddi_AigExistProjectAcc(to, nsvars, NULL, 0, 0, -1.0);
            Ddi_Free(mySm);
            toAndkCone = Ddi_BddAnd(to, kCone);
            sat = Ddi_AigSat(toAndkCone);
            Ddi_Free(toAndkCone);
          } else if (1) {
            to = Ddi_AigSatAndWithInterpolant(from, kCone, nsvars, NULL, NULL,
              NULL, NULL, NULL, &sat, 0, 0, -1.0);
            if (to != NULL) {

              /*
               *  StQ June 2007, 04
               *  Link to ABC tool
               */


              Ddi_Bdd_t *auxTo;
              Ddi_Varset_t *vs = Ddi_BddSupp(to);

              Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                fprintf(tMgrO(travMgr), "TO: %d (supp: %d) - AIG nodes %d.\n",
                  Ddi_BddSize(to), Ddi_VarsetNum(vs),
                  Ddi_MgrReadAigNodesNum(ddm))
                );
              Ddi_Free(vs);

              if (dynAbstr > 2) {

                kConeOver = Ddi_BddNot(to);
                auxTo = Ddi_AigSatAndWithInterpolant(saveFrom,
                  kCone, nsvars, NULL, NULL, NULL, NULL, NULL, &sat, 0, 0,
                  -1.0);
                if (auxTo != NULL) {
                  Ddi_Varset_t *vs = Ddi_BddSupp(auxTo);

                  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                    fprintf(tMgrO(travMgr), "AUXTO: %d (supp: %d).\n",
                      Ddi_BddSize(auxTo), Ddi_VarsetNum(vs))
                    );
                  Ddi_Free(vs);
                  Ddi_BddAndAcc(to, auxTo);
                  Ddi_Free(auxTo);
                }
              }

              Ddi_Free(kConeOver);
            }

          } else {
            Ddi_Bdd_t *kConePlus =
              Ddi_AigSatAndWithInterpolant(kCone, from, nsvars, NULL, NULL,
              NULL, NULL, NULL, &sat, 0, 0, -1.0);

            if (sat)
              to = NULL;
            else {
              Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                fprintf(tMgrO(travMgr), "K-Plus: %d.\n",
                  Ddi_BddSize(kConePlus))
                );
              to =
                Ddi_AigSatAndWithInterpolant(from, kConePlus, nsvars, NULL,
                NULL, NULL, NULL, NULL, &sat, 0, 0, -1.0);
            }
            Ddi_Free(kConePlus);
          }
        }

        Ddi_Free(saveFrom);

        if (redRem && to != NULL) {
          DdiAigRedRemovalAcc(to, careAig, -1, -1.0);
        }

        if (to != NULL && over != NULL) {
          Ddi_Bdd_t *outside = Ddi_BddDiff(to, over);

          if (Ddi_AigSat(outside)) {
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
              fprintf(tMgrO(travMgr), "overapprox refinement: %d.\n",
                Ddi_BddSize(over))
              );
            DdiAigRedRemovalAcc(to, over, -1, -1.0);
            DdiAigRedRemovalAcc(over, to, -1, -1.0);
            Ddi_BddAndAcc(to, over);
          }
          Ddi_Free(outside);
        }

        Ddi_Free(over);

        if ((sat)) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "\nInner loop ABORT.\n")
            );
          Ddi_Free(to);
          Ddi_Free(from0);
          Ddi_Free(careAig);
          abort = 1;
          break;
        }

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "|to:%d|.\n", Ddi_BddSize(to))
          );

        //        DdiAigRedRemovalAcc (to,careAig,-1);

        if (1 && Ddi_BddSize(to) > 100) {
          Ddi_Bdd_t *to2 = NULL, *kConePlus = NULL;

#if 0
          Ddi_BddNotAcc(from);
          kConePlus = Ddi_BddDup(kCone);
          DdiAigExistOverPartialAcc(kConePlus,
            smooth, from, Ddi_BddSize(kCone) / 2);
          Ddi_BddNotAcc(from);
          Ddi_BddNotAcc(to);
          to2 =
            Ddi_AigSatAndWithInterpolant(from, kConePlus, nsvars, psvars, NULL,
            NULL, NULL, NULL, &sat, 0, 0, -1.0);
          Ddi_BddNotAcc(to);
#else
#if 0
          {
            Ddi_Bdd_t *myFrom = Ddi_BddDup(from);

            Ddi_BddNotAcc(kCone);
            DdiAigExistOverPartialAcc(myFrom,
              smooth, kCone, Ddi_BddSize(myFrom) / 2);
            //            Ddi_AigExistAcc(myFrom,smooth,NULL,1,1);
            Ddi_BddNotAcc(kCone);
            to2 = Ddi_AigSatAndWithInterpolant(myFrom, kCone, nsvars, psvars,
              NULL, NULL, &sat, 0, 0, -1.0);
            Ddi_Free(myFrom);
          }
          if (to2 != NULL && Ddi_BddSize(to2) < Ddi_BddSize(to)) {
            Ddi_Free(to);
            to = to2;
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
              fprintf(tMgrO(travMgr), "|to2:%d|.\n", Ddi_BddSize(to))
              );
          } else {
            Ddi_Free(to2);
          }
          to2 = Ddi_BddDup(to);
          Ddi_BddNotAcc(kCone);
          DdiAigExistOverPartialAcc(to2, nsvars, kCone, Ddi_BddSize(to2) / 2);
          Ddi_BddNotAcc(kCone);
#endif
#endif
          if (to2 != NULL && Ddi_BddSize(to2) < Ddi_BddSize(to)) {
            Ddi_Free(to);
            to = to2;
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
              fprintf(tMgrO(travMgr), "|to2:%d|.\n", Ddi_BddSize(to))
              );
          } else if (0) {
            Ddi_Bdd_t *chk;

            Ddi_Free(to2);
            to2 = Ddi_BddDup(from);
            DdiAigExistOverAcc(to2, smooth, NULL);
            chk = Ddi_BddAnd(to2, kCone);
            if (!Ddi_AigSat(chk)) {
              Ddi_Free(to);
              to = to2;
            } else {
              Ddi_Free(to2);
            }
            Ddi_Free(chk);
          }
          Ddi_Free(kConePlus);
        }
#if 0
        DdiAigRedRemovalAcc(from, to, -1, -1.0);
        Ddi_AigExistAcc(from, smooth, to, 1, 0, -1.0);
        //        Ddi_AigExistAcc(from,smooth,to,0,0);
        DdiAigExistOverAcc(from, smooth, NULL);
        Ddi_BddAndAcc(to, from);
#endif

        Ddi_Free(from);

        from = Ddi_BddDiff(to, reached);

        again = Ddi_AigSat(from) == 1;
#if 1
        Ddi_Free(from);
        from = Ddi_BddDup(to);
#endif

        Ddi_BddOrAcc(reached, to);

#if 1
        Ddi_Free(from);
        from = Ddi_BddDup(to);
#endif

        //        if (redRem) {
        //          DdiAigRedRemovalAcc (from,careAig,-1);
        //        }
        Ddi_Free(careAig);

        Ddi_Free(to);

        //    Ddi_AigExistAcc(tr,totPiVars,NULL,1,0);

        //    Ddi_AigOptByBddPartial(tr,careAig);
        //    Ddi_BddSetMono(tr);
        //    Ddi_BddSetAig(tr);
        //    Ddi_AigOptByBddPartial(tr,careAig);
        //      Ddi_Free(careAig);

        sizeAig = Ddi_BddSize(tr);
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "   |tr|=%d |reached|=%d.\n",
            Ddi_BddSize(tr), Ddi_BddSize(reached))
          );

        if (cntR) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            Ddi_Bdd_t * r = Ddi_BddMakeMono(reached);
            fprintf(tMgrO(travMgr), "   # Reached states = %g.\n",
              Ddi_BddCountMinterm(r, Ddi_VararrayNum(ps))); Ddi_Free(r)
            );
        }

        Ddi_Free(from0);

      } while (again);

      Ddi_Free(trAux);
      Ddi_Free(reached);
      Ddi_Free(from);

      activeIterOffset = step - 1;

      /* END INTERPOLANT INNER LOOP */

    }

    if (abort) {

      Ddi_Bdd_t *kConeOld = NULL;
      Ddi_Varset_t *newPiVars = Ddi_VarsetVoid(ddm);
      int j;

      Ddi_VararrayAppend(shiftPiVars, saveNewPiVars);

      newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
      for (j = 0; j < Ddi_VararrayNum(pi); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
        Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), k);
        Ddi_VarAttachName(newv, name);
        Ddi_VarsetAddAcc(totPiVars, newv);
        Ddi_VarsetAddAcc(smooth, newv);
        Ddi_VarsetAddAcc(newPiVars, newv);
        Ddi_VararrayWrite(saveNewPiVars, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newPiLit, j, newvLit);
        Ddi_Free(newvLit);
      }

      Ddi_BddarrayAppend(shiftPiLits, newPiLit);

      delta_i = Ddi_BddarrayDup(myDelta);
      for (j = 0; j < Ddi_BddarrayNum(delta_i); j++) {
        Ddi_BddComposeAcc(Ddi_BddarrayRead(delta_i, j), pi, newPiLit);
      }

      if (kConeLastLevel == NULL) {
        kConeLastLevel = Ddi_BddDup(kCone);
      }

      if (abstrRef) {
        kConeOld = Ddi_BddCompose(kConeAbstr, shiftPiVars, shiftPiLits);
        Ddi_Free(kConeAbstr);
        kConeAbstr = Ddi_BddCompose(kConeLastLevel, ns, delta_i);
      } else {
        kConeOld = Ddi_BddCompose(kCone, shiftPiVars, shiftPiLits);
        Ddi_Free(kCone);
        kCone = Ddi_BddCompose(kConeLastLevel, ns, delta_i);
      }

      Ddi_Free(delta_i);
      if (myCare != NULL) {
        Ddi_Bdd_t *c = Ddi_BddCompose(myCare, pi, newPiLit);

        if (abstrRef) {
          Ddi_BddAndAcc(kConeAbstr, c);
        } else {
          Ddi_BddAndAcc(kCone, c);
        }
        Ddi_Free(c);
      }


      Ddi_Free(newPiLit);
      if (abstrRef) {
        Ddi_BddComposeAcc(kConeAbstr, ps, nsLit);
      } else {
        Ddi_BddComposeAcc(kCone, ps, nsLit);
      }

      //      Ddi_AigExistAcc (kCone,totPiVars,NULL,2,0);


      //      DdiAigRedRemovalAcc (kCone,NULL,-1);
      //      Ddi_AigOptByBdd(kCone);

      Ddi_BddNotAcc(kConeOld);
      //      DdiAigRedRemovalAcc (kCone,kConeOld,-1);

      if (coneOpt) {
        Ddi_AigExistAcc(kCone, totPiVars, kConeOld, 0, 1, -1.0);
        DdiAigRedRemovalAcc(kCone, kConeOld, 2 * Ddi_BddSize(tr), -1.0);
      }
      Ddi_BddNotAcc(kConeOld);

      Ddi_Free(kConeLastLevel);
      if (abstrRef) {
        kConeLastLevel = Ddi_BddDup(kConeAbstr);
        //        Ddi_BddOrAcc(kConeAbstr,kConeOld);
        Ddi_Free(kCone);
        //         Ddi_BddComposeAcc(kConeAbstr,abstrRefCtrl,abstrRefFilter);
        kCone = Ddi_BddCompose(kConeAbstr, abstrRefCtrl, abstrDoRefine);
      } else {
        kConeLastLevel = Ddi_BddDup(kCone);
        //   Ddi_BddOrAcc(kCone,kConeOld);
      }


      Ddi_Free(kConeOld);
      Ddi_Free(newPiVars);

      if (dynAbstr > 1) {
        Ddi_AigExistAcc(kCone, totPiVars, NULL, 1, 1, -1.0);
      }
      if (abcOpt > 3) {
        ddiAbcOptAcc(kCone, -1.0);
      }

    } else {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "Verification Result: PASS.\n")
        );
      retVal = 1;
      break;
    }

  }

  if (dynAbstr) {
    Ddi_Free(dynAbstrCut);
    Ddi_Free(dynAbstrCutLits);
    Ddi_Free(dynAbstrAux);
    Pdtutil_Free(enAbstr);
  }
  if (abstrRef) {
    Ddi_Free(abstrRefFilter);
    Ddi_Free(abstrDoAbstr);
    Ddi_Free(abstrDoRefine);
    Ddi_Free(abstrRefInp);
    Ddi_Free(abstrRefCtrl);
  }

  Trav_MgrSetAssertFlag(travMgr, !retVal);

  Ddi_Free(myDelta);

  Ddi_Free(saveNewPiVars);
  Ddi_Free(shiftPiVars);
  Ddi_Free(shiftPiLits);
  Ddi_Free(myCare);
  Ddi_Free(tr);
  Ddi_Free(trAbstr);
  Ddi_Free(bad);
  Ddi_Free(kConeAbstr);
  Ddi_Free(kCone);
  Ddi_Free(kConeLastLevel);
  Ddi_Free(myInit);
  Ddi_Free(totPiVars);
  Ddi_Free(nsvars);
  Ddi_Free(pivars);
  Ddi_Free(smooth);
  Ddi_Free(psLit);
  Ddi_Free(nsLit);
  Ddi_Free(trArray);

  return retVal;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatFwdInterpolantVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * care,
  int noCheck,
  int initBound,
  int lemmasSteps
)
{
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Varset_t *pivars, *smooth, *nsvars;
  Ddi_Varset_t *totPiVars;
  Ddi_Bddarray_t *delta, *psLit, *nsLit, *deltaPlus, *trUnrolls;
  Ddi_Bdd_t *tr, *trPlus, *reached, *from, *bad, *to, *kCone;
  Ddi_Bdd_t *unroll, *fromRef, *reachedRef, *myInit, *myInvarspec;
  int again, i, nState;
  long startTime;               //, currTime;
  int cntR = 0, sat, k, from_step;
  int activeIterOffset;
  Ddi_Bdd_t *myCare = NULL;
  int retVal = 0, verificationDone = 0;

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Bddarray_t *lemmas = NULL;
  int dynAbstr = Trav_MgrReadDynAbstr(travMgr);
  int abstrRef = Trav_MgrReadAbstrRef(travMgr);
  int abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  int redRem = Ddi_MgrReadAigRedRemLevel(ddm);
  int abcOpt = Ddi_MgrReadAigAbcOptLevel(ddm);

  if (lemmasSteps > 0) {
    int result = 0;

    lemmas = genLemmaClasses(travMgr, fsmMgr, init, NULL, invar,
      invarspec, NULL, NULL, lemmasSteps, 0, 0, 0, &result, 0, NULL);
  }

  if (care == NULL) {
    myCare = Ddi_BddMakeConstAig(ddm, 1);
  } else {
    myCare = Ddi_BddDup(care);
  }

  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Ddi_VararrayDup(Fsm_MgrReadVarI(fsmMgr));
  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  nState = Ddi_BddarrayNum(delta);
  psLit = Ddi_BddarrayAlloc(ddm, nState);
  nsLit = Ddi_BddarrayAlloc(ddm, nState);

  nsvars = Ddi_VarsetMakeFromArray(ns);
  pivars = Ddi_VarsetMakeFromArray(pi);
  smooth = Ddi_VarsetMakeFromArray(ps);
  Ddi_VarsetUnionAcc(smooth, pivars);
  totPiVars = Ddi_VarsetMakeFromArray(pi);

  Ddi_MgrSetOption(ddm, Pdt_DdiLazyRate_c, fnum, 1.1);
  myInvarspec = Ddi_BddDup(invarspec);
  if (travMgr->settings.aig.targetEn > 0) {
#if 1
    Ddi_Bdd_t *r = Trav_TravSatBckAllSolVerif(travMgr, fsmMgr,
      init, invarspec, invar, travMgr->settings.aig.targetEn);
#else
    Ddi_Bdd_t *r = Trav_TravSatBckVerif(travMgr, fsmMgr,
      init, invarspec, invar, travMgr->settings.aig.targetEn, 0);
#endif
    Ddi_Free(myInvarspec);
    Ddi_BddNotAcc(r);
    myInvarspec = r;
  }

  deltaPlus = Ddi_BddarrayDup(delta);
  for (i = 0; i < Ddi_BddarrayNum(deltaPlus); i++) {
    char name[1000];
    Ddi_Var_t *v = Ddi_VararrayRead(pi, 0);
    Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
    Ddi_Bdd_t *newvLit, *wire_i, *dp_i, *d_i;

    sprintf(name, "_INTERPOLANT_SELECT");
    Ddi_VarAttachName(newv, name);
    Ddi_VarsetAddAcc(totPiVars, newv);
    Ddi_VarsetAddAcc(smooth, newv);
    Ddi_VararrayInsertLast(pi, newv);
    newvLit = Ddi_BddMakeLiteralAig(newv, 1);
    wire_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);
    d_i = Ddi_BddarrayRead(delta, i);
    dp_i = Ddi_BddIte(newvLit, d_i, wire_i);
    Ddi_BddarrayWrite(deltaPlus, i, dp_i);
    Ddi_Free(dp_i);
    Ddi_Free(wire_i);
    Ddi_Free(newvLit);
  }

  tr = Ddi_BddMakeConstAig(ddm, 1);
  trPlus = Ddi_BddMakeConstAig(ddm, 1);

  for (i = 0; i < Ddi_BddarrayNum(deltaPlus); i++) {
    Ddi_Bdd_t *tr_i, *psLit_i, *nsLit_i;

    nsLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);
    Ddi_BddarrayWrite(nsLit, i, nsLit_i);
    Ddi_BddarrayWrite(psLit, i, psLit_i);
    tr_i = Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(delta, i));
    Ddi_BddAndAcc(tr, tr_i);
    Ddi_Free(tr_i);
    tr_i = Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(deltaPlus, i));
    Ddi_BddAndAcc(trPlus, tr_i);
    Ddi_Free(tr_i);
    Ddi_Free(psLit_i);
    Ddi_Free(nsLit_i);
  }

  bad = Ddi_BddNot(myInvarspec);
  Ddi_Free(myInvarspec);

  Ddi_BddComposeAcc(bad, ps, nsLit);
  kCone = Ddi_BddDup(bad);
  myInit = Ddi_BddCompose(init, ps, nsLit);
  unroll = Ddi_BddDup(trPlus);
  trUnrolls = Ddi_BddarrayAlloc(ddm, 0);

  startTime = util_cpu_time();
  activeIterOffset = 0;

  if (lemmas != NULL) {
    Ddi_Bdd_t *myCheck;

    for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
      Ddi_BddAndAcc(myCare, Ddi_BddarrayRead(lemmas, i));
      Ddi_BddAndAcc(tr, Ddi_BddarrayRead(lemmas, i));
    }
    Ddi_Free(lemmas);
    myCheck = Ddi_BddAnd(myCare, bad);
    if (Ddi_AigSat(myCheck) != 1) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "Verification Result: PASS (lemmas).\n")
        );
      verificationDone = 1;
      retVal = 1;
    }
    Ddi_Free(myCheck);
  }
  //  Ddi_AigOptByBdd(tr);
  if (0 && myCare != NULL) {
    for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
      DdiAigRedRemovalAcc(Ddi_BddarrayRead(delta, i), myCare, -1, -1.0);
    }
  }

  for (k = 0;; k++) {

    Ddi_Bddarray_t *delta_i;
    Ddi_Bddarray_t *newPiLit;
    Ddi_Bdd_t *checkBad;
    int abort = 0, step = 0;

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c, Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "AIG Interpolant Main Iteration: %d (%d).\n",
        k, Ddi_BddSize(kCone))
      );

    checkBad = Ddi_BddAnd(myInit, kCone);
    if ((!noCheck) && (Ddi_AigSat(checkBad) == 1)) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "Verification Result: FAIL.\n")
        );
      Ddi_Free(checkBad);
      break;
    }
    Ddi_Free(checkBad);

    if (initBound >= 0 && k < initBound || activeIterOffset > 0) {
      abort = 1;
      if (activeIterOffset) {
        activeIterOffset--;
      }
    } else {

      reached = Ddi_BddDup(init);
      reachedRef = Ddi_BddDup(init);

      again = 1;
      fromRef = Ddi_BddDup(init);
      from_step = 0;

      for (step = 0; again; step++) {
        int sizeAig, unroll_bound;
        Ddi_Bdd_t *newFrom, *over = NULL;
        Ddi_Bdd_t *careAig;
        Ddi_Bdd_t *fwdCone_i;

        //    careAig = Ddi_BddNot(reached);

        unroll_bound = step - from_step;
        if (Ddi_BddarrayNum(trUnrolls) <= unroll_bound) {

          Ddi_Varset_t *newPiVars = Ddi_VarsetVoid(ddm);
          int j;

          newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
          for (j = 0; j < Ddi_VararrayNum(pi); j++) {
            char name[1000];
            Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
            Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
            Ddi_Bdd_t *newvLit;

            sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), k);
            Ddi_VarAttachName(newv, name);
            Ddi_VarsetAddAcc(totPiVars, newv);
            Ddi_VarsetAddAcc(newPiVars, newv);
            newvLit = Ddi_BddMakeLiteralAig(newv, 1);
            Ddi_BddarrayWrite(newPiLit, j, newvLit);
            Ddi_Free(newvLit);
          }

          if (unroll_bound == 0) {
            Ddi_BddComposeAcc(unroll, pi, newPiLit);
          } else {
            delta_i = Ddi_BddarrayDup(deltaPlus);
            for (j = 0; j < Ddi_BddarrayNum(delta_i); j++) {
              Ddi_BddComposeAcc(Ddi_BddarrayRead(delta_i, j), pi, newPiLit);
            }
            Ddi_BddComposeAcc(unroll, ps, delta_i);
            Ddi_Free(delta_i);
          }

          Ddi_Free(newPiLit);

          Pdtutil_Assert(Ddi_BddarrayNum(trUnrolls) == unroll_bound,
            "wrong fwd cones num");
          Ddi_BddarrayInsertLast(trUnrolls, unroll);

          Ddi_Free(newPiVars);
        }

        fwdCone_i = Ddi_BddarrayRead(trUnrolls, unroll_bound);
        from = Ddi_BddAnd(fromRef, fwdCone_i);
        if (unroll_bound > 0) {
          newFrom = Ddi_BddAnd(reached, Ddi_BddarrayRead(trUnrolls, 0));
          if (step > 2 * k || Ddi_BddSize(newFrom) < Ddi_BddSize(from)) {
            Ddi_Free(from);
            from = newFrom;
            Ddi_Free(fromRef);
            fromRef = Ddi_BddDup(reached);
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "IMG[1] (newR) ")
              );
            from_step = step;
          } else {
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "IMG[%d] ", unroll_bound + 1)
              );
            Ddi_Free(newFrom);
          }
        } else {
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "IMG[1] ")
            );
        }
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr),
            "\nAIG Interpolant Inner Iteration: %d\n\n (|From|=%d -> ", step,
            Ddi_BddSize(from))
          );

#if 1
        careAig = Ddi_BddMakeConstAig(ddm, 1);
#else
        careAig = Ddi_BddNot(reached);
        Ddi_BddComposeAcc(careAig, ps, nsLit);
#endif
        //        Ddi_AigExistAcc(from,smooth,careAig,1,0);

        //      over = Ddi_BddDup(from);
        //        DdiAigExistOverAcc (over,smooth,NULL);

        if (0) {
          Ddi_Varset_t *mySm = Ddi_BddSupp(from);
          Ddi_Bdd_t *toAndkCone;

          Ddi_VarsetDiffAcc(mySm, nsvars);
          to = Ddi_BddDup(from);
          Ddi_AigExistProjectAcc(to, nsvars, careAig, 3, 0, -1.0);
          Ddi_AigExistProjectAcc(to, nsvars, careAig, 0, 0, -1.0);
          Ddi_Free(mySm);
          toAndkCone = Ddi_BddAnd(to, kCone);
          sat = Ddi_AigSat(toAndkCone);
          Ddi_Free(toAndkCone);
        } else if (1) {
          to = Ddi_AigSatAndWithInterpolant(from, kCone, nsvars, NULL, NULL,
            NULL, NULL, NULL, &sat, 0, 0, -1.0);
        } else {
          Ddi_Bdd_t *toPlus =
            Ddi_AigSatAndWithInterpolant(from, kCone, nsvars, NULL, NULL,
            NULL, NULL, NULL, &sat, 0, 0, -1.0);

          if (!sat) {
            int l;

            for (l = 0; l < 1; l++) {
              Ddi_Bdd_t *newTo;

              Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                Pdtutil_VerbLevelNone_c,
                fprintf(tMgrO(travMgr), "to-Plus: %d.\n", Ddi_BddSize(toPlus))
                );
              Ddi_BddNotAcc(toPlus);
              newTo = Ddi_AigSatAndWithInterpolant(from, toPlus,
                nsvars, NULL, NULL, NULL, NULL, NULL, &sat, 0, 0, -1.0);
              Ddi_BddNotAcc(toPlus);
              if (Ddi_BddSize(newTo) > Ddi_BddSize(toPlus)) {
                Ddi_Free(newTo);
                break;
              } else {
                Ddi_Free(toPlus);
                toPlus = newTo;
              }
            }
          }
          to = toPlus;
        }

        if (to != NULL && over != NULL) {
          Ddi_Bdd_t *outside = Ddi_BddDiff(to, over);

          if (Ddi_AigSat(outside)) {
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "Over-Approximation Refinement: %d.\n",
                Ddi_BddSize(over))
              );
            DdiAigRedRemovalAcc(to, over, -1, -1.0);
            DdiAigRedRemovalAcc(over, to, -1, -1.0);
            Ddi_BddAndAcc(to, over);
          }
          Ddi_Free(outside);
        }

        Ddi_Free(over);

        if ((sat)) {
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "Inner Loop: Abort.\n")
            );
          Ddi_Free(to);
          abort = 1;
          break;
        }

        if (0 && Ddi_BddSize(to) > 100) {
          Ddi_Bdd_t *myTo = Ddi_BddDup(to);
          Ddi_Varset_t *vs = Ddi_BddSupp(to);

          Ddi_BddNotAcc(kCone);
          DdiAigExistOverPartialAcc(myTo, vs, kCone, Ddi_BddSize(myTo) / 2);
          //            Ddi_AigExistAcc(myFrom,smooth,NULL,1,1);
          Ddi_BddNotAcc(kCone);
          if (myTo != NULL && Ddi_BddSize(myTo) < Ddi_BddSize(to)) {
            Ddi_Free(to);
            to = myTo;
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "|to2:%d|.\n", Ddi_BddSize(to))
              );
          } else {
            Ddi_Free(myTo);
          }
          Ddi_Free(vs);
        }


        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "|to:%d.\n", Ddi_BddSize(to))
          );
        Ddi_BddComposeAcc(to, ns, psLit);

        Ddi_Free(from);
        from = Ddi_BddDiff(to, fromRef);
        if (myCare != NULL) {
          Ddi_BddAndAcc(from, myCare);
          DdiAigRedRemovalAcc(to, myCare, -1, -1.0);
        }

        again = Ddi_AigSat(from) == 1;
        if (!again) {
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "to <= reached.\n")
            );
        }
        Ddi_Free(from);

        Ddi_Free(reached);
        reached = to;

        /* fix point if no next state from reached to !reached */
        if (again) {
          Ddi_Bdd_t *check = Ddi_BddCompose(reached, ps, nsLit);

          Ddi_BddNotAcc(check);
          Ddi_BddAndAcc(check, tr);
          Ddi_BddAndAcc(check, reached);
          again = Ddi_AigSat(check) == 1;
          Ddi_Free(check);
          if (again) {
            checkBad = Ddi_BddDup(reached);
            Ddi_BddAndAcc(checkBad, tr);
            Ddi_BddAndAcc(checkBad, kCone);
            Ddi_BddAndAcc(checkBad, myCare);
            abort = Ddi_AigSat(checkBad) == 1;
            Ddi_Free(checkBad);
            if (abort) {
              Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                Pdtutil_VerbLevelNone_c,
                fprintf(tMgrO(travMgr), "iteration aborted.\n")
                );
            } else {
              check = Ddi_BddCompose(fromRef, ps, nsLit);
              Ddi_BddNotAcc(check);
              Ddi_BddAndAcc(check, tr);
              Ddi_BddAndAcc(check, reached);
              again = Ddi_AigSat(check) == 1;
              Ddi_Free(check);
              if (!again) {
                Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                  Pdtutil_VerbLevelNone_c,
                  fprintf(tMgrO(travMgr), "img(to) <= reached.\n")
                  );
              }
            }
          } else {
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "inductive fix point.\n")
              );
          }

        }
        again &= !abort;

        Ddi_Free(careAig);

        sizeAig = Ddi_BddSize(tr);

        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr),
            "   |tr|=%d |reached|=%d.\n", Ddi_BddSize(tr),
            Ddi_BddSize(reached))
          );

        if (cntR) {
          Ddi_Bdd_t *r = Ddi_BddMakeMono(reached);

          fprintf(tMgrO(travMgr), "#Reached States = %g.\n",
            Ddi_BddCountMinterm(r, Ddi_VararrayNum(ps)));
          Ddi_Free(r);
        }

      }

      Ddi_Free(reached);
      Ddi_Free(fromRef);
      Ddi_Free(reachedRef);

      activeIterOffset = step;

    }


    if (abort) {

      Ddi_Varset_t *newPiVars = Ddi_VarsetVoid(ddm);
      int j;
      Ddi_VarsetSetArray(newPiVars);

      newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
      for (j = 0; j < Ddi_VararrayNum(pi); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
        Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), k);
        Ddi_VarAttachName(newv, name);
        Ddi_VarsetAddAcc(totPiVars, newv);
        Ddi_VarsetAddAcc(smooth, newv);
        Ddi_VarsetAddAcc(newPiVars, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newPiLit, j, newvLit);
        Ddi_Free(newvLit);
      }

      //      delta_i = Ddi_BddarrayDup(deltaPlus);
      delta_i = Ddi_BddarrayDup(delta);
      for (j = 0; j < Ddi_BddarrayNum(delta_i); j++) {
        Ddi_BddComposeAcc(Ddi_BddarrayRead(delta_i, j), pi, newPiLit);
      }
      Ddi_Free(newPiLit);

      Ddi_BddComposeAcc(kCone, ns, delta_i);
      Ddi_Free(delta_i);
      if (myCare != NULL) {
        //        DdiAigRedRemovalAcc(kCone,care,-1);
      }
      Ddi_AigExistAcc(kCone, totPiVars, myCare, 1, 1, -1.0);
      Ddi_BddComposeAcc(kCone, ps, nsLit);

      if (abcOpt > 2) {
        ddiAbcOptAcc(kCone, -1.0);
      }

      Ddi_Free(newPiVars);
    } else {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "Verification Result: PASS.\n")
        );
      retVal = 1;
      break;
    }

  }

  Trav_MgrSetAssertFlag(travMgr, !retVal);

  Ddi_Free(myCare);
  Ddi_Free(pi);
  Ddi_Free(tr);
  Ddi_Free(trPlus);
  Ddi_Free(bad);
  Ddi_Free(unroll);
  Ddi_Free(trUnrolls);
  Ddi_Free(kCone);
  Ddi_Free(myInit);
  Ddi_Free(totPiVars);
  Ddi_Free(nsvars);
  Ddi_Free(pivars);
  Ddi_Free(smooth);
  Ddi_Free(psLit);
  Ddi_Free(nsLit);
  Ddi_Free(deltaPlus);

  return retVal;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatBwdInterpolantVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * care,
  int noCheck,
  int initBound,
  int lemmasSteps
)
{
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Varset_t *pivars, *smooth, *nsvars, *psvars;
  Ddi_Varset_t *totPiVars, *piPlusVars = NULL;
  Ddi_Bddarray_t *delta, *myDelta, *psLit, *nsLit;
  Ddi_Bdd_t *tr, *reached, *newS, *from,
    *bad, *to, *kFwdCone, *unroll, *myInvarspec;
  Ddi_Bdd_t *saveCone=NULL;
  Ddi_Bdd_t *reachedPlus = NULL;
  int again, i, j, nState;
  long startTime;               //, currTime;
  int cntR = 0, sat, k;
  int retVal = 0, verificationDone = 0;
  Ddi_Bdd_t *myCare = NULL;
  Ddi_Vararray_t *dynAbstrAux = NULL, *dynAbstrCut = NULL;
  Ddi_Bddarray_t *dynAbstrCutLits = NULL;
  Ddi_Bdd_t *rFile = NULL;

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Bddarray_t *lemmas = NULL;

  int dynAbstr = Trav_MgrReadDynAbstr(travMgr);
  int abstrRef = Trav_MgrReadAbstrRef(travMgr);
  int abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  int redRem = Ddi_MgrReadAigRedRemLevel(ddm);
  int abcOpt = Ddi_MgrReadAigAbcOptLevel(ddm);

  int activeIterOffset;
  int existOverAbstr = 0;
  int chkFalsePositive = 0;
  int init2init = 0;
  unsigned char *enAbstr = NULL;
  Ddi_Bddarray_t *initStub = NULL;
  int fullExistDone = 0;
  int enDynAbstr = 0;
  int maxDynAbstrTime = 600;

  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);

  initStub = Fsm_MgrReadInitStubBDD(fsmMgr);

  activeIterOffset = 0;
  //  rFile = Ddi_AigNetLoadBench(ddm, "r.bench", NULL);

  if (care == NULL) {
    myCare = Ddi_BddMakeConstAig(ddm, 1);
  } else {
    myCare = Ddi_BddDup(care);
  }
  myInvarspec = Ddi_BddDup(invarspec);

  if (lemmasSteps > 0) {
    /* GcP: update from lazy */
    int result = 0;

    lemmas = genLemmaClasses(travMgr, fsmMgr,
      init, initStub, invar, myInvarspec, myCare, NULL, lemmasSteps,
      1, 0, 0, &result, 0, NULL);
    Ddi_Free(lemmas);
  }


  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Ddi_VararrayDup(Fsm_MgrReadVarI(fsmMgr));
  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  nState = Ddi_BddarrayNum(delta);
  psLit = Ddi_BddarrayAlloc(ddm, nState);
  nsLit = Ddi_BddarrayAlloc(ddm, nState);

  //  Ddi_BddSwapVarsAcc(rFile,ps,ns);
  //  DdiAigArrayRedRemovalAcc (delta,myCare,-1,-1.0);

  myDelta = Ddi_BddarrayDup(delta);
  if (init2init) {
    Ddi_Var_t *v = Ddi_VarNew(ddm);
    Ddi_Bdd_t *c_i;

    Ddi_VarAttachName(v, "PDT_STALL_DUMMY_CONTROL");
    Ddi_VararrayInsertLast(pi, v);
    c_i = Ddi_BddMakeLiteralAig(v, 1);
    for (i = 0; i < Ddi_BddarrayNum(myDelta); i++) {
      Ddi_Bdd_t *d_i, *p_i;

      p_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);
      d_i = Ddi_BddIte(c_i, Ddi_BddarrayRead(myDelta, i), p_i);
      Ddi_BddarrayWrite(myDelta, i, d_i);
      Ddi_Free(d_i);
      Ddi_Free(p_i);
    }
    Ddi_Free(c_i);
  }


  nsvars = Ddi_VarsetMakeFromArray(ns);
  psvars = Ddi_VarsetMakeFromArray(ps);
  pivars = Ddi_VarsetMakeFromArray(pi);
  smooth = Ddi_VarsetMakeFromArray(ps);
  Ddi_VarsetUnionAcc(smooth, pivars);
  totPiVars = Ddi_VarsetMakeFromArray(pi);
  Ddi_VarsetSetArray(totPiVars);
  
  Ddi_MgrSetOption(ddm, Pdt_DdiLazyRate_c, fnum, 1.1);

  if (travMgr->settings.aig.targetEn > 0) {
#if 1
    Ddi_Bdd_t *r = Trav_TravSatBckAllSolVerif(travMgr, fsmMgr,
      init, invarspec, invar, travMgr->settings.aig.targetEn);
#else
    Ddi_Bdd_t *r = Trav_TravSatBckVerif(travMgr, fsmMgr,
      init, invarspec, invar, travMgr->settings.aig.targetEn, 0, 0);
#endif
    Ddi_Free(myInvarspec);
    Ddi_BddNotAcc(r);
    myInvarspec = r;
  }

  if (dynAbstr) {
    dynAbstrAux = Ddi_VararrayAlloc(ddm, nState);
    dynAbstrCut = Ddi_VararrayAlloc(ddm, nState);
    dynAbstrCutLits = Ddi_BddarrayAlloc(ddm, nState);
    enAbstr = Pdtutil_Alloc(unsigned char,
      nState
    );

    for (j = 0; j < Ddi_VararrayNum(ps); j++) {
      Ddi_Bdd_t *lit;
      char name[1000];
      Ddi_Var_t *v = Ddi_VararrayRead(ps, j);
      Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);

      sprintf(name, "dynAbstrAux_%s", Ddi_VarName(v));
      Ddi_VarAttachName(newv, name);
      Ddi_VararrayWrite(dynAbstrAux, j, newv);
      newv = Ddi_VarNewBeforeVar(v);
      sprintf(name, "dynAbstrCut_%s", Ddi_VarName(v));
      Ddi_VarAttachName(newv, name);
      Ddi_VararrayWrite(dynAbstrCut, j, newv);
      lit = Ddi_BddMakeLiteralAig(newv, 1);
      Ddi_BddarrayWrite(dynAbstrCutLits, j, lit);
      Ddi_Free(lit);
      enAbstr[j] = 1;
    }
    piPlusVars = Ddi_VarsetMakeFromArray(dynAbstrCut);
    Ddi_VarsetUnionAcc(piPlusVars, pivars);
  } else {
    piPlusVars = Ddi_VarsetDup(pivars);
  }
  if (initStub != NULL) {
    Ddi_Varset_t *stubVars = Ddi_BddarraySupp(initStub);

    Ddi_VarsetUnionAcc(piPlusVars, stubVars);
    Ddi_Free(stubVars);
  }
  //  reachedPlus = Trav_TravSatFwdApprox(travMgr,fsmMgr,init,invarspec,invar);

#if 1
  tr = Ddi_BddMakeConstAig(ddm, 1);
#else
  tr = Ddi_BddMakeConst(ddm, 1);
#endif
  for (i = 0; i < Ddi_BddarrayNum(myDelta); i++) {
    Ddi_Bdd_t *tr_i, *psLit_i, *nsLit_i;

#if 1
    nsLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);
#else
    nsLit_i = Ddi_BddMakeLiteral(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteral(Ddi_VararrayRead(ps, i), 1);
    Ddi_BddSetMono(Ddi_BddarrayRead(myDelta, i));
#endif
    Ddi_BddarrayWrite(nsLit, i, nsLit_i);
    Ddi_BddarrayWrite(psLit, i, psLit_i);
    tr_i = Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(myDelta, i));
    Ddi_BddAndAcc(tr, tr_i);
    Ddi_Free(tr_i);
    Ddi_Free(psLit_i);
    Ddi_Free(nsLit_i);
  }

  bad = Ddi_BddNot(myInvarspec);
  Ddi_Free(myInvarspec);

  if (lemmas != NULL) {
    Ddi_Bdd_t *myCheck;

    for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
      Ddi_BddAndAcc(myCare, Ddi_BddarrayRead(lemmas, i));
      Ddi_BddAndAcc(tr, Ddi_BddarrayRead(lemmas, i));
    }
    Ddi_Free(lemmas);
    myCheck = Ddi_BddAnd(myCare, bad);
    if (Ddi_AigSat(myCheck) != 1) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "Verification Result: PASS (lemmas).\n")
        );
      verificationDone = 1;
      retVal = 1;
    }
    Ddi_Free(myCheck);
  }

  unroll = Ddi_BddDup(tr);
  if (initStub != NULL) {
    kFwdCone = Ddi_BddMakeConstAig(ddm, 1);
    for (i = 0; i < Ddi_BddarrayNum(initStub); i++) {
      Ddi_Bdd_t *psLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);
      Ddi_Bdd_t *tr_i = Ddi_BddXnor(psLit_i, Ddi_BddarrayRead(initStub, i));

      Ddi_BddAndAcc(kFwdCone, tr_i);
      Ddi_Free(tr_i);
      Ddi_Free(psLit_i);
    }
  } else {
    kFwdCone = Ddi_BddDup(init);
  }

  startTime = util_cpu_time();

  for (k = 0;; k++) {

    Ddi_Bddarray_t *delta_i;
    Ddi_Bddarray_t *newPiLit;
    Ddi_Bdd_t *oldCone;
    Ddi_Bdd_t *checkBad;
    int abort = 0, step = 0;

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr),
        "\nAIG Backward Interpolant Main Iteration: %d (size=%d).\n\n", k,
        Ddi_BddSize(kFwdCone))
      );

    if (0) {
      Ddi_Bdd_t *r = DdiAigExistProjectByBdd(kFwdCone, NULL, 200000,
        psvars, -1.0, 0, 0);

      if (r != NULL) {
        Ddi_BddSetMono(r);
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "#Reached States = %g.\n",
            Ddi_BddCountMinterm(r, Ddi_VararrayNum(ps)))
          );
        Ddi_Free(r);
      }
    }


    checkBad = Ddi_BddAnd(bad, kFwdCone);
    if ((!noCheck) && (Ddi_AigSat(checkBad) == 1)) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "Verification Result: FAIL.\n")
        );
      Ddi_Free(checkBad);
      break;
    }
    Ddi_Free(checkBad);

    if (initBound >= 0 && k < initBound || activeIterOffset > 0) {
      abort = 1;
      if (activeIterOffset) {
        activeIterOffset--;
      }
    } else {

      reached = Ddi_BddDup(bad);
      //      reached = Ddi_BddNot(rFile);

      from = Ddi_BddDup(reached);

      again = 1;

      if (abcOpt == 3) {
        //ddiAbcOptAcc(unroll, -1.0);
        //ddiAbcOptAcc (kFwdCone,-1.0);
        //        DdiAigRedRemovalAcc (kFwdCone,myCare,-1);
      }
      if (redRem == 3) {
        DdiAigRedRemovalAcc(unroll, NULL, -1, -1.0);
        DdiAigRedRemovalAcc(kFwdCone, myCare, -1, -1.0);
      }

      for (step = 0; again; step++) {
        int sizeAig;

        //Ddi_Bdd_t *trAux;
        Ddi_Bdd_t *careAig = NULL;
        Ddi_Bdd_t *over = NULL, *toPlus = NULL;
        Ddi_Bdd_t *coneOpt = Ddi_BddDup(kFwdCone);

        //        Ddi_Bdd_t *coneOpt = Ddi_BddDup(rFile);
        Ddi_Bdd_t *chkFrom;
        int fullSat;

        careAig = Ddi_BddNot(reached);
        toPlus = Ddi_BddNot(from);

        //      Pdtutil_Assert(!Ddi_AigSatAnd(from,coneOpt,NULL),"wrong inner from");

        Ddi_BddComposeAcc(from, ps, nsLit);
        if (1) {
          int tryPart=0;
          if (tryPart) {
            Ddi_Bdd_t *p = Ddi_AigPartitionTop(from, 1);
            int j;
            for (j=0; j<Ddi_BddPartNum(p); j++) 
              Ddi_BddComposeAcc(Ddi_BddPartRead(p,j), ns, myDelta);
            Ddi_Free(p);
          }
          Ddi_BddComposeAcc(from, ns, myDelta);
        }
        else {
          int c;
          Ddi_Bdd_t *a = Ddi_BddMakeMono(from);
          Ddi_Bddarray_t *d = Ddi_BddarrayDup(myDelta);
          int i;

          for (i = 0; i < Ddi_BddarrayNum(d); i++) {
            Ddi_BddSetMono(Ddi_BddarrayRead(d, i));
          }
          Ddi_BddComposeAcc(from, ns, myDelta);
          Ddi_BddComposeAcc(a, ns, d);
          Ddi_BddSetAig(a);
          Ddi_BddXorAcc(a, from);
          c = Ddi_AigSat(a);
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "WRONG COMP %d.\n", c)
            );
          Ddi_Free(a);
        }

        //      fullSat = Ddi_AigSatAnd(from,coneOpt,NULL);
        if (chkFalsePositive) {
          chkFrom = Ddi_BddDup(from);
        }
//        DdiAigRedRemovalAcc (from,careAig,-1);
//      if (care != NULL) {
//          DdiAigRedRemovalAcc (from,care,-1);
//      }
        if (myCare != NULL) {
          Ddi_BddAndAcc(from, myCare);
        }
        if (0) {
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "OPT from: ")
            );
          DdiAigRedRemovalAcc(from, toPlus, -1, -1.0);
          Ddi_BddAndAcc(from, toPlus);
        }

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr),
            "\nAIG Interpolant Inner Iteration: %d\n\n (|From|=%d -> ", step,
            Ddi_BddSize(from))
          );

#if 0
        Ddi_AigExistAcc(from, pivars, careAig, 0, 0, -1.0);
        over = Ddi_BddDup(from);
        DdiAigExistOverAcc(over, pivars, NULL);
#endif

        if (dynAbstr) {
          if (dynAbstr > 2) {
            int doTernary;

            do {
              Ddi_Bdd_t *auxF;
              Ddi_Varset_t *ternaryVars = Ddi_VarsetVoid(ddm);
              Ddi_Varset_t *sm = Ddi_BddSupp(from);

              Ddi_VarsetDiffAcc(sm, psvars);

              auxF = DdiAigTernaryInterpolantAcc(from, coneOpt, sm, sm,
                ternaryVars, careAig, 1, 0,
                travMgr->settings.aig.lazyTimeLimit);

              doTernary = 0;
              if (auxF != NULL && Ddi_VarsetNum(ternaryVars) > 0) {
                doTernary = 1;
                Ddi_Free(from);
                from = Ddi_BddDup(auxF);
                //            Ddi_VarsetUnionAcc(ternarySmooth,ternaryVars);
              }
              Ddi_Free(sm);
              Ddi_Free(auxF);
              Ddi_Free(ternaryVars);
            } while (doTernary);
          } else if (dynAbstr > 3) {
            int j, nAbstr = 0;
            Ddi_Bdd_t *chkProd = Ddi_BddAnd(from, coneOpt);
            Ddi_Varset_t *sm = Ddi_BddSupp(from);
            Ddi_Vararray_t *smA;

            Ddi_VarsetDiffAcc(sm, psvars);
            smA = Ddi_VararrayMakeFromVarset(sm, 1);
            Ddi_Free(sm);
            if (careAig != NULL) {
              Ddi_BddAndAcc(chkProd, careAig);
            }
            if (Ddi_AigSat(chkProd)) {
              Ddi_Free(from);
            } else {
              for (j = 0; j < Ddi_VararrayNum(smA); j++) {
                Ddi_Var_t *smV = Ddi_VararrayRead(smA, j);
                Ddi_Bdd_t *chkProdAbstr = Ddi_BddDup(chkProd);

                DdiAigExistVarOverAcc(chkProdAbstr, smV, careAig);
                if (!Ddi_AigSat(chkProdAbstr)) {
                  /* valid abstraction */
                  nAbstr++;
                  Ddi_Free(chkProd);
                  chkProd = Ddi_BddDup(chkProdAbstr);
                  DdiAigExistVarOverAcc(from, smV, careAig);
                }
                Ddi_Free(chkProdAbstr);
              }
              if (nAbstr > 0) {
                Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                  fprintf(tMgrO(travMgr), "Ternary abstraction of %d vars.\n",
                    nAbstr)
                  );
              }
            }
            Ddi_Free(chkProd);
            Ddi_Free(smA);
          }
          if (from != NULL && enDynAbstr) {
            long startTime, currTime;
            int doAbort;
            Ddi_Bdd_t *auxFrom = Ddi_BddCompose(from, ps, dynAbstrCutLits);
            int mySat = Ddi_AigSatAnd(from, coneOpt, NULL);

            Ddi_Free(from);
            //        sprintf(wfile,"INTERP_DYN_ABSTR_%d_%d",k,step);
            startTime = util_cpu_time();


            from = Ddi_AigAbstrVarsForInterpolant(auxFrom, coneOpt,
              dynAbstrCut, ps, dynAbstrAux, NULL, enAbstr, &doAbort);

            if (doAbort) {
              Ddi_Free(from);
              from =
                Ddi_AigAbstrVarsForInterpolantByRefinement(auxFrom, coneOpt,
                dynAbstrCut, ps, dynAbstrAux, NULL, enAbstr);
            }
            currTime = util_cpu_time();

            if (mySat) {
              Pdtutil_Assert(from == NULL, "Wrong dynabstr 1");
            } else {
              Pdtutil_Assert(from != NULL, "Wrong dynabstr 2");
            }
#if 0
            if (step >= 3 && k > 3) {
              for (j = 0; j < Ddi_VararrayNum(ps); j++) {
                enAbstr[j] = 0;
              }
            }
#else
            if ((currTime - startTime) / 1000 > maxDynAbstrTime) {
              // disable further steps of dyn abstraction
              enDynAbstr = 0;
              Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                fprintf(tMgrO(travMgr),
                  "Disabling DYN abstraction at step %d.\n", step)
                );
            }
#endif
            Ddi_Free(auxFrom);
          }
#if 0
          else {
            Ddi_Free(coneOpt);
            coneOpt = Ddi_BddDup(init);
          }
#endif
        }
        to = NULL;

        fullExistDone = 0;
        if (from != NULL) {
          if (existOverAbstr) {
            Ddi_Vararray_t *sm;
            Ddi_Bdd_t *chk;
            int j;
            int abstrCnt = 0;

            chk = Ddi_BddAnd(from, coneOpt);
            sat = Ddi_AigSat(chk);
            Ddi_Free(chk);
            if (!sat) {
              Ddi_Varset_t *piSupp, *auxSupp;

              if (dynAbstr > 3) {
                int size1, size = Ddi_BddSize(from);

#if 1
                Ddi_Bdd_t *bddSmooth = DdiAigExistProjectByBdd(from, careAig,
                  size * 5, psvars, -1.0, 0, 0);
#else
                Ddi_Bdd_t *bddSmooth = DdiAigExistProjectByBdd(from, NULL,
                  size * 5, psvars, -1.0, 0, 0);
#endif
                if (bddSmooth != NULL
                  && ((size1 = Ddi_BddSize(bddSmooth)) < 1.5 * size)) {
                  DdiGenericDataCopy((Ddi_Generic_t *) from,
                    (Ddi_Generic_t *) bddSmooth);
                  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                    Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr),
                      "BDD exist: %d -> %d.\n", size, size1)
                    );
                }
                Ddi_Free(bddSmooth);
              }

              if (dynAbstr > 3) {
                /* exact preimg */
                Ddi_AigExistAcc(from, piPlusVars, careAig, 0, 0, -1.0);
              } else {
                if (dynAbstr > 2) {
                  int doTernary;

                  do {
                    Ddi_Bdd_t *auxF;
                    Ddi_Varset_t *ternaryVars = Ddi_VarsetVoid(ddm);
                    Ddi_Varset_t *sm = Ddi_BddSupp(from);

                    Ddi_VarsetIntersectAcc(sm, piPlusVars);

                    auxF = DdiAigTernaryInterpolantAcc(from, coneOpt, sm, sm,
                      ternaryVars, myCare, 1, 0,
                      travMgr->settings.aig.lazyTimeLimit);

                    doTernary = 0;
                    if (auxF != NULL && Ddi_VarsetNum(ternaryVars) > 0) {
                      doTernary = 1;
                      Ddi_Free(from);
                      from = Ddi_BddDup(auxF);
                    }
                    Ddi_Free(sm);
                    Ddi_Free(auxF);
                    Ddi_Free(ternaryVars);
                  } while (doTernary);
                }
                /* lazy preimg */
                //    Ddi_AigExistAcc(from,piPlusVars,myCare,3,3,100.0);
                // ddiAbcOptAcc (from,-1.0);
                //      Ddi_AigExistAcc(from,piPlusVars,myCare,3,3,100.0);
                // ddiAbcOptAcc (from,-1.0);
              }
              piSupp = Ddi_BddSupp(from);
              Ddi_VarsetIntersectAcc(piSupp, pivars);
              sm = Ddi_VararrayMakeFromVarset(piSupp, 1);
              for (j = 0; 0 && j < Ddi_VararrayNum(sm); j++) {
                Ddi_Var_t *v = Ddi_VararrayRead(sm, j);
                Ddi_Bdd_t *auxFrom = Ddi_BddDup(from);

                DdiAigExistVarOverAcc(auxFrom, v, NULL);
                chk = Ddi_BddAnd(auxFrom, coneOpt);
                if (!Ddi_AigSat(chk)) {
                  abstrCnt++;
                  DdiGenericDataCopy((Ddi_Generic_t *) from,
                    (Ddi_Generic_t *) auxFrom);
                }
                Ddi_Free(chk);
                Ddi_Free(auxFrom);
              }
              Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                Pdtutil_VerbLevelNone_c,
                fprintf(tMgrO(travMgr), "OverAbstr: %d/%d.\n", abstrCnt,
                  Ddi_VararrayNum(sm))
                );
              auxSupp = Ddi_BddSupp(from);
              Ddi_VarsetIntersectAcc(auxSupp, piPlusVars);
              if (Ddi_VarsetIsVoid(auxSupp)) {
                to = Ddi_BddDup(from);
                fullExistDone = 1;
              } else if (0 && Ddi_VarsetNum(auxSupp) < 10) {
                /* exact preimg */
                Ddi_AigExistAcc(from, piPlusVars, careAig, 0, 0, -1.0);
              }
              Ddi_Free(auxSupp);
              Ddi_Free(sm);
              Ddi_Free(piSupp);
              //          Pdtutil_Assert(!Ddi_AigSatAnd(from,coneOpt,NULL),"Wrong over abstr");
            }
          }

          if (0) {
            Ddi_Bdd_t *aa = Ddi_BddAnd(from, coneOpt);

            sat = Ddi_AigSat(aa);
            if (!sat) {
              Ddi_Varset_t *smooth = Ddi_BddSupp(from);

              Ddi_VarsetDiffAcc(smooth, psvars);
              if (Ddi_VarsetIsVoid(smooth)) {
                to = Ddi_BddDup(from);
              } else {
                to =
                  Ddi_AigSatAndWithInterpolant(from, coneOpt, psvars, NULL,
                  NULL, NULL, NULL, NULL, &sat, 0, 0, -1.0);
              }
              Ddi_Free(smooth);
            } else
              to = NULL;
            Ddi_Free(aa);
          } else if (to == NULL) {
#if 0
            Ddi_Bddarray_t *myCone = Ddi_BddarrayAlloc(ddm, 0);
            Ddi_Vararray_t *myPsv = Ddi_VararrayAlloc(ddm, 0);
            int j;

            for (j = 0; j < Ddi_VararrayNum(ps); j++) {
              if (!enAbstr[j]) {
                Ddi_BddarrayInsertLast(myCone, Ddi_BddarrayRead(coneOpt, j));
                Ddi_VararrayInsertLast(myPsv, Ddi_VararrayRead(ps, j));
              }
            }
            to = Ddi_AigSatAndWithInterpolant(from, myCone, myPsv, NULL, NULL,
              NULL, NULL, &sat, 0, 0, -1.0);
            Ddi_Free(myCone);
            Ddi_Free(myPsv);
#endif
            int useMinisat22 = ddm->settings.aig.itpDrup; 
            if (to == NULL && (1 || enDynAbstr) /* && Ddi_BddSize(from) > 500*/) {
              if (useMinisat22) {
                to =
                  Ddi_AigSat22AndWithInterpolant(NULL,
                                   from,coneOpt,NULL,
				   psvars, NULL,NULL,0,
				   0,NULL,
                                     &sat, 0, 1, 0, -1.0);
              }
              else {
                to =
                  Ddi_AigSatAndWithInterpolant(from,
                    coneOpt, psvars, NULL, NULL,
                    NULL, NULL, NULL, &sat, 0, 0, -1.0);
              }
            }
            if (0 && to == NULL) {
              to = Ddi_BddDup(from);
              Ddi_AigExistAcc(to, piPlusVars, careAig, 0, 0, 30.0);
            }
            int itpTwice = 0;
            if (to != NULL && itpTwice>0 &&
                Ddi_BddSize(to)>itpTwice) {
              Ddi_Bdd_t *coneAux = Ddi_BddNot(to);
              Ddi_Bdd_t *to2 =
                Ddi_AigSatAndWithInterpolant(from, coneAux, psvars, NULL, NULL,
                NULL, NULL, NULL, &sat, 0, 0, -1.0);
              if (Ddi_BddSize(to2)<Ddi_BddSize(to)) {
                Ddi_Free(to);
                to = Ddi_BddDup(to2);
              }
              Ddi_Free(coneAux);
              Ddi_Free(to2);
            }
          }

          if (chkFalsePositive) {
            if (to != NULL) {
              Ddi_BddDiffAcc(chkFrom, to);
              if (careAig != NULL) {
                Ddi_BddAndAcc(chkFrom, careAig);
              }
              Pdtutil_Assert(Ddi_AigSat(chkFrom) != 1, "false positive");
            }
            Ddi_Free(chkFrom);
          }

          if (0 && to != NULL && Ddi_BddSize(to) > 100) {
            Ddi_Bdd_t *to2;

#if 1
            to2 = Ddi_BddDup(to);
            Ddi_BddNotAcc(coneOpt);
            DdiAigExistOverPartialAcc(to2,
              psvars, coneOpt, Ddi_BddSize(to2) / 2);
            Ddi_BddNotAcc(coneOpt);
#else
            Ddi_Bdd_t *myFrom = Ddi_BddDup(from);

            Ddi_BddNotAcc(coneOpt);
            DdiAigExistOverPartialAcc(myFrom,
              smooth, coneOpt, Ddi_BddSize(myFrom) / 2);
            Ddi_AigExistAcc(myFrom, totPiVars, NULL, 1, 1, -1.0);
            Ddi_BddNotAcc(coneOpt);
            to2 =
              Ddi_AigSatAndWithInterpolant(myFrom, coneOpt, psvars, NULL, NULL,
              NULL, NULL, &sat, 0, 0, -1.0);
            Ddi_Free(myFrom);
#endif
            if (to2 != NULL && Ddi_BddSize(to2) < Ddi_BddSize(to)) {
              Ddi_Free(to);
              to = to2;
              Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                Pdtutil_VerbLevelNone_c,
                fprintf(tMgrO(travMgr), "|to2:%d|.\n", Ddi_BddSize(to))
                );
            } else {
              Ddi_Free(to2);
            }
          }
        }

        if (to != NULL && over != NULL) {
          Ddi_Bdd_t *outside = Ddi_BddDiff(to, over);

          if (Ddi_AigSat(outside)) {
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "overapprox refinement: %d.\n",
                Ddi_BddSize(over))
              );
            DdiAigRedRemovalAcc(to, over, -1, -1.0);
            DdiAigRedRemovalAcc(over, to, -1, -1.0);
            Ddi_BddAndAcc(to, over);
          }
          //          DdiAigRedRemovalAcc (to,toPlus,-1);
          Ddi_Free(outside);
        }

        Ddi_Free(over);
        Ddi_Free(toPlus);
        Ddi_Free(coneOpt);

        Ddi_Free(careAig);

        if ((sat || to == NULL)) {
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "Inner loop ABORT.\n")
            );
          Ddi_Free(to);
          //        Pdtutil_Assert(fullSat,"Wrong SAT result");
          abort = 1;
          break;
        }


        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "|to:%d|.\n", Ddi_BddSize(to))
          );

        newS = Ddi_BddDiff(to, reached);
        if (reachedPlus != NULL) {
          Ddi_BddAndAcc(newS, reachedPlus);
        }

        careAig = Ddi_BddNot(reached);
        again = Ddi_AigSat(newS) == 1;
        Ddi_Free(newS);

        Ddi_BddOrAcc(reached, to);

        if (0 && dynAbstr == 2 && !fullExistDone    /*&&
                                                       Ddi_BddSize(from) < Ddi_BddSize(to) */ ) {
          // mew pi vars
          Ddi_Vararray_t *smoothVarsArray;
          Ddi_Varset_t *fromSupp = Ddi_BddSupp(from);
          Ddi_Varset_t *smoothVars = Ddi_VarsetMakeFromArray(dynAbstrCut);
          char suffix[20];

          sprintf(suffix, "%d", step + 1);

          Ddi_VarsetUnionAcc(smoothVars, pivars);
          Ddi_VarsetIntersectAcc(smoothVars, fromSupp);
          smoothVarsArray = Ddi_VararrayMakeFromVarset(smoothVars, 1);

          Ddi_Vararray_t *newPiVars =
            Ddi_VararrayMakeNewVars(smoothVarsArray, "PDT_ITP_FWDUNR_PI",
            suffix, 1);
          Ddi_Bddarray_t *newPiLits =
            Ddi_BddarrayMakeLiteralsAig(newPiVars, 1);
          Ddi_Varset_t *newPiVarset = Ddi_VarsetMakeFromArray(newPiVars);

          Ddi_BddComposeAcc(from, smoothVarsArray, newPiLits);
          Ddi_VarsetUnionAcc(piPlusVars, newPiVarset);
          Ddi_Free(newPiVarset);
          Ddi_Free(newPiVars);
          Ddi_Free(newPiLits);
          Ddi_Free(fromSupp);
          Ddi_Free(smoothVars);
          Ddi_Free(smoothVarsArray);
        } else {
          Ddi_Free(from);
          from = Ddi_BddDup(to);
        }

        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "Opt by Interpolant: %d -> ",
            Ddi_BddSize(from))
          );
        DdiAigRedRemovalAcc(from, careAig, -1, -1.0);
        //  DdiAigArrayRedRemovalAcc (delta,myCare,-1);
        if (myCare != NULL) {
          //  DdiAigRedRemovalAcc (from,myCare,-1);
        }
        if (reachedPlus != NULL) {
          DdiAigRedRemovalAcc(from, reachedPlus, -1, -1.0);
          DdiAigRedRemovalAcc(reached, reachedPlus, -1, -1.0);
        }
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "%d -> ", Ddi_BddSize(from))
          );
        //        Ddi_AigOptByInterpolantAcc(from, careAig);
        //Ddi_AigOptByBdd(from,-1.0);
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "%d.\n", Ddi_BddSize(from))
          );
        Ddi_Free(careAig);
        Ddi_Free(to);

        //    Ddi_AigExistAcc(tr,totPiVars,NULL,1,0);

        //    Ddi_AigOptByBddPartial(tr,careAig);
        //    Ddi_BddSetMono(tr);
        //    Ddi_BddSetAig(tr);
        //    Ddi_AigOptByBddPartial(tr,careAig);
        //      Ddi_Free(careAig);

        sizeAig = Ddi_BddSize(tr);
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "   |tr|=%d |reached|=%d.\n",
            Ddi_BddSize(tr), Ddi_BddSize(reached))
          );

        if (cntR) {
          Ddi_Bdd_t *r = Ddi_BddMakeMono(reached);

          fprintf(tMgrO(travMgr), "#Reached States = %g.\n",
            Ddi_BddCountMinterm(r, Ddi_VararrayNum(ps)));
          Ddi_Free(r);
        }

      }

      Ddi_Free(reached);
      Ddi_Free(from);

      activeIterOffset = step;

    }

    if (abort) {

      Ddi_Varset_t *newPiVars = Ddi_VarsetVoid(ddm);
      int j;

      newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
      for (j = 0; j < Ddi_VararrayNum(pi); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
        Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), k);
        Ddi_VarAttachName(newv, name);
        Ddi_VarsetAddAcc(totPiVars, newv);
        Ddi_VarsetAddAcc(newPiVars, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newPiLit, j, newvLit);
        Ddi_Free(newvLit);
      }

      delta_i = Ddi_BddarrayDup(myDelta);
      Ddi_BddarrayComposeAcc(delta_i, pi, newPiLit);

      if (saveCone!=NULL) {
        oldCone = saveCone;
        Ddi_Free(kFwdCone);
        saveCone = NULL;
      }
      else 
        oldCone = kFwdCone;
      if (k == 0) {
        Ddi_BddComposeAcc(unroll, pi, newPiLit);
      } else {
        Ddi_BddComposeAcc(unroll, ps, delta_i);
      }

      if (abcOpt > 3) {
        ddiAbcOptAcc(unroll, -1.0);
      }

      Ddi_Free(newPiLit);

      kFwdCone = Ddi_BddDup(unroll);

      if (initStub != NULL) {
        Ddi_BddComposeAcc(kFwdCone, ps, initStub);
      } else {
        Ddi_AigConstrainCubeAcc(kFwdCone, init);
      }
      Ddi_BddComposeAcc(kFwdCone, ns, psLit);
      saveCone = Ddi_BddDup(kFwdCone);
      Ddi_BddOrAcc(kFwdCone,oldCone);

      if (0 && abcOpt > 2) {
        ddiAbcOptAcc(kFwdCone, -1.0);
      }

      Ddi_Free(delta_i);
      Ddi_Free(oldCone);

      Ddi_Free(newPiVars);

      if (activeIterOffset > 0) {
        activeIterOffset /= 2;
      }

    } else {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "Verification Result: PASS.\n")
        );
      break;
    }

  }

  if (dynAbstr) {
    Ddi_Free(dynAbstrCut);
    Ddi_Free(dynAbstrCutLits);
    Ddi_Free(dynAbstrAux);
    Pdtutil_Free(enAbstr);
  }

  Trav_MgrSetAssertFlag(travMgr, !retVal);

  Ddi_Free(pi);
  Ddi_Free(myDelta);
  Ddi_Free(piPlusVars);
  Ddi_Free(myCare);
  Ddi_Free(reachedPlus);
  Ddi_Free(tr);
  Ddi_Free(bad);
  Ddi_Free(kFwdCone);
  Ddi_Free(saveCone);
  Ddi_Free(unroll);
  Ddi_Free(totPiVars);
  Ddi_Free(nsvars);
  Ddi_Free(psvars);
  Ddi_Free(pivars);
  Ddi_Free(smooth);
  Ddi_Free(psLit);
  Ddi_Free(nsLit);
  return retVal;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Trav_TravSatFwdApprox(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar
)
{
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Varset_t *pivars, *smooth, *nsvars, *psvars;
  Ddi_Varset_t *totPiVars;
  Ddi_Bddarray_t *delta, *psLit, *nsLit;
  Ddi_Bdd_t *tr, *reached, *bad, *kFwdCone, *unroll, *myInvarspec;  //, *from, *to;
  int again, i, nState;
  long startTime;               //, currTime;
  int cntR = 0, k;

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);

  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  nState = Ddi_BddarrayNum(delta);
  psLit = Ddi_BddarrayAlloc(ddm, nState);
  nsLit = Ddi_BddarrayAlloc(ddm, nState);

  nsvars = Ddi_VarsetMakeFromArray(ns);
  psvars = Ddi_VarsetMakeFromArray(ps);
  pivars = Ddi_VarsetMakeFromArray(pi);
  smooth = Ddi_VarsetMakeFromArray(ps);
  Ddi_VarsetUnionAcc(smooth, pivars);
  totPiVars = Ddi_VarsetMakeFromArray(pi);

  Ddi_MgrSetOption(ddm, Pdt_DdiLazyRate_c, fnum, -1.0);

  myInvarspec = Ddi_BddDup(invarspec);

#if 1
  tr = Ddi_BddMakeConstAig(ddm, 1);
#else
  tr = Ddi_BddMakeConst(ddm, 1);
#endif
  for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
    Ddi_Bdd_t *tr_i, *psLit_i, *nsLit_i;

#if 1
    nsLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);
#else
    nsLit_i = Ddi_BddMakeLiteral(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteral(Ddi_VararrayRead(ps, i), 1);
    Ddi_BddSetMono(Ddi_BddarrayRead(delta, i));
#endif
    Ddi_BddarrayWrite(nsLit, i, nsLit_i);
    Ddi_BddarrayWrite(psLit, i, psLit_i);
    tr_i = Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(delta, i));
    Ddi_BddAndAcc(tr, tr_i);
    Ddi_Free(tr_i);
    Ddi_Free(psLit_i);
    Ddi_Free(nsLit_i);
  }

  bad = Ddi_BddNot(myInvarspec);
  Ddi_Free(myInvarspec);

  unroll = Ddi_BddDup(tr);

  startTime = util_cpu_time();
  reached = Ddi_BddDup(init);
  Ddi_BddComposeAcc(reached, ps, nsLit);

  for (k = 0, again = 1; again; k++) {

    Ddi_Bddarray_t *delta_i;
    Ddi_Bddarray_t *newPiLit;
    Ddi_Bdd_t *newstates;       //, *checkBad;
    Ddi_Bdd_t *care;

    //int abort = 0, step = 0;
    Ddi_Varset_t *newPiVars = Ddi_VarsetVoid(ddm);
    int j;

    newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
    for (j = 0; j < Ddi_VararrayNum(pi); j++) {
      char name[1000];
      Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
      Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
      Ddi_Bdd_t *newvLit;

      sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), k);
      Ddi_VarAttachName(newv, name);
      Ddi_VarsetAddAcc(totPiVars, newv);
      Ddi_VarsetAddAcc(smooth, newv);
      Ddi_VarsetAddAcc(newPiVars, newv);
      newvLit = Ddi_BddMakeLiteralAig(newv, 1);
      Ddi_BddarrayWrite(newPiLit, j, newvLit);
      Ddi_Free(newvLit);
    }

    delta_i = Ddi_BddarrayDup(delta);
    for (j = 0; j < Ddi_BddarrayNum(delta_i); j++) {
      Ddi_BddComposeAcc(Ddi_BddarrayRead(delta_i, j), pi, newPiLit);
    }

    if (k == 0) {
      Ddi_BddComposeAcc(unroll, pi, newPiLit);
    } else {
      Ddi_BddComposeAcc(unroll, ps, delta_i);
    }

    Ddi_Free(newPiLit);

    kFwdCone = Ddi_BddDup(unroll);

    Ddi_AigConstrainCubeAcc(kFwdCone, init);

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr),
        "AIG FWD Approximate Iteration %d; Unroll: %d; Reached: %d.\n", k,
        Ddi_BddSize(kFwdCone), Ddi_BddSize(reached))
      );

    if (1) {
      care = Ddi_BddNot(reached);
      //      Ddi_AigExistAcc(kFwdCone,smooth,care,1,0);
      DdiAigExistOverAcc(kFwdCone, smooth, care);
      Ddi_Free(care);
    } else {
      care = Ddi_BddNot(reached);
      Ddi_AigExistAcc(kFwdCone, smooth, care, 0 /*partial */ , 0, -1.0);
      Ddi_Free(care);
    }

    newstates = Ddi_BddDiff(kFwdCone, reached);

    again = Ddi_AigSat(newstates) == 1;

    Ddi_BddOrAcc(reached, kFwdCone);

    if (cntR) {
      Ddi_Bdd_t *r = Ddi_BddMakeMono(reached);

      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "   # Reached states = %g.\n",
          Ddi_BddCountMinterm(r, Ddi_VararrayNum(ps)))
        );
      Ddi_Free(r);
    }

    Ddi_Free(newstates);
    Ddi_Free(delta_i);
    Ddi_Free(kFwdCone);

    Ddi_Free(newPiVars);

  }

  if (cntR) {
    Ddi_Bdd_t *one = Ddi_BddMakeConst(ddm, 1);

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "   # Total Space states = %g.\n",
        Ddi_BddCountMinterm(one, Ddi_VararrayNum(ps)))
      );
    Ddi_Free(one);
  }

  Ddi_Free(tr);
  Ddi_Free(bad);
  Ddi_Free(unroll);
  Ddi_Free(totPiVars);
  Ddi_Free(nsvars);
  Ddi_Free(psvars);
  Ddi_Free(pivars);
  Ddi_Free(smooth);
  Ddi_Free(psLit);
  Ddi_Free(nsLit);

  return (reached);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Trav_TravSatBckAllSolVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  int maxIter
)
{
  Ddi_Vararray_t *pi, *ps;
  Ddi_Varset_t *totPiVars;
  Ddi_Bddarray_t *delta;
  Ddi_Bdd_t *reached, *unroll, *to, *myInvarspec;
  int sat = 0, i, fixPoint = 0;
  int cntR = 0;
  long startTime;               //, currTime;
  int noCheck = 0;

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);

  ps = Fsm_MgrReadVarPS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  delta = Fsm_MgrReadDeltaBDD(fsmMgr);

  myInvarspec = Ddi_BddDup(invarspec);

  unroll = Ddi_BddNot(myInvarspec);

  startTime = util_cpu_time();
  reached = Ddi_BddMakeConstAig(ddm, 0);
  totPiVars = Ddi_VarsetMakeFromArray(pi);

  for (i = 0; !fixPoint && !sat; i++) {
    Ddi_Bdd_t *check;
    int sat1;

    if (maxIter >= 0 && i > maxIter)
      break;

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr),
        "AIG check at bound %d (AIG size: %d / r: %d).\n", i,
        Ddi_BddSize(unroll), Ddi_BddSize(reached))
      );

    if (!noCheck) {
      check = Ddi_BddAnd(unroll, init);
      if (strcmp(travMgr->settings.aig.satSolver, "csat") == 0) {
        sat1 = Ddi_AigSatCircuit(check);
      } else {
        sat1 = Ddi_AigSat(check);
      }
      /*Pdtutil_Assert(sat==sat2,"wrong result of circuit sat"); */
      if (sat1 == 1) {
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "Failure at bound %d.\n", i)
          );
        sat = 1;
      }
      Ddi_Free(check);
    }

    if (!sat) {
      int j, sizeAig;
      Ddi_Bddarray_t *delta_i;
      Ddi_Bdd_t *invarspec_i;
      Ddi_Vararray_t *newPi = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(pi));
      Ddi_Bddarray_t *newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
      Ddi_Bdd_t *careAig = Ddi_BddNot(reached);

      for (j = 0; j < Ddi_VararrayNum(pi); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
        Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), i);
        Ddi_VarAttachName(newv, name);
        Ddi_VararrayWrite(newPi, j, newv);
        Ddi_VarsetAddAcc(totPiVars, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newPiLit, j, newvLit);
        Ddi_Free(newvLit);
      }

      if (0) {
        Ddi_Varset_t *suppd = Ddi_BddSupp(unroll);
        Ddi_Bddarray_t *d2 = Ddi_BddarrayAlloc(ddm, 0);
        int k, i;

        for (i = 0; i < Ddi_VararrayNum(ps); i++) {
          if (Ddi_VarInVarset(suppd, Ddi_VararrayRead(ps, i))) {
            Ddi_BddarrayInsertLast(d2, Ddi_BddarrayRead(delta, i));
          }
        }
        if (Ddi_BddarrayNum(d2) > 0) {
          Ddi_AigArrayExistPartialAcc(d2, totPiVars, careAig);
        }
        for (i = 0, k = 0; i < Ddi_VararrayNum(ps); i++) {
          if (Ddi_VarInVarset(suppd, Ddi_VararrayRead(ps, i))) {
            Ddi_BddarrayWrite(delta, i, Ddi_BddarrayRead(d2, k++));
          }
        }
        Pdtutil_Assert(k == Ddi_BddarrayNum(d2), "Wrong K in d2");
        Ddi_Free(suppd);
        Ddi_Free(d2);
      }

      sizeAig = Ddi_BddarraySize(delta);
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "|delta|=%d.\n", sizeAig)
        );

      delta_i = Ddi_BddarrayDup(delta);
      for (j = 0; j < Ddi_BddarrayNum(delta_i); j++) {
        Ddi_BddComposeAcc(Ddi_BddarrayRead(delta_i, j), pi, newPiLit);
      }
      Ddi_BddComposeAcc(unroll, ps, delta_i);
      invarspec_i = Ddi_BddCompose(myInvarspec, pi, newPiLit);

      check = Ddi_BddAnd(unroll, careAig);
      if (strcmp(travMgr->settings.aig.satSolver, "csat") == 0) {
        sat1 = Ddi_AigSatCircuit(check);
      } else {
        sat1 = Ddi_AigSat(check);
      }
      /*Pdtutil_Assert(sat==sat2,"wrong result of circuit sat"); */
      if (sat1 == 0) {
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "Fix point at bound %d.\n", i)
          );
        fixPoint = 1;
      }
      Ddi_Free(check);

      if (!fixPoint) {
        //        DdiAigRedRemovalAcc (unroll,careAig,-1);
#if 0
        Ddi_AigExistAcc(unroll, totPiVars, careAig, 1 /*partial */ , 1, -1.0);
#endif
        to = Ddi_BddDup(unroll);
#if 0
        Ddi_AigExistAcc(to, totPiVars, careAig, 0, 0, -1.0);
#else
        Ddi_AigExistAllSolutionAcc(to, totPiVars, careAig, NULL, 2);
        DdiAigRedRemovalAcc(to, careAig, -1, -1.0);
#endif
#if 1
        Ddi_BddNotAcc(to);
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "# RED-R: ")
          );
        DdiAigRedRemovalAcc(reached, to, -1, -1.0);
        Ddi_BddNotAcc(to);
#endif
        Ddi_BddOrAcc(reached, to);

        if (cntR) {
          Ddi_Bdd_t *myR = Ddi_BddMakeMono(reached);

          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "# Reached states = %g.\n",
              Ddi_BddCountMinterm(myR, Ddi_VararrayNum(ps)))
            );
          Ddi_Free(myR);
        }

        if (0 && Ddi_BddSize(to) < Ddi_BddSize(unroll)) {
          //        Ddi_Free(unroll);
          //        unroll = Ddi_BddDup(to);
        } else {
          Ddi_AigExistAcc(unroll, totPiVars, careAig, 1 /*partial */ , 1,
            -1.0);
        }
        Ddi_Free(to);
      }

      Ddi_Free(careAig);
      Ddi_Free(invarspec_i);
      Ddi_Free(delta_i);
      Ddi_Free(newPi);
      Ddi_Free(newPiLit);
    }
  }

  if (!sat) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "fix point reached: pass at iteration %d.\n", i)
      );
  }
  Trav_MgrSetAssertFlag(travMgr, sat);

  Ddi_Free(myInvarspec);
  Ddi_Free(unroll);
  Ddi_Free(totPiVars);

  return (reached);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Trav_TravSatItpSeqVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  int seqK,
  int seqGroup,
  float seqSerial,
  int cegar,
  int fwdBwdFP
)
{
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Varset_t *totPiVars;
  Ddi_Bddarray_t *delta;
  Ddi_Bdd_t *reached, *target, *myInit, *myInvarspec;   //, *to;
  Ddi_Bdd_t *cubeInit;
  Ddi_Bddarray_t *unroll;
  int sat = 0, i, initIsCube, nsat;
  long startTime;               //, currTime;
  long bmcTime = 0, bmcStartTime, bmcStepTime;
  Ddi_Bdd_t *constrain = NULL;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  int inverse = 0;
  int doOptThreshold = 5000;
  int optLevel = 0;
  Ddi_Varset_t *psVars = NULL;
  Ddi_Bddarray_t *initStub = Fsm_MgrReadInitStubBDD(fsmMgr);

  Ddi_Bdd_t *cone = Ddi_BddNot(invarspec);
  Ddi_Bdd_t *coneAndInit = Ddi_BddNot(invarspec);
  Ddi_Bdd_t *cex;

  int seqReverse = 0;

  if (seqSerial < 0) {
    seqReverse = 1;
    seqSerial *= -1;
  }

  ps = Fsm_MgrReadVarPS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  delta = Fsm_MgrReadDeltaBDD(fsmMgr);

  optLevel = Ddi_MgrReadAigBddOptLevel(ddm);

  cex = bmcItpSeqCegarCheck(travMgr, delta, cone, init, invar,
    coneAndInit, initStub, ps, ns, pi, seqK,
    seqSerial, cegar, fwdBwdFP, seqReverse, seqGroup);

  Trav_MgrSetAssertFlag(travMgr, cex != NULL);

  Ddi_Free(cex);
  Ddi_Free(cone);
  Ddi_Free(coneAndInit);
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatInductiveTrVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * externalCare,
  int step,
  int first,
  int bound,
  int timeLimit
)
{
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Varset_t *pivars, *smooth;
  Ddi_Bddarray_t *delta, *psLit, *nsLit;
  Ddi_Bdd_t *unroll, *target, *tr, *tr_i,   // *reached,
  *loopFree, *loopFreeBck, *myInvarspec;
  int sat = 0, res = 1, i, j, k, l, nState, initIsCube, oldCoi = -1, nCoi = 0;
  long startTime, timeFrameLitsSize = 1;    //,currTime;
  Ddi_Bddarray_t **timeFrameLits =
    Pdtutil_Alloc(Ddi_Bddarray_t *, timeFrameLitsSize);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Varsetarray_t *timeFrameCoi = Ddi_VarsetarrayAlloc(ddm, 0);
  Ddi_Varset_t *supp, *psVars;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bddarray_t *lemmas = NULL;
  Ddi_Bddarray_t *initStub = NULL;
  Ddi_Bdd_t *oldCheck = NULL;
  Ddi_Bdd_t *initBdd, *initStubRel = NULL;
  long stepTime, initTime;
  unsigned long time_limit = ~0;

  initTime = util_cpu_time();
  if (timeLimit > 0) {
    time_limit = initTime + timeLimit * 1000;
  }

  initStub = Fsm_MgrReadInitStubBDD(fsmMgr);
  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  psVars = Ddi_VarsetMakeFromArray(ps);

  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  nState = Ddi_BddarrayNum(delta);
  psLit = Ddi_BddarrayAlloc(ddm, nState);
  nsLit = Ddi_BddarrayAlloc(ddm, nState);

  pivars = Ddi_VarsetMakeFromArray(pi);
  smooth = Ddi_VarsetMakeFromArray(ps);
  Ddi_VarsetUnionAcc(smooth, pivars);

  initBdd = Ddi_BddMakeMono(init);
  initIsCube = Ddi_BddIsCube(initBdd);
  Ddi_Free(initBdd);

  myInvarspec = Ddi_BddDup(invarspec);
  if (0 && travMgr->settings.aig.targetEn > 0) {
#if 0
    Ddi_Bdd_t *r = Trav_TravSatBckAllSolVerif(travMgr, fsmMgr,
      init, invarspec, invar, travMgr->settings.aig.targetEn);
#else
    Ddi_Bdd_t *r = Trav_TravSatBckVerif(travMgr, fsmMgr,
      init, invarspec, invar, NULL, travMgr->settings.aig.targetEn, 0, 0);
#endif
    Ddi_Free(myInvarspec);
    Ddi_BddNotAcc(r);
    myInvarspec = r;
  }

  if (0 && step > 0) {
    int result = 0;

    lemmas = genLemmaClasses(travMgr, fsmMgr, init, initStub,
      invar, myInvarspec, externalCare, NULL, step, 0, 0, 0, &result, 0, NULL);
  }

  /* build tr */
  tr = Ddi_BddMakeConstAig(ddm, 1);
  if (initStub != NULL) {
    initStubRel = Ddi_BddMakeConstAig(ddm, 1);
  }
  for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
    Ddi_Bdd_t *tr_i, *psLit_i, *nsLit_i, *stub_i;

    nsLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);

    Ddi_BddarrayWrite(nsLit, i, nsLit_i);
    Ddi_BddarrayWrite(psLit, i, psLit_i);
    tr_i = Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(delta, i));
    Ddi_BddAndAcc(tr, tr_i);
    Ddi_Free(tr_i);
    if (initStub != NULL) {
      stub_i = Ddi_BddXnor(psLit_i, Ddi_BddarrayRead(initStub, i));
      Ddi_BddAndAcc(initStubRel, stub_i);
      Ddi_Free(stub_i);
    }
    Ddi_Free(psLit_i);
    Ddi_Free(nsLit_i);
  }

#if 0
  Ddi_BddExistAcc(tr, pivars);
  Ddi_AigOptByBdd(tr, -1.0);
#endif

  Ddi_Free(pivars);

  loopFree = Ddi_BddMakeConstAig(ddm, 1);
  unroll = Ddi_BddMakeConstAig(ddm, 1);
  //  DdiAigRedRemovalAcc (tr,myInvarspec,-1);
  Ddi_BddAndAcc(tr, myInvarspec);
  if (0) {
    Ddi_Bdd_t *initNs = Ddi_BddNot(init);

    Ddi_BddComposeAcc(initNs, ps, nsLit);
    Ddi_BddAndAcc(tr, initNs);
    Ddi_Free(initNs);
  }

  if (lemmas != NULL) {
    for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
      Ddi_BddAndAcc(unroll, Ddi_BddarrayRead(lemmas, i));
    }
    Ddi_Free(lemmas);
  }
  if (externalCare != NULL) {
    Ddi_BddAndAcc(unroll, externalCare);
  }

  startTime = util_cpu_time();

  timeFrameLits[0] = Ddi_BddarrayDup(psLit);
  supp = Ddi_BddSupp(myInvarspec);
  Ddi_VarsetIntersectAcc(supp, psVars);
  Ddi_VarsetarrayInsertLast(timeFrameCoi, supp);
  Ddi_Free(supp);

  for (i = 0; !sat; i++) {
    Ddi_Bdd_t *check;
    int fixPoint = 0;

    if ((bound > 0 && i >= bound) || util_cpu_time() > time_limit) {
      sat = -1;
      res = 2;                  /* abort */
      break;
    }
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMin_c,
      fprintf(tMgrO(travMgr), "Inductive check at depth %d (COI=%d).\n", i,
        nCoi)
      );
    stepTime = util_cpu_time();
    target = Ddi_BddNot(myInvarspec);
    Ddi_BddComposeAcc(target, ps, timeFrameLits[i]);

    /* bmc, possibly skipping some steps */
    if (i >= first) {
      if (initStub != NULL) {
        check = Ddi_BddAnd(unroll, initStubRel);
      } else if (initIsCube) {
        check = Ddi_BddDup(unroll);
        Ddi_AigAndCubeAcc(check, init);
      } else {
        check = Ddi_BddAnd(unroll, init);
      }
      Ddi_BddAndAcc(check, target);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMin_c,
        fprintf(tMgrO(travMgr), "BMC", Ddi_BddSize(check))
        );
      if (util_cpu_time() >= time_limit) {
        sat = -1;
      } else {
        sat =
          Ddi_AigSatWithAbort(check, (time_limit - util_cpu_time()) / 1000.0);
      }
      //sat = Ddi_AigSat(check)==1;
      Ddi_Free(check);
      if (sat < 0) {
        /* abort */
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMin_c,
          fprintf(tMgrO(travMgr), "- step time: %s.\n",
            util_print_time(util_cpu_time() - stepTime))
          );
        break;
      }
      if (sat) {
        Ddi_Free(target);
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "; CPU Time for this Step: %s.\n",
            util_print_time(util_cpu_time() - stepTime)););
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "BMC Failure at Bound %d.\n", i););
        res = !sat;
        break;
      }
    }
    /* backward induction */
    loopFreeBck = Ddi_BddMakeConstAig(ddm, 1);
    for (l = i - 1; l > 0; l--) {
      Ddi_Bdd_t *diff_i;
      Ddi_Varset_t *suppCoi = Ddi_VarsetarrayRead(timeFrameCoi, i - l);

      diff_i = Ddi_BddMakeConstAig(ddm, 1);
      for (j = 0; j < l; j++) {
        Ddi_Bdd_t *diff_j = Ddi_BddMakeConstAig(ddm, 0);

        for (k = 0; k < Ddi_VararrayNum(ps); k++) {
          if (Ddi_VarInVarset(suppCoi, Ddi_VararrayRead(ps, k))) {
            Ddi_Bdd_t *diff_k =
              Ddi_BddXor(Ddi_BddarrayRead(timeFrameLits[l], k),
              Ddi_BddarrayRead(timeFrameLits[j], k));

            Ddi_BddOrAcc(diff_j, diff_k);
            Ddi_Free(diff_k);
          }
        }
        Ddi_BddAndAcc(diff_i, diff_j);
        Ddi_Free(diff_j);
      }
      Ddi_BddAndAcc(loopFreeBck, diff_i);
      Ddi_Free(diff_i);
    }

    check = Ddi_BddAnd(unroll, target);
    Ddi_Free(target);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMin_c,
      fprintf(tMgrO(travMgr), "%s BWD Ind.", i >= first ? " /" : "")
      );
    if (1) {
      Ddi_Bdd_t *cexAig = Ddi_AigSatWithCex(check);

      fixPoint = (cexAig == NULL);
      if (!fixPoint && oldCheck != NULL) {
        Ddi_Bdd_t *check2 = Ddi_BddDiff(check, oldCheck);
        Ddi_Bdd_t *cexAig2 = Ddi_AigSatWithCex(check2);

        fixPoint = (cexAig2 == NULL);
        Ddi_Free(check2);
        Ddi_Free(cexAig2);
        if (0 && fixPoint) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "FIX-POINT.\n")
            );
        }
      }
      if (!fixPoint) {
        int doLF = 0;
        Ddi_Bdd_t *lfDup = Ddi_BddDup(loopFreeBck);

        Ddi_AigConstrainCubeAcc(lfDup, cexAig);
        doLF = Ddi_AigSat(lfDup) == 0;
        if (doLF) {
          Ddi_BddAndAcc(check, loopFreeBck);
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
            fprintf(tMgrO(travMgr), "/%d", Ddi_BddSize(check))
            );
          fixPoint = Ddi_AigSat(check) != 1;
        }
        Ddi_Free(lfDup);
      }
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
        fprintf(tMgrO(travMgr), ")")
        );
      Ddi_Free(oldCheck);
      oldCheck = Ddi_BddDup(check);
      Ddi_Free(check);
      Ddi_Free(cexAig);
    }
    Ddi_Free(loopFreeBck);
    if (fixPoint) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMin_c,
        fprintf(tMgrO(travMgr), "- step time: %s.\n",
          util_print_time(util_cpu_time() - stepTime)););
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "BWD fix point at bound %d.\n", i)
        );
      break;
    }

    /* forward induction */
    if (0 && i <= 8) {
      if (initStub != NULL) {
        check = Ddi_BddAnd(unroll, initStubRel);
      } else if (initIsCube) {
        check = Ddi_BddDup(unroll);
        Ddi_AigAndCubeAcc(check, init);
      } else {
        check = Ddi_BddAnd(unroll, init);
      }
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMin_c,
        fprintf(tMgrO(travMgr), "/ FWD Ind.")
        );
      if (1) {
        Ddi_Bdd_t *cexAig = Ddi_AigSatWithCex(check);

        fixPoint = (cexAig == NULL);
        if (!fixPoint) {
          int doLF = 0;
          Ddi_Bdd_t *lfDup = Ddi_BddDup(loopFree);

          /* if loop free is null all states have been reached */
          fixPoint = Ddi_AigSat(loopFree) != 1;
          Ddi_AigConstrainCubeAcc(lfDup, cexAig);
          doLF = Ddi_AigSat(lfDup) == 0;
          if (doLF) {
            Ddi_BddAndAcc(check, loopFree);
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
              fprintf(tMgrO(travMgr), "/%d", Ddi_BddSize(check))
              );
            fixPoint |= Ddi_AigSat(check) != 1;
          }
          Ddi_Free(lfDup);
        }
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
          fprintf(tMgrO(travMgr), ")")
          );
        Ddi_Free(cexAig);
        Ddi_Free(check);
      }
      if (fixPoint) {
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMin_c,
          fprintf(tMgrO(travMgr), "- step time: %s.\n",
            util_print_time(util_cpu_time() - stepTime));
          fprintf(tMgrO(travMgr), "FWD fix point at bound %d.\n", i)
          );
        break;
      }
    }

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMin_c,
      fprintf(tMgrO(travMgr), "- step time: %s.\n",
        util_print_time(util_cpu_time() - stepTime))
      );
    if (1 || !((bound > 0 && i >= bound) || util_cpu_time() > time_limit)) {
      int j;

      //Ddi_Bddarray_t *delta_i;
      Ddi_Bdd_t *diff_i;        //, *invarspec_i;
      Ddi_Vararray_t *newPi = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(pi));
      Ddi_Bddarray_t *newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
      Ddi_Vararray_t *newNs = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(ns));
      Ddi_Bddarray_t *newNsLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(ns));
      Ddi_Varset_t *coiSupp = Ddi_VarsetVoid(ddm);

      oldCoi = nCoi;
      nCoi = 0;
      for (j = 0; j < Ddi_VararrayNum(pi); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
        Ddi_Var_t *newv;
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), i);
        newv = Ddi_VarFromName(ddm, name);
        if (newv == NULL) {
#if 0
          newv = Ddi_VarNewBeforeVar(v);
          Ddi_VarAttachName(newv, name);
#else
          newv = Ddi_VarNewBaig(ddm, name);
#endif
        }
        Ddi_VararrayWrite(newPi, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newPiLit, j, newvLit);
        Ddi_Free(newvLit);
      }
      for (j = 0; j < Ddi_VararrayNum(ns); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(ns, j);
        Ddi_Var_t *newv;
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), i);
        newv = Ddi_VarFromName(ddm, name);
        if (newv == NULL) {
#if 0
          newv = Ddi_VarNewBeforeVar(v);
          Ddi_VarAttachName(newv, name);
#else
          newv = Ddi_VarNewBaig(ddm, name);
#endif
        }
        Ddi_VararrayWrite(newNs, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newNsLit, j, newvLit);
        Ddi_Free(newvLit);
        if (Ddi_VarInVarset(Ddi_VarsetarrayRead(timeFrameCoi, i),
            Ddi_VararrayRead(ps, j))) {
          nCoi++;
          supp = Ddi_BddSupp(Ddi_BddarrayRead(delta, j));
          Ddi_VarsetUnionAcc(coiSupp, supp);
          Ddi_Free(supp);
        }
      }
      tr_i = Ddi_BddCompose(tr, pi, newPiLit);
      Ddi_BddComposeAcc(tr_i, ns, newNsLit);
      Ddi_BddComposeAcc(tr_i, ps, timeFrameLits[i]);
      if (i + 1 >= timeFrameLitsSize) {
        timeFrameLitsSize *= 2;
        timeFrameLits = Pdtutil_Realloc(Ddi_Bddarray_t *,
          timeFrameLits, timeFrameLitsSize);
      }
      timeFrameLits[i + 1] = Ddi_BddarrayDup(newNsLit);
      Ddi_VarsetIntersectAcc(coiSupp, psVars);
      Ddi_VarsetarrayInsertLast(timeFrameCoi, coiSupp);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMed_c,
        fprintf(tMgrO(travMgr), "{COI:%d} ", nCoi)
        );
      Ddi_BddAndAcc(unroll, tr_i);

      Ddi_Free(tr_i);
      Ddi_Free(newPi);
      Ddi_Free(newPiLit);
      Ddi_Free(newNs);
      Ddi_Free(newNsLit);
      Ddi_Free(coiSupp);

      diff_i = Ddi_BddMakeConstAig(ddm, 1);
      for (j = 0; j <= i; j++) {
        Ddi_Bdd_t *diff_j = Ddi_BddMakeConstAig(ddm, 0);

        for (k = 0; k < Ddi_VararrayNum(ns); k++) {
          Ddi_Bdd_t *diff_k =
            Ddi_BddXor(Ddi_BddarrayRead(timeFrameLits[i + 1], k),
            Ddi_BddarrayRead(timeFrameLits[j], k));

          Ddi_BddOrAcc(diff_j, diff_k);
          Ddi_Free(diff_k);
        }
        Ddi_BddAndAcc(diff_i, diff_j);
        Ddi_Free(diff_j);
      }
      Ddi_BddAndAcc(loopFree, diff_i);
      Ddi_Free(diff_i);
    }
  }
  Ddi_Free(oldCheck);

  if (!sat) {
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "INDUCTIVE pass at depth %d.\n", i)
      );
  }
  Trav_MgrSetAssertFlag(travMgr, sat);

  for (; i >= 0; i--) {
    Ddi_Free(timeFrameLits[i]);
  }


  Pdtutil_Free(timeFrameLits);
  Ddi_Free(timeFrameCoi);

  Ddi_Free(psLit);
  Ddi_Free(nsLit);
  Ddi_Free(smooth);
  Ddi_Free(tr);
  Ddi_Free(initStubRel);

  Ddi_Free(psVars);
  Ddi_Free(myInvarspec);
  Ddi_Free(loopFree);
  Ddi_Free(unroll);

  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c,
    fprintf(tMgrO(travMgr), "Total induction time: %s.\n",
      util_print_time(util_cpu_time() - initTime))
    );
  return (res);
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatDiameterVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  int step,
  int bound
)
{
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Varset_t *pivars, *smooth;
  Ddi_Bddarray_t *delta, *psLit, *nsLit;
  Ddi_Bdd_t *unroll, *target, *tr, *tr_i,   // *reached,
  *loopFree, *myInvarspec;      //, *loopFreeBck;
  int sat = 0, res = 1, i, k, nState, initIsCube;
  long startTime, timeFrameLitsSize = 1;    //,currTime;
  Ddi_Bddarray_t **timeFrameLits =
    Pdtutil_Alloc(Ddi_Bddarray_t *, timeFrameLitsSize);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Varsetarray_t *timeFrameCoi = Ddi_VarsetarrayAlloc(ddm, 0);
  Ddi_Varset_t *supp, *psVars;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bddarray_t *lemmas = NULL;
  Ddi_Bdd_t *oldCheck = NULL, *saveCheck = NULL,
    *newCheck = NULL, *newCheckRed = NULL;

  Ddi_Bdd_t *care = Ddi_BddMakeConstAig(ddm, 1);


  if (step > 0) {
    int result = 0;

    lemmas = genLemmaClasses(travMgr, fsmMgr, init, NULL, invar, invarspec,
      care, NULL, step, 0, 0, 0, &result, 0, NULL);
  }

  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  psVars = Ddi_VarsetMakeFromArray(ps);

  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  nState = Ddi_BddarrayNum(delta);
  psLit = Ddi_BddarrayAlloc(ddm, nState);
  nsLit = Ddi_BddarrayAlloc(ddm, nState);

  pivars = Ddi_VarsetMakeFromArray(pi);
  smooth = Ddi_VarsetMakeFromArray(ps);
  Ddi_VarsetUnionAcc(smooth, pivars);

  {
    Ddi_Bdd_t *initBdd = Ddi_BddMakeMono(init);

    initIsCube = Ddi_BddIsCube(initBdd);
    Ddi_Free(initBdd);
  }

  myInvarspec = Ddi_BddDup(invarspec);
  if (travMgr->settings.aig.targetEn > 0) {
    Ddi_Bdd_t *r = Trav_TravSatBckVerif(travMgr, fsmMgr,
      init, invarspec, invar, NULL, travMgr->settings.aig.targetEn, 0, 0);

    Ddi_Free(myInvarspec);
    Ddi_BddNotAcc(r);
    myInvarspec = r;
  }

  /* build tr */
  tr = Ddi_BddMakeConstAig(ddm, 1);
  for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
    Ddi_Bdd_t *tr_i, *psLit_i, *nsLit_i;

    nsLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);

    Ddi_BddarrayWrite(nsLit, i, nsLit_i);
    Ddi_BddarrayWrite(psLit, i, psLit_i);
    tr_i = Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(delta, i));
    Ddi_BddAndAcc(tr, tr_i);
    Ddi_Free(tr_i);
    Ddi_Free(psLit_i);
    Ddi_Free(nsLit_i);
  }

  Ddi_Free(pivars);

  loopFree = Ddi_BddMakeConstAig(ddm, 1);
  unroll = Ddi_BddMakeConstAig(ddm, 1);

  care = Ddi_BddMakeConstAig(ddm, 1);

  //  DdiAigRedRemovalAcc (tr,myInvarspec,-1);
  //  Ddi_BddAndAcc(tr,myInvarspec);

  if (lemmas != NULL) {
    for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
      Ddi_BddAndAcc(care, Ddi_BddarrayRead(lemmas, i));
    }
    Ddi_Free(lemmas);
  }

  startTime = util_cpu_time();

  timeFrameLits[0] = Ddi_BddarrayDup(psLit);
  supp = Ddi_BddSupp(myInvarspec);
  Ddi_VarsetIntersectAcc(supp, psVars);
  Ddi_VarsetarrayInsertLast(timeFrameCoi, supp);
  Ddi_Free(supp);

  newCheck = Ddi_BddNot(myInvarspec);
  newCheckRed = Ddi_BddNot(myInvarspec);

  for (i = 0; !sat; i++) {
    Ddi_Bdd_t *check, *oldCare;
    int fixPoint = 0;

    if (bound > 0 && i >= bound) {
      sat = 1;
      res = 2;                  /* abort */
      break;
    }
    target = Ddi_BddNot(myInvarspec);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Diameter check at depth %d (unroll: %d).\n",
        i, Ddi_BddSize(unroll))
      );
    Ddi_BddComposeAcc(target, ps, timeFrameLits[i]);
    if (initIsCube) {
      check = Ddi_BddDup(unroll);
      Ddi_AigAndCubeAcc(check, init);
    } else {
      check = Ddi_BddAnd(unroll, init);
    }
    Ddi_BddAndAcc(check, target);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), " BMC (AIG size: %d/%d/%d)", Ddi_BddSize(check),
        Ddi_BddSize(newCheck), Ddi_BddSize(newCheckRed))
      );
    sat = Ddi_AigSat(check) == 1;
    Ddi_Free(check);
    Ddi_Free(target);
    if (sat) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "BMC failure at bound %d.\n", i)
        );
      res = !sat;
      break;
    }

    oldCare = Ddi_BddDup(care);

    fixPoint = checkFixPoint(travMgr, fsmMgr, oldCheck, newCheckRed, NULL);
    if (fixPoint < 0) {
      /* aborted */
      fixPoint =
        checkFixPoint2(travMgr, fsmMgr, oldCheck, newCheckRed, NULL, -1);
    }

    if (!Ddi_BddEqual(care, oldCare)) {
      DdiAigRedRemovalAcc(newCheck, care, -1, -1.0);
      DdiAigRedRemovalAcc(newCheckRed, care, -1, -1.0);
    }
    Ddi_Free(oldCare);

#if 1
    //    Ddi_AigExistProjectAcc(newCheck,psVars,NULL,1,0);
    DdiAigRedRemovalAcc(newCheck, NULL, -1, -1.0);
#endif

    Ddi_Free(saveCheck);
    if (oldCheck != NULL)
      saveCheck = Ddi_BddDup(oldCheck);
    Ddi_Free(oldCheck);
    oldCheck = Ddi_BddDup(newCheck);

    if (fixPoint) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "BWD fix point at bound %d.\n", i)
        );
      break;
    }

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "\n")
      );
    if (1) {
      int j, nCoi = 0;

      //Ddi_Bddarray_t *delta_i;
      Ddi_Bdd_t *diff_i;        //, *invarspec_i;
      Ddi_Vararray_t *newPi = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(pi));
      Ddi_Bddarray_t *newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
      Ddi_Vararray_t *newNs = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(ns));
      Ddi_Bddarray_t *newNsLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(ns));
      Ddi_Varset_t *coiSupp = Ddi_VarsetVoid(ddm);

      for (j = 0; j < Ddi_VararrayNum(pi); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
        Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), i);
        Ddi_VarAttachName(newv, name);
        Ddi_VararrayWrite(newPi, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newPiLit, j, newvLit);
        Ddi_Free(newvLit);
      }
      for (j = 0; j < Ddi_VararrayNum(ns); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(ns, j);
        Ddi_Var_t *newv = Ddi_VarNewAfterVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "%s_%d", Ddi_VarName(v), i);
        Ddi_VarAttachName(newv, name);
        Ddi_VararrayWrite(newNs, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newNsLit, j, newvLit);
        Ddi_Free(newvLit);
        if (Ddi_VarInVarset(Ddi_VarsetarrayRead(timeFrameCoi, i),
            Ddi_VararrayRead(ps, j))) {
          nCoi++;
          supp = Ddi_BddSupp(Ddi_BddarrayRead(delta, j));
          Ddi_VarsetUnionAcc(coiSupp, supp);
          Ddi_Free(supp);
        }
      }
      tr_i = Ddi_BddCompose(tr, pi, newPiLit);
      Ddi_BddComposeAcc(tr_i, ns, newNsLit);
      Ddi_BddComposeAcc(tr_i, ps, timeFrameLits[i]);
      if (i + 1 >= timeFrameLitsSize) {
        timeFrameLitsSize *= 2;
        timeFrameLits = Pdtutil_Realloc(Ddi_Bddarray_t *,
          timeFrameLits, timeFrameLitsSize);
      }
      timeFrameLits[i + 1] = Ddi_BddarrayDup(newNsLit);
      Ddi_VarsetIntersectAcc(coiSupp, psVars);
      Ddi_VarsetarrayInsertLast(timeFrameCoi, coiSupp);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "{COI:%d} ", nCoi)
        );
      Ddi_BddAndAcc(unroll, tr_i);

      Ddi_BddComposeAcc(newCheck, pi, newPiLit);
      Ddi_BddComposeAcc(newCheck, ps, delta);
      Ddi_BddComposeAcc(newCheckRed, pi, newPiLit);
      Ddi_BddComposeAcc(newCheckRed, ps, delta);
      Ddi_BddAndAcc(newCheckRed, myInvarspec);
      //      if (saveCheck != NULL)
      //        Ddi_BddOrAcc(newCheck,saveCheck);
      Ddi_Free(tr_i);
      Ddi_Free(newPi);
      Ddi_Free(newPiLit);
      Ddi_Free(newNs);
      Ddi_Free(newNsLit);
      Ddi_Free(coiSupp);

      diff_i = Ddi_BddMakeConstAig(ddm, 1);
      for (j = 0; j <= i; j++) {
        Ddi_Bdd_t *diff_j = Ddi_BddMakeConstAig(ddm, 0);

        for (k = 0; k < Ddi_VararrayNum(ns); k++) {
          Ddi_Bdd_t *diff_k =
            Ddi_BddXor(Ddi_BddarrayRead(timeFrameLits[i + 1], k),
            Ddi_BddarrayRead(timeFrameLits[j], k));

          Ddi_BddOrAcc(diff_j, diff_k);
          Ddi_Free(diff_k);
        }
        Ddi_BddAndAcc(diff_i, diff_j);
        Ddi_Free(diff_j);
      }
      Ddi_BddAndAcc(loopFree, diff_i);
      Ddi_Free(diff_i);
    }
  }

  Ddi_Free(saveCheck);
  Ddi_Free(oldCheck);
  Ddi_Free(newCheck);
  Ddi_Free(newCheckRed);
  if (!sat) {
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "DIAMETER pass at depth %d.\n", i)
      );
  }

  Trav_MgrSetAssertFlag(travMgr, sat);

  for (; i >= 0; i--) {
    Ddi_Free(timeFrameLits[i]);
  }

  Pdtutil_Free(timeFrameLits);
  Ddi_Free(timeFrameCoi);

  Ddi_Free(psLit);
  Ddi_Free(nsLit);
  Ddi_Free(smooth);
  Ddi_Free(tr);

  Ddi_Free(care);

  Ddi_Free(psVars);
  Ddi_Free(myInvarspec);
  Ddi_Free(loopFree);
  Ddi_Free(unroll);

  Ddi_Free(care);

  return (res);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatFwdDiameterVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  int step,
  int bound
)
{
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Varset_t *pivars, *smooth;
  Ddi_Bddarray_t *delta, *psLit, *nsLit;
  Ddi_Bdd_t *unroll, *target, *tr, *tr_i,   // *reached,
  *loopFree, *myInvarspec;      //, *loopFreeBck;
  int sat = 0, res = 1, i, k, nState, initIsCube;
  long startTime, timeFrameLitsSize = 1;    //,currTime;
  Ddi_Bddarray_t **timeFrameLits =
    Pdtutil_Alloc(Ddi_Bddarray_t *, timeFrameLitsSize);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Varsetarray_t *timeFrameCoi = Ddi_VarsetarrayAlloc(ddm, 0);
  Ddi_Varset_t *supp, *psVars;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bddarray_t *lemmas = NULL;
  Ddi_Bdd_t *oldCheck = NULL, *saveCheck = NULL,
    *newCheck = NULL, *newCheckRed = NULL;

  Ddi_Bdd_t *care = Ddi_BddMakeConstAig(ddm, 1);


  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  psVars = Ddi_VarsetMakeFromArray(ps);

  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  nState = Ddi_BddarrayNum(delta);
  psLit = Ddi_BddarrayAlloc(ddm, nState);
  nsLit = Ddi_BddarrayAlloc(ddm, nState);

  pivars = Ddi_VarsetMakeFromArray(pi);
  smooth = Ddi_VarsetMakeFromArray(ps);
  Ddi_VarsetUnionAcc(smooth, pivars);

  {
    Ddi_Bdd_t *initBdd = Ddi_BddMakeMono(init);

    initIsCube = Ddi_BddIsCube(initBdd);
    Ddi_Free(initBdd);
  }

  myInvarspec = Ddi_BddDup(invarspec);

  /* build tr */
  tr = Ddi_BddMakeConstAig(ddm, 1);
  for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
    Ddi_Bdd_t *tr_i, *psLit_i, *nsLit_i;

    nsLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);

    Ddi_BddarrayWrite(nsLit, i, nsLit_i);
    Ddi_BddarrayWrite(psLit, i, psLit_i);
    tr_i = Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(delta, i));
    Ddi_BddAndAcc(tr, tr_i);
    Ddi_Free(tr_i);
    Ddi_Free(psLit_i);
    Ddi_Free(nsLit_i);
  }

  Ddi_Free(pivars);

  loopFree = Ddi_BddMakeConstAig(ddm, 1);
  unroll = Ddi_BddMakeConstAig(ddm, 1);

  care = Ddi_BddMakeConstAig(ddm, 1);

  //  DdiAigRedRemovalAcc (tr,myInvarspec,-1);
  //  Ddi_BddAndAcc(tr,myInvarspec);

  startTime = util_cpu_time();

  timeFrameLits[0] = Ddi_BddarrayDup(psLit);
  supp = Ddi_BddSupp(myInvarspec);
  Ddi_VarsetIntersectAcc(supp, psVars);
  Ddi_VarsetarrayInsertLast(timeFrameCoi, supp);
  Ddi_Free(supp);

  newCheck = Ddi_BddNot(myInvarspec);
  newCheckRed = Ddi_BddNot(myInvarspec);

  for (i = 0; !sat; i++) {
    Ddi_Bdd_t *check, *oldCare;
    int fixPoint = 0;

    if (bound > 0 && i >= bound) {
      sat = 1;
      res = 2;                  /* abort */
      break;
    }
    target = Ddi_BddNot(myInvarspec);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Diameter check at depth %d (unroll: %d).\n",
        i, Ddi_BddSize(unroll))
      );
    Ddi_BddComposeAcc(target, ps, timeFrameLits[i]);
    if (initIsCube) {
      check = Ddi_BddDup(unroll);
      Ddi_AigAndCubeAcc(check, init);
    } else {
      check = Ddi_BddAnd(unroll, init);
    }
    Ddi_BddAndAcc(check, target);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), " BMC (AIG size: %d/%d/%d)", Ddi_BddSize(check),
        Ddi_BddSize(newCheck), Ddi_BddSize(newCheckRed))
      );
    sat = Ddi_AigSat(check) == 1;
    Ddi_Free(check);
    Ddi_Free(target);
    if (sat) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "BMC failure at bound %d.\n", i)
        );
      res = !sat;
      break;
    }

    oldCare = Ddi_BddDup(care);

    fixPoint = checkFixPoint(travMgr, fsmMgr, oldCheck, newCheckRed, NULL);
    if (fixPoint < 0) {
      /* aborted */
      fixPoint =
        checkFixPoint2(travMgr, fsmMgr, oldCheck, newCheckRed, NULL, -1);
    }

    if (!Ddi_BddEqual(care, oldCare)) {
      DdiAigRedRemovalAcc(newCheck, care, -1, -1.0);
      DdiAigRedRemovalAcc(newCheckRed, care, -1, -1.0);
    }
    Ddi_Free(oldCare);

#if 1
    //    Ddi_AigExistProjectAcc(newCheck,psVars,NULL,1,0);
    DdiAigRedRemovalAcc(newCheck, NULL, -1, -1.0);
#endif

    Ddi_Free(saveCheck);
    if (oldCheck != NULL)
      saveCheck = Ddi_BddDup(oldCheck);
    Ddi_Free(oldCheck);
    oldCheck = Ddi_BddDup(newCheck);

    if (fixPoint) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "BWD fix point at bound %d.\n", i)
        );
      break;
    }

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "\n")
      );
    if (1) {
      int j, nCoi = 0;

      //Ddi_Bddarray_t *delta_i;
      Ddi_Bdd_t *diff_i;        //, *invarspec_i;
      Ddi_Vararray_t *newPi = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(pi));
      Ddi_Bddarray_t *newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
      Ddi_Vararray_t *newNs = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(ns));
      Ddi_Bddarray_t *newNsLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(ns));
      Ddi_Varset_t *coiSupp = Ddi_VarsetVoid(ddm);

      for (j = 0; j < Ddi_VararrayNum(pi); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
        Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), i);
        Ddi_VarAttachName(newv, name);
        Ddi_VararrayWrite(newPi, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newPiLit, j, newvLit);
        Ddi_Free(newvLit);
      }
      for (j = 0; j < Ddi_VararrayNum(ns); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(ns, j);
        Ddi_Var_t *newv = Ddi_VarNewAfterVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "%s_%d", Ddi_VarName(v), i);
        Ddi_VarAttachName(newv, name);
        Ddi_VararrayWrite(newNs, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newNsLit, j, newvLit);
        Ddi_Free(newvLit);
        if (Ddi_VarInVarset(Ddi_VarsetarrayRead(timeFrameCoi, i),
            Ddi_VararrayRead(ps, j))) {
          nCoi++;
          supp = Ddi_BddSupp(Ddi_BddarrayRead(delta, j));
          Ddi_VarsetUnionAcc(coiSupp, supp);
          Ddi_Free(supp);
        }
      }
      tr_i = Ddi_BddCompose(tr, pi, newPiLit);
      Ddi_BddComposeAcc(tr_i, ns, newNsLit);
      Ddi_BddComposeAcc(tr_i, ps, timeFrameLits[i]);
      if (i + 1 >= timeFrameLitsSize) {
        timeFrameLitsSize *= 2;
        timeFrameLits = Pdtutil_Realloc(Ddi_Bddarray_t *,
          timeFrameLits, timeFrameLitsSize);
      }
      timeFrameLits[i + 1] = Ddi_BddarrayDup(newNsLit);
      Ddi_VarsetIntersectAcc(coiSupp, psVars);
      Ddi_VarsetarrayInsertLast(timeFrameCoi, coiSupp);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "{COI:%d} ", nCoi)
        );
      Ddi_BddAndAcc(unroll, tr_i);

      Ddi_BddComposeAcc(newCheck, pi, newPiLit);
      Ddi_BddComposeAcc(newCheck, ps, delta);
      Ddi_BddComposeAcc(newCheckRed, pi, newPiLit);
      Ddi_BddComposeAcc(newCheckRed, ps, delta);
      Ddi_BddAndAcc(newCheckRed, myInvarspec);
      //      if (saveCheck != NULL)
      //        Ddi_BddOrAcc(newCheck,saveCheck);
      Ddi_Free(tr_i);
      Ddi_Free(newPi);
      Ddi_Free(newPiLit);
      Ddi_Free(newNs);
      Ddi_Free(newNsLit);
      Ddi_Free(coiSupp);

      diff_i = Ddi_BddMakeConstAig(ddm, 1);
      for (j = 0; j <= i; j++) {
        Ddi_Bdd_t *diff_j = Ddi_BddMakeConstAig(ddm, 0);

        for (k = 0; k < Ddi_VararrayNum(ns); k++) {
          Ddi_Bdd_t *diff_k =
            Ddi_BddXor(Ddi_BddarrayRead(timeFrameLits[i + 1], k),
            Ddi_BddarrayRead(timeFrameLits[j], k));

          Ddi_BddOrAcc(diff_j, diff_k);
          Ddi_Free(diff_k);
        }
        Ddi_BddAndAcc(diff_i, diff_j);
        Ddi_Free(diff_j);
      }
      Ddi_BddAndAcc(loopFree, diff_i);
      Ddi_Free(diff_i);
    }
  }

  Ddi_Free(saveCheck);
  Ddi_Free(oldCheck);
  Ddi_Free(newCheck);
  Ddi_Free(newCheckRed);

  if (!sat) {
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "DIAMETER pass at depth %d.\n", i)
      );
  }

  Trav_MgrSetAssertFlag(travMgr, sat);

  for (; i >= 0; i--) {
    Ddi_Free(timeFrameLits[i]);
  }

  Pdtutil_Free(timeFrameLits);
  Ddi_Free(timeFrameCoi);

  Ddi_Free(psLit);
  Ddi_Free(nsLit);
  Ddi_Free(smooth);
  Ddi_Free(tr);

  Ddi_Free(care);

  Ddi_Free(psVars);
  Ddi_Free(myInvarspec);
  Ddi_Free(loopFree);
  Ddi_Free(unroll);

  Ddi_Free(care);

  return (res);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatItpVerif0(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * care,
  int step,
  int bound,
  float lazyRate,
  int firstFwdIter,
  int timeLimit
)
{
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Varset_t *pivars;
  Ddi_Bddarray_t *delta, *psLit, *nsLit, *piLit;
  Ddi_Bdd_t *reached, *unroll, *target, *tr, *tr_i,
    *loopFree, *myInvarspec, *notReached = NULL, *newReached = NULL;
  int sat = 0, res = 1, i, k, nState, nPi, initIsCube;
  long initTime, startTime;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Varset_t *supp, *psVars;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bddarray_t *lemmas = NULL;
  Ddi_Bddarray_t *initStub = NULL;
  Ddi_Bdd_t *oldCone = NULL, *newCone = NULL, *fullCone = NULL,
    *fullConeRings = NULL,
    *fullConeAux = NULL,
    *inductionCone = NULL, *inductionConeBase = NULL,
    *previousCone = NULL, *saveCone = NULL,
    *newConeRed = NULL, *newConeAux = NULL, *newConeAux2 = NULL;
  Ddi_Bdd_t *lemmasInvar = NULL;
  int doExist = 0, doExistThreshold = 1000, doExistMaxSize = 10000;
  Trav_ItpMgr_t *itpMgr = NULL;
  int itpBmcBound = 1;
  int stallEnable = 0, optLevel = 0;
  int size0 = -1, size1;
  int nextSaveCone = 2, savedConeIter = -1, savedConeWindow = 1;
  int itpExact = Trav_MgrReadItpExact(travMgr);
  float sizeIncrease = 0.0;
  Ddi_Bddarray_t *previousConeAuxLits = NULL, *saveConeAuxLits = NULL;
  int nBadDoExist = 0, nGoodDoExist = 0;
  int useExtraCheck = 0, useInductionCone = 0;
  int maxFP2Iter = 2;
  int computeFullCone = 0, constrainOpt = 0 /* @@@@@@@@@@@@@@@@@ */ ;
  Ddi_Bdd_t *rInterpolant = NULL;
  float lazyTimeLimit = travMgr->settings.aig.lazyTimeLimit;
  int tryBdd = 0, useTrBdd = 0, maxFailBddBwd = 3, bddSuccess = 0;
  int maxLemmas = 5;
  Ddi_Bddarray_t *partWindows = NULL, *deferredUnroll = NULL;
  int dynAbstr = Trav_MgrReadDynAbstr(travMgr);
  int abstrRef = Trav_MgrReadAbstrRef(travMgr);
  int abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  int abcOpt = Ddi_MgrReadAigAbcOptLevel(ddm);
  int nFreeDelta = 0;
  int nSuppDelta[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  int useInitCare = 0, filterNew = 0;
  Tr_Mgr_t *trMgr = NULL;
  Tr_Tr_t *trBdd = NULL;
  Ddi_Bdd_t *itpCareRef = NULL, *coneBdd = NULL, *careBdd = NULL, *bckReached =
    NULL;
  int imgAndExistTh = 50000;
  int useInnerCone = 1;
  int keepConeRings = Trav_MgrReadItpInnerCones(travMgr);
  int coneRingPeriod = keepConeRings;
  int forceInterpolant = Trav_MgrReadItpForceRun(travMgr);
  int fixPointBdd = 0;
  int enableLoopFree = 0;
  int existOptPlus = 1;
  int useSingleCone = 1;
  int existLevel = 1;
  Ddi_Bdd_t *newConeConstraint = NULL;
  Ddi_Bdd_t *newConeConstraint2 = NULL;
  Ddi_Bdd_t *deltaConstraint = NULL;
  int iProp = -1, iConstr = -1;
  int monotoneConeOpt = 0;
  int constrainConeOpt = 0;
  int useInvarFull = 0;
  int chkFpWithInductionCone = 1;
  int lemmaSteps = 2;
  int deferConeBuild = 0, nDeferred = 0;
  int noItp = 0;
  int doStoreR = 1;
  int itpRefineCex = Trav_MgrReadItpRefineCex(travMgr);
  int itpConstrLevel = Trav_MgrReadItpConstrLevel(travMgr);
  int itpAppr = Trav_MgrReadItpAppr(travMgr);
  int enAigOptPdt = Trav_MgrReadItpConeOpt(travMgr) > 1;
  int enAigStructOpt = Trav_MgrReadItpConeOpt(travMgr) > 0;
  int useBoundkCone = Trav_MgrReadItpBoundkOpt(travMgr);
  int useReached = Trav_MgrReadItpUseReached(travMgr);
  int optForDeep = Trav_MgrReadItpTuneForDepth(travMgr) > 0;
  int noBoundOpt = Trav_MgrReadItpTuneForDepth(travMgr) < 0;
  int disConeUnwind = 0;

  if (1) {
    Ddi_Bdd_t *initFsm = Fsm_MgrReadInitBDD(fsmMgr);

    if (initFsm == NULL) {
      Pdtutil_Assert(init == NULL, "trav & fsm init do not match");
    } else {
      Pdtutil_Assert(Ddi_AigEqualSat(initFsm, init),
        "trav & fsm init do not match");
    }
  }

  if (itpConstrLevel <= 0)
    invar = NULL;

  itpMgr = Trav_ItpMgrInit(travMgr, fsmMgr, itpConstrLevel > 1 ? invar : 0,
    invarspec, 1, optLevel);


  if (care == NULL) {
    care = Ddi_BddMakeConstAig(ddm, 1);
  } else {
    Ddi_Bdd_t *careAndTarget = Ddi_BddMakeAig(care);

    Ddi_BddAndAcc(careAndTarget, itpMgr->target);
    if (0 && invar != NULL) {
      Ddi_BddAndAcc(careAndTarget, invar);
    }
    if (!Ddi_AigSat(careAndTarget)) {
      Ddi_Free(careAndTarget);
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "property proved by CARE.\n")
        );
      Trav_MgrSetAssertFlag(travMgr, 0);
      return (1);
    }
    Ddi_Free(careAndTarget);

    care = Ddi_BddMakeAig(care);
    if (Ddi_BddSize(care) > 1000) {
      ddiAbcOptAcc(care, -1.0);
    }
  }
  if (0 && invar != NULL) {
    Ddi_BddAndAcc(care, invar);
  }

  initStub = Fsm_MgrReadInitStubBDD(fsmMgr);
  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);

  nState = Ddi_VararrayNum(ps);

  Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelDevMin_c) {
    fprintf(tMgrO(travMgr), "STEP: %d.\n", step);
  }

  if (iProp < 0) {
    int l;
    Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");
    Ddi_Var_t *cvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");

    for (l = nState - 1; l >= 0; l--) {
      Ddi_Var_t *v_i = Ddi_VararrayRead(ps, l);

      if (v_i == pvarPs) {
        iProp = l;
      } else if (v_i == cvarPs) {
        iConstr = l;
      }
      if (iProp >= 0 && iConstr >= 0)
        break;
    }
  }

  if (step > 0) {
    int result = 0, lambdaNum = -1;
    int speculate = 0;          /* not effective for inductive proofs !!! */

    /* maybe provides more lemmas when property is not inductive */
    Ddi_Bddarray_t *potLemmas = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_Bddarray_t *falseLemmas = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_Bdd_t *myCare = NULL, *myInvar = NULL;
    Ddi_Bdd_t *myInvarspec = Ddi_BddDup(invarspec);

    //    invar = Ddi_BddMakeLiteralAig(Ddi_VarFromName(ddm,"i36"),0);
    //    Ddi_BddAndAcc(invar,lit);
    //    Ddi_Free(lit);
    //    Ddi_BddNotAcc(invar); Ddi_BddOrAcc(invar,invarspec);
    //    Ddi_Free(invar);

    myCare = Ddi_BddDup(care);
    if (speculate) {
      Ddi_Bdd_t *retimedSpec;

      delta = Fsm_MgrReadDeltaBDD(fsmMgr);
      retimedSpec = Ddi_BddCompose(invarspec, ps, delta);
      Ddi_Free(myInvarspec);
      myInvarspec = retimedSpec;
      Ddi_BddAndAcc(myCare, retimedSpec);
      //      Ddi_Free(retimedSpec);
    }
    //    myCare = Ddi_BddMakeConstAig(ddm,1);

    //    myInvar = Ddi_BddDup(invar);
    myInvar = itpConstrLevel > 0 ? Ddi_BddDup(invar) : NULL;
    if (0 && invar != NULL) {   /* GpC: fix this */
      delta = Fsm_MgrReadDeltaBDD(fsmMgr);
      if (Ddi_BddSize(invar) == 1) {
        int iId = Ddi_VararrayNum(ps) - 2;
        Ddi_Varset_t *iSupp = Ddi_BddSupp(invar);
        Ddi_Var_t *iV = Ddi_VararrayRead(ps, iId);

        if (Ddi_VarInVarset(iSupp, iV)) {
          Ddi_Bdd_t *iRetimed = Ddi_BddarrayRead(delta, iId);

          Ddi_BddAndAcc(myInvar, iRetimed);
        }
        Ddi_Free(iSupp);
      }
      Ddi_BddAndAcc(myCare, myInvar);
    }

    if (Trav_MgrReadNewi(travMgr) != NULL) {
      lambdaNum = Ddi_BddarrayNum(Fsm_MgrReadLambdaBDD(fsmMgr));
      int j;

      Ddi_BddarrayAppend(Fsm_MgrReadLambdaBDD(fsmMgr),
        Trav_MgrReadNewi(travMgr));
    }


    lemmas = genLemmaClasses(travMgr, fsmMgr,
      init, initStub, myInvar, myInvarspec, myCare, potLemmas, step,
      1, 0, 3, &result, 0, NULL /*falseLemmas */ );

    if (Trav_MgrReadNewi(travMgr) != NULL) {
      Pdtutil_Assert(lambdaNum > 0, "wrong lambda num");
      int j;
      Ddi_Bddarray_t *newi = Trav_MgrReadNewi(travMgr);
      Ddi_Bddarray_t *l = Fsm_MgrReadLambdaBDD(fsmMgr);

      for (j = Ddi_BddarrayNum(newi) - 1; j >= 0; j--) {
        Ddi_Bdd_t *l_j = Ddi_BddarrayExtract(l, lambdaNum + j);

        Ddi_BddarrayWrite(newi, j, l_j);
        Ddi_Free(l_j);
      }
    }

    Ddi_Free(falseLemmas);
    if (iConstr >= 0 && myInvar != NULL) {
      Ddi_Bdd_t *dConstr =
        Ddi_BddarrayRead(Fsm_MgrReadDeltaBDD(fsmMgr), iConstr);
      Ddi_BddAndAcc(dConstr, myInvar);
    }

    Ddi_Free(myCare);
    Ddi_Free(myInvar);
    Ddi_Free(myInvarspec);
    if (result > 0) {
      if (doStoreR) {
        Ddi_Bdd_t *rOut = NULL;

        if (0 || lemmas == NULL) {
          rOut = Ddi_BddMakeConstAig(ddm, 1);
        } else {
          rOut = Ddi_BddMakePartConjFromArray(lemmas);
        }
        Ddi_BddSetAig(rOut);
        Trav_MgrSetReached(travMgr, rOut);
        Ddi_Free(rOut);
        if (itpMgr != NULL) {
          if ((Trav_MgrReadItpReuseRings(travMgr) > 2) && itpMgr->nRings > 0) {
            Ddi_Bddarray_t *rings = Ddi_BddarrayDup(itpMgr->fromRings);

            if (itpMgr->eqRings != NULL
              && Ddi_BddarrayNum(itpMgr->eqRings) > 0) {
              int j;

              for (j = 0; j < Ddi_BddarrayNum(itpMgr->eqRings); j++) {
                Ddi_Bdd_t *eq = Ddi_BddarrayRead(itpMgr->eqRings, j);
                Ddi_Bdd_t *ring_j = Ddi_BddarrayRead(rings, j);

                if (eq != NULL) {
                  Ddi_BddSetPartConj(ring_j);
                  Pdtutil_Assert(Ddi_BddPartNum(ring_j) == 1,
                    "error in ring as part");
                  Ddi_BddPartWrite(ring_j, 1, eq);
                }
              }
            }
            Trav_MgrSetNewi(travMgr, rings);
            Ddi_Free(rings);
          }
        }
      }
      Ddi_Free(potLemmas);
      Ddi_Free(lemmas);
      Ddi_Free(care);
      Trav_MgrSetAssertFlag(travMgr, 0);
      return 1;
    }
    if (result < 0) {
      Ddi_Free(care);
      Ddi_Free(potLemmas);
      Ddi_Free(lemmas);
      Trav_MgrSetAssertFlag(travMgr, 1);
      return 0;
    }
    if (0 && Ddi_BddarrayNum(potLemmas) > 0) {
      if (0) {
        partWindows = Ddi_BddarrayDup(potLemmas);
      } else {
        Ddi_Varset_t *supp = Ddi_BddarraySupp(potLemmas);

        partWindows = Ddi_BddarrayAlloc(ddm, 0);
        for (i = 0; i < Ddi_VararrayNum(ps); i++) {
          Ddi_Var_t *v = Ddi_VararrayRead(ps, i);

          if (Ddi_VarInVarset(supp, v)
            /* && (strcmp(Ddi_VarName(v),"l666")==0) */
            ) {
            Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, 1);

            Ddi_BddarrayInsertLast(partWindows, lit);
            Ddi_Free(lit);
          }
        }
        Ddi_Free(supp);
      }
    }
    Ddi_Free(potLemmas);
  }

  initTime = travMgr->travTime = util_cpu_time();

#if 1
  itpCareRef = care;
#else
  itpCareRef = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Free(care);
#endif
  //  care = Ddi_BddDup(care);
  care = Ddi_BddMakeConstAig(ddm, 1);

  if (Trav_MgrReadItpReuseRings(travMgr) == 2) {
    if (Trav_MgrReadNewi(travMgr) != NULL) {
      Ddi_Free(itpCareRef);
      itpCareRef = Ddi_BddMakeConstAig(ddm, 1);
    }
  }

  if (lemmas != NULL) {
    lemmasInvar = Ddi_BddMakeConstAig(ddm, 1);
    for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
      Ddi_BddAndAcc(lemmasInvar, Ddi_BddarrayRead(lemmas, i));
    }
    Ddi_Free(lemmas);
  }
  if (lemmasInvar != NULL) {
    if (invar != NULL) {
      Ddi_BddAndAcc(lemmasInvar, invar);
    }
  }

  useInnerCone = 0;
  if (lazyRate >= 0.89 && lazyRate <= 0.99) {
    lazyRate = 1.0;
  }

  if (lazyRate < 1) {
    optLevel = 0;
    lazyRate = 1.01;
  } else if (lazyRate >= 2.01) {
    //    stallEnable = 1;
    useInitCare = 1;
    optLevel = 2;
    if (lazyRate > 2.21) {
      doExistMaxSize *= 4;
      tryBdd = 1;
    }
    if (lazyRate > 2.26) {
      tryBdd = 2;
      existOptPlus = 1;
      useSingleCone = 1;
    }
    if (lazyRate > 2.31) {
      existOptPlus = 1;
      useSingleCone = 1;
    }
    if (lazyRate > 2.36) {
      existOptPlus = 1;
      itpBmcBound = -4;
      useSingleCone = 1;
      existLevel = 1;
    }
    if (lazyRate > 2.46) {
      itpBmcBound = -10;
      noItp = 1;
      filterNew = 1;
      useSingleCone = 1;
    }
    lazyRate -= 1.0;
  } else if (lazyRate >= 1) {
    optLevel = 1;
    if (lazyRate > 1.01) {
      useInitCare = 1;
    }
    if (lazyRate > 1.09) {
      itpBmcBound = -3;
    }
    if (lazyRate > 1.19) {
      itpBmcBound = -8;
    }
  }

  if (forceInterpolant >= 0) {
    itpBmcBound = forceInterpolant + 1;
  }

  // itpBmcBound = -30;
  if (itpExact)
    tryBdd = 2;

  if (optLevel == 0 /* || dynAbstr>3 */ ) {
    /* disable prev cone opt */
    nextSaveCone = 0;
  }

  useExtraCheck = optLevel > 3;

  Ddi_MgrSetOption(ddm, Pdt_DdiLazyRate_c, fnum, lazyRate);

  psVars = Ddi_VarsetMakeFromArray(ps);

  delta = Ddi_BddarrayDup(Fsm_MgrReadDeltaBDD(fsmMgr));
  /* check if init reachable from init */

  if (0) {
    Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");
    Ddi_Bdd_t *pLit = Ddi_BddMakeLiteralAig(pvarPs, 1);

    Ddi_Bddarray_t *subst = Ddi_BddarrayMakeLiteralsAig(ps, 1);

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Modifying TR to add !prop -> 0 state.\n", i)
      );

    for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
      Ddi_BddAndAcc(Ddi_BddarrayRead(subst, i), pLit);
    }
    Ddi_Free(pLit);
    Ddi_BddarrayComposeAcc(delta, ps, subst);
    Ddi_Free(subst);
  }

  if (0) {
    Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm, 0);
    int rrp = Ddi_MgrReadAigRedRemMaxCnt(ddm);

    Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, 1);
    DdiAigArrayRedRemovalAcc(delta, myCare, -1, -1.0);
    Ddi_Free(myCare);
    Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, rrp);

  }

  if (0 && !stallEnable) {
    Ddi_Bdd_t *checkInit = Ddi_BddCompose(init, ps, delta);

    Ddi_BddAndAcc(checkInit, init);
    stallEnable = !Ddi_AigSat(checkInit);
    Ddi_Free(checkInit);
  }
#if 0
  if (useBoundkCone && initStub == NULL) {
    int initReachable;
    Ddi_Bdd_t *checkInit = Ddi_BddCompose(init, ps, delta);

    Ddi_BddAndAcc(checkInit, init);
    initReachable = Ddi_AigSat(checkInit);
    Ddi_Free(checkInit);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr),
        "INIT is %s reachable from INIT.\n", initReachable ? "" : "NOT")
      );
    if (!initReachable) {
      stallEnable = 1;
    }
  } else if (useBoundkCone) {
    stallEnable = 1;
  }
#endif

  myInvarspec = Ddi_BddNot(itpMgr->target);
  if (travMgr->settings.aig.targetEn > 0) {
    Ddi_Bdd_t *r;
    int nIter = travMgr->settings.aig.targetEn;

    travMgr->settings.aig.targetEn = 0;
    r = Trav_TravSatBckVerif(travMgr, fsmMgr,
      init, invarspec, invar, NULL, nIter, 0, 0);
    Ddi_Free(myInvarspec);
    Ddi_BddNotAcc(r);
    myInvarspec = r;
    Ddi_BddAndAcc(care, r);
    //    stallEnable = 1;
  }

  if (stallEnable) {
    Ddi_Var_t *v = Ddi_VarNew(ddm);
    Ddi_Bdd_t *c_i;
    Ddi_Bddarray_t *pA;

    if (initStub == NULL) {
      pA = Ddi_BddarrayRangeMakeFromCube(init, ps);
    } else {
      pA = Ddi_BddarrayMakeLiteralsAig(ps, 1);
    }

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Modifying TR to add init -> init transition.\n",
        i)
      );

    Ddi_VarAttachName(v, "PDT_STALL_DUMMY_CONTROL");
    Ddi_VararrayInsertLast(pi, v);
    c_i = Ddi_BddMakeLiteralAig(v, 1);
    for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
      Ddi_Bdd_t *d_i, *p_i;

      p_i = Ddi_BddarrayRead(pA, i);
      d_i = Ddi_BddIte(c_i, Ddi_BddarrayRead(delta, i), p_i);
      Ddi_BddarrayWrite(delta, i, d_i);
      Ddi_Free(d_i);
    }
    Ddi_Free(pA);
    Ddi_Free(c_i);
    // NO: because affects backward use
    //    Fsm_MgrSetDeltaBDD (fsmMgr,delta);
  }

  nState = Ddi_BddarrayNum(delta);
  nPi = Ddi_VararrayNum(pi);

  pivars = Ddi_VarsetMakeFromArray(pi);

  {
    Ddi_Bdd_t *initPart = Ddi_AigPartitionTop(init, 0);

    initIsCube = Ddi_BddIsCube(initPart);
    Ddi_Free(initPart);
  }


  if (lemmasInvar != NULL && itpConstrLevel > 3) {
    Trav_ItpMgrQuit(itpMgr);
    itpMgr = Trav_ItpMgrInit(travMgr, fsmMgr, lemmasInvar, invarspec, 1, optLevel);
    //    Ddi_Free(lemmasInvar);
  }

  if (itpMgr->time_limit > 0) {
    itpMgr->time_limit = initTime + itpMgr->time_limit;
  }

  if (invar != NULL) {
    //itpMgr->invarConstr = Ddi_BddDup(invar);
    //invar = NULL;
  }
  if (lazyRate > 1.09) {
    itpMgr->itpOpt = optLevel;
    if (lazyRate > 1.19) {
      itpMgr->itpOpt++;
    }
    lazyRate -= 0.1;
  }

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    fprintf(tMgrO(travMgr), "lazyRate: %f - itpOpt: %d - optLevel: %d.\n",
      lazyRate, itpMgr->itpOpt, optLevel)
    );

  useInductionCone = itpMgr->itpOpt > 1;

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    if (itpMgr->nFreeDelta > 0) {
    fprintf(tMgrO(travMgr), "%d free deltas found.\n", itpMgr->nFreeDelta);}
  ) ;

  /* try TR by BDDs */

  if (1 && tryBdd > 1 && (itpExact || Ddi_VararrayNum(ps) < 120)) {

    int i, size = Ddi_BddarraySize(delta);

    //    int th = size > 500 ? 10000 : size*50;
    int th = Fsm_MgrReadCutThresh(fsmMgr) >= 0 ?
      Fsm_MgrReadCutThresh(fsmMgr) >= 0 : 5000;
    Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm, 0);
    Ddi_Bddarray_t *deltaBdd = Ddi_AigarrayOptByBdd(delta,
      auxF, auxV, th, 0, timeLimit, -1);

    if (deltaBdd != NULL) {

      int size;

      Ddi_MgrReduceHeap(ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);

      size = Ddi_BddarraySize(deltaBdd);
      if (Ddi_BddarrayNum(auxF) > 0) {
        size += Ddi_BddarraySize(auxF);
      }
      if (size > 30000 && !itpExact) {
        Ddi_Free(deltaBdd);
      } else {
        trMgr = Tr_MgrInit("TR-manager-AIG", ddm);
        Tr_MgrSetOption(trMgr, Pdt_TrSort_c, inum, Tr_SortWeight_c);

        /* enable smoothing PIs while clustering */
        Tr_MgrSetClustSmoothPi(trMgr, 1);
        Tr_MgrSetOption(trMgr, Pdt_TrClustTh_c, inum, 1000);

        Tr_MgrSetI(trMgr, pi);
        Tr_MgrSetPS(trMgr, ps);
        Tr_MgrSetNS(trMgr, ns);
        Tr_MgrSetAuxVars(trMgr, auxV);
        Tr_MgrSetAuxFuns(trMgr, auxF);

        trBdd = Tr_TrMakePartConjFromFunsWithAuxVars(trMgr,
          deltaBdd, ns, auxF, auxV);

        itpMgr->trBdd = Tr_TrDup(trBdd);
        itpMgr->trAig = Tr_TrDup(trBdd);
        for (i = 0; i > Ddi_BddPartNum(Tr_TrBdd(itpMgr->trBdd)); i++) {
          Ddi_Bdd_t *tr_i = Ddi_BddPartRead(Tr_TrBdd(itpMgr->trBdd), i);

          Ddi_BddSetAig(tr_i);
        }

        itpMgr->trBddIsAig = 0;

        Tr_TrReverseAcc(trBdd);
        Tr_MgrSetImgAndExistTh(trMgr, imgAndExistTh);
        Tr_TrSortIwls95(trBdd);

        //      Tr_TrSortIwls95(trBdd);
        Tr_TrReverseAcc(trBdd);

        Tr_TrSetClustered(trBdd);

        Tr_TrSortIwls95(itpMgr->trBdd);
        Tr_TrSetClustered(itpMgr->trBdd);

        Ddi_BddSwapVarsAcc(Tr_TrBdd(trBdd), ps, ns);
        for (i = 0; i < Ddi_BddarrayNum(auxF); i++) {
          Ddi_BddSwapVarsAcc(Ddi_BddarrayRead(Tr_MgrReadAuxFuns(trMgr), i), ps,
            ns);
        }

        useInductionCone = 0;
        useTrBdd = 1;

        Ddi_Free(deltaBdd);
      }
    }
    Ddi_Free(auxV);
    Ddi_Free(auxF);

  } else if (itpAppr > 0 && (nState < 5000 || itpAppr > 1)) {

    trMgr = Tr_MgrInit("TR-manager-AIG", ddm);
    Tr_MgrSetOption(trMgr, Pdt_TrSort_c, inum, Tr_SortWeight_c);

    /* enable smoothing PIs while clustering */
    Tr_MgrSetClustSmoothPi(trMgr, 1);
    Tr_MgrSetOption(trMgr, Pdt_TrClustTh_c, inum, 1000);

    Tr_MgrSetI(trMgr, pi);
    Tr_MgrSetPS(trMgr, ps);
    Tr_MgrSetNS(trMgr, ns);

    trBdd = Tr_TrMakePartConjFromFunsWithAuxVars(trMgr, delta, ns, NULL, NULL);

    itpMgr->trBdd = Tr_TrDup(trBdd);

    Tr_TrReverseAcc(trBdd);
    Tr_MgrSetImgAndExistTh(trMgr, imgAndExistTh);
    if (nState < 2000) {
      Tr_TrSortIwls95(trBdd);
    }
    //      Tr_TrSortIwls95(trBdd);
    Tr_TrReverseAcc(trBdd);

    // Tr_TrSetClustered(trBdd);
    Ddi_BddSetClustered(Tr_TrBdd(trBdd), 1000);

    if (nState < 2000) {
      Tr_TrSortIwls95(itpMgr->trBdd);
    }
    //    Tr_TrSetClustered(itpMgr->trBdd);
    Ddi_BddSetClustered(Tr_TrBdd(itpMgr->trBdd), 1000);

    Ddi_BddSwapVarsAcc(Tr_TrBdd(trBdd), ps, ns);

    //useInductionCone = 0;
    itpMgr->trBddIsAig = 1;

  }

  if (tryBdd > 1) {
    if (existOptPlus)
      tryBdd = 0;
  }


  /* build tr */
  nsLit = Ddi_BddarrayMakeLiteralsAig(ns, 1);
  psLit = Ddi_BddarrayMakeLiteralsAig(ps, 1);
  piLit = Ddi_BddarrayMakeLiteralsAig(pi, 1);

  tr = Ddi_BddRelMakeFromArray(delta, ns);
  Ddi_BddSetAig(tr);

#if 0
  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c,
    fprintf(tMgrO(travMgr), "FREE   DELTA: %d/%d.\n", nFreeDelta, nState)
    );
  for (i = 0; i < 10; i++) {
    if (nSuppDelta[i] > 0)
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "%d SUPP DELTA: %d/%d.\n", i, nSuppDelta[i],
          nState)
        );
  }
#endif

  Ddi_Free(pivars);

  loopFree = Ddi_BddMakeConstAig(ddm, 1);
  unroll = Ddi_BddMakeConstAig(ddm, 1);
  reached = Ddi_BddMakeConstAig(ddm, 0);

  //  DdiAigRedRemovalAcc (tr,myInvarspec,-1);
  //  Ddi_BddAndAcc(tr,myInvarspec);

  if (itpMgr->time_limit > 0 && (util_cpu_time() > itpMgr->time_limit)) {
    /* nxr: make the function to abort */
    sat = -1;
  }
  startTime = util_cpu_time();

  supp = Ddi_BddSupp(myInvarspec);
  if (Ddi_VarsetIsArray(psVars)) {
    Ddi_VarsetSetArray(supp);
  }
  Ddi_VarsetIntersectAcc(supp, psVars);

  timeFrameInfoPush(itpMgr->timeFrames, psLit, ps, piLit, pi, supp);

  Ddi_Free(supp);

  newCone = Ddi_BddNot(myInvarspec);
  Ddi_BddWriteMark(newCone, 0);

  if (0) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");

    if (iv != NULL) {
      Ddi_BddCofactorAcc(newCone, iv, 1);
    }
  }

  if (trBdd != NULL) {
    coneBdd = Ddi_BddMakeMono(newCone);
    careBdd = Ddi_BddMakeConst(ddm, 1);
  }


  if (keepConeRings) {
    fullConeRings = Ddi_BddMakePartDisjVoid(ddm);
  }

  newConeRed = Ddi_BddNot(myInvarspec);
  if (0 && optLevel > 1) {
    newConeAux = Ddi_BddNot(myInvarspec);
    fullConeAux = Ddi_BddMakeConstAig(ddm, 0);
  }
  if (useInitCare) {
    Ddi_BddOrAcc(reached, newCone);
    Ddi_BddDiffAcc(care, newCone);
  }

  fullCone = Ddi_BddMakeConstAig(ddm, 0);
  inductionCone = Ddi_BddDup(newCone);

  /* main interpolation loop */
  for (i = 0; !sat; i++) {
    Ddi_Bdd_t *check;           //, *oldCare;
    int coiNum = 1, fixPoint = 0;
    int simplifyCone = 0, simplifiedCone = 0;;
    int forceFixpointCheck = 0, fullState = 0, tryFixpointCheck = 0;
    Ddi_Bdd_t *rOut = NULL;
    Ddi_Bdd_t *careOut = NULL;

    if (itpOutOfLimits(itpMgr)) {
      sat = -1;
      res = 2;                  /* abort */
      break;
    }

    if (bound > 0 && i >= bound) {
      sat = -1;
      res = 2;                  /* abort */
      break;
    }

    if (doStoreR) {
      rOut = Ddi_BddMakeConstAig(ddm, 1);
    }

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      int nbaig = Ddi_MgrReadAigNodesNum(ddm);
      fprintf(tMgrO(travMgr),
        "Using bwd cone at bound %d (cone(aux): %d(%d) - care: %d).\n", i,
        Ddi_BddSize(newCone), newConeAux ? Ddi_BddSize(newConeAux) : 0,
        care ? Ddi_BddSize(care) : 0);
      fprintf(tMgrO(travMgr), "{COI: %d} ", coiNum);
      fprintf(tMgrO(travMgr), "curr NODE ID: %d, ", ddm->currNodeId);
      fprintf(tMgrO(travMgr), "baig Nodes: %d.\n", nbaig)
      );

    if (0 && invar != NULL) {
#if 1
#if 1
      // wrong abstraction when using lemmas under invar assumption
      Ddi_Bdd_t *myInvar =
        Ddi_BddMakeLiteralAig(Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS"), 1);
#else
      Ddi_Bdd_t *myInvar = Ddi_BddDup(invar);
#endif

      Ddi_Bdd_t *partCone = Ddi_AigPartitionTop(newCone, 1);
      int j;

      for (j = 0; j < Ddi_BddPartNum(partCone); j++) {
        Ddi_BddAndAcc(Ddi_BddPartRead(partCone, j), myInvar);
      }
      Ddi_BddSetAig(partCone);
      Ddi_DataCopy(newCone, partCone);
      Ddi_Free(partCone);
      Ddi_Free(myInvar);
#else
      Ddi_BddAndAcc(newCone, invar);
#endif
      if (newConeAux != NULL) {
        Ddi_BddAndAcc(newConeAux, invar);
      }
    }

    int tryMe = 0;

    if (tryMe) {
      Ddi_Var_t *v = Ddi_VarFromName(ddm, "stall");
      Ddi_Var_t *v0 = Ddi_VarFromName(ddm, "stall_0");
      Ddi_Varset_t *supp = Ddi_VarsetMakeFromVar(v);
      Ddi_Varset_t *supp0 = Ddi_VarsetMakeFromVar(v0);

      DdiAigExistOverAcc(newCone, supp0, NULL);
      DdiAigExistOverAcc(newCone, supp, NULL);
      Ddi_Free(supp);
      Ddi_Free(supp0);
    }

    if (partWindows != NULL) {
      int j;
      int size1, size0 = Ddi_BddSize(newCone);

      for (j = 0; j < Ddi_BddarrayNum(partWindows); j++) {
        Ddi_Bdd_t *window = Ddi_BddarrayRead(partWindows, j);
        Ddi_Bdd_t *a = Ddi_BddDup(newCone);
        Ddi_Bdd_t *b = Ddi_BddDup(newCone);

        Ddi_AigConstrainCubeAcc(a, window);
        Ddi_BddAndAcc(a, window);

        Ddi_BddNotAcc(window);
        Ddi_AigConstrainCubeAcc(b, window);
        Ddi_BddAndAcc(b, window);
        Ddi_BddNotAcc(window);

        Ddi_BddOrAcc(a, b);
        Ddi_Free(b);
        size1 = Ddi_BddSize(a);
        if (size1 < 1.1 * size0) {
          Ddi_Free(newCone);
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "ncPartw.\n")
            );
          newCone = a;
          size0 = size1;
          Ddi_Free(inductionCone);
          inductionCone = Ddi_BddDup(newCone);
        } else {
          Ddi_Free(a);
        }
      }
    }

    if (initStub == NULL)
      if (itpMgr->unsatGuaranteed < 0 || i >= itpMgr->unsatGuaranteed) {
        check = Ddi_BddDup(newConeAux != NULL ? newConeAux : newCone);

        if (abstrRef) {
          Ddi_BddComposeAcc(check, itpMgr->abstrRefCtrl,
            itpMgr->abstrDoRefine);
        }
        if (newConeConstraint != NULL) {
          Ddi_BddAndAcc(check, newConeConstraint);
        }
        if (newConeConstraint2 != NULL) {
          Ddi_BddAndAcc(check, newConeConstraint2);
        }
        if (invar) {
          Ddi_BddAndAcc(check, invar);
        }
        if (newConeAux != NULL
          && Ddi_BddSize(newCone) < Ddi_BddSize(check) / 10) {
          Ddi_DataCopy(check, newCone);
        }
        if (initStub != NULL) {
          Ddi_BddComposeAcc(check, ps, initStub);
        } else if (initIsCube) {
          Ddi_AigAndCubeAcc(check, init);
        } else {
          Ddi_BddAndAcc(check, init);
        }

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), " BMC (AIG size: %d/%d/%d) ",
            Ddi_BddSize(check), Ddi_BddSize(newCone), Ddi_BddSize(newConeRed))
          );

        sat = Ddi_AigSatWithAbort(check, lazyTimeLimit);
        if (sat == -1) {
          /* aborted */
          DdiAigRedRemovalAcc(check, NULL, -1, 2 * lazyTimeLimit);
          sat = Ddi_AigSatWithAbort(check, 4 * lazyTimeLimit) == 1;
          //      sat = Ddi_AigSat(check)==1;
        }
        Ddi_Free(check);
        if (sat) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "BMC failure at bound %d.\n", i)
            );
          res = 0;
          Ddi_Free(itpCareRef);
          Ddi_Free(care);
          Ddi_Free(rOut);
          break;
        }
      } else {
        sat = 0;
      }

    if (0) {
      if (Ddi_BddSize(care) > 100) {
        Ddi_Bdd_t *eq = DdiAigEquivVarsAcc(care, NULL,
          NULL, psVars, newCone, NULL, NULL);

        if (eq != NULL) {
          Ddi_BddAndAcc(care, eq);
          Ddi_Free(eq);
        }
      }
    }
    if (0) {
      Ddi_Bddarray_t *implArray = Ddi_BddarrayAlloc(ddm, 0);
      Ddi_Bdd_t *carePlusCube = DdiAigImplicationsAcc(care, NULL, NULL,
        psVars, implArray);

      if (implArray != NULL && Ddi_BddarrayNum(implArray) > 0) {
        Ddi_Bdd_t *careDup = Ddi_BddDup(care);

        Ddi_AigConstrainImplAcc(care, implArray);
        Ddi_AigConstrainImplAcc(newCone, implArray);
        Ddi_BddAndAcc(care, carePlusCube);
        Ddi_BddXorAcc(careDup, care);
        Pdtutil_Assert(!Ddi_AigSat(careDup), "wrong impl constrain");
        Ddi_Free(careDup);
      }
      Ddi_Free(implArray);
      Ddi_Free(carePlusCube);
    }

    if (0 && !stallEnable && step > 2 && i > 2 &&
      /* (Ddi_BddSize(care) > 10) && */ --maxLemmas > 0) {
      int result = 0, l, nstate = Ddi_BddarrayNum(delta);
      Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_Bdd_t *enlargedSpec = Ddi_BddNot(newCone);
      Ddi_Bddarray_t *potLemmas = Ddi_BddarrayAlloc(ddm, 0);
      Ddi_Bddarray_t *lambda = Fsm_MgrReadLambdaBDD(fsmMgr);

      Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");
      Ddi_Bdd_t *deltaProp = NULL;
      Ddi_Bdd_t *myInvarspec = NULL;

      for (l = 0; l < nstate; l++) {
        Ddi_Var_t *v_i = Ddi_VararrayRead(ps, l);

        if (v_i == pvarPs) {
          iProp = l;
          break;
        }
      }
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "iprop = %d/%d.\n", iProp, nstate)
        );
      //      deltaProp = Ddi_BddDup(Ddi_BddarrayRead(delta,iProp));
      // Ddi_BddarrayWrite(delta,iProp,enlargedSpec);

      Ddi_DataCopy(Fsm_MgrReadDeltaBDD(fsmMgr), delta);
      Ddi_BddarrayInsert(lambda, 1, newCone);
      if (invar != NULL) {
        myInvarspec = Ddi_BddDup(itpMgr->target);
        Ddi_BddAndAcc(enlargedSpec, invar);
      } else {
        myInvarspec = enlargedSpec;
      }
      lemmas = genLemmaClasses(travMgr, fsmMgr,
        init, initStub, invar,
        myInvarspec /*enlargedSpec */ , myCare, potLemmas, step, 1, 0, 0,
        &result, 0, NULL);
      //      Ddi_Free(deltaProp);
      Ddi_Free(myInvarspec);

      Ddi_DataCopy(delta, Fsm_MgrReadDeltaBDD(fsmMgr));

      Ddi_Free(newCone);
      //      newCone = Ddi_BddNot(Ddi_BddarrayRead(delta,iProp));
      //      Ddi_BddarrayWrite(delta,iProp,deltaProp);
      newCone = Ddi_BddarrayExtract(lambda, 1);
      //      Ddi_Free(deltaProp);
      Ddi_Free(enlargedSpec);
      Ddi_Free(myCare);
      Ddi_Free(potLemmas);
      Ddi_Free(lemmas);
      Ddi_Free(delta);
      delta = Ddi_BddarrayDup(Fsm_MgrReadDeltaBDD(fsmMgr));
      if (result) {
        res = result > 0 /*1 */ ;
        Ddi_Free(rOut);
        break;
      }
    }

    if (care != NULL && Ddi_BddSize(care) > 1) {
      computeFullCone = 1;
    }

    if (0 && lemmasInvar != NULL) {
#if 1
      Ddi_AigExistProjectAcc(lemmasInvar, psVars, NULL, 0, 0, -1.0);
      Ddi_BddAndAcc(care, lemmasInvar);
#else
      Ddi_BddAndAcc(newCone, lemmasInvar);
#endif
    }

    doExist = useTrBdd || (sizeIncrease > 2.0 /*&& i>1 */ ) ||
      Ddi_BddSize(newCone) < 50 ||
      Ddi_BddSize(newCone) > doExistThreshold || Ddi_VararrayNum(pi) < 50;
    doExist = (doExist || i <= 2) && (nBadDoExist < 1);
    doExist &= useInitCare;
    doExist &= Ddi_BddSize(newCone) < doExistMaxSize;

    bddSuccess = 0;
    if (1 && doExist) {
      newConeAux2 = Ddi_BddDup(newCone);
    }

    if (0 && !doExist) {
      int n;
      Ddi_Varset_t *sm = Ddi_BddSupp(newCone);

      Ddi_VarsetDiffAcc(sm, psVars);
      doExist = (n = Ddi_VarsetNum(sm) > 0 && n <= 30);
      fullState = n == 0;
      Ddi_Free(sm);
    }

    if (0 && reached != NULL && care != NULL) {
      Ddi_Bdd_t *a = Ddi_BddOr(reached, care);

      /* IsOne is not correct */
      Pdtutil_Assert(Ddi_BddIsOne(a), "wrong reached-care");
      Ddi_Free(a);
    }

    /* new inductive check */
    if (1 && useInductionCone &&
      Ddi_BddSize(newCone) > Ddi_BddSize(inductionCone) / 10) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "pseudo-inductive cone: %d.\n",
          Ddi_BddSize(inductionCone))
        );
      sat = Ddi_AigSatWithAbort(inductionCone, (int)lazyTimeLimit);
      if (sat == 0) {
        /* fix point */
        doExist = 0;
        itpBmcBound = -1;
        fixPoint = 1;
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "PSEUDO-INDUCTIVE FIX POINT.\n")
          );
      }
      sat = 0;
    }

    if (doExist && (optLevel > 1 || optLevel > 0 && (i < 15 ||
          (existLevel > 1 && i < 6)))) {

      int size;

      if (tryBdd == 1 && !useTrBdd && maxFailBddBwd >= 0) {
        int size = Ddi_BddSize(newCone), size1;
        int sizeTh = size < 2000 ? 10000 : (size < 20000 ? size * 10 : 200000);
        Ddi_Bdd_t *bddSmooth = DdiAigExistProjectByBdd(newCone, care,
          sizeTh, psVars, -1.0, 0, 0);

        if (bddSmooth != NULL
          && ((size1 = Ddi_BddSize(bddSmooth)) < 1.5 * size)) {
          bddSuccess = 1;
          DdiGenericDataCopy((Ddi_Generic_t *) newCone,
            (Ddi_Generic_t *) bddSmooth);
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "BDD exist: %d -> %d.\n", size, size1)
            );
        } else if (bddSmooth == NULL) {
          maxFailBddBwd = -1;
        } else {
          maxFailBddBwd--;
        }
        Ddi_Free(bddSmooth);
      }

      if (!bddSuccess && !useTrBdd && Ddi_BddSize(newCone) < 10000) {
        /* @@@@@@@@@@@@@@@@@@@@@@@ */
        int doQuantify;
        Ddi_Varset_t *sm = Ddi_BddSupp(newCone);

        Ddi_VarsetDiffAcc(sm, psVars);
        if (!Ddi_VarsetIsVoid(sm)) {
          doQuantify = 1;
        }

        Ddi_Free(sm);

        if (doQuantify) {
          if (filterNew) {
            int j, k;
            Ddi_Bdd_t *partCone = Ddi_AigPartitionTop(newCone, 1);

            if (Ddi_BddPartNum(partCone) > 1) {
              int np = Ddi_BddPartNum(partCone);
              int *suppNum = Pdtutil_Alloc(int, np
              );
              int *sortedIds = Pdtutil_Alloc(int, np
              );
              Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm, 1);
              Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);

              for (j = 0; j < Ddi_BddPartNum(partCone); j++) {
                Ddi_Bdd_t *p_j = Ddi_BddPartRead(partCone, j);
                Ddi_Varset_t *sm = Ddi_BddSupp(p_j);

                Ddi_VarsetDiffAcc(sm, psVars);
                suppNum[j] = Ddi_VarsetNum(sm);
                Ddi_Free(sm);
                sortedIds[j] = j;
              }
              for (j = 0; j < np; j++) {
                for (k = j + 1; k < np; k++) {
                  int jj = sortedIds[j];
                  int kk = sortedIds[k];

                  if (suppNum[jj] > suppNum[kk]) {
                    int t = sortedIds[j];

                    sortedIds[j] = sortedIds[k];
                    sortedIds[k] = t;
                  }
                }
              }
              for (k = 0; k < np; k++) {
                Ddi_Bdd_t *p_j;

                j = sortedIds[k];
                p_j = Ddi_BddPartRead(partCone, j);
                if (suppNum[j] > 0 && suppNum[j] < 10) {
                  Ddi_AigExistProjectAcc(p_j, psVars, myCare, 3, 0,
                    lazyTimeLimit);
                  Ddi_Varset_t *sm = Ddi_BddSupp(p_j);

                  Ddi_VarsetDiffAcc(sm, psVars);
                  suppNum[j] = Ddi_VarsetNum(sm);
                  Ddi_Free(sm);
                }
                if (suppNum[j] == 0) {
                  Ddi_BddDiffAcc(myCare, p_j);
                  if (notReached == NULL) {
                    notReached = Ddi_BddMakeConstAig(ddm, 1);
                  }
                  Ddi_BddDiffAcc(notReached, p_j);
                  if (bckReached == NULL) {
                    bckReached = Ddi_BddDup(p_j);
                  } else {
                    Ddi_BddOrAcc(bckReached, p_j);
                  }
                  Ddi_BddPartWrite(partCone, j, myZero);
                }
              }
              Ddi_BddSetAig(partCone);
              Ddi_DataCopy(newCone, partCone);
              Ddi_Free(myCare);
              Ddi_Free(myZero);
              Pdtutil_Free(suppNum);
              Pdtutil_Free(sortedIds);
            }
            Ddi_Free(partCone);
          }
          Ddi_AigExistProjectAcc(newCone, psVars, notReached, 3, 0,
            lazyTimeLimit);
          if (bckReached != NULL) {
            //      Ddi_BddDiffAcc(care,bckReached);
            //          Ddi_BddOrAcc(newCone,bckReached);
            //      Ddi_Free(bckReached);
          }
        }
      }
      {
        Ddi_Varset_t *sm = Ddi_BddSupp(newCone);

        Ddi_VarsetDiffAcc(sm, psVars);
        if (!Ddi_VarsetIsVoid(sm) && (Ddi_VarsetNum(sm) <= (i < 4 ? 100 : 20))) {
          Ddi_AigExistProjectAcc(newCone, psVars, notReached, 1, 0,
            lazyTimeLimit);
          Ddi_Free(sm);
          sm = Ddi_BddSupp(newCone);
          Ddi_VarsetDiffAcc(sm, psVars);
        }
        if (Ddi_VarsetIsVoid(sm) || Ddi_VarsetNum(sm) == 0) {
          fullState = 1;
          nGoodDoExist++;
          if (i >= nextSaveCone && dynAbstr <= 3) {
            nextSaveCone += 1;
          }
          forceFixpointCheck = 1;
        } else if (1) {

          if (1) {

            Ddi_AigOptByConstrain(newCone, NULL, NULL, 2);
          } else {
            Ddi_Bdd_t *b1 = Ddi_AigPartitionTop(newCone, 1);
            int l;

            for (l = 0; l < Ddi_BddPartNum(b1); l++) {
              Ddi_Bdd_t *p = Ddi_BddPartRead(b1, l);
              Ddi_Bdd_t *p1 = DdiAigFuncDepAcc(p, NULL,
                itpMgr->psvars, NULL, NULL, NULL, NULL, NULL, NULL);

              Ddi_BddPartWrite(b1, l, p1);
              Ddi_Free(p1);
            }
            Ddi_BddSetAig(b1);
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "FUNC DEP QUANT of cone: %d -> %d.\n",
                Ddi_BddSize(newCone), Ddi_BddSize(b1))
              );
            Ddi_DataCopy(newCone, b1);
            Ddi_Free(b1);

          }
          if (Ddi_VarsetNum(sm) > 5 || Ddi_BddSize(newCone) > 20000) {
            nBadDoExist++;
            tryFixpointCheck = 1;
          }

        } else if (Ddi_VarsetNum(sm) > 5 || Ddi_BddSize(newCone) > 20000) {
          nBadDoExist++;
          tryFixpointCheck = 1;
        }
        simplifyCone = 1;
        Ddi_Free(sm);
      }
      if (optLevel > 1 && oldCone != NULL && !fullState) {  /* filter on num vars */
        Ddi_Bdd_t *myCare = NULL;   // Ddi_BddDiff(notReached,oldCone);

        Ddi_AigExistProjectAcc(newCone, psVars, myCare, 3, 0, lazyTimeLimit);
        Ddi_Free(myCare);
      }
      if (care != NULL) {
        //      Ddi_BddAndAcc(newCone,care);
      }
    } else if (0 && i < 6) {
      Ddi_AigOptByConstrain(newCone, NULL, NULL, 4);
      if (Ddi_BddSize(newCone) > 2000) {
        DdiAigFuncDepAcc(newCone, 0, 0, itpMgr->psvars, 0, 0, 0, 0, 0);
      }
      DdiAigRedRemovalControlAcc(newCone, care, -1, 30.0);
    }

    if (!doExist && nGoodDoExist >= 2 && optLevel > 0 &&
      Ddi_BddSize(care) < 20000 &&
      Ddi_BddSize(care) > Ddi_BddSize(newCone) / 2) {
      tryFixpointCheck = 1;
      nGoodDoExist--;
    }
    if (itpBmcBound == 1 && (tryFixpointCheck || forceFixpointCheck)) {
      itpBmcBound++;
    }

    if (0) {
      Ddi_Varset_t *sc = Ddi_BddSupp(care);

      if (!Ddi_VarsetIsVoid(sc)) {
        Ddi_VarsetIntersectAcc(sc, pivars);
        Pdtutil_Assert(Ddi_VarsetIsVoid(sc), "pis in care");
      }
    }

    if (1 && constrainOpt) {
      Ddi_Bdd_t *r = Ddi_BddNot(care);

      //      Ddi_AigConstrainOptAcc(newCone,care,NULL,NULL,NULL,0);
      //      Ddi_BddOrAcc(newCone,r);
      //      Ddi_BddAndAcc(newCone,care);
      //      DdiAigRedRemovalAcc (newCone,NULL,-1,2*lazyTimeLimit);
      DdiAigRedRemovalAcc(newCone, care, -1, 2 * lazyTimeLimit);
      Ddi_Free(fullCone);
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "fc.\n")
        );
      fullCone = Ddi_BddOr(newCone, r);
      if (newConeAux != NULL) {
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "fca.\n")
          );
        Ddi_Free(fullConeAux);
        fullConeAux = Ddi_BddOr(newConeAux, r);
      }
      Ddi_Free(r);
    } else if (!useSingleCone && (fullState) && (itpMgr->specSpace != NULL ||
        1 && !stallEnable && computeFullCone)) {
      if (0 || !fullState) {
        Ddi_BddOrAcc(fullCone, newCone);
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "fcn.\n")
          );
        if (newConeAux != NULL) {
          Ddi_BddOrAcc(fullConeAux, newConeAux);
        }
      }
      //        DdiAigRedRemovalAcc (fullCone,care,-1,30.0);
    } else {
      Ddi_Bdd_t *r = Ddi_BddNot(care);

      if (0 && (Ddi_BddSize(newCone) < 10000) && Ddi_BddSize(care) > 10) {
        Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm, 1);

        Ddi_BddarrayWrite(fA, 0, newCone);
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "fcarr.\n")
          );
#if 0
        Ddi_BddarrayWrite(fA, 1, fullCone);
        DdiAigArrayRedRemovalControlAcc(fA, care, -1, 30.0);
        //      DdiAigRedRemovalControlAcc (optCone,care,-1,30.0);
        //      Ddi_BddNotAcc(care);
        //      Ddi_BddOrAcc(optCone,care);
        //      Ddi_BddNotAcc(care);
        if (1 || Ddi_BddSize(Ddi_BddarrayRead(fA, 0)) < Ddi_BddSize(newCone)) {
          Ddi_DataCopy(newCone, Ddi_BddarrayRead(fA, 0));
        }
        if (1 || Ddi_BddSize(Ddi_BddarrayRead(fA, 1)) < Ddi_BddSize(fullCone)) {
          Ddi_DataCopy(fullCone, Ddi_BddarrayRead(fA, 1));
        }
#else
        DdiAigArrayRedRemovalControlAcc(fA, care, -1, 30.0);
        if (1 || Ddi_BddSize(Ddi_BddarrayRead(fA, 0)) < Ddi_BddSize(newCone)) {
          Ddi_DataCopy(newCone, Ddi_BddarrayRead(fA, 0));
          simplifiedCone = 1;
        }
#endif
        Ddi_Free(fA);
        //      DdiAigRedRemovalControlAcc (fullCone,care,-1,30.0);
      }
      if (!fullState) {
        if (!useSingleCone) {
          Ddi_BddOrAcc(fullCone, newCone);
        } else {
          Ddi_Free(fullCone);
          fullCone = Ddi_BddDup(newCone);
        }
      }

      if (0 && invar != NULL) {
        Ddi_BddAndAcc(fullCone, invar);
      }
      //      Ddi_Free(fullCone);

      // fullCone = Ddi_BddDup(newCone);

      if (newConeAux != NULL) {
        Ddi_Free(fullConeAux);
        fullConeAux = Ddi_BddDup(newConeAux);
      }
      Ddi_Free(r);
    }

    if (simplifiedCone) {
      Ddi_BddNotAcc(care);
      Ddi_BddOrAcc(newCone, care);
      if (0 && newConeAux != NULL) {
        Ddi_BddOrAcc(newConeAux, care);
      }
      Ddi_BddNotAcc(care);
    }

    if (keepConeRings) {
      int j;

      for (j = 0; j < coneRingPeriod; j++) {
        Ddi_BddPartInsertLast(fullConeRings, fullCone);
      }
    }

    Pdtutil_VerbosityMgr(travMgr, Pdtutil_VerbLevelUsrMin_c,
      fprintf(tMgrO(travMgr), "Full Cone (Aux): %d(%d))\n",
        Ddi_BddSize(fullCone), fullConeAux ? Ddi_BddSize(fullConeAux) : 0)
      );

    if (0) {
      Ddi_Bddarray_t *benchArray;
      char filename[100];

      sprintf(filename, "cone%02d.bench", i);
      benchArray = Ddi_BddarrayAlloc(ddm, 0);
      Ddi_BddarrayInsertLast(benchArray, fullCone);
      Ddi_BddarrayInsertLast(benchArray, care);
      Ddi_AigarrayNetStore(benchArray, filename, NULL,
        Pdtutil_Aig2BenchLocalId_c);
      Ddi_Free(benchArray);
    }

    if (0 && itpMgr->specSpace != NULL) {
      /* da GpC per StQ: stats su cono !!! */
      Ddi_Bdd_t *partCone = Ddi_AigPartitionTop(fullCone, 1);
      int j, sizePeak = 0, sizeOver = 0, sizeTot = Ddi_BddSize(fullCone);

      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "PART CONE SIZE: %d -> ", sizeTot)
        );
      for (j = 0; j < Ddi_BddPartNum(partCone); j++) {
        Ddi_Bdd_t *p_j = Ddi_BddPartRead(partCone, j);
        int size_j = Ddi_BddSize(p_j);

        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "%d ", size_j)
          );
        sizeOver += size_j;
        if (size_j > sizePeak)
          sizePeak = size_j;
      }
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "(over: %f, peak: %f).\n",
          ((float)sizeOver) / sizeTot, ((float)sizePeak) / sizeTot)
        );
      Ddi_Free(partCone);
    }

    if (fixPoint <= 0)
      do {

        fixPoint = optLevel > 0 ? -1 : 0;
        if (itpBmcBound > 0 && !noItp)
          itpBmcBound--;
#if 0
        if (forceInterpolant >= 0) {
          itpBmcBound = forceInterpolant < i;
        } else if (forceInterpolant < -1) {
          itpBmcBound = 0;
        }
#endif

        if (!tryFixpointCheck && !forceFixpointCheck) {
          if (itpBmcBound == 1) {
            nDeferred = deferConeBuild;
            deferConeBuild = 0;
          } else {
            // deferConeBuild++;
            deferConeBuild = 0;
          }
        }

        if (1 && itpBmcBound == 0) {
          int abort1 = 0;
          Ddi_Bdd_t *itpCare = Ddi_BddDup(itpCareRef);

          //      Ddi_Bdd_t *itpCare = Ddi_BddDup(care);
          Ddi_Bdd_t *itpCone = fullCone;

          //doExist = 1;
          if (1 && fullConeAux != NULL &&
            Ddi_BddSize(fullConeAux) < 0.95 * Ddi_BddSize(fullCone)) {
            itpCone = fullConeAux;
          }
#if 0
          abort1 = 1;
#else

          if (bckReached != NULL) {
            Ddi_BddDiffAcc(itpCare, bckReached);
          }
          if (0 && fullState) {
            Ddi_BddDiffAcc(itpCare, newCone);
          }
          if (0 && itpMgr->itpOpt > 0) {
            careOut = Ddi_BddMakeConstAig(ddm, 1);
          }
          if (existOptPlus && Ddi_BddSize(itpCare) > 10) {
            //      int ibr = Ddi_MgrReadAigSatIncrByRefinement(ddm);
            // Ddi_MgrSetAigSatIncrByRefinement(ddm,2);
            int rrp = Ddi_MgrReadAigRedRemMaxCnt(ddm);

            //        Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRemPeriod_c,inum,1);

            if (0 && useSingleCone) {
              Ddi_Free(fullCone);
              Ddi_BddAndAcc(newCone, itpCare);
              DdiAigRedRemovalAcc(newCone, itpCare, -1, 30.0);
              Ddi_BddNotAcc(itpCare);
              Ddi_BddOrAcc(newCone, itpCare);
              Ddi_BddNotAcc(itpCare);
              fullCone = itpCone = Ddi_BddDup(newCone);
            } else if (0) {
              DdiAigArrayRedRemovalControlAcc(delta, itpCare, -1, -1.0);
              DdiAigRedRemovalControlAcc(newCone, itpCare, -1, -1.0);
              DdiAigRedRemovalControlAcc(fullCone, itpCare, -1, -1.0);
              //        DdiAigArrayRedRemovalAcc (delta,itpCare,-1,-1.0);
            }

            Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, rrp);
            // Ddi_MgrSetAigSatIncrByRefinement(ddm,ibr);
          }

          itpCone = Ddi_BddDup(itpCone);
          if (useBoundkCone <= 1 && itpMgr->target != NULL) {
            Ddi_BddOrAcc(itpCone, itpMgr->target);
          }
          if (newConeConstraint != NULL) {
            Ddi_BddAndAcc(itpCone, newConeConstraint);
          }
          if (newConeConstraint2 != NULL) {
            Ddi_BddAndAcc(itpCone, newConeConstraint2);
          }

          if (keepConeRings) {
            Ddi_Free(itpCone);
            itpCone = Ddi_BddDup(fullConeRings);
          }

          if (itpRefineCex) {
            careOut = Ddi_BddMakeConstAig(ddm, 1);
          }

          firstFwdIter = -1;    // disable
          itpBmcBound = checkFixPointByInterpolant(itpMgr, travMgr,
            fsmMgr, itpCone, previousCone /*inductionCone */ ,
            init, itpCare, careBdd, rOut, careOut,
            previousConeAuxLits, optLevel, &abort1, itpMgr->time_limit,
            i + 1, firstFwdIter, 0, itpMgr->timeFrames);

          firstFwdIter = -1;    // disable for next calls

          if (careOut != NULL && !Ddi_BddIsOne(careOut)) {
            Ddi_BddOrAcc(newCone, careOut);
            Ddi_BddNotAcc(careOut);
            Ddi_BddAndAcc(care, careOut);
          }

          Ddi_Free(careOut);

          //      Ddi_Free(itpCone);
#endif

          if (abort1 == 3) {
            abort1 = 1;
            sat = 1;
          }
          if (abort1) {
            fixPoint = -1;
            itpBmcBound = -1;
          } else if (itpBmcBound >= 0) {
            fixPoint = 1;
          } else {

            disConeUnwind = 0;
            fixPoint = Trav_IgrTrav(travMgr, fsmMgr,
              itpMgr, itpCone, itpCare,
              rOut, careOut, i, 0, &itpBmcBound, &abort1, &sat);

            if (0 && !fixPoint && !sat) {
              abort1 = 1;
              Ddi_Free(rOut);
              itpMgr->time_limit = util_cpu_time();
            }
            if (abort1 == 2) {
              abort1 = 0;
              Pdtutil_Assert(abstrRef, "abort requires abstr ref mode");
              disConeUnwind = 1;
              i--;
            }

            if (abort1 > 0) {
              fixPoint = -1;
              itpBmcBound = -1;
            } else if (noBoundOpt) {
              itpBmcBound++;
            } else if (0 && itpBmcBound > 2 && itpMgr->nRings > 2) {
              itpBmcBound = 2;
            } else if (!optForDeep &&
              itpBmcBound > 2 && itpBmcBound > i / 2) {
              if (i <= 4) {
                itpBmcBound = 3;
              } else if (i <= 8) {
                itpBmcBound = 4;
              } else {
                itpBmcBound = i / 3;
              }
            } else if (optForDeep && itpBmcBound > i) {
              itpBmcBound *= 0.8;
            }

            if (itpBmcBound > 3 && optLevel > 0) {
              nextSaveCone = i + 1;
              savedConeWindow = 2;
            }
          }

          Ddi_Free(itpCare);
          Ddi_Free(itpCone);
        } else if (itpBmcBound < 0) {
          fixPoint = -1;
        } else {
          fixPoint = optLevel > 0 ? -1 : -2;
          fixPoint = -2;
          //      doExist = 0;
        }

        if (sat) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "BMC failure at bound %d.\n", i)
            );
          fixPoint = 0;
          res = 0;
          Ddi_Free(itpCareRef);
          Ddi_Free(care);
          Ddi_Free(rOut);
          break;
        }

        if (1 && fixPoint < -1 && !(forceFixpointCheck || tryFixpointCheck))
          fixPoint = 0;         // disable further checks;
        if (1 && fixPoint < 0) {
          Ddi_Bdd_t *myCone = Ddi_BddDup(newCone);

          if (chkFpWithInductionCone && useInductionCone
            && inductionCone != NULL) {
            Ddi_Free(myCone);
            myCone = Ddi_BddDup(inductionCone);
          }
          if (bckReached != NULL) {
            Ddi_BddOrAcc(myCone, bckReached);
          }
          if (newConeAux != NULL
            && Ddi_BddSize(newConeAux) < 10 * Ddi_BddSize(newCone)) {
            Ddi_DataCopy(myCone, newConeAux);
          }
          if (useTrBdd && fixPointBdd != -1) {
            fixPoint = fixPointBdd;
          } else {
            fixPoint = checkFixPoint(travMgr, fsmMgr, oldCone, myCone, care);
            //      if (fixPoint < 0) fixPoint = 0; // disable further checks;
          }
          Ddi_Free(myCone);
        }
        if (1 && fixPoint < 0) {
          /* aborted */
          int myAbort;

#if 0
#if 1
          fixPoint = -1;
#else
          itpBmcBound = checkFixPointByInterpolant(itpMgr,
            travMgr, fsmMgr, newCone, previousCone, init, care,
            NULL, NULL, optLevel, &myAbort, 0, 0, -1, 0, itpMgr->time_limit);
          if (itpBmcBound >= 0) {
            fixPoint = 1;
          } else {
            fixPoint = 0;
          }
#endif
#endif

          if (fixPoint < 0) {
            Ddi_Bdd_t *myCone = Ddi_BddDup(newCone);

            if (chkFpWithInductionCone && useInductionCone
              && inductionCone != NULL) {
              Ddi_Free(myCone);
              myCone = Ddi_BddDup(inductionCone);
            }
            if (bckReached != NULL) {
              Ddi_BddOrAcc(myCone, bckReached);
            }
            if (newConeAux != NULL &&
              Ddi_BddSize(newConeAux) < 10 * Ddi_BddSize(newCone)) {
              Ddi_DataCopy(myCone, newConeAux);
            }
            fixPoint = checkFixPoint2(travMgr, fsmMgr,
              oldCone, myCone, care, maxFP2Iter);
            Ddi_Free(myCone);
            if (fixPoint < 0) {
              fixPoint = 0;     // disable further checks;
              itpBmcBound++;
              if (maxFP2Iter < 10)
                maxFP2Iter++;
            }
          }
          if (0 && fixPoint <= 0) {
            Ddi_AigExistProjectAcc(newCone, psVars, care, 1, 0, 30.0);
            {
              int rrl = Ddi_MgrReadAigRedRemLevel(ddm);

              Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRem_c, inum, rrl + 1);
              DdiAigRedRemovalAcc(newCone, care, -1, 30.0);
              Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRem_c, inum, rrl);
            }
            doExist = 0;
          }
        }
      } while (fixPoint < 0);

    if (sat)
      break;

    if (fixPoint) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "BWD fix point at bound %d.\n", i)
        );
      if (1) {
        Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");

        if (iv != NULL && itpConstrLevel > 1) {
          Ddi_Bdd_t *extraInvar = Ddi_BddMakeLiteralAig(iv, 1);

          Ddi_BddComposeAcc(extraInvar, ps, itpMgr->delta);
          if (Trav_MgrReadAssume(travMgr) == NULL) {
            Trav_MgrSetAssume(travMgr, extraInvar);
          } else {
            Ddi_BddAndAcc(Trav_MgrReadAssume(travMgr), extraInvar);
          }
          Ddi_Free(extraInvar);
        }
        if (lemmasInvar != NULL) {
          if (Trav_MgrReadAssume(travMgr) == NULL) {
            Trav_MgrSetAssume(travMgr, lemmasInvar);
          } else {
            Ddi_BddAndAcc(Trav_MgrReadAssume(travMgr), lemmasInvar);
          }

        }
        if (1) {
          int j;
          Ddi_Bddarray_t *rings = NULL;

          if ((Trav_MgrReadItpReuseRings(travMgr) == 2) && itpMgr->nRings > 0) {
            if (rOut != NULL) {
              Trav_MgrSetReached(travMgr, rOut);
            }
            Trav_MgrSetNewi(travMgr, itpMgr->fromRings);
          } else {
            if (rOut != NULL) {
              Trav_MgrSetReached(travMgr, rOut);
            }
            if ((Trav_MgrReadItpReuseRings(travMgr) == 1)
              && itpMgr->nRings > 0) {
              Trav_MgrSetNewi(travMgr, itpMgr->fromRings);
            }
          }
          if (itpMgr->abstrRefRefinedVars != NULL) {
            Trav_MgrSetAbstrRefRefinedVars(travMgr,
              itpMgr->abstrRefRefinedVars);
          }
#if 1
          rings = Trav_MgrReadNewi(travMgr);
          if (rings != NULL &&
            itpMgr->eqRings != NULL && Ddi_BddarrayNum(itpMgr->eqRings) > 0) {
            int j;

            for (j = 0; j < Ddi_BddarrayNum(itpMgr->eqRings); j++) {
              Ddi_Bdd_t *eq = Ddi_BddarrayRead(itpMgr->eqRings, j);
              Ddi_Bdd_t *ring_j = Ddi_BddarrayRead(rings, j);

              if (eq != NULL) {
                Ddi_BddSetPartConj(ring_j);
                Pdtutil_Assert(Ddi_BddPartNum(ring_j) == 1,
                  "error in ring as part");
                Ddi_BddPartWrite(ring_j, 1, eq);
              }
            }
          }
#endif
        } else {
          char name[100];

          sprintf(name, "itpReachedOut%d.bench", getpid());
          Ddi_AigNetStore(rOut, name, NULL, Pdtutil_Aig2BenchLocalId_c);
        }
      }
      Ddi_Free(rOut);
      break;
    }

    if (bckReached != NULL) {
      Ddi_BddDiffAcc(care, bckReached);
    }

    if (0 && doExist && optLevel > 1) {
      int size;

      DdiAigOptByBddRelation(newCone, 500, 50, NULL, 200.0);
      size = Ddi_BddSize(newCone);
      if (size * 2 > doExistThreshold)
        doExistThreshold = size * 2;
      // Ddi_AigExistProjectAcc(newCone,psVars,NULL,3,0,20.0);
    }
    if (doExist && (optLevel > 1 || optLevel > 0 && i <= 3)) {

      int size;

#if 0
      if (0 && notReached != NULL) {
        Ddi_Varset_t *pivars = Ddi_BddSupp(a);
        Ddi_Varset_t *sm = Ddi_BddSupp(newCone);

        Ddi_VarsetDiffAcc(pivars, sm);
        Ddi_VarsetDiffAcc(pivars, psVars);
        Ddi_AigExistAcc(a, pivars, NULL, 0, 0, -1.0);
        Ddi_Bdd_t *b = Ddi_BddDup(a);

        Ddi_BddXorAcc(b, newCone);
        Ddi_BddAndAcc(b, notReached);
        Pdtutil_Assert(!Ddi_AigSat(b), "WRONG EXIST WITH CARE");
        Ddi_Free(sm);
        Ddi_Free(pivars);
        sm = Ddi_BddSupp(notReached);
        Ddi_VarsetDiffAcc(sm, psVars);
        Pdtutil_Assert(Ddi_VarsetIsVoid(sm), "wrong subsetting");
      }
      Ddi_Free(a);
#endif

#if 1
      if (0 && !useTrBdd && !bddSuccess) {
        DdiAigRedRemovalAcc(newCone, notReached, -1, 30.0);
      }
      newReached = Ddi_BddDup(newCone);
#if 0
      if (newReached != NULL && rInterpolant != NULL) {
        Ddi_BddAndAcc(newReached, rInterpolant);
        Ddi_Free(rInterpolant);
      }
      if (rOut != NULL) {
        rInterpolant = Ddi_BddDup(rOut);
      }
#endif
      if (notReached == NULL) {
        notReached = Ddi_BddMakeConstAig(ddm, 1);
      }

      if (!useTrBdd && (!tryBdd || maxFailBddBwd < 0)
        && (optLevel > 1 || optLevel > 0 && i < 3)) {
        Ddi_Varset_t *sm = Ddi_BddSupp(newReached);
        Ddi_Bdd_t *check;
        Ddi_Bdd_t *cexAig;

        Ddi_VarsetDiffAcc(sm, psVars);
        if (0 && Ddi_VarsetNum(sm) > 0) {
          Ddi_AigExistAcc(newReached, sm, notReached, 2, 0, 30.0);
          Ddi_AigExistSubsetAcc(newReached, sm, notReached, NULL, -2, 40.0);
        }
        check = Ddi_BddAnd(newReached, notReached);
        cexAig = Ddi_AigSatWithCex(check);
        Ddi_Free(check);
        if (0 && Ddi_VarsetNum(sm) > 0) {
          Ddi_AigExistSubsetAcc(newReached, sm, notReached, cexAig, 1, 30.0);
        } else {
          DdiAigRedRemovalAcc(newReached, NULL, -1, 30.0);
        }
        Ddi_Free(cexAig);

        Ddi_Free(sm);

        check = Ddi_BddDiff(newCone, newReached);
        if (0 && constrainOpt && !Ddi_AigSat(check)) {
          Ddi_DataCopy(newCone, newReached);
        }
        Ddi_Free(check);
      }

      {
        Ddi_Varset_t *sm = Ddi_BddSupp(newReached);

        Ddi_VarsetDiffAcc(sm, psVars);
        if (Ddi_VarsetIsVoid(sm) && Ddi_BddSize(newReached) > 0) {
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "AIG SUBSET - refine CARE %d+%d=",
              Ddi_BddSize(care), Ddi_BddSize(newReached))
            );
          Ddi_BddDiffAcc(care, newReached);
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "%d.\n", Ddi_BddSize(care))
            );
        }
        Ddi_Free(sm);
      }

      Ddi_Free(newReached);
#endif
      //      Ddi_AigExistProjectAcc(newCone,psVars,care,0,0);

      size = Ddi_BddSize(newCone);
      if (size * 2 > doExistThreshold)
        doExistThreshold = size * 2;
    }

    if (i == 0 && optLevel > 1) {
      Ddi_BddAndAcc(care, myInvarspec);
    }

    newReached = Ddi_BddNot(care);
    Ddi_BddDiffAcc(newReached, reached);

    //    if (!stallEnable) {
    //      DdiAigRedRemovalAcc (newConeRed,care,-1,60.0);
    //      Ddi_BddOrAcc(newCone,newReached);
    //      Ddi_BddOrAcc(newCone,reached);
    //
    //    }
    if (0 && (optLevel > 1 || stallEnable)) {
      Ddi_BddDiffAcc(newCone, reached);
    }
    Ddi_BddOrAcc(reached, newReached);
    Ddi_Free(newReached);
    Ddi_Free(notReached);       /*@@@@ */
    notReached = Ddi_BddNot(reached);

    //    Pdtutil_Assert(Ddi_BddIncluded(care,notReached),"wrong care");

    //      DdiAigRedRemovalAcc (newConeRed,care,-1);

    //    Ddi_BddDiffAcc(care,newCone);

    if (useInnerCone && savedConeIter > 0 &&
      i == (savedConeIter + savedConeWindow)) {
      if (saveCone != NULL) {
        Ddi_Free(previousCone);
        previousCone = Ddi_BddDup(saveCone);
        if (saveConeAuxLits != NULL) {
          Ddi_Free(previousConeAuxLits);
          previousConeAuxLits = Ddi_BddarrayDup(saveConeAuxLits);
        }
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "Using auxiliary cone at depth %d.\n",
            nextSaveCone / 2)
          );
      }
    }
    if (useInnerCone && i == nextSaveCone) {
      if (1 && newCone != NULL) {
        int j;
        Ddi_Bdd_t *auxVarsConstrain = Ddi_BddMakeConstAig(ddm, 1);
        Ddi_Varset_t *checkSupp = Ddi_BddSupp(newCone);

        savedConeIter = i;
        savedConeWindow = i / 4;
        if (savedConeWindow < 2)
          savedConeWindow = 2;
        Ddi_Free(saveCone);
        saveCone = Ddi_BddDup(fullCone);
        if (useExtraCheck) {
          Ddi_Free(saveConeAuxLits);
          saveConeAuxLits = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(ps));
          for (j = 0; j < Ddi_VararrayNum(ps); j++) {
            Ddi_Bdd_t *lit, *constr;
            char name[1000];
            Ddi_Var_t *v = Ddi_VararrayRead(ps, j);
            Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);

            sprintf(name, "previousConeAux_%d_%s", i, Ddi_VarName(v));
            Ddi_VarAttachName(newv, name);
            lit = Ddi_BddMakeLiteralAig(newv, 1);
            Ddi_BddarrayWrite(saveConeAuxLits, j, lit);
            if (Ddi_VarInVarset(checkSupp, v)) {
              constr = Ddi_BddMakeLiteralAig(v, 1);
              Ddi_BddXnorAcc(constr, lit);
              Ddi_BddAndAcc(auxVarsConstrain, constr);
              Ddi_Free(constr);
            }
            Ddi_Free(lit);
          }
          Ddi_BddAndAcc(newCone, auxVarsConstrain);
        }
        Ddi_Free(checkSupp);
        Ddi_Free(auxVarsConstrain);
      }
      if (nextSaveCone < 4)
        nextSaveCone *= 2;
      else
        nextSaveCone *= 2;
    }
    Ddi_Free(oldCone);
    oldCone = Ddi_BddDup(fullCone);

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "\n")
      );
    itpMgr->useAigVars = 1 && !( /*tryBdd || */ useTrBdd);

    if (!disConeUnwind) {
      int j, nCoi = 0;

      //Ddi_Bddarray_t *delta_i;
      Ddi_Bdd_t *diff_i;        //, *invarspec_i;

      nCoi =
        timeFrameFindOrAdd(itpMgr->timeFrames, pi, ps, ns, psVars, i,
        enableLoopFree, itpMgr->useAigVars);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c, coiNum = nCoi;   //printf("{COI:%d} ", nCoi)
        );

      //      Ddi_BddAndAcc(unroll,tr_i);

      if (newConeAux2 != NULL &&
        (optLevel < 2 || Ddi_BddSize(newConeAux2) < Ddi_BddSize(newCone))) {
        Ddi_Free(newCone);
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "ncaux2.\n")
          );
        newCone = newConeAux2;
        newConeAux2 = NULL;
      }
      Ddi_Free(newConeAux2);

      if (useInvarFull && itpMgr->invarConstr != NULL) {
        Ddi_BddAndAcc(newCone, itpMgr->invarConstr);
      }
      if (deferredUnroll == NULL) {
        if (itpMgr->deltaAbstr != NULL) {
          deferredUnroll = Ddi_BddarrayDup(itpMgr->deltaAbstr);
        } else {
          deferredUnroll = Ddi_BddarrayDup(delta);
        }
      }
      if (deferConeBuild) {
        Ddi_Bddarray_t *newDefU = Ddi_BddarrayDup(delta);
        int k = deferConeBuild;

        Ddi_BddarrayComposeAcc(newDefU,
          itpMgr->timeFrames->PiVars[0], itpMgr->timeFrames->PiLits[k]);
        Ddi_BddarrayComposeAcc(newDefU, ps, deferredUnroll);
        Ddi_Free(deferredUnroll);
        deferredUnroll = newDefU;
      } else {
        if (nDeferred > 0) {
          timeFrameShiftKAcc(newCone, itpMgr->timeFrames->PiVars,
            itpMgr->timeFrames->PiLits, i + 2, nDeferred + 1);
        } else if (0) {
          timeFrameShiftKAcc(newCone, itpMgr->timeFrames->PiVars,
            itpMgr->timeFrames->PiLits, i + 2, i + 1);
        } else {
          timeFrameShiftAcc(newCone, itpMgr->timeFrames->PiVars,
            itpMgr->timeFrames->PiLits, i + 2);
        }
      }

      if (0 && newConeConstraint != NULL) {
        if (0 || newConeConstraint2 == NULL) {
          Ddi_Free(newConeConstraint2);
          newConeConstraint2 = Ddi_BddDup(newConeConstraint);
        }
        timeFrameShiftAcc(newConeConstraint2,
          itpMgr->timeFrames->PiVars, itpMgr->timeFrames->PiLits, i + 2);
      }
      if (newConeAux != NULL) {
        if (useInvarFull && itpMgr->invarConstr != NULL) {
          Ddi_BddAndAcc(newConeAux, itpMgr->invarConstr);
        }
        timeFrameShiftAcc(newConeAux, itpMgr->timeFrames->PiVars,
          itpMgr->timeFrames->PiLits, i + 2);
      }
      //      timeFrameShiftAcc(newConeRed,timeFramePiVars,timeFramePiLits,i+2);
      //      if (i>0)
      //        Ddi_BddAndAcc(newCone,myInvarspec);

      if (bckReached != NULL) {
        Ddi_BddOrAcc(newCone, bckReached);
        Ddi_Free(bckReached);
      }
#if 0
      if (constraintGuard != NULL) {
        Ddi_BddCofactorAcc(newCone, constraintGuard, 1);
      }
      if (constraintGuard2 != NULL) {
        Ddi_BddCofactorAcc(newCone, constraintGuard2, 1);
      }
#endif

      if (!deferConeBuild) {
        //        int mark = Ddi_BddReadMark(newCone);

        Ddi_BddComposeAcc(newCone, ps, deferredUnroll);

        //        Ddi_BddWriteMark (newCone, mark+1);
        if (newConeConstraint2 != NULL) {
          Ddi_BddComposeAcc(newConeConstraint2, ps, deferredUnroll);
        }
        Ddi_Free(deferredUnroll);
      }

      if (monotoneConeOpt && Ddi_BddSize(newCone) < 30000) {
        Ddi_Bdd_t *myCone = Ddi_BddDup(newCone);
        int mark = Ddi_BddReadMark(newCone);

        Ddi_AigExistProjectAcc(newCone, psVars, NULL, 3, 0, 60.0);
        if (0) {
          if (Ddi_BddSize(newCone) < Ddi_BddSize(myCone)) {
            Ddi_BddNotAcc(newCone);
            Ddi_AigOptByMonotoneCoreAcc(newCone, myCone, NULL, 0, -1.0);
            Ddi_BddNotAcc(newCone);
          } else {
            Ddi_BddNotAcc(myCone);
            Ddi_AigOptByMonotoneCoreAcc(myCone, newCone, NULL, 0, -1.0);
            Ddi_BddNotAcc(myCone);
            if (Ddi_BddSize(myCone) < Ddi_BddSize(newCone)) {
              Ddi_DataCopy(newCone, myCone);
            }
          }
        }
        Ddi_Free(myCone);
        Ddi_BddWriteMark(newCone, mark);
      }

      if (constrainConeOpt) {
        Ddi_Var_t *varProp = NULL;
        Ddi_Bdd_t *litProp = NULL;
        Ddi_Varset_t *vars = Ddi_VarsetMakeFromArray(ps);
        Ddi_Varset_t *pivars = Ddi_VarsetMakeFromArray(pi);

        Pdtutil_Assert(iProp >= 0, "iProp unassigned");
        varProp = Ddi_VararrayRead(ps, iProp);
        litProp = Ddi_BddMakeLiteralAig(varProp, 1);

        Ddi_VarsetUnionAcc(vars, pivars);
        //         Ddi_AigConstrainOptAcc(newCone,litProp,vars,NULL,NULL,1);
        Ddi_AigConstrainOptAcc(newCone, litProp, vars, pivars, NULL, 1);
        //      Ddi_AigConstrainOptAcc(newCone,litProp,NULL,NULL,NULL,3);
        Ddi_BddNotAcc(litProp);
        Ddi_BddOrAcc(newCone, litProp);

        Ddi_Free(vars);
        Ddi_Free(pivars);
        Ddi_Free(litProp);
      }
#if 0
      if (1 && constraintGuard != NULL) {
        static int noFilter = 0;
        int j;

        if (deltaConstraint == NULL) {
          for (j = 0; j < Ddi_VararrayNum(ps); j++) {
            if (Ddi_VararrayRead(ps, j) == constraintGuard) {
              break;
            }
          }
          Pdtutil_Assert(j < Ddi_VararrayNum(ps),
            "constraint guard not found");
          /* included in AND with invarspec */
          deltaConstraint = Ddi_BddDup(Ddi_BddarrayRead(delta, j));
        }
#if 1
        {
          Ddi_Bdd_t *constrDelta = deltaConstraint;
          Ddi_Bdd_t *cc = Ddi_BddCofactor(constrDelta, constraintGuard, 1);
          Ddi_Varset_t *ccSupp = Ddi_BddSupp(cc);
          Ddi_Bdd_t *fullConstr = Ddi_BddMakeConstAig(ddm, 1);

          if (Ddi_VarsetNum(ccSupp) == 1) {
            Ddi_Var_t *vC = Ddi_VarsetTop(ccSupp);
            int j;

            for (j = 0; j < Ddi_VararrayNum(ps); j++) {
              if (Ddi_VararrayRead(ps, j) == vC) {
                break;
              }
            }
            Pdtutil_Assert(j < Ddi_VararrayNum(ps),
              "constraint guard2 not found");
            constrDelta = Ddi_BddarrayRead(delta, j);
            constraintGuard2 = vC;
            Ddi_BddAndAcc(newCone, cc);
          }
          {
            Ddi_Bdd_t *constrLit = Ddi_BddMakeLiteralAig(constraintGuard, 1);

            Ddi_BddAndAcc(newCone, constrLit);
            Ddi_Free(constrLit);
          }
          if (0) {
            Ddi_BddAndAcc(newCone, constrDelta);
          } else {
            int again = 0;
            Ddi_Bdd_t *constrPart = Ddi_AigPartitionTop(constrDelta, 0);
            int np, np0 = Ddi_BddPartNum(constrPart);

            do {

              Ddi_Varset_t *pSupp = Ddi_BddSupp(newCone);
              int k;

              again = 0;
              for (k = Ddi_BddPartNum(constrPart) - 1; k >= 0; k--) {
                Ddi_Bdd_t *c_k = Ddi_BddPartRead(constrPart, k);
                Ddi_Varset_t *cSupp = Ddi_BddSupp(c_k);
                int forceCone = Ddi_BddSize(c_k) == 1;

                if (Ddi_VarsetIsArray(pSupp)) {
                  Ddi_VarsetSetArray(cSupp);
                }
                Ddi_VarsetIntersectAcc(cSupp, pSupp);
                if (noFilter || !Ddi_VarsetIsVoid(cSupp)) {
                  Ddi_BddAndAcc(fullConstr, c_k);
                  Ddi_BddPartRemove(constrPart, k);
                  again = 1;
                } else if (forceCone) {
                  Ddi_Bdd_t *newC = Ddi_BddCompose(c_k, ps, delta);

                  Ddi_BddAndAcc(deltaConstraint, newC);
                  Ddi_Free(newC);
                }
                Ddi_Free(cSupp);
              }
              Ddi_Free(pSupp);
            } while (1 && again);

            np = Ddi_BddPartNum(constrPart);
            if (np > 0) {
              Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                Pdtutil_VerbLevelNone_c,
                fprintf(tMgrO(travMgr),
                  "%d/%d constraints are filtered out.\n", np, np0)
                );
            }
            Ddi_Free(newConeConstraint);
            newConeConstraint = Ddi_BddMakeAig(constrPart);
            Ddi_Free(constrPart);
          }
          if (0) {
            Ddi_Varset_t *vars = Ddi_VarsetMakeFromArray(pi);
            Ddi_Varset_t *psvars = Ddi_VarsetMakeFromArray(ps);

            Ddi_VarsetUnionAcc(vars, psvars);
            Ddi_AigConstrainOptAcc(newCone, fullConstr, vars, NULL, NULL, 5);
            Ddi_Free(vars);
            Ddi_Free(psvars);
          }
          Ddi_BddAndAcc(newCone, fullConstr);
          if (itpBmcBound <= 1) {
            ddiAbcOptAcc(newCone, -1.0);
          }
          Ddi_Free(fullConstr);
          Ddi_Free(ccSupp);
          Ddi_Free(cc);
        }
#else
        Ddi_Bdd_t *constrLit = Ddi_BddMakeLiteralAig(constraintGuard, 1);

        Ddi_BddAndAcc(newCone, constrLit);
        Ddi_Free(constrLit);
#endif
      }
#endif

      if (newConeAux != NULL) {
        Ddi_BddComposeAcc(newConeAux, ps, delta);
        if (1 && Ddi_BddSize(newConeAux) > Ddi_BddSize(newCone)) {
          Ddi_DataCopy(newConeAux, newCone);
        }
      }


      if (itpMgr->inductiveRplus != NULL) {
        Ddi_Bdd_t *myConstr =
          Ddi_BddCompose(itpMgr->inductiveRplus, ns, psLit);
        Ddi_BddAndAcc(care, myConstr);
        Ddi_BddAndAcc(itpCareRef, myConstr);
        Ddi_Free(myConstr);
      }

      if (0) {
        int nv, nv1, j, size0 = Ddi_BddSize(newCone);
        Ddi_Vararray_t *vA;
        Ddi_Varset_t *psvars = Ddi_VarsetMakeFromArray(ps);
        Ddi_Varset_t *s = Ddi_BddSupp(newCone);

        Ddi_VarsetSetArray(s);
        Ddi_VarsetSetArray(psvars);
        Ddi_VarsetIntersectAcc(s, psvars);
        nv = nv1 = Ddi_VarsetNum(s);
        if (itpMgr->coreVars != NULL) {
          Ddi_VarsetDiffAcc(s, itpMgr->coreVars);
        }
        vA = Ddi_VararrayMakeFromVarset(s, 1);
        for (j = 0; j < Ddi_VararrayNum(vA); j++) {
          Ddi_Var_t *v = Ddi_VararrayRead(vA, j);
          Ddi_Bdd_t *cof0 = Ddi_BddCofactor(newCone, v, 0);
          Ddi_Bdd_t *cof1 = Ddi_BddCofactor(newCone, v, 1);
          Ddi_Bdd_t *dif = Ddi_BddXor(cof0, cof1);

          //      if (Ddi_BddEqual(cof0,cof1)) {
          if (Ddi_AigSatWithAbort(dif, 0.2) == 0) {
            Ddi_Free(newCone);
            newCone = Ddi_BddDup(cof0);
            nv1--;
            Ddi_VarsetRemoveAcc(s, v);
          }
          Ddi_Free(dif);
          Ddi_Free(cof0);
          Ddi_Free(cof1);
        }
        if (itpMgr->coreVars == NULL) {
          itpMgr->coreVars = Ddi_VarsetDup(s);
        } else {
          Ddi_VarsetUnionAcc(itpMgr->coreVars, s);
        }

        Ddi_Free(s);
        Ddi_Free(psvars);
        Ddi_Free(vA);
        if (nv > nv1) {
          printf("univ quant: simplified cone supp: %d -> %d\n", nv, nv1);
          printf("univ quant: simplified cone size: %d -> %d\n", size0,
            Ddi_BddSize(newCone));
        }
      }

      if (itpMgr->inductiveRplus != NULL) {
        Ddi_Bdd_t *myConstr =
          Ddi_BddCompose(itpMgr->inductiveRplus, ns, psLit);

        if (1) {
          int size0 = Ddi_BddSize(newCone);
          Ddi_Bdd_t *myCare = Ddi_BddDup(myConstr);
          Ddi_Bdd_t *eq =
            DdiAigEquivVarsAcc(myCare, NULL, NULL, itpMgr->psvars, newCone,
            NULL, NULL);

          Ddi_Free(myCare);
          if (eq != NULL) {
            printf("EQ simplifying cone: %d -> %d\n", size0,
              Ddi_BddSize(newCone));
          }
          Ddi_Free(eq);
        }

        Ddi_BddAndAcc(newCone, myConstr);
        Ddi_Free(myConstr);
      }

      if (itpMgr->specSpace != NULL && !stallEnable) {

        if (0) {
          Ddi_BddAndAcc(newCone, itpMgr->specSpace);
        } else if (!useSingleCone || stallEnable) {
          Ddi_AigConstrainCubeAcc(newCone, itpMgr->specSpace);
          if (newConeAux != NULL) {
            Ddi_AigConstrainCubeAcc(newConeAux, itpMgr->specSpace);
          }
        } else if (1) {
#if 0
          Ddi_Varset_t *vars = Ddi_VarsetMakeFromArray(ps);
          Ddi_Varset_t *pivars = Ddi_VarsetMakeFromArray(pi);

          Ddi_VarsetUnionAcc(vars, pivars);
          Ddi_AigConstrainOptAcc(newCone, itpMgr->specSpace, vars, NULL, NULL,
            5);
          Ddi_Free(vars);
          Ddi_Free(pivars);
#else
          if (0) {
            Ddi_BddAndAcc(newCone, itpMgr->specSpace);
          } else {
            Ddi_Var_t *propVar = Ddi_VararrayRead(ps, iProp);

            Ddi_BddCofactorAcc(newCone, propVar, 1);
          }
#endif

          if (enAigStructOpt &&
            (Ddi_AigFilterStructMonotone(newCone, psVars) > 0)) {
            //Ddi_AigFilterStructMonotone(newCone,psVars);
          }
          if (enAigOptPdt) {
            if (Ddi_BddSize(newCone) > 150000) {
              enAigOptPdt = 0;
            } else {
              int size0 = Ddi_BddSize(newCone);
              long myStartTime = util_cpu_time();

              Ddi_AigOptByFoCntTop(newCone, NULL, -1);
              if (optLevel >= 1 && abcOpt >= 3) {
                ddiAbcOptAcc(newCone, -1.0);
              }
              if (enAigOptPdt > 1) {
                Ddi_Bdd_t *coneEq = Ddi_BddDup(newCone);
                Ddi_Bdd_t *eq = DdiAigFindEquiv(coneEq, NULL, 20, 0, 30.0);

                if (eq != NULL) {
                  Ddi_BddSetAig(eq);
                  //                  Ddi_BddAndAcc(coneEq,eq);
                  if ((Ddi_BddSize(coneEq) < Ddi_BddSize(newCone))) {
                    Ddi_DataCopy(newCone, coneEq);
                  }
                }
                Ddi_Free(eq);
                Ddi_Free(coneEq);
              }
              if ((((float)(util_cpu_time() - myStartTime)) / 1000) >
                travMgr->settings.aig.lazyTimeLimit / 10) {
                enAigOptPdt = 0;
              }
              if (size0 > 40000
                && ((size0 - Ddi_BddSize(newCone)) < 0.005 * size0)) {
                enAigOptPdt = 0;
              }
            }
          }

          if (itpMgr->boundkOptPis != NULL) {
            Ddi_Var_t *newv, *newv2;
            char name[1000];
            char name2[1000];
            Ddi_Bdd_t *boundkCone1, *boundkCone0, *boundkConeTot,
              *boundkLit, *boundkLit2;

            sprintf(name, "PDTRAV_VAR_BOUNDK_OPT_%d",
              itpMgr->boundkOptNumVars);
            sprintf(name2, "PDTRAV_VAR2_BOUNDK_OPT_%d",
              itpMgr->boundkOptNumVars);
            itpMgr->boundkOptNumVars++;
            if (!itpMgr->useAigVars) {
              newv = Ddi_VarNew(ddm);
              newv2 = Ddi_VarNew(ddm);
              Ddi_VarAttachName(newv, name);
              Ddi_VarAttachName(newv2, name2);
            } else {
              newv = Ddi_VarNewBaig(ddm, name);
              newv2 = Ddi_VarNewBaig(ddm, name2);
            }
            Ddi_VararrayInsertLast(itpMgr->boundkOptPis, newv);
            Ddi_VararrayInsertLast(itpMgr->boundkOptPis, newv2);

            boundkLit = Ddi_BddMakeLiteralAig(newv, 1);
            boundkLit2 = Ddi_BddMakeLiteralAig(newv2, 1);

            boundkCone0 = Ddi_BddAnd(newCone, boundkLit2);
            boundkCone1 = Ddi_BddOr(boundkCone0, itpMgr->target);

            boundkConeTot = Ddi_BddIte(boundkLit, boundkCone1, boundkCone0);
            Ddi_DataCopy(newCone, boundkConeTot);
            Ddi_Free(boundkConeTot);
            Ddi_Free(boundkCone1);
            Ddi_Free(boundkCone0);
            Ddi_Free(boundkLit);
            Ddi_Free(boundkLit2);
          } else {
            if (!useBoundkCone) {
              Ddi_BddOrAcc(newCone, itpMgr->target);
            }
          }

        }

        fixPointBdd = 0;
        if (useTrBdd && trBdd != NULL && !itpExact) {
          Ddi_Bdd_t *toBck, *careNS = NULL;
          Ddi_Varset_t *toSupp;

          Pdtutil_Assert(coneBdd != NULL, "Bdd cone is NULL");

          Ddi_MgrSetExistClustThresh(ddm, imgAndExistTh);
          if (0 && care != NULL) {
            careNS = Ddi_BddMakeMono(care);
            Ddi_BddSwapVarsAcc(careNS, ps, ns);
          }

          toBck = Tr_ImgWithConstrain(trBdd, coneBdd, careNS);

          if (care != NULL) {
            Ddi_Free(careNS);
          }
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "TOBDD = %d - ", Ddi_BddSize(toBck))
            );
          Ddi_MgrSetExistClustThresh(ddm, -1);
          toSupp = Ddi_BddSupp(toBck);
          Ddi_VarsetDiffAcc(toSupp, psVars);
          if (Ddi_VarsetIsVoid(toSupp) &&
            Ddi_BddSize(toBck) < 100000 && Ddi_BddSize(care) < 500000) {
            Ddi_Free(coneBdd);
            coneBdd = toBck;
            Ddi_Free(newCone);
            if (careBdd != NULL) {
              {
                Ddi_BddSetMono(careBdd);
                Ddi_BddNotAcc(careBdd);
                fixPointBdd = Ddi_BddIncluded(coneBdd, careBdd);
                Ddi_BddNotAcc(careBdd);
              }
              Ddi_BddRestrictAcc(coneBdd, careBdd);
              Ddi_BddSetPartConj(careBdd);
              Ddi_BddNotAcc(coneBdd);
              Ddi_BddPartInsertLast(careBdd, coneBdd);
              Ddi_BddNotAcc(coneBdd);
              Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                Pdtutil_VerbLevelNone_c,
                fprintf(tMgrO(travMgr), "CONEBDD = %d - ",
                  Ddi_BddSize(coneBdd));
                fprintf(tMgrO(travMgr), "CAREBDD = %d - ",
                  Ddi_BddSize(careBdd))
                );
            } else
              fixPointBdd = -1;
            newCone = Ddi_BddMakeAig(coneBdd);
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "ncBdd.\n");
              fprintf(tMgrO(travMgr), "CONEAIG = %d.\n", Ddi_BddSize(newCone))
              );
            if (0) {
              Ddi_Bdd_t *r = Ddi_BddMakeMono(reached);

              Ddi_BddOrAcc(r, coneBdd);
              Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                Pdtutil_VerbLevelNone_c,
                fprintf(tMgrO(travMgr), "#Reached States = %g.\n",
                  Ddi_BddCountMinterm(r, Ddi_VararrayNum(ps)))
                );
              Ddi_Free(r);
            }
          } else {
            useTrBdd = tryBdd = 0;
            Ddi_Free(toBck);
          }
          Ddi_Free(toSupp);

        }

      }

      if (0 && filterNew) {
        Ddi_Varset_t *psvars = Ddi_VarsetMakeFromArray(ps);

        Ddi_AigExistProjectAcc(newCone, psVars, 0, 3, 0, -1.0);
        Ddi_Free(psvars);
      }
      if (filterNew) {
        int j, removed = 0;
        Ddi_Bdd_t *partCone = Ddi_AigPartitionTop(newCone, 1);

        if (Ddi_BddPartNum(partCone) > 1) {
          for (j = Ddi_BddPartNum(partCone) - 1; j >= 0; j--) {
            Ddi_Bdd_t *p_j = Ddi_BddPartRead(partCone, j);

            if (!Ddi_AigSatAnd(p_j, care, NULL)) {
              Ddi_BddPartRemove(partCone, j);
              removed = 1;
            }
          }
          if (removed) {
            Ddi_BddSetAig(partCone);
            Ddi_DataCopy(newCone, partCone);
          }
        } else if (0) {
          Ddi_Bdd_t *pMax, *pMaxPart;
          int jMax = -1, size, np, npMax, sizeMax = 0;

          Ddi_Free(partCone);
          partCone = Ddi_AigPartitionTop(newCone, 0);
          if (Ddi_BddPartNum(partCone) > 1) {
            for (j = 0; j < Ddi_BddPartNum(partCone); j++) {
              Ddi_Bdd_t *p_j = Ddi_BddPartRead(partCone, j);

              size = Ddi_BddSize(p_j);
              if (size <= 10)
                continue;
              pMaxPart = Ddi_AigPartitionTop(p_j, 1);
              if (Ddi_BddPartNum(pMaxPart) > 2)
                if (jMax < 0 || np > npMax) {
                  jMax = j;
                  sizeMax = size;
                  npMax = np;
                }
            }
            if (jMax >= 0) {
              pMax = Ddi_BddPartExtract(partCone, jMax);
              pMaxPart = Ddi_AigPartitionTop(pMax, 1);
              Ddi_BddSetAig(partCone);
#if 0
              for (j = 0; j < Ddi_BddPartNum(pMaxPart); j++) {
                Ddi_Bdd_t *p_j = Ddi_BddPartRead(pMaxPart, j);

                Ddi_BddAndAcc(p_j, partCone);
              }
              Ddi_BddSetAig(pMaxPart);
              Ddi_DataCopy(newCone, pMaxPart);
#else
              Ddi_BddAndAcc(partCone, Ddi_BddPartRead(pMaxPart, 0));
              Ddi_BddSetAig(partCone);
              Ddi_DataCopy(newCone, partCone);
#endif
              Ddi_Free(pMaxPart);
              Ddi_Free(pMax);
            }
          }
        }
        Ddi_Free(partCone);
      }
      //      Ddi_BddComposeAcc(newConeRed,ps,delta);
      //      Ddi_BddAndAcc(newConeRed,myInvarspec);

      //      DdiAigRedRemovalAcc (newCone,care,-1,30.0);

      size1 = Ddi_BddSize(newCone);
      sizeIncrease =
        size0 == 0 ? 1.5 : size0 < 0 ? 1.0 : ((float)size1) / size0;
      size0 = size1;
      // Overapprox !
      //      if (Ddi_BddSize(newCone) > 100) {
      //        Ddi_AigExistAcc(newCone,psVars,care,1,2);
      //      }

      //      Ddi_AigExistProjectAcc(newCone,psVars,care,1,0);
      if (0) {
        Ddi_Varset_t *supp = Ddi_BddSupp(newCone);

        Ddi_VarsetDiffAcc(supp, psVars);
        DdiAigExistOverAcc(newCone, supp, care);
        Ddi_Free(supp);
      }
      //      DdiAigTernaryReductionAcc (newCone,NULL,psVars,care);

      if (0 && (simplifyCone || sizeIncrease > 1.5) && !bddSuccess) {
        DdiAigRedRemovalAcc(newCone, care, -1, lazyTimeLimit);
      }
      if (optLevel >= 1 && abcOpt > 3) {
        ddiAbcOptAcc(newCone, -1.0);
      }
      //      Ddi_AigExistProjectAcc(newConeRed,psVars,NULL,1,0);

      //      Ddi_Free(tr_i);

      if (useInductionCone) {
        if (inductionConeBase != NULL) {
          Ddi_Free(inductionCone);
          inductionCone = inductionConeBase;
        }
        timeFrameShiftAcc(inductionCone,
          itpMgr->timeFrames->PiVars, itpMgr->timeFrames->PiLits, i + 2);
        Ddi_BddComposeAcc(inductionCone, ps, delta);
        if (1 && itpMgr->specSpace != NULL) {
          Ddi_BddAndAcc(inductionCone, itpMgr->specSpace);
        }
        //Ddi_BddAndAcc(inductionCone,care);
        inductionConeBase = Ddi_BddDup(inductionCone);
        Ddi_BddAndAcc(inductionCone, care); /* @@@ */
        //      Ddi_BddDiffAcc(inductionCone,fullCone);
        if (Ddi_BddSize(inductionCone) > 500000) {
          Ddi_Free(inductionCone);
          Ddi_Free(inductionConeBase);
          useInductionCone = 0;
        }
      }

      if (enableLoopFree) {
        diff_i = Ddi_BddMakeConstAig(ddm, 1);
        for (j = 0; j <= i; j++) {
          Ddi_Bdd_t *diff_j = Ddi_BddMakeConstAig(ddm, 0);

          for (k = 0; k < Ddi_VararrayNum(ns); k++) {
            Ddi_Bdd_t *diff_k =
              Ddi_BddXor(Ddi_BddarrayRead(itpMgr->timeFrames->Lits[i + 1], k),
              Ddi_BddarrayRead(itpMgr->timeFrames->Lits[j], k));

            Ddi_BddOrAcc(diff_j, diff_k);
            Ddi_Free(diff_k);
          }
          Ddi_BddAndAcc(diff_i, diff_j);
          Ddi_Free(diff_j);
        }
        Ddi_BddAndAcc(loopFree, diff_i);
        Ddi_Free(diff_i);
      }
    }

    Ddi_Free(rOut);

  }

  Ddi_Free(deferredUnroll);
  Ddi_Free(newConeAux2);
  Ddi_Free(saveCone);
  Ddi_Free(previousCone);
  Ddi_Free(oldCone);
  Ddi_Free(newCone);
  Ddi_Free(inductionCone);
  Ddi_Free(inductionConeBase);
  Ddi_Free(fullCone);
  Ddi_Free(newConeRed);
  Ddi_Free(fullConeAux);
  Ddi_Free(fullConeRings);
  Ddi_Free(newConeAux);
  Ddi_Free(notReached);
  Ddi_Free(bckReached);

  if (!sat) {
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Lazy Pass at Depth %d.\n", i)
      );
  }
  //Trav_MgrSetAssertFlag (travMgr, !res);
  Trav_MgrSetAssertFlag(travMgr, sat);

  Trav_ItpMgrQuit(itpMgr);

  Tr_TrFree(trBdd);
  Tr_MgrQuit(trMgr);

  Ddi_Free(coneBdd);
  Ddi_Free(careBdd);
  Ddi_Free(bckReached);
  Ddi_Free(newConeConstraint);
  Ddi_Free(newConeConstraint2);
  Ddi_Free(deltaConstraint);

  Ddi_Free(rInterpolant);
  Ddi_Free(previousConeAuxLits);
  Ddi_Free(saveConeAuxLits);
  Ddi_Free(delta);
  Ddi_Free(reached);
  Ddi_Free(piLit);
  Ddi_Free(psLit);
  Ddi_Free(nsLit);
  Ddi_Free(tr);

  Ddi_Free(lemmasInvar);
  Ddi_Free(care);
  Ddi_Free(itpCareRef);

  Ddi_Free(psVars);
  Ddi_Free(myInvarspec);
  Ddi_Free(loopFree);
  Ddi_Free(unroll);
  Ddi_Free(partWindows);

  //Trav_MgrSetAssertFlag(travMgr, !res);
  return (res);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatCheckProof(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Fsm_Mgr_t * fsmMgrRef,
  char *wFsm
)
{
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int fp=0;
  Fsm_Fsm_t *fsmFsm = Fsm_FsmMakeFromFsmMgr(fsmMgr);
  Fsm_FsmUnfoldProperty(fsmFsm, 1);
  Fsm_FsmUnfoldConstraint(fsmFsm);
  Fsm_Fsm_t *fsmFsmRef = Fsm_FsmMakeFromFsmMgr(fsmMgrRef);
  Fsm_FsmUnfoldProperty(fsmFsmRef, 1);
  Fsm_FsmUnfoldConstraint(fsmFsmRef);
  
  Ddi_Bddarray_t *delta = Fsm_FsmReadDelta(fsmFsm); 
  Ddi_Bddarray_t *deltaRef = Fsm_FsmReadDelta(fsmFsmRef); 
  Ddi_Bdd_t *initRef = Fsm_FsmReadInit(fsmFsmRef); 
  Ddi_Bddarray_t *lambda = Fsm_FsmReadLambda(fsmFsm); 
  Ddi_Bddarray_t *lambdaRef = Fsm_FsmReadLambda(fsmFsmRef); 
  Ddi_Bdd_t *constrRef = Fsm_FsmReadConstraint(fsmFsmRef); 
  Ddi_Bdd_t *target = Ddi_BddNot(Ddi_BddarrayRead(lambda,0));
  Ddi_Bdd_t *targetRef = Ddi_BddNot(Ddi_BddarrayRead(lambdaRef,0));

  // check invariant (fix-point)
  
  Ddi_Vararray_t *psRef = Fsm_FsmReadPS(fsmFsmRef);
  Ddi_Vararray_t *piRef = Fsm_FsmReadPI(fsmFsmRef);
  Ddi_Vararray_t *ps = Fsm_FsmReadPS(fsmFsm);
  Ddi_Vararray_t *ns = Fsm_FsmReadPS(fsmFsm);


  Ddi_Bdd_t *r = Trav_MgrReadReached(travMgr);
  Ddi_Vararray_t *auxV = Fsm_MgrReadVarAuxVar(fsmMgr);
  Ddi_Bddarray_t *auxF = Fsm_MgrReadAuxVarBDD(fsmMgr);
  if (r==NULL) {
    Ddi_Free(target);
    Ddi_Free(targetRef);
    return 0;
  }
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("checking reached\n");
  }
  // Ddi_BddComposeAcc(target,ps,delta);
  // Ddi_BddComposeAcc(targetRef,psRef,deltaRef);
  Ddi_Bdd_t *rUnfolded = Ddi_BddDup(r);
  Ddi_Var_t *pVar = Fsm_MgrReadPdtSpecVar(fsmMgr);
  Ddi_Var_t *cVar = Fsm_MgrReadPdtConstrVar(fsmMgr);

  if (pVar!=NULL) {
    Ddi_BddCofactorAcc(rUnfolded,pVar,1);
    Ddi_BddCofactorAcc(target,pVar,1);
    Ddi_BddCofactorAcc(targetRef,pVar,1);
  }
  if (cVar!=NULL) {
    Ddi_BddCofactorAcc(rUnfolded,cVar,1);
    Ddi_BddCofactorAcc(target,cVar,1);
    Ddi_BddCofactorAcc(targetRef,cVar,1);
  }

  Ddi_BddComposeAcc(rUnfolded,auxV,auxF);
  Ddi_Bdd_t *notR = Ddi_BddDup(rUnfolded);

  int doExist = 0;
  if (doExist) {
    Ddi_Varset_t *proj = Ddi_VarsetMakeFromArray(psRef);
    Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
    Pdtutil_VerbLevel_e vNew = Pdtutil_VerbLevelDevMax_c;
    if (constrRef!=NULL) {
      Ddi_BddAndAcc(notR,constrRef);
    }
    Ddi_MgrSetVerbosity(ddm,vNew);
    Ddi_BddExistProjectAcc(notR,proj);
    Ddi_MgrSetVerbosity(ddm,verbosity);
    Ddi_Free(proj);
  }
  else {
    Ddi_Vararray_t *piNext = Ddi_BddSuppVararray(notR);
    Ddi_VararrayDiffAcc(piNext,ps);
    Ddi_Vararray_t *piNextNewVars = Ddi_VararrayMakeNewAigVars(piNext,
                                    "PDT_NEWV_FOR_CHECK", "");
    Ddi_BddSubstVarsAcc(notR,piNext,piNextNewVars);
    Ddi_Free(piNext);
    Ddi_Free(piNextNewVars);
  }
  Ddi_BddNotAcc(notR);


  int findDiff=0;
  if (findDiff) {
    int i,j;
    for (i=j=0; i<Ddi_VararrayNum(psRef); i++)  {
      Ddi_Var_t *v_i = Ddi_VararrayRead(psRef,i);
      if (j>=Ddi_VararrayNum(ps)) {
          printf("var: %s not found, delta size: %d\n",
                 Ddi_VarName(v_i),
                 Ddi_BddSize(Ddi_BddarrayRead(deltaRef,i)));
      }
      else {
        Ddi_Var_t *v_j = Ddi_VararrayRead(ps,j);
        if (v_i!=v_j) {
          printf("var: %s not found, delta size: %d\n",
                 Ddi_VarName(v_i),
                 Ddi_BddSize(Ddi_BddarrayRead(deltaRef,i)));
        }
        else j++;
      }
    }                                                
  }
  
  int result = 1;
  Ddi_BddComposeAcc(notR,psRef,deltaRef);
  //Ddi_BddComposeAcc(notR,ps,delta);
  long myStartTime = util_cpu_time();

  // base step
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("Checking base step for reached of size. %d\n",
           Ddi_BddSize(notR));
  }
  if (Fsm_MgrReadInitStubSteps(fsmMgr) <= 1) {
    if (Ddi_AigSatAnd(initRef,notR,NULL))
      result = 0;
  }
  else
    result = 0;
  
  if (result) {
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("Checking inductive reached of size. %d\n",
           Ddi_BddSize(notR));
    }
    fp = !Ddi_AigSatAnd(rUnfolded,notR,constrRef);
    if (!fp)
      result = 0;
  }
  if (result) {
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("Checking target reached of size. %d\n",
           Ddi_BddSize(notR));
    }
    if (Ddi_AigSatAnd(rUnfolded,targetRef,NULL)) {
      result = 0;
      Ddi_Vararray_t *rSuppA = Ddi_BddSuppVararray(rUnfolded);
      Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(target,
            rUnfolded, NULL, rSuppA, 100, NULL);

      Ddi_Free(cex);
      Ddi_Free(rSuppA);

      int safe = 10, done = 0;
      Ddi_Bdd_t *chkCone = Ddi_BddDup(targetRef);
      for (int j=1; j<=safe && !done; j++) {
        char suffix[10];
        sprintf(suffix, "%d", j);
        Ddi_Vararray_t *newFrameVars =
          Ddi_VararrayMakeNewVars(piRef, "PDT_TF_PI", suffix, 1);
        Ddi_Bddarray_t *deltaFrame = Ddi_BddarrayDup(deltaRef);
        Ddi_BddarraySubstVarsAcc(deltaFrame, piRef, newFrameVars);
        Ddi_Free(newFrameVars);
        Ddi_BddComposeAcc(chkCone,psRef,deltaFrame);
        Ddi_Free(deltaFrame);
        int res = Ddi_AigSatAnd(chkCone,
                                rUnfolded,0);
        if (res) {
          printf("reached is hitting cone of bound %d\n", j);
          int res0 = Ddi_AigSatAnd(chkCone,initRef,NULL);
          if (res0) {
            printf("BMC failure at bound %d\n", j);
            done = 1;
          }
          else {
            printf("BMC ok for bound %d\n", j);
          }
        }
        else {
          done = 1;
          printf("reached is safe for bound %d\n", j);
          result = 1;
        }
      }
      Ddi_Free(chkCone);
    }
  }
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nCheck Done invariant %s - time: %s\n",
             result ? "proved" : "disproved",
        util_print_time((util_cpu_time() - myStartTime)));
  }

  if (wFsm != NULL) {
    Ddi_BddarrayInsertLast(lambdaRef,rUnfolded);
    Fsm_FsmMiniWriteAiger(fsmFsmRef, wFsm);
  }                    
  
  Ddi_Free(notR);
  Ddi_Free(rUnfolded);
  Ddi_Free(target);
  Ddi_Free(targetRef);
  Fsm_FsmFree(fsmFsm);
  Fsm_FsmFree(fsmFsmRef);

  return result;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
proofCheckInvar(
  Fsm_Fsm_t * fsmFsm,
  Ddi_Bdd_t *invar
)
{
  Ddi_Mgr_t *ddm = Fsm_MgrReadDdManager(Fsm_FsmReadMgr(fsmFsm));
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);

  Ddi_Bddarray_t *delta = Fsm_FsmReadDelta(fsmFsm); 
  Ddi_Bddarray_t *lambda = Fsm_FsmReadLambda(fsmFsm); 
  Ddi_Bdd_t *target = Ddi_BddNot(Ddi_BddarrayRead(lambda,0));

  // check invariant (fix-point)
  
  Ddi_Vararray_t *ps = Fsm_FsmReadPS(fsmFsm);
  Ddi_Vararray_t *ns = Fsm_FsmReadNS(fsmFsm);

  Ddi_Bdd_t *notInv = Ddi_BddNot(invar);
  Ddi_Vararray_t *suppPi = Ddi_BddSuppVararray(notInv);
  Ddi_VararrayDiffAcc(suppPi,ps);
  if (Ddi_VararrayNum(suppPi) > 0) {
    Ddi_Vararray_t *auxVars = Ddi_VararrayMakeNewAigVars(suppPi,"PDT_PROOF_CHECK","");
    Ddi_BddSubstVarsAcc(notInv, suppPi, auxVars);
    Ddi_Free(auxVars);
  }
  Ddi_Free(suppPi);

  if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
    printf("Checking inductive invariant of size. %d\n",
           Ddi_BddSize(invar));
  }
  Ddi_Bdd_t *notInvAndTr =  Ddi_BddCompose(notInv,ps,delta);
  long myStartTime = util_cpu_time();
  int fp = !Ddi_AigSatAnd(invar,notInvAndTr,NULL);
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nCheck Done invariant %s - time: %s\n",
             fp ? "proved" : "disproved",
        util_print_time((util_cpu_time() - myStartTime)));
  }
  if (!fp) {
    Ddi_Bdd_t *myNotInv = Ddi_BddDup(notInv);
    Ddi_Bdd_t *tr = Ddi_BddRelMakeFromArray(delta, ns);
    Ddi_Varset_t *nsv = Ddi_VarsetMakeFromArray(ns);
    Ddi_BddSetAig(tr);
    Ddi_BddSubstVarsAcc(myNotInv, ps, ns);
    Ddi_BddNotAcc(myNotInv);
    Ddi_BddExistProjectAcc(myNotInv,nsv);
    Ddi_BddNotAcc(myNotInv);
    Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(invar,
            myNotInv, tr, NULL, 100, NULL);  
    Ddi_Free(nsv);
    Ddi_Free(tr);
    Ddi_Free(myNotInv);
    Ddi_Free(cex);
  }
  Ddi_Free(notInvAndTr);
  Ddi_Free(notInv);

  int chk;
  if (fp) {
    myStartTime = util_cpu_time();
    if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
      printf("Checking property of size. %d\n",
             Ddi_BddSize(target));
    }
    chk = Ddi_AigSatAnd(invar,target,NULL);
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nCheck Done property %s - time: %s\n",
             !chk ? "proved" : "disproved",
             util_print_time((util_cpu_time() - myStartTime)));
    }
  }
  Ddi_Free(target);
  return fp && chk;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
proofHandlePhaseAbstr(
  Fsm_Fsm_t *fsmFsm,
  Ddi_Bdd_t *invar,
  int phAbstr
)
{
  Ddi_Mgr_t *ddm = Fsm_MgrReadDdManager(Fsm_FsmReadMgr(fsmFsm));

  if (phAbstr == 0)
    return 0;

  char name [100];
  Ddi_Bddarray_t *delta = Fsm_FsmReadDelta(fsmFsm); 
  Ddi_Bddarray_t *lambda = Fsm_FsmReadLambda(fsmFsm); 
  Ddi_Vararray_t *pi = Fsm_FsmReadPI(fsmFsm);
  Ddi_Vararray_t *ps = Fsm_FsmReadPS(fsmFsm);
  Ddi_Vararray_t *ns = Fsm_FsmReadNS(fsmFsm);
  Ddi_Bddarray_t *initStub = Fsm_FsmReadInitStub(fsmFsm);
  Ddi_Bdd_t *init = Fsm_FsmReadInit(fsmFsm); 

  int i, nl = Ddi_VararrayNum(ps), iLast = nl-1;

  Ddi_Var_t *prevPs = NULL;

  Ddi_Vararray_t *psPrevVars = Ddi_VararrayMakeNewAigVars(ps,"PDT_PHASE_ABSTR_PREV_PS",NULL);
  Ddi_Vararray_t *piPrevVars = Ddi_VararrayMakeNewAigVars(pi,"PDT_PHASE_ABSTR_PREV_PI",NULL);
  Ddi_Vararray_t *newPsVars = Ddi_VararrayUnion(psPrevVars,piPrevVars);
  Ddi_Vararray_t *newNsVars = Ddi_VararrayMakeNewAigVars(newPsVars,NULL,"$NS");
  Ddi_Bddarray_t *newDeltasPs = Ddi_BddarrayMakeLiteralsAig(ps, 1);
  Ddi_Bddarray_t *newDeltasPi = Ddi_BddarrayMakeLiteralsAig(pi, 1);

  Ddi_Bddarray_t *delta0 = Ddi_BddarrayDup(delta);

  Ddi_BddarraySubstVarsAcc(delta0,pi,piPrevVars);
  Ddi_BddarraySubstVarsAcc(delta0,ps,psPrevVars);
  Ddi_Bdd_t *newInv = Ddi_BddRelMakeFromArray(delta0, ps);
  Ddi_BddSetAig(newInv);
  Ddi_Bdd_t *prevInv = Ddi_BddSubstVars(invar,ps,psPrevVars);
  Ddi_BddAndAcc(newInv,prevInv); // so this is the imag of invar
  Ddi_Free(prevInv);
  
  Ddi_Var_t *newvPs = Ddi_VarNewBaig(ddm, "PDT_PHASE_ABSTR_CTRL_0");
  Ddi_Var_t *newvNs = Ddi_VarNewBaig(ddm, "PDT_PHASE_ABSTR_CTRL_0$NS");
  Ddi_VararrayInsertLast(ps,newvPs);
  Ddi_VararrayInsertLast(ns,newvNs); 
  Ddi_Bdd_t *newD = Ddi_BddMakeLiteralAig(newvPs, 0); 
  Ddi_BddarrayInsertLast(delta,newD);
  if (initStub==NULL) {
    Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(newvPs, 0); 
    Ddi_BddAndAcc(init,lit);
    Ddi_Free(lit);
  }
  else {
    Ddi_Bdd_t *zero = Ddi_BddMakeConstAig(ddm, 0);
    Ddi_BddarrayInsertLast(initStub,zero);
    Ddi_Free(zero);
  }

  Ddi_BddarrayAppend(delta, newDeltasPs);
  Ddi_BddarrayAppend(delta, newDeltasPi);

  Ddi_VararrayAppend(ps,newPsVars);
  Ddi_VararrayAppend(ns,newNsVars);
  Ddi_Free(psPrevVars);
  Ddi_Free(piPrevVars);

  if (initStub==NULL) {
    Ddi_Bddarray_t *litArray = Ddi_BddarrayMakeLiteralsAig(newPsVars, 0); 
    Ddi_Bdd_t *newInit = Ddi_BddMakePartConjFromArray(litArray);
    Ddi_BddSetAig(newInit);
    Ddi_BddAndAcc(init,newInit);
    Ddi_Free(litArray);
    Ddi_Free(newInit);
  }
  else {
    Ddi_Bdd_t *zero = Ddi_BddMakeConstAig(ddm, 0);
    for (int i=0; i<Ddi_VararrayNum(newPsVars); i++) 
      Ddi_BddarrayInsertLast(initStub,zero);
    Ddi_Free(zero);
  }

  Ddi_BddOrAcc(newInv,newD);
  Ddi_BddNotAcc(newD);
  Ddi_BddOrAcc(invar,newD);
  Ddi_BddAndAcc(invar,newInv);
  
  Ddi_Free(newD);
  Ddi_Free(delta0);
  Ddi_Free(newInv);
  Ddi_Free(newPsVars);
  Ddi_Free(newNsVars);
  Ddi_Free(newDeltasPi);
  Ddi_Free(newDeltasPs);

  
  return 1;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
proofHandleInitStub(
  Fsm_Fsm_t *fsmFsm,
  Ddi_Bdd_t *invar,
  int iSteps
)
{
  Ddi_Mgr_t *ddm = Fsm_MgrReadDdManager(Fsm_FsmReadMgr(fsmFsm));

  if (iSteps == 0)
    return 0;

  char name [100];
  Ddi_Bddarray_t *delta = Fsm_FsmReadDelta(fsmFsm); 
  Ddi_Bddarray_t *lambda = Fsm_FsmReadLambda(fsmFsm); 
  Ddi_Vararray_t *pi = Fsm_FsmReadPI(fsmFsm);
  Ddi_Vararray_t *ps = Fsm_FsmReadPS(fsmFsm);
  Ddi_Vararray_t *ns = Fsm_FsmReadNS(fsmFsm);
  Ddi_Bdd_t *init = Fsm_FsmReadInit(fsmFsm); 

  int i, nl = Ddi_VararrayNum(ps), iLast = nl-1;

  Ddi_Var_t *prevPs = NULL;
  Ddi_Bddarray_t *unroll = Ddi_BddarrayMakeLiteralsAig(ps, 1);
  Ddi_Bddarray_t *delta0 = Ddi_BddarrayDup(delta);
  Ddi_Bddarray_t *deltaSim = Ddi_BddarrayDup(delta);
  Ddi_Vararray_t *ps0 = Ddi_VararrayDup(ps);
  Ddi_Vararray_t *suppPi = Ddi_BddarraySuppVararray(delta0);
  Ddi_VararrayDiffAcc (suppPi,ps);
  Ddi_AigarrayConstrainCubeAcc(unroll,init);
  Ddi_Vararray_t *suppPs = Ddi_BddarraySuppVararray(unroll);
  Ddi_Bdd_t *is0Inv = NULL;
  Ddi_Vararray_t *isPsVars = NULL;
  if (Ddi_VararrayNum(suppPs) > 0) {
    Ddi_Bddarray_t *unrollRef = Ddi_BddarrayDup(unroll);
    Ddi_Bdd_t *is0Inv = Ddi_BddMakeConstAig(ddm, 1);
    isPsVars = Ddi_VararrayMakeNewAigVars(suppPs,"PDT_STUB_PS","");
    Ddi_BddarraySubstVarsAcc(unroll, suppPs, isPsVars);
    for (int i=0; i<Ddi_BddarrayNum(unroll); i++)  {
      Ddi_Bdd_t *u_i = Ddi_BddarrayRead(unroll,i);
      if (!Ddi_BddIsConstant(u_i)) {
        Ddi_Bdd_t *u0_i = Ddi_BddarrayRead(unroll,i);
        Ddi_Bdd_t *c_i = Ddi_BddXnor(u0_i, u_i);
        Ddi_BddAndAcc(is0Inv,c_i);
        Ddi_Free(c_i);
      }
    }
    Ddi_Free(unrollRef);
  }
  Ddi_Free(suppPs);

  Ddi_Bdd_t *prevStepsDone = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t *isInv = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t *resetInv = Ddi_BddDup(init);
  Ddi_Bddarray_t *stepConstrNeg = Ddi_BddarrayAlloc(ddm,1);
  Ddi_VararrayWriteMarkWithIndex (pi, 1);
  Ddi_Vararray_t *cleanVarMarks = NULL;
  for (i=0; i<iSteps; i++) {
    sprintf(name, "PDT_TEMPOR_DECOMP_VAR_%d", i);
    Ddi_Var_t *newvPs = Ddi_VarNewBaig(ddm, name);
    sprintf(name, "PDT_TEMPOR_DECOMP_VAR_%d$NS", i);
    Ddi_Var_t *newvNs = Ddi_VarNewBaig(ddm, name);
    Ddi_VararrayInsertLast(ps,newvPs);
    Ddi_VararrayInsertLast(ns,newvNs); // dummy, not stored on file
    Ddi_Bdd_t *newD = i==0 ?
      Ddi_BddMakeConstAig(ddm, 1) :
      Ddi_BddMakeLiteralAig(prevPs, 1); 
    Ddi_BddarrayInsertLast(delta,newD);
    Ddi_Bdd_t *initDone_i = Ddi_BddMakeLiteralAig(newvPs, 1);
    Ddi_BddOrAcc(resetInv,initDone_i);
    if (i>0) {
      Ddi_Bddarray_t *newUnroll = Ddi_BddarrayCompose(delta0,ps0,unroll);
      char suffix[10];
      sprintf(suffix, "%d", i-1);
      Ddi_Vararray_t *isPiVars = Ddi_VararrayMakeNewAigVars(suppPi,"PDT_STUB_PI",suffix);
      Ddi_BddarraySubstVarsAcc(newUnroll, suppPi, isPiVars);
      for (int j=0; j<Ddi_VararrayNum(isPiVars); j++) {
        int m = Ddi_VarReadMark (Ddi_VararrayRead(suppPi,j));
        Ddi_VarWriteMark (Ddi_VararrayRead(isPiVars,j),m);
      }
      if (cleanVarMarks == NULL)
        cleanVarMarks = Ddi_VararrayDup(isPiVars);
      else
        Ddi_VararrayAppend(cleanVarMarks,isPiVars);
      Ddi_Free(isPiVars);
      Ddi_Free(unroll);
      unroll = newUnroll;

      Ddi_Bdd_t *newInv = Ddi_BddRelMakeFromArray(unroll, ps0);
      Ddi_Bdd_t *thisStep = Ddi_BddDiff(prevStepsDone,initDone_i);
      Ddi_BddNotAcc(thisStep);
      Ddi_BddarrayWrite(stepConstrNeg,i,thisStep);
      Ddi_BddSetAig(newInv);
      Ddi_BddOrAcc(newInv,thisStep);
      Ddi_BddAndAcc(isInv,newInv);
      Ddi_Free(newInv);
      Ddi_Free(thisStep);
      // newvPs => prevPs
      newInv = Ddi_BddNot(initDone_i);
      Ddi_BddOrAcc(newInv,newD);
      Ddi_BddAndAcc(isInv,newInv);
      Ddi_Free(newInv);      
    }
    else {
      if (is0Inv!=NULL) {
        Ddi_BddOrAcc(is0Inv,initDone_i);
      }
      Ddi_BddarrayWrite(stepConstrNeg,i,initDone_i);
    }
    Ddi_BddDiffAcc(init,initDone_i);
    Ddi_BddAndAcc(prevStepsDone,initDone_i);
    prevPs = newvPs;
    Ddi_Free(initDone_i);
    Ddi_Free(newD);
  }
  Ddi_Free(suppPi);
  Ddi_Free(delta0);
  Ddi_Free(deltaSim);
  Ddi_Free(ps0);
  Ddi_Free(unroll);

  Ddi_VararrayWriteMark (pi, 0);

  //  Ddi_Bdd_t *isDone = Ddi_BddMakeLiteralAig(prevPs, 1); 
  Ddi_Bdd_t *isDone = Ddi_BddDup(prevStepsDone); 
  Ddi_Bdd_t *refInvarspec = Ddi_BddarrayRead(lambda,0);
  // stepinv => invariant
  Ddi_BddNotAcc(isDone);
  Ddi_BddOrAcc(invar,isDone);
  Ddi_Free(isDone);


  Ddi_Vararray_t *supp = Ddi_BddSuppVararray(isInv);
  Ddi_Vararray_t *newPsVars = Ddi_VararrayAlloc(ddm,0);
  vec<int> varRefPiIndex;
  for (int i=0; i<Ddi_VararrayNum(supp); i++) {
    Ddi_Var_t *v_i = Ddi_VararrayRead(supp,i);
    int m = Ddi_VarReadMark(v_i);
    if (m>0) {
      Ddi_VararrayInsertLast(newPsVars,v_i);
      varRefPiIndex.push(m-1);
    }
  }
  Ddi_Free(supp);
  if (cleanVarMarks != NULL) {
    Ddi_VararrayWriteMark (cleanVarMarks, 0);
    Ddi_Free(cleanVarMarks);
  }
  Ddi_VararrayUnionAcc(ps,newPsVars);
  Ddi_Vararray_t *newNsVars = Ddi_VararrayMakeNewAigVars(newPsVars,NULL,"$NS");
  Ddi_VararrayUnionAcc(ns,newNsVars);
  Ddi_Bddarray_t *newDeltas = Ddi_BddarrayMakeLiteralsAig(newPsVars, 1);
  for (int i=0; i<Ddi_BddarrayNum(newDeltas); i++) {
    Ddi_Bdd_t *d_i = Ddi_BddarrayRead(newDeltas,i);
    Ddi_Var_t *newPs_i = Ddi_VararrayRead(newPsVars,i);
    int step = Pdtutil_StrGetNumSuffix(Ddi_VarName(newPs_i),'_');
    Pdtutil_Assert(step>=0 && step<Ddi_BddarrayNum(stepConstrNeg),"missing step suffix");
    int piIndex = varRefPiIndex[i];
    Pdtutil_Assert(piIndex>=0 && piIndex<Ddi_VararrayNum(pi),"wrong pi index");
    Ddi_Var_t *pi_i = Ddi_VararrayRead(pi,piIndex);
    Ddi_Bdd_t *stepCN_i = Ddi_BddarrayRead(stepConstrNeg,step);
    Ddi_Bdd_t *piLit_i = Ddi_BddMakeLiteralAig(pi_i,1); 
    Ddi_Bdd_t *newD_i = Ddi_BddIte(stepCN_i,d_i,piLit_i);
    Ddi_BddarrayWrite(newDeltas,i,newD_i);
    Ddi_Free(newD_i);
    Ddi_Free(piLit_i);
  }
  Ddi_BddarrayAppend(delta, newDeltas);
  Ddi_Free(newPsVars);
  Ddi_Free(newNsVars);
  Ddi_Free(newDeltas);
  // !stepInv => original invarspec
  Ddi_BddAndAcc(invar,refInvarspec);
  Ddi_BddAndAcc(invar,isInv);
  Ddi_BddAndAcc(invar,resetInv);
  if (is0Inv!=NULL)
    Ddi_BddAndAcc(invar,is0Inv);
               
  Ddi_Free(prevStepsDone);
  Ddi_Free(resetInv);
  Ddi_Free(is0Inv);
  Ddi_Free(isInv);
  Ddi_Free(isPsVars);
  Ddi_Free(stepConstrNeg);
  
  return 1;
}




/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatStoreProofAiger(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Fsm_Mgr_t * fsmMgrRef,
  char *wFsm
)
{
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int fp=0;
  Fsm_Fsm_t *fsmFsm = Fsm_FsmMakeFromFsmMgr(fsmMgr);
  Fsm_FsmUnfoldProperty(fsmFsm, 1);
  Fsm_FsmUnfoldConstraint(fsmFsm);
  Fsm_Fsm_t *fsmFsmRef = Fsm_FsmMakeFromFsmMgr(fsmMgrRef);
  Fsm_FsmUnfoldProperty(fsmFsmRef, 1);
  Fsm_FsmUnfoldConstraint(fsmFsmRef);
  
  Ddi_Bddarray_t *delta = Fsm_FsmReadDelta(fsmFsm); 
  Ddi_Bddarray_t *deltaRef = Fsm_FsmReadDelta(fsmFsmRef); 
  Ddi_Bdd_t *initRef = Fsm_FsmReadInit(fsmFsmRef); 
  Ddi_Bddarray_t *lambda = Fsm_FsmReadLambda(fsmFsm); 
  Ddi_Bddarray_t *lambdaRef = Fsm_FsmReadLambda(fsmFsmRef); 
  Ddi_Bdd_t *constrRef = Fsm_FsmReadConstraint(fsmFsmRef); 
  Ddi_Bdd_t *target = Ddi_BddNot(Ddi_BddarrayRead(lambda,0));
  Ddi_Bdd_t *targetRef = Ddi_BddNot(Ddi_BddarrayRead(lambdaRef,0));

  
  Ddi_Vararray_t *psRef = Fsm_FsmReadPS(fsmFsmRef);
  Ddi_Vararray_t *piRef = Fsm_FsmReadPI(fsmFsmRef);
  Ddi_Vararray_t *ps = Fsm_FsmReadPS(fsmFsm);
  Ddi_Vararray_t *ns = Fsm_FsmReadPS(fsmFsm);


  Ddi_Bdd_t *r = Trav_MgrReadReached(travMgr);
  Ddi_Vararray_t *auxV = Fsm_MgrReadVarAuxVar(fsmMgr);
  Ddi_Bddarray_t *auxF = Fsm_MgrReadAuxVarBDD(fsmMgr);
  if (r==NULL || wFsm == NULL) {
    printf("mising invariant or filename\n");
    Ddi_Free(target);
    Ddi_Free(targetRef);
    return 0;
  }
  // Ddi_BddComposeAcc(target,ps,delta);
  // Ddi_BddComposeAcc(targetRef,psRef,deltaRef);
  Ddi_Bdd_t *rUnfolded = Ddi_BddDup(r);

  int custom = 0;
  if (custom) {
    Ddi_Var_t *v1 = Ddi_VarFromName(ddm,"l338");
    Ddi_Var_t *v2 = Ddi_VarFromName(ddm,"l166");
    //    Ddi_Var_t *v1 = Ddi_VarFromName(ddm,"b0");
    //    Ddi_Var_t *v2 = Ddi_VarFromName(ddm,"b1");
    Ddi_Bdd_t *l1 = Ddi_BddMakeLiteralAig(v1,1);
    Ddi_Bdd_t *l2 = Ddi_BddMakeLiteralAig(v2,1);
    Ddi_BddAndAcc(rUnfolded,l1);
    Ddi_BddAndAcc(rUnfolded,l2);
    Ddi_Free(l1);
    Ddi_Free(l2);
  }
  
  if (Fsm_FsmReadConstrInvar(fsmFsm) != NULL) {
    Ddi_Bdd_t *constrInvar = Fsm_FsmReadConstrInvar(fsmFsm);
    Ddi_BddOrAcc(rUnfolded,constrInvar);
  }
  
  if (Fsm_FsmReadLatchEqClasses(fsmFsm) != NULL) {
    Ddi_Bdd_t *latchEqClasses = Ddi_BddMakeAig(Fsm_FsmReadLatchEqClasses(fsmFsm));
    Ddi_BddAndAcc(rUnfolded,latchEqClasses);
    Ddi_Free(latchEqClasses);
  }

  Ddi_Var_t *pVar = Fsm_MgrReadPdtSpecVar(fsmMgr);
  Ddi_Var_t *cVar = Fsm_MgrReadPdtConstrVar(fsmMgr);

  if (pVar!=NULL) {
    Ddi_BddCofactorAcc(rUnfolded,pVar,1);
    Ddi_BddCofactorAcc(target,pVar,1);
    Ddi_BddCofactorAcc(targetRef,pVar,1);
  }
  if (cVar!=NULL) {
    Ddi_BddCofactorAcc(rUnfolded,cVar,1);
    Ddi_BddCofactorAcc(target,cVar,1);
    Ddi_BddCofactorAcc(targetRef,cVar,1);
  }

  Ddi_BddComposeAcc(rUnfolded,auxV,auxF);
  Ddi_Bdd_t *notR = Ddi_BddNot(rUnfolded);

  //  Ddi_Vararray_t *psRemoved = Ddi_VararrayDiff(psRef,ps);
  proofHandlePhaseAbstr(fsmFsmRef, rUnfolded, Fsm_MgrReadPhaseAbstr(fsmMgr));

  //  Ddi_Vararray_t *psRemoved = Ddi_VararrayDiff(psRef,ps);
  proofHandleInitStub(fsmFsmRef, rUnfolded, Fsm_MgrReadInitStubSteps(fsmMgr));
  
  proofCheckInvar(fsmFsmRef, rUnfolded);
  
  Ddi_BddarrayWrite(lambdaRef,0,rUnfolded);
  //    Fsm_FsmWriteInvarspec(fsmFsmRef,rUnfolded);
  Fsm_FsmWriteInvarspec(fsmFsmRef,notR);
  
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("storing proof in %s\n",wFsm);
  }
  Fsm_FsmMiniWriteAiger(fsmFsmRef, wFsm);
  
  Ddi_Free(notR);
  Ddi_Free(rUnfolded);
  Ddi_Free(target);
  Ddi_Free(targetRef);
  Fsm_FsmFree(fsmFsm);
  Fsm_FsmFree(fsmFsmRef);

  return 1;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatCheckInvar(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t *invar,
  int *checkTargetSatP
)
{
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int fp=0;
  Fsm_Fsm_t *fsmFsm = Fsm_FsmMakeFromFsmMgr(fsmMgr);
  Fsm_FsmUnfoldProperty(fsmFsm, 1);
  Fsm_FsmUnfoldConstraint(fsmFsm);
  
  Ddi_Bddarray_t *delta = Fsm_FsmReadDelta(fsmFsm); 
  Ddi_Bddarray_t *lambda = Fsm_FsmReadLambda(fsmFsm); 
  Ddi_Bdd_t *target = Ddi_BddNot(Ddi_BddarrayRead(lambda,0));

  // check invariant (fix-point)
  
  Ddi_Vararray_t *ps = Fsm_FsmReadPS(fsmFsm);
  Ddi_Vararray_t *ns = Fsm_FsmReadPS(fsmFsm);

  Ddi_Bdd_t *notInv = Ddi_BddNot(invar);
  if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
    printf("Checking inductive invariant of size. %d\n",
           Ddi_BddSize(invar));
  }
  Ddi_BddComposeAcc(notInv,ps,delta);
  long myStartTime = util_cpu_time();
  fp = !Ddi_AigSatAnd(invar,notInv,NULL);
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nCheck Done invariant %s - time: %s\n",
             fp ? "proved" : "disproved",
        util_print_time((util_cpu_time() - myStartTime)));
  }
  Ddi_Free(notInv);
  if (checkTargetSatP != NULL) {
    int chk;
    myStartTime = util_cpu_time();
    if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
      printf("Checking property of size. %d\n",
           Ddi_BddSize(target));
    }
    chk = *checkTargetSatP = Ddi_AigSatAnd(invar,target,NULL);
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nCheck Done property %s - time: %s\n",
             !chk ? "proved" : "disproved",
             util_print_time((util_cpu_time() - myStartTime)));
    }
  }
  Fsm_FsmFree(fsmFsm);
  Ddi_Free(target);
  return fp;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatItpGfp(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  int gfp,
  int countR
)
{
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Trav_ItpMgr_t *itpMgr = NULL;
  Trav_ItpTravMgr_t *itpTravMgr = NULL;
  itpMgr = Trav_ItpMgrInit(travMgr, fsmMgr,
			   Fsm_MgrReadConstraintBDD(fsmMgr), NULL, 1, 0);

  int nl = Ddi_BddarrayNum(itpMgr->delta);
  Ddi_Bdd_t *target = Ddi_BddNot(Ddi_BddarrayRead(itpMgr->delta,nl-1));
  itpMgr->target = target;
  
  itpTravMgr = itpTravMgrInit(travMgr, itpMgr);

  int lastRing = Ddi_BddarrayNum(itpMgr->fromRings)-1;
  itpTravMgr->careBwd = Ddi_BddMakeConstAig(ddm, 1);

  if (itpTravMgr->reached == NULL) {
    Ddi_Free(itpTravMgr->reached);
    if (lastRing>0) {
      itpTravMgr->reached = Ddi_BddMakeConstAig(ddm, 0);
      for (int i=0; i<=lastRing; i++) {
	Ddi_Bdd_t *r_i = Ddi_BddarrayRead(itpMgr->fromRings,i);
	if (r_i!=NULL)
	  Ddi_BddOrAcc(itpTravMgr->reached,r_i);
      }
    }
    else {
      Ddi_Bdd_t *r = Trav_MgrReadReached(travMgr);
      if (r!=NULL) {
	itpTravMgr->reached = Ddi_BddDup(Trav_MgrReadReached(travMgr));
	Ddi_BddSubstVarsAcc(itpTravMgr->reached,
                                  itpMgr->ps,itpMgr->ns);      }
      else
	itpTravMgr->reached = Ddi_BddMakeConstAig(ddm, 1);

    }
  }

  int nVars = Ddi_VararrayNum(itpMgr->ns);
  double nr0;

  if (countR>0) {
    Ddi_Bdd_t *rBdd = Ddi_BddMakeMono(itpTravMgr->reached);
    double nr = Ddi_BddCountMinterm(rBdd, 1);
    fprintf(stdout, "#INITIAL Reached States = %g * 2^(#ref vars: %d)\n",
            nr, nVars);
    nr0 = nr;
    Ddi_Free(rBdd);
  }

  int sizeR0 = Ddi_BddSize(itpTravMgr->reached);
  int doReplaceConstr = 0;
  for (int i=0; i<gfp; i++) {
    int size0 = Ddi_BddSize(itpTravMgr->reached);
    int enStrong = (gfp>3) && (i<gfp-1);

    int doBmcRefine = 0;
    if (doBmcRefine) {
      Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
      Pdtutil_VerbLevel_e vNew = Pdtutil_VerbLevelUsrMed_c;
      if (verbosity > Pdtutil_VerbLevelUsrMed_c)
	Ddi_MgrSetVerbosity(ddm,vNew);
      itpStrengthenRingsBwdByBmc(itpMgr,1,lastRing,1,itpMgr->delta,3,0,0,0);
      Ddi_MgrSetVerbosity(ddm,verbosity);
    }
    int useInvarConstr=0;
    if (lastRing<0 && Ddi_BddIsOne(itpTravMgr->reached) && !Ddi_BddIsOne(itpMgr->invarConstr)) {
      useInvarConstr = 1;
      doReplaceConstr = 1;
    }
    int ret = itpStrengthenReachedGfp(itpTravMgr, &lastRing,
                                      enStrong,i==(gfp-1),useInvarConstr,0);
    if (!ret) break;
    if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
      printf("GFP reached reduction iter %d: %d -> %d\n",
             i, size0,
             Ddi_BddSize(itpTravMgr->reached));
    }
    if (countR>0) {
      Ddi_Bdd_t *rBdd = Ddi_BddMakeMono(itpTravMgr->reached);
      double nr = Ddi_BddCountMinterm(rBdd, 1);
      fprintf(stdout, "#TOTAL Reached States = %g * 2^(#ref vars: %d)\n",
            nr, nVars);
      fprintf(stdout, "reached strengthening: %g - size: %g\n",
              nr0/nr, ((double)Ddi_BddSize(itpTravMgr->reached))/sizeR0);
      Ddi_Free(rBdd);
    }
  }

  Ddi_Bdd_t *r = Ddi_BddSubstVars(itpTravMgr->reached,
                                  itpMgr->ns,itpMgr->ps);
  Fsm_MgrSetReachedBDD(fsmMgr,r);
  Fsm_MgrSetCareBDD(fsmMgr,r);
  Ddi_Bdd_t *constr = Fsm_MgrReadConstraintBDD(fsmMgr);
  if (constr!=NULL) {
    if (!doReplaceConstr)
      Ddi_BddAndAcc(r,constr);
  }
  Fsm_MgrSetConstraintBDD(fsmMgr,r);
  Ddi_Bddarray_t *delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  int iConstr = Ddi_BddarrayNum(delta)-2;
  Ddi_Bdd_t *dConstr = Ddi_BddarrayRead(delta,iConstr);
  if (doReplaceConstr)
    Ddi_DataCopy(dConstr,r);
  else
    Ddi_BddAndAcc(dConstr,r);
  Ddi_Free(r);
  
  itpTravMgrFree(itpTravMgr);
  Trav_ItpMgrQuit(itpMgr);
  return 1;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravTrAbstrItp(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  int nFrames,
  int optLevel,
  int firstFwdStep,
  int maxFwdStep,
  int bmcBound
)
{
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Trav_ItpMgr_t *itpMgr = NULL;
  Ddi_Bddarray_t *trConstrA = NULL;
  char fileSuffix[100];
  
  itpMgr = Trav_ItpMgrInit(travMgr, fsmMgr,
			   Fsm_MgrReadConstraintBDD(fsmMgr),
                           Fsm_MgrReadInvarspecBDD(fsmMgr), 1, 0);

  int nl = Ddi_BddarrayNum(itpMgr->delta);
  
  if (travMgr->settings.aig.trAbstrItpLoad != NULL) {
    int nFrames;
    //    Ddi_Bddarray_t *trConstrA0 = TravTravTrAbstrLoad(travMgr,&nFrames); 
    Ddi_Bddarray_t *trConstrA0 = itpMgr->trItpAbstr.psNsConstr;
    nFrames = itpMgr->trItpAbstr.nFrames;

    char *s = strstr(travMgr->settings.aig.trAbstrItpLoad, "_tr_abstr_");
    Pdtutil_Assert(s!=NULL, "wrong file name for tr constr");
    sprintf(fileSuffix,"_opt%s", s);
    //    trConstrA = optTrConstr(itpMgr,trConstrA0,nFrames);
    if (optLevel < 0) {
      Ddi_Bdd_t *trOpt = Ddi_AigNnfStats(Ddi_BddarrayRead(trConstrA0,0),0,-optLevel);
      trConstrA = Ddi_BddarrayAlloc(ddm,1);
      Ddi_BddarrayWrite(trConstrA,0,trOpt);
      Ddi_Free(trOpt);
    }
    else {
      trConstrA = optTrConstrForBmcCone(itpMgr,trConstrA0,nFrames,optLevel>1?1:0);    
    }
    //    Ddi_Free(trConstrA0);
  }
  else if (bmcBound > 0) {
    int lastRing = firstFwdStep + nFrames;
    trConstrA = genTrConstrFromBmcCone(itpMgr,firstFwdStep,lastRing,bmcBound);    
    sprintf(fileSuffix,"_tr_abstr_bmc_%d_%d_%d.aig", bmcBound, firstFwdStep, nFrames);
  }
  else {
    int lastRing = Ddi_BddarrayNum(itpMgr->fromRings)-1;
    if (maxFwdStep+nFrames > lastRing)
      maxFwdStep = lastRing-nFrames;
    lastRing = maxFwdStep+nFrames;
    if (firstFwdStep < 0) firstFwdStep=0;
    if (firstFwdStep > maxFwdStep) firstFwdStep=maxFwdStep;
    trConstrA = genTrConstrFromItpRings(itpMgr,firstFwdStep,lastRing,nFrames);
    sprintf(fileSuffix,"_tr_abstr_rings_%d_%d_%d.aig", lastRing, maxFwdStep, nFrames);
  }

  char *store = travMgr->settings.aig.trAbstrItpStore;
  if (store != NULL) {
    char fname[500];
    strcpy(fname,store);
    char *s = strstr(fname,".");
    if (s==NULL) s = fname+strlen(fname);
    sprintf(s,"%s", fileSuffix);
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nAbstrRef - storing tr constraint [%d] (size: %d) to file %s\n\n",
             Ddi_BddarrayNum(trConstrA), Ddi_BddarraySize(trConstrA), fname);
    }
    Ddi_AigarrayNetStoreAiger(trConstrA, 0, fname);
  }

  Ddi_Free(trConstrA);
  
  Trav_ItpMgrQuit(itpMgr);
  return 1;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatItpVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * lemma,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * care,
  int step,
  int bound,
  float lazyRate,
  int firstFwdIter,
  int timeLimit
)
{
  Ddi_Varset_t *pivars;
  Ddi_Bddarray_t *delta, *psLit, *nsLit, *piLit;
  Ddi_Bdd_t *reached, *unroll, *target, *tr, *tr_i,
    *loopFree, *myInvarspec, *notReached = NULL, *newReached = NULL;
  int sat = 0, res = 1, i, k, nState, nPi, initIsCube;
  long initTime, startTime;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Varset_t *supp, *psVars;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bddarray_t *lemmas = NULL;
  Ddi_Bdd_t *oldCone = NULL, *newCone = NULL, *fullCone = NULL,
    *fullConeRings = NULL,
    *fullConeAux = NULL,
    *inductionCone = NULL, *inductionConeBase = NULL,
    *previousCone = NULL, *saveCone = NULL,
    *newConeRed = NULL, *newConeAux = NULL, *newConeAux2 = NULL;
  Ddi_Bdd_t *lemmasInvar = NULL;
  int doExist = 0, doExistThreshold = 1000, doExistMaxSize = 10000;
  Trav_ItpMgr_t *itpMgr = NULL;
  int itpBmcBound = 1;
  int stallEnable = 0, optLevel = 0;
  int size0 = -1, size1;
  int nextSaveCone = 2, savedConeIter = -1, savedConeWindow = 1;
  int itpExact = Trav_MgrReadItpExact(travMgr);
  float sizeIncrease = 0.0;
  Ddi_Bddarray_t *previousConeAuxLits = NULL, *saveConeAuxLits = NULL;
  int nBadDoExist = 0, nGoodDoExist = 0;
  int useExtraCheck = 0, useInductionCone = 0;
  int maxFP2Iter = 2;
  int computeFullCone = 0, constrainOpt = 0 /* @@@@@@@@@@@@@@@@@ */ ;
  Ddi_Bdd_t *rInterpolant = NULL;
  float lazyTimeLimit = travMgr->settings.aig.lazyTimeLimit;
  int tryBdd = 0, useTrBdd = 0, maxFailBddBwd = 3, bddSuccess = 0;
  int maxLemmas = 5;
  Ddi_Bddarray_t *partWindows = NULL, *deferredUnroll = NULL;
  int dynAbstr = Trav_MgrReadDynAbstr(travMgr);
  int abstrRef = Trav_MgrReadAbstrRef(travMgr);
  int abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  int abcOpt = Ddi_MgrReadAigAbcOptLevel(ddm);
  int nFreeDelta = 0;
  int nSuppDelta[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  int useInitCare = 0, filterNew = 0;
  Tr_Mgr_t *trMgr = NULL;
  Tr_Tr_t *trBdd = NULL;
  Ddi_Bdd_t *itpCareRef = NULL, *coneBdd = NULL, *careBdd = NULL, *bckReached =
    NULL;
  int imgAndExistTh = 50000;
  int useInnerCone = 1;
  int keepConeRings = Trav_MgrReadItpInnerCones(travMgr);
  int coneRingPeriod = keepConeRings;
  int forceInterpolant = Trav_MgrReadItpForceRun(travMgr);
  int fixPointBdd = 0;
  int enableLoopFree = 0;
  int existOptPlus = 1;
  int useSingleCone = 1;
  int existLevel = 1;
  Ddi_Bdd_t *newConeConstraint = NULL;
  Ddi_Bdd_t *newConeConstraint2 = NULL;
  Ddi_Bdd_t *deltaConstraint = NULL;
  int iProp = -1, iConstr = -1;
  int monotoneConeOpt = 0;
  int constrainConeOpt = 0;
  int useInvarFull = 0;
  int chkFpWithInductionCone = 1;
  int lemmaSteps = 2;
  int deferConeBuild = 0, nDeferred = 0;
  int noItp = 0;
  int doStoreR = 1;
  int itpRefineCex = Trav_MgrReadItpRefineCex(travMgr);
  int itpConstrLevel = Trav_MgrReadItpConstrLevel(travMgr);
  int itpAppr = Trav_MgrReadItpAppr(travMgr);
  int enAigOptPdt = Trav_MgrReadItpConeOpt(travMgr) > 1;
  int enAigStructOpt = Trav_MgrReadItpConeOpt(travMgr) > 0;
  int useBoundkCone = Trav_MgrReadItpBoundkOpt(travMgr);
  int useReached = Trav_MgrReadItpUseReached(travMgr);
  int optForDeep = Trav_MgrReadItpTuneForDepth(travMgr) > 0;
  int noBoundOpt = Trav_MgrReadItpTuneForDepth(travMgr) < 0;
  int itpMaxStepK = travMgr->settings.aig.itpMaxStepK;
  int disConeUnwind = 0;
  int isIgr = 0;
  int enIgr = Trav_MgrReadItpReuseRings(travMgr) == 2;

  if (travMgr->settings.ints.igrSingleRewind > 0)
    forceInterpolant = -1;
  
  /* initialization steps */

  if (1) {
    /* check init state */
    Ddi_Bdd_t *initFsm = Fsm_MgrReadInitBDD(fsmMgr);

    if (initFsm == NULL) {
      Pdtutil_Assert(init == NULL, "trav & fsm init do not match");
    } else {
      Pdtutil_Assert(Ddi_AigEqualSat(initFsm, init),
        "trav & fsm init do not match");
    }
  }

  if (itpConstrLevel <= 0)
    invar = NULL;

  itpMgr = Trav_ItpMgrInit(travMgr, fsmMgr, itpConstrLevel > 1 ? invar : 0,
    invarspec, 1, optLevel);

  if (lemma != NULL) {
    itpMgr->lemma = Ddi_BddDup(lemma);
  }

  /* init care and check if target proved */

  if (care == NULL) {
    care = Ddi_BddMakeConstAig(ddm, 1);
  } else {
    Ddi_Bdd_t *careAndTarget = Ddi_BddMakeAig(care);

    Ddi_BddAndAcc(careAndTarget, itpMgr->target);
    if (0 && invar != NULL) {
      Ddi_BddAndAcc(careAndTarget, invar);
    }
    if (!Ddi_AigSat(careAndTarget)) {
      Ddi_Free(careAndTarget);
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "property proved by CARE.\n")
        );
      Trav_MgrSetAssertFlag(travMgr, 0);
      return (1);
    }
    Ddi_Free(careAndTarget);

    care = Ddi_BddMakeAig(care);
    if (0 && Ddi_BddSize(care) > 1000) {
      ddiAbcOptAcc(care, -1.0);
    }
  }

  nState = Ddi_VararrayNum(itpMgr->ps);

  Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelDevMin_c) {
    fprintf(tMgrO(travMgr), "STEP: %d.\n", step);
  }

  if (iProp < 0) {
    int l;
    Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");
    Ddi_Var_t *cvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");

    for (l = nState - 1; l >= 0; l--) {
      Ddi_Var_t *v_i = Ddi_VararrayRead(itpMgr->ps, l);

      if (v_i == pvarPs) {
        iProp = l;
      } else if (v_i == cvarPs) {
        iConstr = l;
      }
      if (iProp >= 0 && iConstr >= 0)
        break;
    }
  }

  if (step > 0) {
    int result = 0, lambdaNum = -1;
    int speculate = 0;          /* not effective for inductive proofs !!! */

    /* maybe provides more lemmas when property is not inductive */
    Ddi_Bddarray_t *potLemmas = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_Bddarray_t *falseLemmas = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_Bdd_t *myCare = NULL, *myInvar = NULL;
    Ddi_Bdd_t *myInvarspec = Ddi_BddDup(invarspec);

    //    invar = Ddi_BddMakeLiteralAig(Ddi_VarFromName(ddm,"i36"),0);
    //    Ddi_BddAndAcc(invar,lit);
    //    Ddi_Free(lit);
    //    Ddi_BddNotAcc(invar); Ddi_BddOrAcc(invar,invarspec);
    //    Ddi_Free(invar);

    myCare = Ddi_BddDup(care);
    if (speculate) {
      Ddi_Bdd_t *retimedSpec;

      //      delta = Fsm_MgrReadDeltaBDD(fsmMgr);
      delta = itpMgr->delta;
      retimedSpec = Ddi_BddCompose(invarspec, itpMgr->ps, delta);
      Ddi_Free(myInvarspec);
      myInvarspec = retimedSpec;
      Ddi_BddAndAcc(myCare, retimedSpec);
      //      Ddi_Free(retimedSpec);
    }
    //    myCare = Ddi_BddMakeConstAig(ddm,1);

    //    myInvar = Ddi_BddDup(invar);
    myInvar = itpConstrLevel > 0 ? Ddi_BddDup(invar) : NULL;
    if (0 && invar != NULL) {   /* GpC: fix this */
      //      delta = Fsm_MgrReadDeltaBDD(fsmMgr);
      delta = itpMgr->delta;
      if (Ddi_BddSize(invar) == 1) {
        int iId = Ddi_VararrayNum(itpMgr->ps) - 2;
        Ddi_Varset_t *iSupp = Ddi_BddSupp(invar);
        Ddi_Var_t *iV = Ddi_VararrayRead(itpMgr->ps, iId);

        if (Ddi_VarInVarset(iSupp, iV)) {
          Ddi_Bdd_t *iRetimed = Ddi_BddarrayRead(delta, iId);

          Ddi_BddAndAcc(myInvar, iRetimed);
        }
        Ddi_Free(iSupp);
      }
      Ddi_BddAndAcc(myCare, myInvar);
    }

    if (Trav_MgrReadNewi(travMgr) != NULL) {
      lambdaNum = Ddi_BddarrayNum(Fsm_MgrReadLambdaBDD(fsmMgr));
      int j;

      Ddi_BddarrayAppend(Fsm_MgrReadLambdaBDD(fsmMgr),
        Trav_MgrReadNewi(travMgr));
    }


    lemmas = genLemmaClasses(travMgr, fsmMgr,
      init, itpMgr->initStub, myInvar, myInvarspec, myCare, potLemmas, step,
      1, 0, 3, &result, 0, NULL /*falseLemmas */ );

    if (Trav_MgrReadNewi(travMgr) != NULL) {
      Pdtutil_Assert(lambdaNum > 0, "wrong lambda num");
      int j;
      Ddi_Bddarray_t *newi = Trav_MgrReadNewi(travMgr);
      Ddi_Bddarray_t *l = Fsm_MgrReadLambdaBDD(fsmMgr);

      for (j = Ddi_BddarrayNum(newi) - 1; j >= 0; j--) {
        Ddi_Bdd_t *l_j = Ddi_BddarrayExtract(l, lambdaNum + j);

        Ddi_BddarrayWrite(newi, j, l_j);
        Ddi_Free(l_j);
      }
    }

    Ddi_Free(falseLemmas);
    if (iConstr >= 0 && myInvar != NULL) {
      Ddi_Bdd_t *dConstr =
        Ddi_BddarrayRead(Fsm_MgrReadDeltaBDD(fsmMgr), iConstr);
      Ddi_BddAndAcc(dConstr, myInvar);
    }

    Ddi_Free(myCare);
    Ddi_Free(myInvar);
    Ddi_Free(myInvarspec);
    if (result > 0) {
      if (doStoreR) {
        Ddi_Bdd_t *rOut = NULL;

        if (0 || lemmas == NULL) {
          rOut = Ddi_BddMakeConstAig(ddm, 1);
        } else {
          rOut = Ddi_BddMakePartConjFromArray(lemmas);
        }
        Ddi_BddSetAig(rOut);
        Trav_MgrSetReached(travMgr, rOut);
        Ddi_Free(rOut);
        if (itpMgr != NULL) {
          if ((Trav_MgrReadItpReuseRings(travMgr) > 2) && itpMgr->nRings > 0) {
            Ddi_Bddarray_t *rings = Ddi_BddarrayDup(itpMgr->fromRings);

            if (itpMgr->eqRings != NULL
              && Ddi_BddarrayNum(itpMgr->eqRings) > 0) {
              int j;

              for (j = 0; j < Ddi_BddarrayNum(itpMgr->eqRings); j++) {
                Ddi_Bdd_t *eq = Ddi_BddarrayRead(itpMgr->eqRings, j);
                Ddi_Bdd_t *ring_j = Ddi_BddarrayRead(rings, j);

                if (eq != NULL) {
                  Ddi_BddSetPartConj(ring_j);
                  Pdtutil_Assert(Ddi_BddPartNum(ring_j) == 1,
                    "error in ring as part");
                  Ddi_BddPartWrite(ring_j, 1, eq);
                }
              }
            }
            Trav_MgrSetNewi(travMgr, rings);
            Ddi_Free(rings);
          }
        }
      }
      Ddi_Free(potLemmas);
      Ddi_Free(lemmas);
      Ddi_Free(care);
      Trav_MgrSetAssertFlag(travMgr, 0);
      return 1;
    }
    if (result < 0) {
      Ddi_Free(care);
      Ddi_Free(potLemmas);
      Ddi_Free(lemmas);
      Trav_MgrSetAssertFlag(travMgr, 1);
      return 0;
    }
    if (0 && Ddi_BddarrayNum(potLemmas) > 0) {
      if (0) {
        partWindows = Ddi_BddarrayDup(potLemmas);
      } else {
        Ddi_Varset_t *supp = Ddi_BddarraySupp(potLemmas);

        partWindows = Ddi_BddarrayAlloc(ddm, 0);
        for (i = 0; i < Ddi_VararrayNum(itpMgr->ps); i++) {
          Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->ps, i);

          if (Ddi_VarInVarset(supp, v)
            /* && (strcmp(Ddi_VarName(v),"l666")==0) */
            ) {
            Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, 1);

            Ddi_BddarrayInsertLast(partWindows, lit);
            Ddi_Free(lit);
          }
        }
        Ddi_Free(supp);
      }
    }
    Ddi_Free(potLemmas);
  }

  initTime = travMgr->travTime = util_cpu_time();

#if 1
  itpCareRef = care;
#else
  itpCareRef = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Free(care);
#endif
  //  care = Ddi_BddDup(care);
  care = Ddi_BddMakeConstAig(ddm, 1);

  if (Trav_MgrReadItpReuseRings(travMgr) == 2) {
    if (0 && (Trav_MgrReadNewi(travMgr) != NULL)) {
      Ddi_Free(itpCareRef);
      itpCareRef = Ddi_BddMakeConstAig(ddm, 1);
    }
  }

  if (lemmas != NULL) {
    lemmasInvar = Ddi_BddMakeConstAig(ddm, 1);
    for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
      Ddi_BddAndAcc(lemmasInvar, Ddi_BddarrayRead(lemmas, i));
    }
    Ddi_Free(lemmas);
  }
  if (lemmasInvar != NULL) {
    if (invar != NULL) {
      Ddi_BddAndAcc(lemmasInvar, invar);
    }
  }

  useInnerCone = 0;
  if (lazyRate >= 0.89 && lazyRate <= 0.99) {
    lazyRate = 1.0;
  }

  if (lazyRate < 1) {
    optLevel = 0;
    lazyRate = 1.01;
  } else if (lazyRate >= 2.01) {
    //    stallEnable = 1;
    useInitCare = 1;
    optLevel = 2;
    if (lazyRate > 2.21) {
      doExistMaxSize *= 4;
      tryBdd = 1;
    }
    if (lazyRate > 2.26) {
      tryBdd = 2;
      existOptPlus = 1;
      useSingleCone = 1;
    }
    if (lazyRate > 2.31) {
      existOptPlus = 1;
      useSingleCone = 1;
    }
    if (lazyRate > 2.36) {
      existOptPlus = 1;
      itpBmcBound = -4;
      useSingleCone = 1;
      existLevel = 1;
    }
    if (lazyRate > 2.46) {
      itpBmcBound = -10;
      noItp = 1;
      filterNew = 1;
      useSingleCone = 1;
    }
    lazyRate -= 1.0;
  } else if (lazyRate >= 1) {
    optLevel = 1;
    if (lazyRate > 1.01) {
      useInitCare = 1;
    }
    if (lazyRate > 1.09) {
      itpBmcBound = -3;
    }
    if (lazyRate > 1.19) {
      itpBmcBound = -8;
    }
  }

  if (!enIgr && forceInterpolant >= 0) {
    itpBmcBound = forceInterpolant + 1;
  }

  // itpBmcBound = -30;
  if (itpExact)
    tryBdd = 2;

  if (optLevel == 0 /* || dynAbstr>3 */ ) {
    /* disable prev cone opt */
    nextSaveCone = 0;
  }

  useExtraCheck = optLevel > 3;

  Ddi_MgrSetOption(ddm, Pdt_DdiLazyRate_c, fnum, lazyRate);

  psVars = Ddi_VarsetMakeFromArray(itpMgr->ps);

  //  delta = Ddi_BddarrayDup(Fsm_MgrReadDeltaBDD(fsmMgr));
  delta = Ddi_BddarrayDup(itpMgr->delta);
  /* check if init reachable from init */

  if (0) {
    Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");
    Ddi_Bdd_t *pLit = Ddi_BddMakeLiteralAig(pvarPs, 1);

    Ddi_Bddarray_t *subst = Ddi_BddarrayMakeLiteralsAig(itpMgr->ps, 1);

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Modifying TR to add !prop -> 0 state.\n", i)
      );

    for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
      Ddi_BddAndAcc(Ddi_BddarrayRead(subst, i), pLit);
    }
    Ddi_Free(pLit);
    Ddi_BddarrayComposeAcc(delta, itpMgr->ps, subst);
    Ddi_Free(subst);
  }

  if (0) {
    Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm, 0);
    int rrp = Ddi_MgrReadAigRedRemMaxCnt(ddm);

    Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, 1);
    DdiAigArrayRedRemovalAcc(delta, myCare, -1, -1.0);
    Ddi_Free(myCare);
    Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, rrp);

  }

  if (0 && !stallEnable) {
    Ddi_Bdd_t *checkInit = Ddi_BddCompose(init, itpMgr->ps, delta);

    Ddi_BddAndAcc(checkInit, init);
    stallEnable = !Ddi_AigSat(checkInit);
    Ddi_Free(checkInit);
  }
#if 0
  if (useBoundkCone && initStub == NULL) {
    int initReachable;
    Ddi_Bdd_t *checkInit = Ddi_BddCompose(init, ps, delta);

    Ddi_BddAndAcc(checkInit, init);
    initReachable = Ddi_AigSat(checkInit);
    Ddi_Free(checkInit);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr),
        "INIT is %s reachable from INIT.\n", initReachable ? "" : "NOT")
      );
    if (!initReachable) {
      stallEnable = 1;
    }
  } else if (useBoundkCone) {
    stallEnable = 1;
  }
#endif

  myInvarspec = Ddi_BddNot(itpMgr->target);
  if (0 && (travMgr->settings.aig.targetEn > 0)) {
    Ddi_Bdd_t *r;
    int nIter = travMgr->settings.aig.targetEn;

    travMgr->settings.aig.targetEn = 0;
    r = Trav_TravSatBckVerif(travMgr, fsmMgr,
      init, invarspec, invar, NULL, nIter, 0, 0);
    Ddi_Free(myInvarspec);
    Ddi_BddNotAcc(r);
    myInvarspec = r;
    Ddi_BddAndAcc(care, r);
    //    stallEnable = 1;
  }

  if (stallEnable) {
    Ddi_Var_t *v = Ddi_VarNew(ddm);
    Ddi_Bdd_t *c_i;
    Ddi_Bddarray_t *pA;

    if (itpMgr->initStub == NULL) {
      pA = Ddi_BddarrayRangeMakeFromCube(init, itpMgr->ps);
    } else {
      pA = Ddi_BddarrayMakeLiteralsAig(itpMgr->ps, 1);
    }

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Modifying TR to add init -> init transition.\n",
        i)
      );

    Ddi_VarAttachName(v, "PDT_STALL_DUMMY_CONTROL");
    Ddi_VararrayInsertLast(itpMgr->pi, v);
    c_i = Ddi_BddMakeLiteralAig(v, 1);
    for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
      Ddi_Bdd_t *d_i, *p_i;

      p_i = Ddi_BddarrayRead(pA, i);
      d_i = Ddi_BddIte(c_i, Ddi_BddarrayRead(delta, i), p_i);
      Ddi_BddarrayWrite(delta, i, d_i);
      Ddi_Free(d_i);
    }
    Ddi_Free(pA);
    Ddi_Free(c_i);
    // NO: because affects backward use
    //    Fsm_MgrSetDeltaBDD (fsmMgr,delta);
  }

  nState = Ddi_BddarrayNum(delta);
  nPi = Ddi_VararrayNum(itpMgr->pi);

  pivars = Ddi_VarsetMakeFromArray(itpMgr->pi);

  {
    Ddi_Bdd_t *initPart = Ddi_AigPartitionTop(init, 0);

    initIsCube = Ddi_BddIsCube(initPart);
    Ddi_Free(initPart);
  }


  if (lemmasInvar != NULL && itpConstrLevel > 3) {
    Trav_ItpMgrQuit(itpMgr);
    itpMgr = Trav_ItpMgrInit(travMgr, fsmMgr, lemmasInvar, invarspec, 1, optLevel);
    //    Ddi_Free(lemmasInvar);
  }

  if (itpMgr->time_limit > 0) {
    itpMgr->time_limit = initTime + itpMgr->time_limit;
  }

  if (invar != NULL) {
    //itpMgr->invarConstr = Ddi_BddDup(invar);
    //invar = NULL;
  }
  if (lazyRate > 1.09) {
    itpMgr->itpOpt = optLevel;
    if (lazyRate > 1.19) {
      itpMgr->itpOpt++;
    }
    lazyRate -= 0.1;
  }

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    fprintf(tMgrO(travMgr), "lazyRate: %f - itpOpt: %d - optLevel: %d.\n",
      lazyRate, itpMgr->itpOpt, optLevel)
    );

  useInductionCone = itpMgr->itpOpt > 1;

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    if (itpMgr->nFreeDelta > 0) {
    fprintf(tMgrO(travMgr), "%d free deltas found.\n", itpMgr->nFreeDelta);}
  ) ;

  /* try TR by BDDs */

  if (1 && tryBdd > 1 && (itpExact || Ddi_VararrayNum(itpMgr->ps) < 120)) {

    int i, size = Ddi_BddarraySize(delta);

    //    int th = size > 500 ? 10000 : size*50;
    int th = Fsm_MgrReadCutThresh(fsmMgr) >= 0 ?
      Fsm_MgrReadCutThresh(fsmMgr) >= 0 : 5000;
    Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm, 0);
    Ddi_Bddarray_t *deltaBdd = Ddi_AigarrayOptByBdd(delta,
      auxF, auxV, th, 0, timeLimit, -1);

    if (deltaBdd != NULL) {

      int size;

      Ddi_MgrReduceHeap(ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);

      size = Ddi_BddarraySize(deltaBdd);
      if (Ddi_BddarrayNum(auxF) > 0) {
        size += Ddi_BddarraySize(auxF);
      }
      if (size > 30000 && !itpExact) {
        Ddi_Free(deltaBdd);
      } else {
        trMgr = Tr_MgrInit("TR-manager-AIG", ddm);
        Tr_MgrSetOption(trMgr, Pdt_TrSort_c, inum, Tr_SortWeight_c);

        /* enable smoothing PIs while clustering */
        Tr_MgrSetClustSmoothPi(trMgr, 1);
        Tr_MgrSetOption(trMgr, Pdt_TrClustTh_c, inum, 1000);

        Tr_MgrSetI(trMgr, itpMgr->pi);
        Tr_MgrSetPS(trMgr, itpMgr->ps);
        Tr_MgrSetNS(trMgr, itpMgr->ns);
        Tr_MgrSetAuxVars(trMgr, auxV);
        Tr_MgrSetAuxFuns(trMgr, auxF);

        trBdd = Tr_TrMakePartConjFromFunsWithAuxVars(trMgr,
          deltaBdd, itpMgr->ns, auxF, auxV);

        itpMgr->trBdd = Tr_TrDup(trBdd);
        itpMgr->trAig = Tr_TrDup(trBdd);
        for (i = 0; i > Ddi_BddPartNum(Tr_TrBdd(itpMgr->trBdd)); i++) {
          Ddi_Bdd_t *tr_i = Ddi_BddPartRead(Tr_TrBdd(itpMgr->trBdd), i);

          Ddi_BddSetAig(tr_i);
        }

        itpMgr->trBddIsAig = 0;

        Tr_TrReverseAcc(trBdd);
        Tr_MgrSetImgAndExistTh(trMgr, imgAndExistTh);
        Tr_TrSortIwls95(trBdd);

        //      Tr_TrSortIwls95(trBdd);
        Tr_TrReverseAcc(trBdd);

        Tr_TrSetClustered(trBdd);

        Tr_TrSortIwls95(itpMgr->trBdd);
        Tr_TrSetClustered(itpMgr->trBdd);

        Ddi_BddSwapVarsAcc(Tr_TrBdd(trBdd), itpMgr->ps, itpMgr->ns);
        for (i = 0; i < Ddi_BddarrayNum(auxF); i++) {
          Ddi_BddSwapVarsAcc(Ddi_BddarrayRead(Tr_MgrReadAuxFuns(trMgr), i), itpMgr->ps,
            itpMgr->ns);
        }

        useInductionCone = 0;
        useTrBdd = 1;

        Ddi_Free(deltaBdd);
      }
    }
    Ddi_Free(auxV);
    Ddi_Free(auxF);

  } else if (0 && (itpAppr > 0 && (nState < 5000 || itpAppr > 1))) {

    trMgr = Tr_MgrInit("TR-manager-AIG", ddm);
    Tr_MgrSetOption(trMgr, Pdt_TrSort_c, inum, Tr_SortWeight_c);

    /* enable smoothing PIs while clustering */
    Tr_MgrSetClustSmoothPi(trMgr, 1);
    Tr_MgrSetOption(trMgr, Pdt_TrClustTh_c, inum, 1000);

    Tr_MgrSetI(trMgr, itpMgr->pi);
    Tr_MgrSetPS(trMgr, itpMgr->ps);
    Tr_MgrSetNS(trMgr, itpMgr->ns);

    trBdd = Tr_TrMakePartConjFromFunsWithAuxVars(trMgr, delta, itpMgr->ns, NULL, NULL);

    itpMgr->trBdd = Tr_TrDup(trBdd);

    Tr_TrReverseAcc(trBdd);
    Tr_MgrSetImgAndExistTh(trMgr, imgAndExistTh);
    if (nState < 2000) {
      Tr_TrSortIwls95(trBdd);
    }
    //      Tr_TrSortIwls95(trBdd);
    Tr_TrReverseAcc(trBdd);

    // Tr_TrSetClustered(trBdd);
    Ddi_BddSetClustered(Tr_TrBdd(trBdd), 1000);

    if (nState < 2000) {
      Tr_TrSortIwls95(itpMgr->trBdd);
    }
    //    Tr_TrSetClustered(itpMgr->trBdd);
    Ddi_BddSetClustered(Tr_TrBdd(itpMgr->trBdd), 1000);

    Ddi_BddSwapVarsAcc(Tr_TrBdd(trBdd), itpMgr->ps, itpMgr->ns);

    //useInductionCone = 0;
    itpMgr->trBddIsAig = 1;

  }

  if (tryBdd > 1) {
    if (existOptPlus)
      tryBdd = 0;
  }


  /* build tr */
  nsLit = Ddi_BddarrayMakeLiteralsAig(itpMgr->ns, 1);
  psLit = Ddi_BddarrayMakeLiteralsAig(itpMgr->ps, 1);
  piLit = Ddi_BddarrayMakeLiteralsAig(itpMgr->pi, 1);

  tr = Ddi_BddRelMakeFromArray(delta, itpMgr->ns);
  Ddi_BddSetAig(tr);

#if 0
  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c,
    fprintf(tMgrO(travMgr), "FREE   DELTA: %d/%d.\n", nFreeDelta, nState)
    );
  for (i = 0; i < 10; i++) {
    if (nSuppDelta[i] > 0)
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "%d SUPP DELTA: %d/%d.\n", i, nSuppDelta[i],
          nState)
        );
  }
#endif

  Ddi_Free(pivars);

  loopFree = Ddi_BddMakeConstAig(ddm, 1);
  unroll = Ddi_BddMakeConstAig(ddm, 1);
  reached = Ddi_BddMakeConstAig(ddm, 0);

  //  DdiAigRedRemovalAcc (tr,myInvarspec,-1);
  //  Ddi_BddAndAcc(tr,myInvarspec);

  if (itpMgr->time_limit > 0 && (util_cpu_time() > itpMgr->time_limit)) {
    /* nxr: make the function to abort */
    sat = -1;
  }
  startTime = util_cpu_time();

  supp = Ddi_BddSupp(myInvarspec);
  if (Ddi_VarsetIsArray(psVars)) {
    Ddi_VarsetSetArray(supp);
  }
  Ddi_VarsetIntersectAcc(supp, psVars);

  timeFrameInfoPush(itpMgr->timeFrames, psLit, itpMgr->ps, piLit, itpMgr->pi, supp);

  Ddi_Free(supp);

  newCone = Ddi_BddNot(myInvarspec);
  Ddi_BddWriteMark(newCone, 0);

  if (0) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");

    if (iv != NULL) {
      Ddi_BddCofactorAcc(newCone, iv, 1);
    }
  }

  if (trBdd != NULL) {
    coneBdd = Ddi_BddMakeMono(newCone);
    careBdd = Ddi_BddMakeConst(ddm, 1);
  }


  if (keepConeRings) {
    fullConeRings = Ddi_BddMakePartDisjVoid(ddm);
  }

  newConeRed = Ddi_BddNot(myInvarspec);
  if (0 && optLevel > 1) {
    newConeAux = Ddi_BddNot(myInvarspec);
    fullConeAux = Ddi_BddMakeConstAig(ddm, 0);
  }
  if (useInitCare) {
    Ddi_BddOrAcc(reached, newCone);
    Ddi_BddDiffAcc(care, newCone);
  }

  fullCone = Ddi_BddMakeConstAig(ddm, 0);
  inductionCone = Ddi_BddDup(newCone);

  /* main interpolation loop */
  for (i = 0; !sat; i++) {
    Ddi_Bdd_t *check;           //, *oldCare;
    int coiNum = 1, fixPoint = 0;
    int simplifyCone = 0, simplifiedCone = 0;;
    int forceFixpointCheck = 0, fullState = 0, tryFixpointCheck = 0;
    Ddi_Bdd_t *rOut = NULL;
    Ddi_Bdd_t *careOut = NULL;

    if (itpOutOfLimits(itpMgr)) {
      sat = -1;
      res = 2;                  /* abort */
      break;
    }

    if (bound > 0 && i >= bound) {
      sat = -1;
      res = 2;                  /* abort */
      break;
    }

    if (doStoreR) {
      rOut = Ddi_BddMakeConstAig(ddm, 1);
    }

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      int nbaig = Ddi_MgrReadAigNodesNum(ddm);
      fprintf(tMgrO(travMgr),
        "Using bwd cone at bound %d (cone(aux): %d(%d) - care: %d).\n", i,
        Ddi_BddSize(newCone), newConeAux ? Ddi_BddSize(newConeAux) : 0,
        care ? Ddi_BddSize(care) : 0);
      fprintf(tMgrO(travMgr), "{COI: %d} ", coiNum);
      fprintf(tMgrO(travMgr), "curr NODE ID: %d, ", ddm->currNodeId);
      fprintf(tMgrO(travMgr), "baig Nodes: %d.\n", nbaig)
      );

    if (0 && invar != NULL) {
#if 1
#if 1
      // wrong abstraction when using lemmas under invar assumption
      Ddi_Bdd_t *myInvar =
        Ddi_BddMakeLiteralAig(Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS"), 1);
#else
      Ddi_Bdd_t *myInvar = Ddi_BddDup(invar);
#endif

      Ddi_Bdd_t *partCone = Ddi_AigPartitionTop(newCone, 1);
      int j;

      for (j = 0; j < Ddi_BddPartNum(partCone); j++) {
        Ddi_BddAndAcc(Ddi_BddPartRead(partCone, j), myInvar);
      }
      Ddi_BddSetAig(partCone);
      Ddi_DataCopy(newCone, partCone);
      Ddi_Free(partCone);
      Ddi_Free(myInvar);
#else
      Ddi_BddAndAcc(newCone, invar);
#endif
      if (newConeAux != NULL) {
        Ddi_BddAndAcc(newConeAux, invar);
      }
    }

    int tryMe = 0;

    if (tryMe) {
      Ddi_Var_t *v = Ddi_VarFromName(ddm, "stall");
      Ddi_Var_t *v0 = Ddi_VarFromName(ddm, "stall_0");
      Ddi_Varset_t *supp = Ddi_VarsetMakeFromVar(v);
      Ddi_Varset_t *supp0 = Ddi_VarsetMakeFromVar(v0);

      DdiAigExistOverAcc(newCone, supp0, NULL);
      DdiAigExistOverAcc(newCone, supp, NULL);
      Ddi_Free(supp);
      Ddi_Free(supp0);
    }

    if (partWindows != NULL) {
      int j;
      int size1, size0 = Ddi_BddSize(newCone);

      for (j = 0; j < Ddi_BddarrayNum(partWindows); j++) {
        Ddi_Bdd_t *window = Ddi_BddarrayRead(partWindows, j);
        Ddi_Bdd_t *a = Ddi_BddDup(newCone);
        Ddi_Bdd_t *b = Ddi_BddDup(newCone);

        Ddi_AigConstrainCubeAcc(a, window);
        Ddi_BddAndAcc(a, window);

        Ddi_BddNotAcc(window);
        Ddi_AigConstrainCubeAcc(b, window);
        Ddi_BddAndAcc(b, window);
        Ddi_BddNotAcc(window);

        Ddi_BddOrAcc(a, b);
        Ddi_Free(b);
        size1 = Ddi_BddSize(a);
        if (size1 < 1.1 * size0) {
          Ddi_Free(newCone);
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "ncPartw.\n")
            );
          newCone = a;
          size0 = size1;
          Ddi_Free(inductionCone);
          inductionCone = Ddi_BddDup(newCone);
        } else {
          Ddi_Free(a);
        }
      }
    }

    if (1 || (itpMgr->initStub == NULL))
      if (itpMgr->unsatGuaranteed < 0 || i >= itpMgr->unsatGuaranteed) {
        check = Ddi_BddDup(newConeAux != NULL ? newConeAux : newCone);

        if (abstrRef) {
          Ddi_BddComposeAcc(check, itpMgr->abstrRefCtrl,
            itpMgr->abstrDoRefine);
        }
        if (newConeConstraint != NULL) {
          Ddi_BddAndAcc(check, newConeConstraint);
        }
        if (newConeConstraint2 != NULL) {
          Ddi_BddAndAcc(check, newConeConstraint2);
        }
        if (invar) {
          Ddi_BddAndAcc(check, invar);
        }
        if (newConeAux != NULL
          && Ddi_BddSize(newCone) < Ddi_BddSize(check) / 10) {
          Ddi_DataCopy(check, newCone);
        }
        if (itpMgr->initStub != NULL) {
          Ddi_BddComposeAcc(check, itpMgr->ps, itpMgr->initStub);
        } else if (initIsCube) {
          Ddi_AigAndCubeAcc(check, init);
        } else {
          Ddi_BddAndAcc(check, init);
        }

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), " BMC (AIG size: %d/%d/%d) ",
            Ddi_BddSize(check), Ddi_BddSize(newCone), Ddi_BddSize(newConeRed))
          );

        sat = Ddi_AigSatWithAbort(check, lazyTimeLimit);
        if (sat == -1) {
          /* aborted */
          DdiAigRedRemovalAcc(check, NULL, -1, 2 * lazyTimeLimit);
          sat = Ddi_AigSatWithAbort(check, 4 * lazyTimeLimit) == 1;
          //      sat = Ddi_AigSat(check)==1;
        }
        Ddi_Free(check);
        if (sat) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "BMC failure at bound %d.\n", i)
            );
          res = 0;
          Ddi_Free(itpCareRef);
          Ddi_Free(care);
          Ddi_Free(rOut);
          break;
        }
      } else {
        sat = 0;
      }

    if (0) {
      if (Ddi_BddSize(care) > 100) {
        Ddi_Bdd_t *eq = DdiAigEquivVarsAcc(care, NULL,
          NULL, psVars, newCone, NULL, NULL);

        if (eq != NULL) {
          Ddi_BddAndAcc(care, eq);
          Ddi_Free(eq);
        }
      }
    }
    if (0) {
      Ddi_Bddarray_t *implArray = Ddi_BddarrayAlloc(ddm, 0);
      Ddi_Bdd_t *carePlusCube = DdiAigImplicationsAcc(care, NULL, NULL,
        psVars, implArray);

      if (implArray != NULL && Ddi_BddarrayNum(implArray) > 0) {
        Ddi_Bdd_t *careDup = Ddi_BddDup(care);

        Ddi_AigConstrainImplAcc(care, implArray);
        Ddi_AigConstrainImplAcc(newCone, implArray);
        Ddi_BddAndAcc(care, carePlusCube);
        Ddi_BddXorAcc(careDup, care);
        Pdtutil_Assert(!Ddi_AigSat(careDup), "wrong impl constrain");
        Ddi_Free(careDup);
      }
      Ddi_Free(implArray);
      Ddi_Free(carePlusCube);
    }

    if (0 && !stallEnable && step > 2 && i > 2 &&
      /* (Ddi_BddSize(care) > 10) && */ --maxLemmas > 0) {
      int result = 0, l, nstate = Ddi_BddarrayNum(delta);
      Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_Bdd_t *enlargedSpec = Ddi_BddNot(newCone);
      Ddi_Bddarray_t *potLemmas = Ddi_BddarrayAlloc(ddm, 0);
      Ddi_Bddarray_t *lambda = Fsm_MgrReadLambdaBDD(fsmMgr);

      Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");
      Ddi_Bdd_t *deltaProp = NULL;
      Ddi_Bdd_t *myInvarspec = NULL;

      for (l = 0; l < nstate; l++) {
        Ddi_Var_t *v_i = Ddi_VararrayRead(itpMgr->ps, l);

        if (v_i == pvarPs) {
          iProp = l;
          break;
        }
      }
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "iprop = %d/%d.\n", iProp, nstate)
        );
      //      deltaProp = Ddi_BddDup(Ddi_BddarrayRead(delta,iProp));
      // Ddi_BddarrayWrite(delta,iProp,enlargedSpec);

      Ddi_DataCopy(Fsm_MgrReadDeltaBDD(fsmMgr), delta);
      Ddi_BddarrayInsert(lambda, 1, newCone);
      if (invar != NULL) {
        myInvarspec = Ddi_BddDup(itpMgr->target);
        Ddi_BddAndAcc(enlargedSpec, invar);
      } else {
        myInvarspec = enlargedSpec;
      }
      lemmas = genLemmaClasses(travMgr, fsmMgr,
        init, itpMgr->initStub, invar,
        myInvarspec /*enlargedSpec */ , myCare, potLemmas, step, 1, 0, 0,
        &result, 0, NULL);
      //      Ddi_Free(deltaProp);
      Ddi_Free(myInvarspec);

      Ddi_DataCopy(delta, Fsm_MgrReadDeltaBDD(fsmMgr));

      Ddi_Free(newCone);
      //      newCone = Ddi_BddNot(Ddi_BddarrayRead(delta,iProp));
      //      Ddi_BddarrayWrite(delta,iProp,deltaProp);
      newCone = Ddi_BddarrayExtract(lambda, 1);
      //      Ddi_Free(deltaProp);
      Ddi_Free(enlargedSpec);
      Ddi_Free(myCare);
      Ddi_Free(potLemmas);
      Ddi_Free(lemmas);
      Ddi_Free(delta);
      delta = Ddi_BddarrayDup(Fsm_MgrReadDeltaBDD(fsmMgr));
      if (result) {
        res = result > 0 /*1 */ ;
        Ddi_Free(rOut);
        break;
      }
    }

    if (care != NULL && Ddi_BddSize(care) > 1) {
      computeFullCone = 1;
    }

    if (0 && lemmasInvar != NULL) {
#if 1
      Ddi_AigExistProjectAcc(lemmasInvar, psVars, NULL, 0, 0, -1.0);
      Ddi_BddAndAcc(care, lemmasInvar);
#else
      Ddi_BddAndAcc(newCone, lemmasInvar);
#endif
    }

    doExist = useTrBdd || (sizeIncrease > 2.0 /*&& i>1 */ ) ||
      Ddi_BddSize(newCone) < 50 ||
      Ddi_BddSize(newCone) > doExistThreshold || Ddi_VararrayNum(itpMgr->pi) < 50;
    doExist = (doExist || i <= 2) && (nBadDoExist < 1);
    doExist &= useInitCare;
    doExist &= Ddi_BddSize(newCone) < doExistMaxSize;

    bddSuccess = 0;
    if (1 && doExist) {
      newConeAux2 = Ddi_BddDup(newCone);
    }

    if (0 && !doExist) {
      int n;
      Ddi_Varset_t *sm = Ddi_BddSupp(newCone);

      Ddi_VarsetDiffAcc(sm, psVars);
      doExist = (n = Ddi_VarsetNum(sm) > 0 && n <= 30);
      fullState = n == 0;
      Ddi_Free(sm);
    }

    if (0 && reached != NULL && care != NULL) {
      Ddi_Bdd_t *a = Ddi_BddOr(reached, care);

      /* IsOne is not correct */
      Pdtutil_Assert(Ddi_BddIsOne(a), "wrong reached-care");
      Ddi_Free(a);
    }

    /* new inductive check */
    if (1 && useInductionCone &&
      Ddi_BddSize(newCone) > Ddi_BddSize(inductionCone) / 10) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "pseudo-inductive cone: %d.\n",
          Ddi_BddSize(inductionCone))
        );
      sat = Ddi_AigSatWithAbort(inductionCone, (int)lazyTimeLimit);
      if (sat == 0) {
        /* fix point */
        doExist = 0;
        itpBmcBound = -1;
        fixPoint = 1;
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "PSEUDO-INDUCTIVE FIX POINT.\n")
          );
      }
      sat = 0;
    }

    if (doExist && (optLevel > 1 || optLevel > 0 && (i < 15 ||
          (existLevel > 1 && i < 6)))) {

      int size;

      if (tryBdd == 1 && !useTrBdd && maxFailBddBwd >= 0) {
        int size = Ddi_BddSize(newCone), size1;
        int sizeTh = size < 2000 ? 10000 : (size < 20000 ? size * 10 : 200000);
        Ddi_Bdd_t *bddSmooth = DdiAigExistProjectByBdd(newCone, care,
          sizeTh, psVars, -1.0, 0, 0);

        if (bddSmooth != NULL
          && ((size1 = Ddi_BddSize(bddSmooth)) < 1.5 * size)) {
          bddSuccess = 1;
          DdiGenericDataCopy((Ddi_Generic_t *) newCone,
            (Ddi_Generic_t *) bddSmooth);
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "BDD exist: %d -> %d.\n", size, size1)
            );
        } else if (bddSmooth == NULL) {
          maxFailBddBwd = -1;
        } else {
          maxFailBddBwd--;
        }
        Ddi_Free(bddSmooth);
      }

      if (!bddSuccess && !useTrBdd && Ddi_BddSize(newCone) < 10000) {
        /* @@@@@@@@@@@@@@@@@@@@@@@ */
        int doQuantify;
        Ddi_Varset_t *sm = Ddi_BddSupp(newCone);

        Ddi_VarsetDiffAcc(sm, psVars);
        if (!Ddi_VarsetIsVoid(sm)) {
          doQuantify = 1;
        }

        Ddi_Free(sm);

        if (doQuantify) {
          if (filterNew) {
            int j, k;
            Ddi_Bdd_t *partCone = Ddi_AigPartitionTop(newCone, 1);

            if (Ddi_BddPartNum(partCone) > 1) {
              int np = Ddi_BddPartNum(partCone);
              int *suppNum = Pdtutil_Alloc(int, np
              );
              int *sortedIds = Pdtutil_Alloc(int, np
              );
              Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm, 1);
              Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);

              for (j = 0; j < Ddi_BddPartNum(partCone); j++) {
                Ddi_Bdd_t *p_j = Ddi_BddPartRead(partCone, j);
                Ddi_Varset_t *sm = Ddi_BddSupp(p_j);

                Ddi_VarsetDiffAcc(sm, psVars);
                suppNum[j] = Ddi_VarsetNum(sm);
                Ddi_Free(sm);
                sortedIds[j] = j;
              }
              for (j = 0; j < np; j++) {
                for (k = j + 1; k < np; k++) {
                  int jj = sortedIds[j];
                  int kk = sortedIds[k];

                  if (suppNum[jj] > suppNum[kk]) {
                    int t = sortedIds[j];

                    sortedIds[j] = sortedIds[k];
                    sortedIds[k] = t;
                  }
                }
              }
              for (k = 0; k < np; k++) {
                Ddi_Bdd_t *p_j;

                j = sortedIds[k];
                p_j = Ddi_BddPartRead(partCone, j);
                if (suppNum[j] > 0 && suppNum[j] < 10) {
                  Ddi_AigExistProjectAcc(p_j, psVars, myCare, 3, 0,
                    lazyTimeLimit);
                  Ddi_Varset_t *sm = Ddi_BddSupp(p_j);

                  Ddi_VarsetDiffAcc(sm, psVars);
                  suppNum[j] = Ddi_VarsetNum(sm);
                  Ddi_Free(sm);
                }
                if (suppNum[j] == 0) {
                  Ddi_BddDiffAcc(myCare, p_j);
                  if (notReached == NULL) {
                    notReached = Ddi_BddMakeConstAig(ddm, 1);
                  }
                  Ddi_BddDiffAcc(notReached, p_j);
                  if (bckReached == NULL) {
                    bckReached = Ddi_BddDup(p_j);
                  } else {
                    Ddi_BddOrAcc(bckReached, p_j);
                  }
                  Ddi_BddPartWrite(partCone, j, myZero);
                }
              }
              Ddi_BddSetAig(partCone);
              Ddi_DataCopy(newCone, partCone);
              Ddi_Free(myCare);
              Ddi_Free(myZero);
              Pdtutil_Free(suppNum);
              Pdtutil_Free(sortedIds);
            }
            Ddi_Free(partCone);
          }
          Ddi_AigExistProjectAcc(newCone, psVars, notReached, 3, 0,
            lazyTimeLimit);
          if (bckReached != NULL) {
            //      Ddi_BddDiffAcc(care,bckReached);
            //          Ddi_BddOrAcc(newCone,bckReached);
            //      Ddi_Free(bckReached);
          }
        }
      }
      {
        Ddi_Varset_t *sm = Ddi_BddSupp(newCone);

        Ddi_VarsetDiffAcc(sm, psVars);
        if (!Ddi_VarsetIsVoid(sm) && (Ddi_VarsetNum(sm) <= (i < 4 ? 100 : 20))) {
          Ddi_AigExistProjectAcc(newCone, psVars, notReached, 1, 0,
            lazyTimeLimit);
          Ddi_Free(sm);
          sm = Ddi_BddSupp(newCone);
          Ddi_VarsetDiffAcc(sm, psVars);
        }
        if (Ddi_VarsetIsVoid(sm) || Ddi_VarsetNum(sm) == 0) {
          fullState = 1;
          nGoodDoExist++;
          if (i >= nextSaveCone && dynAbstr <= 3) {
            nextSaveCone += 1;
          }
          forceFixpointCheck = 1;
        } else if (1) {

          if (1) {

            Ddi_AigOptByConstrain(newCone, NULL, NULL, 2);
          } else {
            Ddi_Bdd_t *b1 = Ddi_AigPartitionTop(newCone, 1);
            int l;

            for (l = 0; l < Ddi_BddPartNum(b1); l++) {
              Ddi_Bdd_t *p = Ddi_BddPartRead(b1, l);
              Ddi_Bdd_t *p1 = DdiAigFuncDepAcc(p, NULL,
                itpMgr->psvars, NULL, NULL, NULL, NULL, NULL, NULL);

              Ddi_BddPartWrite(b1, l, p1);
              Ddi_Free(p1);
            }
            Ddi_BddSetAig(b1);
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "FUNC DEP QUANT of cone: %d -> %d.\n",
                Ddi_BddSize(newCone), Ddi_BddSize(b1))
              );
            Ddi_DataCopy(newCone, b1);
            Ddi_Free(b1);

          }
          if (Ddi_VarsetNum(sm) > 5 || Ddi_BddSize(newCone) > 20000) {
            nBadDoExist++;
            tryFixpointCheck = 1;
          }

        } else if (Ddi_VarsetNum(sm) > 5 || Ddi_BddSize(newCone) > 20000) {
          nBadDoExist++;
          tryFixpointCheck = 1;
        }
        simplifyCone = 1;
        Ddi_Free(sm);
      }
      if (optLevel > 1 && oldCone != NULL && !fullState) {  /* filter on num vars */
        Ddi_Bdd_t *myCare = NULL;   // Ddi_BddDiff(notReached,oldCone);

        Ddi_AigExistProjectAcc(newCone, psVars, myCare, 3, 0, lazyTimeLimit);
        Ddi_Free(myCare);
      }
      if (care != NULL) {
        //      Ddi_BddAndAcc(newCone,care);
      }
    } else if (0 && i < 6) {
      Ddi_AigOptByConstrain(newCone, NULL, NULL, 4);
      if (Ddi_BddSize(newCone) > 2000) {
        DdiAigFuncDepAcc(newCone, 0, 0, itpMgr->psvars, 0, 0, 0, 0, 0);
      }
      DdiAigRedRemovalControlAcc(newCone, care, -1, 30.0);
    }

    if (!doExist && nGoodDoExist >= 2 && optLevel > 0 &&
      Ddi_BddSize(care) < 20000 &&
      Ddi_BddSize(care) > Ddi_BddSize(newCone) / 2) {
      tryFixpointCheck = 1;
      nGoodDoExist--;
    }
    //    if (step==1) forceFixpointCheck=1;
    if (itpBmcBound == 1 && (tryFixpointCheck || forceFixpointCheck)) {
      itpBmcBound++;
    }

    if (0) {
      Ddi_Varset_t *sc = Ddi_BddSupp(care);

      if (!Ddi_VarsetIsVoid(sc)) {
        Ddi_VarsetIntersectAcc(sc, pivars);
        Pdtutil_Assert(Ddi_VarsetIsVoid(sc), "pis in care");
      }
    }

    if (1 && constrainOpt) {
      Ddi_Bdd_t *r = Ddi_BddNot(care);

      //      Ddi_AigConstrainOptAcc(newCone,care,NULL,NULL,NULL,0);
      //      Ddi_BddOrAcc(newCone,r);
      //      Ddi_BddAndAcc(newCone,care);
      //      DdiAigRedRemovalAcc (newCone,NULL,-1,2*lazyTimeLimit);
      DdiAigRedRemovalAcc(newCone, care, -1, 2 * lazyTimeLimit);
      Ddi_Free(fullCone);
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "fc.\n")
        );
      fullCone = Ddi_BddOr(newCone, r);
      if (newConeAux != NULL) {
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "fca.\n")
          );
        Ddi_Free(fullConeAux);
        fullConeAux = Ddi_BddOr(newConeAux, r);
      }
      Ddi_Free(r);
    } else if (!useSingleCone && (fullState) && (itpMgr->specSpace != NULL ||
        1 && !stallEnable && computeFullCone)) {
      if (0 || !fullState) {
        Ddi_BddOrAcc(fullCone, newCone);
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "fcn.\n")
          );
        if (newConeAux != NULL) {
          Ddi_BddOrAcc(fullConeAux, newConeAux);
        }
      }
      //        DdiAigRedRemovalAcc (fullCone,care,-1,30.0);
    } else {
      Ddi_Bdd_t *r = Ddi_BddNot(care);

      if (0 && (Ddi_BddSize(newCone) < 10000) && Ddi_BddSize(care) > 10) {
        Ddi_Bddarray_t *fA = Ddi_BddarrayAlloc(ddm, 1);

        Ddi_BddarrayWrite(fA, 0, newCone);
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "fcarr.\n")
          );
#if 0
        Ddi_BddarrayWrite(fA, 1, fullCone);
        DdiAigArrayRedRemovalControlAcc(fA, care, -1, 30.0);
        //      DdiAigRedRemovalControlAcc (optCone,care,-1,30.0);
        //      Ddi_BddNotAcc(care);
        //      Ddi_BddOrAcc(optCone,care);
        //      Ddi_BddNotAcc(care);
        if (1 || Ddi_BddSize(Ddi_BddarrayRead(fA, 0)) < Ddi_BddSize(newCone)) {
          Ddi_DataCopy(newCone, Ddi_BddarrayRead(fA, 0));
        }
        if (1 || Ddi_BddSize(Ddi_BddarrayRead(fA, 1)) < Ddi_BddSize(fullCone)) {
          Ddi_DataCopy(fullCone, Ddi_BddarrayRead(fA, 1));
        }
#else
        DdiAigArrayRedRemovalControlAcc(fA, care, -1, 30.0);
        if (1 || Ddi_BddSize(Ddi_BddarrayRead(fA, 0)) < Ddi_BddSize(newCone)) {
          Ddi_DataCopy(newCone, Ddi_BddarrayRead(fA, 0));
          simplifiedCone = 1;
        }
#endif
        Ddi_Free(fA);
        //      DdiAigRedRemovalControlAcc (fullCone,care,-1,30.0);
      }
      if (!fullState) {
        if (!useSingleCone) {
          Ddi_BddOrAcc(fullCone, newCone);
        } else {
          Ddi_Free(fullCone);
          fullCone = Ddi_BddDup(newCone);
        }
      }

      if (0 && invar != NULL) {
        Ddi_BddAndAcc(fullCone, invar);
      }
      //      Ddi_Free(fullCone);

      // fullCone = Ddi_BddDup(newCone);

      if (newConeAux != NULL) {
        Ddi_Free(fullConeAux);
        fullConeAux = Ddi_BddDup(newConeAux);
      }
      Ddi_Free(r);
    }

    if (simplifiedCone) {
      Ddi_BddNotAcc(care);
      Ddi_BddOrAcc(newCone, care);
      if (0 && newConeAux != NULL) {
        Ddi_BddOrAcc(newConeAux, care);
      }
      Ddi_BddNotAcc(care);
    }

    if (keepConeRings) {
      int j;

      for (j = 0; j < coneRingPeriod; j++) {
        Ddi_BddPartInsertLast(fullConeRings, fullCone);
      }
    }

    Pdtutil_VerbosityMgr(travMgr, Pdtutil_VerbLevelUsrMin_c,
      fprintf(tMgrO(travMgr), "Full Cone (Aux): %d(%d))\n",
        Ddi_BddSize(fullCone), fullConeAux ? Ddi_BddSize(fullConeAux) : 0)
      );

    if (0) {
      Ddi_Bddarray_t *benchArray;
      char filename[100];

      sprintf(filename, "cone%02d.bench", i);
      benchArray = Ddi_BddarrayAlloc(ddm, 0);
      Ddi_BddarrayInsertLast(benchArray, fullCone);
      Ddi_BddarrayInsertLast(benchArray, care);
      Ddi_AigarrayNetStore(benchArray, filename, NULL,
        Pdtutil_Aig2BenchLocalId_c);
      Ddi_Free(benchArray);
    }

    if (0 && itpMgr->specSpace != NULL) {
      /* da GpC per StQ: stats su cono !!! */
      Ddi_Bdd_t *partCone = Ddi_AigPartitionTop(fullCone, 1);
      int j, sizePeak = 0, sizeOver = 0, sizeTot = Ddi_BddSize(fullCone);

      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "PART CONE SIZE: %d -> ", sizeTot)
        );
      for (j = 0; j < Ddi_BddPartNum(partCone); j++) {
        Ddi_Bdd_t *p_j = Ddi_BddPartRead(partCone, j);
        int size_j = Ddi_BddSize(p_j);

        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "%d ", size_j)
          );
        sizeOver += size_j;
        if (size_j > sizePeak)
          sizePeak = size_j;
      }
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "(over: %f, peak: %f).\n",
          ((float)sizeOver) / sizeTot, ((float)sizePeak) / sizeTot)
        );
      Ddi_Free(partCone);
    }

    if (fixPoint <= 0)
      do {

        fixPoint = optLevel > 0 ? -1 : 0;
        if (itpBmcBound > 0 && !noItp)
          itpBmcBound--;
#if 0
        if (forceInterpolant >= 0) {
          itpBmcBound = forceInterpolant < i;
        } else if (forceInterpolant < -1) {
          itpBmcBound = 0;
        }
#endif

        if (!tryFixpointCheck && !forceFixpointCheck) {
          if (itpBmcBound == 1) {
            nDeferred = deferConeBuild;
            deferConeBuild = 0;
          } else {
            // deferConeBuild++;
            deferConeBuild = 0;
          }
        }

        if (1 && itpBmcBound == 0) {
          int abort1 = 0;
          Ddi_Bdd_t *itpCare = Ddi_BddDup(itpCareRef);

          //      Ddi_Bdd_t *itpCare = Ddi_BddDup(care);
          Ddi_Bdd_t *itpCone = fullCone;

          //doExist = 1;
          if (1 && fullConeAux != NULL &&
            Ddi_BddSize(fullConeAux) < 0.95 * Ddi_BddSize(fullCone)) {
            itpCone = fullConeAux;
          }
#if 0
          abort1 = 1;
#else

          if (bckReached != NULL) {
            Ddi_BddDiffAcc(itpCare, bckReached);
          }
          if (0 && fullState) {
            Ddi_BddDiffAcc(itpCare, newCone);
          }
          if (0 && itpMgr->itpOpt > 0) {
            careOut = Ddi_BddMakeConstAig(ddm, 1);
          }
          if (existOptPlus && Ddi_BddSize(itpCare) > 10) {
            //      int ibr = Ddi_MgrReadAigSatIncrByRefinement(ddm);
            // Ddi_MgrSetAigSatIncrByRefinement(ddm,2);
            int rrp = Ddi_MgrReadAigRedRemMaxCnt(ddm);

            //        Ddi_MgrSetOption(ddm,Pdt_DdiAigRedRemPeriod_c,inum,1);

            if (0 && useSingleCone) {
              Ddi_Free(fullCone);
              Ddi_BddAndAcc(newCone, itpCare);
              DdiAigRedRemovalAcc(newCone, itpCare, -1, 30.0);
              Ddi_BddNotAcc(itpCare);
              Ddi_BddOrAcc(newCone, itpCare);
              Ddi_BddNotAcc(itpCare);
              fullCone = itpCone = Ddi_BddDup(newCone);
            } else if (0) {
              DdiAigArrayRedRemovalControlAcc(delta, itpCare, -1, -1.0);
              DdiAigRedRemovalControlAcc(newCone, itpCare, -1, -1.0);
              DdiAigRedRemovalControlAcc(fullCone, itpCare, -1, -1.0);
              //        DdiAigArrayRedRemovalAcc (delta,itpCare,-1,-1.0);
            }

            Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, rrp);
            // Ddi_MgrSetAigSatIncrByRefinement(ddm,ibr);
          }

          itpCone = Ddi_BddDup(itpCone);
          if (useBoundkCone <= 1 && itpMgr->target != NULL) {
            Ddi_BddOrAcc(itpCone, itpMgr->target);
          }
          if (newConeConstraint != NULL) {
            Ddi_BddAndAcc(itpCone, newConeConstraint);
          }
          if (newConeConstraint2 != NULL) {
            Ddi_BddAndAcc(itpCone, newConeConstraint2);
          }

          if (keepConeRings) {
            Ddi_Free(itpCone);
            itpCone = Ddi_BddDup(fullConeRings);
          }

          if (itpRefineCex) {
            careOut = Ddi_BddMakeConstAig(ddm, 1);
          }

          firstFwdIter = -1;    // disable

	  int implAbstr = Trav_MgrReadImplAbstr(travMgr);
	  if (itpMgr->hints.hintsEnabled) {
	    Trav_MgrSetImplAbstr(travMgr,0);
	  }
          if (1 && (travMgr->settings.ints.itpBmcBoundFirst > 0)) {
            itpBmcBound = -1 -
              travMgr->settings.ints.itpBmcBoundFirst;
            travMgr->settings.ints.itpBmcBoundFirst = -1;
            abort1 = 0;
            itpAbstrRefCurrAbstrSetup(itpMgr,NULL, NULL);
          }
          else {
            itpBmcBound = checkFixPointByInterpolant(itpMgr, travMgr,
            fsmMgr, itpCone, previousCone /*inductionCone */ ,
            init, itpCare, careBdd, rOut, careOut,
            previousConeAuxLits, optLevel, &abort1, itpMgr->time_limit,
            i + 1, firstFwdIter, 0, itpMgr->timeFrames);
          }

	  if (itpMgr->hints.hintsEnabled) {
	    Trav_MgrSetImplAbstr(travMgr,implAbstr);
	    if (itpBmcBound>=0) {
	      itpBmcBound++;
              if (itpBmcBound==1)
                itpBmcBound++;
	      itpBmcBound *= -1;
	    }
	  }
          firstFwdIter = -1;    // disable for next calls

          if (careOut != NULL && !Ddi_BddIsOne(careOut)) {
            Ddi_BddOrAcc(newCone, careOut);
            Ddi_BddNotAcc(careOut);
            Ddi_BddAndAcc(care, careOut);
          }

          Ddi_Free(careOut);

          //      Ddi_Free(itpCone);
#endif

          if (abort1 == 3) {
            abort1 = 1;
            sat = 1;
          }
          if (abort1) {
            fixPoint = -1;
            itpBmcBound = -1;
          } else if (itpBmcBound >= 0) {
            fixPoint = 1;
          } else {
	    int maxIter = Trav_MgrReadIgrMaxIter(travMgr);
            disConeUnwind = 0;
	    if (0 && (step==0)) {
	      Trav_MgrSetIgrMaxIter(travMgr,1);
	    }
            if (enIgr) {
              if (forceInterpolant >= -itpBmcBound) {
                itpBmcBound = -forceInterpolant;
              }
            }
            fixPoint = Trav_IgrTrav(travMgr, fsmMgr,
              itpMgr, itpCone, itpCare,
              rOut, careOut, i, 0, &itpBmcBound, &abort1, &sat);
	    Trav_MgrSetIgrMaxIter(travMgr,maxIter);

            if (0 && !fixPoint && !sat) {
              abort1 = 1;
              Ddi_Free(rOut);
              itpMgr->time_limit = util_cpu_time();
            }
            if (abort1 == 2) {
              abort1 = 0;
              Pdtutil_Assert(abstrRef, "abort requires abstr ref mode");
              disConeUnwind = 1;
              i--;
            }

            if (abort1 > 0) {
              fixPoint = -1;
              itpBmcBound = -1;
            } else if (noBoundOpt) {
              itpBmcBound = 1;
            } else if (0 && itpBmcBound > 2 && itpMgr->nRings > 2) {
              itpBmcBound = 2;
            } else if (!optForDeep &&
              itpBmcBound > 2 && itpBmcBound > i / 2) {
              if (i <= 4) {
                itpBmcBound = 1;
              } else if (i <= 8) {
                itpBmcBound = 2;
              } else {
                itpBmcBound = i / 5;
              }
            } else if (optForDeep && itpBmcBound > i) {
              itpBmcBound *= 0.8;
            }
	    if (itpMaxStepK > 0 && itpBmcBound > itpMaxStepK)  {
	      itpBmcBound = itpMaxStepK;
	    }

            if (itpBmcBound > 3 && optLevel > 0) {
              nextSaveCone = i + 1;
              savedConeWindow = 2;
            }
          }

          Ddi_Free(itpCare);
          Ddi_Free(itpCone);
        } else if (itpBmcBound < 0) {
          fixPoint = -1;
        } else {
          fixPoint = optLevel > 0 ? -1 : -2;
          fixPoint = -2;
          //      doExist = 0;
        }

        if (sat) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "BMC failure at bound %d.\n", i)
            );
          fixPoint = 0;
          res = 0;
          Ddi_Free(itpCareRef);
          Ddi_Free(care);
          Ddi_Free(rOut);
          break;
        }

        if (1 && fixPoint < -1 && !(forceFixpointCheck || tryFixpointCheck))
          fixPoint = 0;         // disable further checks;
        if (1 && fixPoint < 0) {
          Ddi_Bdd_t *myCone = Ddi_BddDup(newCone);

          if (chkFpWithInductionCone && useInductionCone
            && inductionCone != NULL) {
            Ddi_Free(myCone);
            myCone = Ddi_BddDup(inductionCone);
          }
          if (bckReached != NULL) {
            Ddi_BddOrAcc(myCone, bckReached);
          }
          if (newConeAux != NULL
            && Ddi_BddSize(newConeAux) < 10 * Ddi_BddSize(newCone)) {
            Ddi_DataCopy(myCone, newConeAux);
          }
          if (useTrBdd && fixPointBdd != -1) {
            fixPoint = fixPointBdd;
          } else {
            fixPoint = checkFixPoint(travMgr, fsmMgr, oldCone, myCone, care);
            //      if (fixPoint < 0) fixPoint = 0; // disable further checks;
          }
          Ddi_Free(myCone);
        }
        if (1 && fixPoint < 0) {
          /* aborted */
          int myAbort;

#if 0
#if 1
          fixPoint = -1;
#else
          itpBmcBound = checkFixPointByInterpolant(itpMgr,
            travMgr, fsmMgr, newCone, previousCone, init, care,
            NULL, NULL, optLevel, &myAbort, 0, 0, -1, 0, itpMgr->time_limit);
          if (itpBmcBound >= 0) {
            fixPoint = 1;
          } else {
            fixPoint = 0;
          }
#endif
#endif

          if (fixPoint < 0) {
            Ddi_Bdd_t *myCone = Ddi_BddDup(newCone);

            if (chkFpWithInductionCone && useInductionCone
              && inductionCone != NULL) {
              Ddi_Free(myCone);
              myCone = Ddi_BddDup(inductionCone);
            }
            if (bckReached != NULL) {
              Ddi_BddOrAcc(myCone, bckReached);
            }
            if (newConeAux != NULL &&
              Ddi_BddSize(newConeAux) < 10 * Ddi_BddSize(newCone)) {
              Ddi_DataCopy(myCone, newConeAux);
            }
            fixPoint = checkFixPoint2(travMgr, fsmMgr,
              oldCone, myCone, care, maxFP2Iter);
            Ddi_Free(myCone);
            if (fixPoint < 0) {
              fixPoint = 0;     // disable further checks;
              itpBmcBound++;
              if (maxFP2Iter < 10)
                maxFP2Iter++;
            }
          }
          if (0 && fixPoint <= 0) {
            Ddi_AigExistProjectAcc(newCone, psVars, care, 1, 0, 30.0);
            {
              int rrl = Ddi_MgrReadAigRedRemLevel(ddm);

              Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRem_c, inum, rrl + 1);
              DdiAigRedRemovalAcc(newCone, care, -1, 30.0);
              Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRem_c, inum, rrl);
            }
            doExist = 0;
          }
        }
      } while (fixPoint < 0);

    if (sat)
      break;

    if (fixPoint) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "BWD fix point at bound %d.\n", i)
        );
      travMgr->settings.ints.igrRingLast = itpMgr->lastRingId;
      if (1) {
        Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");

        if (0 && iv != NULL && itpConstrLevel > 1) {
          Ddi_Bdd_t *extraInvar = Ddi_BddMakeLiteralAig(iv, 1);

          Ddi_BddComposeAcc(extraInvar, itpMgr->ps, itpMgr->delta);
          if (Trav_MgrReadAssume(travMgr) == NULL) {
            Trav_MgrSetAssume(travMgr, extraInvar);
          } else {
            Ddi_BddAndAcc(Trav_MgrReadAssume(travMgr), extraInvar);
          }
          Ddi_Free(extraInvar);
        }
        if (lemmasInvar != NULL) {
          if (Trav_MgrReadAssume(travMgr) == NULL) {
            Trav_MgrSetAssume(travMgr, lemmasInvar);
          } else {
            Ddi_BddAndAcc(Trav_MgrReadAssume(travMgr), lemmasInvar);
          }

        }
        if (1) {
          int j;
          Ddi_Bddarray_t *rings = NULL;

          if ((Trav_MgrReadItpReuseRings(travMgr) == 2) && itpMgr->nRings > 0) {
            if (rOut != NULL) {
              Trav_MgrSetReached(travMgr, rOut);
            }
            Trav_MgrSetNewi(travMgr, itpMgr->fromRings);
          } else {
            if (rOut != NULL) {
              Trav_MgrSetReached(travMgr, rOut);
            }
            if ((Trav_MgrReadItpReuseRings(travMgr) == 1)
              && itpMgr->nRings > 0) {
              Trav_MgrSetNewi(travMgr, itpMgr->fromRings);
            }
          }
          if (itpMgr->abstrRefRefinedVars != NULL) {
            Trav_MgrSetAbstrRefRefinedVars(travMgr,
              itpMgr->abstrRefRefinedVars);
          }
#if 1
          rings = Trav_MgrReadNewi(travMgr);
          if (rings != NULL &&
            itpMgr->eqRings != NULL && Ddi_BddarrayNum(itpMgr->eqRings) > 0) {
            int j;

            for (j = 0; j < Ddi_BddarrayNum(rings); j++) {
              if (j>=Ddi_BddarrayNum(itpMgr->eqRings)) break;
              Ddi_Bdd_t *eq = Ddi_BddarrayRead(itpMgr->eqRings, j);
              Ddi_Bdd_t *ring_j = Ddi_BddarrayRead(rings, j);

              if (eq != NULL && ring_j!=NULL) {
                Ddi_BddSetPartConj(ring_j);
                Pdtutil_Assert(Ddi_BddPartNum(ring_j) == 1,
                  "error in ring as part");
                Ddi_BddPartWrite(ring_j, 1, eq);
              }
            }
          }
#endif
        } else {
          char name[100];

          sprintf(name, "itpReachedOut%d.bench", getpid());
          Ddi_AigNetStore(rOut, name, NULL, Pdtutil_Aig2BenchLocalId_c);
        }
      }
      Ddi_Free(rOut);
      break;
    }
    else {
      if (itpMgr->abstrRefRefinedVars != NULL) {
	Trav_MgrSetAbstrRefRefinedVars(travMgr,
				       itpMgr->abstrRefRefinedVars);
      }
      if ((Trav_MgrReadItpReuseRings(travMgr) == 2) && itpMgr->nRings > 0) {
	Ddi_Bddarray_t *rings = NULL;
	Trav_MgrSetNewi(travMgr, itpMgr->fromRings);

	rings = Trav_MgrReadNewi(travMgr);
	if (rings != NULL &&
            itpMgr->eqRings != NULL && Ddi_BddarrayNum(itpMgr->eqRings) > 0) {
	  int j;

	  for (j = 0; j < Ddi_BddarrayNum(itpMgr->eqRings); j++) {
	    Ddi_Bdd_t *eq = Ddi_BddarrayRead(itpMgr->eqRings, j);
	    Ddi_Bdd_t *ring_j = Ddi_BddarrayRead(rings, j);

	    if (eq != NULL && ring_j!=NULL) {
	      Ddi_BddSetPartConj(ring_j);
	      Pdtutil_Assert(Ddi_BddPartNum(ring_j) == 1,
			     "error in ring as part");
	      Ddi_BddPartWrite(ring_j, 1, eq);
	    }
	  }
	}

      }
    }

    if (bckReached != NULL) {
      Ddi_BddDiffAcc(care, bckReached);
    }

    if (0 && doExist && optLevel > 1) {
      int size;

      DdiAigOptByBddRelation(newCone, 500, 50, NULL, 200.0);
      size = Ddi_BddSize(newCone);
      if (size * 2 > doExistThreshold)
        doExistThreshold = size * 2;
      // Ddi_AigExistProjectAcc(newCone,psVars,NULL,3,0,20.0);
    }
    if (doExist && (optLevel > 1 || optLevel > 0 && i <= 3)) {

      int size;

#if 0
      if (0 && notReached != NULL) {
        Ddi_Varset_t *pivars = Ddi_BddSupp(a);
        Ddi_Varset_t *sm = Ddi_BddSupp(newCone);

        Ddi_VarsetDiffAcc(pivars, sm);
        Ddi_VarsetDiffAcc(pivars, psVars);
        Ddi_AigExistAcc(a, pivars, NULL, 0, 0, -1.0);
        Ddi_Bdd_t *b = Ddi_BddDup(a);

        Ddi_BddXorAcc(b, newCone);
        Ddi_BddAndAcc(b, notReached);
        Pdtutil_Assert(!Ddi_AigSat(b), "WRONG EXIST WITH CARE");
        Ddi_Free(sm);
        Ddi_Free(pivars);
        sm = Ddi_BddSupp(notReached);
        Ddi_VarsetDiffAcc(sm, psVars);
        Pdtutil_Assert(Ddi_VarsetIsVoid(sm), "wrong subsetting");
      }
      Ddi_Free(a);
#endif

#if 1
      if (0 && !useTrBdd && !bddSuccess) {
        DdiAigRedRemovalAcc(newCone, notReached, -1, 30.0);
      }
      newReached = Ddi_BddDup(newCone);
#if 0
      if (newReached != NULL && rInterpolant != NULL) {
        Ddi_BddAndAcc(newReached, rInterpolant);
        Ddi_Free(rInterpolant);
      }
      if (rOut != NULL) {
        rInterpolant = Ddi_BddDup(rOut);
      }
#endif
      if (notReached == NULL) {
        notReached = Ddi_BddMakeConstAig(ddm, 1);
      }

      if (!useTrBdd && (!tryBdd || maxFailBddBwd < 0)
        && (optLevel > 1 || optLevel > 0 && i < 3)) {
        Ddi_Varset_t *sm = Ddi_BddSupp(newReached);
        Ddi_Bdd_t *check;
        Ddi_Bdd_t *cexAig;

        Ddi_VarsetDiffAcc(sm, psVars);
        if (0 && Ddi_VarsetNum(sm) > 0) {
          Ddi_AigExistAcc(newReached, sm, notReached, 2, 0, 30.0);
          Ddi_AigExistSubsetAcc(newReached, sm, notReached, NULL, -2, 40.0);
        }
        check = Ddi_BddAnd(newReached, notReached);
        cexAig = Ddi_AigSatWithCex(check);
        Ddi_Free(check);
        if (0 && Ddi_VarsetNum(sm) > 0) {
          Ddi_AigExistSubsetAcc(newReached, sm, notReached, cexAig, 1, 30.0);
        } else {
          DdiAigRedRemovalAcc(newReached, NULL, -1, 30.0);
        }
        Ddi_Free(cexAig);

        Ddi_Free(sm);

        check = Ddi_BddDiff(newCone, newReached);
        if (0 && constrainOpt && !Ddi_AigSat(check)) {
          Ddi_DataCopy(newCone, newReached);
        }
        Ddi_Free(check);
      }

      {
        Ddi_Varset_t *sm = Ddi_BddSupp(newReached);

        Ddi_VarsetDiffAcc(sm, psVars);
        if (Ddi_VarsetIsVoid(sm) && Ddi_BddSize(newReached) > 0) {
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "AIG SUBSET - refine CARE %d+%d=",
              Ddi_BddSize(care), Ddi_BddSize(newReached))
            );
          Ddi_BddDiffAcc(care, newReached);
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "%d.\n", Ddi_BddSize(care))
            );
        }
        Ddi_Free(sm);
      }

      Ddi_Free(newReached);
#endif
      //      Ddi_AigExistProjectAcc(newCone,psVars,care,0,0);

      size = Ddi_BddSize(newCone);
      if (size * 2 > doExistThreshold)
        doExistThreshold = size * 2;
    }

    if (i == 0 && optLevel > 1) {
      Ddi_BddAndAcc(care, myInvarspec);
    }

    newReached = Ddi_BddNot(care);
    Ddi_BddDiffAcc(newReached, reached);

    //    if (!stallEnable) {
    //      DdiAigRedRemovalAcc (newConeRed,care,-1,60.0);
    //      Ddi_BddOrAcc(newCone,newReached);
    //      Ddi_BddOrAcc(newCone,reached);
    //
    //    }
    if (0 && (optLevel > 1 || stallEnable)) {
      Ddi_BddDiffAcc(newCone, reached);
    }
    Ddi_BddOrAcc(reached, newReached);
    Ddi_Free(newReached);
    Ddi_Free(notReached);       /*@@@@ */
    notReached = Ddi_BddNot(reached);

    //    Pdtutil_Assert(Ddi_BddIncluded(care,notReached),"wrong care");

    //      DdiAigRedRemovalAcc (newConeRed,care,-1);

    //    Ddi_BddDiffAcc(care,newCone);

    if (useInnerCone && savedConeIter > 0 &&
      i == (savedConeIter + savedConeWindow)) {
      if (saveCone != NULL) {
        Ddi_Free(previousCone);
        previousCone = Ddi_BddDup(saveCone);
        if (saveConeAuxLits != NULL) {
          Ddi_Free(previousConeAuxLits);
          previousConeAuxLits = Ddi_BddarrayDup(saveConeAuxLits);
        }
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "Using auxiliary cone at depth %d.\n",
            nextSaveCone / 2)
          );
      }
    }
    if (useInnerCone && i == nextSaveCone) {
      if (1 && newCone != NULL) {
        int j;
        Ddi_Bdd_t *auxVarsConstrain = Ddi_BddMakeConstAig(ddm, 1);
        Ddi_Varset_t *checkSupp = Ddi_BddSupp(newCone);

        savedConeIter = i;
        savedConeWindow = i / 4;
        if (savedConeWindow < 2)
          savedConeWindow = 2;
        Ddi_Free(saveCone);
        saveCone = Ddi_BddDup(fullCone);
        if (useExtraCheck) {
          Ddi_Free(saveConeAuxLits);
          saveConeAuxLits = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(itpMgr->ps));
          for (j = 0; j < Ddi_VararrayNum(itpMgr->ps); j++) {
            Ddi_Bdd_t *lit, *constr;
            char name[1000];
            Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->ps, j);
            Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);

            sprintf(name, "previousConeAux_%d_%s", i, Ddi_VarName(v));
            Ddi_VarAttachName(newv, name);
            lit = Ddi_BddMakeLiteralAig(newv, 1);
            Ddi_BddarrayWrite(saveConeAuxLits, j, lit);
            if (Ddi_VarInVarset(checkSupp, v)) {
              constr = Ddi_BddMakeLiteralAig(v, 1);
              Ddi_BddXnorAcc(constr, lit);
              Ddi_BddAndAcc(auxVarsConstrain, constr);
              Ddi_Free(constr);
            }
            Ddi_Free(lit);
          }
          Ddi_BddAndAcc(newCone, auxVarsConstrain);
        }
        Ddi_Free(checkSupp);
        Ddi_Free(auxVarsConstrain);
      }
      if (nextSaveCone < 4)
        nextSaveCone *= 2;
      else
        nextSaveCone *= 2;
    }
    Ddi_Free(oldCone);
    oldCone = Ddi_BddDup(fullCone);

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "\n")
      );
    itpMgr->useAigVars = 1 && !( /*tryBdd || */ useTrBdd);

    if (!disConeUnwind) {
      int j, nCoi = 0;

      //Ddi_Bddarray_t *delta_i;
      Ddi_Bdd_t *diff_i;        //, *invarspec_i;

      nCoi =
        timeFrameFindOrAdd(itpMgr->timeFrames, itpMgr->pi, itpMgr->ps, itpMgr->ns, psVars, i,
        enableLoopFree, itpMgr->useAigVars);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c, coiNum = nCoi;   //printf("{COI:%d} ", nCoi)
        );

      //      Ddi_BddAndAcc(unroll,tr_i);

      if (newConeAux2 != NULL &&
        (optLevel < 2 || Ddi_BddSize(newConeAux2) < Ddi_BddSize(newCone))) {
        Ddi_Free(newCone);
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "ncaux2.\n")
          );
        newCone = newConeAux2;
        newConeAux2 = NULL;
      }
      Ddi_Free(newConeAux2);

      if (useInvarFull && itpMgr->invarConstr != NULL) {
        Ddi_BddAndAcc(newCone, itpMgr->invarConstr);
      }
      if (deferredUnroll == NULL) {
        if (itpMgr->deltaAbstr != NULL) {
          deferredUnroll = Ddi_BddarrayDup(itpMgr->deltaAbstr);
        } else {
          deferredUnroll = Ddi_BddarrayDup(delta);
        }
      }
      if (deferConeBuild) {
        Ddi_Bddarray_t *newDefU = Ddi_BddarrayDup(delta);
        int k = deferConeBuild;

        Ddi_BddarrayComposeAcc(newDefU,
          itpMgr->timeFrames->PiVars[0], itpMgr->timeFrames->PiLits[k]);
        Ddi_BddarrayComposeAcc(newDefU, itpMgr->ps, deferredUnroll);
        Ddi_Free(deferredUnroll);
        deferredUnroll = newDefU;
      } else {
        if (nDeferred > 0) {
          timeFrameShiftKAcc(newCone, itpMgr->timeFrames->PiVars,
            itpMgr->timeFrames->PiLits, i + 2, nDeferred + 1);
        } else if (0) {
          timeFrameShiftKAcc(newCone, itpMgr->timeFrames->PiVars,
            itpMgr->timeFrames->PiLits, i + 2, i + 1);
        } else {
          timeFrameShiftAcc(newCone, itpMgr->timeFrames->PiVars,
            itpMgr->timeFrames->PiLits, i + 2);
        }
      }

      if (0 && newConeConstraint != NULL) {
        if (0 || newConeConstraint2 == NULL) {
          Ddi_Free(newConeConstraint2);
          newConeConstraint2 = Ddi_BddDup(newConeConstraint);
        }
        timeFrameShiftAcc(newConeConstraint2,
          itpMgr->timeFrames->PiVars, itpMgr->timeFrames->PiLits, i + 2);
      }
      if (newConeAux != NULL) {
        if (useInvarFull && itpMgr->invarConstr != NULL) {
          Ddi_BddAndAcc(newConeAux, itpMgr->invarConstr);
        }
        timeFrameShiftAcc(newConeAux, itpMgr->timeFrames->PiVars,
          itpMgr->timeFrames->PiLits, i + 2);
      }
      //      timeFrameShiftAcc(newConeRed,timeFramePiVars,timeFramePiLits,i+2);
      //      if (i>0)
      //        Ddi_BddAndAcc(newCone,myInvarspec);

      if (bckReached != NULL) {
        Ddi_BddOrAcc(newCone, bckReached);
        Ddi_Free(bckReached);
      }
#if 0
      if (constraintGuard != NULL) {
        Ddi_BddCofactorAcc(newCone, constraintGuard, 1);
      }
      if (constraintGuard2 != NULL) {
        Ddi_BddCofactorAcc(newCone, constraintGuard2, 1);
      }
#endif

      if (!deferConeBuild) {
        //        int mark = Ddi_BddReadMark(newCone);

        Ddi_BddComposeAcc(newCone, itpMgr->ps, deferredUnroll);

        //        Ddi_BddWriteMark (newCone, mark+1);
        if (newConeConstraint2 != NULL) {
          Ddi_BddComposeAcc(newConeConstraint2, itpMgr->ps, deferredUnroll);
        }
        if (travMgr->settings.aig.itpExactBoundDouble) {
          if (oldCone!=NULL) {
            Ddi_BddOrAcc(newCone,oldCone);
          }
        }
        Ddi_Free(deferredUnroll);
      }

      if (monotoneConeOpt && Ddi_BddSize(newCone) < 30000) {
        Ddi_Bdd_t *myCone = Ddi_BddDup(newCone);
        int mark = Ddi_BddReadMark(newCone);

        Ddi_AigExistProjectAcc(newCone, psVars, NULL, 3, 0, 60.0);
        if (0) {
          if (Ddi_BddSize(newCone) < Ddi_BddSize(myCone)) {
            Ddi_BddNotAcc(newCone);
            Ddi_AigOptByMonotoneCoreAcc(newCone, myCone, NULL, 0, -1.0);
            Ddi_BddNotAcc(newCone);
          } else {
            Ddi_BddNotAcc(myCone);
            Ddi_AigOptByMonotoneCoreAcc(myCone, newCone, NULL, 0, -1.0);
            Ddi_BddNotAcc(myCone);
            if (Ddi_BddSize(myCone) < Ddi_BddSize(newCone)) {
              Ddi_DataCopy(newCone, myCone);
            }
          }
        }
        Ddi_Free(myCone);
        Ddi_BddWriteMark(newCone, mark);
      }

      if (constrainConeOpt) {
        Ddi_Var_t *varProp = NULL;
        Ddi_Bdd_t *litProp = NULL;
        Ddi_Varset_t *vars = Ddi_VarsetMakeFromArray(itpMgr->ps);
        Ddi_Varset_t *pivars = Ddi_VarsetMakeFromArray(itpMgr->pi);

        Pdtutil_Assert(iProp >= 0, "iProp unassigned");
        varProp = Ddi_VararrayRead(itpMgr->ps, iProp);
        litProp = Ddi_BddMakeLiteralAig(varProp, 1);

        Ddi_VarsetUnionAcc(vars, pivars);
        //         Ddi_AigConstrainOptAcc(newCone,litProp,vars,NULL,NULL,1);
        Ddi_AigConstrainOptAcc(newCone, litProp, vars, pivars, NULL, 1);
        //      Ddi_AigConstrainOptAcc(newCone,litProp,NULL,NULL,NULL,3);
        Ddi_BddNotAcc(litProp);
        Ddi_BddOrAcc(newCone, litProp);

        Ddi_Free(vars);
        Ddi_Free(pivars);
        Ddi_Free(litProp);
      }
#if 0
      if (1 && constraintGuard != NULL) {
        static int noFilter = 0;
        int j;

        if (deltaConstraint == NULL) {
          for (j = 0; j < Ddi_VararrayNum(ps); j++) {
            if (Ddi_VararrayRead(ps, j) == constraintGuard) {
              break;
            }
          }
          Pdtutil_Assert(j < Ddi_VararrayNum(ps),
            "constraint guard not found");
          /* included in AND with invarspec */
          deltaConstraint = Ddi_BddDup(Ddi_BddarrayRead(delta, j));
        }
#if 1
        {
          Ddi_Bdd_t *constrDelta = deltaConstraint;
          Ddi_Bdd_t *cc = Ddi_BddCofactor(constrDelta, constraintGuard, 1);
          Ddi_Varset_t *ccSupp = Ddi_BddSupp(cc);
          Ddi_Bdd_t *fullConstr = Ddi_BddMakeConstAig(ddm, 1);

          if (Ddi_VarsetNum(ccSupp) == 1) {
            Ddi_Var_t *vC = Ddi_VarsetTop(ccSupp);
            int j;

            for (j = 0; j < Ddi_VararrayNum(ps); j++) {
              if (Ddi_VararrayRead(ps, j) == vC) {
                break;
              }
            }
            Pdtutil_Assert(j < Ddi_VararrayNum(ps),
              "constraint guard2 not found");
            constrDelta = Ddi_BddarrayRead(delta, j);
            constraintGuard2 = vC;
            Ddi_BddAndAcc(newCone, cc);
          }
          {
            Ddi_Bdd_t *constrLit = Ddi_BddMakeLiteralAig(constraintGuard, 1);

            Ddi_BddAndAcc(newCone, constrLit);
            Ddi_Free(constrLit);
          }
          if (0) {
            Ddi_BddAndAcc(newCone, constrDelta);
          } else {
            int again = 0;
            Ddi_Bdd_t *constrPart = Ddi_AigPartitionTop(constrDelta, 0);
            int np, np0 = Ddi_BddPartNum(constrPart);

            do {

              Ddi_Varset_t *pSupp = Ddi_BddSupp(newCone);
              int k;

              again = 0;
              for (k = Ddi_BddPartNum(constrPart) - 1; k >= 0; k--) {
                Ddi_Bdd_t *c_k = Ddi_BddPartRead(constrPart, k);
                Ddi_Varset_t *cSupp = Ddi_BddSupp(c_k);
                int forceCone = Ddi_BddSize(c_k) == 1;

                if (Ddi_VarsetIsArray(pSupp)) {
                  Ddi_VarsetSetArray(cSupp);
                }
                Ddi_VarsetIntersectAcc(cSupp, pSupp);
                if (noFilter || !Ddi_VarsetIsVoid(cSupp)) {
                  Ddi_BddAndAcc(fullConstr, c_k);
                  Ddi_BddPartRemove(constrPart, k);
                  again = 1;
                } else if (forceCone) {
                  Ddi_Bdd_t *newC = Ddi_BddCompose(c_k, ps, delta);

                  Ddi_BddAndAcc(deltaConstraint, newC);
                  Ddi_Free(newC);
                }
                Ddi_Free(cSupp);
              }
              Ddi_Free(pSupp);
            } while (1 && again);

            np = Ddi_BddPartNum(constrPart);
            if (np > 0) {
              Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                Pdtutil_VerbLevelNone_c,
                fprintf(tMgrO(travMgr),
                  "%d/%d constraints are filtered out.\n", np, np0)
                );
            }
            Ddi_Free(newConeConstraint);
            newConeConstraint = Ddi_BddMakeAig(constrPart);
            Ddi_Free(constrPart);
          }
          if (0) {
            Ddi_Varset_t *vars = Ddi_VarsetMakeFromArray(pi);
            Ddi_Varset_t *psvars = Ddi_VarsetMakeFromArray(ps);

            Ddi_VarsetUnionAcc(vars, psvars);
            Ddi_AigConstrainOptAcc(newCone, fullConstr, vars, NULL, NULL, 5);
            Ddi_Free(vars);
            Ddi_Free(psvars);
          }
          Ddi_BddAndAcc(newCone, fullConstr);
          if (itpBmcBound <= 1) {
            ddiAbcOptAcc(newCone, -1.0);
          }
          Ddi_Free(fullConstr);
          Ddi_Free(ccSupp);
          Ddi_Free(cc);
        }
#else
        Ddi_Bdd_t *constrLit = Ddi_BddMakeLiteralAig(constraintGuard, 1);

        Ddi_BddAndAcc(newCone, constrLit);
        Ddi_Free(constrLit);
#endif
      }
#endif

      if (newConeAux != NULL) {
        Ddi_BddComposeAcc(newConeAux, itpMgr->ps, itpMgr->delta);
        if (1 && Ddi_BddSize(newConeAux) > Ddi_BddSize(newCone)) {
          Ddi_DataCopy(newConeAux, newCone);
        }
      }


      if (itpMgr->inductiveRplus != NULL) {
        Ddi_Bdd_t *myConstr =
          Ddi_BddCompose(itpMgr->inductiveRplus, itpMgr->ns, psLit);
        Ddi_BddAndAcc(care, myConstr);
        Ddi_BddAndAcc(itpCareRef, myConstr);
        Ddi_Free(myConstr);
      }

      if (0) {
        int nv, nv1, j, size0 = Ddi_BddSize(newCone);
        Ddi_Vararray_t *vA;
        Ddi_Varset_t *psvars = Ddi_VarsetMakeFromArray(itpMgr->ps);
        Ddi_Varset_t *s = Ddi_BddSupp(newCone);

        Ddi_VarsetSetArray(s);
        Ddi_VarsetSetArray(psvars);
        Ddi_VarsetIntersectAcc(s, psvars);
        nv = nv1 = Ddi_VarsetNum(s);
        if (itpMgr->coreVars != NULL) {
          Ddi_VarsetDiffAcc(s, itpMgr->coreVars);
        }
        vA = Ddi_VararrayMakeFromVarset(s, 1);
        for (j = 0; j < Ddi_VararrayNum(vA); j++) {
          Ddi_Var_t *v = Ddi_VararrayRead(vA, j);
          Ddi_Bdd_t *cof0 = Ddi_BddCofactor(newCone, v, 0);
          Ddi_Bdd_t *cof1 = Ddi_BddCofactor(newCone, v, 1);
          Ddi_Bdd_t *dif = Ddi_BddXor(cof0, cof1);

          //      if (Ddi_BddEqual(cof0,cof1)) {
          if (Ddi_AigSatWithAbort(dif, 0.2) == 0) {
            Ddi_Free(newCone);
            newCone = Ddi_BddDup(cof0);
            nv1--;
            Ddi_VarsetRemoveAcc(s, v);
          }
          Ddi_Free(dif);
          Ddi_Free(cof0);
          Ddi_Free(cof1);
        }
        if (itpMgr->coreVars == NULL) {
          itpMgr->coreVars = Ddi_VarsetDup(s);
        } else {
          Ddi_VarsetUnionAcc(itpMgr->coreVars, s);
        }

        Ddi_Free(s);
        Ddi_Free(psvars);
        Ddi_Free(vA);
        if (nv > nv1) {
          printf("univ quant: simplified cone supp: %d -> %d\n", nv, nv1);
          printf("univ quant: simplified cone size: %d -> %d\n", size0,
            Ddi_BddSize(newCone));
        }
      }

      if (itpMgr->inductiveRplus != NULL) {
        Ddi_Bdd_t *myConstr =
          Ddi_BddCompose(itpMgr->inductiveRplus, itpMgr->ns, psLit);

        if (1) {
          int size0 = Ddi_BddSize(newCone);
          Ddi_Bdd_t *myCare = Ddi_BddDup(myConstr);
          Ddi_Bdd_t *eq =
            DdiAigEquivVarsAcc(myCare, NULL, NULL, itpMgr->psvars, newCone,
            NULL, NULL);

          Ddi_Free(myCare);
          if (eq != NULL) {
            printf("EQ simplifying cone: %d -> %d\n", size0,
              Ddi_BddSize(newCone));
          }
          Ddi_Free(eq);
        }

        Ddi_BddAndAcc(newCone, myConstr);
        Ddi_Free(myConstr);
      }

      if (itpMgr->specSpace != NULL && !stallEnable) {

        if (0) {
          Ddi_BddAndAcc(newCone, itpMgr->specSpace);
        } else if (!useSingleCone || stallEnable) {
          Ddi_AigConstrainCubeAcc(newCone, itpMgr->specSpace);
          if (newConeAux != NULL) {
            Ddi_AigConstrainCubeAcc(newConeAux, itpMgr->specSpace);
          }
        } else if (1) {
#if 0
          Ddi_Varset_t *vars = Ddi_VarsetMakeFromArray(ps);
          Ddi_Varset_t *pivars = Ddi_VarsetMakeFromArray(pi);

          Ddi_VarsetUnionAcc(vars, pivars);
          Ddi_AigConstrainOptAcc(newCone, itpMgr->specSpace, vars, NULL, NULL,
            5);
          Ddi_Free(vars);
          Ddi_Free(pivars);
#else
          if (0) {
            Ddi_BddAndAcc(newCone, itpMgr->specSpace);
          } else {
            Ddi_Var_t *propVar = Ddi_VararrayRead(itpMgr->ps, iProp);

            Ddi_BddCofactorAcc(newCone, propVar, 1);
          }
#endif

          if (enAigStructOpt &&
            (Ddi_AigFilterStructMonotone(newCone, psVars) > 0)) {
            //Ddi_AigFilterStructMonotone(newCone,psVars);
          }
          if (enAigOptPdt) {
            if (Ddi_BddSize(newCone) > 150000) {
              enAigOptPdt = 0;
            } else {
              int size0 = Ddi_BddSize(newCone);
              long myStartTime = util_cpu_time();

              Ddi_AigOptByFoCntTop(newCone, NULL, -1);
              if (optLevel >= 1 && abcOpt >= 3) {
                ddiAbcOptAcc(newCone, -1.0);
              }
              if (enAigOptPdt > 1) {
                Ddi_Bdd_t *coneEq = Ddi_BddDup(newCone);
                Ddi_Bdd_t *eq = DdiAigFindEquiv(coneEq, NULL, 20, 0, 30.0);

                if (eq != NULL) {
                  Ddi_BddSetAig(eq);
                  //                  Ddi_BddAndAcc(coneEq,eq);
                  if ((Ddi_BddSize(coneEq) < Ddi_BddSize(newCone))) {
                    Ddi_DataCopy(newCone, coneEq);
                  }
                }
                Ddi_Free(eq);
                Ddi_Free(coneEq);
              }
              if ((((float)(util_cpu_time() - myStartTime)) / 1000) >
                travMgr->settings.aig.lazyTimeLimit / 10) {
                enAigOptPdt = 0;
              }
              if (size0 > 40000
                && ((size0 - Ddi_BddSize(newCone)) < 0.005 * size0)) {
                enAigOptPdt = 0;
              }
            }
          }

          if (itpMgr->boundkOptPis != NULL) {
            Ddi_Var_t *newv, *newv2;
            char name[1000];
            char name2[1000];
            Ddi_Bdd_t *boundkCone1, *boundkCone0, *boundkConeTot,
              *boundkLit, *boundkLit2;

            sprintf(name, "PDTRAV_VAR_BOUNDK_OPT_%d",
              itpMgr->boundkOptNumVars);
            sprintf(name2, "PDTRAV_VAR2_BOUNDK_OPT_%d",
              itpMgr->boundkOptNumVars);
            itpMgr->boundkOptNumVars++;
            if (!itpMgr->useAigVars) {
              newv = Ddi_VarNew(ddm);
              newv2 = Ddi_VarNew(ddm);
              Ddi_VarAttachName(newv, name);
              Ddi_VarAttachName(newv2, name2);
            } else {
              newv = Ddi_VarNewBaig(ddm, name);
              newv2 = Ddi_VarNewBaig(ddm, name2);
            }
            Ddi_VararrayInsertLast(itpMgr->boundkOptPis, newv);
            Ddi_VararrayInsertLast(itpMgr->boundkOptPis, newv2);

            boundkLit = Ddi_BddMakeLiteralAig(newv, 1);
            boundkLit2 = Ddi_BddMakeLiteralAig(newv2, 1);

            boundkCone0 = Ddi_BddAnd(newCone, boundkLit2);
            boundkCone1 = Ddi_BddOr(boundkCone0, itpMgr->target);

            boundkConeTot = Ddi_BddIte(boundkLit, boundkCone1, boundkCone0);
            Ddi_DataCopy(newCone, boundkConeTot);
            Ddi_Free(boundkConeTot);
            Ddi_Free(boundkCone1);
            Ddi_Free(boundkCone0);
            Ddi_Free(boundkLit);
            Ddi_Free(boundkLit2);
          } else {
            if (!useBoundkCone) {
              Ddi_BddOrAcc(newCone, itpMgr->target);
            }
          }

        }

        fixPointBdd = 0;
        if (useTrBdd && trBdd != NULL && !itpExact) {
          Ddi_Bdd_t *toBck, *careNS = NULL;
          Ddi_Varset_t *toSupp;

          Pdtutil_Assert(coneBdd != NULL, "Bdd cone is NULL");

          Ddi_MgrSetExistClustThresh(ddm, imgAndExistTh);
          if (0 && care != NULL) {
            careNS = Ddi_BddMakeMono(care);
            Ddi_BddSwapVarsAcc(careNS, itpMgr->ps, itpMgr->ns);
          }

          toBck = Tr_ImgWithConstrain(trBdd, coneBdd, careNS);

          if (care != NULL) {
            Ddi_Free(careNS);
          }
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c,
            fprintf(tMgrO(travMgr), "TOBDD = %d - ", Ddi_BddSize(toBck))
            );
          Ddi_MgrSetExistClustThresh(ddm, -1);
          toSupp = Ddi_BddSupp(toBck);
          Ddi_VarsetDiffAcc(toSupp, psVars);
          if (Ddi_VarsetIsVoid(toSupp) &&
            Ddi_BddSize(toBck) < 100000 && Ddi_BddSize(care) < 500000) {
            Ddi_Free(coneBdd);
            coneBdd = toBck;
            Ddi_Free(newCone);
            if (careBdd != NULL) {
              {
                Ddi_BddSetMono(careBdd);
                Ddi_BddNotAcc(careBdd);
                fixPointBdd = Ddi_BddIncluded(coneBdd, careBdd);
                Ddi_BddNotAcc(careBdd);
              }
              Ddi_BddRestrictAcc(coneBdd, careBdd);
              Ddi_BddSetPartConj(careBdd);
              Ddi_BddNotAcc(coneBdd);
              Ddi_BddPartInsertLast(careBdd, coneBdd);
              Ddi_BddNotAcc(coneBdd);
              Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                Pdtutil_VerbLevelNone_c,
                fprintf(tMgrO(travMgr), "CONEBDD = %d - ",
                  Ddi_BddSize(coneBdd));
                fprintf(tMgrO(travMgr), "CAREBDD = %d - ",
                  Ddi_BddSize(careBdd))
                );
            } else
              fixPointBdd = -1;
            newCone = Ddi_BddMakeAig(coneBdd);
            Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
              Pdtutil_VerbLevelNone_c,
              fprintf(tMgrO(travMgr), "ncBdd.\n");
              fprintf(tMgrO(travMgr), "CONEAIG = %d.\n", Ddi_BddSize(newCone))
              );
            if (0) {
              Ddi_Bdd_t *r = Ddi_BddMakeMono(reached);

              Ddi_BddOrAcc(r, coneBdd);
              Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
                Pdtutil_VerbLevelNone_c,
                fprintf(tMgrO(travMgr), "#Reached States = %g.\n",
                  Ddi_BddCountMinterm(r, Ddi_VararrayNum(itpMgr->ps)))
                );
              Ddi_Free(r);
            }
          } else {
            useTrBdd = tryBdd = 0;
            Ddi_Free(toBck);
          }
          Ddi_Free(toSupp);

        }

      }

      if (0 && filterNew) {
        Ddi_Varset_t *psvars = Ddi_VarsetMakeFromArray(itpMgr->ps);

        Ddi_AigExistProjectAcc(newCone, psVars, 0, 3, 0, -1.0);
        Ddi_Free(psvars);
      }
      if (filterNew) {
        int j, removed = 0;
        Ddi_Bdd_t *partCone = Ddi_AigPartitionTop(newCone, 1);

        if (Ddi_BddPartNum(partCone) > 1) {
          for (j = Ddi_BddPartNum(partCone) - 1; j >= 0; j--) {
            Ddi_Bdd_t *p_j = Ddi_BddPartRead(partCone, j);

            if (!Ddi_AigSatAnd(p_j, care, NULL)) {
              Ddi_BddPartRemove(partCone, j);
              removed = 1;
            }
          }
          if (removed) {
            Ddi_BddSetAig(partCone);
            Ddi_DataCopy(newCone, partCone);
          }
        } else if (0) {
          Ddi_Bdd_t *pMax, *pMaxPart;
          int jMax = -1, size, np, npMax, sizeMax = 0;

          Ddi_Free(partCone);
          partCone = Ddi_AigPartitionTop(newCone, 0);
          if (Ddi_BddPartNum(partCone) > 1) {
            for (j = 0; j < Ddi_BddPartNum(partCone); j++) {
              Ddi_Bdd_t *p_j = Ddi_BddPartRead(partCone, j);

              size = Ddi_BddSize(p_j);
              if (size <= 10)
                continue;
              pMaxPart = Ddi_AigPartitionTop(p_j, 1);
              if (Ddi_BddPartNum(pMaxPart) > 2)
                if (jMax < 0 || np > npMax) {
                  jMax = j;
                  sizeMax = size;
                  npMax = np;
                }
            }
            if (jMax >= 0) {
              pMax = Ddi_BddPartExtract(partCone, jMax);
              pMaxPart = Ddi_AigPartitionTop(pMax, 1);
              Ddi_BddSetAig(partCone);
#if 0
              for (j = 0; j < Ddi_BddPartNum(pMaxPart); j++) {
                Ddi_Bdd_t *p_j = Ddi_BddPartRead(pMaxPart, j);

                Ddi_BddAndAcc(p_j, partCone);
              }
              Ddi_BddSetAig(pMaxPart);
              Ddi_DataCopy(newCone, pMaxPart);
#else
              Ddi_BddAndAcc(partCone, Ddi_BddPartRead(pMaxPart, 0));
              Ddi_BddSetAig(partCone);
              Ddi_DataCopy(newCone, partCone);
#endif
              Ddi_Free(pMaxPart);
              Ddi_Free(pMax);
            }
          }
        }
        Ddi_Free(partCone);
      }
      //      Ddi_BddComposeAcc(newConeRed,ps,delta);
      //      Ddi_BddAndAcc(newConeRed,myInvarspec);

      //      DdiAigRedRemovalAcc (newCone,care,-1,30.0);

      size1 = Ddi_BddSize(newCone);
      sizeIncrease =
        size0 == 0 ? 1.5 : size0 < 0 ? 1.0 : ((float)size1) / size0;
      size0 = size1;
      // Overapprox !
      //      if (Ddi_BddSize(newCone) > 100) {
      //        Ddi_AigExistAcc(newCone,psVars,care,1,2);
      //      }

      //      Ddi_AigExistProjectAcc(newCone,psVars,care,1,0);
      if (0) {
        Ddi_Varset_t *supp = Ddi_BddSupp(newCone);

        Ddi_VarsetDiffAcc(supp, psVars);
        DdiAigExistOverAcc(newCone, supp, care);
        Ddi_Free(supp);
      }
      //      DdiAigTernaryReductionAcc (newCone,NULL,psVars,care);

      if (0 && (simplifyCone || sizeIncrease > 1.5) && !bddSuccess) {
        DdiAigRedRemovalAcc(newCone, care, -1, lazyTimeLimit);
      }
      if (optLevel >= 1 && abcOpt > 3) {
        ddiAbcOptAcc(newCone, -1.0);
      }
      //      Ddi_AigExistProjectAcc(newConeRed,psVars,NULL,1,0);

      //      Ddi_Free(tr_i);

      if (useInductionCone) {
        if (inductionConeBase != NULL) {
          Ddi_Free(inductionCone);
          inductionCone = inductionConeBase;
        }
        timeFrameShiftAcc(inductionCone,
          itpMgr->timeFrames->PiVars, itpMgr->timeFrames->PiLits, i + 2);
        Ddi_BddComposeAcc(inductionCone, itpMgr->ps, itpMgr->delta);
        if (1 && itpMgr->specSpace != NULL) {
          Ddi_BddAndAcc(inductionCone, itpMgr->specSpace);
        }
        //Ddi_BddAndAcc(inductionCone,care);
        inductionConeBase = Ddi_BddDup(inductionCone);
        Ddi_BddAndAcc(inductionCone, care); /* @@@ */
        //      Ddi_BddDiffAcc(inductionCone,fullCone);
        if (Ddi_BddSize(inductionCone) > 500000) {
          Ddi_Free(inductionCone);
          Ddi_Free(inductionConeBase);
          useInductionCone = 0;
        }
      }

      if (enableLoopFree) {
        diff_i = Ddi_BddMakeConstAig(ddm, 1);
        for (j = 0; j <= i; j++) {
          Ddi_Bdd_t *diff_j = Ddi_BddMakeConstAig(ddm, 0);

          for (k = 0; k < Ddi_VararrayNum(itpMgr->ns); k++) {
            Ddi_Bdd_t *diff_k =
              Ddi_BddXor(Ddi_BddarrayRead(itpMgr->timeFrames->Lits[i + 1], k),
              Ddi_BddarrayRead(itpMgr->timeFrames->Lits[j], k));

            Ddi_BddOrAcc(diff_j, diff_k);
            Ddi_Free(diff_k);
          }
          Ddi_BddAndAcc(diff_i, diff_j);
          Ddi_Free(diff_j);
        }
        Ddi_BddAndAcc(loopFree, diff_i);
        Ddi_Free(diff_i);
      }
    }

    Ddi_Free(rOut);

  }

  Ddi_Free(deferredUnroll);
  Ddi_Free(newConeAux2);
  Ddi_Free(saveCone);
  Ddi_Free(previousCone);
  Ddi_Free(oldCone);
  Ddi_Free(newCone);
  Ddi_Free(inductionCone);
  Ddi_Free(inductionConeBase);
  Ddi_Free(fullCone);
  Ddi_Free(newConeRed);
  Ddi_Free(fullConeAux);
  Ddi_Free(fullConeRings);
  Ddi_Free(newConeAux);
  Ddi_Free(notReached);
  Ddi_Free(bckReached);

  if (!sat) {
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Lazy Pass at Depth %d.\n", i)
      );
  }
  //Trav_MgrSetAssertFlag (travMgr, !res);
  Trav_MgrSetAssertFlag(travMgr, sat);

  Trav_ItpMgrQuit(itpMgr);

  Tr_TrFree(trBdd);
  Tr_MgrQuit(trMgr);

  Ddi_Free(coneBdd);
  Ddi_Free(careBdd);
  Ddi_Free(bckReached);
  Ddi_Free(newConeConstraint);
  Ddi_Free(newConeConstraint2);
  Ddi_Free(deltaConstraint);

  Ddi_Free(rInterpolant);
  Ddi_Free(previousConeAuxLits);
  Ddi_Free(saveConeAuxLits);
  Ddi_Free(delta);
  Ddi_Free(reached);
  Ddi_Free(piLit);
  Ddi_Free(psLit);
  Ddi_Free(nsLit);
  Ddi_Free(tr);

  Ddi_Free(lemmasInvar);
  Ddi_Free(care);
  Ddi_Free(itpCareRef);

  Ddi_Free(psVars);
  Ddi_Free(myInvarspec);
  Ddi_Free(loopFree);
  Ddi_Free(unroll);
  Ddi_Free(partWindows);

  //Trav_MgrSetAssertFlag(travMgr, !res);
  return (res);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bdd_t *
Trav_DeepestRingCex(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * target,
  Ddi_Bdd_t * invarspec,
  Ddi_Bddarray_t * fromRings,
  int start_i,
  int genCubes,
  Ddi_Varset_t *hintVars,
  int *fullTarget,
  int doRunItp,
  int subsetByAntecedents
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(target);
  int j, minj = start_i;
  int start_i_saved = start_i;
  Ddi_Bdd_t *cex = NULL, *cexNew = NULL;
  Trav_ItpMgr_t *itpMgr = Trav_ItpMgrInit(travMgr, fsmMgr, NULL, invarspec, 0, 1);
  Ddi_Bdd_t *f_j0 = Ddi_BddarrayRead(fromRings, start_i);
  Ddi_Bddarray_t *piLit;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  int subsetByEnables = !subsetByAntecedents;

  Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");
  Ddi_Var_t *pvarNs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
  Ddi_Var_t *cvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
  Ddi_Var_t *cvarNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
  Ddi_Vararray_t *psAux =
      Ddi_VararrayMakeNewVars(itpMgr->ps,
                              "PDT_ITP_PS_AUX_", NULL, 1);
  Ddi_Vararray_t *piAux =
      Ddi_VararrayMakeNewVars(itpMgr->pi,
                              "PDT_ITP_PI_AUX_", NULL, 1);
  Ddi_Vararray_t *tAux =
      Ddi_VararrayMakeNewVars(itpMgr->pi,
                              "PDT_ITP_PI_TARGET_AUX_", NULL, 1);
  Ddi_Vararray_t *tAux2 =
      Ddi_VararrayMakeNewVars(itpMgr->pi,
                              "PDT_ITP_PI_TARGET_AUX2_", NULL, 1);

  if (fullTarget!=NULL) {
    *fullTarget = 0;
  }

  if (Ddi_BddIsPartConj(f_j0)) {
    f_j0 = Ddi_BddPartRead(f_j0, 0);
  }

  if (fromRings != NULL) {
    Ddi_Free(itpMgr->fromRings);
    itpMgr->fromRings = Ddi_BddarrayDup(fromRings);
    itpMgr->nRings = Ddi_BddarrayNum(itpMgr->fromRings);
  }

  piLit = Ddi_BddarrayMakeLiteralsAig(itpMgr->pi, 1);
  timeFrameInfoPush(itpMgr->timeFrames, itpMgr->psLit, itpMgr->ps, piLit,
    itpMgr->pi, NULL);

  Ddi_Free(piLit);
  Ddi_Vararray_t *nsSupp = Ddi_BddSuppVararray(target);

  Ddi_VararrayIntersectAcc(nsSupp, itpMgr->ns);
  int tryAgain = 0, maxExpand = hintVars==NULL?1:0, maxExpandToMin = hintVars==NULL?1:0;
  int useItp = 0;
  int nIter = useItp?10:1;
  Ddi_Bdd_t *targetDup = Ddi_BddDup(target); 
  Ddi_BddSubstVarsAcc(targetDup,itpMgr->pi,tAux);
  
#if 0
  Ddi_Bdd_t *prop = Ddi_BddNot(target);
  Ddi_BddSubstVarsAcc(prop,itpMgr->pi,tAux2);
  if (Ddi_AigSatAnd(targetDup,prop,NULL)) {
    Ddi_BddAndAcc(targetDup,prop);
  }
  Ddi_Free(prop);
#endif
  //  int useRewind = minj<(start_i-1);
  //  int useRewind = minj<(start_i) || start_i>16;
  int useRewind = 0;
  if (travMgr->settings.aig.igrGrowConeMaxK>=0 && 
      start_i>travMgr->settings.aig.igrGrowConeMaxK) {
    useRewind = 1;
  }
  //  if (start_i>15) useRewind = 1;
  if (!useRewind)
  do {
    int deeperFound = 0;
    for (j = start_i - 1; j >= 0 && j >= (minj-1); j--) {
      Ddi_Bdd_t *f_jj = Ddi_BddarrayRead(fromRings, j);
      if (f_jj==NULL) continue;
      //    Ddi_Bdd_t *myCone = Ddi_BddDup(f_j0);
      Ddi_Bdd_t *myCone;
      Ddi_Bdd_t *chk;

      if (!deeperFound && (j<start_i-3))
        break;

      myCone = growUnrollRelation(itpMgr, nsSupp, start_i - 1, j,
                                  itpMgr->delta, itpMgr->initStub,
                                  0, 0, 0, 0);


      if (Ddi_BddIsPartConj(f_jj)) {
        f_jj = Ddi_BddPartRead(f_jj, 0);
      }
      chk = Ddi_BddDup(f_jj);
      Ddi_BddSubstVarsAcc(chk, itpMgr->ns, itpMgr->ps);
      //    chk = Ddi_BddCofactor(f_jj,pvarNs,1);
      Ddi_BddAndAcc(chk, targetDup);
      Ddi_BddAndAcc(chk, myCone);

      Ddi_BddCofactorAcc(chk, pvarNs, 1);
      Ddi_BddCofactorAcc(chk, cvarNs, 1);

      int abort = 0;
      cexNew = Ddi_AigSatAndWithCexAndAbort(chk,
            NULL, NULL, NULL, 300, &abort);

      Ddi_Free(chk);
      if (cexNew != NULL) {
        deeperFound = 1;
        minj = j;
        Ddi_Free(cex);
        cex = cexNew;
      }
      Ddi_Free(myCone);
    }
    tryAgain = 0;
    if ((((start_i >= 10) && minj<start_i/2)||(start_i>=20))
      && maxExpand>0 &&
        fullTarget!=NULL) {
      minj = start_i;
      maxExpandToMin = 0;
      Ddi_Free(cex);
      cex = Ddi_BddDup(target);
      Ddi_Bdd_t *f_jj = Ddi_BddarrayRead(fromRings, start_i);
      if (Ddi_BddIsPartConj(f_jj)) {
        f_jj = Ddi_BddPartRead(f_jj, 0);
      }
      Ddi_BddAndAcc(cex,f_jj);
      *fullTarget = 1;
    }
    if (start_i >= 10 && minj<start_i/2 && maxExpand>0) {
#if 1
      start_i--;
      maxExpand--;
      minj=start_i;
      nIter /= 2; if (nIter<1) nIter = 1;
      maxExpandToMin=1;
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nDeepest ring - unwinding target fron %d to %d\n",
               start_i+1, start_i);
      }
#else
      Ddi_Bdd_t *prop = Ddi_BddNot(target);
      Ddi_BddSubstVarsAcc(prop,itpMgr->pi,tAux2);
      if (Ddi_AigSatAnd(targetDup,prop,NULL)) {
        Ddi_BddAndAcc(targetDup,prop);
      }
      Ddi_Free(prop);
#endif
    }
    if (minj==start_i && maxExpandToMin>0) {
      maxExpandToMin--;
      if (start_i > 10)
	genCubes=1;
      if (!genCubes) {
        tryAgain = 1;
        Ddi_BddComposeAcc(targetDup,itpMgr->ns,itpMgr->delta);
        Ddi_BddSubstVarsAcc(targetDup,itpMgr->ps,itpMgr->ns);
        Ddi_Vararray_t *targetPis = Ddi_BddSuppVararray(targetDup);
        Ddi_VararrayDiffAcc(targetPis,itpMgr->ns);
        Ddi_Vararray_t *t2Aux =
          Ddi_VararrayMakeNewVars(targetPis,
                              "PDT_ITP_TARGET_AUX_", NULL, 1);
        Ddi_BddSubstVarsAcc(targetDup,targetPis,t2Aux);
        Ddi_Free(t2Aux);
        Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
          printf("\nDeepest ring - increasing cone: %d\n",
                 Ddi_BddSize(targetDup));
        }
        Ddi_Free(targetPis);
      }
      else if (start_i < Ddi_BddarrayNum(fromRings)-1) {
        start_i++;  
        tryAgain = 1;
        Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
          printf("\nDeepest ring - moving to ring: %d\n",
                 start_i);
        }
      }
    }
  } while (tryAgain);
  
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nDeepest ring: %d -> %d\n", start_i, minj);
  }
  if (0 && minj==1 && start_i>2) {
    minj++;
  }
  useRewind = 0;
  if (minj < start_i && minj>=1) {
    static int save_start_i = -1;
    static int save_minj = -1;
    static int repeated = 0;
    if (minj==save_minj && start_i == save_start_i) {
      repeated++;
    }
    else {
      repeated = 0;
    }
    if (repeated > 1) {
      useRewind = 1;
    }
    save_start_i = start_i;
    save_minj = minj; 
  }
  if (useRewind && doRunItp) {
    static int enOddEven = 0;
    static int oddEven = 0;
    oddEven = oddEven? 0: 1;
    int nRings = Ddi_BddarrayNum(fromRings);
    if (enOddEven && oddEven)
      travMgr->settings.ints.itpBmcBoundFirst = nRings-1;
    else 
      travMgr->settings.ints.itpBmcBoundFirst = start_i_saved;
    travMgr->settings.ints.igrSingleRewind = 1;
    //    travMgr->settings.aig.abstrRef=0;
    Pdtutil_VerbosityLocalIf(verbosity,
                             Pdtutil_VerbLevelUsrMax_c) {
      printf("\nEnabling single loop rewind run from ring: %d\n",
             travMgr->settings.ints.itpBmcBoundFirst);
    }
    Ddi_Free(cex);
    cex = Ddi_BddDup(target);
  }
  else if (minj < start_i && minj>=1) {
    Pdtutil_Assert(minj>=1,"problem with ring index");

    Ddi_Bdd_t *f_minj = Ddi_BddarrayRead(fromRings, minj);
    Ddi_Bdd_t *f_minj1 = Ddi_BddarrayRead(fromRings, minj-1);
    Ddi_Bdd_t *myConeMin;
    Ddi_Bdd_t *care, *myTarget;
    Ddi_Bdd_t *f_jj = Ddi_BddarrayRead(fromRings, start_i);
    if (Ddi_BddIsPartConj(f_jj)) {
      f_jj = Ddi_BddPartRead(f_jj, 0);
    }
    if (Ddi_BddIsPartConj(f_minj)) {
      f_minj = Ddi_BddPartRead(f_minj, 0);
    }
    if (f_minj1 != NULL && Ddi_BddIsPartConj(f_minj1)) {
      f_minj1 = Ddi_BddPartRead(f_minj1, 0);
    }
    myConeMin = growUnrollRelation(itpMgr, nsSupp, start_i - 1, minj,
				itpMgr->delta, itpMgr->initStub, 0, 0, 0, 0);
    Ddi_BddSubstVarsAcc(myConeMin, itpMgr->pi, piAux);

    if (Ddi_BddIsPartConj(f_minj)) {
      f_minj = Ddi_BddPartRead(f_minj, 0);
    }

    care = Ddi_BddDup(f_minj);
    Ddi_BddSubstVarsAcc(care, itpMgr->ns, itpMgr->ps);
    Ddi_BddAndAcc(care, myConeMin);
    Ddi_BddAndAcc(care, f_jj);
    Ddi_BddCofactorAcc(care, pvarNs, 1);
    Ddi_BddCofactorAcc(care, cvarNs, 1);

    myTarget = Ddi_BddDup(targetDup);
    Ddi_BddCofactorAcc(myTarget, pvarNs, 1);
    Ddi_BddCofactorAcc(myTarget, cvarNs, 1);

    int chk=0;
    Ddi_Free(cex);
    Ddi_Varset_t *nv = Ddi_VarsetMakeFromArray(itpMgr->ns);
    int res;

    Ddi_Bdd_t *f_minj1Aux = NULL;
    Ddi_Bddarray_t *myDelta = Ddi_BddarraySubstVars(itpMgr->delta,
                                             itpMgr->ps,
                                             psAux);
    Ddi_BddSubstVarsAcc(myTarget,itpMgr->pi,tAux);
    Ddi_BddarraySubstVarsAcc(myDelta,itpMgr->pi,piAux);

    Ddi_Bdd_t *fromAndTr = Ddi_BddRelMakeFromArray(myDelta,
                                                   itpMgr->ps);
    if (f_minj1!=NULL) {
      f_minj1Aux = Ddi_BddSubstVars(f_minj1, itpMgr->ns,psAux);
    }
    else {
      if (itpMgr->initStub!=NULL) {
        f_minj1Aux = Ddi_BddRelMakeFromArray(itpMgr->initStub,
                                             psAux);
      }
      else {
        Ddi_BddSubstVars(itpMgr->init, itpMgr->ps,psAux);
      }
    }

    Ddi_BddPartInsertLast(fromAndTr,f_minj1Aux);
    Ddi_BddSetFlattened(fromAndTr);
    Ddi_Free(f_minj1Aux);
    Ddi_Free(myDelta);

    if (chk) {
      int sat = Ddi_AigSatAnd(fromAndTr,myConeMin,myTarget);
      Pdtutil_Assert(!sat,"unsat problem");
    }

    cex = Ddi_BddMakeConstAig(ddm, 0);
    Ddi_Varset_t *nvt = Ddi_BddSupp(myTarget);
    Ddi_VarsetIntersectAcc(nv,nvt);
    Ddi_Free(nvt);
    int i;
    for (i=0; i<nIter; i++) {
      int sat;
      Ddi_Bdd_t *cex_i=NULL;
      if (0 && genCubes) {
        cex_i = Ddi_AigExistProjectByGenClauses(myTarget,
            care, care, nv, genCubes /**doGen*/, 0, &res);
      }
      else {
        Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(myTarget,
            care, NULL, NULL, 100, NULL);
        if (cex != NULL) {
          cex_i = Ddi_BddDup(myTarget);
          if (hintVars!=NULL) {
            Pdtutil_VerbosityLocalIf(verbosity,
                                     Pdtutil_VerbLevelUsrMax_c) {
              printf("\nDeepest ring projecting cex on %d vars\n",
                     Ddi_VarsetNum(hintVars));
              nIter = 1;
            }
            Ddi_AigCubeExistProjectAcc(cex,hintVars);
            Ddi_AigAndCubeAcc(cex_i, cex);
          }
          if (subsetByEnables) {
            Ddi_Bddarray_t *enables = Ddi_FindAigIte(cex_i,-1);
            if (enables==NULL) {
              enables = Ddi_BddarrayAlloc(ddm, 0);
            }
            Ddi_Bddarray_t *xors = Ddi_AigFindXors(cex_i,NULL,0);
            if (xors!=NULL)
              Ddi_BddarrayAppend(enables,xors);
            Ddi_Free(xors);
            if (Ddi_BddarrayNum(enables)==0) {
              subsetByEnables = 0;
            }
            else {  
              Ddi_Bddarray_t *constEnables = Ddi_BddarrayDup(enables);
              Ddi_AigarrayConstrainCubeAcc(constEnables,cex);
              for (int i=0; i<Ddi_BddarrayNum(enables); i++) {
                Ddi_Bdd_t *ec_i = Ddi_BddarrayRead(constEnables,i);
                if (Ddi_BddIsZero(ec_i)) {
                  Ddi_Bdd_t *e_i = Ddi_BddarrayRead(enables,i);
                  Ddi_BddNotAcc(e_i);
                }
              }
              Ddi_Bdd_t *constr = Ddi_BddMakePartConjFromArray(enables);
              Ddi_BddSetAig(constr);
              Ddi_BddAndAcc(cex_i,constr);
              Ddi_AigStructRedRemAcc (cex_i,NULL);
              Ddi_Free(constr);
              Ddi_Free(constEnables);
            }
              Ddi_Free(enables);
          }
          if (subsetByEnables) {
          }
          else if (subsetByAntecedents) {
            Ddi_Free(cex_i);
            cex_i = subsByOrSelect(myTarget,cex,1000);
          }
          else {
            Ddi_Varset_t *sm = Ddi_VarsetMakeFromArray(itpMgr->ns);
            Ddi_AigCubeExistAcc(cex,sm);
            Ddi_Free(sm);
            Ddi_AigConstrainCubeAcc(cex_i, cex);
          }
          Ddi_Free(cex);
          if (cex_i)
            Ddi_BddSubstVarsAcc(cex_i,tAux,itpMgr->pi);
        }
      }
      if (cex_i==NULL) break;
      Ddi_BddOrAcc(cex,cex_i);
      if (!useItp) {
        Ddi_BddDiffAcc(care,cex_i);
      }
      else {
        Ddi_Bdd_t *cone1 = Ddi_BddAnd(cex_i,myConeMin);
        Ddi_Bdd_t *care_i = Ddi_AigSatAndWithInterpolant(
          fromAndTr, cone1,
          itpMgr->psvars, NULL, NULL, NULL, NULL, NULL,
          &sat, 0, 1, -1.0);
        if (care_i != NULL) {
          Ddi_AigOptByMonotoneCoreAcc(care_i,cone1,NULL,0,-1.0);
          Ddi_BddAndAcc(care,care_i);
        }
        Ddi_Free(care_i);
        Ddi_Free(cone1);
      }
      Ddi_Free(cex_i);
    }
    Ddi_Free(psAux);
    Ddi_Free(fromAndTr);
    Ddi_Free(nv);
    Ddi_Free(myConeMin);
    Ddi_Free(myTarget);
    Ddi_Free(care);

  }
  else {
    Pdtutil_Assert(minj==start_i,"problem with ring index");
    Ddi_Bdd_t *myTarget;
    Ddi_Bdd_t *f_minj = Ddi_BddarrayRead(fromRings, start_i);
    Ddi_Bdd_t *f_jj = Ddi_BddarrayRead(fromRings, start_i);
    Ddi_Varset_t *nv = Ddi_VarsetMakeFromArray(itpMgr->ns);
    if (Ddi_BddIsPartConj(f_jj)) {
      f_jj = Ddi_BddPartRead(f_jj, 0);
    }

    myTarget = Ddi_BddDup(targetDup);
    Ddi_BddCofactorAcc(myTarget, pvarNs, 1);
    Ddi_BddCofactorAcc(myTarget, cvarNs, 1);

    int chk=0;
    int res;

    Ddi_Free(cex);

    cex = Ddi_AigExistProjectByGenClauses(targetDup,
          f_jj, f_jj, nv, 10 /**doGen*/, 0, &res);

    Ddi_Free(nv);
    Ddi_Free(myTarget);
  }
  Ddi_Free(nsSupp);
  Ddi_Free(targetDup);
  Ddi_Free(piAux);
  Ddi_Free(psAux);
  Ddi_Free(tAux);
  Ddi_Free(tAux2);


  if (cex!=NULL && Ddi_BddIsZero(cex)) {
    int nRings = Ddi_BddarrayNum(fromRings);
    travMgr->settings.ints.itpBmcBoundFirst = start_i_saved;
    //    travMgr->settings.ints.itpBmcBoundFirst = nRings-1;
    travMgr->settings.ints.igrSingleRewind = 1;
    //    travMgr->settings.aig.abstrRef=0;
    Ddi_Free(cex);
    cex = Ddi_BddDup(target);
  }
  
  Trav_ItpMgrQuit(itpMgr);
  Ddi_Vararray_t *pi = Fsm_MgrReadVarI(fsmMgr);
  Ddi_Vararray_t *ns = Fsm_MgrReadVarNS(fsmMgr);
  Ddi_Vararray_t *cexSupp = Ddi_BddSuppVararray(cex);
  Ddi_VararrayDiffAcc(cexSupp,ns);
  Ddi_VararrayUnionAcc(pi,cexSupp);
  Ddi_Free(cexSupp);
  return cex;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
chkConeBmc(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  Ddi_Bdd_t * from,
  Ddi_Bddarray_t * fromRings,
  Ddi_Bddarray_t * initStub,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  int useRingConstr,
  int boundK,
  int split
)
{
  Ddi_Bdd_t *myCone = Ddi_BddDup(cone);
  Ddi_Bdd_t *f;
  int ret = 0;

  if (end_i > 0)
    initStub = NULL;

  if (initStub != NULL) {
    f = NULL;
  } else if (from != NULL) {
    f = Ddi_BddDup(from);
  } else {
    f = NULL;
  }

  if (split > 0) {
    Pdtutil_Assert(end_i + split <= start_i, "wrong split");
    end_i += split;
  }
  growConeBwd(itpMgr, myCone, start_i, end_i, delta,
	      initStub, useRingConstr, -1, boundK);
  if (split > 0) {
    Pdtutil_Assert(end_i + split <= start_i, "wrong split");
    start_i = end_i - 1;
    end_i -= split;
    growConeBwd(itpMgr, myCone, start_i, end_i, delta,
		initStub, useRingConstr, -1, boundK);
  }

  if (f == NULL) {
    ret = Ddi_AigSat(myCone);
  } else {
    ret = Ddi_AigSatAnd(f, myCone, NULL);
  }

  Ddi_Free(myCone);
  Ddi_Free(f);

  return ret;
}

/**Function*******************************************************************
  Synopsis    [Join previously split cone.]
  Description [Join previously split cone. unroll split is function of ps
  vars. cone is function of ns vars (and ps for part of the constrain.
  Subsetting is (conditionally) applied first. Then ns vars are composed
  with unrollSplit.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
coneJoinWithSubset(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  Ddi_Bddarray_t * unrollSplit,
  int subsetLevel
)
{
  int mark = Ddi_BddReadMark(cone);
  Ddi_Bdd_t *joinedCone;

  Pdtutil_Assert(subsetLevel <= 0, "subsetting not supported yet");
  joinedCone = Ddi_BddCompose(cone, itpMgr->ns, unrollSplit);
  Ddi_BddSubstVarsAcc(joinedCone, itpMgr->ps, itpMgr->ns);
  Ddi_BddWriteMark(joinedCone, mark);
  return joinedCone;
}

/**Function*******************************************************************
  Synopsis    [Join previously split cone.]
  Description [Join previously split cone. unroll split is function of ps
  vars. cone is function of ns vars (and ps for part of the constrain.
  Subsetting is (conditionally) applied first. Then ns vars are composed
  with unrollSplit.]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
splitAndSubsetCone(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  Ddi_Bddarray_t * delta,
  int start_i,
  int end_i,
  int split_i,
  int subsetLevel
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cone);
  Ddi_Bdd_t *coneUp = Ddi_BddDup(cone);
  Ddi_Bdd_t *care, *coneUpSubs, *specSpaceNs;
  int i, j, nFramesTot, nFramesCone, nFramesUnroll, timeMark;
  Ddi_Bddarray_t *unroll = NULL;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;

  Pdtutil_Assert(end_i > 0, "end_i > 0 required");

  nFramesTot = start_i - end_i + 1;
  nFramesCone = start_i - split_i + 1;
  nFramesUnroll = split_i - end_i;
  timeMark = Ddi_BddReadMark(coneUp);

  itpMgrFindOrAddTimeFrames(itpMgr,nFramesTot,timeMark+1,0);

  growConeBwdSplit(itpMgr, coneUp, start_i, split_i, -1, delta, NULL, 0, 1, 0,
       NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 1);
  specSpaceNs = Ddi_BddSubstVars(itpMgr->specSpace, ps, ns);
  Ddi_BddAndAcc(coneUp, specSpaceNs);

  unroll = Ddi_BddarraySubstVars(delta, ps, ns);
  if (Ddi_BddarrayNum(itpMgr->eqRings) > end_i) {
    Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, end_i);

    if (eqConstr != NULL) {
      Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
      Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

      Ddi_BddarrayComposeAcc(unroll, vars, subst);
    }
  }

  for (i = end_i + 1, j = 1; i < split_i; i++, j++) {
    Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(delta);
    Ddi_Bddarray_t *lA = itpMgr->timeFrames->PiLits[j];

    Ddi_BddarrayComposeAcc(myDelta, itpMgr->pi, lA);
    Ddi_BddarrayComposeAcc(myDelta, ps, unroll);
    Ddi_Free(unroll);
    unroll = myDelta;
  }

  Ddi_BddarraySubstVarsAcc(unroll, ns, ps);

  care = Ddi_BddRelMakeFromArray(unroll, ns);
  timeFrameShiftKAcc(care, itpMgr->timeFrames->PiVars,
    itpMgr->timeFrames->PiLits, nFramesTot + timeMark, nFramesCone + timeMark);

  if (Ddi_BddarrayNum(itpMgr->fromRings) > i) {
    Ddi_Bdd_t *currRing =
      Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, end_i));
    Ddi_BddSubstVarsAcc(currRing, ns, ps);
    Ddi_BddAndAcc(care, currRing);
    Ddi_Free(currRing);
  }

  coneUpSubs =
    Ddi_AigSatCore(coneUp, care, NULL, itpMgr->nsvars, 100, -1, 2, 1);
  Ddi_BddWriteMark(coneUpSubs, Ddi_BddReadMark(coneUp));

  printf("CONEUP: %d -> subs: %d\n",
    Ddi_BddSize(coneUp), Ddi_BddSize(coneUpSubs));

  //  Ddi_BddNotAcc(specSpaceNs);
  Ddi_BddAndAcc(coneUpSubs, specSpaceNs);
  if (subsetLevel > 0) {
    Ddi_BddNotAcc(specSpaceNs);
    Ddi_BddOrAcc(coneUpSubs, specSpaceNs);
  }

  Ddi_Free(specSpaceNs);
  Ddi_Free(unroll);
  Ddi_Free(care);
  Ddi_Free(coneUp);

  return (coneUpSubs);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
growUnrollRelation(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Vararray_t * nsSupp,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int andWithRingForced_i,
  int boundK,
  int initMark
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(nsSupp);
  int i, j, nFrames, timeMark;
  Ddi_Bddarray_t *unroll = NULL;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Ddi_Bddarray_t *constrA = Ddi_BddarrayAlloc(ddm, 0);
  Ddi_Bddarray_t *coneA = Ddi_BddarrayAlloc(ddm, 0);
  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bddarray_t *deltaNs = Ddi_BddarrayCompose(delta, ps, itpMgr->nsLit);
  Ddi_Bdd_t *specSpaceNs = NULL;
  int andWithRing_i = -1;
  int doRedRem = 0;
  Ddi_Bdd_t *ref = NULL;
  int chk = 0;
  int igrUseRings = itpMgr->igr.useRings;
  Ddi_Bddarray_t *filteredUnroll;
  Ddi_Bdd_t *cone;

  if (igrUseRings < 0) {
    igrUseRings *= -1;
    doRedRem = 1;
  }

  nFrames = start_i - end_i + 1;
  timeMark = 0;
  if (initMark>0) {
    timeMark = initMark;
  }

  itpMgrFindOrAddTimeFrames(itpMgr,nFrames,timeMark,0);

  if (itpMgr->igr.useRings > 0 && start_i - end_i > itpMgr->igr.useRings) {
    int i0 = (start_i + end_i) / 2;
    int i1 = i0 - (start_i - end_i) / 4;
    int ii;
    int sizeMin = -1, sizeCurr;
    if (andWithRingForced_i>0) {
      andWithRing_i = andWithRingForced_i;
    }
    else {
      Pdtutil_Assert(i0 <= start_i && i0 >= end_i, "wrong ring index");
      Pdtutil_Assert(i1 <= start_i && i1 >= end_i, "wrong ring index");
      for (ii = i0; ii >= i1; ii--) {
	if (Ddi_BddarrayNum(itpMgr->fromRings) > ii) {
	  sizeCurr = Ddi_BddSize(Ddi_BddarrayRead(itpMgr->fromRings, ii));
	  if (sizeMin < 0 || (sizeMin > sizeCurr)) {
	    sizeMin = sizeCurr;
	    andWithRing_i = ii;
	  }
	}
      }
    }
  }

  boundK = 0; // already handled in property

  unroll = Ddi_BddarrayDup(deltaNs);
  if (end_i == 0 && initStub != NULL) {
    Ddi_Free(unroll);
    unroll = Ddi_BddarrayDup(initStub);
    //    Ddi_BddarrayComposeAcc(unroll,ns,initStub);
  }

  Pdtutil_Assert(itpMgr->specSpace != NULL, "missing spec space");
  specSpaceNs = Ddi_BddCompose(itpMgr->specSpace, ps, itpMgr->nsLit);

  if ((end_i > 0) && boundK) {
    Ddi_BddarrayInsertLast(constrA, specSpaceNs);
    Ddi_BddNotAcc(specSpaceNs);
    Ddi_BddarrayInsertLast(coneA, specSpaceNs);
    Ddi_BddNotAcc(specSpaceNs);
  }

  if (useRingConstr > 0 && end_i > 0) {
    if (Ddi_BddarrayNum(itpMgr->eqRings) > end_i) {
      Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, end_i);

      if (eqConstr != NULL) {
        Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
        Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

        Ddi_BddarrayComposeAcc(unroll, vars, subst);
        Ddi_BddarrayComposeAcc(constrA, vars, subst);
        Ddi_BddarrayComposeAcc(coneA, vars, subst);
        if (useRingConstr > 0) {
          eqConstr = Ddi_BddMakeAig(eqConstr);
          Ddi_BddarrayInsertLast(constrA, eqConstr);
          Ddi_BddarrayInsertLast(coneA, myZero);
          Ddi_Free(eqConstr);
        }
      }
    }
  }

  vA = itpMgr->pi;

  for (i = end_i + 1, j = 1; i <= start_i; i++, j++) {
    Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(deltaNs);
    Ddi_Bdd_t *mySpecSpace = Ddi_BddDup(specSpaceNs);
    Ddi_Bdd_t *myRingConstr = NULL;

    lA = itpMgr->timeFrames->PiLits[j];
    Ddi_BddarrayComposeAcc(myDelta, vA, lA);

    if (itpMgr->igr.useRings && i > 0 && (andWithRing_i == i)) {
      Ddi_Bdd_t *currRing = Ddi_BddarrayRead(itpMgr->fromRings, i);
      int sizeRing = currRing == 0 ? 0 : Ddi_BddSize(currRing);
      int sizeUnroll = Ddi_BddarraySize(unroll);

      if (sizeRing < 10000 || sizeRing < sizeUnroll * 0.2 || 
	  andWithRingForced_i > 0) {
        myRingConstr = Ddi_BddDup(currRing);
      }
    }

    if (useRingConstr > 0 && i > 0) {
      if (Ddi_BddarrayNum(itpMgr->eqRings) > i) {
        Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i);

        if (eqConstr != NULL) {
          Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
          Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

          Ddi_BddarrayComposeAcc(myDelta, vars, subst);
          Ddi_BddComposeAcc(mySpecSpace, vars, subst);
          if (myRingConstr != NULL)
            Ddi_BddComposeAcc(myRingConstr, vars, subst);
          if (useRingConstr > 1) {
            eqConstr = Ddi_BddMakeAig(eqConstr);
            Ddi_BddComposeAcc(eqConstr, ns, unroll);
            Ddi_BddarrayInsertLast(constrA, eqConstr);
            Ddi_Free(eqConstr);
            Ddi_BddarrayInsertLast(coneA, myZero);
          }
        }
      }
    }

    if (myRingConstr != NULL) {
      if (doRedRem) {
        DdiAigArrayRedRemovalControlAcc(myDelta, myRingConstr, -1, 60.0);
      }
      Ddi_BddComposeAcc(myRingConstr, ns, unroll);
      Ddi_BddarrayInsertLast(constrA, myRingConstr);
      Ddi_BddarrayInsertLast(coneA, myZero);
      Ddi_Free(myRingConstr);
    }

    if (i > 0 && boundK) {
      Ddi_Bdd_t *myConstr = Ddi_BddDup(mySpecSpace);

      Ddi_BddComposeAcc(myConstr, ns, unroll);
      Ddi_BddarrayInsertLast(constrA, myConstr);
      if (boundK) {
        Ddi_BddNotAcc(myConstr);
        Ddi_BddarrayInsertLast(coneA, myConstr);
      } else {
        Ddi_BddarrayInsertLast(coneA, myZero);
      }
      Ddi_Free(myConstr);
    }
    Ddi_Free(mySpecSpace);

    Ddi_BddarrayComposeAcc(myDelta, ns, unroll);
    Ddi_Free(unroll);
    unroll = myDelta;

  }

  filteredUnroll = Ddi_BddarrayMakeLiteralsAig(nsSupp, 1);
  Ddi_Bdd_t *constrEq=NULL;
  if (useRingConstr > 0) {
    if (Ddi_BddarrayNum(itpMgr->eqRings) > start_i+1) {
      Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, start_i+1);

      if (eqConstr != NULL) {
        Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
        Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

        Ddi_BddarrayComposeAcc(filteredUnroll, vars, subst);
        constrEq = Ddi_BddMakeAig(eqConstr);
      }
    }
  }

  Ddi_BddarrayComposeAcc(filteredUnroll, ns, unroll);
  Ddi_BddarraySubstVarsAcc(filteredUnroll, ns, ps);

  cone = Ddi_BddRelMakeFromArray(filteredUnroll, nsSupp);
  Ddi_BddSetAig(cone);

  if (constrEq!=NULL) {
    Ddi_BddAndAcc(cone,constrEq);
  }
  Ddi_Free(constrEq);

  Ddi_Free(unroll);
  Ddi_Free(filteredUnroll);

  Pdtutil_Assert(Ddi_BddarrayNum(coneA) == Ddi_BddarrayNum(constrA),
    "wrong array size");
  for (i = Ddi_BddarrayNum(constrA) - 1; i >= 0; i--) {
    Ddi_Bdd_t *constr_i = Ddi_BddarrayRead(constrA, i);
    Ddi_Bdd_t *cone_i = Ddi_BddarrayRead(coneA, i);

    if (!Ddi_BddIsOne(constr_i)) {
      Ddi_BddAndAcc(cone, constr_i);
    }
    Pdtutil_Assert(Ddi_BddIsZero(cone_i),"no cone supported here");
  }

  Ddi_Free(deltaNs);
  Ddi_Free(specSpaceNs);

  Ddi_Free(coneA);
  Ddi_Free(constrA);
  Ddi_Free(myOne);
  Ddi_Free(myZero);

  if (timeMark>0) {
    timeFrameShiftKAcc(cone, itpMgr->timeFrames->PiVars,
       itpMgr->timeFrames->PiLits, timeMark + nFrames + 1, timeMark);
  }

  Ddi_BddWriteMark(cone, timeMark + nFrames);

  if (ref != NULL) {
    Pdtutil_Assert(Ddi_AigEqualSat(ref, cone), "wrong grow cone bwd");
    Ddi_Free(ref);
  }

  return cone;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
genComposedTr(
  Trav_ItpMgr_t * itpMgr,
  int nFrames,
  int timeShift,
  Ddi_Vararray_t *filterVars
)
{
  
  Ddi_Mgr_t *ddm = itpMgr->ddiMgr;
  int i;
  Ddi_Bddarray_t *unroll = NULL;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *pi = itpMgr->pi;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bdd_t *tr;
  
  if (timeShift<0) timeShift = 0;
  
  itpMgrFindOrAddTimeFrames(itpMgr,nFrames,timeShift,0);

  unroll = Ddi_BddarrayDup(itpMgr->delta);
  vA = itpMgr->timeFrames->PiVars[timeShift];
  Ddi_BddarraySubstVarsAcc(unroll,pi,vA);
  
  for (i = 1; i < nFrames; i++) {
    Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(itpMgr->delta);
    vA = itpMgr->timeFrames->PiVars[timeShift+i];
    Ddi_BddarraySubstVarsAcc(myDelta,pi,vA);

    Ddi_BddarrayComposeAcc(myDelta, ps, unroll);
    Ddi_Free(unroll);
    unroll = myDelta;
  }

  if (filterVars==NULL)
    tr = Ddi_BddRelMakeFromArray(unroll, ns);
  else {
    Ddi_VararrayWriteMark(filterVars, 1);
    Ddi_Vararray_t *vars = Ddi_VararrayAlloc(ddm, 0);
    Ddi_Bddarray_t *funcs = Ddi_BddarrayAlloc(ddm, 0);
    for (int i=0; i<Ddi_VararrayNum(ns); i++) {
      Ddi_Var_t *ns_i = Ddi_VararrayRead(ns,i);
      if (Ddi_VarReadMark(ns_i)!=0) {
        Ddi_VararrayInsertLast(vars,ns_i);
        Ddi_BddarrayInsertLast(funcs,Ddi_BddarrayRead(unroll,i));
      }
    }
    tr = Ddi_BddRelMakeFromArray(funcs, vars);
    Ddi_Free(funcs);
    Ddi_Free(vars);
    Ddi_VararrayWriteMark(filterVars, 0);
  }
  
  Ddi_Free(unroll);

  return tr;
}



/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpMgrApplyRingEq(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *f,
  Ddi_Bddarray_t *fA,
  Ddi_Vararray_t *suppVars,
  int i,
  int applyEqConstr
) 
{
  Ddi_Bdd_t *eqConstr = NULL;

  if (itpMgr->eqRings==NULL) return;
  if (Ddi_BddarrayNum(itpMgr->eqRings) <= i) return;

  eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i);
  if (eqConstr != NULL) {
    Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
    Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

    if (suppVars!=NULL) {
      vars = Ddi_VararraySubstVars(vars,itpMgr->ns,suppVars);
      subst = Ddi_BddarraySubstVars(subst,itpMgr->ns,suppVars);
    }
    if (f!=NULL) {
      Ddi_BddComposeAcc(f, vars, subst);
      if (applyEqConstr) {
	Ddi_Bdd_t *constr = Ddi_BddMakeAig(eqConstr);
	if (suppVars!=NULL) {
	  Ddi_BddSubstVars(constr,itpMgr->ns,suppVars);
	}
	Ddi_BddAndAcc(f,constr);
	Ddi_Free(constr);
      }
    }
    if (fA!=NULL) {
      Ddi_BddarrayComposeAcc(fA, vars, subst);
    }
    if (suppVars!=NULL) {
      Ddi_Free(vars);
      Ddi_Free(subst);
    }

  }
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpTravMgrConstrainWithSplitCex(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * kConeRings,
  int step
)
{
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;
  if (kConeRings==NULL) return;

  if (itpMgr->splitCex!=NULL) {
    Ddi_Mgr_t *ddm = Ddi_ReadMgr(itpMgr->splitCex);
    Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);

    int np = Ddi_BddPartNum(kConeRings);
    int iRing = (step >= np ? np - 1 : step);
    int nFrames = Ddi_BddPartNum(itpMgr->splitCex);
    int j = nFrames - (np-iRing) - 1;
    if (j>=0 && j<nFrames) {
      Ddi_Bdd_t *cex_i = Ddi_BddDup(Ddi_BddPartRead(itpMgr->splitCex,j));

      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
	printf("CONSTRAINING TR WITH SPLIT CEX %d/%d\n", j, nFrames);
      }

      Ddi_BddSubstVarsAcc(cex_i, itpMgr->pi, itpMgr->auxVarPis);
      Ddi_AigConstrainCubeAcc(itpTravMgr->from,cex_i);
      Ddi_Free(cex_i);
    }
  }
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpMgrGenSplitCex(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cex,
  int start_i,
  int end_i
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cex);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  int i, j, nFrames;
  Ddi_Vararray_t *vA;
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t *splitCex = Ddi_BddMakePartConjVoid(ddm);
  Ddi_Bdd_t *litCex = Ddi_AigPartitionTop(cex, 0);
  int chk = 1;

  Ddi_Free(itpMgr->splitCex);

  nFrames = start_i - end_i + 1;
  Pdtutil_Assert(itpMgr->timeFrames->Num>=nFrames,"missing time frames");
  vA = itpMgr->pi;

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nSPLITTING CEX of %d time frames\n", nFrames+1);
  }

  for (j=0; j<=nFrames; j++) {
    Ddi_Vararray_t *tfV_i = itpMgr->timeFrames->PiVars[j];
    Ddi_VararrayWriteMark(tfV_i, j+1);
  }

  for (i=0; i<=nFrames; i++) {
    Ddi_BddPartWrite(splitCex,i,myOne);
  }

  for (i=0; i<Ddi_BddPartNum(litCex); i++) {
    Ddi_Bdd_t *lit = Ddi_BddPartRead(litCex,i);
    Ddi_Var_t *v = Ddi_BddTopVar(lit);
    int part_id = Ddi_VarReadMark(v)-1;
    if (part_id<0) continue; // state var
    Pdtutil_Assert(part_id >= 0,"wrong frame id");
    Pdtutil_Assert(part_id <= nFrames,"wrong frame id");
    Ddi_BddAndAcc(Ddi_BddPartRead(splitCex,part_id),lit);
  }

  for (j=0; j<=nFrames; j++) {
    Ddi_Vararray_t *tfV_i = itpMgr->timeFrames->PiVars[j];
    Ddi_VararrayWriteMark(tfV_i, 0);
  }

  for (i=0; i<=nFrames; i++) {
    Ddi_Bdd_t *cex_i = Ddi_BddPartRead(splitCex,i);
    Ddi_Vararray_t *tfV_i = itpMgr->timeFrames->PiVars[i];
    if (chk) {
      Ddi_Vararray_t *s_i = Ddi_BddSuppVararray(cex_i);
      Ddi_VararrayDiffAcc(s_i,tfV_i);
      Pdtutil_Assert(Ddi_VararrayNum(s_i)==0,"wrong tf supp");
      Ddi_Free(s_i); 
    }
    Pdtutil_Assert(Ddi_VararrayNum(tfV_i) == Ddi_VararrayNum(vA),
		   "tf var arrays not aligned");
    Ddi_BddSubstVarsAcc(cex_i, tfV_i, vA);
  }

  itpMgr->splitCex = splitCex;
  Ddi_Free(litCex);
  Ddi_Free(myOne);
}


/**Function*******************************************************************
  Synopsis    []
  Description [Search best fowd ring to be used (complemented) as bwd ring constr]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
findBwdRingConstr(
  Trav_ItpMgr_t * itpMgr,
  int andWithRing_i,
  int *andWithBwdRing_iP,
  int end_i,
  int start_i
)
{
  int andWithBwdRing_i=-1;
  Ddi_Bdd_t *bwdRingConstr=NULL;
  int bwd_i = andWithRing_i-1;
  int safe_i = -1;
  while (bwd_i >= Ddi_BddarrayNum(itpMgr->fromRings)) bwd_i--;
  if (bwd_i>0) {
    Ddi_Bdd_t *f_i = Ddi_BddarrayRead(itpMgr->fromRings,bwd_i);
    safe_i = Trav_ItpMgrReadConeBoundOK(itpMgr,bwd_i);
    while (bwd_i>end_i-1 && (Ddi_BddIsOne(f_i)||safe_i<0)) {
      if (bwd_i < 1)
        break;
      bwd_i--;
      f_i = Ddi_BddarrayRead(itpMgr->fromRings,bwd_i);
      safe_i = Trav_ItpMgrReadConeBoundOK(itpMgr,bwd_i);
    }
    if (!Ddi_BddIsOne(f_i) && safe_i>0) {
      bwdRingConstr = Ddi_BddNot(f_i);
      andWithBwdRing_i = start_i - safe_i + 1;
    }
  }
  if (0) // disable as it re-uses same ring
  while (bwd_i > end_i-1 && (bwd_i > 1)) {
    bwd_i--;
    Ddi_Bdd_t *f_i = Ddi_BddarrayRead(itpMgr->fromRings,bwd_i);
    int safe_i1 = Trav_ItpMgrReadConeBoundOK(itpMgr,bwd_i);
    if (!Ddi_BddIsOne(f_i) && (safe_i1 > safe_i)) {
      Ddi_Free(bwdRingConstr);
      bwdRingConstr = Ddi_BddNot(f_i);
      andWithBwdRing_i = start_i - safe_i + 1;
      safe_i = safe_i1;
    }
  }
  if (andWithBwdRing_i > 0 && andWithBwdRing_i < andWithRing_i)
    andWithBwdRing_i = andWithRing_i;
  *andWithBwdRing_iP = andWithBwdRing_i;
  return bwdRingConstr;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
timeFrameConstr(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * c0,
  int tf0,
  int tf1
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(c0);
  Ddi_Bddarray_t *deltaNs, *unroll;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Ddi_Bdd_t *constr;
  int j;

  constr = Ddi_BddMakeConstAig(ddm, 1);
  deltaNs = Ddi_BddarrayDup(itpMgr->delta);
  Ddi_BddarraySubstVarsAcc(deltaNs, ps, ns);
  unroll = Ddi_BddarrayDup(deltaNs);
  vA = itpMgr->pi;

  for (j=1; j<=tf1; j++) {
    Ddi_Bdd_t *myConstr = Ddi_BddDup(c0);
    Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(deltaNs);
    lA = itpMgr->timeFrames->PiLits[j];
    Ddi_BddarrayComposeAcc(myDelta, vA, lA);
    if (j>=tf0) {
      Ddi_BddComposeAcc(myConstr, ns, unroll);
      Ddi_BddAndAcc(constr,myConstr);
    }
    Ddi_BddarrayComposeAcc(myDelta, ns, unroll);
    unroll = myDelta;
  }
  Ddi_Free(unroll);
  Ddi_Free(deltaNs);
  
  return constr;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
timeFrameConstrWithEnablingVars(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t *cA,
  int tf0,
  int tf1,
  int end_i,
  Ddi_Bddarray_t * initStub,
  Ddi_Vararray_t *enVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cA);
  Ddi_Bddarray_t *deltaNs, *unroll;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Ddi_Vararray_t *refEnVars;
  Ddi_Bdd_t *constr;
  Ddi_Bdd_t *cRef;
  int j, i, nconstr;

  Pdtutil_Assert(Ddi_VararrayNum(enVars)==0,"void var array needed");
  constr = Ddi_BddMakeConstAig(ddm, 1);
  deltaNs = Ddi_BddarrayDup(itpMgr->delta);
  Ddi_BddarraySubstVarsAcc(deltaNs, ps, ns);
  unroll = Ddi_BddarrayDup(deltaNs);
  vA = itpMgr->pi;
  nconstr = Ddi_BddarrayNum(cA);
  cRef = Ddi_BddMakePartConjVoid(ddm);
  refEnVars = Ddi_VararrayAlloc(ddm, 0);

  if (end_i == 0 && initStub != NULL) {
    Ddi_Free(unroll);
    unroll = Ddi_BddarrayDup(initStub);
  }
  
  for (j=0; j<nconstr; j++) {
    char name[100];
    Ddi_Var_t *env;
    sprintf(name,"_PDT_CONSTR_EN_%d", j);
    env = Ddi_VarFindOrAdd(ddm, name, 0);
    Ddi_VararrayInsertLast(refEnVars,env);
    Ddi_Bdd_t *constr_j = Ddi_BddMakeLiteralAig(env, 1);
    Ddi_Bdd_t *c_j = Ddi_BddarrayRead(cA,j);
    Ddi_Bdd_t *c_jNeg = Ddi_BddNot(c_j);
    Ddi_BddIteAcc(constr_j,c_j,c_jNeg);
    Ddi_BddPartInsertLast(cRef,constr_j);
    Ddi_Free(c_jNeg);
    Ddi_Free(constr_j);
  }
  Ddi_BddSubstVarsAcc(cRef,itpMgr->ps,itpMgr->ns);
  
  for (i = end_i + 1, j = 1; i <= tf1; i++, j++) {
    char varSuffix[10];
    sprintf(varSuffix,"%d",j);
    Ddi_Bdd_t *myConstr = Ddi_BddDup(cRef);
    Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(deltaNs);
    Ddi_Vararray_t *frameVars =
      Ddi_VararrayMakeNewAigVars(refEnVars, NULL, varSuffix);
    Ddi_BddSubstVarsAcc(myConstr,refEnVars,frameVars);
    Ddi_BddSetAig(myConstr);
    Ddi_VararrayAppend(enVars,frameVars);
    lA = itpMgr->timeFrames->PiLits[j];
    Ddi_BddarrayComposeAcc(myDelta, vA, lA);
    if (j>=tf0) {
      Ddi_BddComposeAcc(myConstr, vA, lA);
      Ddi_BddComposeAcc(myConstr, ns, unroll);
      Ddi_BddAndAcc(constr,myConstr);
    }
    Ddi_BddarrayComposeAcc(myDelta, ns, unroll);
    Ddi_Free(myConstr);
    Ddi_Free(unroll);
    unroll = myDelta;
    Ddi_Free(frameVars);
  }
  Ddi_Free(unroll);
  Ddi_Free(deltaNs);
  Ddi_Free(cRef);
  Ddi_Free(refEnVars);
  
  return constr;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
growConeBwdSplit(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  int split_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int boundK,
  int assumeBound,
  Ddi_Bddarray_t * unrollSplit,
  Ddi_Vararray_t * varsSplit,
  Ddi_Bdd_t * careSplit,
  Ddi_Bdd_t * constrSplit,
  Ddi_Bdd_t * coneSplit,
  Ddi_Bdd_t *customConstr,
  Ddi_Bddarray_t *observedGates,
  int *andWithRingP,
  int useSplitUnrollConstr,
  int useForImage
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cone);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  int i, j, nFrames, timeMark;
  Ddi_Bddarray_t *unroll = NULL;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Ddi_Bddarray_t *constrA = Ddi_BddarrayAlloc(ddm, 0);
  Ddi_Bddarray_t *coneA = Ddi_BddarrayAlloc(ddm, 0);
  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t *initConstr = NULL;
  Ddi_Bddarray_t *deltaNs = NULL;
  Ddi_Bddarray_t *deltaNs0 = NULL;
  Ddi_Bddarray_t *deltaNsUnrollSplit = NULL;
  Ddi_Bddarray_t *deltaNsNoImg = NULL;
  Ddi_Bdd_t *specSpaceNs = NULL, *targetNs, *invarConstrNs=NULL;
  int andWithRing_i = -1;
  int igrUseRingsStep = itpMgr->igr.useRingsStep;
  int andWithBwdRing_i = -1;
  int andWithBwdRing_i1 = -1;
  int andWithRingDone_i = -1;
  int doRedRem = 0;
  Ddi_Bdd_t *ref = NULL;
  int chk = 0, chkNnf = 1 && itpMgr->abstrRefNnf;
  int igrUseRings = itpMgr->igr.useRings;
  int initStubAsConstr = 0;
  Ddi_Var_t *vProp=NULL, *vConstr=NULL;
  Ddi_Bdd_t *bwdRingConstr = NULL;
  Ddi_Bdd_t *bwdRingConstr1 = NULL;
  int saveUnroll_i = 0;
  int andWithRingSizeMax = 100000;
  int useRingsMultiple = (start_i-end_i)>igrUseRings;
  int useBwdRings = itpMgr->igr.useBwdRings; // enable
  int useRingConstrAsCone = 0,
    enRingConstrAsCone = boundK && useBwdRings>0;
  Ddi_Bdd_t *itpTrAbstr = itpMgr->itpTrAbstr;
  Ddi_Bdd_t *itpTrAbstrConstr = NULL;
  int trConstrSize=0;
  Ddi_Bddarray_t *antecedentsNs = NULL;
  
  if (split_i >= 0 && varsSplit==NULL) {
    assert(unrollSplit!=NULL);
    saveUnroll_i = split_i;
    split_i = -1;
  }

  if (observedGates!=NULL && end_i>0) {
    Pdtutil_Assert(itpMgr->antecedents!=NULL,"missing antecedents");
    antecedentsNs = Ddi_BddarrayDup(itpMgr->antecedents);
    Ddi_BddarraySubstVarsAcc(antecedentsNs, ps, ns);
  }
  
  if (1&&(boundK==0)) {
    vProp = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
    vConstr = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    //    useRingConstr=0;
  }

  if (igrUseRings > 0 && (andWithRingP!=NULL && *andWithRingP>0)) {
    andWithRing_i = *andWithRingP;
  }

  //  printf("\nGROWCONE: %d-%d, RC: %d - bK: %d\n", start_i, end_i, useRingConstr, boundK);

  if (delta == NULL) {
    delta = itpMgr->delta;
    if (itpMgr->nnf.delta != NULL) {
      delta = itpMgr->nnf.delta;
      ps = itpMgr->nnf.ps2;
      ns = itpMgr->nnf.ns2;
      Pdtutil_Assert(!chkNnf
        || Ddi_AigarrayCheckMonotone(delta, ps), "not monotone");

    }
  }

  if (itpMgr->abstrRefNnf) {
    ps = itpMgr->nnf.ps2;
    ns = itpMgr->nnf.ns2;
  }

  timeMark = Ddi_BddReadMark(cone);

  deltaNs = Ddi_BddarrayDup(delta);
      
  if (customConstr!=NULL) {
    int iconstr = Ddi_BddarrayNum(deltaNs)-2;
    Ddi_Bdd_t *deltaConstr = Ddi_BddarrayRead(deltaNs,iconstr);
    Ddi_BddAndAcc(deltaConstr,customConstr);
  }

  if (0 && itpMgr->hints.hintsArray!=NULL) {
    int iprop = Ddi_BddarrayNum(deltaNs)-1;
    Ddi_Bdd_t *deltaProp = Ddi_BddarrayRead(delta,iprop);
    Ddi_AigConstrainByStructRedRemAcc (deltaProp, NULL, 
					   itpMgr->hints.hintsConstr);
  }
  Ddi_BddarraySubstVarsAcc(deltaNs, ps, ns);
  
  targetNs = Ddi_BddSubstVars(itpMgr->target, ps, ns);

  if (timeMark>0) {
    //    Ddi_DataCopy(targetNs,cone);
  }
  
  if (1 && vProp!=NULL) {
    int l, iProp=-1, nstate = Ddi_BddarrayNum(deltaNs);
    for (l = nstate-1; l>=0; l--) {
      Ddi_Var_t *v_i = Ddi_VararrayRead(ns, l);
      if (v_i == vProp) {
	iProp = l;
	break;
      }
    }
    if (iProp>=0) {
      Ddi_Bdd_t *deltaProp = Ddi_BddarrayRead(deltaNs,iProp);
      Ddi_BddCofactorAcc(deltaProp,vProp,1);
    }
  }
  deltaNsNoImg = Ddi_BddarrayDup(deltaNs);
  deltaNs0 = Ddi_BddarrayDup(deltaNs);
  if (split_i>=0 && vProp==NULL) { 
    vProp = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
    deltaNsUnrollSplit = Ddi_BddarrayDup(deltaNs);
    vProp = NULL;
    int l, iProp=-1, nstate = Ddi_BddarrayNum(deltaNs);
    for (l = nstate-1; l>=0; l--) {
      Ddi_Var_t *v_i = Ddi_VararrayRead(ns, l);
      if (v_i == vProp) {
	iProp = l;
	break;
      }
    }
    if (iProp>=0) {
      Ddi_Bdd_t *deltaProp = Ddi_BddarrayRead(deltaNsUnrollSplit,
                                              iProp);
      Ddi_BddCofactorAcc(deltaProp,vProp,1);
    }
  }
  
  if (0 && itpMgr->hints.hintsEnabled) {
    int iConstr0 = itpMgr->hints.invar0_i;
    int iConstr = itpMgr->hints.invar_i;
    int iProp = iConstr+1;
    Ddi_Bdd_t *deltaConstr0 = Ddi_BddDup(Ddi_BddarrayRead(deltaNs,iConstr0));
    Ddi_Bdd_t *deltaConstr = Ddi_BddDup(Ddi_BddarrayRead(deltaNs,iConstr));
    Ddi_Bdd_t *deltaProp = Ddi_BddDup(Ddi_BddarrayRead(deltaNs,iProp));
    Ddi_Bdd_t *hintsConstr = Ddi_BddDup(itpMgr->hints.hintsConstr);
    Ddi_Var_t *vProp = Ddi_VararrayRead(itpMgr->ps,iProp);
    //    Ddi_Bdd_t *negProp = Ddi_BddMakeLiteralAig(vProp, 0);
    //    Ddi_BddOrAcc(deltaConstr,negProp);
    //    Ddi_Free(negProp);
    Ddi_BddSubstVarsAcc(hintsConstr,ps,ns);
    if (itpMgr->hints.strategy != 3) {
      Ddi_AigarrayConstrainCubeAcc(deltaNs, hintsConstr);
    }
    else {
      deltaConstr = Ddi_BddDup(itpMgr->hints.saveConstr);
      Ddi_BddSubstVarsAcc(deltaConstr,ps,ns);
    }
    Ddi_Free(hintsConstr);
    if (1) {
      Ddi_Free(deltaConstr0);
      deltaConstr0 = Ddi_BddMakeConstAig(ddm, 1);
    }
    Ddi_BddarrayWrite(deltaNs,iConstr0,deltaConstr0);
    Ddi_BddarrayWrite(deltaNs,iConstr,deltaConstr);
    Ddi_BddarrayWrite(deltaNs,iProp,deltaProp);
    Ddi_Free(deltaConstr);
    Ddi_Free(deltaConstr0);
    Ddi_Free(deltaProp);
    if (useForImage) {
      Ddi_DataCopy(deltaNs0,deltaNs);
    }
  }

  if (0) {
    Ddi_Free(constrA);
    Ddi_Free(coneA);
    Ddi_Free(myZero);
    Ddi_Free(myOne);
    Ddi_Free(deltaNs);
    return
      growConeBwd0(itpMgr, cone,
      start_i, end_i, delta, initStub, useRingConstr, boundK);
  }

  if (chk) {
    ref = Ddi_BddDup(cone);
    growConeBwd0(itpMgr, ref, start_i, end_i, delta, initStub, useRingConstr,
      boundK);
  }

  boundK = 0; // already taken into account by not cofactoring delta

  if (useRingConstr && (itpMgr->abstrRefNnf || itpMgr->itpIncr)) {
    useRingConstr = 1;
  }
  //  if (useRingConstr) useRingConstr = 1;

  nFrames = start_i - end_i + 1;

  itpMgrFindOrAddTimeFrames(itpMgr,nFrames,timeMark,0);

  if ((useBwdRings && (nFrames >= useBwdRings)) ||
      igrUseRings > 0 && (start_i - end_i) > igrUseRings) {
    int step = useRingsMultiple ? (start_i - end_i) / 3:
      (start_i - end_i) / 2;
    if (step==0) step++;
    if (igrUseRingsStep>0) {
      if (igrUseRingsStep<step)
        step = igrUseRingsStep;
      igrUseRingsStep = step;
    }

    int i0 = end_i + step;
    int i1 = i0 - (i0 - end_i) / 4;
    int ii;
    int sizeMin = -1, sizeCurr;

    Pdtutil_Assert(i0 <= start_i && i0 >= end_i, "wrong ring index");
    Pdtutil_Assert(i1 <= start_i && i1 >= end_i, "wrong ring index");
    if (andWithRing_i<0) {
      int sizeI1, limit = (i0-end_i)/2;
      while (Ddi_BddarrayNum(itpMgr->fromRings) > i0) {
        sizeCurr = Ddi_BddSize(Ddi_BddarrayRead(itpMgr->fromRings, i0));
        sizeI1 = Ddi_BddSize(Ddi_BddarrayRead(itpMgr->fromRings, i1));
        if (sizeCurr>sizeI1/5 || i0==limit) break;
        i0--;
        i1 = i0 - (i0 - end_i) / 4;
      }
      for (ii = i0; ii >= i1; ii--) {
	if (Ddi_BddarrayNum(itpMgr->fromRings) > ii) {
	  sizeCurr = Ddi_BddSize(Ddi_BddarrayRead(itpMgr->fromRings, ii));
	  if (sizeMin < 0 || (sizeMin > sizeCurr)) {
	    sizeMin = sizeCurr;
	    andWithRing_i = ii;
	  }
	}
      }
    }
  }
  if (igrUseRings<=0) {
    andWithRing_i = -1;
  }
  if (andWithRing_i>0 && useBwdRings && 
      nFrames >= useBwdRings) {
    bwdRingConstr = findBwdRingConstr(itpMgr, andWithRing_i, &andWithBwdRing_i, end_i, start_i);
  }
  
  
  if (deltaNsUnrollSplit!=NULL)
    unroll = Ddi_BddarrayDup(deltaNsUnrollSplit);
  else 
    unroll = Ddi_BddarrayDup(deltaNs0);

  if (end_i == 0 && initStub != NULL) {
    Ddi_Free(unroll);
    if (initStubAsConstr) {
      initConstr = Ddi_BddRelMakeFromArray(initStub, ns);
      Ddi_BddSetAig(initConstr);
      unroll = Ddi_BddarrayMakeLiteralsAig(ns, 1);
    } else {
      unroll = Ddi_BddarrayDup(initStub);
    }
    //    Ddi_BddarrayComposeAcc(unroll,ns,initStub);
  }
  if (itpMgr->splitCex!=NULL) {
    int frameStart = 0 + (Ddi_BddPartNum(itpMgr->splitCex)-nFrames-1);

    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("USING SPLIT CEX of %d/%d time frames - start: %d\n", 
	     Ddi_BddPartNum(itpMgr->splitCex), nFrames, frameStart);
    }

    if (frameStart>=0) {
      Ddi_Bdd_t *cex_i = Ddi_BddPartRead(itpMgr->splitCex,frameStart);
      Ddi_AigarrayConstrainCubeAcc(unroll, cex_i);
    }
  }

  vA = itpMgr->pi;

  if (0 && (timeMark>0)) {
    lA = itpMgr->timeFrames->PiLits[timeMark];
    Ddi_BddarrayComposeAcc(unroll, vA, lA);
  }


  if (itpMgr->specSpace != NULL) {
    Ddi_Var_t *vConstr = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    specSpaceNs = Ddi_BddSubstVars(itpMgr->specSpace, ps, ns);
    if (vConstr!=NULL) {
      Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(vConstr, 1);
      Ddi_AigAndCubeAcc(specSpaceNs,lit);
      Ddi_Free(lit);
    }
  } else {
    specSpaceNs = Ddi_BddMakeConstAig(ddm, 1);
  }

  if (vConstr!=NULL) {
    invarConstrNs = Ddi_BddMakeLiteralAig(vConstr, 1);
    Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(vProp, 1);
    //    Ddi_BddAndAcc(invarConstrNs,lit);
    Ddi_Free(lit);
  }
  
  if (itpMgr->abstrRefNnf) {
    if (end_i == 0 && initStub != NULL) {
      Ddi_BddarrayNnfOutputSplitAcc(unroll);
    } else {
      Ddi_BddarrayAigFromNnfAcc(unroll, itpMgr->ns, NULL, 0);
    }
    Ddi_BddAigFromNnfAcc(specSpaceNs, itpMgr->ns);
    Ddi_BddAigFromNnfAcc(targetNs, itpMgr->ns);
  }
  // if (end_i>0) {
  //  if ((end_i>0) && (boundK==0 || boundK>1)) { // to avoid unsound cones
  if ((end_i>0) && (/*boundK==0 ||*/ boundK>=1)) { // to avoid unsound cones
  //  if ((end_i > 0) && (boundK)) {
    Ddi_BddarrayInsertLast(constrA, specSpaceNs);
    if (timeMark==0) 
      Ddi_BddarrayInsertLast(coneA, targetNs);
    else 
      Ddi_BddarrayInsertLast(coneA, myZero);
  }

  if (useRingConstr > 0 && end_i > 0) {
    if (Ddi_BddarrayNum(itpMgr->eqRings) > end_i) {
      Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, end_i);

      if (eqConstr != NULL) {
        Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
        Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

        Ddi_BddarrayComposeAcc(unroll, vars, subst);
        Ddi_BddarrayComposeAcc(constrA, vars, subst);
        Ddi_BddarrayComposeAcc(coneA, vars, subst);
        if (useRingConstr > 0) {
          eqConstr = Ddi_BddMakeAig(eqConstr);
	  if (vProp!=NULL) {
	    Ddi_BddCofactorAcc(eqConstr,vProp,1);
	  }
	  if (vConstr!=NULL) {
	    Ddi_BddCofactorAcc(eqConstr,vConstr,1);
	  }
          Ddi_BddarrayInsertLast(constrA, eqConstr);
          Ddi_BddarrayInsertLast(coneA, myZero);
          Ddi_Free(eqConstr);
        }
      }
    }
  }

#if 0
  // disabled - useBwdRings now used for negation of fwd rings
  if (itpMgr->bckReachedRings!=NULL && itpMgr->igr.useBwdRings && 
      nFrames >= itpMgr->igr.useBwdRings) {
    int bwdRing_j = nFrames-4;
    int found = 0;
    if (Ddi_BddarrayNum(itpMgr->bckReachedRings)>bwdRing_j) {
      while (split_i>0 && bwdRing_j > 2 &&
             bwdRing_j>(start_i-split_i+1)) {
        Ddi_Bdd_t *ring_j = Ddi_BddarrayRead(
                            itpMgr->bckReachedRings,bwdRing_j);
        if (ring_j != NULL && Ddi_BddSize(ring_j) > 100) {
          found=1;
          break;
        }
        bwdRing_j--;
      }
    }
    if (found &&
        Ddi_BddarrayNum(itpMgr->bckReachedRings)>bwdRing_j) {
      bwdRingConstr = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->bckReachedRings,bwdRing_j));
      Ddi_BddSubstVarsAcc(bwdRingConstr,ps,ns);
      andWithBwdRing_i = start_i - bwdRing_j + 1;
    }
  }
#endif

  int printRingConstr=0;

  if (itpTrAbstr != NULL) {
    itpTrAbstrConstr = Ddi_BddMakeConstAig(ddm, 1);
  }

  if (timeMark>0) {
    lA = itpMgr->timeFrames->PiLits[timeMark];
    Ddi_BddarrayComposeAcc(unroll, vA, lA);
  }
  
  for (i = end_i + 1, j = 1; i <= start_i; i++, j++) {
    Ddi_Bddarray_t *myAntecedents = NULL;
    Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(deltaNs);
    Ddi_Bdd_t *mySpecSpace = Ddi_BddDup(specSpaceNs);
    Ddi_Bdd_t *myRingConstr = NULL;
    Ddi_Bdd_t *myBwdRingConstr = NULL;
    Ddi_Var_t *vConstr = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");

    useRingConstrAsCone = enRingConstrAsCone;
    
    if (saveUnroll_i>0 && (saveUnroll_i == i)) {
      Pdtutil_Assert(unrollSplit!=NULL,"missing unroll parameter");
      Ddi_DataCopy(unrollSplit,unroll);
    }

    if (!useForImage) {
      if (i==end_i+1) {
        Ddi_Free(myDelta);
        myDelta = Ddi_BddarrayDup(deltaNsNoImg);
      }
    }
    if (deltaNsUnrollSplit!=NULL && i<split_i) {
      Ddi_Free(myDelta);
      myDelta = Ddi_BddarrayDup(deltaNsUnrollSplit);
    }
    if (itpMgr->splitCex!=NULL) {
      int frameId = j + (Ddi_BddPartNum(itpMgr->splitCex)-nFrames-1);
      if ((frameId>=0) && frameId<Ddi_BddPartNum(itpMgr->splitCex)) {
	Ddi_Bdd_t *cex_i = Ddi_BddPartRead(itpMgr->splitCex,frameId);
	Ddi_AigarrayConstrainCubeAcc(myDelta, cex_i);
      }
    }

    int enRetCuts = split_i < 0 || i < split_i-1 || i > split_i;
    if (itpMgr->retimedCutPis!=NULL && j+timeMark+1<nFrames && enRetCuts) {
      Ddi_Bddarray_t *lA1 = itpMgr->timeFrames->PiLits[j+timeMark+1];
      Ddi_BddarraySubstVarsAcc(myDelta,itpMgr->retimedCutPis,itpMgr->retimedCutRefPis);
      Ddi_BddarrayComposeAcc(myDelta, vA, lA1);
    }
    lA = itpMgr->timeFrames->PiLits[j+timeMark];
    Ddi_BddarrayComposeAcc(myDelta, vA, lA);
    if (antecedentsNs!=NULL) {
      myAntecedents = Ddi_BddarrayCompose(antecedentsNs,vA,lA);
      if (itpMgr->retimedCutPis!=NULL && j+timeMark+1<nFrames && enRetCuts) {
        Ddi_Bddarray_t *lA1 = itpMgr->timeFrames->PiLits[j+timeMark+1];
        Ddi_BddarraySubstVarsAcc(myAntecedents,itpMgr->retimedCutPis,itpMgr->retimedCutRefPis);
        Ddi_BddarrayComposeAcc(myAntecedents, vA, lA1);
      }
    }
    
    if (split_i >= 0 && i == split_i) {
      igrUseRings = 0; // disable it NOW
      useBwdRings = 0; // disable it NOW
    }
    if (igrUseRings && i > 1 && (andWithRing_i == i ||
                                 0&&(abs(andWithRing_i-i)<4))
	|| 0&&(split_i >= 0 && i == split_i)) {
      if (itpMgr->fromRings!=NULL && Ddi_BddarrayNum(itpMgr->fromRings)>i) {
	Ddi_Bdd_t *currRing = Ddi_BddarrayRead(itpMgr->fromRings, i);
	int sizeRing = currRing == 0 ? 0 : Ddi_BddSize(currRing);
	int sizeBck = -1;
	int sizeUnroll = Ddi_BddarraySize(unroll);
	int j=-1;

	if (sizeRing >= andWithRingSizeMax) {
          andWithRingSizeMax *= 1.2;
          andWithRing_i++;
        }
        else if ((sizeRing < andWithRingSizeMax ||
                  sizeRing < sizeUnroll * 0.5)
                 && !Ddi_BddIsOne(currRing)) {
          if (myRingConstr!=NULL) {
            Ddi_BddAndAcc(myRingConstr,currRing);
          }
          else {
            myRingConstr = Ddi_BddDup(currRing);
          }
          Ddi_BddCofactorAcc(myRingConstr,vConstr,1);
	  if (0 && (1||boundK) && (i>2)) {
	    int safeRequired = start_i - i + 1;
	    for (j=i-1; j>end_i && j>2; j--) {
	      int safe = Trav_ItpMgrReadConeBoundOK(itpMgr,j);
	      if (safe >= safeRequired) {
		Ddi_Bdd_t *prevRing = 
		  Ddi_BddarrayRead(itpMgr->fromRings, j);
		/* use as care bwd */
		sizeBck = Ddi_BddSize(prevRing);
		Ddi_BddDiffAcc(myRingConstr,prevRing);
		break;
	      }
	    }
	  }
	  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
            if (printRingConstr++ == 0) {
	      printf("RING CONSTR:");
            }
            printf(" [%d]%s%d", i,
                   useRingConstrAsCone?"|":"&", sizeRing);
	  }
          if (useRingsMultiple && andWithRingDone_i<0) {
            andWithRing_i = andWithRing_i + igrUseRingsStep;
          }
          //	  andWithRingDone_i = i;
	}
      }
    }

    if (useBwdRings && i > 1 && (andWithBwdRing_i == i)) {
      Pdtutil_Assert(bwdRingConstr!=NULL,"no bwd constr");
      myBwdRingConstr = Ddi_BddDup(bwdRingConstr);
      Ddi_BddCofactorAcc(myBwdRingConstr,vConstr,1);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        if (printRingConstr++ == 0) {
          printf("RING CONSTR:");
        }
        printf(" [%d-B]&%d", i, Ddi_BddSize(myBwdRingConstr));
      }
      Ddi_Free(bwdRingConstr);
      bwdRingConstr = findBwdRingConstr(itpMgr, andWithRing_i, &andWithBwdRing_i, end_i, start_i);
    }

    if (0 && (useRingConstr > 0) && i > 0) {
      if (Ddi_BddarrayNum(itpMgr->eqRings) > i) {
        Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i);

        if (eqConstr != NULL) {
          Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
          Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

          if (itpMgr->abstrRefNnf) {
            eqConstr = Ddi_NnfDualRailEq(eqConstr, ns);
            vars = Ddi_BddReadEqVars(eqConstr);
            subst = Ddi_BddReadEqSubst(eqConstr);
          }
          Ddi_BddarrayComposeAcc(myDelta, vars, subst);
          Ddi_BddComposeAcc(mySpecSpace, vars, subst);
          if (myRingConstr != NULL)
            Ddi_BddComposeAcc(myRingConstr, vars, subst);
          if (myBwdRingConstr != NULL)
            Ddi_BddComposeAcc(myBwdRingConstr, vars, subst);
          if (useRingConstr > 1) {
            eqConstr = Ddi_BddMakeAig(eqConstr);
	    if (split_i < 0 || i != split_i) {
	      Ddi_BddComposeAcc(eqConstr, ns, unroll);
	    }
	    if (vProp!=NULL) {
	      Ddi_BddCofactorAcc(eqConstr,vProp,1);
	    }
	    if (vConstr!=NULL) {
	      Ddi_BddCofactorAcc(eqConstr,vConstr,1);
	    }
            Ddi_BddarrayInsertLast(constrA, eqConstr);
            Ddi_Free(eqConstr);
            Ddi_BddarrayInsertLast(coneA, myZero);
          }
          if (itpMgr->abstrRefNnf) {
            Ddi_Free(eqConstr);
          }
        }
      }
    }

    //    if (i>0 && (boundK>1 || (boundK==1 && j==1))) {
    int useSpaceConstr = customConstr != NULL;
    if (i > 0 && (0 || boundK || useSpaceConstr)) {
      Ddi_Bdd_t *myConstr = Ddi_BddDup(mySpecSpace);

      Ddi_BddComposeAcc(myConstr, ns, unroll);
      if (vProp!=NULL) {
        Ddi_BddCofactorAcc(myConstr,vProp,1);
      }
      if (vConstr!=NULL) {
        Ddi_BddCofactorAcc(myConstr,vConstr,1);
      }
      Ddi_BddarrayInsertLast(constrA,myConstr);
      //      Ddi_BddarrayInsertLast(constrA, myOne);
      if ((1 || boundK) && customConstr==NULL) {
        if (vConstr!=NULL) {
          Ddi_Bdd_t *cLit = Ddi_BddMakeLiteralAig(vConstr, 0);
          int size0 = Ddi_BddSize(myConstr);
          Ddi_BddCofactorAcc(myConstr,vConstr,1);
          if (Ddi_BddSize(myConstr)<size0) 
            Ddi_BddOrAcc(myConstr,cLit);
          Ddi_Free(cLit);
        }
        Ddi_BddNotAcc(myConstr);
        Ddi_BddarrayInsertLast(coneA, myConstr);
      } else {
        Ddi_BddarrayInsertLast(coneA, myZero);
      }
      Ddi_Free(myConstr);
    }
    Ddi_Free(mySpecSpace);

    if (split_i >= 0 && i == split_i) {
      char splitName[100];
      int ii;
      igrUseRings = 0; // disable it NOW
      Pdtutil_Assert(unrollSplit != NULL, "NULL unroll split");
      Ddi_DataCopy(unrollSplit, unroll);
      Ddi_BddarraySubstVarsAcc(unrollSplit, ns, ps);
      Ddi_BddarraySubstVarsAcc(constrA, ns, ps);
      Ddi_BddarraySubstVarsAcc(coneA, ns, ps);
      Pdtutil_Assert(Ddi_BddarrayNum(constrA)==Ddi_BddarrayNum(coneA),
		     "constr and cone are not aligned");
      //  if (0 && (useSplitUnrollConstr>1)) {
      //  /* DISABLED SO FAR: still to implement */
      useRingConstr=0;
      if (constrSplit != NULL) {
	Pdtutil_Assert(Ddi_BddarrayNum(coneA)==Ddi_BddarrayNum(constrA),
		       "cone/constr mismatch");
	for (ii = Ddi_BddarrayNum(coneA) - 1; ii >= 0; ii--) {
	  Ddi_Bdd_t *constr_i = Ddi_BddarrayRead(constrA, ii);
	  Ddi_Bdd_t *cone_i = Ddi_BddarrayRead(coneA, ii);  
	  if (!Ddi_BddIsOne(constr_i)) {
	    if (ii==Ddi_BddarrayNum(coneA)-1 || coneSplit==NULL) {
	      Ddi_Bdd_t *constr0_i = Ddi_BddDup(constr_i);
	      Ddi_BddComposeAcc(constr0_i, ns, unroll);
	      Ddi_BddAndAcc(constrSplit, constr0_i);
	      Ddi_Free(constr0_i);
	      Ddi_BddSubstVarsAcc(constr_i, ps, ns);
	      Ddi_BddarrayWrite(constrA,ii,myOne);
	    }
	    else {
	      Ddi_BddAndAcc(coneSplit, constr_i);
	      Ddi_BddAndAcc(constrSplit, constr_i);
	      Ddi_BddarrayWrite(constrA,ii,myOne);
	    }
	  }
	  if (!Ddi_BddIsZero(cone_i)) {
	    if (coneSplit==NULL) {
	      Pdtutil_Assert(Ddi_BddIsZero(cone_i),
			 "cone not compatible with split constr");
	    }
	    else {
      	      Ddi_BddOrAcc(coneSplit, cone_i);
	      Ddi_BddarrayWrite(coneA,ii,myZero);
	    }
	  }
	}
      }
      else {
	for (ii=0; ii<Ddi_BddarrayNum(coneA); ii++) {
	  Ddi_Bdd_t *constr_i = Ddi_BddarrayRead(constrA, ii);
	  Ddi_Bdd_t *cone_i = Ddi_BddarrayRead(coneA, ii);
	  if (!Ddi_BddIsOne(constr_i)) {
	    if (useSplitUnrollConstr) {
	      Ddi_Var_t *vSplit_i = Ddi_VarFindOrAdd(ddm,splitName,1);
	      Ddi_Bdd_t *lit_i;
	      sprintf(splitName,"PDT_ITP_SPLITV_CONSTR_%d", ii);
	      vSplit_i = Ddi_VarFindOrAdd(ddm,splitName,1);
	      lit_i = Ddi_BddMakeLiteralAig(vSplit_i, 1);
	      Ddi_BddarrayInsertLast(unrollSplit,constr_i);
	      Ddi_BddarrayWrite(constrA,ii,lit_i);
	      Ddi_VararrayInsertLast(varsSplit,vSplit_i);
	      Ddi_Free(lit_i);
	    }
	    else {
	      Ddi_BddarrayWrite(constrA,ii,myOne);
	    }
	  }
	  if (!Ddi_BddIsZero(cone_i)) {
	    if (useSplitUnrollConstr) {
	      Ddi_Var_t *vSplit_i = Ddi_VarFindOrAdd(ddm,splitName,1);
	      Ddi_Bdd_t *lit_i;
	      sprintf(splitName,"PDT_ITP_SPLITV_CONE_%d", ii);
	      vSplit_i = Ddi_VarFindOrAdd(ddm,splitName,1);
	      lit_i = Ddi_BddMakeLiteralAig(vSplit_i, 1);
	      Ddi_BddarrayInsertLast(unrollSplit,cone_i);
	      Ddi_BddarrayWrite(coneA,ii,lit_i);
	      Ddi_VararrayInsertLast(varsSplit,vSplit_i);
	      Ddi_Free(lit_i);
	    }
	    else {
	      Ddi_BddarrayWrite(coneA,ii,myZero);
	    }
	  }
	}
      }
      if (1 && myBwdRingConstr != NULL) {
        Ddi_BddarrayInsertLast(constrA, myBwdRingConstr);
        Ddi_BddarrayInsertLast(coneA, myZero);
      }
      if (invarConstrNs != NULL) {
        Ddi_BddarrayInsertLast(constrA, invarConstrNs);
        Ddi_BddarrayInsertLast(coneA, myZero);
      }
      if (myRingConstr != NULL) {
	// keep constr on cut variables
	// Ddi_BddComposeAcc(myRingConstr, ns, unroll);
        if (useRingConstrAsCone) {
          Ddi_BddarrayInsertLast(constrA, myOne);
          Ddi_BddNotAcc(myRingConstr);
          Ddi_BddarrayInsertLast(coneA, myRingConstr);
        }
        else {
          Ddi_BddarrayInsertLast(constrA, myRingConstr);
          Ddi_BddarrayInsertLast(coneA, myZero);
        }
      }
      if (careSplit!=NULL && itpMgr->fromRings!=NULL && 
	  Ddi_BddarrayNum(itpMgr->fromRings)>i) {
	Ddi_Bdd_t *currRing = Ddi_BddarrayRead(itpMgr->fromRings, i);
	Ddi_DataCopy(careSplit,currRing);
      }
    } else {
      Ddi_BddarrayComposeAcc(myDelta, ns, unroll);
      if (myAntecedents!=NULL) {
        Ddi_BddarrayComposeAcc(myAntecedents, ns, unroll);
      }
      if (1 && myBwdRingConstr != NULL) {
	Ddi_BddComposeAcc(myBwdRingConstr, ns, unroll);
        Ddi_BddarrayInsertLast(constrA, myBwdRingConstr);
        Ddi_BddarrayInsertLast(coneA, myZero);
      }
      if (invarConstrNs != NULL) {
        Ddi_BddarrayInsertLast(constrA, invarConstrNs);
        Ddi_BddarrayInsertLast(coneA, myZero);
      }
      if (myRingConstr != NULL) {
	Ddi_BddComposeAcc(myRingConstr, ns, unroll);
        if (useRingConstrAsCone) {
          Ddi_BddarrayInsertLast(constrA, myOne);
          Ddi_BddNotAcc(myRingConstr);
          Ddi_BddarrayInsertLast(coneA, myRingConstr);
        }
        else {
          Ddi_BddarrayInsertLast(constrA, myRingConstr);
          Ddi_BddarrayInsertLast(coneA, myZero);
        }
      }
    }

    if (itpTrAbstr != NULL) {
      Ddi_Bdd_t *myConstr = Ddi_BddDup(itpTrAbstr);
      // ns has to be first to avoid multiple ns compose
      trConstrSize += Ddi_BddSize(myConstr);
      Ddi_BddComposeAcc(myConstr, ns, myDelta); 
      Ddi_BddComposeAcc(myConstr, ps, unroll);
      Ddi_BddarrayInsertLast(constrA, myConstr);
      Ddi_BddarrayInsertLast(coneA, myZero);
      Ddi_Free(myConstr);
    }
    
    Ddi_Free(myRingConstr);
    Ddi_Free(myBwdRingConstr);
    Ddi_Free(unroll);
    unroll = myDelta;
    if (myAntecedents!=NULL) {
      Ddi_BddarrayAppend(observedGates, myAntecedents);
      Ddi_Free(myAntecedents);
    }


  }

  if (itpTrAbstr != NULL) {
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf(" (itp TR CONSTR: %d) ", trConstrSize);
      printRingConstr = 1;
    }
  }

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    if (printRingConstr > 0) {
      printf("\n");
    }
  }
  
  if (itpMgr->abstrRefNnf) {
    int mark = Ddi_BddReadMark(cone);
    Ddi_Bdd_t *myCone = Ddi_AigNnf(cone, itpMgr->ns, NULL, NULL, NULL, NULL);
    Ddi_DataCopy(cone, myCone);
    Ddi_Free(myCone);
    Pdtutil_Assert(mark == Ddi_BddReadMark(cone), "wrong mark");
    Pdtutil_Assert(Ddi_AigCheckMonotone(cone, ns), "not monotone");
  }

  timeFrameShiftKAcc(cone, itpMgr->timeFrames->PiVars,
    itpMgr->timeFrames->PiLits, timeMark + nFrames + 1, nFrames);

  Ddi_BddComposeAcc(cone, ns, unroll);

  Ddi_Free(unroll);

  if (initConstr != NULL) {
    Ddi_BddAndAcc(cone, initConstr);
    Ddi_Free(initConstr);
  }

  Pdtutil_Assert(Ddi_BddarrayNum(coneA) == Ddi_BddarrayNum(constrA),
    "wrong array size");
  for (i = Ddi_BddarrayNum(constrA) - 1; i >= 0; i--) {
    Ddi_Bdd_t *constr_i = Ddi_BddarrayRead(constrA, i);
    Ddi_Bdd_t *cone_i = Ddi_BddarrayRead(coneA, i);

    if (!Ddi_BddIsOne(constr_i)) {
      Ddi_BddAndAcc(cone, constr_i);
    }
    if (!Ddi_BddIsZero(cone_i)) {
      Ddi_BddOrAcc(cone, cone_i);
    }
  }

  Ddi_Free(bwdRingConstr);
  Ddi_Free(bwdRingConstr1);
  Ddi_Free(deltaNsUnrollSplit);
  Ddi_Free(antecedentsNs);
  Ddi_Free(deltaNs0);
  Ddi_Free(deltaNsNoImg);
  Ddi_Free(deltaNs);
  Ddi_Free(specSpaceNs);
  Ddi_Free(invarConstrNs);
  Ddi_Free(targetNs);
  Ddi_Free(itpTrAbstrConstr);

  Ddi_Free(coneA);
  Ddi_Free(constrA);
  Ddi_Free(myOne);
  Ddi_Free(myZero);

  Ddi_BddWriteMark(cone, timeMark + nFrames);
  if (andWithRingP!=NULL && andWithRingDone_i >= 0) {
    *andWithRingP = andWithRingDone_i;
  }

  if (ref != NULL) {
    Pdtutil_Assert(Ddi_AigEqualSat(ref, cone), "wrong grow cone bwd");
    Ddi_Free(ref);
  }

  return cone;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
growConeBwdRelational(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int boundK
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cone);
  int i, j, nFrames, timeMark;
  Ddi_Bdd_t *unroll = NULL;
  Ddi_Bdd_t *myRel = NULL;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vAState = NULL;
  Ddi_Bddarray_t *lAState = NULL;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Ddi_Bddarray_t *constrA = Ddi_BddarrayAlloc(ddm, 0);
  Ddi_Bddarray_t *coneA = Ddi_BddarrayAlloc(ddm, 0);
  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t *initConstr = NULL;
  Ddi_Bddarray_t *deltaNs = NULL;
  Ddi_Bdd_t *specSpaceNs = NULL, *targetNs;
  int andWithRing_i = -1;
  int doRedRem = 0;
  Ddi_Bdd_t *ref = NULL;
  int chk = 0, chkNnf = 1 && itpMgr->abstrRefNnf;
  int igrUseRings = itpMgr->igr.useRings;
  int initStubAsConstr = 0;
  int constrDiff = 0;

  //  printf("\nGRWCONE: %d-%d, RC: %d - bK: %d\n", start_i, end_i, useRingConstr, boundK);

  if (igrUseRings < 0) {
    igrUseRings *= -1;
    doRedRem = 1;
  }

  if (delta == NULL) {
    delta = itpMgr->delta;
    if (itpMgr->nnf.delta != NULL) {
      delta = itpMgr->nnf.delta;
      ps = itpMgr->nnf.ps2;
      ns = itpMgr->nnf.ns2;
      Pdtutil_Assert(!chkNnf
        || Ddi_AigarrayCheckMonotone(delta, ps), "not monotone");

    }
  }

  if (itpMgr->abstrRefNnf) {
    ps = itpMgr->nnf.ps2;
    ns = itpMgr->nnf.ns2;
  }

  deltaNs = Ddi_BddarraySubstVars(delta, ps, ns);

  if (useRingConstr && (itpMgr->abstrRefNnf || itpMgr->itpIncr)) {
    useRingConstr = 1;
  }
  //  if (useRingConstr) useRingConstr = 1;

  nFrames = start_i - end_i + 1;
  timeMark = Ddi_BddReadMark(cone);

  itpMgrFindOrAddTimeFrames(itpMgr,nFrames+1,timeMark,1/*useNsVars*/);

  unroll = Ddi_BddMakePartConjVoid(ddm);

  vAState = itpMgr->timeFrames->vars[1];
  myRel = Ddi_BddRelMakeFromArray(deltaNs, vAState);

  if (end_i == 0 && initStub != NULL) {
    Ddi_Free(myRel);
    if (initStubAsConstr) {
      initConstr = Ddi_BddRelMakeFromArray(initStub, vAState);
      Ddi_BddSetAig(initConstr);
      myRel = Ddi_BddMakeConstAig(ddm, 1);
    } else {
      myRel = Ddi_BddRelMakeFromArray(initStub, vAState);
    }
  }

  Ddi_BddPartInsertLast(unroll, myRel);
  Ddi_Free(myRel);

  if (itpMgr->specSpace != NULL) {
    specSpaceNs = Ddi_BddSubstVars(itpMgr->specSpace, ps, ns);
  } else {
    specSpaceNs = Ddi_BddMakeConstAig(ddm, 1);
  }
  targetNs = Ddi_BddSubstVars(itpMgr->target, ps, ns);

  if (itpMgr->abstrRefNnf) {
    Pdtutil_Assert(0, "not yet supported");
  }
  // if (end_i>0) {
  // if ((end_i>0) && (boundK==0 || boundK>1)) { // to avoid unsound cones
  if ((end_i > 0) && (boundK)) {
    Ddi_BddarrayInsertLast(constrA, specSpaceNs);
    Ddi_BddarrayInsertLast(coneA, targetNs);
  }

  if (useRingConstr > 0 && end_i > 0) {
    if (Ddi_BddarrayNum(itpMgr->eqRings) > end_i) {
      Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, end_i);

      if (eqConstr != NULL) {
        Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
        Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

        Ddi_BddComposeAcc(unroll, vars, subst);
        Ddi_BddarrayComposeAcc(constrA, vars, subst);
        Ddi_BddarrayComposeAcc(coneA, vars, subst);
        if (useRingConstr > 0) {
          eqConstr = Ddi_BddMakeAig(eqConstr);
          Ddi_BddarrayInsertLast(constrA, eqConstr);
          Ddi_BddarrayInsertLast(coneA, myZero);
          Ddi_Free(eqConstr);
        }
      }
    }
  }

  vA = itpMgr->pi;
  vAState = itpMgr->ns;

  constrDiff = Ddi_BddarrayNum(constrA) - Ddi_BddPartNum(unroll);

  for (i = end_i + 1, j = 1; i <= start_i; i++, j++) {
    Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(deltaNs);
    Ddi_Bdd_t *mySpecSpace = Ddi_BddDup(specSpaceNs);

    lA = itpMgr->timeFrames->PiLits[j];
    Ddi_BddarrayComposeAcc(myDelta, vA, lA);

    lAState = itpMgr->timeFrames->Lits[j];

    if (useRingConstr > 0 && i > 0) {
      if (Ddi_BddarrayNum(itpMgr->eqRings) > i) {
        Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i);

        if (eqConstr != NULL) {
          Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
          Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

          if (itpMgr->abstrRefNnf) {
            eqConstr = Ddi_NnfDualRailEq(eqConstr, ns);
            vars = Ddi_BddReadEqVars(eqConstr);
            subst = Ddi_BddReadEqSubst(eqConstr);
          }
          Ddi_BddarrayComposeAcc(myDelta, vars, subst);
          Ddi_BddComposeAcc(mySpecSpace, vars, subst);
          if (useRingConstr > 1) {
            eqConstr = Ddi_BddMakeAig(eqConstr);
            Ddi_BddComposeAcc(eqConstr, ns, lAState);
            Ddi_BddarrayInsertLast(constrA, eqConstr);
            Ddi_Free(eqConstr);
            Ddi_BddarrayInsertLast(coneA, myZero);
          }
          if (itpMgr->abstrRefNnf) {
            Ddi_Free(eqConstr);
          }
        }
      }
    }
    //    if (i>0 && (boundK>1 || (boundK==1 && j==1))) {
    if (i > 0 && (boundK)) {
      Ddi_Bdd_t *myConstr = Ddi_BddDup(mySpecSpace);

      Ddi_BddComposeAcc(myConstr, ns, lAState);
      // Ddi_BddarrayInsertLast(constrA,myConstr);
      Ddi_BddarrayInsertLast(constrA, myOne);
      if (boundK) {
        Ddi_BddNotAcc(myConstr);
        Ddi_BddarrayInsertLast(coneA, myConstr);
      } else {
        Ddi_BddarrayInsertLast(coneA, myZero);
      }
      Ddi_Free(myConstr);
    }
    Ddi_Free(mySpecSpace);

    Ddi_BddarrayComposeAcc(myDelta, itpMgr->ns, lAState);

    Pdtutil_Assert(j + 1 < itpMgr->timeFrames->Num,
      "time frame index out fo bounds");
    vAState = itpMgr->timeFrames->vars[j + 1];
    myRel = Ddi_BddRelMakeFromArray(myDelta, vAState);

    Ddi_BddPartInsertLast(unroll, myRel);
    Ddi_Free(myRel);
    Ddi_Free(myDelta);

  }

  if (itpMgr->abstrRefNnf) {
    int mark = Ddi_BddReadMark(cone);
    Ddi_Bdd_t *myCone = Ddi_AigNnf(cone, itpMgr->ns, NULL, NULL, NULL, NULL);

    Ddi_DataCopy(cone, myCone);
    Ddi_Free(myCone);
    Pdtutil_Assert(mark == Ddi_BddReadMark(cone), "wrong mark");
    Pdtutil_Assert(Ddi_AigCheckMonotone(cone, ns), "not monotone");
  }

  timeFrameShiftKAcc(cone, itpMgr->timeFrames->PiVars,
    itpMgr->timeFrames->PiLits, timeMark + nFrames + 1, nFrames);

  lAState = itpMgr->timeFrames->Lits[nFrames];

  Ddi_BddComposeAcc(cone, ns, lAState);

  Ddi_BddPartInsertLast(unroll, cone);

  Pdtutil_Assert(Ddi_BddarrayNum(coneA) == Ddi_BddarrayNum(constrA),
    "wrong array size");

  for (i = Ddi_BddPartNum(unroll) - 1; i >= 0; i--) {
    int iConstr = i - constrDiff;
    Ddi_Bdd_t *unroll_i = Ddi_BddPartRead(unroll, i);

    Ddi_BddSetAig(unroll_i);
    if (iConstr >= 0 && (iConstr < Ddi_BddarrayNum(constrA))) {
      Ddi_Bdd_t *constr_i = Ddi_BddarrayRead(constrA, iConstr);
      Ddi_Bdd_t *cone_i = Ddi_BddarrayRead(coneA, iConstr);

      if (!Ddi_BddIsOne(constr_i)) {
        Ddi_BddAndAcc(unroll_i, constr_i);
      }
      if (!Ddi_BddIsZero(cone_i)) {
        Ddi_BddOrAcc(unroll_i, cone_i);
      }
      if (i == 0) {
        while (iConstr-- > 0) {
          Ddi_Bdd_t *constr_i = Ddi_BddarrayRead(constrA, iConstr);
          Ddi_Bdd_t *cone_i = Ddi_BddarrayRead(coneA, iConstr);

          if (!Ddi_BddIsOne(constr_i)) {
            Ddi_BddAndAcc(unroll_i, constr_i);
          }
          if (!Ddi_BddIsZero(cone_i)) {
            Ddi_BddOrAcc(unroll_i, cone_i);
          }
        }
      }
    }
    if (i > 0) {
      Ddi_Vararray_t *suppA = Ddi_BddSuppVararray(unroll_i);
      Ddi_Bdd_t *unroll_i0 = Ddi_BddPartRead(unroll, i - 1);
      Ddi_Bdd_t *newUnroll = Ddi_BddMakePartConjVoid(ddm);

      Ddi_VararrayWriteMark(suppA, 1);
      vAState = itpMgr->timeFrames->vars[i];
      for (j = 0; j < Ddi_VararrayNum(vAState); j++) {
        Ddi_Var_t *v_j = Ddi_VararrayRead(vAState, j);

        if (Ddi_VarReadMark(v_j) != 0) {
          Ddi_Bdd_t *u_j = Ddi_BddPartRead(unroll_i0, j);

          Ddi_BddPartInsertLast(newUnroll, u_j);
        }
      }
      Ddi_DataCopy(unroll_i0, newUnroll);
      Ddi_Free(newUnroll);
      Ddi_VararrayWriteMark(suppA, 0);
      Ddi_Free(suppA);
    } else if (initConstr != NULL) {
      Ddi_BddAndAcc(unroll_i, initConstr);
    }
  }

  //  Ddi_BddSetAig(unroll);
  Ddi_DataCopy(cone, unroll);
  Ddi_Free(unroll);

  Ddi_Free(initConstr);
  Ddi_Free(deltaNs);
  Ddi_Free(specSpaceNs);
  Ddi_Free(targetNs);

  Ddi_Free(coneA);
  Ddi_Free(constrA);
  Ddi_Free(myOne);
  Ddi_Free(myZero);

  Ddi_BddWriteMark(cone, timeMark + nFrames);

  if (ref != NULL) {
    Pdtutil_Assert(Ddi_AigEqualSat(ref, cone), "wrong grow cone bwd");
    Ddi_Free(ref);
  }

  return cone;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
growConeBwd(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int andWithRing_i,
  int boundK
)
{
  //  Ddi_Bdd_t *cone1 = Ddi_BddDup(cone);
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = itpMgr->ddiMgr;
  static int nCalls = 0;
  int *andWithRingP = NULL;
  int useForImage = 1;
  int exactBoundDouble = travMgr->settings.aig.itpExactBoundDouble;
  Ddi_Bdd_t *cone1=NULL;
  
  nCalls++;

  if (andWithRing_i>0) {
    andWithRingP = &andWithRing_i;
  }
  if (boundK<0) {
    boundK = 0;
    useForImage = 0;
  }
  if (boundK==0 && exactBoundDouble>0 && (start_i-end_i)>0) {
    cone1 = Ddi_BddDup(cone);
    growConeBwdSplit(itpMgr, cone1, start_i-1, end_i, -1, delta,
                     initStub, useRingConstr, boundK, 0, NULL, NULL, 
		   NULL, NULL, NULL, NULL, NULL, andWithRingP, 0,
                   useForImage);
  }

  growConeBwdSplit(itpMgr, cone, start_i, end_i, -1, delta,
		   initStub, useRingConstr, boundK, 0, NULL,
                   NULL, NULL, NULL, NULL, NULL, NULL, andWithRingP, 0,
                   useForImage);

  if (cone1!=NULL) {
    Ddi_BddOrAcc(cone,cone1);
    Ddi_Free(cone1);
  }

#if 0
  if ((start_i - end_i) > 4 && end_i > 0) {
    int split_i = (end_i + start_i) / 2;
    Ddi_Mgr_t *ddm = Ddi_ReadMgr(cone);
    Ddi_Bdd_t *coneUp, *coneTot;
    Ddi_Bddarray_t *unrollSplit = Ddi_BddarrayAlloc(ddm, 1);

    growConeBwdSplit(itpMgr, cone1, start_i, end_i, split_i, delta,
		     initStub, useRingConstr, boundK, 0, unrollSplit, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 1);
    coneTot = coneJoinWithSubset(itpMgr, cone1, unrollSplit, 0);
    Ddi_Free(unrollSplit);
    Pdtutil_Assert(Ddi_AigEqualSat(coneTot, cone), "wrong cone split+join");
    Ddi_Free(coneTot);
  }
  Ddi_Free(cone1);
#endif

  return cone;
}
/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
growConeBwdSubsetByTarget(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  Ddi_Bddarray_t *observedGates,
  int doSubsetByTarget,
  int useRingConstr,
  int andWithRing_i,
  int boundK
)
{
  //  Ddi_Bdd_t *cone1 = Ddi_BddDup(cone);
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = itpMgr->ddiMgr;
  static int nCalls = 0;
  int *andWithRingP = NULL;
  Ddi_Bdd_t *auxCone = NULL;
  int exactBoundDouble = travMgr->settings.aig.itpExactBoundDouble;
  Ddi_Bdd_t *cone1=NULL;
  nCalls++;

  if (andWithRing_i>0) {
    andWithRingP = &andWithRing_i;
  }

  if (doSubsetByTarget && ((start_i - end_i)>doSubsetByTarget)) {
#if 0
    Ddi_Bdd_t *auxConstr=NULL;
    char *name1p = "PDT_BDD_PROP_WITNESS_1_VAR$PS";
    Ddi_Var_t *var1p = Ddi_VarFromName(ddm, name1p);
    if (var1p!=NULL) {
      Ddi_Bdd_t *auxConstr = Ddi_BddMakeLiteralAig(var1p, 0);
      //      Ddi_BddComposeAcc(auxConstr,itpMgr->ps,itpMgr->delta);
      auxCone = Ddi_BddDup(cone);
    
      growConeBwdSplit(itpMgr, auxCone, start_i, end_i, -1, delta,
                       initStub, useRingConstr, 0, 0, NULL, NULL, 
		   NULL, NULL, NULL, auxConstr, NULL, andWithRingP, 0, 1);
      Ddi_Free(auxConstr);
    }
#else
    int start_i_1 = start_i - (start_i-end_i)/2;
      auxCone = Ddi_BddDup(cone);
      growConeBwdSplit(itpMgr, auxCone, start_i_1, end_i,
                       -1, delta,
                       initStub, useRingConstr, 0, 0, NULL, NULL, 
                       NULL, NULL, NULL, NULL, NULL, andWithRingP, 0, 1);    
#endif
  }

  float coneSplitRatio = travMgr->settings.aig.igrConeSplitRatio;
  Ddi_Bddarray_t *unrollSplit = NULL;
  int split_i = -1;
  if ((coneSplitRatio < 0.99) && (start_i-end_i)>4) {
    unrollSplit = Ddi_BddarrayAlloc(ddm, 0);
    split_i = end_i + (start_i-end_i)*coneSplitRatio;
    if (split_i == end_i) split_i++;
  }
  
  if (exactBoundDouble>0 && (start_i-end_i)>0) {
    int start_i1 = start_i-exactBoundDouble;
    if (start_i1<=end_i) start_i1 = end_i+1;
    cone1 = Ddi_BddDup(cone);
    growConeBwdSplit(itpMgr, cone1, start_i1, end_i, -1, delta,
                     initStub, useRingConstr, boundK, 0, NULL, NULL, 
		   NULL, NULL, NULL, NULL, NULL, andWithRingP, 0,1);
  }


  growConeBwdSplit(itpMgr, cone, start_i, end_i, split_i, delta,
		   initStub, useRingConstr, boundK, 0, unrollSplit,
                   NULL, NULL, NULL, NULL, NULL,
                   observedGates, andWithRingP, 0,
                   1);
  if (unrollSplit!=NULL) {
    Ddi_Bdd_t *coneNew;
    coneNew = Ddi_BddMakeCompose(cone, NULL, NULL, unrollSplit,
                              NULL,NULL,NULL);
    Ddi_DataCopy(cone,coneNew);
    Ddi_Free(unrollSplit);
    Ddi_Free(coneNew);
  }
  if (cone1!=NULL) {
    Ddi_BddSetPartDisj(cone);
    Ddi_BddPartInsertLast(cone,cone1);
    Ddi_Free(cone1);
  }

  if (auxCone!=NULL) {
    Ddi_BddSetPartDisj(cone);
    Ddi_BddPartInsertLast(cone,auxCone);
    //    Ddi_BddOrAcc(cone,auxCone);
    Ddi_Free(auxCone);
  }
#if 0
  if ((start_i - end_i) > 4 && end_i > 0) {
    int split_i = (end_i + start_i) / 2;
    Ddi_Mgr_t *ddm = Ddi_ReadMgr(cone);
    Ddi_Bdd_t *coneUp, *coneTot;
    Ddi_Bddarray_t *unrollSplit = Ddi_BddarrayAlloc(ddm, 1);

    growConeBwdSplit(itpMgr, cone1, start_i, end_i, split_i, delta,
		     initStub, useRingConstr, boundK, 0, unrollSplit, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 1);
    coneTot = coneJoinWithSubset(itpMgr, cone1, unrollSplit, 0);
    Ddi_Free(unrollSplit);
    Pdtutil_Assert(Ddi_AigEqualSat(coneTot, cone), "wrong cone split+join");
    Ddi_Free(coneTot);
  }
  Ddi_Free(cone1);
#endif

  return cone;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
growConeBwdForRingCheck(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int andWithRing_i,
  int boundK
)
{
  //  Ddi_Bdd_t *cone1 = Ddi_BddDup(cone);
  static int nCalls = 0;
  int *andWithRingP = NULL;
  nCalls++;

  if (andWithRing_i>0) {
    andWithRingP = &andWithRing_i;
  }
  growConeBwdSplit(itpMgr, cone, start_i, end_i, -1, delta,
		   initStub, useRingConstr, boundK, 0, NULL, NULL, 
		   NULL, NULL, NULL, NULL, NULL, andWithRingP, 0, 0);

  return cone;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
coneNearestNeighbourConstr(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone
)
{
  Ddi_Bdd_t *miterConstr;
  Ddi_Bddarray_t *d0, *d1;
  Ddi_Vararray_t *piAux0, *piAux1, *nsAux;

  nsAux =
    Ddi_VararrayMakeNewVars(itpMgr->ns, "PDT_ITP_NS_AUX_", NULL, 1);
  piAux0 =
    Ddi_VararrayMakeNewVars(itpMgr->pi, "PDT_ITP_PI_AUX0_", NULL, 1);
  piAux1 =
    Ddi_VararrayMakeNewVars(itpMgr->pi, "PDT_ITP_PI_AUX1_", NULL, 1);
  
  d0 = Ddi_BddarrayDup(itpMgr->delta);
  d1 = Ddi_BddarrayDup(itpMgr->delta);
  Ddi_BddarraySubstVarsAcc(d0,itpMgr->ps,itpMgr->ns);
  Ddi_BddarraySubstVarsAcc(d0,itpMgr->pi,piAux0);
  Ddi_BddarraySubstVarsAcc(d1,itpMgr->ps,nsAux);
  //Ddi_BddarraySubstVarsAcc(d1,itpMgr->pi,piAux1);
  
  miterConstr = Ddi_BddMiterMakeFromArray(d0, d1);
  Ddi_BddSetAig(miterConstr);

  Ddi_BddSubstVarsAcc(cone,itpMgr->ns,nsAux);
  Ddi_BddAndAcc(cone,miterConstr);
  
  Ddi_Free(nsAux);
  Ddi_Free(piAux0);
  Ddi_Free(piAux1);
  Ddi_Free(d0);
  Ddi_Free(d1);

  return cone;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
growConeBwdDecomp(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  int split_i,
  int useSplitUnrollConstr,
  int useNewVars,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int andWithRing_i,
  int boundK
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cone);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  Ddi_Bdd_t *coneAux = NULL, *coneTot, *coneUp = Ddi_BddDup(cone);
  Ddi_Bddarray_t *unrollSplit = Ddi_BddarrayAlloc(ddm, 0);
  Ddi_Vararray_t *varsSplit = Ddi_VararrayAlloc(ddm, 0);
  Ddi_Bdd_t * coneSplit = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t * careSplit = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t * constrSplit = Ddi_BddMakeConstAig(ddm, 1);
  int chk = 0;
  int mark, markUp;
  int myAndWithRing = -1;

  if (andWithRing_i>0) {
    myAndWithRing = andWithRing_i;
  }

  growConeBwdSplit(itpMgr, coneUp, start_i, end_i, split_i, delta,
		   initStub, useRingConstr, boundK, 0,
		   unrollSplit, varsSplit, careSplit, constrSplit, coneSplit, NULL,
		   NULL, &myAndWithRing, useSplitUnrollConstr, 1);

  mark = Ddi_BddReadMark(coneUp);
  markUp = mark-(split_i-end_i);
  Ddi_BddWriteMark(constrSplit, markUp);
  Ddi_BddWriteMark(coneSplit, markUp);
  Ddi_BddWriteMark(coneUp, markUp);

  if (chk) {
    coneAux = coneJoinWithSubset(itpMgr, coneUp, unrollSplit, 0);
  }

  if (useNewVars) {
    Ddi_BddarraySubstVarsAcc(unrollSplit, itpMgr->ps, itpMgr->ns);
    Ddi_BddSubstVarsAcc(constrSplit, itpMgr->ps, itpMgr->ns);
    Ddi_BddSubstVarsAcc(coneSplit, itpMgr->ps, itpMgr->ns);
    Ddi_Vararray_t *splitV2 =
      Ddi_VararrayMakeNewVars(itpMgr->ps, "PDT_ITP_SPLITV_", NULL, 1);
    Ddi_BddSubstVarsAcc(coneUp,itpMgr->ns,splitV2);
    Ddi_BddSubstVarsAcc(careSplit,itpMgr->ns,splitV2);
    Ddi_VararrayAppend(splitV2,varsSplit);
    Pdtutil_Assert(Ddi_VararrayNum(varsSplit)==0,"not handled varssplit");
    coneTot = Ddi_BddMakeCompose(coneUp, itpMgr->ns, splitV2, unrollSplit,careSplit,constrSplit,coneSplit);
    Ddi_Free(splitV2);
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("SPLITTING CONE AT RING %d (%d+%d,c:%d)\n", split_i,
	     Ddi_BddarraySize(unrollSplit),
	     Ddi_BddSize(coneUp),
	     Ddi_BddSize(careSplit));
    }
  }
  else {
    coneTot = Ddi_BddMakeCompose(coneUp, NULL, itpMgr->ns, unrollSplit,careSplit,constrSplit,coneSplit);
  }
  Ddi_BddWriteMark(coneTot, mark);
  Ddi_Free(varsSplit);
  Ddi_Free(coneUp);



  if (chk) {
    Pdtutil_Assert(Ddi_AigEqualSat(coneAux, coneTot), "wrong decomp cone");
    Ddi_Free(coneAux);
  }
  Ddi_DataCopy(cone, coneTot);
  Ddi_Free(coneTot);
  Ddi_Free(careSplit);
  Ddi_Free(constrSplit);
  Ddi_Free(coneSplit);
  Ddi_Free(unrollSplit);

  return cone;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
growConeBwd0(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cone,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  Ddi_Bddarray_t * initStub,
  int useRingConstr,
  int boundK
)
{
  int i;

  for (i = start_i; i >= end_i; i--) {
    if (i == 0 && initStub != NULL) {
      timeFrameAddAcc(cone, itpMgr->pi, itpMgr->ps, itpMgr->ns, itpMgr->psvars,
        itpMgr->ns, initStub, itpMgr->timeFrames, itpMgr->useAigVars);
    } else {
      timeFrameAddAcc(cone, itpMgr->pi, itpMgr->ps, itpMgr->ns, itpMgr->psvars,
        itpMgr->ns, delta, itpMgr->timeFrames, itpMgr->useAigVars);

      if (i > 0) {
        Pdtutil_Assert(itpMgr->specSpace != NULL, "missing spec space");
        Ddi_BddAndAcc(cone, itpMgr->specSpace);
        if (boundK) {
          Ddi_BddNotAcc(itpMgr->specSpace);
          Ddi_BddOrAcc(cone, itpMgr->specSpace);
          Ddi_BddNotAcc(itpMgr->specSpace);
        }
      }

      Ddi_BddComposeAcc(cone, itpMgr->ps, itpMgr->nsLit);
    }

    if (itpMgr->igr.useRings && i > 0 && Ddi_BddarrayNum(itpMgr->fromRings) > i) {
      Ddi_Bdd_t *currRing = Ddi_BddarrayRead(itpMgr->fromRings, i);
      int sizeRing = currRing == 0 ? 0 : Ddi_BddSize(currRing);
      int sizeCone = Ddi_BddSize(cone);

      if (sizeRing < 10000 || sizeRing < sizeCone * 0.1) {
        Ddi_BddAndAcc(cone, currRing);
      }
    }

    if (useRingConstr > 0 && i > 0) {
      if (Ddi_BddarrayNum(itpMgr->eqRings) > i) {
        Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i);

        if (eqConstr != NULL) {
          Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
          Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

          Ddi_BddComposeAcc(cone, vars, subst);
          if (useRingConstr > 1) {
            eqConstr = Ddi_BddMakeAig(eqConstr);
            Ddi_BddAndAcc(cone, eqConstr);
            Ddi_Free(eqConstr);
          }
        }
      }
    }

  }
  return cone;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpSimplifyRingsBwdFwd(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int maxIter,
  Ddi_Bddarray_t * delta,
  int maxFail,
  int useRingConstr,
  int *enItpP,
  int boundK
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  int end_i = start_i - maxIter;
  int enWeaken = travMgr->settings.aig.itpWeaken;
  static int chk = 0;

  if (end_i < 1)
    end_i = 1;

  if (chk) {
    int myChkRings = itpCheckRingsFwd(itpMgr,end_i,start_i,0);
    printf("RING CHECK: %d\n", myChkRings);
    Pdtutil_Assert(myChkRings,"problem with from rings");
  }

  if (enWeaken) { 
    itpWeakenRingsBwd(itpMgr, start_i, end_i, delta, maxFail, useRingConstr,
                      boundK);
    if (chk) {
      int myChkRings = itpCheckRingsFwd(itpMgr,end_i,start_i,0);
      printf("RING CHECK: %d\n", myChkRings);
      Pdtutil_Assert(myChkRings,"problem with from rings");
    }
  }
  itpStrengthenRingsFwd(itpMgr, end_i, start_i, delta, maxFail, useRingConstr, enItpP,
                        boundK,0);
  if (chk) {
    int myChkRings = itpCheckRingsFwd(itpMgr,end_i,start_i,0);
    printf("RING CHECK: %d\n", myChkRings);
    Pdtutil_Assert(myChkRings,"problem with from rings");
  }

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpWeakenRingsBwd(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  int useItp,
  int useRingConstr,
  int boundK
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(delta);
  int i, nFrames, timeMark;
  Ddi_Bddarray_t *unroll = NULL;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bddarray_t *deltaNs = Ddi_BddarrayCompose(delta, ps, itpMgr->nsLit);
  Ddi_Bdd_t *psNs = Ddi_BddRelMakeFromArray(itpMgr->psLit, ns);
  Ddi_Bdd_t *itp;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  int chk = 0;
  int tryWeakenPlus = 0;

  Pdtutil_Assert(start_i >= end_i, "wrong start/end indexes in itp weakening");

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMed_c) {
    printf("\nITP weakening %d -> %d\n", start_i, end_i);
  }

  for (i = start_i; i > end_i; i--) {
    Ddi_Bdd_t *currRing = Ddi_BddarrayRead(itpMgr->fromRings, i);
    Ddi_Bdd_t *prevRing = Ddi_BddarrayRead(itpMgr->fromRings, i - 1);
    Ddi_Bdd_t *prevRingConstr = NULL;
    int sat, size1, sizeRing = Ddi_BddSize(prevRing);
    Ddi_Bdd_t *prevRingWithPsNs = NULL;

    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\n Aig weaken.ing ring %d (time:  %s ***\n", i - 1,
        util_print_time((util_cpu_time() - itpMgr->travMgr->travTime)));
    }
    if (!Ddi_BddIsOne(currRing)) {

      Ddi_Bdd_t *myPrevRing = Ddi_BddDup(prevRing);
      Ddi_Bdd_t *bwdFrom = Ddi_BddNot(currRing);
      Ddi_Bdd_t *myCare = NULL;

      if (itpMgr->pdrReachedRings!=NULL) {
	if (Ddi_BddarrayNum(itpMgr->pdrReachedRings)>i && i>=1) {
	  Ddi_Bdd_t *pdrR = Ddi_BddarrayRead(itpMgr->pdrReachedRings,i);
	  Ddi_BddDiffAcc(bwdFrom,pdrR);
	}
	if ((Ddi_BddarrayNum(itpMgr->pdrReachedRings)>=i) && (i>1)) {
	  Ddi_Bdd_t *pdrR = Ddi_BddarrayRead(itpMgr->pdrReachedRings,i-1);
	  myCare = Ddi_BddDup(pdrR);
	}
      }

      if (itpMgr->stallCtrl!=NULL) {
        int i;
        Ddi_Bdd_t *c_i = Ddi_BddMakeLiteralAig(itpMgr->stallCtrl, 1);
        Ddi_Bddarray_t *iStub =
          Ddi_BddarrayMakeLiteralsAig(itpMgr->ns, 1);
        for (i = 0; i < Ddi_BddarrayNum(deltaNs); i++) {
          Ddi_Bdd_t *d_i, *p_i;
          p_i = Ddi_BddarrayRead(iStub, i);
          d_i = Ddi_BddIte(c_i, Ddi_BddarrayRead(deltaNs, i), p_i);
          Ddi_BddarrayWrite(deltaNs, i, d_i);
          Ddi_Free(d_i);
        }
        Ddi_Free(c_i);
        Ddi_Free(iStub);
      }

      Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
      if (iv != NULL) {
        Ddi_Bdd_t *invarIn = Ddi_BddMakeLiteralAig(iv, 1);
        Ddi_BddAndAcc(bwdFrom, invarIn);
        Ddi_Free(invarIn);
      }

      Ddi_BddComposeAcc(bwdFrom, ns, deltaNs);

      if (itpMgr->invarConstr!=NULL && !Ddi_BddIsOne(itpMgr->invarConstr)) {
        Ddi_Bdd_t *myConstr = Ddi_BddDup(itpMgr->invarConstr);
        Ddi_BddSubstVarsAcc(myConstr, ps, ns);
	Ddi_BddAndAcc(bwdFrom,myConstr);
        Ddi_Free(myConstr);
      }

      if (0 && (Trav_MgrReadFromSelect(itpMgr->travMgr) ==
                Trav_FromSelectReached_c)) {
	Ddi_BddNotAcc(currRing);
	Ddi_BddOrAcc(bwdFrom,currRing);
	Ddi_BddNotAcc(currRing);
      }

      if (iv != NULL) {
        Ddi_Bdd_t *invarIn = Ddi_BddMakeLiteralAig(iv, 1);
        Ddi_BddAndAcc(bwdFrom, invarIn);
        Ddi_Free(invarIn);
      }

      if (useRingConstr > 0 && i > 0) {
        if (Ddi_BddarrayNum(itpMgr->eqRings) >= i) {
          Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i - 1);

          if (eqConstr != NULL) {
            Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
            Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

            Ddi_BddComposeAcc(bwdFrom, vars, subst);
            Ddi_BddComposeAcc(myPrevRing, vars, subst);
            prevRingConstr = Ddi_BddDup(eqConstr);
          }
        }
      }

      Pdtutil_Assert(!chk || !Ddi_AigSatAnd(myPrevRing, bwdFrom, NULL),
        "unsat required");
      if (useItp>0) {
        Ddi_BddSubstVarsAcc(myPrevRing, ns, ps);
        prevRingWithPsNs = Ddi_BddDup(psNs);
        Ddi_BddPartInsertLast(prevRingWithPsNs, myPrevRing);
        itp = Ddi_AigSatAndWithInterpolant(prevRingWithPsNs, bwdFrom,
          itpMgr->nsvars, NULL, NULL, NULL, NULL, NULL, &sat, 0, 1, -1.0);
      } else {
        itp = Ddi_BddDup(myPrevRing);
        if (Ddi_BddSize(itp)>100) {
          Ddi_Bdd_t *ret = 
            Ddi_AigOptByMonotoneCoreAcc(itp, bwdFrom, myCare, 0, -1.0);
          Pdtutil_Assert(ret!=NULL,"problem with weakening");
	  if (0 && itpMgr->specSpace!=NULL) {
	    Ddi_Var_t *v1 = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
	    Ddi_Bdd_t *b1 = Ddi_BddCofactor(bwdFrom,v1,0);
	    Pdtutil_Assert(Ddi_BddIsOne(b1),"unsound weakening");
	    Ddi_Free(b1);
	  }
 	  Pdtutil_Assert(!chk||!Ddi_AigSatAnd(itp,bwdFrom,myCare),"wrong weakening");
	  if (tryWeakenPlus) {
	    Ddi_Bdd_t *b2 = Ddi_BddAnd(bwdFrom,itp);
	    Ddi_Bdd_t *itp1 = Ddi_BddDup(itp);
	    Ddi_Bdd_t *itp2 = Ddi_BddDup(itp);
	    Ddi_AigOptByMonotoneCoreAcc(itp1, b2, myCare, 0, -1.0);
	    Ddi_Free(b2);
	    b2 = Ddi_BddAnd(bwdFrom,itp1);
	    Ddi_AigOptByMonotoneCoreAcc(itp2, b2, myCare, 0, -1.0);
	    Ddi_BddAndAcc(itp2,itp1);
	    Ddi_Free(b2);
	    Ddi_Free(itp1);
	    Ddi_AigOptByMonotoneCoreAcc(itp2, bwdFrom, myCare, 0, -1.0);
	    Pdtutil_Assert(!chk||!Ddi_AigSatAnd(itp2,bwdFrom,myCare),"wrong weakening");
	    if (Ddi_BddSize(itp2)<Ddi_BddSize(itp)) {
	      Ddi_DataCopy(itp, itp2);
	    }
	    Ddi_Free(itp2);
	  }
        }
      }
      Ddi_Free(myCare);
      Ddi_Free(prevRingWithPsNs);
      Pdtutil_Assert(itp != NULL, "null interpolant");
      if (prevRingConstr != NULL) {
        Ddi_BddSetAig(prevRingConstr);
        Ddi_BddAndAcc(itp, prevRingConstr);
        Ddi_Free(prevRingConstr);
      }

      size1 = Ddi_BddSize(itp);

      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMed_c) {
        printf("ITP weakening ring [%d] - ring sz: %d", i - 1, sizeRing);
        fflush(stdout);
      }

      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMed_c) {
        printf(" -> %d %s\n", size1, size1 < sizeRing ? "[weakened]" : "");
      }

      if (size1 < sizeRing) {
        Ddi_DataCopy(prevRing, itp);
      }
      Ddi_Free(itp);
      Ddi_Free(bwdFrom);
      Ddi_Free(myPrevRing);

    }
  }

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nitp weakening ended\n\n");
  }

  Ddi_Free(psNs);
  Ddi_Free(deltaNs);

  Ddi_Free(myOne);
  Ddi_Free(myZero);

}



/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpStrengthenRingsByBmc(
  Trav_ItpMgr_t * itpMgr,
  int useTarget,
  int fwd_j,
  int kBound,
  int subsetBound,
  int maxSubsetIter
)
{
  Ddi_Mgr_t *ddm = itpMgr->ddiMgr;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  int useEqRings = itpMgr->eqRings != NULL &&
    Ddi_BddarrayNum(itpMgr->eqRings) > 0;
  int nRings = Ddi_BddarrayNum(itpMgr->fromRings);
  Ddi_Bdd_t *coneRing;
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int boundK = (growCone > 2) ? 1 : 0;

  while (Ddi_BddarrayNum(itpMgr->fromRings)<=kBound) {
    Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
    Ddi_BddarrayInsertLast(itpMgr->fromRings,myOne);
    Ddi_Free(myOne);
  }
  nRings = Ddi_BddarrayNum(itpMgr->fromRings);
  Pdtutil_Assert(nRings>kBound,"wrong strengthening bound");

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nITP BMC-based strengthening with bound %d (subset bound: %d)\n", kBound, subsetBound);
  }

  int end_i = kBound-subsetBound+fwd_j;
  int start_i = kBound+fwd_j-1; // bound is one more
  coneRing = Ddi_BddNot(Ddi_BddarrayRead(itpMgr->fromRings, end_i));
  if (1) {
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    
    if (ivNs != NULL) {
      Ddi_Bdd_t *invarNs = Ddi_BddMakeLiteralAig(ivNs, 1);
      Ddi_BddAndAcc(coneRing,invarNs);
      Ddi_Free(invarNs);
    }
  }
  if (useTarget) {
    Pdtutil_Assert(itpMgr->target!=NULL,"missing target");
    Ddi_Bdd_t *myTarget = Ddi_BddSubstVars(itpMgr->target,
                                           itpMgr->ps, itpMgr->ns);
    Ddi_Vararray_t *tSuppA = Ddi_BddSuppVararray(myTarget);
    Ddi_VararrayDiffAcc(tSuppA,itpMgr->ns);
    Ddi_Vararray_t *tAux =
      Ddi_VararrayMakeNewVars(tSuppA,
                              "PDT_ITP_PI_TARGET_AUX_", NULL, 1);
    Ddi_BddSubstVarsAcc(myTarget,tSuppA,tAux);
    kBound++; start_i++; end_i++;
    Ddi_Free(coneRing);
    coneRing = Ddi_BddDup(myTarget);
    Ddi_Free(tAux);
    Ddi_Free(tSuppA);
    Ddi_Free(myTarget);
  }
  Ddi_BddWriteMark(coneRing, 0);

  int nIter = 1;
  Ddi_Bdd_t *myConePrev = Ddi_BddDup(coneRing);
  Ddi_Bdd_t *myConePrevTop=NULL;
  Pdtutil_Assert(end_i>fwd_j+1,"missing gap for BWD refinement");
  if (subsetBound > 0) {
    nIter = maxSubsetIter;
    growConeBwd(itpMgr, coneRing, start_i, end_i, itpMgr->delta,
	      itpMgr->initStub, 0, -1, boundK);
    growConeBwdDecomp(itpMgr, myConePrev, start_i, end_i-1, end_i, 
		      1, 0, NULL, itpMgr->initStub, 0, -1, boundK);

    Pdtutil_Assert(Ddi_BddReadComposeF(myConePrev)!=NULL,"no split cone");
    myConePrevTop = Ddi_BddReadComposeF(myConePrev);
    Ddi_BddSubstVarsAcc(myConePrev,itpMgr->ps,itpMgr->ns);
  }
  else {
    myConePrevTop = Ddi_BddDup(coneRing);
  }
  
  int nSteps = 0;

  for (int i=0; i<nIter; i++) {
    Ddi_Bdd_t *myCone = Ddi_BddDup(myConePrevTop);
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nitp BMC-based strengthening iteration: %d\n", i);
    }
    if (subsetBound > 0) {
      int abort;
      Ddi_Bdd_t *constrRing = Ddi_BddarrayRead(itpMgr->fromRings,end_i-1);
      Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(myConePrev,
		constrRing, NULL, NULL, -1, &abort);
      if (cex==NULL) {
	/* refined enough */
	Ddi_Free(myCone);
	nSteps = 1;
	break;
      }
      Ddi_BddExistAcc(cex,itpMgr->nsvars);
      Ddi_AigConstrainCubeAcc(myCone,cex);
      Ddi_Free(cex);
    }
    int res;
    nSteps = igrRefineRingsBwd(itpMgr, myCone, 0, fwd_j,
				   end_i-1, 
      useEqRings, 1 /* doTrav */, &res);

    Ddi_Free(myCone);
    itpStrengthenRingsFwd(itpMgr, fwd_j>0?fwd_j:1, end_i-1,
			  itpMgr->delta, -1, 1, NULL, 0, 0);
    nSteps++;
    if (nSteps < (kBound-subsetBound)) {
      nSteps = kBound-subsetBound;
      //      break;      
    }
  }
  Ddi_Free(coneRing);
  Ddi_Free(myConePrev);

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nitp BMC-based strengthening ended\n\n");
  }
  return nSteps;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpStrengthenRingsIntern(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  int maxFail,
  int useRingConstr,
  int *enItpP,
  int boundK,
  int useItp,
  int fwd
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(delta);
  int ii, nFrames, timeMark;
  Ddi_Bddarray_t *unroll = NULL;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bddarray_t *deltaNs = Ddi_BddarrayCompose(delta, ps, itpMgr->nsLit);
  Ddi_Bdd_t *invarPs=NULL, *invarNs=NULL;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  int doInductiveToPlus = 0 && Trav_MgrReadItpInductiveTo(itpMgr->travMgr);
  int forceNew = useItp;
  int chk = 0;

  Pdtutil_Assert(start_i <= end_i,
    "wrong start/end indexes in itp strengthening");

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMed_c) {
    if (fwd)
      printf("\nITP strengthening %d -> %d\n", start_i, end_i);
    else 
      printf("\nITP strengthening %d -> %d\n", end_i, start_i);
  }

  if (1) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    
    if (iv != NULL) {
      invarPs = Ddi_BddMakeLiteralAig(iv, 1);
      invarNs = Ddi_BddMakeLiteralAig(ivNs, 1);
    }
  }

  for (ii = 0; ii < end_i-start_i; ii++) {
    int i = fwd ? (start_i + ii) : (end_i - 1 - ii);
    Ddi_Bdd_t *currRing = Ddi_BddarrayRead(itpMgr->fromRings, i);
    Ddi_Bdd_t *nextRing = Ddi_BddarrayRead(itpMgr->fromRings, i + 1);
    Ddi_Bdd_t *nextRingConstr = NULL;
    int sat, size1, sizeRing = Ddi_BddSize(nextRing);
    int doInductiveImgPlus = doInductiveToPlus&&(i==end_i-1);
    int doItp = (enItpP!=NULL) && (*enItpP)&&(i==end_i-1);
    Ddi_Bdd_t *inductiveTo = NULL, *indToPlus = NULL;

    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\n Aig strengthening ring %d (time:  %s ***\n", i + 1,
        util_print_time((util_cpu_time() - itpMgr->travMgr->travTime)));
    }
    if (!Ddi_BddIsOne(currRing)) {

      Ddi_Bdd_t *itp, *fromAndTr;
      Ddi_Bdd_t *myCone = Ddi_BddNot(nextRing);
      Ddi_Bdd_t *fwdFrom = Ddi_BddDup(currRing);
      Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(deltaNs);

      if (itpMgr->invarConstr!=NULL && !Ddi_BddIsOne(itpMgr->invarConstr)) {
        Ddi_Bdd_t *myConstr = Ddi_BddDup(itpMgr->invarConstr);
        Ddi_BddSubstVarsAcc(myConstr, ps, ns);
	Ddi_BddAndAcc(fwdFrom,myConstr);
        Ddi_Free(myConstr);
      }

      if (useRingConstr > 0 && i > 0) {
        if (Ddi_BddarrayNum(itpMgr->eqRings) > i) {
          Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i);

          if (eqConstr != NULL) {
            Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
            Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

            Ddi_BddComposeAcc(fwdFrom, vars, subst);
            Ddi_BddarrayComposeAcc(myDelta, vars, subst);
          }
        }
      }

      if (doInductiveImgPlus) {
	inductiveTo = Ddi_BddDup(fwdFrom);
      }

      Ddi_BddSubstVarsAcc(fwdFrom, ns, ps);
      Ddi_BddarraySubstVarsAcc(myDelta, ns, ps);

      if (itpMgr->stallCtrl!=NULL) {
        int i;
        Ddi_Bdd_t *c_i = Ddi_BddMakeLiteralAig(itpMgr->stallCtrl, 1);
        Ddi_Bddarray_t *iStub =
          Ddi_BddarrayMakeLiteralsAig(itpMgr->ps, 1);
        for (i = 0; i < Ddi_BddarrayNum(myDelta); i++) {
          Ddi_Bdd_t *d_i, *p_i;
          p_i = Ddi_BddarrayRead(iStub, i);
          d_i = Ddi_BddIte(c_i, Ddi_BddarrayRead(myDelta, i), p_i);
          Ddi_BddarrayWrite(myDelta, i, d_i);
          Ddi_Free(d_i);
        }
        Ddi_Free(c_i);
        Ddi_Free(iStub);
      }
      fromAndTr = Ddi_BddRelMakeFromArray(myDelta, ns);
      if (1) {
        Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
        if (iv != NULL) {
          Ddi_Bdd_t *invarIn = Ddi_BddMakeLiteralAig(iv, 1);
          Ddi_BddAndAcc(fromAndTr, invarIn);
          Ddi_Free(invarIn);
        }
      }

      if (useRingConstr > 0 && i > 0) {
        if (Ddi_BddarrayNum(itpMgr->eqRings) > i + 1) {
          Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i + 1);

          if (eqConstr != NULL) {
            Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
            Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

            Ddi_BddComposeAcc(myCone, vars, subst);
            Ddi_BddComposeAcc(fromAndTr, vars, subst);
            nextRingConstr = Ddi_BddDup(eqConstr);
          }
        }
      }

      if (invarNs!=NULL) {
        Ddi_BddPartInsertLast(fromAndTr, invarNs);
      }

      Ddi_BddPartInsertLast(fromAndTr, fwdFrom);
      Pdtutil_Assert(!chk || !Ddi_AigSatAnd(fromAndTr, myCone, NULL),
        "unsat required");

      if (doInductiveImgPlus) {
	Ddi_Bdd_t *myFrom = Ddi_BddMakeAig(fromAndTr);
        indToPlus = Ddi_AigInductiveImgPlus(myFrom,
          inductiveTo, NULL, NULL, doInductiveToPlus);
	Ddi_Free(inductiveTo);
	Ddi_Free(myFrom);
      }

      int saveItpReverse = ddm->settings.aig.itpReverse;

      ddm->settings.aig.itpReverse = 0;
      Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
      Pdtutil_VerbLevel_e vNew = Pdtutil_VerbLevelUsrMed_c;
      if (verbosity > Pdtutil_VerbLevelUsrMed_c)
	Ddi_MgrSetVerbosity(ddm,vNew);
      if (useItp) {
	//        itp = Ddi_AigSatAndWithInterpolant(fromAndTr, myCone,
        //  itpMgr->nsvars, NULL, NULL, NULL, NULL, NULL, &sat, 0, 1, -1.0);
        itp = Ddi_AigSat22AndWithInterpolant(NULL,fromAndTr,myCone,NULL,
	  itpMgr->nsvars, NULL,NULL,0,NULL,NULL, &sat, 0, 1, 0, -1.0);
        Ddi_BddNotAcc(itp);
        Ddi_BddSetAig(fromAndTr);
        if (Ddi_BddSize(itp)>1) {
          Ddi_AigOptByMonotoneCoreAcc(itp, fromAndTr, indToPlus, 0, -1.0);
        }
        Ddi_BddNotAcc(itp);
      } else {
	if (doItp && (indToPlus!=NULL)) {
	  Ddi_BddAndAcc(myCone,indToPlus);
	  itp = Ddi_AigSat22AndWithInterpolant(NULL,fromAndTr,myCone,NULL,
	    itpMgr->nsvars, NULL,NULL,0,NULL,NULL, &sat, 0, 1, 0, -1.0);
          //itp = Ddi_AigSatAndWithInterpolant(fromAndTr, myCone,
	  //itpMgr->nsvars, NULL, NULL, NULL, NULL, NULL, &sat, 0, 1, -1.0);
	  Ddi_BddAndAcc(itp,indToPlus);
	  Ddi_BddNotAcc(itp);
	}
        else if (doItp) {
	  itp = Ddi_AigSat22AndWithInterpolant(NULL,fromAndTr,myCone,NULL,
	    itpMgr->nsvars, NULL,NULL,0,NULL,NULL, &sat, 0, 1, 0, -1.0);
	  //          itp = Ddi_AigSatAndWithInterpolant(fromAndTr, myCone,
	  //itpMgr->nsvars, NULL, NULL, NULL, NULL, NULL, &sat, 0, 1, -1.0);
	  Ddi_BddNotAcc(itp);
        }
	else {
	  itp = Ddi_BddDup(myCone);
	}
        Ddi_BddSetAig(fromAndTr);
        if (Ddi_BddSize(itp)>1) {
          Ddi_AigOptByMonotoneCoreAcc(itp, fromAndTr, indToPlus, 0, -1.0);
        }
        Ddi_BddNotAcc(itp);
      }
      Ddi_MgrSetVerbosity(ddm,verbosity);
      Ddi_Free(indToPlus);
      ddm->settings.aig.itpReverse = saveItpReverse;

      Pdtutil_Assert(itp != NULL, "null interpolant");

      if (nextRingConstr != NULL) {
        Ddi_BddSetAig(nextRingConstr);
        Ddi_BddAndAcc(itp, nextRingConstr);
        Ddi_Free(nextRingConstr);
      }
      if (1 && invarNs!=NULL) {
        Ddi_BddAndAcc(itp, invarNs);
      }
      
      size1 = Ddi_BddSize(itp);

      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMed_c) {
        printf("ITP strengthening ring [%d] - ring sz: %d", i + 1, sizeRing);
        fflush(stdout);
      }
      int update = (size1 < sizeRing) ||
        (forceNew>1)&&(size1 < forceNew*sizeRing);

      if (update) {
        Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMed_c) {
          printf(" -> %d %s\n", size1,
                 size1 < sizeRing ? "[reduced]" : "[increased]");
        }
        Ddi_DataCopy(nextRing, itp);
      }
      else {
        Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMed_c) {
          printf(" -> (%d)\n", size1);
        }
	if (doItp && enItpP && (size1 > 1.1 * sizeRing)
            && (size1 > 1000)) {
	  *enItpP = 0; // disable when failing
	}
      }
      Ddi_Free(myCone);
      Ddi_Free(myDelta);
      Ddi_Free(fromAndTr);
      Ddi_Free(itp);
      Ddi_Free(fwdFrom);

    }
  }

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nitp strengthening ended\n\n");
  }

  Ddi_Free(deltaNs);

  Ddi_Free(invarPs);
  Ddi_Free(invarNs);
  Ddi_Free(myOne);
  Ddi_Free(myZero);

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpStrengthenRingsFwd(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  int maxFail,
  int useRingConstr,
  int *enItpP,
  int boundK,
  int useItp
)
{
  itpStrengthenRingsIntern(itpMgr,start_i,end_i,delta,
       maxFail,useRingConstr,enItpP,boundK,useItp,1);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpStrengthenRingsBwd(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int end_i,
  Ddi_Bddarray_t * delta,
  int maxFail,
  int useRingConstr,
  int *enItpP,
  int boundK,
  int useItp
)
{
  itpStrengthenRingsIntern(itpMgr,start_i,end_i,delta,
    maxFail,useRingConstr,enItpP,boundK,useItp,0);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpStrengthenRingsBwdByBmc(
  Trav_ItpMgr_t * itpMgr,
  int start_i,
  int end_i,
  int step_i,
  Ddi_Bddarray_t * delta,
  int maxK,
  int useRingConstr,
  int boundK,
  int useItp
)
{
  int i, chk=1;

  for (i=start_i; i+maxK/2 <= end_i && i<(end_i-1); i+=step_i) {
    if (maxK>end_i-i) maxK = end_i-i;
    itpStrengthenRingsByBmc(itpMgr,0/* no target */,i,maxK,0,0);
  }
  if (1 && chk) {
    int myChkRings = itpCheckRingsFwd(itpMgr,-1,-1,0);
    printf("RING CHECK: %d\n", myChkRings);
    Pdtutil_Assert(myChkRings,"problem with from rings");
  }

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpStrengthenReachedGfp(
  Trav_ItpTravMgr_t * itpTravMgr,
  int *lastRingP,
  int enUpdateFromRings,
  int enUpdateConstr,
  int useInvarConstr,
  int useGen
)
{
  Trav_ItpMgr_t * itpMgr = itpTravMgr->itpMgr;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(itpMgr->delta);
  Ddi_Bddarray_t * delta = (itpMgr->deltaAbstr)?
    itpMgr->delta0:itpMgr->delta;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t *invarConstr=NULL;
  Ddi_Bddarray_t *deltaNs = Ddi_BddarrayCompose(delta, ps, itpMgr->nsLit);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  Ddi_Bdd_t *invarPs=NULL, *invarNs=NULL;
  Ddi_Bdd_t *reached = NULL;
  int lastRing = *lastRingP;
  int useItp = enUpdateFromRings;
  int itpBoundK = 2;
  int chk = 1;
  int useRingConstr = 1;
  int ret = 0;
  int i, maxIter = 10;
  int enDbg = 0;
  int maxItp = 0;
  static int nCalls = 0;
  int constrWithTarget = enUpdateConstr, doExist = 0;
  int igrBwdRefinement = itpMgr->travMgr->settings.aig.igrBwdRefine;

  if (enUpdateConstr)
    enUpdateFromRings = 0;
  
  nCalls++;
  reached = itpTravMgr->reached;

  int chkSupp=1;
  if (chkSupp) {
    Ddi_Vararray_t *s = Ddi_BddSuppVararray(itpTravMgr->reached);
    Ddi_VararrayDiffAcc(s,ns);
    Pdtutil_Assert(Ddi_VararrayNum(s)==0,"wrong supp");
    Ddi_Free(s);
  }
  
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nITP based GFP - reached size: %d\n", Ddi_BddSize(reached));
  }

  static int chk0 = 0;
  Ddi_Bddarray_t *saveF = Ddi_BddarrayDup(itpMgr->fromRings);
  Ddi_Bdd_t *saveR = Ddi_BddDup(itpTravMgr->reached);
  if (chk0) {
    int myChkRings = itpCheckRingsFwd(itpMgr,-1,-1,0);
    printf("RING CHECK: %d\n", myChkRings);
    Pdtutil_Assert(myChkRings,"problem with from rings");
    if (1 || !constrWithTarget) {
      int sat = checkRingIsFixPoint(itpMgr->ps,itpMgr->ns,
				    delta,
				    itpTravMgr->reached);
      Pdtutil_Assert(!sat,"problem with fix point for reached");
    }
  }

  int strengthenRings = lastRing > 1;
  if (strengthenRings) {
    for (int i=1; i<=lastRing; i++) {
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(itpMgr->fromRings,i);
      if (!Ddi_BddIncluded(f_i,itpTravMgr->careBwd)) {
        Ddi_BddAndAcc(f_i,itpTravMgr->careBwd);
      }
      if (!Ddi_BddIncluded(f_i,itpTravMgr->reached)) {
        Ddi_BddAndAcc(f_i,itpTravMgr->reached);
      }
    }
  }
  if (!Ddi_BddIncluded(itpTravMgr->reached,itpTravMgr->careBwd)) {
    Ddi_BddAndAcc(itpTravMgr->reached,itpTravMgr->careBwd);
  }


  if (itpMgr->invarConstr==NULL) {
    itpMgr->invarConstr = Ddi_BddMakeConstAig(ddm, 1);
  }
  if (itpMgr->invarConstr!=NULL && !Ddi_BddIsOne(itpMgr->invarConstr)) {
    invarConstr = Ddi_BddSubstVars(itpMgr->invarConstr,
				     itpMgr->ps,itpMgr->ns);
  }
 
  Ddi_Bdd_t *from = Ddi_BddSubstVars(reached, ns, ps);
  Ddi_Bdd_t *notReached = Ddi_BddNot(reached);
  Ddi_Bdd_t *itp=NULL, *fromAndTr;
  Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(deltaNs);

  if (useInvarConstr) {
    Pdtutil_Assert(Ddi_BddIsZero(notReached), "wrong use of invarconstr");
    Ddi_Free(notReached);
    notReached = Ddi_BddNot(invarConstr);
    Ddi_Vararray_t *suppA = Ddi_BddSuppVararray(notReached);
    Ddi_VararrayDiffAcc(suppA,itpMgr->ns);
    if (Ddi_VararrayNum(suppA)>0) {
      Ddi_Vararray_t *vAux =
        Ddi_VararrayMakeNewVars(suppA,
                              "PDT_ITP_PI_INVARCONSTR_AUX_", NULL, 1);
      Ddi_BddSubstVarsAcc(notReached,suppA,vAux);
      Ddi_Free(vAux);
    }
    useItp=1;
    Ddi_Free(suppA);
  }

  if (1) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    
    if (iv != NULL) {
      invarPs = Ddi_BddMakeLiteralAig(iv, 1);
      invarNs = Ddi_BddMakeLiteralAig(ivNs, 1);
      if (invarConstr==NULL) {
	invarConstr = Ddi_BddMakeConstAig(ddm, 1);
      }      
      Ddi_BddAndAcc(invarConstr, invarPs);
      Ddi_BddAndAcc(invarConstr, invarNs);
    }
  }
  
  if (1 && invarNs!=NULL) {
    Ddi_BddAndAcc(notReached,invarNs);
    //Ddi_AigarrayConstrainCubeAcc(myDelta,invarNs);
  }

  Ddi_BddarraySubstVarsAcc(myDelta, ns, ps);
  fromAndTr = Ddi_BddRelMakeFromArray(myDelta, ns);
  if (invarNs!=NULL) {
    Ddi_BddPartInsertLast(fromAndTr,invarNs);
  }

  if (itpMgr->invarConstr!=NULL && !Ddi_BddIsOne(itpMgr->invarConstr)) {
    Ddi_BddAndAcc(from,itpMgr->invarConstr);
    Ddi_Bdd_t *constrNs = Ddi_BddSubstVars(itpMgr->invarConstr, ps, ns);
    if (!useInvarConstr)
      Ddi_BddPartInsertLast(fromAndTr,constrNs);
    Ddi_Free(constrNs);
  }

  if (itpTravMgr->careBwd!=NULL && !Ddi_BddIsOne(itpTravMgr->careBwd)) {
    Ddi_Bdd_t *constr = Ddi_BddSubstVars(itpTravMgr->careBwd, ns, ps);
    Ddi_BddPartInsertLast(fromAndTr,constr);
    Ddi_Free(constr);
  }

  int fp = 0||!Ddi_AigSatAnd(fromAndTr, notReached, from);
  Pdtutil_Assert(fp, "fix point not reached");

  Ddi_Bdd_t *initStubRel = NULL;
  Ddi_Bdd_t *initNs = NULL;
  if (itpMgr->initStub!=NULL) {
    initStubRel = Ddi_BddRelMakeFromArray(itpMgr->initStub, ns);
  }
  else {
    initNs = Ddi_BddSubstVars(itpMgr->init, ps, ns);
  }
  int again = 1;
  float growRatio = 1.0;
  Ddi_Bdd_t *newReached = Ddi_BddNot(notReached);

  Ddi_Vararray_t *tAux =
      Ddi_VararrayMakeNewVars(itpMgr->pi,
                              "PDT_ITP_PI_TARGET_AUX_", NULL, 1);
  Ddi_Bdd_t *targetNs = Ddi_BddSubstVars(itpMgr->target,
                                         itpMgr->ps,itpMgr->ns);
  Ddi_Bdd_t *targetNsProj = NULL;
  if (Ddi_BddSize(targetNs) < 10) {
    constrWithTarget = 0;
  }
  constrWithTarget = 0;
  if (doExist) {
    targetNsProj = Ddi_BddExistProject(targetNs,itpMgr->nsvars);
  }

  Ddi_BddSubstVarsAcc(targetNs,itpMgr->pi,tAux);
      
  for (i=0; i<maxIter && again; i++) {
    Ddi_Bdd_t *myFromAndTr = Ddi_BddDup(fromAndTr);
    int size0 = Ddi_BddSize(from);
    Ddi_BddPartInsertLast(myFromAndTr, from);

    if (useGen) {
      Ddi_Vararray_t *glbA = Ddi_BddSuppVararray(myFromAndTr);
      int maxIter = 100;
      int res;
      Ddi_VararrayIntersectAcc(glbA, itpMgr->ns);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(itpMgr->travMgr),
                "|gfp-GENeralization:%d|.\n",
          Ddi_BddSize(myFromAndTr))
        );
      Ddi_Bdd_t *myA = Ddi_BddDup(myFromAndTr);
      Ddi_BddPartInsertLast(myA,targetNs);
      Ddi_Bdd_t *itpGen =
        Ddi_AigInterpolantByGenClauses(myA, myFromAndTr, NULL,
          NULL, itpMgr->ps, itpMgr->ns, itpMgr->init, glbA,
          NULL, NULL, NULL, maxIter, 1, &res);
      Ddi_Free(myA);
      Ddi_Free(glbA);
      if (itpGen!=NULL) {
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(itpMgr->travMgr),
                "|gfp-Inductive itp:%d|.\n",
          Ddi_BddSize(itpGen))
        );
        Ddi_Free(itpGen);
      }
    }

    if (constrWithTarget) {
      int maxIter = 100;
      Ddi_Bdd_t *targetSubset;
      if (doExist) {
	targetSubset = Ddi_BddDup(targetNsProj);
      }
      else {
	Ddi_Bdd_t *myCare = Ddi_BddDup(newReached);
	if (targetNsProj!=NULL) {
	  Ddi_BddDiffAcc(myCare,targetNsProj);
	}
	targetSubset = 
	Ddi_AigSatCore(targetNs, myCare, NULL, itpMgr->nsvars,
		       maxIter, maxIter, 2, 1);
	if (targetNsProj==NULL) {
	  targetNsProj = Ddi_BddDup(targetSubset);
	}
	Ddi_BddOrAcc(targetNsProj,targetSubset);
	Ddi_Free(targetSubset);
	targetSubset = Ddi_BddDup(targetNsProj);
	Ddi_Free(myCare);
      }
      int countR = 0;
      if (countR) {
	int nVars = Ddi_VararrayNum(itpMgr->ns);
	Ddi_Bdd_t *rBdd = Ddi_BddMakeMono(targetSubset);
	double nr = Ddi_BddCountMinterm(rBdd, 1);
	fprintf(stdout, "#TOTAL Reached States = %g * 2^(#ref vars: %d)\n",
            nr, nVars);
	Ddi_Free(rBdd);
      }
      Ddi_BddNotAcc(targetSubset);
      Ddi_BddSubstVarsAcc(targetSubset,itpMgr->ns,itpMgr->ps);
      Ddi_BddPartInsertLast(myFromAndTr, targetSubset);
      Ddi_Free(targetSubset);
    }

    itp = Ddi_BddDup(notReached);
    Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
    Pdtutil_VerbLevel_e vNew = Pdtutil_VerbLevelUsrMed_c;
    if (verbosity > Pdtutil_VerbLevelUsrMed_c)
      Ddi_MgrSetVerbosity(ddm,vNew);
    if (useItp) {
      int sat;
      int saveItpAigCore;
      Ddi_Bdd_t *b = Ddi_BddDup(notReached);
      if (itpBoundK > 1 && lastRing>=0) {
        int nFrames = itpBoundK;
        Ddi_BddWriteMark(b,0);
        growConeBwd(itpMgr, b, lastRing+nFrames-1, lastRing,
		      NULL, NULL, 0, -1, 1 /*boundK */ );
        timeFrameShiftAcc(b, itpMgr->timeFrames->PiVars,
            itpMgr->timeFrames->PiLits, nFrames+1);
      }
      Ddi_BddOrAcc(b,notReached);
      Ddi_MgrReadOption(ddm, Pdt_DdiItpAigCore_c, &saveItpAigCore);
      Ddi_MgrSetOption(ddm, Pdt_DdiItpAigCore_c, inum, size0/2);
      Ddi_Bdd_t *itp1 = Ddi_AigSatAndWithInterpolant(myFromAndTr, b,
        itpMgr->nsvars, NULL, NULL, NULL, NULL, NULL, &sat, 0, 1, -1.0);
      Ddi_MgrSetOption(ddm, Pdt_DdiItpAigCore_c, inum, saveItpAigCore);
      if (itp1!=NULL) {
	Ddi_BddNotAcc(itp1);
	Ddi_DataCopy(itp,itp1);
      }
      Ddi_Free(b);
      Ddi_Free(itp1);
    } 
    //      Ddi_BddSetAig(fromAndTr);
    Ddi_AigOptByMonotoneCoreAcc(itp, myFromAndTr, NULL, 0, -1.0);
    Ddi_BddNotAcc(itp);
    Ddi_MgrSetVerbosity(ddm,verbosity);

    if (itp==NULL) {
      again=0;
    }
    else {
      if (itpMgr->initStub==NULL) {
        Ddi_BddOrAcc(itp,initNs);
      }
      else if (1) {
        int sat;
        Ddi_Bdd_t *itpStub = 
          Ddi_AigSatAndWithInterpolant(initStubRel, notReached,
                                       itpMgr->nsvars, NULL, NULL, NULL, NULL, NULL, &sat, 0, 1, -1.0);
        Ddi_BddOrAcc(itp,itpStub);
        Ddi_Free(itpStub);
      }

      Ddi_Free(newReached);
      newReached = Ddi_BddNot(notReached);
      int size1 = Ddi_BddSize(itp);
      if (invarNs!=NULL) {
	Ddi_Bdd_t *aux = Ddi_BddAnd(itp,invarNs);
	size1 = Ddi_BddSize(aux);
	Ddi_Free(aux);
      }
      if (size1 >= growRatio * size0) {
        if (useItp) {
          useItp=0;
        }
        else {
          again = 0;
        }
      }
      else {
        Ddi_Free(from);
        Ddi_Free(notReached);
        notReached = Ddi_BddNot(itp);
	if (invarNs!=NULL) {
	  Ddi_BddAndAcc(itp,invarNs);
	}
        if (chkSupp) {
          Ddi_Vararray_t *s = Ddi_BddSuppVararray(notReached);
          Ddi_VararrayDiffAcc(s,ns);
          Pdtutil_Assert(Ddi_VararrayNum(s)==0,"wrong supp");
          Ddi_Free(s);
        }
        
        from = Ddi_BddSubstVars(itp, ns, ps);
        if (maxItp-->0)
          useItp=1;
      }
    }
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nGFP iteration [%d] - reached size: %d\n", i, Ddi_BddSize(from));
    }
    Ddi_Free(myFromAndTr);
    Ddi_Free(itp);
  }

  Ddi_Free(tAux);
  Ddi_Free(targetNs);
  Ddi_Free(targetNsProj);
  
  if (!Ddi_BddIncluded(itpTravMgr->reached,newReached)
      || (Ddi_BddSize(newReached)<Ddi_BddSize(itpTravMgr->reached))
      ) {
    Ddi_Free(itpTravMgr->reached);
    itpTravMgr->reached = Ddi_BddDup(newReached);
    //    Ddi_BddSubstVarsAcc(newReached,ns,ps);
    //    Ddi_BddAndAcc(itpMgr->invarConstr,newReached);
    ret = 1;
  }
  Ddi_Free(newReached);

  if (chkSupp) {
    Ddi_Vararray_t *s = Ddi_BddSuppVararray(itpTravMgr->reached);
    Ddi_VararrayDiffAcc(s,ns);
    Pdtutil_Assert(Ddi_VararrayNum(s)==0,"wrong supp");
    Ddi_Free(s);
  }

  if (strengthenRings) {
    Ddi_Bddarray_t *fromRings = itpMgr->fromRings;
    Ddi_Bdd_t *newReached = Ddi_BddMakeConstAig(ddm, 0);
    if (Ddi_BddarrayNum(itpMgr->reachedRings)>0) {
      Ddi_BddOrAcc(newReached,
                   Ddi_BddarrayRead(itpMgr->reachedRings,0));
    }
#if 0
    for (int i=Ddi_BddarrayNum(itpMgr->fromRings)-1; i>lastRing; i--) {
      Ddi_BddarrayRemove(itpMgr->fromRings,i);
      //      Ddi_BddarrayRemove(itpMgr->reachedRings,i);
    }
#endif
    int chk=0;
    for (int i=1; i<=lastRing; i++) {
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(itpMgr->fromRings,i);
      if (!Ddi_BddIncluded(f_i,itpTravMgr->reached)) {
        Ddi_BddAndAcc(f_i,itpTravMgr->reached);
        ret = 1;
      }
    }

    Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
    Pdtutil_VerbLevel_e vNew = Pdtutil_VerbLevelUsrMed_c;
    if (verbosity > Pdtutil_VerbLevelUsrMed_c)
      Ddi_MgrSetVerbosity(ddm,vNew);
    // itpWeakenRingsBwd(itpMgr,lastRing-1, 1, delta, 0, 1, 0);
    if (enUpdateFromRings) { 
      itpStrengthenRingsFwd(itpMgr,1,lastRing,delta,-1,1,NULL,0,2);
    }
    // itpStrengthenRingsBwd(itpMgr,1,lastRing,delta,-1,1,NULL,0,2);
    if (chk) {
      int myChkRings = itpCheckRingsFwd(itpMgr,-1,-1,0);
      printf("RING CHECK: %d\n", myChkRings);
      Pdtutil_Assert(myChkRings,"problem with from rings");
    }
    if (igrBwdRefinement>0) {
      int start_bwd = lastRing;
      if (start_bwd > igrBwdRefinement) {
	int step = (start_bwd+1)/4;
	int maxK = (start_bwd+1)/2;
	if (step==1) step++;
	itpStrengthenRingsBwdByBmc(itpMgr,0,start_bwd,step,
				   itpMgr->delta,maxK,0,0,0);
      }
    }      
    itpStrengthenRingsFwd(itpMgr,1,lastRing,delta,-1,1,NULL,0,0);
    Ddi_MgrSetVerbosity(ddm,verbosity);
    if (chk) {
      int myChkRings = itpCheckRingsFwd(itpMgr,-1,-1,0);
      printf("RING CHECK: %d\n", myChkRings);
      Pdtutil_Assert(myChkRings,"problem with from rings");
    }
    int tryDecrease = lastRing == Ddi_BddarrayNum(itpMgr->fromRings)-1;
    int last = tryDecrease ? lastRing-1 : lastRing;
    for (int i=1; i<=last; i++) {
      Ddi_Bdd_t *f_i = Ddi_BddarrayRead(itpMgr->fromRings,i);
      Ddi_BddOrAcc(newReached,f_i);
    }
    if (tryDecrease) {
      Ddi_Bdd_t *myFrom = Ddi_BddSubstVars(newReached, ns, ps);
      Ddi_Bdd_t *notR = Ddi_BddNot(newReached);
      int fp = !Ddi_AigSatAnd(fromAndTr, notR, myFrom);
      if (fp) {
        // fix point reached - rremove last ring
        Ddi_BddarrayRemove(itpMgr->fromRings,lastRing);
        lastRing--;
        *lastRingP = lastRing;
      }
      else {
        Ddi_Bdd_t *f_i = Ddi_BddarrayRead(itpMgr->fromRings,
                                          lastRing);
        Ddi_BddOrAcc(newReached,f_i);
      }
      Ddi_Free(myFrom);
      Ddi_Free(notR);
    }
    
    if (enUpdateFromRings &&
        !Ddi_BddIncluded(itpTravMgr->reached,newReached)) {
      Ddi_Bdd_t *myFrom = Ddi_BddSubstVars(newReached, ns, ps);
      Ddi_Bdd_t *notR = Ddi_BddNot(newReached);
      int fp = 0||!Ddi_AigSatAnd(fromAndTr, notR, myFrom);
      Ddi_Free(notR);
      Ddi_Free(myFrom);
      while (!fp) {
	if (Ddi_BddarrayNum(itpMgr->fromRings)>(lastRing+1)) {
	  Ddi_Bdd_t *f_l = Ddi_BddarrayRead(itpMgr->fromRings,lastRing+1);
	  Ddi_BddAndAcc(f_l,itpTravMgr->reached);
	}
	else {
	  Ddi_BddarrayWrite(itpMgr->fromRings,lastRing+1,
                          itpTravMgr->reached);
	}
        itpStrengthenRingsFwd(itpMgr,lastRing,lastRing+1,
                              delta,-1,1,NULL,0,0);
        lastRing++;
        *lastRingP = lastRing;
        Ddi_Bdd_t *f_i = Ddi_BddarrayRead(itpMgr->fromRings,
                                          lastRing);
        Ddi_BddOrAcc(newReached,f_i);
        Ddi_Free(myFrom);
        Ddi_Free(notR);
        myFrom = Ddi_BddSubstVars(newReached, ns, ps);
        notR = Ddi_BddNot(newReached);
        fp = !Ddi_AigSatAnd(fromAndTr, notR, myFrom);
      }
      if (fp) {
        Ddi_Free(itpTravMgr->reached);
        itpTravMgr->reached = Ddi_BddDup(newReached);
        //        Ddi_BddSubstVarsAcc(newReached,ns,ps);
        //        Ddi_BddAndAcc(itpMgr->invarConstr,newReached);
        ret = 1;
      }
      Ddi_Free(myFrom);
      Ddi_Free(notR);
    }
    Ddi_Free(newReached);
  }

  if (!Ddi_BddIncluded(itpTravMgr->reached,itpTravMgr->careBwd)) {
    Ddi_BddAndAcc(itpTravMgr->reached,itpTravMgr->careBwd);
  }
  if (chk0) {
    int sat = checkRingIsFixPoint(itpMgr->ps,itpMgr->ns,
                                  delta,
                                  itpTravMgr->reached);
    Pdtutil_Assert(!sat,"problem with fox point for reached");
    Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->reached,
                                   itpTravMgr->careBwd),
                   "problem with reached inclusion in care");
  }
  
  Ddi_Free(saveR);
  Ddi_Free(saveF);
  Ddi_Free(initStubRel);
  Ddi_Free(initNs);
  Ddi_Free(notReached);
  Ddi_Free(from);
  Ddi_Free(myDelta);
  Ddi_Free(invarConstr);
  Ddi_Free(invarPs);
  Ddi_Free(invarNs);

  Ddi_Free(fromAndTr);
  Ddi_Free(deltaNs);
  Ddi_Free(myOne);
  Ddi_Free(myZero);

  return ret;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int checkRingIsFixPoint(
  Ddi_Vararray_t *ps,
  Ddi_Vararray_t *ns,
  Ddi_Bddarray_t *delta,
  Ddi_Bdd_t * ring
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(ring);
  Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
  Ddi_Bdd_t *invarPs = Ddi_BddMakeLiteralAig(iv, 1);
  Ddi_Bdd_t *ringPs = Ddi_BddSubstVars(ring,ns,ps);
  Ddi_Bdd_t *notRing = Ddi_BddNot(ringPs);
  Ddi_BddAndAcc(ringPs,invarPs);
  Ddi_BddAndAcc(notRing,invarPs);
  Ddi_BddComposeAcc(notRing,ps,delta);
  int sat = Ddi_AigSatAnd(ringPs,notRing,NULL);
  Ddi_Free(notRing);
  Ddi_Free(ringPs);
  Ddi_Free(invarPs);
  return sat;

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpCheckRingsFwd(
  Trav_ItpMgr_t * itpMgr,
  int i0,
  int i1,
  int checkFp
)
{
  //  Ddi_Bddarray_t * delta = itpMgr->delta;
  Ddi_Bddarray_t * delta = (itpMgr->deltaAbstr && itpMgr->delta0)?
    itpMgr->delta0:itpMgr->delta;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(delta);
  int i, nFrames, timeMark;
  Ddi_Bddarray_t *unroll = NULL;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Ddi_Bdd_t *invarConstr=NULL;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  int start_i = i0;
  int end_i = i1;
  Ddi_Bdd_t *invarPs=NULL, *invarNs=NULL;
  Ddi_Bdd_t *reached = NULL;
  
  int useItp = 0;
  int chk = 1;
  int useRingConstr = 1;
  int ret = 1;
  int enDbg = 0;
  static int nCalls = 0;
  static Ddi_Bddarray_t *prevRings = NULL;

  if (start_i<0) start_i = 1;
  if (end_i<0) end_i = Ddi_BddarrayNum(itpMgr->fromRings) - 1;

  if (start_i>end_i) return 1;

  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bddarray_t *deltaNs = Ddi_BddarrayCompose(delta, ps, itpMgr->nsLit);

  if (checkFp) {
    reached = Ddi_BddMakeConstAig(ddm, 0);
  }
  
  nCalls++;

  Pdtutil_Assert(start_i <= end_i,
    "wrong start/end indexes in itp strengthening");

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nITP checking %d -> %d (nc: %d)\n", start_i, end_i, nCalls);
  }


  if (itpMgr->invarConstr!=NULL && !Ddi_BddIsOne(itpMgr->invarConstr)) {
    invarConstr = Ddi_BddSubstVars(itpMgr->invarConstr,
				     itpMgr->ps,itpMgr->ns);
  }
  if (1) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    
    if (iv != NULL) {
      invarPs = Ddi_BddMakeLiteralAig(iv, 1);
      invarNs = Ddi_BddMakeLiteralAig(ivNs, 1);
      if (invarConstr==NULL) {
	invarConstr = Ddi_BddMakeConstAig(ddm, 1);
      }      
      Ddi_BddAndAcc(invarConstr, invarPs);
      Ddi_BddAndAcc(invarConstr, invarNs);
    }
  }

  while(Ddi_BddIsOne(Ddi_BddarrayRead(itpMgr->fromRings, end_i))) {
    end_i--;
  }
  if (start_i>end_i) {
    ret = 1;
    goto end;
  }
  for (i = start_i; i < end_i; i++) {
    Ddi_Bdd_t *currRing = Ddi_BddarrayRead(itpMgr->fromRings, i);
    Ddi_Bdd_t *nextRing = Ddi_BddarrayRead(itpMgr->fromRings, i + 1);    
    if (1 && (Trav_MgrReadFromSelect(itpMgr->travMgr) ==
              Trav_FromSelectReached_c)) {
      int included = Ddi_BddIncluded(currRing,nextRing);
      ret &= included;
      Pdtutil_Assert(included,"error in reached set inclusion");
    }

    if (1 || !Ddi_BddIsOne(currRing)) {

      Ddi_Bdd_t *itp, *fromAndTr;
      Ddi_Bdd_t *myCone = Ddi_BddNot(nextRing);
      Ddi_Bdd_t *fwdFrom = Ddi_BddDup(currRing);
      Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(deltaNs);

      if (invarNs!=NULL) {
	Ddi_BddAndAcc(myCone,invarNs);
	//Ddi_AigarrayConstrainCubeAcc(myDelta,invarNs);
      }
      if (useRingConstr > 0 && i > 0) {
        if (Ddi_BddarrayNum(itpMgr->eqRings) > i) {
          Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i);

          if (eqConstr != NULL) {
            Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
            Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

            Ddi_BddComposeAcc(fwdFrom, vars, subst);
            Ddi_BddarrayComposeAcc(myDelta, vars, subst);
          }
        }
      }

      Ddi_BddSubstVarsAcc(fwdFrom, ns, ps);

      if (itpMgr->invarConstr!=NULL && !Ddi_BddIsOne(itpMgr->invarConstr)) {
	Ddi_BddAndAcc(fwdFrom,itpMgr->invarConstr);
      }

      Ddi_BddarraySubstVarsAcc(myDelta, ns, ps);
      fromAndTr = Ddi_BddRelMakeFromArray(myDelta, ns);

      if (useRingConstr > 0 && i > 0) {
        if (Ddi_BddarrayNum(itpMgr->eqRings) > i + 1) {
          Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i + 1);

          if (eqConstr != NULL) {
            Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
            Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

            Ddi_BddComposeAcc(myCone, vars, subst);
            Ddi_BddComposeAcc(fromAndTr, vars, subst);
          }
        }
      }

      Ddi_BddPartInsertLast(fromAndTr, fwdFrom);

      if (checkFp) {
        Ddi_BddOrAcc(reached,currRing);
        Ddi_Bdd_t *notReached = Ddi_BddNot(reached);
        int fp = !Ddi_AigSatAnd(fromAndTr, notReached, NULL);
        Pdtutil_Assert(!fp, "fix point reached");
        Ddi_Free(notReached);
      }
      
      int sat = Ddi_AigSatAnd(fromAndTr, myCone, NULL);
      int load = 0;
      if (enDbg && (sat||load)) {
	Ddi_Bdd_t *cex;
	if (load) {
	  cex = Ddi_AigNetLoadAiger(ddm, NULL, "itp-cex.aig");
	}
	else {
	  Ddi_Bdd_t *prod = Ddi_BddAnd(fromAndTr,myCone);
	  cex = Ddi_AigSatWithCex(prod);
	  Ddi_Free(prod);
	  Ddi_AigNetStoreAiger(cex, 0, "itp-cex.aig");
	}
	Ddi_Varset_t *psv = Ddi_VarsetMakeFromArray(itpMgr->ps);
	Ddi_Varset_t *nsv = Ddi_VarsetMakeFromArray(itpMgr->ns);
	Ddi_Bdd_t *p0 = Ddi_BddExistProject(cex,psv);
	Ddi_Bdd_t *p1 = Ddi_BddExistProject(cex,nsv);
	if (itpMgr->hints.hintsEnabled) {
	  int iConstr0 = itpMgr->hints.invar0_i;
	  int iConstr = itpMgr->hints.invar_i;
	  Ddi_Bdd_t *deltaConstr0 = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->delta,iConstr0));
	  Ddi_Bdd_t *deltaConstr = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->delta,iConstr));
	  Ddi_Var_t *cvar0Ns = Ddi_VararrayRead(itpMgr->ns,iConstr0); 
	  Ddi_AigConstrainCubeAcc(deltaConstr0,p0);
	  Ddi_AigConstrainCubeAcc(deltaConstr,p0);
	  Ddi_BddCofactorAcc(p1,cvar0Ns,0);
	  Ddi_Free(deltaConstr);
	  Ddi_Free(deltaConstr0);
	}
	Ddi_BddSubstVarsAcc(p0,itpMgr->ps,itpMgr->ns);
	Ddi_Free(p0);
	Ddi_Free(p1);
	Ddi_Free(psv);
	Ddi_Free(nsv);
	Ddi_Free(cex);
      }
      Pdtutil_Assert(!chk || !sat,
        "unsat required");

      ret &= !Ddi_AigSatAnd(fromAndTr,myCone,0);

      Ddi_Free(myCone);
      Ddi_Free(myDelta);
      Ddi_Free(fromAndTr);
      Ddi_Free(fwdFrom);

    }
  }

  if (enDbg) {
    Ddi_Free(prevRings);
    prevRings = Ddi_BddarrayDup(itpMgr->fromRings);
  }

 end:
  
  Ddi_Free(reached);
  Ddi_Free(deltaNs);
  Ddi_Free(invarConstr);
  Ddi_Free(invarPs);
  Ddi_Free(invarNs);

  Ddi_Free(myOne);
  Ddi_Free(myZero);

  return ret;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpCheckRingsBwd(
  Trav_ItpMgr_t * itpMgr,
  int step,
  int bi0,
  int bi1
)
{
  Ddi_Bddarray_t * delta = itpMgr->delta;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(delta);
  int i, nFrames, timeMark;
  Ddi_Bddarray_t *unroll = NULL;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  int start_i;
  int end_i;
  Ddi_Bdd_t *invarPs=NULL, *invarNs=NULL;

  int useItp = 0;
  int chk = 1;
  int useRingConstr = 1;
  int ret = 1;
  int enDbg = 0;
  static int nCalls = 0;
  static Ddi_Bddarray_t *prevRings = NULL;

  start_i = step;
  
  if (start_i<=0) start_i = 1;

  end_i = start_i + bi1-bi0-1;
  
  nCalls++;

  if (start_i>end_i) return 1;

  if (Ddi_BddarrayNum(itpMgr->bckReachedRings)<=bi1) return 1;

  Pdtutil_Assert(start_i <= end_i,
    "wrong start/end indexes in itp strengthening");

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nBWD ITP checking %d -> %d (nc: %d)\n", start_i, end_i, nCalls);
  }

  Ddi_Bdd_t *bR0 = Ddi_BddarrayRead(itpMgr->bckReachedRings,bi0);
  Ddi_Bdd_t *bR1 = Ddi_BddarrayRead(itpMgr->bckReachedRings,bi1);

  if (bR0==NULL || bR1==NULL) return 1;

  Ddi_Bdd_t *cone = Ddi_BddDup(bR0);
  Ddi_Bdd_t *ring = Ddi_BddNot(bR1);
  Ddi_BddSubstVarsAcc(ring,ps,ns);
  Ddi_BddSubstVarsAcc(cone,ps,ns);
  Ddi_BddWriteMark (cone, 0);

  growConeBwd(itpMgr, cone, end_i, start_i, NULL,
	      NULL, 0, -1, 0 /*boundK */ );
  
  ret = Ddi_AigSatAnd(cone,ring,NULL);
  Ddi_Free(cone);
  Ddi_Free(ring);

  return ret;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpCheckTr(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t *trA,
  Ddi_Bddarray_t *delta
)
{
  int ret = 1;
  Ddi_Bdd_t *tr1 = Ddi_BddRelMakeFromArray(delta, itpMgr->ns);
  Ddi_BddSubstVarsAcc(tr1,itpMgr->pi,itpMgr->auxVarPis);
  for (int i=0; i<Ddi_BddPartNum(tr1); i++) {
    Ddi_Bdd_t *ref_i = Ddi_BddarrayRead(trA,i);
    Ddi_Bdd_t *tr1_i = Ddi_BddPartRead(tr1,i);
    if (!Ddi_BddEqualSat(ref_i,tr1_i)) {
      printf("Difference found - index: %d\n", i);
      ret = 0;
    }
  }
  Ddi_Free(tr1);
  return ret;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpCheckConeAtRing(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *ring,
  Ddi_Bdd_t *cone, 
  int iRing,
  int k,
  int boundK
)
{
  Ddi_Mgr_t *ddm = itpMgr->ddiMgr;
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int myend = iRing;
  int mystart = iRing+k-1;
  int useRingConstr = growCone != 1 ? 2 : 0;
  int chk, chk2 = 0;;
  Ddi_Bdd_t *chkCone = Ddi_BddDup(itpMgr->target);
  Ddi_Bdd_t *chkCone2 = NULL, *chkConeSave=NULL;
  static int nc = 0;

  if (cone!=NULL) {
    Ddi_Free(chkCone);
    chkCone = Ddi_BddDup(cone);
  }
  nc++;

  Ddi_BddSubstVarsAcc(chkCone, itpMgr->ps, itpMgr->ns);
  Ddi_BddWriteMark (chkCone, 0);

  chkCone2 = Ddi_BddDup(chkCone);
  chkConeSave = Ddi_BddDup(chkCone);
  int nh = itpMgr->hints.hintsNum;
  //  itpMgr->hints.hintsNum=0;
  growConeBwd(itpMgr, chkCone, mystart, myend, NULL,
	      itpMgr->initStub, 
	      useRingConstr, -1, boundK /*boundK */ );
  itpMgr->hints.hintsNum=nh;
  if (boundK) {
    Ddi_Var_t *pvarNs = Ddi_VarFromName(ddm,
                          "PDT_BDD_INVARSPEC_VAR$NS");
    Ddi_Bdd_t *pLit = Ddi_BddMakeLiteralAig(pvarNs, 1);
    Ddi_AigAndCubeAcc(chkCone,pLit);
    Ddi_Free(pLit);
  }

  chk = Ddi_AigSatAnd(chkCone,ring,0);
  if (!chk) {
    Ddi_Bdd_t *tr = Ddi_BddDup(itpMgr->tr);
    itpMgrApplyRingEq(itpMgr,tr,NULL,NULL,myend+1,0);
    itpMgrApplyRingEq(itpMgr,tr,NULL,itpMgr->ps,myend,0);
    growConeBwd(itpMgr, chkCone2, mystart, myend+1, NULL,
	      itpMgr->initStub, 
	      useRingConstr, -1, boundK /*boundK */ );
    Ddi_Bdd_t *ring2 = Ddi_BddDup(ring);
    Ddi_BddSubstVarsAcc(ring2, itpMgr->ns, itpMgr->ps);
    int chk2 = Ddi_AigSatAnd(chkCone2,ring2,tr);
    if (chk2) {
      Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(tr, chkCone2,
            ring2, NULL, 100, NULL);
      Ddi_Bdd_t *cex2 = Ddi_BddDup(cex);
      Ddi_Varset_t *nsv = Ddi_VarsetMakeFromArray(itpMgr->ns);
      Ddi_Varset_t *psv = Ddi_VarsetMakeFromArray(itpMgr->ps);
      int iConstr0 = itpMgr->hints.invar0_i;
      int iConstr = itpMgr->hints.invar_i;
      //      int iProp = iConstr+1;
      int iProp = Ddi_BddarrayNum(itpMgr->delta)-1;
      Ddi_Bdd_t *deltaTarget = Ddi_BddNot(
				Ddi_BddarrayRead(itpMgr->delta,iProp));
      Ddi_BddCubeExistProjectAcc(cex,psv);
      Ddi_BddCubeExistProjectAcc(cex2,nsv);
      Ddi_AigConstrainCubeAcc(deltaTarget,cex);

      growConeBwd(itpMgr, chkConeSave, mystart, myend, NULL,
	      itpMgr->initStub, 
	      useRingConstr, -1, boundK /*boundK */ );

      Ddi_Free(psv);
      Ddi_Free(nsv);
      Ddi_Free(cex);
      Ddi_Free(cex2);
      Ddi_Free(deltaTarget);
    }
    Pdtutil_Assert(!chk2,"unsound cone");
    Ddi_Free(ring2);
    Ddi_Free(tr);
  }

  Ddi_Free(chkCone2);
  Ddi_Free(chkConeSave);
  if (chk && k==1) {
    int n = Ddi_BddarrayNum(itpMgr->delta);
    Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(chkCone,
            ring, NULL, NULL, 100, NULL);
    Ddi_Varset_t *nsv = Ddi_VarsetMakeFromArray(itpMgr->ns);
    Ddi_Bddarray_t *myDelta = Ddi_BddarrayDup(itpMgr->delta);
    Ddi_Bddarray_t *myDelta0 = Ddi_BddarrayDup(itpMgr->delta);
    Ddi_Bdd_t *myTarget, *myConstr;
    Ddi_Bddarray_t *lA = itpMgr->timeFrames->PiLits[1];
    Ddi_BddarrayComposeAcc(myDelta, itpMgr->pi, lA);
    myTarget = Ddi_BddNot(Ddi_BddarrayRead(myDelta,n-1));
    myConstr = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->delta,n-2));
    Ddi_BddAndAcc(myTarget,myConstr);
    Ddi_BddSubstVarsAcc(myConstr,itpMgr->ps,itpMgr->ns);

    int res = Ddi_AigSatAnd(chkCone,ring,myConstr);
    Ddi_BddarrayComposeAcc(myDelta, itpMgr->ps, itpMgr->delta);
    Ddi_BddarraySubstVarsAcc(myDelta,itpMgr->ps,itpMgr->ns);
    Ddi_BddarraySubstVarsAcc(myDelta0,itpMgr->ps,itpMgr->ns);

    Ddi_AigarrayConstrainCubeAcc(myDelta, cex);
    Ddi_AigarrayConstrainCubeAcc(myDelta0, cex);
    Ddi_AigConstrainCubeAcc(myTarget, cex);
    Ddi_BddSubstVarsAcc(myTarget,itpMgr->ps,itpMgr->ns);
    if (1) {
      Ddi_Vararray_t *supp = Ddi_BddSuppVararray(myTarget);
      Ddi_VararrayWriteMark(supp, 1);
      Ddi_Bdd_t *cube = Ddi_BddMakeConstAig(ddm, 1);
      int i;
      for (i=0; i<Ddi_VararrayNum(itpMgr->ns); i++) {
	Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->ns,i);
	if (Ddi_VarReadMark(v)==0) continue;
	Ddi_Bdd_t *val = Ddi_BddarrayRead(myDelta0,i);
        if (Ddi_BddIsConstant(val)) {
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, Ddi_BddIsOne(val));
	  Ddi_BddAndAcc(cube,lit);
	  Ddi_Free(lit);
	}
	else {
	  printf("not constant: %d\n", i);
	}
      }
      Ddi_VararrayWriteMark(supp, 0);

      Ddi_Bdd_t *l = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(itpMgr->ns,n-2),1);
      //      Ddi_BddAndAcc(cube,l);
      Ddi_Bdd_t *ringPs = Ddi_BddSubstVars(ring,itpMgr->ns,itpMgr->ps);
      int res2 = Ddi_AigSatAnd(itpMgr->trAux,ringPs,cube);
      Ddi_BddComposeAcc(cube,itpMgr->ns,itpMgr->delta);
      Ddi_BddSubstVarsAcc(cube,itpMgr->ps,itpMgr->ns);
      int res1 = Ddi_AigSatAnd(chkCone,ring,cube);

      Ddi_Free(ringPs);
      Ddi_Free(l);
      Ddi_Free(supp);
      Ddi_Free(cube);
    }
    Ddi_BddExistProjectAcc(cex,nsv);
    Ddi_Free(cex);
    Ddi_Free(nsv);
    Ddi_Free(myDelta);
    Ddi_Free(myDelta0);
  }
  Ddi_Free(chkCone);
  if (chk2) {
    Ddi_Bddarray_t *myDelta = Ddi_BddarraySubstVars(itpMgr->delta,
						    itpMgr->ps,itpMgr->ns);
    int n = Ddi_BddarrayNum(myDelta);
    Ddi_Bdd_t *target = Ddi_BddNot(Ddi_BddarrayRead(myDelta,n-1));
    Ddi_Bdd_t *deltaConstr = Ddi_BddarrayRead(myDelta,n-2);
    if (Ddi_AigSatAnd(ring,target,NULL)) {
      int res = Ddi_AigSatAnd(ring,target,deltaConstr);
      printf("target reached: constr %s\n", res?"OK":"NO");
    }
    Ddi_Free(myDelta);
    Ddi_Free(target);
  }
  return chk;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
itpBwdRingPreimg(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *bRing,
  Ddi_Bdd_t *prevRing,
  int ring_i,
  int bound
)
{
  Ddi_Mgr_t *ddm = itpMgr->ddiMgr;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);

  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int myend, mystart;
  int useRingConstr = 0; // DISABLED!
  Ddi_Bdd_t *myCone = NULL;
  int boundK=Trav_MgrReadIgrGrowCone(travMgr)>2, sat, chk=0;
  Ddi_Bdd_t *splitB=NULL, *nextRingConstr=NULL;
  int i = ring_i+1;

  static int nc = 0;
  nc++;

  myend = ring_i+1;
  mystart = ring_i+bound-1;

  myCone = Ddi_BddDup(itpMgr->target);
  Ddi_BddSubstVarsAcc(myCone, itpMgr->ps, itpMgr->ns);
  Ddi_BddWriteMark(myCone, 0);

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nPREIMG bwd ring %d\n", bound);
  }

  growConeBwd(itpMgr, myCone, mystart, myend, NULL,
	      NULL, 
	      useRingConstr, -1, boundK /*boundK */ );

  Ddi_Bdd_t *itp, *fromAndTr, *fromAndTrConstr;
  Ddi_Bdd_t *fwdFrom = Ddi_BddNot(bRing);

  Ddi_Bddarray_t *myDelta = Ddi_BddarraySubstVars(itpMgr->delta,
                                                  itpMgr->ps,
                                                  itpMgr->ns);

  if (itpMgr->invarConstr!=NULL && !Ddi_BddIsOne(itpMgr->invarConstr)) {
    Ddi_Bdd_t *myConstr = Ddi_BddDup(itpMgr->invarConstr);
    Ddi_BddSubstVarsAcc(myConstr, itpMgr->ps, itpMgr->ns);
    Ddi_BddAndAcc(fwdFrom,myConstr);
    Ddi_Free(myConstr);
  }

  if (useRingConstr > 0 && i > 0) {
    if (Ddi_BddarrayNum(itpMgr->eqRings) > i) {
      Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i);
      
      if (eqConstr != NULL) {
        Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
        Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);
        
        Ddi_BddComposeAcc(fwdFrom, vars, subst);
        Ddi_BddarrayComposeAcc(myDelta, vars, subst);
      }
    }
  }

  Ddi_BddSubstVarsAcc(fwdFrom, itpMgr->ns, itpMgr->ps);
  Ddi_BddarraySubstVarsAcc(myDelta, itpMgr->ns, itpMgr->ps);
  Ddi_BddarraySubstVarsAcc(myDelta, itpMgr->pi, itpMgr->auxVarPis);

  fromAndTr = Ddi_BddRelMakeFromArray(myDelta, itpMgr->ns);
  if (1) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    if (iv != NULL) {
      Ddi_Bdd_t *invarIn = Ddi_BddMakeLiteralAig(iv, 1);
      Ddi_BddAndAcc(fromAndTr, invarIn);
      Ddi_Free(invarIn);
    }
  }

  if (useRingConstr > 0 && i > 0) {
    if (Ddi_BddarrayNum(itpMgr->eqRings) > i + 1) {
      Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, i + 1);
      
      if (eqConstr != NULL) {
        Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
        Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);
        
        Ddi_BddComposeAcc(myCone, vars, subst);
        Ddi_BddComposeAcc(fromAndTr, vars, subst);
        nextRingConstr = Ddi_BddDup(eqConstr);
      }
    }
  }
  
  Ddi_BddPartInsertLast(fromAndTr, fwdFrom);
  Pdtutil_Assert(!chk || !Ddi_AigSatAnd(fromAndTr, myCone, NULL),
                 "unsat required");
  fromAndTrConstr = Ddi_BddDup(fromAndTr);
  if (prevRing!=NULL) {
    Ddi_BddPartInsertLast(fromAndTrConstr, prevRing);
  }
  
  int saveItpNnfAbstrAB = ddm->settings.aig.itpNnfAbstrAB;
  int saveItpReverse = ddm->settings.aig.itpReverse;
  // set just B
  ddm->settings.aig.itpNnfAbstrAB = 1;
  //  ddm->settings.aig.itpReverse = 1;
  itp = Ddi_AigSatAndWithInterpolant(fromAndTrConstr, myCone,
           itpMgr->nsvars, NULL, NULL, NULL, NULL, NULL,
                                     &sat, 0, 1, -1.0);
  ddm->settings.aig.itpNnfAbstrAB = saveItpNnfAbstrAB;
  ddm->settings.aig.itpReverse = saveItpReverse;

  if (nextRingConstr != NULL) {
    Ddi_BddSetAig(nextRingConstr);
    Ddi_BddAndAcc(itp, nextRingConstr);
    Ddi_Free(nextRingConstr);
  }
  
  Ddi_BddNotAcc(itp);
  if (prevRing != NULL) {
    int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
    //    ddm->settings.aig.aigCnfLevel = 1;
    Ddi_BddSetAig(fromAndTr);
#if 0
    Ddi_BddNotAcc(prevRing);
    Ddi_BddOrAcc(fromAndTr,prevRing);
    Ddi_BddNotAcc(prevRing);
#endif
    Ddi_BddAndAcc(itp, prevRing);
    Ddi_AigOptByMonotoneCoreAcc(itp,fromAndTr,NULL,0,-1.0);
    ddm->settings.aig.aigCnfLevel = aigCnfLevel;
  }

  Ddi_Free(myCone);
  Ddi_Free(fwdFrom);
  Ddi_Free(myDelta);

  Ddi_Free(fromAndTr);
  Ddi_Free(fromAndTrConstr);

  return itp;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpStrengthenBwdRing(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *splitCone
)
{
  Ddi_Mgr_t *ddm = itpMgr->ddiMgr;
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);

  Ddi_Bddarray_t *bRings = itpMgr->bckReachedRings;
  Ddi_Bdd_t *bRing = NULL;
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int myend, mystart, markUp, bwdRing_j;
  int useRingConstr = 0; // DISABLED!
  Ddi_Bdd_t *topCone = NULL;
  int boundK=1;
  Ddi_Bdd_t *splitB=NULL;

  static int nc = 0;
  nc++;

  Pdtutil_Assert(Ddi_BddReadComposeF(splitCone)!=NULL,"missing split cone");
  splitB = Ddi_BddReadComposeF(splitCone);
  Pdtutil_Assert(splitB!=NULL,"missing split cone");
  markUp = Ddi_BddReadMark(splitB);

  myend = 1;
  bwdRing_j = markUp;
  if (Ddi_BddarrayNum(bRings)<=bwdRing_j) return 0;
  bRing = Ddi_BddarrayRead(bRings,bwdRing_j);
  if (bRing == NULL) return 0;


  mystart = myend+markUp-1;

  topCone = Ddi_BddDup(itpMgr->target);
  Ddi_BddSubstVarsAcc(topCone, itpMgr->ps, itpMgr->ns);
  Ddi_BddWriteMark (topCone, 0);

  Ddi_BddWriteMark(topCone,0);

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nSTRENGTHENING bwd ring %d\n", markUp);
  }

  growConeBwd(itpMgr, topCone, mystart, myend, NULL,
	      NULL, 
	      useRingConstr, -1, boundK /*boundK */ );

  Ddi_AigOptByMonotoneCoreAcc(bRing,topCone,NULL,1,-1.0);
  Ddi_Free(topCone);

  return 1;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpLookaheadRingsFwd(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t * kCone,
  int start_i,
  int step,
  int useRingConstr,
  int boundK
)
{
  Trav_ItpMgr_t * itpMgr = itpTravMgr->itpMgr;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(itpMgr->delta);
  int i, nFrames, timeMark;
  Ddi_Bddarray_t *unroll = NULL;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;
  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
  Ddi_Bdd_t *currRing = NULL, *stepRing = NULL, *splitCone;
  Ddi_Bdd_t *topCone=NULL;
  Ddi_Bddarray_t *splitU=NULL;
  Ddi_Vararray_t *splitV=NULL;
  Ddi_Varset_t *splitVars=NULL;
  int coneBoundOK, targetBoundOK;
  int ret = start_i+step;
 
  int useItp = 0;
  int chk = 0;
  int enNew = 0;

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nITP lookahead %d+%d -> %d\n", start_i, step, start_i+step);
  }

  if (itpMgr->fromRings==NULL) return 0;
  if (Ddi_BddarrayNum(itpMgr->fromRings)<=start_i) return 0;
  currRing = Ddi_BddarrayRead(itpMgr->fromRings, start_i);
  while (Ddi_BddarrayNum(itpMgr->fromRings)<=start_i+step) {
    Ddi_BddarrayInsertLast(itpMgr->fromRings,myOne);
  }

  stepRing = Ddi_BddarrayRead(itpMgr->fromRings, start_i+step);
  targetBoundOK = -1;
  if (kConeRings != NULL) {
    int k, np = Ddi_BddPartNum(kConeRings);
    Pdtutil_Assert(np>start_i+step,"not enough rings");
    int d = Ddi_BddReadMark(Ddi_BddPartRead(kConeRings, np - 1));
    int safe = Trav_ItpMgrReadConeBoundOK(itpMgr,start_i+step-1);
    targetBoundOK = d+np-(start_i+step);
    if (enNew && (safe == targetBoundOK)) {
      start_i += step-1;
      step = 1;
      currRing = Ddi_BddarrayRead(itpMgr->fromRings, start_i);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
	printf("\nITP new lookahead %d+%d -> %d\n", start_i, step, start_i+step);
      }
    }
    else {
      int i;
      for (i=1; i<step; i++) {
	safe = Trav_ItpMgrReadConeBoundOK(itpMgr,start_i+step-i);
	targetBoundOK++;
	if (safe==targetBoundOK) {
	  // no computation needed
	  ret = start_i+step-i;
	  currRing = NULL;
	  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
	    printf("\nITP lookahead no computation -> %d\n", ret);
	  }
	  break;
	}
      }
    }
  }

  if (currRing!=NULL && !Ddi_BddIsOne(currRing)) {

    Ddi_Bdd_t *fromAndTr, *itpSplit;
    Ddi_Bdd_t *fwdFrom = Ddi_BddDup(currRing);
    Ddi_Vararray_t *nsSupp;
    int sat, size1, sizeRing;
    Ddi_Bdd_t *aux = NULL;

    splitCone = itpImgGetCone(itpTravMgr, kCone, kConeRings, NULL, start_i, 
			      3, step, 0, 0, -1, 0);
    Pdtutil_Assert(Ddi_BddReadComposeF(splitCone)!=NULL,
		   "split cone needed");

    topCone = Ddi_BddDup(Ddi_BddReadComposeF(splitCone));
    splitU = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(splitCone));
    splitV = Ddi_VararrayDup(Ddi_BddReadComposeVars(splitCone));
    fromAndTr = Ddi_BddRelMakeFromArray(splitU,splitV);
    splitVars = Ddi_VarsetMakeFromArray(splitV);
    Ddi_BddSubstVarsAcc(fwdFrom, ns, ps);

    if (0) {
      Ddi_Var_t *v1 = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
      Ddi_Var_t *v2 = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
      Ddi_Var_t *v3 = Ddi_VarFromName(ddm, "l252$NS");
      Ddi_Bdd_t *l1 = Ddi_BddMakeLiteralAig(v1, 1);
      Ddi_Bdd_t *l2 = Ddi_BddMakeLiteralAig(v2, 1);
      Ddi_Bdd_t *l3 = Ddi_BddMakeLiteralAig(v3, 1);
      aux = Ddi_BddAnd(l1,l2);
      Ddi_BddAndAcc(aux,l3);
      Ddi_Free(l1);
      Ddi_Free(l2);
      Ddi_Free(l3);
    }

    if (useRingConstr > 0 && i > 0) {
      if (Ddi_BddarrayNum(itpMgr->eqRings) > start_i+step) {
	Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, 
					       start_i+step);
	
	if (eqConstr != NULL) {
	  Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
	  Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);
	  
	  Ddi_BddComposeAcc(topCone, vars, subst);
	  Ddi_BddComposeAcc(fromAndTr, vars, subst);
	}
      }
    }

    Ddi_BddPartInsertLast(fromAndTr, fwdFrom);

    
    itpSplit =
      Ddi_AigSat22AndWithInterpolant(NULL,fromAndTr,topCone,NULL,
				   splitVars, NULL,NULL,0,
				   stepRing,NULL,
                                     &sat, 0, 1, 0, -1.0);

    if (itpSplit==NULL) {
      ret = 0;
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
	printf("\nitp lookahead SAT\n\n");
      }
    }
    else {
      Pdtutil_Assert(itpSplit!=NULL,"NULL itpSplit");
      Ddi_BddAndAcc(itpSplit, stepRing);
#if 1
      Ddi_AigOptByMonotoneCoreAcc(itpSplit,fromAndTr,NULL,
				  1,-1.0);
#endif
      sizeRing = Ddi_BddSize(stepRing);
      size1 = Ddi_BddSize(itpSplit);

      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
	printf("ITP lookahead ring [%d] - ring sz: %d->%d\n", 
	       start_i+step, sizeRing, size1);
	fflush(stdout);
      }
      
      Ddi_DataCopy(stepRing, itpSplit);
      coneBoundOK = Ddi_BddReadMark(splitCone) - (step);
      Trav_ItpMgrSetConeBoundOK(itpMgr,start_i+step,coneBoundOK);    
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
	printf("lookahead ring %d - safe for bound %d\n", 
	       start_i+step, coneBoundOK);
      }

      if (0) {
	Ddi_BddNotAcc(itpSplit);
	Ddi_BddComposeAcc(itpSplit,splitV,splitU);
	Pdtutil_Assert(!Ddi_AigSatAnd(fwdFrom,itpSplit,NULL),"split itp problem");
      }
    }
    Ddi_Free(itpSplit);
    Ddi_Free(fromAndTr);
    Ddi_Free(fwdFrom);
    
    Ddi_Free(splitU);
    Ddi_Free(splitV);
    Ddi_Free(splitVars);
    Ddi_Free(splitCone);
    Ddi_Free(topCone);
  }

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nitp lookahead ended\n\n");
  }

  Ddi_Free(myOne);
  Ddi_Free(myZero);

  return ret;

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
igrAbstrRef(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * myConeAbstr,
  int start_j,
  int useEqRings,
  Ddi_Bdd_t *abstrCex,
  int enPrio,
  float timeLimit,
  int *cexUsedP
)
{
  /* cegar/pba */
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int abstrRef = Trav_MgrReadAbstrRef(itpMgr->travMgr);
  int abstrRefGla = Trav_MgrReadAbstrRefGla(itpMgr->travMgr);
  int doPba = ((abstrRef % 2) == 1);
  int mySat, chk = 0, cexHit = 1;
  Ddi_Bdd_t *ringAndCone;
  Ddi_Bddarray_t *currAbstr = itpMgr->abstrCurrAbstr;
  Ddi_Bddarray_t *abstrRefA = NULL;
  Ddi_Bddarray_t *abstrRefA0 = NULL;
  Ddi_Vararray_t *abstrRefCtrl = itpMgr->abstrRefCtrl;
  Ddi_Bddarray_t *abstrDoAbstr = itpMgr->abstrDoAbstr;
  Ddi_Bddarray_t *abstrDoRefine = itpMgr->abstrDoRefine;
  Ddi_Bdd_t *coneNoAbstr = NULL, *coneCurrAbstr = NULL;
  int chk2 = 0, chk3 = 0, isSat = -1, isSatCurrAbstr = -1;
  int enChkAbstr = 0;

  static int ncalls = 0;

  ncalls++;

  Ddi_Bdd_t *saveMyConeAbstr = Ddi_BddDup(myConeAbstr);
  
  if (start_j >= 0) {
    Ddi_Bddarray_t *delta = itpMgr->deltaAbstr;

    if (itpMgr->abstrRefNnf) {
      delta = itpMgr->nnf.deltaAbstr;
    }
    growConeBwd(itpMgr, myConeAbstr, start_j, 0,
		delta, itpMgr->initStub, useEqRings ? 2 : 0, -1, 2 /*boundK */ );

    if (timeLimit<0 && abstrCex!=NULL && start_j > 2) {
      Ddi_Bdd_t *cexProj = Ddi_BddDup(abstrCex);
#if 0
      int nKeepFrames = start_j/3;
      Ddi_Vararray_t **tfPiVars = itpMgr->timeFrames->PiVars;
      int tfPiNum =  itpMgr->timeFrames->Num;
      Pdtutil_Assert(tfPiNum>nKeepFrames,"missing frames");
      Ddi_Vararray_t *projVA = Ddi_VararrayDup(tfPiVars[1]);
      for (int i=2; i<=nKeepFrames; i++)  {
        Ddi_VararrayAppend(projVA,tfPiVars[i]);
      }
#else
      Ddi_Vararray_t *projVA = Ddi_BddSuppVararray(cexProj);
      int nKeep = Ddi_VararrayNum(projVA)/3;
      for (int i=Ddi_VararrayNum(projVA)-1; i>nKeep; i--)  {
        Ddi_VararrayRemove(projVA,i);
      }
#endif

      doPba = 1;

      Ddi_Varset_t *proj = Ddi_VarsetMakeFromArray(projVA);
      Ddi_Free(projVA);
      Ddi_BddCubeExistProjectAcc(cexProj, proj);
      int size0 = Ddi_BddSize(myConeAbstr);
      Ddi_AigConstrainCubeAcc(myConeAbstr, cexProj);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("AbstrRef: using cex constrained cone |%d| -> |%d|\n", size0,
               Ddi_BddSize(myConeAbstr));
      }
      Ddi_Free(proj);
      Ddi_Free(cexProj);
    }
    Ddi_BddSetAig(myConeAbstr);
  }

  ringAndCone = Ddi_BddDup(myConeAbstr);

  if (itpMgr->initStub == NULL) {
    Ddi_Bdd_t *initNs = Ddi_BddSubstVars(itpMgr->init, itpMgr->ps, itpMgr->ns);

    //    if (0 && itpMgr->abstrRefNnf) {
    // state vars already joined in growCone
    //   Ddi_Bdd_t *initNs0=NULL;
    //  Ddi_Bddarray_t *subst =
    //    Ddi_BddarrayMakeLiteralsAig(itpMgr->nnf.ns0,0);
    //  initNs0 = Ddi_BddCompose(initNs,itpMgr->ns,subst);
    //  Ddi_BddAndAcc(initNs,initNs0);
    //  Ddi_Free(initNs0);
    //  Ddi_Free(subst);
    // }
    //    Ddi_AigAndCubeAcc(ringAndCone,initNs);
    Ddi_AigConstrainCubeAcc(ringAndCone, initNs);
    Ddi_Free(initNs);
  } else {
    // already done in growConeBwd
    //    Ddi_BddComposeAcc(ringAndCone,ns,initStub);
  }
  if (chk2) {
    coneNoAbstr = Ddi_BddDup(ringAndCone);
    Ddi_BddComposeAcc(coneNoAbstr, itpMgr->abstrRefCtrl, abstrDoRefine);
    isSat = Ddi_AigSat(coneNoAbstr);
  }
  if (chk3 && currAbstr != NULL) {
#if 0
    int jj;

    for (jj = 0; jj < Ddi_BddarrayNum(currAbstr); jj++) {
      printf("%d", Ddi_BddIsOne(Ddi_BddarrayRead(currAbstr, jj)));
    }
    printf("\n");
#endif
    coneCurrAbstr = Ddi_BddDup(ringAndCone);
    Ddi_BddComposeAcc(coneCurrAbstr, itpMgr->abstrRefCtrl, currAbstr);
    isSatCurrAbstr = Ddi_AigSat(coneCurrAbstr);
    Pdtutil_Assert(isSatCurrAbstr, "wrong refinement (sat/unsat)");
    Ddi_Free(coneCurrAbstr);
  }

  if (chk) {
    Ddi_Bdd_t *checkAbstr = Ddi_BddCompose(ringAndCone,
      itpMgr->abstrRefCtrl, abstrDoRefine);
    if (Ddi_AigSat(checkAbstr)) {
      printf("SAT refinement\n");
    }
    else {
      printf("UNSAT refinement\n");
    }
    Ddi_Free(checkAbstr);
  }

  int doRecur=0;
  if (enPrio && itpMgr->abstrPrioRefineNum>0) {
    Ddi_Bddarray_t *myDoRefine = Ddi_BddarrayDup(abstrDoRefine);
    int na = Ddi_BddarrayNum(abstrDoRefine);
    for (int i=0; i<na; i++) {
      Ddi_Bdd_t *r_i = Ddi_BddarrayRead(itpMgr->abstrPrioRefine,i);
      if (Ddi_BddIsOne(r_i))
        Ddi_BddarrayWrite(myDoRefine,i,r_i);
    }
    abstrRefA = doPba ?
      Ddi_AigAbstrRefinePba(ringAndCone,
                            abstrRefCtrl, myDoRefine, currAbstr, &mySat, -1.0) :
      Ddi_AigAbstrRefineCegarPba(ringAndCone,
                             abstrRefCtrl, myDoRefine, currAbstr, &mySat, -1.0);
    if (!mySat)
      doRecur = 1;
    Ddi_Free(myDoRefine);
  }
  else {
    abstrRefA = doPba ?
      Ddi_AigAbstrRefinePba(ringAndCone,
                            abstrRefCtrl, abstrDoRefine, currAbstr, &mySat,timeLimit) :
      Ddi_AigAbstrRefineCegarPba(ringAndCone,
                            abstrRefCtrl, abstrDoRefine, currAbstr, &mySat,timeLimit);
    if (timeLimit>0 && mySat<0) {
      doRecur = 1;
      cexHit = 0;
    }
  }

  if (chk) {
    Ddi_Bdd_t *checkAbstr = Ddi_BddCompose(ringAndCone,
      itpMgr->abstrRefCtrl, abstrDoRefine);
    Ddi_Vararray_t *vA = Ddi_BddSuppVararray(checkAbstr);
    int jj;
    int n = strlen("abstrRef");

    for (jj = 0; jj < Ddi_VararrayNum(vA); jj++) {
      Ddi_Var_t *v = Ddi_VararrayRead(vA, jj);
      char *name = Ddi_VarName(v);

      if (name != NULL) {
        Pdtutil_Assert(strncmp(name, "abstrRef", n) != 0, "wrong abstraction");
      }
    }
    Ddi_Free(vA);
    Ddi_Free(checkAbstr);

    if (enChkAbstr && !mySat && abstrRefA != NULL) {
      Ddi_Bdd_t *cone_j, *constr_j;
      Ddi_Bdd_t *tryCheck = Ddi_BddCompose(ringAndCone,
        itpMgr->abstrRefCtrl, abstrRefA);

      Pdtutil_Assert(!Ddi_AigSat(tryCheck), "error in pba ref.");
      Ddi_Free(tryCheck);
    }
  }

  Ddi_Free(ringAndCone);
  if (!mySat && abstrRefA != NULL) {
    int i;
    Ddi_Varset_t *refinedVars0 = NULL, *refinedVars1 = NULL;

    int iConstr = Ddi_BddarrayNum(abstrRefA)-2;
    if (Ddi_BddIsOne(Ddi_BddarrayRead(abstrRefA,iConstr)))
      Ddi_BddNotAcc(Ddi_BddarrayRead(abstrRefA,iConstr));
    
    refinedVars0 = Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 0);
    if (Ddi_VarsetarrayNum(itpMgr->abstrRefRefinedVars) > 1) {
      Pdtutil_Assert(Ddi_VarsetarrayNum(itpMgr->abstrRefRefinedVars) == 2,
        "max 2 refined varsets supported");
      refinedVars1 = Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 1);
    }
    Ddi_Free(itpMgr->abstrCurrAbstr);
    itpMgr->abstrCurrAbstr = abstrRefA; // Ddi_Free(abstrRefA);
    // Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    //  fprintf(stdout, "abstr-ref: %d\n", Ddi_BddSize(localCone)));
    cexHit = mySat;
    Pdtutil_Assert(itpMgr->abstrRefRefinedVars != NULL,
      "missing refine varset");
    for (i = 0; i < Ddi_BddarrayNum(abstrRefA); i++) {
      if (Ddi_BddIsZero(Ddi_BddarrayRead(abstrRefA, i))) {
        Ddi_Var_t *ctrl = Ddi_VararrayRead(itpMgr->abstrRefCtrl, i);
	if (i<Ddi_VararrayNum(itpMgr->abstrRefPsPiVars)) {
	  Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->abstrRefPsPiVars, i);
	  char *name = Ddi_VarName(ctrl);
	  
	  // printf("refined: %s\n", name);
	  if (strstr(name, "abstrRefCtrl1_") != NULL) {
	    Pdtutil_Assert(refinedVars1 != NULL, "NULL refined varset");
	    Ddi_VarsetAddAcc(refinedVars1, v);
	  } else {
	    Ddi_VarsetAddAcc(refinedVars0, v);
	  }
	}
      }
    }
  } else {
    Ddi_Free(abstrRefA);
  }

  if (chk2) {
    Pdtutil_Assert(isSat == mySat, "wrong refinement (sat/unsat)");
    Ddi_Free(coneNoAbstr);
  }

  Pdtutil_Assert(!(!mySat && abstrRefA == NULL), "wrong refinement");

  if (doRecur) {
    Pdtutil_Assert(!cexHit,"wrong abstrref cex hit");
    cexHit = igrAbstrRef(itpMgr,saveMyConeAbstr,start_j,useEqRings,abstrCex,0,-1.0,NULL);
    if (cexUsedP != NULL && abstrCex != NULL)
      *cexUsedP = 1;
  }
  Ddi_Free(saveMyConeAbstr);  
  return cexHit;

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
genRefiningTrConstr(
  Trav_ItpMgr_t * itpMgr,
  int start_j,
  int *pSat
)
{
  /* cegar/pba */
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int abstrRef = Trav_MgrReadAbstrRef(itpMgr->travMgr);
  int abstrRefGla = Trav_MgrReadAbstrRefGla(itpMgr->travMgr);
  int doPba = ((abstrRef % 2) == 1);
  int mySat, chk = 0, cexHit = 1;
  Ddi_Bdd_t *ringAndCone;
  Ddi_Bddarray_t *currAbstr = itpMgr->abstrCurrAbstr;
  Ddi_Bddarray_t *abstrRefA = NULL;
  Ddi_Bddarray_t *abstrRefA0 = NULL;
  Ddi_Vararray_t *abstrRefCtrl = itpMgr->abstrRefCtrl;
  Ddi_Bddarray_t *abstrDoAbstr = itpMgr->abstrDoAbstr;
  Ddi_Bddarray_t *abstrDoRefine = itpMgr->abstrDoRefine;
  Ddi_Bddarray_t *initStub = itpMgr->initStub;

  Ddi_Bdd_t *refTr = Ddi_BddMakePartConjVoid(ddm);
  int k;

  Ddi_Bddarray_t *delta = itpMgr->deltaAbstr; 
  Ddi_Bdd_t *fwdConstr = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bddarray_t *splitU0 = NULL;
  Ddi_BddSetPartConj(fwdConstr);

  Ddi_Vararray_t *abstrCutVars = Ddi_VararrayAlloc(ddm, 0);
  Ddi_Vararray_t *abstrCutPs = Ddi_VararrayAlloc(ddm, 0);
  Ddi_Vararray_t *abstrCutNs = Ddi_VararrayAlloc(ddm, 0);
  Ddi_Bddarray_t *abstrCutDelta = Ddi_BddarrayAlloc(ddm, 0);
  // select curr absrtraction
  for (int i=0; i<Ddi_VararrayNum(itpMgr->ps); i++) {
    if (Ddi_BddIsOne(Ddi_BddarrayRead(itpMgr->abstrCurrAbstr,i))) {
      Ddi_VararrayInsertLast(abstrCutVars,Ddi_VararrayRead(itpMgr->abstrRefInp,i));
      Ddi_VararrayInsertLast(abstrCutPs,Ddi_VararrayRead(itpMgr->ps,i));
      Ddi_VararrayInsertLast(abstrCutNs,Ddi_VararrayRead(itpMgr->ns,i));
      Ddi_BddarrayInsertLast(abstrCutDelta,Ddi_BddarrayRead(itpMgr->delta,i));
    }
  }
  Ddi_Bdd_t *abstrTr = Ddi_BddRelMakeFromArray(delta,itpMgr->ns);
  // Ddi_Bdd_t *cutTr = Ddi_BddRelMakeFromArrayFiltered(delta,itpMgr->ns,abstrCutNs);
  Ddi_Bdd_t *cutTr = Ddi_BddRelMakeFromArray(delta,itpMgr->ns);
  Ddi_BddComposeAcc(abstrTr, itpMgr->abstrRefCtrl, currAbstr);
  Ddi_BddComposeAcc(cutTr, itpMgr->abstrRefCtrl, abstrDoRefine);
  //  Ddi_BddSubstVarsAcc(cutTr,abstrCutVars,abstrCutPs);
  int sat=0;

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nAbstrRef - refining TR by INTERPOLATION\n");
  }

  int maxIter = travMgr->settings.aig.abstrRefItpMaxIter;

  for (k = 1; (k<=start_j+1) && !sat; k++) {
    int useSplitUnrollConstr = 1;
    int useNewVars = 0;
    int boundK = Trav_MgrReadIgrGrowCone(travMgr)>2 ? 1 : 0;
    Ddi_Bdd_t *cone_k = Ddi_BddDup(itpMgr->target);
    Ddi_Bdd_t *rel0;
    if (k==1) {
      Pdtutil_Assert(splitU0==NULL,"wrong splitU0");
      if (itpMgr->initStub!=NULL) {
        splitU0 = Ddi_BddarrayDup(itpMgr->initStub);
        rel0 = Ddi_BddRelMakeFromArray(splitU0,itpMgr->ps);
      }
      else {
        rel0 = Ddi_BddDup(itpMgr->init);
      }
    }
    else {
      rel0 = Ddi_BddRelMakeFromArray(splitU0,itpMgr->ps);
    }

    Ddi_BddSubstVarsAcc(cone_k, itpMgr->ps, itpMgr->ns);
    Ddi_BddWriteMark(cone_k,k);

    if (k<=start_j) {
      growConeBwd(itpMgr, cone_k, start_j, k, itpMgr->deltaAbstr,
		  NULL, 0, 0,
                  boundK /*boundK */ );
    }
    Ddi_Bdd_t *bwdCone = Ddi_BddCompose(cone_k,
                                             itpMgr->abstrRefCtrl, abstrDoRefine);
    Ddi_Vararray_t *myTfPis = itpMgr->timeFrames->PiVars[k-1];
    Ddi_Bdd_t *abstrTr_k = Ddi_BddSubstVars(abstrTr,itpMgr->pi,myTfPis);
    Ddi_Bdd_t *cutTr_k = Ddi_BddSubstVars(cutTr,itpMgr->pi,myTfPis);
    
    Ddi_Bdd_t *bForItp = Ddi_BddDup(abstrTr_k);
    Ddi_BddPartInsertLast(bForItp,bwdCone);
    Ddi_BddPartInsertLast(bForItp,rel0);
    Ddi_BddPartInsertLast(bForItp,fwdConstr);
    if (0 && k>1) {
      Ddi_Bdd_t *prevTrConstr = Ddi_BddMakeAig(refTr);
      Ddi_BddSubstVarsAcc(prevTrConstr,itpMgr->pi,myTfPis);
      Ddi_BddPartInsertLast(bForItp,prevTrConstr);
      Ddi_Free(prevTrConstr);
    }
    Ddi_BddSetFlattened(bForItp);
    
    Ddi_Vararray_t * gblA = Ddi_VararrayUnion(itpMgr->ns,itpMgr->ps);
    Ddi_VararrayUnionAcc(gblA,myTfPis);
    Ddi_Varset_t *gblVars = Ddi_VarsetMakeFromArray(gblA);
    Ddi_Free(gblA);
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nAbstrRef - INTERPOLATION iteration: %d/%d\n\n", k-1, start_j);
    }
  
    Ddi_Bdd_t *trRefinement = Ddi_AigSatAndWithInterpolant(cutTr_k,
                                 bForItp, gblVars, NULL, NULL,
                                 NULL, NULL, NULL, &sat, 0, 0, -1.0);
    if (k>=maxIter) sat=1;
    if (sat) {
    }
    else {
      Pdtutil_Assert(trRefinement!=NULL,"sat refinement not yet supported");
      Ddi_Bdd_t *fwdConstr_k = Ddi_BddDup(trRefinement);
      Ddi_BddSubstVarsAcc(trRefinement,myTfPis,itpMgr->pi);
      Ddi_BddPartInsertLast(refTr,trRefinement);
      Ddi_Bddarray_t *splitU1 = Ddi_BddarrayDup(itpMgr->delta);
      Ddi_BddarraySubstVarsAcc(splitU1,itpMgr->pi,myTfPis);
      if (splitU0!=NULL) {
        Ddi_BddarrayComposeAcc(splitU1, itpMgr->ps,splitU0);
        Ddi_BddComposeAcc(fwdConstr_k, itpMgr->ps,splitU0);
        Ddi_Free(splitU0);
      }
      else {
        Pdtutil_Assert(k==1,"K==0 needed");
        Ddi_AigarrayConstrainCubeAcc(splitU1, itpMgr->init);
        Ddi_AigConstrainCubeAcc(fwdConstr_k, itpMgr->init);
        Pdtutil_Assert((Ddi_BddSize(itpMgr->init)/2+1)==Ddi_VararrayNum(itpMgr->ps),"init don't cares not supported here");
      // look for init don't cares
      }
      Ddi_BddComposeAcc(fwdConstr_k,itpMgr->ns,splitU1);
      Ddi_BddPartInsertLast(fwdConstr,fwdConstr_k);
      splitU0 = splitU1;
      Ddi_Free(fwdConstr_k);
    }
    Ddi_Free(bForItp);
    Ddi_Free(gblVars);
    
    Ddi_Free(trRefinement);
    Ddi_Free(abstrTr_k);
    Ddi_Free(cutTr_k);
    Ddi_Free(bwdCone);
    Ddi_Free(cone_k);
    Ddi_Free(rel0);
  }

  Ddi_BddSetAig(refTr);
  if (itpMgr->abstrRefTrConstr!=NULL) {
    Ddi_BddAndAcc(refTr,itpMgr->abstrRefTrConstr);
  }
  int doOpt = 1;
  if (doOpt) {
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nAbstrRef - strengthening refimed TR\n\n");
    }
    int doItp2 = 0;
    if (doItp2) {
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nAbstrRef - strengthening by ITP\n\n");
      }
      Ddi_BddNotAcc(refTr);
      int sat1;
      Ddi_Bdd_t *refTr1 = Ddi_AigSatAndWithInterpolant(refTr,
                                 cutTr, NULL, NULL, NULL,
                                 NULL, NULL, NULL, &sat1, 0, 0, -1.0);
      Ddi_BddNotAcc(refTr1);
      Ddi_Free(refTr);
      refTr = refTr1;
    }
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nAbstrRef - strengthening by NNF\n\n");
    }
    Ddi_AigOptByMonotoneCoreAcc(refTr,cutTr,NULL,1,-1.0);
  }
  
  Ddi_Free(abstrCutVars);
  Ddi_Free(abstrCutPs);
  Ddi_Free(abstrCutNs);
  Ddi_Free(abstrCutDelta);
    
  Ddi_Free(splitU0);
  Ddi_Free(fwdConstr);
  Ddi_Free(abstrTr);
  Ddi_Free(cutTr);

  *pSat = sat;
  
  return refTr;

 
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
igrAbstrRefByItp(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * myConeAbstr,
  int start_j,
  int useEqRings,
  Ddi_Bdd_t *abstrCex,
  int enPrio,
  float timeLimit,
  int *cexUsedP
)
{
  /* cegar/pba */
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int abstrRef = Trav_MgrReadAbstrRef(itpMgr->travMgr);
  int abstrRefGla = Trav_MgrReadAbstrRefGla(itpMgr->travMgr);
  int doPba = ((abstrRef % 2) == 1);
  int mySat, chk = 0, cexHit = 1;
  Ddi_Bdd_t *ringAndCone;
  Ddi_Bddarray_t *currAbstr = itpMgr->abstrCurrAbstr;
  Ddi_Bddarray_t *abstrRefA = NULL;
  Ddi_Bddarray_t *abstrRefA0 = NULL;
  Ddi_Vararray_t *abstrRefCtrl = itpMgr->abstrRefCtrl;
  Ddi_Bddarray_t *abstrDoAbstr = itpMgr->abstrDoAbstr;
  Ddi_Bddarray_t *abstrDoRefine = itpMgr->abstrDoRefine;
  Ddi_Bdd_t *coneNoAbstr = NULL, *coneCurrAbstr = NULL;
  int chk2 = 0, chk3 = 0, isSat = -1, isSatCurrAbstr = -1;
  int enChkAbstr = 0;

  static int ncalls = 0;

  ncalls++;

  Ddi_Bdd_t *saveMyConeAbstr = Ddi_BddDup(myConeAbstr);
  
  if (start_j >= 0) {
    //Ddi_Bddarray_t *delta = itpMgr->deltaAbstr;
    Ddi_Bddarray_t *delta = itpMgr->delta; // use current abstraction

    growConeBwd(itpMgr, myConeAbstr, start_j, 0,
		delta, itpMgr->initStub, useEqRings ? 2 : 0, -1, 2 /*boundK */ );

    if (timeLimit<0 && abstrCex!=NULL && start_j > 2) {
      Ddi_Bdd_t *cexProj = Ddi_BddDup(abstrCex);
      Ddi_Vararray_t *projVA = Ddi_BddSuppVararray(cexProj);
      int nKeep = Ddi_VararrayNum(projVA)/3;
      for (int i=Ddi_VararrayNum(projVA)-1; i>nKeep; i--)  {
        Ddi_VararrayRemove(projVA,i);
      }

      doPba = 1;

      Ddi_Varset_t *proj = Ddi_VarsetMakeFromArray(projVA);
      Ddi_Free(projVA);
      Ddi_BddCubeExistProjectAcc(cexProj, proj);
      int size0 = Ddi_BddSize(myConeAbstr);
      Ddi_AigConstrainCubeAcc(myConeAbstr, cexProj);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("AbstrRef: using cex constrained cone |%d| -> |%d|\n", size0,
               Ddi_BddSize(myConeAbstr));
      }
      Ddi_Free(proj);
      Ddi_Free(cexProj);
    }
    Ddi_BddSetAig(myConeAbstr);
  }

  ringAndCone = Ddi_BddDup(myConeAbstr);

  if (itpMgr->initStub == NULL) {
    Ddi_Bdd_t *initNs = Ddi_BddSubstVars(itpMgr->init, itpMgr->ps, itpMgr->ns);

    //    if (0 && itpMgr->abstrRefNnf) {
    // state vars already joined in growCone
    //   Ddi_Bdd_t *initNs0=NULL;
    //  Ddi_Bddarray_t *subst =
    //    Ddi_BddarrayMakeLiteralsAig(itpMgr->nnf.ns0,0);
    //  initNs0 = Ddi_BddCompose(initNs,itpMgr->ns,subst);
    //  Ddi_BddAndAcc(initNs,initNs0);
    //  Ddi_Free(initNs0);
    //  Ddi_Free(subst);
    // }
    //    Ddi_AigAndCubeAcc(ringAndCone,initNs);
    Ddi_AigConstrainCubeAcc(ringAndCone, initNs);
    Ddi_Free(initNs);
  } else {
    // already done in growConeBwd
    //    Ddi_BddComposeAcc(ringAndCone,ns,initStub);
  }
  int doRecur=0;


  int sat;
  Ddi_Bdd_t *refiningTrConstr = genRefiningTrConstr(itpMgr, start_j, &sat);
  Ddi_Free (itpMgr->abstrRefTrConstr);
  itpMgr->abstrRefTrConstr = refiningTrConstr;
  cexHit = mySat = sat;
  if (refiningTrConstr!=NULL) {
    if (abstrRefA==NULL)
      abstrRefA = Ddi_BddarrayDup(currAbstr);
    int iConstr = Ddi_BddarrayNum(abstrRefA)-2;
    int iProp = iConstr+1;
    if (Ddi_BddIsOne(Ddi_BddarrayRead(abstrRefA,iConstr)))
      Ddi_BddNotAcc(Ddi_BddarrayRead(abstrRefA,iConstr));
    if (Ddi_BddIsOne(Ddi_BddarrayRead(abstrRefA,iProp)))
      Ddi_BddNotAcc(Ddi_BddarrayRead(abstrRefA,iProp));
  }

  Ddi_Free(ringAndCone);

  if (abstrRefA != NULL) {
    int i;
    Ddi_Varset_t *refinedVars0 = NULL, *refinedVars1 = NULL;

    refinedVars0 = Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 0);
    if (Ddi_VarsetarrayNum(itpMgr->abstrRefRefinedVars) > 1) {
      Pdtutil_Assert(Ddi_VarsetarrayNum(itpMgr->abstrRefRefinedVars) == 2,
        "max 2 refined varsets supported");
      refinedVars1 = Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 1);
    }
    Ddi_Free(itpMgr->abstrCurrAbstr);
    itpMgr->abstrCurrAbstr = abstrRefA; // Ddi_Free(abstrRefA);
    // Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    //  fprintf(stdout, "abstr-ref: %d\n", Ddi_BddSize(localCone)));
    cexHit = mySat;
    Pdtutil_Assert(itpMgr->abstrRefRefinedVars != NULL,
      "missing refine varset");
    for (i = 0; i < Ddi_BddarrayNum(abstrRefA); i++) {
      if (Ddi_BddIsZero(Ddi_BddarrayRead(abstrRefA, i))) {
        Ddi_Var_t *ctrl = Ddi_VararrayRead(itpMgr->abstrRefCtrl, i);
	if (i<Ddi_VararrayNum(itpMgr->abstrRefPsPiVars)) {
	  Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->abstrRefPsPiVars, i);
	  char *name = Ddi_VarName(ctrl);
	  
	  // printf("refined: %s\n", name);
	  if (strstr(name, "abstrRefCtrl1_") != NULL) {
	    Pdtutil_Assert(refinedVars1 != NULL, "NULL refined varset");
	    Ddi_VarsetAddAcc(refinedVars1, v);
	  } else {
	    Ddi_VarsetAddAcc(refinedVars0, v);
	  }
	}
      }
    }
  } else {
    Ddi_Free(abstrRefA);
  }

  Pdtutil_Assert(!(!mySat && abstrRefA == NULL), "wrong refinement");

  if (doRecur) {
    Pdtutil_Assert(!cexHit,"wrong abstrref cex hit");
    cexHit = igrAbstrRefByItp(itpMgr,saveMyConeAbstr,start_j,useEqRings,abstrCex,0,-1.0,NULL);
    if (cexUsedP != NULL && abstrCex != NULL)
      *cexUsedP = 1;
  }
  Ddi_Free(saveMyConeAbstr);  
  return cexHit;

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
itpPreimgOnFwdRings(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone,
  int k,
  int img_j,
  int fwd_j,
  int useToPlusAsCare,
  int *toPlusRefined
)
{
  /* cegar/pba */
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cone);
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int boundK = (growCone > 2) ? 1 : 0;
  int useSplitUnrollConstr = 1;
  int useNewVars = 0;
  int start_i = img_j+k;
  int split_i = img_j;
  Ddi_Bdd_t *refineBwdRing=NULL;
  Ddi_Bdd_t *myCone = Ddi_BddDup(cone), *toPlus=NULL;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);

  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitCare = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Varset_t *splitVars = NULL;
  Ddi_Bdd_t *bwdItp, *fwdRing=NULL;
  int sat;
  float itpTimeLimit = travMgr->settings.aig.lazyTimeLimit;
  int useEqRings = itpMgr->eqRings != NULL &&
    Ddi_BddarrayNum(itpMgr->eqRings) > 0;
  Ddi_Var_t *cvarNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
  Ddi_Var_t *cvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
  Ddi_Bdd_t *constrLitNs = Ddi_BddMakeLiteralAig(cvarNs,1);
  Ddi_Bdd_t *constrLitPs = Ddi_BddMakeLiteralAig(cvarPs,1);

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nITP PREIMG K: %d (rings: %d<-%d (curr: %d)) |from|=%d\n\n", k,
	   fwd_j, start_i, split_i, Ddi_BddSize(cone));
  }

  if (fwd_j>0 && Ddi_BddarrayNum(itpMgr->fromRings)>fwd_j) {
    fwdRing = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, fwd_j));
    if (fwdRing!=NULL) {
      Ddi_BddSubstVarsAcc(fwdRing, itpMgr->ns, itpMgr->ps);
    }
  }
  else if (fwd_j==0 && itpMgr->initStub==NULL) {
    Pdtutil_Assert(itpMgr->init!=NULL,"missing init state");
    fwdRing = Ddi_BddSubstVars(itpMgr->init, itpMgr->ns, itpMgr->ps);
  }
  if (fwdRing!=NULL)
    Ddi_BddAndAcc(fwdRing,constrLitPs);

  if (split_i>0 &&
      Ddi_BddarrayNum(itpMgr->fromRings)>split_i) {
    toPlus = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, split_i));
  }

  growConeBwdDecomp(itpMgr, myCone, start_i, fwd_j, split_i, 
		      useSplitUnrollConstr, useNewVars, NULL,
		      itpMgr->initStub, 
		      growCone != 1 ? 2 : 0 /*useRingConstr */ ,
		      -1/* andwithring_i*/,boundK /*boundK */);

  Pdtutil_Assert(Ddi_BddReadComposeF(myCone)!=NULL,"no split cone");
  splitB = Ddi_BddDup(Ddi_BddReadComposeF(myCone));
  splitCare = Ddi_BddDup(Ddi_BddReadComposeCare(myCone));
  splitU = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(myCone));
  splitV = Ddi_VararrayDup(Ddi_BddReadComposeVars(myCone));
  splitRel = Ddi_BddRelMakeFromArray(splitU,splitV);
  splitVars = Ddi_VarsetMakeFromArray(splitV);
  //  Ddi_BddSetAig(splitRel);
  Ddi_BddPartInsertLast(splitRel,splitCare);

  if (fwdRing!=NULL) {
    if (Ddi_BddIsCube(fwdRing)) {
      Ddi_AigAndCubeAcc(splitRel, fwdRing);
    }
    else if (Ddi_BddIsPartConj(splitRel))
      Ddi_BddPartInsertLast(splitRel,fwdRing);
    else
      Ddi_BddAndAcc(splitRel,fwdRing);
  }
  Ddi_Free(fwdRing);
  if (0 && splitCare!=NULL && !Ddi_BddIsOne(splitCare)) {
    if (Ddi_BddIsPartConj(splitRel))
      Ddi_BddPartInsertLast(splitRel,splitCare);
    else
      Ddi_BddAndAcc(splitRel,splitCare);
  }

  if (toPlusRefined !=NULL) {
    *toPlusRefined = 1;
  }
  //Pdtutil_Assert(Ddi_AigSat(splitRel),"unsat fwd unroll");
  int itpOpt = Ddi_MgrReadAigItpOpt(ddm);
  Ddi_MgrSetAigItpOpt(ddm, 1);
  // splitRel splitB swapped for part conj
  int reuseToPlus = 0;
  if (useToPlusAsCare && toPlus!=NULL) {
#if 0
    Ddi_Var_t *pvarNs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
    Ddi_Var_t *cvarNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    Ddi_BddCofactorAcc(toPlus,pvarNs,1);
    Ddi_BddCofactorAcc(toPlus,cvarNs,1);
#endif
    if (!Ddi_AigSatAnd(splitB,toPlus,NULL)) {
      reuseToPlus=1;
      if (toPlusRefined !=NULL) {
	*toPlusRefined = 0;
      }
    }
  }
  else if (toPlus!=NULL) {
    Ddi_Var_t *cvarNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    Ddi_Bdd_t *over = Ddi_BddNot(toPlus);
    Ddi_BddAndAcc(over,constrLitNs);
    Ddi_BddOrAcc(splitB,over);
    Ddi_Free(over);
  }
    
  if (reuseToPlus) {
    bwdItp = Ddi_BddDup(toPlus);
  }
  else {
    int careOpt = ddm->settings.aig.itpUseCare;
    ddm->settings.aig.itpUseCare = 1;
    bwdItp = Ddi_AigSat22AndWithInterpolant(NULL,splitRel,splitB,
                NULL,splitVars,NULL,NULL,0,
                useToPlusAsCare?toPlus:NULL,NULL,
		&sat, 0, 1, 0, itpTimeLimit);
    ddm->settings.aig.itpUseCare = careOpt;
    Pdtutil_Assert (bwdItp!=NULL,"Null itp found");
  }
  if (0) {
    Ddi_Var_t *cvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    Ddi_Bdd_t *c = Ddi_BddMakeLiteralAig(cvarPs, 1); 
    Ddi_BddAndAcc(bwdItp,c);
    Ddi_Free(c);
  }
  Ddi_MgrSetAigItpOpt(ddm, itpOpt);

  Pdtutil_Assert (1||splitCare==NULL||Ddi_BddIsOne(splitCare),
                  "handle splitcare");
  if (0){
    Ddi_BddNotAcc(splitCare);
    Ddi_BddOrAcc(bwdItp,splitCare);
  }

  if (toPlus!=NULL) {
    Ddi_BddAndAcc(bwdItp,toPlus);
  }
  Ddi_Free(toPlus);
  int doSatApprImg=0;
  if (doSatApprImg) {
    Ddi_Varset_t *supp = Ddi_BddSupp(bwdItp);
    int nv = Ddi_VarsetNum(supp);
    int nIter = 2<<nv;
    Ddi_Bdd_t *myFrom = Ddi_BddMakeAig(splitRel);
    Ddi_Bdd_t *myFromAux = Ddi_BddDup(myFrom);
    Ddi_Bdd_t *toAppr =  
      Ddi_AigProjectRefineOutImgAcc(myFrom, supp, bwdItp,
                                   nv, 2);

    Ddi_Var_t *pvarNs = Ddi_VarFromName(ddm,
                     "PDT_BDD_INVARSPEC_VAR$NS");
    // can do the following if not using bwdItp as care
    // Ddi_Bdd_t *b = Ddi_BddCofactor(bwdItp,pvarNs,1);
    // Pdtutil_Assert(Ddi_BddIncluded(toAppr,b),"unsound toappr");     // Ddi_Free(b);
       
    Pdtutil_Assert(1||Ddi_BddIncluded(myFromAux,toAppr),"unsound toappr");        
    Ddi_BddAndAcc(bwdItp,toAppr);
    Ddi_Free(myFromAux);
    Ddi_Free(supp);
    Ddi_Free(toAppr);
  }
  
  if (!reuseToPlus && bwdItp!=NULL) {
    Ddi_Bdd_t *ret =
      Ddi_AigOptByMonotoneCoreAcc(bwdItp,splitB,NULL,0,-1.0);
    //Ddi_AigOptByMonotoneCoreAcc(bwdItp,splitRel,NULL,1,-1.0);
    if (ret==NULL) {
      Pdtutil_Assert(useToPlusAsCare,"problem with weakening");
      Ddi_Free(bwdItp);
      bwdItp = itpPreimgOnFwdRings(itpMgr,cone,k,img_j,fwd_j,0,NULL);
    }
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    if (0 && (iv != NULL)) {
      Ddi_Bdd_t *invar = Ddi_BddMakeLiteralAig(iv, 1);
      
      Ddi_BddAndAcc(bwdItp, invar);
      Ddi_Free(invar);
    }
  }


  Ddi_Free(constrLitNs);
  Ddi_Free(constrLitPs);
  Ddi_Free(splitB);
  Ddi_Free(splitCare);
  Ddi_Free(splitU);
  Ddi_Free(splitV);
  Ddi_Free(splitRel);
  Ddi_Free(splitVars);

  Ddi_Free(myCone);


  return bwdItp;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
itpPreimg(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *from,
  Ddi_Bdd_t *toPlus,
  int k,
  int fwd_j
)
{
  /* cegar/pba */
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));

  int useSplitUnrollConstr = 1;
  int useNewVars = 0;
  int start_i = k+1;
  int split_i = k+1;
  Ddi_Bdd_t *refineBwdRing=NULL;
  Ddi_Bdd_t *myCone = Ddi_BddDup(from);
  Ddi_Bdd_t *myConeChk = Ddi_BddDup(from);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);

  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitCare = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Varset_t *splitVars = NULL;
  Ddi_Bdd_t *bwdItp, *fwdRing=NULL;
  int sat;
  float itpTimeLimit = travMgr->settings.aig.lazyTimeLimit;
  int useEqRings = itpMgr->eqRings != NULL &&
    Ddi_BddarrayNum(itpMgr->eqRings) > 0;

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nITP PREIMG K: %d (rings: %d<-%d) |from|=%d\n\n", k,
	   fwd_j, start_i, Ddi_BddSize(from));
  }

  growConeBwd(itpMgr, myConeChk, start_i, fwd_j,
	      itpMgr->delta, itpMgr->initStub, useEqRings ? 2 : 0, -1, 2 /*boundK */ );

  if (fwd_j>0) {
    Pdtutil_Assert(Ddi_BddarrayNum(itpMgr->fromRings)>fwd_j,"missing fwd ring");
    fwdRing = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, fwd_j));
    if (Ddi_AigSatAnd(myConeChk,fwdRing,NULL)) {
      Ddi_Free(myCone);
      Ddi_Free(myConeChk);
      Ddi_Free(fwdRing);
      return NULL;
    }
  }
  else {
    if (0 && Ddi_AigSat(myConeChk)) {
      Ddi_Free(myCone);
      Ddi_Free(myConeChk);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nITP PREIMG ENDED\n");
      }

      return NULL;
    }
  }

  Ddi_Bdd_t *cone1 = Ddi_BddDup(myCone);
  growConeBwdDecomp(itpMgr, myCone, start_i, fwd_j, split_i, 
		      useSplitUnrollConstr, useNewVars, NULL,
		      itpMgr->initStub, 
		      growCone != 1 ? 2 : 0 /*useRingConstr */ ,
		      -1/* andwithring_i*/,1 /*boundK */);
  growConeBwdDecomp(itpMgr, cone1, start_i-1, fwd_j, split_i-1, 
		      useSplitUnrollConstr, useNewVars, NULL,
		      itpMgr->initStub, 
		      growCone != 1 ? 2 : 0 /*useRingConstr */ ,
		      -1/* andwithring_i*/,1 /*boundK */);

  if (fwdRing!=NULL) {
    Ddi_BddSubstVarsAcc(fwdRing, itpMgr->ns, itpMgr->ps);
  }
  if (0&& Ddi_AigSatAnd(myCone,toPlus,fwdRing)) {
    Ddi_Free(myCone);
    Ddi_Free(cone1);
    Ddi_Free(fwdRing);
    return NULL;
  }

  Pdtutil_Assert(Ddi_BddReadComposeF(myCone)!=NULL,"no split cone");
  splitB = Ddi_BddDup(Ddi_BddReadComposeF(myCone));
  splitCare = Ddi_BddDup(Ddi_BddReadComposeCare(myCone));
  splitU = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(myCone));
  splitV = Ddi_VararrayDup(Ddi_BddReadComposeVars(myCone));
  splitRel = Ddi_BddRelMakeFromArray(splitU,splitV);
  splitVars = Ddi_VarsetMakeFromArray(splitV);
  //  Ddi_BddSetAig(splitRel);

  if (0 && (toPlus!=NULL)) {
    // now in care for interpolant
    Ddi_BddAndAcc(splitRel,toPlus);
  }
  if (fwdRing!=NULL) {
    if (Ddi_BddIsPartConj(splitRel))
      Ddi_BddPartInsertLast(splitRel,fwdRing);
    else
      Ddi_BddAndAcc(splitRel,fwdRing);
  }
  Ddi_Free(fwdRing);

  //Pdtutil_Assert(Ddi_AigSat(splitRel),"unsat fwd unroll");
  int itpOpt = Ddi_MgrReadAigItpOpt(ddm);
  Ddi_MgrSetAigItpOpt(ddm, 1);
  // splitRel splitB swapped for part conj
  bwdItp = Ddi_AigSat22AndWithInterpolant(NULL,splitRel,splitB,NULL,
					  splitVars, NULL,NULL,0,
					  toPlus,NULL,
					  &sat, 0, 1, 0, itpTimeLimit);
  if (bwdItp==NULL) {
    Ddi_Free(myCone);
    Ddi_Free(cone1);
    Ddi_Free(fwdRing);
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nITP PREIMG ENDED\n");
    }
    return NULL;
  }

  if (bwdItp!=NULL) Ddi_BddNotAcc(bwdItp);
  if (1) {
    Ddi_Var_t *cvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    Ddi_Bdd_t *c = Ddi_BddMakeLiteralAig(cvarPs, 1); 
    Ddi_BddAndAcc(bwdItp,c);
    Ddi_Free(c);
  }
  Ddi_MgrSetAigItpOpt(ddm, itpOpt);

  static Ddi_Bdd_t *bddR = NULL; 
  if (0 && (bddR == NULL)) {
    Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");
    Ddi_Var_t *cvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Bdd_t *p = Ddi_BddMakeLiteral(pvarPs, 1); 
    Ddi_Bdd_t *c = Ddi_BddMakeLiteral(cvarPs, 1); 
    bddR = Ddi_BddLoad(ddm, DDDMP_VAR_MATCHNAMES,
        DDDMP_MODE_DEFAULT, "i3.bdd", NULL);
    Ddi_BddCofactorAcc(bddR,pvarPs,1);
    Ddi_BddCofactorAcc(bddR,cvarPs,1);
    Ddi_BddAndAcc(bddR,p);
    Ddi_BddAndAcc(bddR,c);
    Ddi_BddNotAcc(c);
    Ddi_BddAndAcc(p,c);
    Ddi_BddOrAcc(bddR,p);
    //    Ddi_BddSetAig(bddR);
    Ddi_BddSubstVarsAcc(bddR, itpMgr->ps, itpMgr->ns);    
    Ddi_Free(p);
    Ddi_Free(c);
  }
  if (bddR!=NULL) {
    Ddi_Bdd_t *fwd = Ddi_BddMakeAig(splitRel);
    Ddi_Varset_t *proj = Ddi_BddSupp(bwdItp);
    Ddi_Bdd_t *notR1 = Ddi_BddExistProject(bddR,splitVars);
    Ddi_Bdd_t *notR = Ddi_BddExistProject(bddR,splitVars);
    Ddi_Bdd_t *fwdR = NULL; //Ddi_BddExistProject(fwd,splitVars);
    Ddi_BddSetAig(notR);
    Ddi_BddNotAcc(notR);
    Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(fwd,
                       notR, NULL, NULL, -1.0, NULL);
    if (cex!=NULL) {
      Ddi_BddCubeExistProjectAcc(cex, splitVars);
    }
    Ddi_Free(cex);
    Ddi_BddNotAcc(notR);
    cex = Ddi_AigSatAndWithCexAndAbort(bwdItp,
                       notR, NULL, NULL, -1.0, NULL);
    if (cex!=NULL) {
      int kk;
      Ddi_BddCubeExistProjectAcc(cex, splitVars);
      for (kk=start_i-1; kk>1; kk--) {
        Ddi_Bdd_t *target = Ddi_BddDup(cex);
        Ddi_BddWriteMark(target,0);
        growConeBwd(itpMgr, target, kk, fwd_j,
                    itpMgr->delta, itpMgr->initStub, 0, -1, 0);
        if (Ddi_AigSat(target)) {
          printf("cex found\n");
        }
        Ddi_Free(target);
      }
    }
    Ddi_Free(cex);
    Ddi_Free(proj);
    Ddi_Free(fwd);
    Ddi_Free(notR);
    Ddi_Free(notR1);
    Ddi_Free(fwdR);
  }

  if (splitCare!=NULL) {
    Ddi_BddNotAcc(splitCare);
    Ddi_BddOrAcc(bwdItp,splitCare);
  }

  if (toPlus!=NULL && bwdItp!=NULL) {
    Ddi_BddAndAcc(bwdItp,toPlus);
  }

  int chkInner = 0;
  if (chkInner && (bwdItp!=NULL)) {
    int kk;
    for (kk=start_i-1; kk>1; kk--) {
      Ddi_Bdd_t *target = Ddi_BddDup(bwdItp);
      Ddi_BddWriteMark(target,0);
      growConeBwd(itpMgr, target, kk, fwd_j,
                  itpMgr->delta, itpMgr->initStub, 0, -1, 0);
      if (Ddi_AigSat(target)) {
        printf("cex found\n");
      }
      Ddi_Free(target);
    }
  }
  if (bwdItp!=NULL) {
    Ddi_Bddarray_t *splitU1 = Ddi_BddReadComposeSubst(cone1);
    Ddi_Vararray_t *splitV1 = Ddi_BddReadComposeVars(cone1);
    Ddi_Bdd_t *splitRel1 = Ddi_BddRelMakeFromArray(splitU1,splitV1);
    Ddi_Bdd_t *b2 = NULL;
    if (Ddi_AigSatAnd(splitRel1,bwdItp,NULL)) {
      if (1) {
        Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(splitRel1,
           bwdItp, NULL, NULL, -1.0, NULL);
        Ddi_BddCubeExistProjectAcc(cex, splitVars);
        Ddi_Free(cex);
      }
      b2 = Ddi_AigSat22AndWithInterpolant(NULL,splitRel1,splitB,NULL,
					  splitVars, NULL,NULL,0,
					  bwdItp,NULL,
					  &sat, 0, 1, 0, itpTimeLimit);

      if (b2!=NULL) Ddi_BddNotAcc(b2);
      Ddi_Free(splitRel1);
      if (b2==NULL) {
        Ddi_Free(bwdItp);
      }
      else {
        Ddi_Bdd_t *sC1 = Ddi_BddDup(Ddi_BddReadComposeCare(cone1));
        if (sC1 != NULL) {
          Ddi_BddNotAcc(sC1);
          Ddi_BddOrAcc(b2,sC1);
        }
        if (toPlus!=NULL) {
          Ddi_BddAndAcc(b2,toPlus);
        }
        Ddi_BddAndAcc(bwdItp,b2);
      }
    }
  }
  Ddi_Free(cone1);

  if (bwdItp!=NULL) {
    Ddi_AigOptByMonotoneCoreAcc(bwdItp,splitB,NULL,1,-1.0);
    //    Ddi_AigOptByMonotoneCoreAcc(bwdItp,splitRel,NULL,0,-1.0);
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    if (iv != NULL) {
      Ddi_Bdd_t *invar = Ddi_BddMakeLiteralAig(iv, 1);
      
      Ddi_BddAndAcc(bwdItp, invar);
      Ddi_Free(invar);
    }
  }

  //  Ddi_BddOrAcc(bwdItp,from);

  if (0) {
    int d = Ddi_BddReadMark(splitB);
    Ddi_BddWriteMark(bwdItp,d+1);
    Pdtutil_Assert(!igrChkReachable(itpMgr,bwdItp,fwd_j,k,0,0),"unsound");
  }

  Ddi_Free(splitB);
  Ddi_Free(splitCare);
  Ddi_Free(splitU);
  Ddi_Free(splitV);
  Ddi_Free(splitRel);
  Ddi_Free(splitVars);

  Ddi_Free(myCone);
  Ddi_Free(myConeChk);


  return bwdItp;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
refineBwdRingForCone(
  Trav_ItpTravMgr_t *itpTravMgr,
  Ddi_Bdd_t *cone0,
  int start_i,
  int end_i,
  int minBound,
  int *satp,
  int noCheck,
  int noSplit
)
{
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cone0);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int k, ret, bound = start_i - end_i;
  int startDepth = noSplit ? minBound-1 : minBound/3;
  int boundStep = startDepth; // bound/3
  int split_i = start_i - startDepth;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  float itpTimeLimit = travMgr->settings.aig.lazyTimeLimit;
  Ddi_Bdd_t *myCone0 = Ddi_BddDup(cone0);
  int useSplitUnrollConstr = 1;
  int useNewVars = 0;
  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitRel0 = NULL,
    *splitCare = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Varset_t *splitVars = NULL;
  Ddi_Bdd_t *splitConstr=NULL;
  Ddi_Bdd_t *bwdItp, *bwdItp1, *fwdFrom = itpTravMgr->from;
  Ddi_Bdd_t *toCare=NULL;
  int sat=0;
  int start_i_0 = start_i;
  Ddi_Bdd_t *cone_k = Ddi_BddDup(myCone0);
  int doAbstrB = 1, doAbstrA = 1, doItp=0;
  int indexes[10] = {0};
  static int chkCareRings = 0;
  Ddi_Bdd_t *invarPs=NULL;
  Ddi_Bdd_t *invarNs=NULL;
  
  // if (end_i == 0) return 0;
  
  ret = 0;
  
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nITP REFINE CONE BY PREIMG K (rings: %d-%d)\n\n",
	   end_i, start_i);
  }

  int split_i1 = split_i-(noSplit ? 0 : boundStep);
  Ddi_Vararray_t *psAux;
    
  if (noCheck) {
    int bwd_j1 = start_i-split_i1+1;
    Ddi_Bdd_t *prevBwd1=NULL;
    if (Ddi_BddarrayNum(itpMgr->bckReachedRings) <= bwd_j1)
      return 0;
    prevBwd1 = Ddi_BddarrayRead(itpMgr->bckReachedRings,bwd_j1);
    if (prevBwd1==NULL || Ddi_BddIsConstant(prevBwd1))
      return 0;
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("ITP REFINE CONE REUSES EXISTING BWD RING[%d]: %d\n\n",
               bwd_j1,Ddi_BddSize(prevBwd1));
    }
    if (satp!=NULL) {
      *satp = 0;
    }
    return bwd_j1;
  }
  
  Ddi_Var_t *ivPs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
  Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
  if (ivNs != NULL) {
    invarPs = Ddi_BddMakeLiteralAig(ivPs, 1);
    invarNs = Ddi_BddMakeLiteralAig(ivNs, 1);
  }
  

  psAux =
    Ddi_VararrayMakeNewVars(itpMgr->ps,
                              "PDT_ITP_PS_AUX_", NULL, 1);

  for (k=0; !sat && k<1 && split_i1>end_i+1;
       k++, start_i=split_i-1, split_i = split_i1,
         boundStep+=3, split_i1-=boundStep) {
    Ddi_Bdd_t *bwdCare=NULL, *bwdCare1=NULL,
      *prevBwd=NULL, *prevBwd1=NULL;
    Ddi_Bdd_t *fwdCare=NULL, *fwdCare1=NULL;
    int bwd_j = start_i-split_i+1;
    int bwd_j1 = start_i-split_i1+1;
    int prev_split = split_i-boundStep;
    int bwd_j_prev = bwd_j+boundStep;
    int invertAB = 1, refinePrevRing = 1;
    Ddi_Bdd_t *cone_k_prev = NULL;
    Ddi_Bddarray_t *initStub = itpMgr->initStub;

    int saveUbr = itpMgr->igr.useBwdRings;
    int saveUr = itpMgr->igr.useRings;
    int boundK = (growCone > 2) ? 1 : 0;

    Ddi_Bdd_t *cone_k1 = Ddi_BddDup(cone_k);
    
    itpMgr->igr.useBwdRings = 0; // k<1 ? bound/2 : 0;
    itpMgr->igr.useRings = 0; // k<1 ? bound/2 : 0;
    Ddi_BddWriteMark(cone_k,0);
    if (!noSplit) {
      growConeBwdDecomp(itpMgr, cone_k, start_i,
                      split_i1, split_i, 
		      useSplitUnrollConstr, useNewVars, NULL,
		      initStub, 
		      0 /*useRingConstr */ ,
		      -1/* andwithring_i*/,boundK);
      Pdtutil_Assert(Ddi_BddReadComposeF(cone_k)!=NULL,"no split cone");
      splitB = Ddi_BddReadComposeF(cone_k);
      splitU = Ddi_BddReadComposeSubst(cone_k);
      splitV = Ddi_BddReadComposeVars(cone_k);
      splitConstr = Ddi_BddReadComposeConstr(cone_k);
      splitRel = Ddi_BddRelMakeFromArray(splitU,splitV);
      splitVars = Ddi_VarsetMakeFromArray(splitV);
      if (splitConstr!=NULL && !Ddi_BddIsOne(splitConstr)) { 
        Ddi_BddPartInsertLast(splitRel,splitConstr);
      }    
    }
    Ddi_BddWriteMark(cone_k1,0);
    itpMgr->igr.useRings = saveUr; 
    growConeBwdDecomp(itpMgr, cone_k1, start_i, end_i, split_i1, 
		      useSplitUnrollConstr, useNewVars, NULL,
		      initStub, 
		      0 /*useRingConstr */ ,
		      -1/* andwithring_i*/,boundK);

    itpMgr->igr.useBwdRings = saveUbr; 
    itpMgr->igr.useRings = saveUr; 
    
    Pdtutil_Assert(Ddi_BddReadComposeF(cone_k1)!=NULL,"no split cone");
    Ddi_Bddarray_t *splitU1 = NULL;
    Ddi_Vararray_t *splitV1 = NULL;
    Ddi_Bdd_t *splitRel1 = NULL;
    Ddi_Bdd_t *splitB1 = NULL;

    splitB1 = Ddi_BddReadComposeF(cone_k1);
    splitU1 = Ddi_BddReadComposeSubst(cone_k1);
    splitV1 = Ddi_BddReadComposeVars(cone_k1);
    splitRel1 = Ddi_BddRelMakeFromArray(splitU1,splitV1);
    if (invarNs!=NULL) {
      Ddi_BddPartInsertLast(splitRel1,invarNs);
      Ddi_BddPartInsertLast(splitRel,invarNs);
      Ddi_BddAndAcc(splitB,invarNs);
      Ddi_BddAndAcc(splitB1,invarNs);
    }
    
    Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
    while (Ddi_BddarrayNum(itpMgr->bckReachedRings)<=bwd_j1) {
      Ddi_BddarrayInsertLast(itpMgr->bckReachedRings,myOne);
    }

    if (!noSplit) {
      if (Ddi_BddarrayRead(itpMgr->bckReachedRings,bwd_j)==NULL) {
        Ddi_BddarrayWrite(itpMgr->bckReachedRings,bwd_j,myOne);
      }
      prevBwd = Ddi_BddarrayRead(itpMgr->bckReachedRings,bwd_j);
      if (1 && Ddi_BddIsOne(prevBwd)) {
        int i;
        for (i=Ddi_BddarrayNum(itpMgr->fromRings); i>0; i--) {
          int safeBound = Trav_ItpMgrReadConeBoundOK(itpMgr,i);
          if (safeBound >= bwd_j) {
            Ddi_Bdd_t *f_i = Ddi_BddarrayRead(itpMgr->fromRings,i);
            Ddi_BddDiffAcc(prevBwd,f_i);
            break;
          }
        }
      }
    }
    Ddi_Free(myOne);
    
    prevBwd1 = Ddi_BddarrayRead(itpMgr->bckReachedRings,bwd_j1);
    if (0 && Ddi_BddIsOne(prevBwd1)) {
      int i;
      for (i=Ddi_BddarrayNum(itpMgr->fromRings); i>0; i--) {
        int safeBound = Trav_ItpMgrReadConeBoundOK(itpMgr,i);
        if (safeBound >= bwd_j1) {
          Ddi_Bdd_t *f_i = Ddi_BddarrayRead(itpMgr->fromRings,i);
          Ddi_BddDiffAcc(prevBwd1,f_i);
          break;
        }
      }
    }

    if (!noSplit) {
      bwdCare =  Ddi_BddSubstVars(prevBwd,itpMgr->ps,itpMgr->ns);
      if (Ddi_BddarrayNum(itpMgr->fromRings)>split_i)
        fwdCare = Ddi_BddarrayRead(itpMgr->fromRings,split_i);
    }
    bwdCare1 =  Ddi_BddSubstVars(prevBwd1,itpMgr->ps,itpMgr->ns);
    if (Ddi_BddarrayNum(itpMgr->fromRings)>split_i1)
      fwdCare1 = Ddi_BddarrayRead(itpMgr->fromRings,split_i1);

    if (itpMgr->igr.useBwdRings) {
      if (!noSplit && fwdCare!=NULL && !Ddi_BddIsOne(fwdCare)) {
        Ddi_Bdd_t *bwdRing = Ddi_BddNot(fwdCare);
        if (boundK)
          Ddi_BddOrAcc(splitB,bwdRing);
        Ddi_BddAndAcc(splitB,bwdCare);
        Ddi_Free(bwdRing);
      }
      if (fwdCare1!=NULL && !Ddi_BddIsOne(fwdCare1)) {
        Ddi_BddPartInsertLast(splitRel1,fwdCare1);
      }
    }
    
    if (itpTravMgr->careBwd!=NULL) {
      Ddi_Bdd_t *bwdConstr = itpTravMgr->careBwd;
      if (!Ddi_BddIsOne(bwdConstr)) {
        if (!noSplit) {
          Ddi_BddAndAcc(splitB,bwdConstr);
        }
        Ddi_BddAndAcc(splitB1,bwdConstr);
      }
    }

    if (chkCareRings) {
      if (fwdCare!=NULL) {
        Ddi_Vararray_t *auxSplitV1 = Ddi_VararraySubstVars(splitV1,
                                      itpMgr->ns,itpMgr->ps);
        Ddi_Bdd_t *fwdRel = Ddi_BddCompose(splitRel,
                                           auxSplitV1,splitU1);
        Ddi_Bdd_t *notRing = Ddi_BddNot(fwdCare);
        Pdtutil_Assert(!Ddi_AigSatAnd(fwdRel,fwdFrom,notRing),
                       "problem");
        Ddi_Free(auxSplitV1);
        Ddi_Free(notRing);
        Ddi_Free(fwdRel);
      }
      if (fwdCare1!=NULL) {
        Ddi_Bdd_t *notRing = Ddi_BddNot(fwdCare1);
        Pdtutil_Assert(!Ddi_AigSatAnd(splitRel1,fwdFrom,notRing),
                       "problem");
        Ddi_Free(notRing);
      }
      Pdtutil_Assert(Ddi_BddIncluded(splitB,bwdCare),"problem");
      Pdtutil_Assert(Ddi_BddIncluded(splitB1,bwdCare1),"problem");
    }
    if (noSplit) {
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("ITP REFINE CONE USES OLD BWD RING[%d]: %d\n",
               bwd_j1,Ddi_BddSize(bwdCare1));
      }
    }
    else {
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("ITP REFINE CONE USES OLD BWD RING[%d-%d]: %d-%d\n",
               bwd_j, bwd_j1,
             Ddi_BddSize(bwdCare), Ddi_BddSize(bwdCare1));
      }
    }

#if 1
    //    invertAB=0;
    int doReverse = k<=1;
    int maxIter = k<=1?4:1;
    int chkCone = 1;
    if (chkCone) {
    }

    int shiftFrames = Ddi_BddReadMark(cone_k1);
    int i, nFrames = split_i1 - end_i;

    int useConstrHints = 20;
    Ddi_Bdd_t *constrHints = NULL;
    Ddi_Vararray_t *constrHintsVars = NULL;
    if (useConstrHints) {
      if (itpMgr->enables==NULL) {
        itpMgr->enables = Ddi_FindIteFull(itpMgr->delta,itpMgr->ps,NULL,-1);
      }
      constrHintsVars = Ddi_VararrayAlloc(ddm, 0);
      Ddi_Bddarray_t *hintsBase = Ddi_BddarrayAlloc(ddm, 0); 
      for (int j=0; j<useConstrHints; j++) {
        if (j>=Ddi_BddarrayNum(itpMgr->enables)) break;
        char name[30];
        sprintf(name,"retime_CUT_VAR_%d$NS",j);
        Ddi_BddarrayInsertLast(hintsBase,Ddi_BddarrayRead(itpMgr->enables,j));
      }
      constrHints = timeFrameConstrWithEnablingVars(itpMgr,
                                                    hintsBase,end_i+1,split_i1-1,
                                                    end_i,initStub,constrHintsVars);
      Ddi_BddPartInsertLast(splitRel1,constrHints);
      Ddi_Free(hintsBase);
    }
    
    itpMgrFindOrAddTimeFrames(itpMgr,nFrames,shiftFrames,0);
    
    timeFrameShiftKAcc(splitRel1, itpMgr->timeFrames->PiVars,
    itpMgr->timeFrames->PiLits, shiftFrames+nFrames, shiftFrames);

    sat = itpImgPartItpByDomainCubesFwdBwd (
                  fwdFrom,splitRel1,splitRel,splitB,splitB1,
                  bwdCare1,bwdCare,fwdCare1,fwdCare,maxIter,
                  itpMgr->ps,itpMgr->ns,psAux,constrHintsVars,noSplit,
                  itpTimeLimit);

    Ddi_Free(constrHintsVars);
    Ddi_Free(constrHints);
    bwdItp1 = Ddi_BddDup(bwdCare1);
    if (!noSplit) {
      bwdItp = Ddi_BddDup(bwdCare);
    }
#else
    if (invertAB) {
      int doReverse = k<=1;
      int saveItpNnfAbstrAB = ddm->settings.aig.itpNnfAbstrAB;
      int saveItpReverse = ddm->settings.aig.itpReverse;
      // set just A
      ddm->settings.aig.itpNnfAbstrAB = k==0?1:3;
      ddm->settings.aig.itpReverse = doReverse;
      bwdItp = Ddi_AigSat22AndWithInterpolant(NULL,splitRel,splitB,NULL,
					  splitVars, NULL,NULL,0,
                                          NULL/*bwdCare*/,NULL,
					  &sat, 0, 1, 0, itpTimeLimit);
      ddm->settings.aig.itpNnfAbstrAB = saveItpNnfAbstrAB;
      ddm->settings.aig.itpReverse = saveItpReverse;
      if (bwdItp!=NULL) {
        Ddi_BddNotAcc(bwdItp);
      }
    }
    else {
      int doReverse = 1;//k>0;
      int saveItpNnfAbstrAB = ddm->settings.aig.itpNnfAbstrAB;
      int saveItpReverse = ddm->settings.aig.itpReverse;
      // set just A
      //      ddm->settings.aig.itpNnfAbstrAB = 2;
      ddm->settings.aig.itpReverse = doReverse;
      bwdItp = Ddi_AigSat22AndWithInterpolant(NULL,splitB,splitRel,NULL,
					  splitVars, NULL,NULL,0,
                                          NULL/*bwdCare*/,NULL,
					  &sat, 0, 1, 0, itpTimeLimit);
      ddm->settings.aig.itpNnfAbstrAB = saveItpNnfAbstrAB;
      ddm->settings.aig.itpReverse = saveItpReverse;
    }
#endif
    if (noSplit && bwdItp1 != NULL) {
      Ddi_Bdd_t *bR1;
      int chk1=chkCareRings;
      Ddi_Bdd_t *save=NULL;
      if (boundK) {
        Ddi_BddOrAcc(bwdItp1,cone0);
      }
      bR1 = Ddi_BddSubstVars(bwdItp1,itpMgr->ns,itpMgr->ps);
      Ddi_BddAndAcc(bR1,invarPs);
      Ddi_BddarrayWrite(itpMgr->bckReachedRings,bwd_j1,bR1);
      Ddi_Free(bR1);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nITP REFINE ITERATION %d (bwd k: %d) DONE - size: %d\n\n",
               k, bwd_j1, Ddi_BddSize(bwdItp1));
      }
      ret = bwd_j1;
    }
    else if (!noSplit && bwdItp != NULL) {
      Ddi_Bdd_t *bR, *bR1;
      int chk1=0&&chkCareRings;
      Ddi_Bdd_t *save=NULL;
      doAbstrA &= 1 && !Ddi_BddIsOne(bwdItp); // disabled
      doAbstrB &= !Ddi_BddIsOne(bwdItp);
      doItp &= !Ddi_BddIsOne(bwdItp);

      if (chk1 && splitRel0!=NULL) {
        int ret = Ddi_AigSatAnd(splitRel0,fwdFrom,bwdItp);
        Pdtutil_Assert(!ret,"unsound bwdItp before cone0");
      }
      if (boundK) {
        Ddi_BddOrAcc(bwdItp,cone0);
        Ddi_BddOrAcc(bwdItp1,cone0);
      }
      if (chk1 && splitRel0!=NULL) {
        int ret = Ddi_AigSatAnd(splitRel0,fwdFrom,bwdItp);
        Pdtutil_Assert(!ret,"unsound bwdItp after cone0");
      }
      if (chk1) {
        Pdtutil_Assert(Ddi_BddIncluded(splitB,bwdItp),"problem");
        Pdtutil_Assert(Ddi_BddIncluded(splitB1,bwdItp1),"problem");
      }
      bR = Ddi_BddSubstVars(bwdItp,itpMgr->ns,itpMgr->ps);
      bR1 = Ddi_BddSubstVars(bwdItp1,itpMgr->ns,itpMgr->ps);
      Ddi_BddAndAcc(bR1,invarPs);
      Ddi_BddAndAcc(bR,invarPs);
      Ddi_BddarrayWrite(itpMgr->bckReachedRings,bwd_j,bR);
      Ddi_BddarrayWrite(itpMgr->bckReachedRings,bwd_j1,bR1);
      Ddi_Free(bR);
      Ddi_Free(bR1);
      Ddi_Free(cone_k);
      cone_k = Ddi_BddDup(bwdItp);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nITP REFINE ITERATION %d (bwd k: %d-%d) DONE - size: %d-%d\n\n",
               k, bwd_j, bwd_j1, Ddi_BddSize(bwdItp),
               Ddi_BddSize(bwdItp1));
      }
      Ddi_Free(bwdItp);
      ret = bwd_j1;
    }
    else {
      Ddi_Free(cone_k);
      sat = 1;
    }
    Ddi_Free(splitVars);
    Ddi_Free(splitRel);
    Ddi_Free(splitRel1);
    Ddi_Free(splitRel0);
    Ddi_Free(bwdItp);
    Ddi_Free(bwdItp1);
    Ddi_Free(bwdCare);
    Ddi_Free(bwdCare1);
    Ddi_Free(cone_k_prev);
    Ddi_Free(cone_k1);
    
  }  

  Ddi_Free(invarPs);
  Ddi_Free(invarNs);
  Ddi_Free(psAux);
  Ddi_Free(cone_k);
  Ddi_Free(myCone0);
  if (satp!=NULL) {
    *satp = sat;
  }
  
  return ret;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
refineBwdRingForCone0(
  Trav_ItpTravMgr_t *itpTravMgr,
  Ddi_Bdd_t *cone0,
  int start_i,
  int end_i,
  int *satp
)
{
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cone0);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int k, ret, bound = start_i - end_i;
  int split_i = start_i - bound/4;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  float itpTimeLimit = travMgr->settings.aig.lazyTimeLimit;
  Ddi_Bdd_t *myCone0 = Ddi_BddDup(cone0);
  int useSplitUnrollConstr = 1;
  int useNewVars = 0;
  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitCare = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Varset_t *splitVars = NULL;
  Ddi_Bdd_t *bwdItp, *fwdFrom = itpTravMgr->from;
  Ddi_Bdd_t *toCare=NULL;
  int sat=0;
  int start_i_0 = start_i;
  
  if (end_i == 0) return 0;
  
  ret = 0;
  
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nITP REFINE CONE BY PREIMG K (rings: %d-%d)\n\n",
	   end_i, start_i);
  }

  for (k=0; !sat && k<2; k++,
         start_i=split_i-1, split_i-=bound/4) {
    Ddi_Bdd_t *cone_k = Ddi_BddDup(myCone0);
    Ddi_Bdd_t *bwdCare=NULL, *prevBwd=NULL;
    int bwd_j = start_i_0-split_i+1;
    int invertAB = 0, refinePrevRing = 1;
    
    growConeBwdDecomp(itpMgr, cone_k, start_i, end_i, split_i, 
		      useSplitUnrollConstr, useNewVars, NULL,
		      NULL /* no initStub: end_i>0 */, 
		      0 /*useRingConstr */ ,
		      -1/* andwithring_i*/,1 /*boundK */);


    Pdtutil_Assert(Ddi_BddReadComposeF(cone_k)!=NULL,"no split cone");
    splitB = Ddi_BddReadComposeF(cone_k);
    splitU = Ddi_BddReadComposeSubst(cone_k);
    splitV = Ddi_BddReadComposeVars(cone_k);
    splitRel = Ddi_BddRelMakeFromArray(splitU,splitV);
    splitVars = Ddi_VarsetMakeFromArray(splitV);
    Ddi_BddPartInsertLast(splitRel,fwdFrom);
    
    if (Ddi_BddarrayNum(itpMgr->bckReachedRings)>bwd_j) {
      prevBwd = Ddi_BddarrayRead(itpMgr->bckReachedRings,bwd_j);
      if (refinePrevRing&&(prevBwd!=NULL)) {
        bwdCare =  Ddi_BddSubstVars(prevBwd,itpMgr->ps,itpMgr->ns);
        if (!Ddi_BddIncluded(splitB,bwdCare)) {
          Ddi_Free(bwdCare);
        }
        else {
          Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("ITP REFINE CONE USES OLD BWD RING[%d]: %d\n",
	   bwd_j, Ddi_BddSize(bwdCare));
          }
          Ddi_BddSetAig(splitRel);
          Ddi_BddNotAcc(bwdCare);
          Ddi_BddOrAcc(splitRel,bwdCare);
          Ddi_Free(bwdCare);
        }
      }
    }
    if (invertAB) {
      bwdItp = Ddi_AigSat22AndWithInterpolant(NULL,splitRel,splitB,NULL,
					  splitVars, NULL,NULL,0,
                                          NULL/*bwdCare*/,NULL,
					  &sat, 0, 1, 0, itpTimeLimit);
      if (bwdItp!=NULL) {
        Ddi_BddNotAcc(bwdItp);
      }
    }
    else {
      bwdItp = Ddi_AigSat22AndWithInterpolant(NULL,splitB,splitRel,NULL,
					  splitVars, NULL,NULL,0,
                                          NULL/*bwdCare*/,NULL,
					  &sat, 0, 1, 0, itpTimeLimit);
    }
    Ddi_Free(cone_k);
    if (bwdItp != NULL) {
      Ddi_Bdd_t *bR;
      if (bwdCare!=NULL)
        Ddi_BddAndAcc(bwdItp,bwdCare);
      bR = Ddi_BddSubstVars(bwdItp,itpMgr->ns,itpMgr->ps);
      Ddi_BddarrayWrite(itpMgr->bckReachedRings,bwd_j,bR);
      Ddi_Free(bR);
      cone_k = Ddi_BddDup(bwdItp);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("ITP REFINE ITERATION %d (bwd k: %d) - size: %d\n",
               k, bwd_j, Ddi_BddSize(bwdItp));
      }
      Ddi_Free(bwdItp);
      ret = bwd_j;
    }
    else {
      sat = 1;
    }
    Ddi_Free(splitVars);
    Ddi_Free(splitRel);
    Ddi_Free(bwdCare);
    
  }  

  Ddi_Free(myCone0);
  if (satp!=NULL) {
    *satp = sat;
  }
  
  return ret;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
itpPreimgK(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *from,
  Ddi_Bdd_t *toPlus,
  int k,
  int bwd_k
)
{
  /* cegar/pba */
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));

  int useSplitUnrollConstr = 1;
  int useNewVars = 0;
  int start_i = k+bwd_k;
  int split_i = k+1;
  int fwd_j = 0;
  Ddi_Bdd_t *refineBwdRing=NULL;
  Ddi_Bdd_t *myCone = Ddi_BddDup(from);
  Ddi_Bdd_t *myConeChk = Ddi_BddDup(from);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);

  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitCare = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Varset_t *splitVars = NULL;
  Ddi_Bdd_t *bwdItp, *fwdRing=NULL;
  int sat;
  float itpTimeLimit = travMgr->settings.aig.lazyTimeLimit;
  int useEqRings = itpMgr->eqRings != NULL &&
    Ddi_BddarrayNum(itpMgr->eqRings) > 0;

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nITP PREIMG K: %d (rings: %d<-%d) |from|=%d\n\n", k,
	   fwd_j, start_i, Ddi_BddSize(from));
  }


  growConeBwdDecomp(itpMgr, myCone, start_i, fwd_j, split_i, 
		      useSplitUnrollConstr, useNewVars, NULL,
		      itpMgr->initStub, 
		      growCone != 1 ? 2 : 0 /*useRingConstr */ ,
		      -1/* andwithring_i*/,1 /*boundK */);


  Pdtutil_Assert(Ddi_BddReadComposeF(myCone)!=NULL,"no split cone");
  splitB = Ddi_BddDup(Ddi_BddReadComposeF(myCone));
  splitCare = Ddi_BddDup(Ddi_BddReadComposeCare(myCone));
  splitU = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(myCone));
  splitV = Ddi_VararrayDup(Ddi_BddReadComposeVars(myCone));
  splitRel = Ddi_BddRelMakeFromArray(splitU,splitV);
  splitVars = Ddi_VarsetMakeFromArray(splitV);
  //  Ddi_BddSetAig(splitRel);

  //Pdtutil_Assert(Ddi_AigSat(splitRel),"unsat fwd unroll");
  int itpOpt = Ddi_MgrReadAigItpOpt(ddm);
  Ddi_Bdd_t *toCare = NULL;
  Ddi_MgrSetAigItpOpt(ddm, 1);
  // splitRel splitB swapped for part conj
  if (toPlus!=NULL) {
    toCare = Ddi_BddNot(toPlus);
  }
  bwdItp = Ddi_AigSat22AndWithInterpolant(NULL,splitRel,splitB,NULL,
					  splitVars, NULL,NULL,0,
					  toCare,NULL,
					  &sat, 0, 1, 0, itpTimeLimit);
  Ddi_Free(toCare);
  if (bwdItp==NULL) {
    Ddi_Free(myCone);
    Ddi_Free(toPlus);
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nITP PREIMG ENDED\n");
    }
    return NULL;
  }

  Ddi_BddNotAcc(bwdItp);
  if (1) {
    Ddi_Var_t *cvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    Ddi_Bdd_t *c = Ddi_BddMakeLiteralAig(cvarPs, 1); 
    Ddi_BddAndAcc(bwdItp,c);
    Ddi_Free(c);
  }
  Ddi_MgrSetAigItpOpt(ddm, itpOpt);

  if (0 && splitCare!=NULL) {
    /* need review */
    Ddi_BddNotAcc(splitCare);
    Ddi_BddOrAcc(bwdItp,splitCare);
  }

  if (toPlus!=NULL && bwdItp!=NULL) {
    Ddi_BddAndAcc(bwdItp,toPlus);
  }

  if (bwdItp!=NULL) {
    Ddi_AigOptByMonotoneCoreAcc(bwdItp,splitB,NULL,1,-1.0);
    //    Ddi_AigOptByMonotoneCoreAcc(bwdItp,splitRel,NULL,0,-1.0);
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    if (iv != NULL) {
      Ddi_Bdd_t *invar = Ddi_BddMakeLiteralAig(iv, 1);
      
      Ddi_BddAndAcc(bwdItp, invar);
      Ddi_Free(invar);
    }
  }

  //  Ddi_BddOrAcc(bwdItp,from);

  if (0) {
    int d = Ddi_BddReadMark(splitB);
    Ddi_BddWriteMark(bwdItp,d+1);
    Pdtutil_Assert(!igrChkReachable(itpMgr,bwdItp,fwd_j,k,0,0),"unsound");
  }

  Ddi_Free(splitB);
  Ddi_Free(splitCare);
  Ddi_Free(splitU);
  Ddi_Free(splitV);
  Ddi_Free(splitRel);
  Ddi_Free(splitVars);

  Ddi_Free(myCone);
  Ddi_Free(myConeChk);


  return bwdItp;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
igrChkReachable(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone,
  int fwd_j,
  int start_j,
  int useEqRings,
  int psnsSubst
)
{
  /* cegar/pba */
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int mySat, chk = 1, cexHit = 1;
  Ddi_Bdd_t *currRing=NULL;
  Ddi_Bddarray_t *delta = itpMgr->delta;
  int bwd_j;
  Ddi_Bdd_t *myCone = NULL;

  static int ncalls = 0;

  ncalls++;

  Pdtutil_Assert(start_j>=0,"missing start_j in bwd ref");

  /* find safe bwd ring */
  myCone = Ddi_BddDup(cone);
  if (psnsSubst) {
    Ddi_BddSubstVarsAcc(myCone, itpMgr->ps, itpMgr->ns);
  }
  growConeBwd(itpMgr, myCone, start_j, fwd_j,
	      delta, itpMgr->initStub, useEqRings ? 2 : 0, -1, 0 /*boundK */ );
  if (fwd_j>0) {
    Pdtutil_Assert(Ddi_BddarrayNum(itpMgr->fromRings)>fwd_j,"missing fwd ring");
    currRing = Ddi_BddarrayRead(itpMgr->fromRings, fwd_j);
    Ddi_BddAndAcc(myCone,currRing);
  }
  cexHit = Ddi_AigSat(myCone);
  Ddi_Free(myCone);

  return cexHit;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
igrBwdRef(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone0,
  int bwdCone_j,
  int fwd_j,
  int start_j,
  int useEqRings,
  int doTrav,
  int *resP
)
{
  /* cegar/pba */
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int mySat, chk = 1, cexHit = 1;
  Ddi_Bdd_t *currRing=NULL;
  Ddi_Bddarray_t *delta = itpMgr->delta;
  int bwd_j;
  int chkFp = 1;
  int maxIter = 10;

  static int ncalls = 0;

  ncalls++;

  Pdtutil_Assert(start_j>=0,"missing start_j in bwd ref");

  /* find safe bwd ring */
  int bwd_expand_cone = 0;
#if IGR_BWD_FORCE_EXPAND_BWD
  bwd_expand_cone = 1;
#endif
  if (bwd_expand_cone) {
    bwd_j = bwdCone_j;
    cexHit = 0;
  }
  else {
    int nMinor = 0, m;
    for (bwd_j=bwdCone_j; cexHit && bwd_j>=0; bwd_j--) {
    Ddi_Bdd_t *myCone1, *myCone = 
      Ddi_BddDup(Ddi_BddarrayRead(itpMgr->bckReachedRings,bwd_j));
    Ddi_BddSubstVarsAcc(myCone, itpMgr->ps, itpMgr->ns);
    myCone1 = Ddi_BddDup(myCone);
    growConeBwd(itpMgr, myCone, start_j, fwd_j,
		delta, itpMgr->initStub, useEqRings ? 2 : 0, -1, 2 /*boundK */ );
    if (nMinor>=start_j-fwd_j) {
      nMinor = start_j-fwd_j-1;
    }
    for (m=1; m<=nMinor; m++) {
      Ddi_Bdd_t *cone1 = Ddi_BddDup(myCone);
      growConeBwd(itpMgr, cone1, start_j-m, fwd_j,
		delta, itpMgr->initStub, useEqRings ? 2 : 0, -1, 2 /*boundK */ );
      Ddi_BddOrAcc(myCone,cone1);
      Ddi_Free(cone1);
    }
    Ddi_Free(myCone1);
    if (fwd_j>0) {
      Pdtutil_Assert(Ddi_BddarrayNum(itpMgr->fromRings)>fwd_j,"missing fwd ring");
      currRing = Ddi_BddarrayRead(itpMgr->fromRings, fwd_j);
      Ddi_BddAndAcc(myCone,currRing);
    }
    cexHit = Ddi_AigSat(myCone);
    Ddi_Free(myCone);
  }
  bwd_j++;
  }

  if (cexHit) {
    *resP = 1;
    return 0;
  }
  else {
    *resP = -1;
  }

  /* if safe ring found, do bwd traversal/refinement */

  /* now try just one pre-img and stop */

  Ddi_Bdd_t *prevReached = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *reached = 
    Ddi_BddDup(Ddi_BddarrayRead(itpMgr->bckReachedRings,bwd_j));

  if (!doTrav) {
    int incrRing = 0;
    Ddi_Bdd_t *from = NULL;
    Ddi_Bdd_t *toPlus = NULL;
    Ddi_Bdd_t *to = NULL;
    if (cone0!=NULL) {
      from = Ddi_BddDup(cone0);
    }
    else {
      from = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->bckReachedRings,0));
      Ddi_BddSubstVarsAcc(from, itpMgr->ps, itpMgr->ns);
    }
    if (incrRing) {
      while (2*(start_j-fwd_j) > bwd_j) 
        bwd_j++;
    }
    else {
      toPlus = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->bckReachedRings,bwd_j));
      Pdtutil_Assert(toPlus!=NULL,"missing bwd ring");
      Ddi_BddSubstVarsAcc(toPlus, itpMgr->ps, itpMgr->ns);
    }
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nITP REFINING BWD RING: %d - cone0 size: %d\n", bwd_j, Ddi_BddSize(from));
    }

    to = itpPreimgK(itpMgr,from,toPlus,start_j,bwd_j);
    Ddi_Free(from);

    if (to!=NULL) {
      Ddi_BddSubstVarsAcc(to, itpMgr->ns, itpMgr->ps);
      Ddi_BddWriteMark(to, bwd_j);
      Ddi_BddarrayWrite(itpMgr->bckReachedRings,bwd_j,to);
      Ddi_Free(to);
    }
  }
  
  while (doTrav && (maxIter-- > 0)) {
    Ddi_Bdd_t *toPlus = NULL;
    Ddi_Bdd_t *from = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->bckReachedRings,bwd_j));
    Ddi_Bdd_t *to = NULL;

    int useNew=1;
    if (useNew && prevReached!=NULL) {
      Ddi_BddDiffAcc(from,prevReached);
    }
    Ddi_BddSubstVarsAcc(from, itpMgr->ps, itpMgr->ns);
    if (cone0!=NULL) {
      Ddi_BddOrAcc(from,cone0);
    }
    if (Ddi_BddarrayNum(itpMgr->bckReachedRings)>(bwd_j+1)) {
      toPlus = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->bckReachedRings,bwd_j+1));
      Ddi_BddSubstVarsAcc(toPlus, itpMgr->ps, itpMgr->ns);
    }

    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nITP BWD RING: %d - size: %d\n", bwd_j, Ddi_BddSize(from));
    }

    to = itpPreimg(itpMgr,from,toPlus,start_j,fwd_j);
    Ddi_Free(from);
    Ddi_Free(toPlus);

    if (to!=NULL) {
      Ddi_BddSubstVarsAcc(to, itpMgr->ns, itpMgr->ps);

      bwd_j++;
      Ddi_BddWriteMark(to, bwd_j);
      Ddi_BddarrayWrite(itpMgr->bckReachedRings,bwd_j,to);
      if (chkFp&&(bwd_j>1)) {
	if (Ddi_BddIncluded(to,reached)) {
	  printf("BWD FIX POINT\n");
	  Pdtutil_Assert(0,"bwd igr fix point not handled");
	}
      }
      Ddi_Free(prevReached);
      prevReached = Ddi_BddDup(reached);
      Ddi_BddOrAcc(reached,to);
      Ddi_Free(to);
    }
    else {
      doTrav = 0;
    }
  }
  Ddi_Free(reached);
  Ddi_Free(prevReached);

  return bwd_j;

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
igrRefineRingsBwd(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone0,
  int bwdCone_k,
  int fwd_j,
  int start_j,
  int useEqRings,
  int doTrav,
  int *resP
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int mySat, chk = 1, cexHit = 1;
  int bwd_k, curr_j;
  Ddi_Bdd_t *from;
  
  static int ncalls = 0;

  ncalls++;

  Pdtutil_Assert(start_j>=0,"missing start_j in bwd ref");

  bwd_k = bwdCone_k;

  /* do bwd traversal/refinement */

  /* now try just one pre-img and stop */

  from = Ddi_BddDup(cone0);
  curr_j = start_j-bwdCone_k;

  int refined = 1;
  
  for (curr_j = start_j-bwdCone_k; curr_j>fwd_j; curr_j--) {
    Ddi_Bdd_t *toPlus = NULL;
    Ddi_Bdd_t *to = NULL, *fwdRing=NULL;

    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nBWD RING REFINEMENT: %d - cone/ring size: %d\n",
             bwd_k, Ddi_BddSize(cone0));
    }

    to = itpPreimgOnFwdRings(itpMgr,from,bwdCone_k,
                             curr_j,fwd_j,0,&refined);
    if (curr_j>0) {
      while (Ddi_BddarrayNum(itpMgr->fromRings)<=curr_j) {
        Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
        Ddi_BddarrayInsertLast(itpMgr->fromRings,myOne);
        Ddi_Free(myOne);
      }
      fwdRing = Ddi_BddarrayRead(itpMgr->fromRings, curr_j);
      Ddi_BddAndAcc(fwdRing,to);
    }
    Pdtutil_Assert (to!=NULL,"null preimg");
    
    Ddi_Free(from);
    from = Ddi_BddNot(fwdRing);
    Ddi_Free(to);
    Ddi_Var_t *cvarNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    Ddi_Bdd_t *invarLit = Ddi_BddMakeLiteralAig(cvarNs, 1);
    Ddi_BddAndAcc(from,invarLit);
    Ddi_Free(invarLit);
    if (!refined)
      break;
    bwd_k++;
    bwdCone_k = 0;
    Ddi_BddWriteMark(from, bwd_k);
  }

  Ddi_Free(from);
  
  return bwd_k;

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_IgrTrav(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * itpCone,
  Ddi_Bdd_t * itpCare,
  Ddi_Bdd_t * rOut,
  Ddi_Bdd_t * careOut,
  int bwdK,
  int recLevel,
  int *itpBmcBoundP,
  int *abortP,
  int *satP
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(itpCone);
  int ret;
  Ddi_Vararray_t *ps = itpMgr->ps;
  int hints = itpMgr->hints.hintsNum;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int doCofactor = 0;
  int abstrRef = Trav_MgrReadAbstrRef(travMgr) % 100;
  int doAbstrRef = abstrRef == 1 || abstrRef == 2;


  if (0) {
    Ddi_Bddarray_t *en =
      Ddi_FindIte(itpMgr->delta, itpMgr->ps, -1);
    Ddi_Bdd_t *en0 = Ddi_BddarrayRead(en,0);
    Ddi_Bddarray_t *d0 = Ddi_BddarrayDup(itpMgr->delta);
    Ddi_Bddarray_t *d1 = Ddi_BddarrayDup(itpMgr->delta);
    Ddi_AigarrayConstrainAcc (d0,en0,0);
    Ddi_AigarrayConstrainAcc (d1,en0,1);
    Ddi_Free(d0);
    Ddi_Free(d1);
    Ddi_Free(en);
  }

  if (hints>Ddi_VararrayNum(ps)) {
    Pdtutil_Warning(1,"too few PS vars. Hints disabled");
    hints = 0;
  }

  if (!hints) {

    float gcm = travMgr->settings.aig.igrGrowConeMax;
    int gc = travMgr->settings.aig.igrGrowCone;
    int sd = travMgr->settings.aig.igrSide;
    int fwdBwd = travMgr->settings.aig.igrFwdBwd;

    if (travMgr->settings.ints.igrSingleRewind > 0) {
      travMgr->settings.aig.igrGrowConeMax = -1.0;
      travMgr->settings.aig.igrGrowCone = 0;
      travMgr->settings.aig.igrSide = 0;
      travMgr->settings.aig.igrFwdBwd = 0;
    }
    ret = igrTravIntern(travMgr,fsmMgr,itpMgr,itpCone,itpCare,
		     rOut,careOut,bwdK,recLevel,itpBmcBoundP,
		     abortP,satP);
    travMgr->settings.ints.igrSingleRewind = -1;
    travMgr->settings.aig.igrGrowConeMax = gcm;
    travMgr->settings.aig.igrGrowCone = gc;
    travMgr->settings.aig.igrSide = sd;    
    travMgr->settings.aig.igrFwdBwd = fwdBwd;
  }
  else {
    int var0_i = itpMgr->hints.invar0_i;
    int var_i = itpMgr->hints.invar_i;
    int iRing = -1, iter=0;;
    Ddi_Bdd_t *deltaConstr, *deltaConstr0;
    itpMgr->hints.hintsEnabled = 2;
    while (itpMgr->hints.hintsNum>=0) {
      int nRings = -1;
      Ddi_Bddarray_t *deltaSave = NULL;
      if (doCofactor) {
	deltaSave = Ddi_BddarrayDup(itpMgr->delta);
	int iConstr0 = itpMgr->hints.invar0_i;
	int iConstr = itpMgr->hints.invar_i;
	int iProp = iConstr+1;
	Ddi_Bdd_t *deltaConstr0 = Ddi_BddarrayRead(deltaSave,iConstr0);
	Ddi_Bdd_t *deltaConstr = Ddi_BddarrayRead(deltaSave,iConstr);
	Ddi_Bdd_t *deltaProp = Ddi_BddarrayRead(deltaSave,iProp);
	if (itpMgr->hints.hintsArray!=NULL) {
	  Ddi_AigarrayStructRedRemWithConstrAcc (itpMgr->delta, NULL, 
						 itpMgr->hints.hintsConstr);
	}
	else {
	  Ddi_AigarrayConstrainCubeAcc(itpMgr->delta, itpMgr->hints.hintsConstr);
	}
	Ddi_BddarrayWrite(itpMgr->delta,iConstr0,deltaConstr0);
	Ddi_BddarrayWrite(itpMgr->delta,iConstr,deltaConstr);
	Ddi_BddarrayWrite(itpMgr->delta,iProp,deltaProp);
      }
      Ddi_Bdd_t *saveConstr = NULL;
      if (itpMgr->invarConstr!=NULL) {
	saveConstr = Ddi_BddDup(itpMgr->invarConstr);
	Ddi_BddAndAcc(itpMgr->invarConstr,itpMgr->hints.hintsConstr);
      }
      else {
	saveConstr = Ddi_BddMakeConstAig(ddm, 1);
      }
      Ddi_Free(itpMgr->invarConstr);
      itpMgr->invarConstr = Ddi_BddDup(itpMgr->hints.hintsConstr);
      Ddi_BddSubstVarsAcc(itpMgr->invarConstr,
                          itpMgr->pi,itpMgr->auxVarPis);

      ret = igrTravIntern(travMgr,fsmMgr,itpMgr,itpCone,itpCare,
		     rOut,careOut,bwdK,recLevel,itpBmcBoundP,
		     abortP,satP);
      Ddi_Free(itpMgr->invarConstr);
      if (saveConstr!=NULL) {
	itpMgr->invarConstr = saveConstr;
	saveConstr = NULL;
      }
      if (doCofactor) {
	Ddi_DataCopy(itpMgr->delta,deltaSave);
	Ddi_Free(deltaSave);
      }
      if (!ret || itpMgr->hints.hintsNum==0) return ret;

      nRings = itpMgr->lastRingId+1;
      Pdtutil_Assert(nRings>=0,"Problem with IGR ring count");
      while (Ddi_BddarrayNum(itpMgr->fromRings)>nRings) {
	Ddi_BddarrayRemove(itpMgr->fromRings,Ddi_BddarrayNum(itpMgr->fromRings)-1);
      }
      if (itpMgr->eqRings != NULL) {
	while (Ddi_BddarrayNum(itpMgr->eqRings)>nRings) {
	  Ddi_BddarrayRemove(itpMgr->eqRings,Ddi_BddarrayNum(itpMgr->eqRings)-1);
	}
      }
      *itpBmcBoundP = -nRings;
#if 0
      itpMgr->hints.hintsNum -= 2;
      if (itpMgr->hints.hintsNum<0) {
	itpMgr->hints.hintsNum = 0;
      }
#endif
      int hints = itpMgr->hints.hintsNum;
      // old constr + with history (and with ps lit)
      //      Ddi_Var_t *ps_i = Ddi_VararrayRead(itpMgr->ps,var0_i);
      //Ddi_Bdd_t *hLit = Ddi_BddMakeLiteralAig(ps_i, 1);
      //      int chk=doAbstrRef?0:2;
      int chk=0 && (doAbstrRef?1:0);
      if (1 && chk) {
	int myChkRings = itpCheckRingsFwd(itpMgr,-1,-1,0);
	printf("RING CHECK: %d\n", myChkRings);
	Pdtutil_Assert(myChkRings,"problem with from rings");
      }

      iRing = igrHintsUpdateRingsAndConstr(itpMgr);
      if (1 && iRing>0) {
	*itpBmcBoundP = -(iRing+1);
      }
      else if (1 && iRing==0) {
	*itpBmcBoundP = -(iRing+2); // has to be >1
      } 

      if (itpMgr->hints.hintsArray!=NULL) {
        itpMgr->hints.hintsNum = hints = 
          Ddi_BddarrayNum(itpMgr->hints.hintsArray);
      }
      else {
        itpMgr->hints.hintsNum = hints = 
          Ddi_VararrayNum(itpMgr->hints.hintsVars);
      }
      
      if (hints <= 1) {
	itpMgr->hints.hintsMaxStep = -1;
      }
      int j;
      for (j=0; j<hints; j++) {
	if (itpMgr->hints.hintsArray!=NULL) {
	  Ddi_Bdd_t *h_j = Ddi_BddarrayRead(itpMgr->hints.hintsArray,j);
	  Ddi_BddAndAcc(itpMgr->hints.hintsConstr,h_j);
	}
	else {
	  Ddi_Var_t *ps_i = Ddi_VararrayRead(itpMgr->hints.hintsVars,j);
	  Ddi_Bdd_t *hLit = Ddi_BddMakeLiteralAig(ps_i, 1);
	  Ddi_BddDiffAcc(itpMgr->hints.hintsConstr,hLit);
	  Ddi_Free(hLit);
	}
      }
      
      deltaConstr = Ddi_BddarrayRead(itpMgr->delta,var_i);
      Ddi_Bdd_t *hConstr = Ddi_BddDup(itpMgr->hints.hintsConstr);
      if (itpMgr->hints.strategy>3 && itpMgr->hints.strategy<=10) {
	Ddi_BddComposeAcc(hConstr,itpMgr->ps,itpMgr->delta);
      }
      Ddi_BddAndAcc(deltaConstr,hConstr);
      Ddi_Free(hConstr);

      if (1) {
	int iProp = itpMgr->hints.invar_i+1;
	int iConstr = itpMgr->hints.invar_i;
	Ddi_Var_t *vProp = Ddi_VararrayRead(itpMgr->ps,iProp);
	Ddi_Var_t *vConstr = Ddi_VararrayRead(itpMgr->ps,iConstr);
	Ddi_Bdd_t *negProp = Ddi_BddMakeLiteralAig(vProp, 0);
	Ddi_Bdd_t *litConstr = Ddi_BddMakeLiteralAig(vConstr, 1);
	Ddi_BddAndAcc(negProp,litConstr);
        //	Ddi_BddOrAcc(deltaConstr,negProp);
	Ddi_Free(negProp);
	Ddi_Free(litConstr);	
      }

      if (doAbstrRef) {
	Ddi_BddarrayWrite(itpMgr->deltaAbstr,var_i,deltaConstr); 

	Ddi_Bdd_t *nsLit_i0 = Ddi_BddarrayRead(itpMgr->nsLit, var0_i);
	Ddi_Bdd_t *nsLit_i = Ddi_BddarrayRead(itpMgr->nsLit, var_i);

	Ddi_Bdd_t *tr_i0 = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->deltaAbstr, var0_i));
	Ddi_Bdd_t *tr_i = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->deltaAbstr, var_i));
	Ddi_BddXnorAcc(tr_i0, nsLit_i0);
	Ddi_BddXnorAcc(tr_i, nsLit_i);
	Ddi_BddSubstVarsAcc(tr_i0,itpMgr->pi,itpMgr->auxVarPis);
	Ddi_BddSubstVarsAcc(tr_i,itpMgr->pi,itpMgr->auxVarPis);
	Ddi_BddarrayWrite(itpMgr->trArrayAbstr,var0_i,tr_i0);
	Ddi_BddarrayWrite(itpMgr->trArrayAbstr,var_i,tr_i);
	Ddi_Free(tr_i0);
	Ddi_Free(tr_i);
	Ddi_Free(itpMgr->trAuxAbstr);
	Ddi_Free(itpMgr->trAbstr);
	itpMgr->trAbstr = Ddi_BddMakePartConjFromArray(itpMgr->trArrayAbstr);
	itpMgr->trAuxAbstr = Ddi_BddDup(itpMgr->trAbstr);
      }

      if (1) {
	Ddi_Bdd_t *tr_i = 
	  Ddi_BddDup(Ddi_BddarrayRead(itpMgr->delta,var0_i));
	Ddi_Var_t *ns_i = Ddi_VararrayRead(itpMgr->ns,var0_i);
	Ddi_Bdd_t *nLit = Ddi_BddMakeLiteralAig(ns_i, 1);
	Ddi_BddXnorAcc(tr_i,nLit);
	Ddi_Free(nLit);
	Ddi_BddSubstVarsAcc(tr_i,itpMgr->pi,itpMgr->auxVarPis);
	Ddi_BddarrayWrite(itpMgr->trArray,var0_i,tr_i);
	Ddi_Free(tr_i);
	tr_i = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->delta,var_i));
	ns_i = Ddi_VararrayRead(itpMgr->ns,var_i);
	nLit = Ddi_BddMakeLiteralAig(ns_i, 1);
	Ddi_BddXnorAcc(tr_i,nLit);
	Ddi_Free(nLit);
	Ddi_BddSubstVarsAcc(tr_i,itpMgr->pi,itpMgr->auxVarPis);
	Ddi_BddarrayWrite(itpMgr->trArray,var_i,tr_i);
	Ddi_Free(tr_i);
	Ddi_Free(itpMgr->tr);
	itpMgr->tr = Ddi_BddMakePartConjFromArray(itpMgr->trArray);
	Ddi_BddSetAig(itpMgr->tr);
	Ddi_DataCopy(itpMgr->trAux,itpMgr->tr);
      }
  
      if (chk>1) {
	int myChkRings = itpCheckRingsFwd(itpMgr,-1,-1,0);
	printf("RING CHECK: %d\n", myChkRings);
	Pdtutil_Assert(myChkRings,"problem with from rings");
      }

      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
	fprintf(tMgrO(travMgr),
		"New hint management (%d hints - iter: %d) at ring: %d\n", hints, ++iter, iRing));
    

    }
    return ret;

#if 0
  itpMgr->hints.invar_i = var_i+1;
  itpMgr->hints.invar0_i = var_i;

  hintsVars = itpMgr->hints.hintsVars = Ddi_VararrayAlloc(ddm, 0);
  hintsIds = itpMgr->hints.hintsIds = Pdtutil_Alloc(int, hints);

  itpMgr->hints.hintsConstr = Ddi_BddMakeConstAig(ddm, 1);

  int start = 0;
  int j;
  deltaProp = 
    Ddi_BddNot(Ddi_BddarrayRead(itpMgr->delta,itpMgr->hints.invar_i));
  for (i=j=0; j<hints && i<Ddi_VararrayNum(pi); i++) {
    Ddi_Var_t *ps_i = Ddi_VararrayRead(pi,i);
    Ddi_Bdd_t *hLit = Ddi_BddMakeLiteralAig(ps_i, 1);
    Ddi_Bdd_t *dpDup = Ddi_BddCofactor(deltaProp,ps_i,0);
    if (Ddi_AigSat(dpDup)) {
      Ddi_BddDiffAcc(itpMgr->hints.hintsConstr,hLit);
      Ddi_VararrayInsertLast(hintsVars,ps_i);
      hintsIds[j++] = i;
      Ddi_BddCofactorAcc(deltaProp,ps_i,0);
    }
    Ddi_Free(dpDup);
    Ddi_Free(hLit);
  }
  Ddi_Free(deltaProp);

  pv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR0_VAR$PS");
  nv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR0_VAR$NS");
  if (pv == NULL) {
    pv = Ddi_VarNew(ddm);
    nv = Ddi_VarNew(ddm);
    Ddi_VarAttachName(pv, "PDT_BDD_INVAR0_VAR$PS");
    Ddi_VarAttachName(nv, "PDT_BDD_INVAR0_VAR$NS");
  }
  pvLit = Ddi_BddMakeLiteralAig(pv, 1);
  nvLit = Ddi_BddMakeLiteralAig(nv, 1);
  
  Ddi_VararrayInsert(itpMgr->ps, var_i, pv);
  Ddi_VararrayInsert(itpMgr->ns, var_i, nv);
  
  // so far just make any state as new
  Ddi_Bdd_t *zeroConst = Ddi_BddMakeConstAig(ddm, 0);
  if (itpMgr->initStub != NULL) {
    Ddi_BddarrayInsert(itpMgr->initStub,var_i,zeroConst);
  } else {
    Ddi_BddDiffAcc(itpMgr->init,pvLit);
    //    Ddi_BddAndAcc(itpMgr->init,pvLit);
  }
  
  //  Ddi_BddarrayInsert(itpMgr->delta,var_i,pvLit);

  Ddi_BddarrayInsert(itpMgr->delta,var_i,zeroConst); 
  Ddi_Free(zeroConst);




    for (iter=0; iter<hints; iter++) {
      int hintSize = hints-iter;
      // apply  hint

      // reduce hint
      Ddi_VararrayRemove(hintsVars,hintSize-1);
    }
#endif
  }

  return ret;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
igrHintsUpdateRingsAndConstr(
  Trav_ItpMgr_t *itpMgr
)
{
  Ddi_Mgr_t *ddm = itpMgr->ddiMgr;
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  int iProp = itpMgr->hints.invar_i+1;
  int iConstr = itpMgr->hints.invar_i;
  int iConstr0 = itpMgr->hints.invar0_i;
  Ddi_Bdd_t *deltaProp = Ddi_BddarrayRead(itpMgr->delta,iProp);
  Ddi_Bdd_t *deltaConstr = Ddi_BddarrayRead(itpMgr->delta,iConstr);
  Ddi_Bdd_t *target = Ddi_BddDup(itpMgr->target);
  Ddi_Bdd_t *invar = Ddi_BddDup(itpMgr->invarConstr);
  Ddi_Bddarray_t *fromRings = itpMgr->fromRings;
  Ddi_Bddarray_t *bckReachedRings = itpMgr->bckReachedRings;
  Ddi_Bdd_t *reached = NULL;
  int remove = itpMgr->hints.hintsNum/10;
  int saveBwdRings = 0;
  int iRing = -1;

  if (remove == 0) remove = 1;
  Ddi_BddSubstVarsAcc(target, itpMgr->ps, itpMgr->ns);
  //      chk = Ddi_BddAnd(care,pLit);

  Pdtutil_Assert(fromRings != NULL,"rings needed for hints");
  int jj;
  Ddi_Var_t *cvarNs = Ddi_VararrayRead(itpMgr->ns,iConstr); 
  Ddi_Var_t *cvar0Ns = Ddi_VararrayRead(itpMgr->ns,iConstr0); 
  Ddi_Bdd_t *lit1 = Ddi_BddMakeLiteralAig(cvar0Ns, 1);
  Ddi_Bdd_t *lit0 = Ddi_BddMakeLiteralAig(cvar0Ns, 0);
  Ddi_Bdd_t *invar1 = Ddi_BddMakeLiteralAig(cvarNs, 1);
  Ddi_Bdd_t *invar0 = Ddi_BddMakeLiteralAig(cvarNs, 0);
  Ddi_Bdd_t *currConstr = Ddi_BddDup(itpMgr->hints.hintsConstr);
  Ddi_Var_t *cvarPs = Ddi_VararrayRead(itpMgr->ps,iConstr); 
  Ddi_Var_t *cvar0Ps = Ddi_VararrayRead(itpMgr->ps,iConstr0); 
  Ddi_Bdd_t *invar1ps = Ddi_BddMakeLiteralAig(cvarPs, 1);
  Ddi_Bdd_t *lit1ps = Ddi_BddMakeLiteralAig(cvar0Ps, 1);
  int nRings = Ddi_BddarrayNum(itpMgr->fromRings);
  int checkOutOfConstr = 0;

  int abstrRef = Trav_MgrReadAbstrRef(travMgr) % 100;
  int doAbstrRef = abstrRef == 1 || abstrRef == 2;

  Ddi_BddWriteMark(target,0);
  growConeBwd(itpMgr, target, 1+nRings/2, 1, NULL,
	      NULL, 0, -1, 0 /*boundK */ );

  Ddi_DataCopy(deltaConstr,itpMgr->hints.saveConstr);

  Ddi_Free(itpMgr->hints.hintsConstr);
  itpMgr->hints.hintsConstr = Ddi_BddMakeConstAig(ddm, 1);

  if (itpMgr->eqRings != NULL) {
    int j;
    for (j=Ddi_BddarrayNum(itpMgr->eqRings)-1; j>0; j--) {
      Ddi_Bdd_t *eq = Ddi_BddarrayRead(itpMgr->eqRings, j);
      Ddi_Bdd_t *ring_j = Ddi_BddarrayRead(itpMgr->fromRings, j);
      if (eq != NULL) {
	Ddi_BddSetPartConj(ring_j);
	Pdtutil_Assert(Ddi_BddPartNum(ring_j) == 1,
		       "error in ring as part");
	Ddi_BddPartWrite(ring_j, 1, eq);
	Ddi_BddarrayRemove(itpMgr->eqRings,j);
	Ddi_BddSetAig(ring_j);
      }
    }
  }

  Ddi_Bdd_t *ring = NULL;
  Ddi_Bdd_t *currHint = Ddi_BddDup(currConstr);
  Ddi_Bdd_t *currHintNs = Ddi_BddDup(currConstr);
  Ddi_Bdd_t *myTr = Ddi_BddRelMakeFromArray(itpMgr->delta, itpMgr->ns);
  Ddi_BddSetAig(myTr);
  //  Ddi_BddSubstVarsAcc(myTr,itpMgr->pi,itpMgr->auxVarPis);
#if 0
  reached = Ddi_BddMakeConstAig(ddm, 0);
  for (jj = 1; jj < nRings; jj++) {
    Ddi_BddOrAcc(reached,Ddi_BddarrayRead(itpMgr->fromRings,jj));
  }
#endif
  int start = nRings/2;
  Ddi_BddSubstVarsAcc(currHintNs,itpMgr->ps,itpMgr->ns);
  for (jj = start; jj < nRings; jj++) {
    //for (jj = nRings-1; jj>=0; jj--) {
    int next = jj<nRings-1?1:0;
    Ddi_Bdd_t *f_0, *f_1;
    if (jj==0) {
      if (itpMgr->initStub!=NULL) {
	f_0 = Ddi_BddRelMakeFromArray(itpMgr->initStub, itpMgr->ps);
	Ddi_BddSetAig(f_0);
      }
      else {
	f_0 = Ddi_BddDup(itpMgr->init);
      }
    }
    else {
      f_0 = Ddi_BddDup(Ddi_BddarrayRead(fromRings, jj));
      Ddi_BddSubstVarsAcc(f_0,itpMgr->ns,itpMgr->ps);
    }
    Ddi_BddAndAcc(f_0,invar1ps);
    if (reached == NULL) 
      f_1 = Ddi_BddNot(Ddi_BddarrayRead(fromRings, jj+next));
    else 
      f_1 = Ddi_BddNot(reached);
    if (checkOutOfConstr==1) {
      Ddi_Bdd_t *extraConstr = Ddi_BddNot(currHint);
      Ddi_BddSubstVarsAcc(extraConstr,itpMgr->ps,itpMgr->ns);
      Ddi_BddAndAcc(f_1,extraConstr);
      Ddi_Free(extraConstr);
    }
    if (checkOutOfConstr==2) {
      Ddi_BddAndAcc(f_1,target);
    }
    Ddi_BddDiffAcc(f_1,invar0);
    if (1) {
      Ddi_Bdd_t *f_10 = Ddi_BddCofactor(f_1,cvar0Ns,0);
      Ddi_BddCofactorAcc(f_1,cvar0Ns,1);
      Ddi_BddAndAcc(f_1,f_10);
      Ddi_Free(f_10);
    }

    //    Ddi_AigConstrainCubeAcc(f_1,currHintNs);

    //    Ddi_BddComposeAcc(f_1,itpMgr->ns,itpMgr->delta);
    // Ddi_BddAndAcc(f_0,lit1);
    Ddi_BddAndAcc(f_1,lit0); // look for new states just out of old ones 
    if (Ddi_AigSatAnd(f_0,f_1,myTr)) {
      Ddi_Bdd_t *saveHint = Ddi_BddDup(currHint);
      int isCube = Ddi_BddIsCube(currHint) || Ddi_BddIsConstant(currHint);
      Ddi_BddAndAcc(f_1,f_0);
      Ddi_BddAndAcc(f_1,myTr);
      if (!Ddi_AigSatMinisatWithAbortAndFinal(f_1,currHint,-1.0,0)) {
	if (isCube) {
	  Ddi_Bdd_t *f_1Save = Ddi_BddDup(f_1);
	  int cntVars = 0;
	  do {
	    Ddi_Vararray_t *select = Ddi_BddSuppVararray(currHint);
	    if (Ddi_VararrayNum(select)==0) {
	      Ddi_Free(select);
	      break;
	    }
	    else if (Ddi_VararrayNum(select)>remove) {
	      int k;
	      Ddi_Varset_t *proj;
	      for (k=Ddi_VararrayNum(select)-1; k>=remove; k--) {
		Ddi_VararrayRemove(select,k);
	      }
	      proj = Ddi_VarsetMakeFromArray(select);
	      Ddi_BddCubeExistProjectAcc(currHint, proj);
	      Ddi_Free(proj);
	    }
	    Pdtutil_Assert(Ddi_VararrayNum(select)>0,"missing var");
	    cntVars += Ddi_VararrayNum(select);
	    //	while (Ddi_VararrayNum(select)>remove)
	    //  Ddi_VararrayRemove(select,Ddi_VararrayNum(select)-1);
	    Ddi_VararrayDiffAcc(itpMgr->hints.hintsVars,select);
	    Ddi_Free(select);
	    Ddi_AigConstrainCubeAcc(saveHint,currHint);
	    //	  Ddi_AigConstrainCubeAcc(f_1,currHint);
	    //	  Ddi_BddDiffAcc(f_1,currHint);
	    Ddi_DataCopy(currHint,saveHint);
	    if (checkOutOfConstr==3) {
	      Ddi_Bdd_t *extraConstr = Ddi_BddNot(currHint);
	      //	    Ddi_BddSubstVarsAcc(extraConstr,itpMgr->ps,itpMgr->ns);
	      Ddi_BddAndAcc(f_1,extraConstr);
	      Ddi_Free(extraConstr);
	    }
	    if (cntVars > remove) break;
	  } while (!Ddi_AigSatMinisatWithAbortAndFinal(f_1,currHint,-1.0,0));
	  Ddi_Free(f_1);
	  Ddi_Free(f_0);
	  ring = Ddi_BddarrayRead(fromRings, jj);
	  Ddi_Free(saveHint);
	  iRing = jj;
	  Ddi_Free(f_1Save);
	  break;
	}
	else {
	  int i;
	  Pdtutil_Assert(itpMgr->hints.hintsArray!=NULL,
			 "missing hints array");
	  for (i=Ddi_BddarrayNum(itpMgr->hints.hintsArray)-1; i>=0; i--) {
	    Ddi_Bdd_t *h_i = Ddi_BddarrayRead(itpMgr->hints.hintsArray,i);
	    Ddi_Bdd_t *notH = Ddi_BddNot(h_i);
	    if (Ddi_AigSatAnd(f_1,notH,NULL)) {
	      Ddi_BddarrayRemove(itpMgr->hints.hintsArray,i);
	      break;
	    }
	    Ddi_Free(notH);
	  }
          break;
	}
      }
      else {
	Ddi_Varset_t *nsv = Ddi_VarsetMakeFromArray(itpMgr->ns);
	Ddi_Varset_t *psv = Ddi_VarsetMakeFromArray(itpMgr->ps);
	Ddi_BddAndAcc(f_1,currHint);
	Ddi_Bdd_t *cex = Ddi_AigSatWithCex(f_1);
	Ddi_Bdd_t *cexState = Ddi_BddCubeExistProject(cex, nsv);
	Ddi_Bdd_t *cexState0 = Ddi_BddCubeExistProject(cex, psv);
	Ddi_BddSubstVarsAcc(cexState0,itpMgr->ps,itpMgr->ns);
	printf("already out of ring %d\n", jj);
	Ddi_Free(psv);
	Ddi_Free(nsv);
	Ddi_Free(cex);
	Ddi_Free(cexState);
	Ddi_Free(cexState0);
      }
      Ddi_Free(saveHint);
    }
    else if (0) {
      Ddi_Varset_t *sm = Ddi_VarsetMakeFromArray(itpMgr->ns);
      Ddi_Bdd_t *from0 = Ddi_BddAnd(f_0,currConstr);
      Ddi_Bdd_t *from1 = Ddi_BddAnd(f_0,currConstr);
      Ddi_Bdd_t *from2 = Ddi_BddDup(f_0);
      Ddi_BddAndAcc(from0,myTr);
      Ddi_BddAndAcc(from2,myTr);
      Ddi_BddAndAcc(from1,itpMgr->tr);
      Ddi_BddExistProjectAcc(from0,sm);
      Ddi_BddExistProjectAcc(from1,sm);
      Ddi_BddExistProjectAcc(from2,sm);
      Ddi_Free(from2);
      Ddi_Free(from1);
      Ddi_Free(from0);
      Ddi_Free(sm);
    }
    Ddi_Free(f_1);
    Ddi_Free(f_0);
  }
  Ddi_Free(myTr);
  Ddi_Free(currHint);
  Ddi_Free(currHintNs);
  Ddi_Free(reached);

  if (ring==NULL) {
    if (itpMgr->hints.hintsArray!=NULL) {
      int nh = Ddi_BddarrayNum(itpMgr->hints.hintsArray);
      if (nh>0)
        Ddi_BddarrayRemove(itpMgr->hints.hintsArray,nh-1);
    }
    else {
      int jj;
      for (jj=0; jj<remove&&Ddi_VararrayNum(itpMgr->hints.hintsVars)>0; jj++) {
        Ddi_VararrayRemove(itpMgr->hints.hintsVars,
			 Ddi_VararrayNum(itpMgr->hints.hintsVars)-1);
      }
    }
  }

  if (saveBwdRings) {
    Pdtutil_Assert(0,"useBwdRings now handled as user option");
    itpMgr->igr.useBwdRings = 10;
    int safe = -1;
    for (jj = Ddi_BddarrayNum(fromRings)-1; jj>=2; jj--) {
      Ddi_Bdd_t *f_jj = Ddi_BddarrayRead(fromRings, jj);
      Ddi_Bdd_t *b_safe = NULL;
      int safe_jj = Trav_ItpMgrReadConeBoundOK(itpMgr,jj);
      if (safe_jj<0) break; // stop here
      if (safe<0) safe = safe_jj;
      else safe++;
      Ddi_BddSetAig(f_jj);
      while (Ddi_BddarrayNum(bckReachedRings)<=safe) {
        Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
        Ddi_BddarrayInsertLast(bckReachedRings,myOne);
        Ddi_Free(myOne);
      }
      b_safe = Ddi_BddarrayRead(bckReachedRings,safe);
      Ddi_BddDiffAcc(b_safe,f_jj);
    }
    Trav_ItpMgrResetConeBoundOK(itpMgr);

  }

  if (itpMgr->hints.strategy>=2) {
    if (Ddi_BddarrayNum(fromRings)<=1) {
      Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_BddarrayWrite(fromRings, 1, myOne);
      Ddi_Free(myOne);
    }
    else {
      Ddi_Bdd_t *ring1 = Ddi_BddarrayRead(fromRings, 1);
      Ddi_BddSetAig(ring1);
      for (jj = Ddi_BddarrayNum(fromRings)-1; jj>=2; jj--) {
	Ddi_Bdd_t *f_jj = Ddi_BddarrayExtract(fromRings, jj);
	Ddi_BddSetAig(f_jj);
	Ddi_BddOrAcc(ring1,f_jj);
	Ddi_Free(f_jj);
      }
      iRing = 1;
    }
  }
  else { 
    for (jj = 1; jj < Ddi_BddarrayNum(fromRings); jj++) {
      Ddi_Bdd_t *f_jj = Ddi_BddarrayRead(fromRings, jj);
      Ddi_Bdd_t *move;
      Ddi_BddSetAig(f_jj);
      move = Ddi_BddCofactor(f_jj,cvarNs,1);
      Ddi_BddAndAcc(move, invar1);
      Ddi_BddCofactorAcc(move,cvar0Ns,0); // new states
      Ddi_BddOrAcc(f_jj,move); // add as old
      //    Ddi_BddAndAcc(f_jj,lit1);
      if (0 || jj>iRing) {
	Ddi_AigAndCubeAcc(f_jj,lit1); // new states
	Ddi_BddOrAcc(f_jj,lit0);
      }
      else {
	Ddi_AigConstrainCubeAcc(f_jj,lit1); // new states
      }
      Ddi_BddOrAcc(f_jj,invar0);
      Ddi_Free(move);
    }
  }
  itpMgr->hints.hintsFirst = 1;
    
  if (itpMgr->hints.strategy>3 && itpMgr->hints.strategy<=10) {
    Ddi_BddComposeAcc(currConstr,itpMgr->ps,itpMgr->delta);
  }
  Ddi_BddAndAcc(currConstr,lit1ps);
  Ddi_BddarrayWrite(itpMgr->delta,iConstr0,currConstr); 
  if (doAbstrRef) {
    Ddi_BddarrayWrite(itpMgr->deltaAbstr,iConstr0,currConstr); 
  }

  Ddi_Free(invar0);
  Ddi_Free(invar1);
  Ddi_Free(lit0);
  Ddi_Free(lit1);
  Ddi_Free(lit1ps);
  Ddi_Free(invar1ps);

  Ddi_Free(currConstr);

  Ddi_Free(target);
  Ddi_Free(invar);
  //  if (iRing>0) iRing = 1;
  return iRing;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
igrTravIntern(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * itpCone,
  Ddi_Bdd_t * itpCare,
  Ddi_Bdd_t * rOut,
  Ddi_Bdd_t * careOut,
  int bwdK,
  int recLevel,
  int *itpBmcBoundP,
  int *abortP,
  int *satP
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(itpCone);
  int k, maxRef = Trav_MgrReadIgrMaxIter(travMgr);
  int nExactTimeFrames = Trav_MgrReadIgrMaxExact(travMgr);
  int abstrRef = Trav_MgrReadAbstrRef(travMgr) % 100;
  int abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  int abstrRefItp = travMgr->settings.aig.abstrRefItp;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int useBoundkCone = Trav_MgrReadItpBoundkOpt(travMgr);
  int useReached = Trav_MgrReadItpUseReached(travMgr);

  float smoothRatio = 0.5;
  Ddi_Bdd_t *partCone = Ddi_BddMakePartDisjVoid(ddm);
  Ddi_Bdd_t *coneQueue = Ddi_BddMakePartDisjVoid(ddm);
  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t *myCare = itpCare ? Ddi_BddDup(itpCare) :
    Ddi_BddMakeConstAig(ddm, 1);
  int refinedCones = 0;
  int sameRingRefinement = 0;   // Trav_MgrReadIgrSide(travMgr);
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int useRings = travMgr->settings.aig.igrUseRings;
  int useBwdRings = travMgr->settings.aig.igrUseBwdRings;
  int projByGenClauses = 0, projByUnsat = 1;
  int unsoundProof = 0;
  int doAbstrRef = abstrRef == 1 || abstrRef == 2;
  int doPba = abstrRef == 1;
  int enIgr = Trav_MgrReadItpReuseRings(travMgr) == 2;
  int igrFwdBwd = travMgr->settings.aig.igrFwdBwd;
  int fixPoint, itpBmcBound;
  int useAigVars = itpMgr->useAigVars;
  Ddi_Vararray_t *pi = itpMgr->pi;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Bddarray_t *psLit = itpMgr->psLit;
  Ddi_Bddarray_t *nsLit = itpMgr->nsLit;
  Ddi_Varset_t *psVars = itpMgr->psvars;
  Ddi_Varset_t *nsVars = itpMgr->nsvars;
  Ddi_Varset_t *piVars = itpMgr->pivars;
  Ddi_Bdd_t *init = itpMgr->init;
  Ddi_Bddarray_t *initStub = itpMgr->initStub;
  int maxExact = Trav_MgrReadIgrMaxExact(travMgr), maxExactSave = maxExact;
  int doRingWeakening = travMgr->settings.aig.itpWeaken;
  int doRingStrengthening = travMgr->settings.aig.itpStrengthen;
  int enWeakenStrengthen = 0;
  int useEqRings = itpMgr->eqRings != NULL &&
    Ddi_BddarrayNum(itpMgr->eqRings) > 0;
  int chkAbstr = 0;
  int returnCex = 1;
  int currBwdCone = -1;
  int doTestCones = 0;
  int savedGrowCone = growCone; 
  int savedMaxExpandSame = Trav_MgrReadIgrSide(travMgr);
  int shiftToInit = 0;
  int igrBwdRefinement = travMgr->settings.aig.igrBwdRefine;
  int incrBoundMin = 1;
  int cexUsedForAbstr = 0;
  
  int minIgrBound = 0;
  if (bwdK<minIgrBound) {
    enIgr = 0;
  }
  
  if (growCone > 3) {
    Trav_MgrSetIgrGrowCone(travMgr,3);
    growCone = 3;
  }
  else if (growCone == 2) {
    // shiftToInit = 1;
  }
  
  Pdtutil_Assert(itpBmcBoundP != NULL, "missing pointer");

  itpBmcBound = *itpBmcBoundP;

  *abortP = 0;

  itpBmcBound *= -1;

  itpMgr->unsatGuaranteed = bwdK + itpBmcBound - 1;

  Fsm_MgrLogUnsatBound(fsmMgr, itpMgr->unsatGuaranteed, 0);

  itpMgr->igr.useRings = useRings;
  itpMgr->igr.useRingsStep = travMgr->settings.aig.igrUseRings;
  itpMgr->igr.useBwdRings = useBwdRings;
  itpMgr->lastRingId = -1;

  //  fixPoint = checkFixPoint(travMgr,fsmMgr,oldCone,newCone,care);
  fixPoint = 0;
  for (k = 0; k < itpBmcBound; k++) {
    Ddi_BddPartWrite(partCone, k, myZero);
  }

  if (doTestCones) {
    Ddi_Bdd_t *cone0 = Ddi_BddSubstVars(itpCone, itpMgr->ps, itpMgr->ns);
    testCones(itpMgr, cone0, 30);
    Ddi_Free(cone0);
  }

  if (igrFwdBwd > 0) {
    /* disable now !!! */
    igrFwdBwd = 0;
    maxRef = travMgr->settings.aig.igrMaxIter = 1000000;
    Ddi_BddarrayWrite(itpMgr->bckReachedRings,0,itpCone);
    currBwdCone = 0;
  }
  if (igrBwdRefinement > 0) {
    maxRef = travMgr->settings.aig.igrMaxIter = 1000000;
  }

  //        if (i>3)
  if (itpBmcBound <= 1 || itpMgr->nRings < 2) {
    if (doAbstrRef && !itpMgr->hints.hintsEnabled) {
      Ddi_Bdd_t *abstrCone = Ddi_BddSubstVars(itpCone,
        itpMgr->ps, itpMgr->ns);
      int start_j = itpBmcBound - 1;

      int cexHit = igrAbstrRef(itpMgr, abstrCone, start_j, useEqRings, NULL, 1, -1.0, NULL);

      if (!cexHit) {
        itpAbstrRefCurrAbstrDeltaSetup(itpMgr);
      }
      else if (itpBmcBound <= 1) {
	itpBmcBound = 2; // try IGR
      }

      if (!cexHit && (itpBmcBound == 1)) {
        /* repeat time main iteration with refined cone */
        itpBmcBound = 0;
        *abortP = 2;
      }
      Ddi_Free(abstrCone);
    }
  }

  int refinedInPrevIter = 0;

  while (!fixPoint && itpBmcBound > 1 && enIgr && itpMgr->nRings >= 2) {
    int j, d, cexHit = 1;
    Ddi_Bdd_t *myCone = NULL;
    Ddi_Bdd_t *myConeAbstr = NULL;
    Ddi_Bdd_t *myCone0 = NULL;
    int refineReduced = Trav_MgrReadItpReuseRings(travMgr) == 2;
    int timeShift = 1;
    int singleCex = 0;
    int coneAnd = 0;
    int nCompose = 1;
    int maxExpandSame = Trav_MgrReadIgrSide(travMgr);
    int tryExpandSame = maxExpandSame;
    int maxAndWithRing = 0,     // useRings*10,
      andWithRingPeriod = useRings > 1 ? 1 : 2, andWithRingCnt =
      andWithRingPeriod;
    int enableSubset = nExactTimeFrames > 0;
    int skip = 0;
    float satTimeLimit = (float)Ddi_MgrReadAigSatTimeLimit(ddm);
    int useEqRings = itpMgr->eqRings != NULL &&
      Ddi_BddarrayNum(itpMgr->eqRings) > 0;
    int prevRefined = 0;
    int refined = 0;
    int startBack = 1;
    int restartFrom0 = travMgr->settings.aig.igrRestart;

    if (*abortP == 1 || itpOutOfLimits(itpMgr)) {
      break;
    }
    if (refinedInPrevIter) {
      refinedInPrevIter = 0;
      restartFrom0 = -1;
    }
    
    if (igrFwdBwd > 0) {
      Pdtutil_Assert(currBwdCone>=0 && 
	currBwdCone<Ddi_BddarrayNum(itpMgr->bckReachedRings),
		     "bwd igr error");
      itpCone = Ddi_BddarrayRead(itpMgr->bckReachedRings,currBwdCone);
    }
    myCone = Ddi_BddDup(itpCone);

    if (itpMgr->stats.igrPiSubsetK>=0) {
      int kMax = Ddi_BddPartNum(partCone) - 1;

      //      itpBmcBound = itpBmcBound*0.95;
      int incr = 3*(itpBmcBound - itpMgr->stats.igrPiSubsetK)/4;
      //      itpBmcBound = itpMgr->stats.igrPiSubsetK+1;
      itpBmcBound = itpMgr->stats.igrPiSubsetK;
      Pdtutil_Assert(itpMgr->stats.igrPiSubsetRing >= 0,
		       "Missing Pi subset");
      itpMgr->igr.sameConeFail = itpMgr->stats.igrPiSubsetRing;

      itpBmcBound += incr;
      itpMgr->igr.sameConeFail += incr;
      satTimeLimit *= 50;

      tryExpandSame = maxExpandSame = 0;
      //      startBack = 0;
	    
      k = itpBmcBound - 1;
      //      Pdtutil_Assert(k<=kMax,"error in cone Pi Subset bound");
      Ddi_Bdd_t *p = Ddi_BddDup(Ddi_BddPartRead(partCone, kMax));
      Ddi_BddPartWrite(partCone, k, p);
      Ddi_Free(p);
      while (kMax > k) {
	Ddi_BddPartRemove(partCone, kMax);
	kMax--;
      }

    }

    if ((maxRef-- <= 0 && Ddi_BddPartNum(partCone) <= itpBmcBound)) {
      int nRef = Trav_MgrReadIgrMaxIter(travMgr);

      Ddi_Free(myCone);
      if (itpBmcBound > 2) {
        // itpBmcBound = 2;
      }
      //        Trav_MgrSetIgrMaxIter(travMgr,nRef*1.5);
      //      Trav_MgrSetOption(travMgr,Pdt_TravIgrMaxIter_c,inum,nRef*1.5) ;
      break;
    }

    Ddi_BddSetPartDisj(partCone);
    Ddi_BddSubstVarsAcc(myCone, ps, ns);

    for (k = 0 /*Ddi_BddPartNum(partCone)-1 */ ; k < itpBmcBound - 1;
      k++) {
      Ddi_BddPartWrite(partCone, k, myZero);
    }
    if (unsoundProof && (Ddi_BddPartNum(partCone) > itpBmcBound)) {
#if 1
      int jj;

      for (jj = 1; jj < Ddi_BddarrayNum(itpMgr->fromRings); jj++) {
        Ddi_Bdd_t *ring = Ddi_BddarrayRead(itpMgr->fromRings, jj);

        if (Ddi_AigSatAnd(ring, myCone, 0)) {
          itpBmcBound = jj;
          break;
        }
      }
#endif
#if 1
      int kMax = Ddi_BddPartNum(partCone) - 1;

      k = itpBmcBound - 1;
      Ddi_BddPartWrite(partCone, k, Ddi_BddPartRead(partCone, kMax));
      while (kMax > k) {
        Ddi_BddPartRemove(partCone, kMax);
        kMax--;
      }
#else
      itpBmcBound = Ddi_BddPartNum(partCone);
#endif
      tryExpandSame = 0;        //maxExpandSame = 0;
    }

    if (growCone < 1) {
      myCone0 = Ddi_BddDup(myCone);
    }

    if ((Ddi_BddPartNum(partCone) < itpBmcBound) ||
      (!refinedCones && (Ddi_BddPartNum(partCone) == itpBmcBound))) {
      Ddi_Bdd_t *myItpCone = Ddi_BddDup(itpCone);
      int mark = Ddi_BddReadMark(itpCone);

      Pdtutil_Assert(Ddi_BddPartNum(partCone) >= itpBmcBound - 1,
        "wrong partCone num");
      itpAbstrRefApplyCurrAbstr(itpMgr, myItpCone);
      Ddi_BddPartWrite(partCone, itpBmcBound - 1, myItpCone);
      Ddi_Free(myItpCone);
      Pdtutil_Assert(currBwdCone<0 || (mark == bwdK+currBwdCone), 
		     "wrong or missing time mark");
    } else if (1) {
      Pdtutil_Assert(0, "problem with partcone size");
    } else {
      int start = Ddi_BddPartNum(partCone) - 1;

      itpAbstrRefApplyCurrAbstr(itpMgr, myCone);
      growConeBwdForRingCheck(itpMgr, myCone, start, itpBmcBound,
		  NULL, initStub, useEqRings ? 2 : 0, -1, 0 /*boundK */ );
    }

    refinedCones = 0;
    if (doAbstrRef) {
      myConeAbstr = Ddi_BddSubstVars(itpCone, itpMgr->ps, itpMgr->ns);
    }
    if (growCone > 0) {
      myCone0 = Ddi_BddDup(myCone);
    }

    if ((doRingWeakening||doRingStrengthening) && enWeakenStrengthen) {
      if (itpMgr->fromRings != NULL) {
        //int start_i = Ddi_BddarrayNum(itpMgr->fromRings) - 2;
        int start_i = enWeakenStrengthen;
        int end_i = 1;
        static int doBwdStrengthening = igrBwdRefinement;
	static int chkRings = 0;
        if (chkRings) {
  	  int myChkRings = itpCheckRingsFwd(itpMgr,end_i,start_i,0);
	  printf("RING CHECK: %d\n", myChkRings);
	  Pdtutil_Assert(myChkRings,"problem with from rings");
        }  
        if (start_i > end_i+2) {
	  Ddi_Bddarray_t *myDelta = (itpMgr->deltaAbstr)?
	    itpMgr->delta0:itpMgr->delta;
          if (doRingWeakening) 
            itpWeakenRingsBwd(itpMgr, start_i, end_i, myDelta, -1, 1, 0);
          if (doBwdStrengthening) {
	    int start_bwd = start_i;
	    if (0 && itpMgr->igr.sameConeFail >= 0 &&
		itpMgr->igr.sameConeFail < start_bwd/2)
	      start_bwd = itpMgr->igr.sameConeFail;
	    if (start_bwd > igrBwdRefinement) {
	      int step = (start_bwd+1)/4;
	      int maxK = (start_bwd+1)/2;
	      if (step==1) step++;
	      itpStrengthenRingsBwdByBmc(itpMgr,0,start_bwd+1,step,
					 myDelta,maxK,0,0,0);
	      //itpStrengthenRingsByBmc(itpMgr,0/* use target */,0,start_bwd+1,0,0);
	    }
	  }
          if (doRingStrengthening) {
	    Ddi_Bddarray_t *myDelta = (itpMgr->deltaAbstr)?
	      itpMgr->delta0:itpMgr->delta;
            itpStrengthenRingsFwd(itpMgr, end_i, start_i, myDelta, -1, 1, NULL, 0, 0);
          }
          if (0 && (travMgr->settings.aig.igrItpSeq!=0)) {
            itpWeakenRingsBwd(itpMgr, start_i, end_i, itpMgr->delta, -1, 1, 0);
            itpStrengthenRingsFwd(itpMgr, end_i, start_i, itpMgr->delta, -1, 1, NULL, 0, 0);
          }
        }
        if (chkRings) {
  	  int myChkRings = itpCheckRingsFwd(itpMgr,end_i,start_i,0);
	  printf("RING CHECK AFTER WEAKENING: %d\n", myChkRings);
	  Pdtutil_Assert(myChkRings,"problem with from rings");
        }  

      }
    }
    int nrings = Ddi_BddarrayNum(itpMgr->fromRings);
    if (travMgr->settings.aig.itpStoreRings != NULL && nrings > 2) {
      Ddi_Bddarray_t *benchArray;
      char filename[100];
      benchArray = Ddi_BddarrayDup(itpMgr->fromRings);
      if (Ddi_BddarrayRead(benchArray,0)==NULL) {
        Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
        Ddi_BddarrayWrite(benchArray,0,myZero);
        Ddi_Free(myZero);
      }
      while (Ddi_BddIsOne(Ddi_BddarrayRead(benchArray,Ddi_BddarrayNum(benchArray)-1)))
        Ddi_BddarrayRemove(benchArray,Ddi_BddarrayNum(benchArray)-1);
      nrings = Ddi_BddarrayNum(benchArray);
      if (nrings>2) {
        int safe = Trav_ItpMgrReadConeBoundOK(itpMgr,nrings-1);
        strcpy(filename, travMgr->settings.aig.itpStoreRings);
        char *s = strstr(filename,".aig");
        if (s==NULL) s = filename+strlen(filename);
        sprintf(s, "_%d_%d.aig", nrings, safe);
        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("Writing itp rings to %s\n", filename);
        }
        Ddi_AigarrayNetStoreAiger(benchArray, 0, filename);
      }
      Ddi_Free(benchArray);
    }
    
    if (travMgr->settings.aig.itpTrAbstr>0 && itpMgr->fromRings != NULL) {
      itpTrAbstrWithItpRefineWithRings(itpMgr,-1,-1);
    }
    enWeakenStrengthen = 0;

    skip = 0;

    if (itpBmcBound > Ddi_BddarrayNum(itpMgr->fromRings)) {
      skip = itpBmcBound - Ddi_BddarrayNum(itpMgr->fromRings);
    }
    if (itpMgr->igr.sameConeFail >= 0 && 
	itpBmcBound > itpMgr->igr.sameConeFail) {
      skip = itpBmcBound - itpMgr->igr.sameConeFail;
    }
    if (travMgr->settings.ints.igrRingFirst>=0) {
      if (growCone<3) {
        int skip1 = 3*(itpBmcBound - travMgr->settings.ints.igrRingFirst)/4;
        if (skip1>skip) {
          if (growCone<2 || skip1-skip < 4)
            skip=skip1;
        }
      }
    }
      
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf
        ("\ntry ITP ref. # %d/%d - cone/constr %d of size: %d - ring: %d (rl: %d)\n",
        Trav_MgrReadIgrMaxIter(travMgr) - maxRef,
        Trav_MgrReadIgrMaxIter(travMgr), bwdK, Ddi_BddSize(myCone),
        itpBmcBound - 1, recLevel);
    }

    if (travMgr->settings.aig.igrRewindMinK>=0 && 
        itpBmcBound>=travMgr->settings.aig.igrRewindMinK) {
      travMgr->settings.aig.igrRewind = 1;
      travMgr->settings.aig.igrGrowConeMax = -1.0;
    }
    if (travMgr->settings.aig.igrGrowConeMaxK>=0 && 
        itpBmcBound>travMgr->settings.aig.igrGrowConeMaxK) {
      travMgr->settings.aig.igrGrowCone = 0;
      travMgr->settings.aig.igrSide = 0;
      travMgr->settings.aig.igrGrowConeMax = -1.0;
      travMgr->settings.aig.igrFwdBwd = 0;
    }

    enableSubset = nExactTimeFrames > 0;
    int maxIncrBound = -1;
    float maxIncrBoundRate = travMgr->settings.aig.igrGrowConeMax;
    int doRewind = 0;
    int first_j = itpBmcBound - 1 - skip;
    if (maxIncrBoundRate>0) {
      maxIncrBound = (1+skip) * maxIncrBoundRate;
      if (maxIncrBound<incrBoundMin) {
        maxIncrBound=incrBoundMin;
      }
    }
    
    while (Ddi_BddarrayNum(itpMgr->fromRings) <= first_j) {
      Ddi_BddarrayInsertLast(itpMgr->fromRings, myOne);
    }
    for (j = first_j, d = skip; j >= 0 && cexHit;
      d++, j--) {
      Ddi_Bdd_t *currRing = Ddi_BddarrayRead(itpMgr->fromRings, j);
      int sizeCone, sizeRing;
      int ii;
      //        int andWithRing = 1||Trav_MgrReadIgrSide(travMgr)<=0;
      int andWithRing = maxAndWithRing > 0;
      int useRingConstr = 0;
      int start_j = j + d;
      int abort = 0;
      Ddi_Bdd_t *abstrCex = NULL;
      
#if 1
      /* now just restart from 0 */
      if (maxIncrBound>=0 &&
          (itpBmcBound-1-skip-j >= maxIncrBound)) {
        while (j > 0 && itpBmcBound>2) {
          j--; d++;
          itpBmcBound--;
          Ddi_BddPartRemove(partCone, 0);
        }
	//        incrBoundMin++;
        currRing = Ddi_BddarrayRead(itpMgr->fromRings, j);
        Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
          printf("MAX cone bound incr reached: %d - new bmc bound %d\n",
                 maxIncrBound, itpBmcBound);
          fflush(stdout);
        }
        tryExpandSame = 0;
      }
#else 
      if (!doRewind && maxIncrBound>0 &&
          (itpBmcBound-1-skip-j > maxIncrBound)) {
        doRewind = 1;        
      }
#endif
      if (doRewind) {
        itpBmcBound--; d--;
        start_j--;
        Ddi_BddPartRemove(partCone, 0);
      }
      //      Pdtutil_Assert(d==(Ddi_BddReadMark(myCone)-
      //             Ddi_BddReadMark(myCone0)+skip),
      //               "wrong start of cone grow ring");

      refined = 0;

      if (itpMgr->igr.sameConeFail >= 0 && j > itpMgr->igr.sameConeFail) {
        continue;
      }
      if (Ddi_BddIsOne(currRing) && j>0) {
        continue;
      }
      
      sizeRing = currRing == 0 ? 0 : Ddi_BddSize(currRing);

      Pdtutil_Assert(start_j >= itpBmcBound - 1, "wrong start_j");
      //      Pdtutil_Assert(start_j<Ddi_BddPartNum(partCone),"wrong start_j");
      
      if (*abortP == 1 || itpOutOfLimits(itpMgr)) {
        abort = 1;
        *abortP = 1;
        break;
      }

      if (useEqRings) {
        useRingConstr += 2;
      }

      Ddi_Free(myCone);
      myCone = Ddi_BddDup(myCone0);

      if (doAbstrRef) {
        itpAbstrRefApplyCurrAbstr(itpMgr, myCone);
      }

      int boundk = 0;
      if (/*growCone==2 ||*/ itpMgr->hints.hintsEnabled ||
          (doAbstrRef&& (j>0||growCone>=3)) ||
          //          travMgr->settings.aig.igrFwdBwd>0 ||
          itpMgr->stats.igrPiSubsetK>=0 ||
          igrBwdRefinement>0 || growCone<3 ||
          (skip>0 && growCone>=3)) {
	boundk = 1;
      }
      if (j==0 && growCone<3) boundk = 0;
      if (growCone<3) boundk = 0; // Need to check for soundness

      
      int customZipCpu = 0;
      if (customZipCpu) {
        Ddi_Varsetarray_t *coi = Ddi_VarsetarrayAlloc(ddm,13);
        int ii;
        for (ii=7; ii<13; ii++) {
          Ddi_Bdd_t *cone_i = Ddi_BddDup(myCone);
          growConeBwd(itpMgr, cone_i, 2+ii, 2, NULL,
                      initStub, useRingConstr, 0,
                      boundk /*boundK */ ) ;
          Ddi_Varset_t *supp_i = Ddi_BddSupp(cone_i);
          Ddi_VarsetIntersectAcc(supp_i,nsVars);
          Ddi_VarsetarrayWrite(coi,ii,supp_i);
          Ddi_Free(supp_i);
          Ddi_Free(cone_i);
        }
        for (ii=8;ii<13;ii++) {
          int jj = ii-1;
          Ddi_Varset_t *v_ii = Ddi_VarsetarrayRead(coi,ii);
          Ddi_Varset_t *v_jj = Ddi_VarsetarrayRead(coi,jj);
          Ddi_Varset_t *new_ii = Ddi_VarsetDiff(v_ii,v_jj);
          Ddi_Varset_t *lost_ii = Ddi_VarsetDiff(v_jj,v_ii);
          printf("coi[%d] %d -> coi[%d] %d ( = %d - new: %d - lost: %d\n", ii-1, ii,
                 Ddi_VarsetNum(v_jj),
                 Ddi_VarsetNum(v_ii),
                 Ddi_VarsetNum(new_ii),
                 Ddi_VarsetNum(lost_ii));

          Ddi_Free(new_ii);
          Ddi_Free(lost_ii);
        }

        Ddi_Free(coi);
      }


      int andRing = -1;
      int saveUseRings = itpMgr->igr.useRings;
      if (1 && j<first_j) {
        //        andRing = (j+itpBmcBound-1)/2;
        andRing = (2*j+itpBmcBound-1)/3;
        itpMgr->igr.useRings = 1;
      }
      growConeBwd(itpMgr, myCone, start_j, j, NULL,
		  initStub, useRingConstr, andRing,
                  boundk /*boundK */ );
      itpMgr->igr.useRings = saveUseRings;
      Ddi_BddSetAig(myCone);
      if (boundk) {
        Ddi_Var_t *pvarNs = Ddi_VarFromName(ddm,
                     "PDT_BDD_INVARSPEC_VAR$NS");
        Ddi_Bdd_t *pLit = Ddi_BddMakeLiteralAig(pvarNs, 1);
        Ddi_AigAndCubeAcc(myCone,pLit);
        Ddi_Free(pLit);
      }
      if (chkAbstr && doAbstrRef && itpMgr->abstrCurrAbstr != NULL) {
        Ddi_Bdd_t *auxCone = Ddi_BddDup(myCone0);

        growConeBwd(itpMgr, auxCone, start_j, j, NULL,
		    initStub, useRingConstr, -1, boundk /*boundK */ );
        itpAbstrRefApplyCurrAbstr(itpMgr, auxCone);
        Pdtutil_Assert(Ddi_BddEqualSat(auxCone, myCone), "wrong abstr/ref");
        Ddi_Free(auxCone);
      }

      sizeCone = Ddi_BddSize(myCone);

      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("ITP ref. chk[%d] - cone sz: %d - fwd ring: %d",
          j, sizeCone, sizeRing);
        fflush(stdout);
      }

      if (sizeCone == 0 && j > 0) {
        if (tryExpandSame > 0)
          tryExpandSame = 1;
      }
      if (sizeRing > 10000 && sizeRing > sizeCone * 0.1) {
        andWithRing = 0;
      }
      if (andWithRing) {
        andWithRingCnt = andWithRingCnt % andWithRingPeriod;
        if (andWithRingCnt != 0) {
          andWithRing = 0;
        } else {
          maxAndWithRing--;
        }
        andWithRingCnt++;
      }

      if (itpMgr->stats.igrRewindRing > 0 &&
                 j <= itpMgr->stats.igrRewindRing) {
        cexHit = 0;
      } else if (itpMgr->igr.sameConeFail >= 0 && j > itpMgr->igr.sameConeFail) {
        cexHit = 1;
      } else {
	Ddi_Bdd_t *myRing = Ddi_BddDup(currRing);
        itpMgr->igr.sameConeFail = -1;
	if (j>0 && itpMgr->eqRings != NULL
	    && Ddi_BddarrayNum(itpMgr->eqRings) > j) {
	  Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, j);
	  if (eqConstr != NULL) {
	    Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
	    Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);
	    Ddi_BddComposeAcc(myCone, vars, subst);
	    Ddi_BddComposeAcc(myRing, vars, subst);
	  }
	}
	if (0 && j>0 && itpMgr->hints.hintsFirst) {
	  int iConstr0 = itpMgr->hints.invar0_i;
	  Ddi_Var_t *cvar0Ns = Ddi_VararrayRead(itpMgr->ns,iConstr0); 
	  Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(cvar0Ns, 1);
	  Ddi_BddAndAcc(myRing,lit);
	  Ddi_Free(lit);
	}
        if (j == 0) {
	  int useTimeLimit = !doAbstrRef && travMgr->settings.doCex<0;
          Ddi_Bdd_t *ring = myRing!=NULL ? myRing : myOne;
	  if (itpMgr->initStub!=NULL) ring = myOne;
          Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(myCone,
		ring, NULL, NULL, useTimeLimit?satTimeLimit:-1, &abort);
          cexHit =  (cex != NULL);
          if (doAbstrRef) {
            Ddi_Free(abstrCex);
            abstrCex = Ddi_BddDup(cex);
          }
          Ddi_Free(cex);
          if (abort) {
            tryExpandSame = maxExpandSame = 0;
          }
        } else {
          Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(myCone,
            myRing, NULL, NULL, satTimeLimit, &abort);

          cexHit = abort || (cex != NULL);
	  if (cex!=NULL) {
	    if (j > 2 && ((j + nExactTimeFrames) < itpBmcBound)
		&& enableSubset) {
	      itpMgrGenSplitCex(itpMgr,cex,start_j,j);
	      enableSubset = 0;
	    }
	  }
	  if (0 && cex==NULL && d>0) {
	    int res = itpCheckConeAtRing(itpMgr,currRing,NULL,j,d,boundk);
	    Pdtutil_Assert(!res,"unsound cone");
	  }
          Ddi_Free(cex);
          if (abort) {
            tryExpandSame = maxExpandSame = 0;
            satTimeLimit *= 2.0;
          }
        }
	Ddi_Free(myRing);
      }

      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("%s\n", abort ? " (A)" : "");
      }


      if (cexHit && j == 0 && (currBwdCone>=0)) {
        int start_j = d;
	int prevBwdCone = currBwdCone;

	while (cexHit && (currBwdCone>0)) {
#if IGR_BWD_FORCE_EXPAND_BWD
          int res;
	  int newBwdCone = igrBwdRef(itpMgr, NULL, currBwdCone, 0, start_j, 
			       useEqRings, 0, &res);
	  cexHit = !res;
          if (!cexHit) {
            Pdtutil_Assert(newBwdCone>=currBwdCone,"problem with bwd cones");
            itpCone = Ddi_BddarrayRead(itpMgr->bckReachedRings,currBwdCone);
            currBwdCone = newBwdCone;
            Ddi_Free(myCone);
            Ddi_Free(myCone0);
            myCone = Ddi_BddDup(itpCone);
            myCone0 = Ddi_BddDup(itpCone);
            Ddi_BddSubstVarsAcc(myCone, itpMgr->ps, itpMgr->ns);
            Ddi_BddSubstVarsAcc(myCone0, itpMgr->ps, itpMgr->ns);
          }
#else
	  currBwdCone--;
	  itpCone = Ddi_BddarrayRead(itpMgr->bckReachedRings,currBwdCone);
	  Ddi_Free(myCone);
	  Ddi_Free(myCone0);
	  myCone = Ddi_BddDup(itpCone);
	  myCone0 = Ddi_BddDup(itpCone);
	  Ddi_BddSubstVarsAcc(myCone, itpMgr->ps, itpMgr->ns);
	  Ddi_BddSubstVarsAcc(myCone0, itpMgr->ps, itpMgr->ns);

	  growConeBwd(itpMgr, myCone, start_j, j, NULL,
		  initStub, useRingConstr, -1, boundk /*boundK */ );
	  cexHit = Ddi_AigSat(myCone);
#endif
	}
        if (!cexHit) {
          refined = 1;
	  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
	    printf("BWD ring refined: %d -> %d\n", 
		   prevBwdCone, currBwdCone);
	  }
        }
      }

      if (cexHit && j == 0 && doAbstrRef) {
        int start_j = d;

        Pdtutil_Assert(d == Ddi_BddReadMark(myCone) -
          Ddi_BddReadMark(myCone0) - 1, "wrong cone start in abstr ref");

        if (chkAbstr && (itpMgr->abstrCurrAbstr != NULL)) {
          Ddi_Bdd_t *auxCone = Ddi_BddDup(myCone);

          growConeBwd(itpMgr, auxCone, start_j, 0,
		      NULL, itpMgr->initStub, useEqRings ? 2 : 0, -1, boundk /*boundK */ );
          Ddi_BddComposeAcc(auxCone, itpMgr->abstrRefCtrl,
            itpMgr->abstrCurrAbstr);
          Pdtutil_Assert(Ddi_AigSat(auxCone), "missing abstr cex");
          Ddi_Free(auxCone);
        }
        Ddi_BddSetAig(myConeAbstr);
        float refinedRatio = ((float)itpMgr->abstrRefNumRefinedLatches)/
          Ddi_VararrayNum(itpMgr->ps);
        int enItpAbstr = abstrRefItp>0 && itpMgr->abstrRefNumRefinedLatches>0 &&
          itpMgr->abstrCurrAbstr!=NULL &&
          (float)abstrRefItp/100 < refinedRatio;

        if (enItpAbstr) {
          Ddi_Bdd_t *myConeAbstrForItp = Ddi_BddDup(myConeAbstr);
          cexHit = igrAbstrRefByItp(itpMgr, myConeAbstrForItp, start_j,
                             useEqRings, abstrCex, 1,
                             cexUsedForAbstr?-1:satTimeLimit, &cexUsedForAbstr);
          Ddi_Free(myConeAbstrForItp);
          itpAbstrRefCurrAbstrDeltaSetup(itpMgr);
        }
        if (cexHit)
          cexHit = igrAbstrRef(itpMgr, myConeAbstr, start_j, useEqRings, abstrCex, 1,
                             cexUsedForAbstr?-1:satTimeLimit, &cexUsedForAbstr);
        Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelDevMed_c) {
          fprintf(dMgrO(ddm), "\nREFINED VARS:\n");
          Ddi_Varset_t *vars =
            Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 0);
          Ddi_VarsetPrint(vars,0,0,tMgrO(travMgr));
        }
        if (travMgr->settings.aig.storeAbstrRefRefinedVars != NULL) {
          Ddi_Varset_t *vars =
            Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 0);
          Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(vars, 0);
          Ddi_VararrayStore (vA, travMgr->settings.aig.storeAbstrRefRefinedVars, NULL);
          Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
            fprintf(dMgrO(ddm),
                    "Abstr Ref: stored %d refined vars to file %s\n",
                    Ddi_VarsetNum(vars), travMgr->settings.aig.storeAbstrRefRefinedVars);
          }
          Ddi_Free(vA);
        }
        if (!cexHit) {
          itpAbstrRefCurrAbstrDeltaSetup(itpMgr);
          refined = 1;
          if (savedGrowCone>3) {
            if (growCone==3) {
              Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
                fprintf(tMgrO(travMgr),
                 "IGR switching to full REWIND (after refinement)\n");
              }
              Trav_MgrSetIgrGrowCone(travMgr,0);
              growCone = 0;
              //              Trav_MgrSetIgrSide(travMgr,0);
            }
          }
        }
      }
      Ddi_Free(abstrCex);

      if (refined) {
        // restart with refined cone
        maxRef++;
        refinedInPrevIter = 1;
        Pdtutil_Assert(itpMgr->igr.sameConeFail < 0, "wrong sameconefail");
        Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
          printf("\n\nrestarting with refined cone\n");
        }
        if (itpBmcBound>10 && !cexUsedForAbstr) {
          if (travMgr->settings.ints.igrSingleRewind <= 0) {
            itpBmcBound -= 2;
          }
          while (Ddi_BddPartNum(partCone)>itpBmcBound) {
            int remIndex = Ddi_BddPartNum(partCone)-2;
            Ddi_BddPartRemove(partCone,remIndex);
          }
        }
        if (growCone>0 && !cexUsedForAbstr) {
          itpMgr->igr.sameConeFail =
            (itpBmcBound - 1 - skip) / 2 + skip/3;
          if (itpMgr->igr.sameConeFail < 2) {
            itpMgr->igr.sameConeFail = 2;
          }
        }
	itpMgr->stats.igrPiSubsetK = -1;
        if (cexUsedForAbstr) {
          itpMgr->igr.sameConeFail = 1;
        }
      } else if (!cexHit && /* j>0 && */ tryExpandSame > 0) {
        Ddi_Bdd_t *prevCone, *currCone;
        int np;
        int mark = Ddi_BddReadMark(myCone);

        Pdtutil_Assert(Ddi_BddPartNum(partCone) > j, "missing cones");

        if (1 || j>0 || Ddi_BddSize(myCone)>0)
          tryExpandSame--;

        Ddi_Free(myCone);
        myCone = Ddi_BddDup(myCone0);
        Ddi_BddPartInsert(partCone, j > 0 ? j - 1 : 0, myZero);
        np = Ddi_BddPartNum(partCone);
        /* rebuild cone constrained on outer(+1) rings */

        growConeBwd(itpMgr, myCone, j + d + 1, j + 1, NULL,
		    initStub, useRingConstr, -1, boundk /*boundK */ );
        j++;                    /* repeat for this ring */
        cexHit = 1;             /* assume side cex */
        itpBmcBound++;
      } else if (!cexHit) {
        int curr = j;
        int iter, maxItpIter = 0, firstItpIter = j;
        int myItpBmcBound = 0;
        int savedIter = j;
        int doRefine = 1, oldNrings = Ddi_BddarrayNum(itpMgr->fromRings);
        Ddi_Bdd_t *myConePlus = NULL;
        int cCompl = Trav_MgrReadItpCheckCompleteness(travMgr);

        cexUsedForAbstr = 0;

        if (0 && j > 0 && travMgr->settings.aig.igrGrowCone>0 && 
	    itpMgr->hints.hintsNum<=0) {
	  if ((j > 1) && startBack>0) {
	    j--; curr--;
	    firstItpIter--;
	  }
          Ddi_BddPartWrite(partCone, j - 1, myZero);
        }

        //int restartFrom0 = 0;
        if ((restartFrom0 < 0 // always enabled
             || j<restartFrom0) // just up to a given bound
            && travMgr->settings.aig.igrGrowCone>0 
	    && itpMgr->hints.hintsNum<=0) {
          while (j > 0) {
            j--; curr--;
            itpBmcBound--;
            Ddi_BddPartRemove(partCone, 0);
            firstItpIter--;
            // Keep same bound
            // if (j>0)
            //  Ddi_BddPartWrite(partCone, j - 1, myZero);
          }
        }

        if (shiftToInit) {
          int i;
          j=0;
          while (Ddi_BddPartNum(partCone)>15) {
            Ddi_BddPartRemove(partCone, 0);
          }
          firstItpIter = 0;
          for (i=Ddi_BddarrayNum(itpMgr->fromRings)-1; i>0; i--) {
            Ddi_BddarrayRemove(itpMgr->fromRings,i);
          }
          for (i=Ddi_BddarrayNum(itpMgr->eqRings)-1; i>0; i--) {
            Ddi_BddarrayRemove(itpMgr->eqRings,i);
          }
          for (i=Ddi_BddarrayNum(itpMgr->reachedRings)-1; i>0; i--) {
            Ddi_BddarrayRemove(itpMgr->reachedRings,i);
          }
        }
        
        Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
          printf("refinement possible at level %d\n\n", j);
        }

        if (j > 1 && doAbstrRef && prevRefined) {
          int jj;

          for (jj = j - 1; jj > 0; jj--) {
            Ddi_Bdd_t *inRing = Ddi_BddarrayRead(itpMgr->fromRings, jj);

            Pdtutil_Assert(!Ddi_AigSatAnd(myCone, inRing, NULL),
              "inner ring hit");
          }
        }

#if 0
	int refineBwd = 4;
	if ((refineBwd>0) && (start_j-j > refineBwd)) {
	  if (Ddi_BddarrayNum(itpMgr->fromRings)>=start_j) {
	    int jj;
	    Ddi_Bdd_t *myRing = Ddi_BddDup(currRing);
	    itpMgr->igr.sameConeFail = -1;
	    if (j>0 && itpMgr->eqRings != NULL
		&& Ddi_BddarrayNum(itpMgr->eqRings) > j) {
	      Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, j);
	      if (eqConstr != NULL) {
		Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
		Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);
		Ddi_BddComposeAcc(myCone, vars, subst);
		Ddi_BddComposeAcc(myRing, vars, subst);
	      }
	    }
	    for (jj=j+2; jj<start_j-1; jj++) {
	      Ddi_Bdd_t *ring_jj = Ddi_BddarrayRead(itpMgr->fromRings, jj);
	      Ddi_Bdd_t *coneBwd = Ddi_BddNot(ring_jj);
	      Ddi_BddWriteMark(coneBwd,start_j-jj);
	      growConeBwd(itpMgr, coneBwd, jj-1, j + 1, NULL,
		    initStub, useRingConstr, -1, 0 /*boundK */ );
	      int bwdCexHit = Ddi_AigSatAnd(coneBwd, myRing, NULL);
	      Ddi_Free(coneBwd);
	    }
	    Ddi_Free(myRing);
	  }
	}
#else
	if ((igrFwdBwd>0 && start_j>0 && j>=0) ||
	    (cexHit && j == 0 && (igrFwdBwd>0) && (currBwdCone>=0))) {
	  int newBwdCone, res=1;
	  Ddi_Bdd_t *newCone=NULL;

	  Pdtutil_Assert(d == Ddi_BddReadMark(myCone) -
	     Ddi_BddReadMark(myCone0) - 1, "wrong cone start in bwd ref");

	  newBwdCone = igrBwdRef(itpMgr, myCone0, currBwdCone, j, start_j, 
			       useEqRings, 1 /* doTrav */, &res);
          if (newBwdCone > 0) newBwdCone--;
          
	  if (res>0) {
	    cexHit = 1;
	    refined = 0;
	  }
	  else if (res==0) {
	    /* proved by bwd trav */
	  }
	  else {
	    /* refined: found safe bwd ring */
	    Pdtutil_Assert(Ddi_BddPartNum(partCone)>start_j,
			   "problem with partcone");
	    cexHit = 0;
	    //          refined = 1;
	  }
	  if (1 && (newBwdCone != currBwdCone)) {
	    Ddi_Bdd_t *cone0 = Ddi_BddDup(
	      Ddi_BddarrayRead(itpMgr->bckReachedRings,0));
	    Ddi_Bdd_t *newCone = Ddi_BddDup(
	      Ddi_BddarrayRead(itpMgr->bckReachedRings,newBwdCone));
	    Ddi_BddSubstVarsAcc(cone0, itpMgr->ps, itpMgr->ns);
	    Ddi_BddSubstVarsAcc(newCone, itpMgr->ps, itpMgr->ns);

	    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
	    printf("\nPREIMG [l: %d] with new cone: %d\n\n",
		   newBwdCone, Ddi_BddSize(newCone));
	    }
	    printf("start_j: %d - AI: %d, pc: %d, BC: %d\n", start_j,
		 itpBmcBound, Ddi_BddPartNum(partCone),
		 newBwdCone); 
	    if (0 && (newBwdCone<currBwdCone)) {
	      int jj, extraRings = currBwdCone-newBwdCone;
	      for (jj=0; jj<extraRings; jj++) {
		Ddi_BddPartWrite(partCone, start_j+jj, myZero);
	      }
	      start_j += extraRings;
	      itpBmcBound += extraRings;
	    }
	    Ddi_BddOrAcc(newCone,cone0);
	    Ddi_Free(cone0);
	    Ddi_BddPartWrite(partCone,start_j,newCone);
	    Ddi_DataCopy(myCone0,newCone);
	    currBwdCone = newBwdCone;
	  }
	  Ddi_Free(newCone);

	  int chkCone = 0;
	  if (chkCone) {
	    Ddi_Bdd_t *myRing = Ddi_BddDup(currRing);
	    Ddi_Bdd_t *coneChk = Ddi_BddDup(myCone0); 
	    if (myRing == NULL) {
	      myRing = Ddi_BddMakeConstAig(ddm, 1);
	    }
	    itpMgrApplyRingEq(itpMgr,myRing,NULL,NULL,j,0);
	    growConeBwd(itpMgr, coneChk, start_j, j, NULL,
		  initStub, useRingConstr, -1, 0 /*boundK */ );
	    int hit = Ddi_AigSatAnd(myRing,coneChk,NULL);
	    Pdtutil_Assert(!hit,"problem with bwd refinement");
	    Ddi_Free(myRing);
	    Ddi_Free(coneChk);
	  }

	}


#endif


        if (0 && igrBwdRefinement>0) {
          int res;
          int k = start_j-j;
          int doWeakening = 0 && doRingWeakening;
	  int subsetBound = 2;
          if (k>igrBwdRefinement+subsetBound) {
            //            int currBwdCone = skip+1;
            int currBwdCone = 0; // skip;
#if 0
            int nSteps = igrRefineRingsBwd(
              itpMgr, myCone0, currBwdCone, j, start_j, 
              useEqRings, 1 /* doTrav */, &res);
            Pdtutil_Assert(nSteps == start_j-j,
                         "problem with BWD ref");
#endif
            if ((start_j-1)>0) {
              if (doWeakening) {
                itpWeakenRingsBwd(itpMgr, start_j-skip, 1, itpMgr->delta, -1, 1, 0);
                if (1) {
                  int myChkRings = itpCheckRingsFwd(itpMgr,-1,-1,1);
                  printf("RING CHECK: %d\n", myChkRings);
                  Pdtutil_Assert(myChkRings,"problem with from rings");
                }
              }
	      //	      int strengthenBound = start_j-skip;
	      int strengthenBound = start_j-j;
	      if (0 && strengthenBound>(start_j-j))
		strengthenBound = start_j-j;
	      int steps;
	      subsetBound = strengthenBound/4;
	      if (subsetBound<2) subsetBound = 2;
	      steps = itpStrengthenRingsByBmc(itpMgr,1,j,
			strengthenBound,subsetBound,4);
	      if (steps < (strengthenBound-subsetBound)) {
		firstItpIter += (strengthenBound-subsetBound-steps);
	      }
	      //  itpStrengthenRingsByBmc(itpMgr,1,(start_j-skip)/2);
	      
	      
	      if (1) {
		int myChkRings = itpCheckRingsFwd(itpMgr,-1,-1,1);
		printf("RING CHECK: %d\n", myChkRings);
		Pdtutil_Assert(myChkRings,"problem with from rings");
	      }
            }
            if (0) {
              while (Ddi_BddPartNum(partCone) > start_j)
                Ddi_BddPartRemove(partCone, 0); 
              while (firstItpIter<start_j-skip) {
                firstItpIter++;
              }
            }
          }
        }
        
        myConePlus = Ddi_BddDup(partCone);
        if (!growCone)
          Trav_MgrSetItpCheckCompleteness(travMgr, 2);

        unsoundProof = 0;

	itpMgr->hints.hintsFirst = 0;

        
        myItpBmcBound =
          checkFixPointByInterpolant(itpMgr, travMgr, fsmMgr, myConePlus, NULL,
          init, myCare, NULL, rOut, careOut, NULL, itpMgr->optLevel, abortP,
          itpMgr->time_limit, bwdK + 1, firstItpIter, maxItpIter,
          itpMgr->timeFrames);

	Ddi_Free(itpMgr->splitCex);

	travMgr->settings.ints.igrRingFirst = firstItpIter;
	travMgr->settings.ints.igrRingLast = -1;

        Trav_MgrSetItpCheckCompleteness(travMgr, cCompl);
        if (Ddi_BddIsPartDisj(myConePlus)) {
          while (0 && (Ddi_BddPartNum(myConePlus) > abs(myItpBmcBound))) {
            Ddi_BddPartRemove(myConePlus, Ddi_BddPartNum(myConePlus) - 1);
          }
          // done only to align arrays
          Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
          Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);

          if (myItpBmcBound < 0) {
	    travMgr->settings.ints.igrRingLast = -myItpBmcBound - 1;
            if (-myItpBmcBound <= Ddi_BddarrayNum(itpMgr->fromRings)) {
              if (-myItpBmcBound > 3) {
                enWeakenStrengthen = -myItpBmcBound-2;
              }
            }
            while (Ddi_BddPartNum(myConePlus) >= abs(myItpBmcBound)) {
              int j = abs(myItpBmcBound);

              myItpBmcBound--;
              if (Ddi_BddarrayNum(itpMgr->fromRings) <= j) {
                Ddi_BddarrayWrite(itpMgr->fromRings, j, myOne);
              }
            }
          }
          while (Ddi_BddPartNum(myConePlus) > Ddi_BddPartNum(partCone)) {
            Ddi_BddPartInsert(partCone, 0, myZero);
          }
          Ddi_Free(myZero);
          Ddi_Free(myOne);
        }
        Ddi_Free(myConePlus);

        if (*abortP < 0) {
          /* unsound fix point */
          unsoundProof = 1;
          *abortP = 0;
          doRefine = 0;
          itpBmcBound = myItpBmcBound;
        } else if (myItpBmcBound >= 0) {
          fixPoint = 1;
          doRefine = 0;
          if (itpMgr->stats.igrPiSubsetK>=0) {
            fixPoint = 0;
            if (myItpBmcBound < itpBmcBound) {
              itpBmcBound = myItpBmcBound;
            }
          }    
        } else {
          itpBmcBound = myItpBmcBound = -myItpBmcBound;
          /* SAT */
          Trav_MgrSetIgrSide(travMgr,savedMaxExpandSame);
          if (savedGrowCone>3) {
            if (growCone==3) {
              Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
                fprintf(tMgrO(travMgr),
                        "IGR switching to full REWIND\n");
              }
              
              Trav_MgrSetIgrGrowCone(travMgr,0);
              growCone = 0;
              Trav_MgrSetIgrSide(travMgr,0);
            }
            else {
              Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
                fprintf(tMgrO(travMgr),
                        "IGR switching to full UNWIND\n");
              }
              Trav_MgrSetIgrGrowCone(travMgr,3);
              growCone = 3;
              travMgr->settings.aig.igrRewind = 0;
            }
          }
          else if (0 && itpMgr->stats.igrRewindRing >= 0) {
            Trav_MgrSetIgrSide(travMgr,savedMaxExpandSame/2);
            travMgr->settings.aig.igrRewind *= 2;
          }
        }

      } else if (j == 0) {
        /* failure */
        Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
          fprintf(tMgrO(travMgr), "ITP refinement failure at bound %d.\n",
            bwdK + itpBmcBound - 1);
        }
        if (returnCex) {
          Ddi_Bdd_t *cex, *splitCex = NULL;
	  int len;
	  Ddi_Bdd_t *dummyRing = initStub==NULL ? Ddi_BddDup(currRing) :
	    Ddi_BddMakeConstAig(ddm, 1);
          cex = Ddi_AigSatAndWithCexAndAbort(myCone, dummyRing, NULL, NULL,
            -1, &abort);
          splitCex = itpTfSplitCex(itpMgr, cex, Ddi_BddReadMark(myCone));
	  len = Ddi_BddPartNum(splitCex);
	  if (len>1) {
	    /* remove last frame due to folded target */
	    Ddi_BddPartRemove(splitCex,len-1);
	  }
          Fsm_MgrSetCexBDD(fsmMgr, splitCex);
          Ddi_Free(cex);
          Ddi_Free(dummyRing);
          Ddi_Free(splitCex);
        }
        fixPoint = -2;
        itpBmcBound = 0;
        *satP = 1;
      } else if (j > 2 && j + nExactTimeFrames < itpBmcBound
        && enableSubset && 0) {
	/* DISABLED NOW !!! GpC: 12/2015 */
        int start_j = j + d;
        int subset_j =
          j < start_j - 3 ? (start_j - 3) : j + (2 * (start_j - j)) / 3;
        int myItpBmcBound = -(subset_j);
        int myAbort, mySat, myBwdK, myFP;

        /* generate cone subset */
        int growCone = Trav_MgrReadIgrGrowCone(travMgr);
        Ddi_Bdd_t *coneSubset = splitAndSubsetCone(itpMgr, myCone0,
          itpMgr->delta,
          start_j, j, subset_j, 0 && (growCone > 2 ? 1 : 0));

        myBwdK = Ddi_BddReadMark(coneSubset);
        maxExact *= 1.2;
        Trav_MgrSetIgrMaxExact(travMgr, maxExact);
        Trav_MgrSetIgrGrowCone(travMgr,
          growCone > 2 ? growCone - 1 : growCone);
        while (-myItpBmcBound > Ddi_BddarrayNum(itpMgr->fromRings)) {
          Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);

          Ddi_BddarrayInsertLast(itpMgr->fromRings, myOne);
          Ddi_Free(myOne);
        }
        myFP = Trav_IgrTrav(travMgr, fsmMgr, itpMgr, coneSubset, itpCare,
          rOut, careOut, myBwdK, recLevel + 1, &myItpBmcBound, &myAbort, &mySat);
        Trav_MgrSetIgrMaxExact(travMgr, maxExactSave);
        Trav_MgrSetIgrGrowCone(travMgr, growCone);
        //        nExactTimeFrames = 10000;

        Ddi_Free(coneSubset);
        /* push cone */
        enableSubset = 0;
        if (myAbort) {
          *abortP = myAbort;
        }

        break;
      } else if (!unsoundProof && ((j + nExactTimeFrames > itpBmcBound)
          || sizeRing < 10000 || sizeRing < 0.5 * sizeCone)) {
        tryExpandSame = maxExpandSame;  /* reset counter */
	if (itpMgr->stats.igrPiSubsetK>=0) {
	  if (j>=itpMgr->stats.igrPiSubsetRing) {
	    // disable cone growing
	    d--;
	    itpBmcBound--;
	    int kMax = Ddi_BddPartNum(partCone) - 1;
	    Pdtutil_Assert(kMax>1,"cone is too short");
	    Ddi_BddPartRemove(partCone, kMax-1);
	  }
	}
      }
    }
    prevRefined = refined;

    Ddi_Free(myCone0);
    Ddi_Free(myConeAbstr);
    Ddi_Free(myCone);
  }

  Ddi_Free(myCare);
  Ddi_Free(partCone);
  Ddi_Free(coneQueue);
  Ddi_Free(myZero);
  Ddi_Free(myOne);

  //  if ((*abortP) && !(*satP)) {
  // }
  
  *itpBmcBoundP = itpBmcBound;
  Trav_MgrSetIgrGrowCone(travMgr,savedGrowCone);

  return fixPoint;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Trav_SimplifyRingsBwdFwd(
  Trav_ItpMgr_t *itpMgr,
  int start_i,
  int maxIter,
  int maxFail,
  int useRingConstr,
  int boundK,
  int doFwd
)
{
  int end_i = start_i - maxIter;

  if (end_i < 1)
    end_i = 1;

  itpWeakenRingsBwd(itpMgr, start_i, end_i, itpMgr->delta, maxFail, useRingConstr,
    boundK);
  if (doFwd)
    itpStrengthenRingsFwd(itpMgr, end_i, start_i, itpMgr->delta, maxFail, useRingConstr, NULL,
                          boundK, 0);

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravSatQbfVerif(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * care,
  int step,
  int bound,
  float lazyRate
)
{
  Ddi_Vararray_t *pi, *ps, *ns, *quantifyArray;
  Ddi_Varset_t *pivars, *smooth, *quantify;
  Ddi_Bddarray_t *delta, *psLit, *nsLit, *piLit;
  Ddi_Bdd_t *reached, *unroll, *target, *tr,    // *tr_i,
  *loopFree, *myInvarspec;      //, *loopFreeBck;
  int sat = 0, res = 1, i, k, nState, nPi, initIsCube;
  long startTime, timeFrameLitsSize = 1;    //, currTime;
  Ddi_Bddarray_t **timeFrameLits =
    Pdtutil_Alloc(Ddi_Bddarray_t *, timeFrameLitsSize);
  Ddi_Bddarray_t **timeFramePiLits =
    Pdtutil_Alloc(Ddi_Bddarray_t *, timeFrameLitsSize);
  Ddi_Vararray_t **timeFramePiVars =
    Pdtutil_Alloc(Ddi_Vararray_t *, timeFrameLitsSize);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Varsetarray_t *timeFrameCoi = Ddi_VarsetarrayAlloc(ddm, 0);
  Ddi_Varset_t *supp, *psVars;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bddarray_t *lemmas = NULL;
  Ddi_Bdd_t *oldCheck = NULL, *newCheck = NULL, *newCheckRed = NULL;
  int genCex = 1;

  if (step > 0) {
    int result = 0;

    lemmas = genLemmaClasses(travMgr, fsmMgr, init, NULL,
      invar, invarspec, NULL, NULL, step, 0, 0, 0, &result, 0, NULL);
  }

  Ddi_MgrSetOption(ddm, Pdt_DdiLazyRate_c, fnum, lazyRate);

  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  psVars = Ddi_VarsetMakeFromArray(ps);

  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  nState = Ddi_BddarrayNum(delta);
  nPi = Ddi_VararrayNum(pi);
  psLit = Ddi_BddarrayAlloc(ddm, nState);
  nsLit = Ddi_BddarrayAlloc(ddm, nState);
  piLit = Ddi_BddarrayAlloc(ddm, nPi);

  pivars = Ddi_VarsetMakeFromArray(pi);
  smooth = Ddi_VarsetMakeFromArray(ps);
  Ddi_VarsetUnionAcc(smooth, pivars);

  {
    Ddi_Bdd_t *initBdd = Ddi_BddMakeMono(init);

    initIsCube = Ddi_BddIsCube(initBdd);
    Ddi_Free(initBdd);
  }

  myInvarspec = Ddi_BddDup(invarspec);
  if (travMgr->settings.aig.targetEn > 0) {
    Ddi_Bdd_t *r = Trav_TravSatBckVerif(travMgr, fsmMgr,
      init, invarspec, invar, NULL, travMgr->settings.aig.targetEn, 0, 0);

    Ddi_Free(myInvarspec);
    Ddi_BddNotAcc(r);
    myInvarspec = r;
  }

  /* build tr */
  tr = Ddi_BddMakeConstAig(ddm, 1);
  for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
    Ddi_Bdd_t *tr_i, *psLit_i, *nsLit_i;

    nsLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);

    Ddi_BddarrayWrite(nsLit, i, nsLit_i);
    Ddi_BddarrayWrite(psLit, i, psLit_i);
    tr_i = Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(delta, i));
    Ddi_BddAndAcc(tr, tr_i);
    Ddi_Free(tr_i);
    Ddi_Free(psLit_i);
    Ddi_Free(nsLit_i);
  }

  for (i = 0; i < Ddi_VararrayNum(pi); i++) {
    Ddi_Bdd_t *piLit_i;

    piLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(pi, i), 1);

    Ddi_BddarrayWrite(piLit, i, piLit_i);
    Ddi_Free(piLit_i);
  }

  Ddi_Free(pivars);

  loopFree = Ddi_BddMakeConstAig(ddm, 1);
  unroll = Ddi_BddMakeConstAig(ddm, 1);
  reached = Ddi_BddMakeConstAig(ddm, 0);

  if (care == NULL) {
    care = Ddi_BddMakeConstAig(ddm, 1);
  } else {
    care = Ddi_BddMakeAig(care);
  }
  //  DdiAigRedRemovalAcc (tr,myInvarspec,-1);
  //  Ddi_BddAndAcc(tr,myInvarspec);

  if (lemmas != NULL) {
    for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
      Ddi_BddAndAcc(care, Ddi_BddarrayRead(lemmas, i));
    }
    Ddi_Free(lemmas);
  }

  startTime = util_cpu_time();

  timeFrameLits[0] = Ddi_BddarrayDup(psLit);
  timeFramePiLits[0] = Ddi_BddarrayDup(piLit);
  timeFramePiVars[0] = Ddi_VararrayDup(pi);

  supp = Ddi_BddSupp(myInvarspec);
  Ddi_VarsetIntersectAcc(supp, psVars);
  Ddi_VarsetarrayInsertLast(timeFrameCoi, supp);
  Ddi_Free(supp);

  newCheck = Ddi_BddNot(myInvarspec);
  newCheckRed = Ddi_BddNot(myInvarspec);

  for (i = 0; !sat; i++) {
    Ddi_Bdd_t *check;           //, *oldCare;
    int fixPoint = 0;

    if (bound > 0 && i >= bound) {
      sat = 1;
      res = 2;                  /* abort */
      break;
    }
    {
      int nbaig = Ddi_MgrReadAigNodesNum(ddm);

      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "baig Nodes: %d.\n", nbaig)
        );
    }
    target = Ddi_BddNot(myInvarspec);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Inductive check at depth %d (unroll: %d).\n",
        i, Ddi_BddSize(unroll))
      );
    Ddi_BddComposeAcc(target, ps, timeFrameLits[i]);
    if (initIsCube) {
#if 0
      check = Ddi_BddDup(unroll);
#else
      check = Ddi_BddDup(newCheck);
#endif
      Ddi_AigAndCubeAcc(check, init);
    } else {
#if 0
      check = Ddi_BddAnd(unroll, init);
#else
      check = Ddi_BddAnd(newCheck, init);
#endif
    }
    Ddi_BddAndAcc(check, target);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "BMC (AIG size: %d/%d/%d).\n",
        Ddi_BddSize(check), Ddi_BddSize(newCheck), Ddi_BddSize(newCheckRed))
      );
    if (genCex) {
      Ddi_Bddarray_t *cexes;
      Ddi_Bdd_t *cex = Ddi_AigSatWithCex(check);

      if (cex != NULL) {
        cexes = Trav_MgrReadCexes(travMgr);
        if (cexes == NULL) {
          cexes = Ddi_BddarrayAlloc(ddm, 0);
          Ddi_BddarrayInsertLast(cexes, cex);
          Trav_MgrSetCexes(travMgr, cexes);
          Ddi_Free(cexes);
        } else {
          Ddi_BddarrayInsertLast(cexes, cex);
        }
        sat = 1;
        Ddi_Free(cex);
      }
    } else {
      sat = Ddi_AigSat(check) == 1;
    }
    Ddi_Free(check);
    Ddi_Free(target);
    if (sat) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "BMC failure at bound %d.\n", i)
        );
      res = !sat;
      break;
    }

    quantify = Ddi_BddSupp(reached);
    Ddi_VarsetDiffAcc(quantify, psVars);
    Ddi_BddNotAcc(reached);
    quantifyArray = Ddi_VararrayMakeFromVarset(quantify, 0);
    fixPoint = Ddi_AigQbfAndSolve(newCheck, reached, quantifyArray) == 0;
    Ddi_BddNotAcc(reached);
    Ddi_Free(quantifyArray);
    Ddi_Free(quantify);

    if (fixPoint) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "BWD fix point at bound %d.\n", i)
        );
      break;
    }

    Ddi_BddOrAcc(reached, newCheck);

    DdiAigRedRemovalAcc(newCheck, care, -1, -1.0);
    //      DdiAigRedRemovalAcc (newCheckRed,care,-1);

    Ddi_BddDiffAcc(care, newCheck);

    Ddi_Free(oldCheck);
    oldCheck = Ddi_BddDup(newCheck);

    if (1) {
      int j, nCoi = 0;

      //Ddi_Bddarray_t *delta_i;
      Ddi_Bdd_t *diff_i;        //, *invarspec_i;
      Ddi_Vararray_t *newPi = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(pi));
      Ddi_Bddarray_t *newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
      Ddi_Vararray_t *newNs = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(ns));
      Ddi_Bddarray_t *newNsLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(ns));
      Ddi_Varset_t *coiSupp = Ddi_VarsetVoid(ddm);

      for (j = 0; j < Ddi_VararrayNum(pi); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
        Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), i);
        Ddi_VarAttachName(newv, name);
        Ddi_VararrayWrite(newPi, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newPiLit, j, newvLit);
        Ddi_Free(newvLit);
      }
      for (j = 0; j < Ddi_VararrayNum(ns); j++) {
        char name[1000];
        Ddi_Var_t *v = Ddi_VararrayRead(ns, j);
        Ddi_Var_t *newv = Ddi_VarNewAfterVar(v);
        Ddi_Bdd_t *newvLit;

        sprintf(name, "%s_%d", Ddi_VarName(v), i);
        Ddi_VarAttachName(newv, name);
        Ddi_VararrayWrite(newNs, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newNsLit, j, newvLit);
        Ddi_Free(newvLit);
        if (Ddi_VarInVarset(Ddi_VarsetarrayRead(timeFrameCoi, i),
            Ddi_VararrayRead(ps, j))) {
          nCoi++;
          supp = Ddi_BddSupp(Ddi_BddarrayRead(delta, j));
          Ddi_VarsetUnionAcc(coiSupp, supp);
          Ddi_Free(supp);
        }
      }
      //      tr_i = Ddi_BddCompose(tr,pi,newPiLit);
      //      Ddi_BddComposeAcc(tr_i,ns,newNsLit);
      //      Ddi_BddComposeAcc(tr_i,ps,timeFrameLits[i]);
      if (i + 1 >= timeFrameLitsSize) {
        timeFrameLitsSize *= 2;
        timeFrameLits = Pdtutil_Realloc(Ddi_Bddarray_t *,
          timeFrameLits, timeFrameLitsSize);
        timeFramePiLits = Pdtutil_Realloc(Ddi_Bddarray_t *,
          timeFramePiLits, timeFrameLitsSize);
        timeFramePiVars = Pdtutil_Realloc(Ddi_Vararray_t *,
          timeFramePiVars, timeFrameLitsSize);
      }
      timeFrameLits[i + 1] = Ddi_BddarrayDup(newNsLit);
      timeFramePiLits[i + 1] = Ddi_BddarrayDup(newPiLit);
      timeFramePiVars[i + 1] = Ddi_VararrayDup(newPi);
      Ddi_VarsetIntersectAcc(coiSupp, psVars);
      Ddi_VarsetarrayInsertLast(timeFrameCoi, coiSupp);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMed_c,
        fprintf(tMgrO(travMgr), "{COI:%d} ", nCoi)
        );
      //      Ddi_BddAndAcc(unroll,tr_i);

      timeFrameShiftAcc(newCheck, timeFramePiVars, timeFramePiLits, i + 2);
      //      timeFrameShiftAcc(newCheckRed,timeFramePiVars,timeFramePiLits,i+2);
      if (i > 0) {
        Ddi_BddAndAcc(newCheck, myInvarspec);
      }
      Ddi_BddComposeAcc(newCheck, ps, delta);

      //      Ddi_BddComposeAcc(newCheckRed,ps,delta);
      //      Ddi_BddAndAcc(newCheckRed,myInvarspec);

      DdiAigRedRemovalAcc(newCheck, care, -1, -1.0);
      Ddi_BddAndAcc(newCheck, myInvarspec);

      // Overapprox !
      //      if (Ddi_BddSize(newCheck) > 100) {
      //        Ddi_AigExistAcc(newCheck,psVars,care,1,2);
      //      }
#if 0
      Ddi_AigExistProjectAcc(newCheck, psVars, care, 1, 0, -1.0);
      {
        Ddi_Varset_t *supp = Ddi_BddSupp(newCheck);

        Ddi_VarsetDiffAcc(supp, psVars);
        DdiAigExistOverAcc(newCheck, supp, care);
        Ddi_Free(supp);
      }
#endif
      //      Ddi_AigExistProjectAcc(newCheckRed,psVars,NULL,1,0);

      //      Ddi_Free(tr_i);
      Ddi_Free(newPi);
      Ddi_Free(newPiLit);
      Ddi_Free(newNs);
      Ddi_Free(newNsLit);
      Ddi_Free(coiSupp);
#if 0
      diff_i = Ddi_BddMakeConstAig(ddm, 1);
      for (j = 0; j <= i; j++) {
        Ddi_Bdd_t *diff_j = Ddi_BddMakeConstAig(ddm, 0);

        for (k = 0; k < Ddi_VararrayNum(ns); k++) {
          Ddi_Bdd_t *diff_k =
            Ddi_BddXor(Ddi_BddarrayRead(timeFrameLits[i + 1], k),
            Ddi_BddarrayRead(timeFrameLits[j], k));

          Ddi_BddOrAcc(diff_j, diff_k);
          Ddi_Free(diff_k);
        }
        Ddi_BddAndAcc(diff_i, diff_j);
        Ddi_Free(diff_j);
      }
      Ddi_BddAndAcc(loopFree, diff_i);
      Ddi_Free(diff_i);
#endif
    }
  }

  Ddi_Free(oldCheck);
  Ddi_Free(newCheck);
  Ddi_Free(newCheckRed);

  if (!sat) {
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Inductive Pass at Depth %d.\n", i)
      );
  }

  Trav_MgrSetAssertFlag(travMgr, sat);

  for (; i >= 0; i--) {
    Ddi_Free(timeFrameLits[i]);
    Ddi_Free(timeFramePiLits[i]);
    Ddi_Free(timeFramePiVars[i]);
  }

  Pdtutil_Free(timeFrameLits);
  Pdtutil_Free(timeFramePiLits);
  Pdtutil_Free(timeFramePiVars);
  Ddi_Free(timeFrameCoi);

  Ddi_Free(reached);
  Ddi_Free(piLit);
  Ddi_Free(psLit);
  Ddi_Free(nsLit);
  Ddi_Free(smooth);
  Ddi_Free(tr);

  Ddi_Free(care);

  Ddi_Free(psVars);
  Ddi_Free(myInvarspec);
  Ddi_Free(loopFree);
  Ddi_Free(unroll);

  return (res);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_TravLemmaReduction(
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invarspec,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * care,
  int lemmasSteps,
  int doImpl,
  int execMode,
  char *fsmName
)
{
  Ddi_Bdd_t *myInvarspec = NULL, *myCare;
  char filename[1000];
  Ddi_Bddarray_t *lemmas = NULL;
  int i;
  int result = 0;
  Ddi_Bddarray_t *initStub = Fsm_MgrReadInitStubBDD(fsmMgr);

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);

  if (invarspec != NULL) {
    myInvarspec = Ddi_BddDup(invarspec);
  }

  if (care != NULL) {
    myCare = Ddi_BddDup(care);
  } else {
    myCare = Ddi_BddMakeConstAig(ddm, 1);
  }

  if (lemmasSteps > 0) {
    if (0 && doImpl) {
      int i;

      lemmas = genLemmas(travMgr, fsmMgr, init, invar,
        myInvarspec, myCare, lemmasSteps, 1, -1, &result);
      for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
        Ddi_BddAndAcc(myCare, Ddi_BddarrayRead(lemmas, i));
      }
    } else {
      Ddi_Bddarray_t *delta = Fsm_MgrReadDeltaBDD(fsmMgr);
      Ddi_Vararray_t *ps = Fsm_MgrReadVarPS(fsmMgr);
      Ddi_Bdd_t *fsmInvar = NULL, *fsmProp = NULL;
      int iInvar = -1, iProp = -1;

      if (0) {
        Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
        int i, n = Ddi_BddarrayNum(delta);

        myInvarspec = NULL;
        for (i = n / 2; i < n; i++) {
          Ddi_BddarrayWrite(delta, i, myOne);
        }
        Ddi_Free(myOne);
      }
      lemmas = genLemmaClasses(travMgr, fsmMgr,
        init, initStub, invar, myInvarspec, myCare, NULL, lemmasSteps,
        1, doImpl, care != NULL ? 1 : execMode, &result, 0, NULL);

      for (i = Ddi_BddarrayNum(delta) - 1; i >= 0; i--) {
        Ddi_Var_t *pv_i = Ddi_VararrayRead(ps, i);
        int isInvar = Ddi_VarName(pv_i) != NULL &&
          (strcmp(Ddi_VarName(pv_i), "PDT_BDD_INVAR_VAR$PS") == 0);
        int isProp = Ddi_VarName(pv_i) != NULL &&
          (strcmp(Ddi_VarName(pv_i), "PDT_BDD_INVARSPEC_VAR$PS") == 0);
        if (isInvar) {
          fsmInvar = Ddi_BddarrayRead(delta, i);
          iInvar = i;
          // break;
        } else if (isProp) {
          fsmProp = Ddi_BddarrayRead(delta, i);
          iProp = i;
          // break;
        }
        if (iProp >= 0 && iInvar >= 0)
          break;
      }
      if (invar != NULL && fsmInvar != NULL) {
        Ddi_BddAndAcc(fsmInvar, invar);
      }

      if (execMode > 0 && lemmas && invar) {
        Ddi_Bddarray_t *delta = Fsm_MgrReadDeltaBDD(fsmMgr);

        if (0 && fsmInvar != NULL && fsmProp != NULL) {
          Ddi_Var_t *vInvar = Ddi_VararrayRead(ps, iInvar);

          Ddi_BddCofactorAcc(fsmProp, vInvar, 1);
        }
        for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
          Ddi_BddAndAcc(invar, Ddi_BddarrayRead(lemmas, i));
          if (fsmInvar != NULL) {
            Ddi_BddAndAcc(fsmInvar, Ddi_BddarrayRead(lemmas, i));
          }
        }
        if (0 && fsmInvar != NULL && fsmProp != NULL) {
          Ddi_Var_t *vInvar = Ddi_VararrayRead(ps, iInvar);
          Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(vInvar, 0);

          Ddi_BddOrAcc(fsmProp, lit);
          Ddi_Free(lit);
        }
      } else if (execMode == 0 && care != NULL && lemmas) {
        for (i = 0; i < Ddi_BddarrayNum(lemmas); i++) {
          Ddi_BddAndAcc(care, Ddi_BddarrayRead(lemmas, i));
        }

      }
    }
    Ddi_Free(lemmas);
  }

  if (fsmName != NULL) {
    Ddi_Vararray_t *pi, *ps, *ns;
    Ddi_Bdd_t *s0;
    Ddi_Bddarray_t *delta, *lambda;

    pi = Fsm_MgrReadVarI(fsmMgr);
    ps = Fsm_MgrReadVarPS(fsmMgr);
    ns = Fsm_MgrReadVarNS(fsmMgr);
    s0 = Fsm_MgrReadInitBDD(fsmMgr);
    delta = Fsm_MgrReadDeltaBDD(fsmMgr);
    lambda = Fsm_MgrReadLambdaBDD(fsmMgr);

    //printf("Seq. restrict: |delta|=%d", Ddi_BddarraySize(delta));
    //Ddi_BddRestrictAcc(delta, myCare);

    if (myCare != NULL) {
      Ddi_SetName(myCare, "lemmaCareSet");
      Ddi_BddarrayWrite(lambda, 1, myCare);
    }

    sprintf(filename, "%s.blif", fsmName);
    Ddi_AigFsmStore(pi, ps, ns, s0, delta, lambda,
      filename, NULL, Pdtutil_Aig2Blif_c);
  }
  Ddi_Free(lemmas);
  Ddi_Free(myInvarspec);
  Ddi_Free(myCare);

  if (result) {
    Trav_MgrSetAssertFlag(travMgr, result < 0);
  }
  return result;
}





/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Vararray_t *
Trav_RefPiVars(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Ddi_Vararray_t * vars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(vars);
  int j, k, n = Ddi_VararrayNum(vars);
  Ddi_Vararray_t *refVars = Ddi_VararrayAlloc(ddm, n);
  static char buf[1000], *buf2;

  for (j = 0; j < Ddi_VararrayNum(vars); j++) {
    Ddi_Var_t *v_ref_j, *v_j = Ddi_VararrayRead(vars, j);

    strcpy(buf, Ddi_VarName(v_j));
    buf2 = Pdtutil_StrSkipPrefix(buf, "PDT_TF_VAR_");
    if (buf2 != NULL) {
      Pdtutil_StrRemoveNumSuffix(buf2, '_');
    } else {
      buf2 = buf;
    }
    v_ref_j = Ddi_VarFromName(ddm, buf2);
    Ddi_VararrayWrite(refVars, j, v_ref_j);
  }
  return refVars;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Ddi_Bddarray_t *
Trav_SimulateAndCheckProp(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bddarray_t * delta,
  Ddi_Bdd_t * deltaPropPart,
  Ddi_Bdd_t * init,
  Ddi_Bddarray_t * initStub,
  Ddi_Bdd_t * cex
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(delta);
  int np = Ddi_BddPartNum(deltaPropPart);
  Ddi_Bddarray_t *res = NULL;
  int part = Ddi_BddPartNum(cex);
  int i, i0 = 0, failed = 0;
  Ddi_Vararray_t *pi = Fsm_MgrReadVarI(fsmMgr);
  Ddi_Vararray_t *ps = Fsm_MgrReadVarPS(fsmMgr);
  Ddi_Bddarray_t *stateArray;
  int doPrint = 0;

  if (initStub != NULL) {
    Ddi_Bdd_t *tfCex = Ddi_BddPartRead(cex, i0++);

    stateArray = Ddi_BddarrayDup(initStub);
    Ddi_AigarrayConstrainCubeAcc(stateArray, tfCex);
  } else {
    stateArray = Ddi_BddarrayMakeLiteralsAig(ps, 1);
    Ddi_AigarrayConstrainCubeAcc(stateArray, init);
  }

  for (i = i0; i < part && !failed; i++) {
    Ddi_Bddarray_t *newStateArray = Ddi_BddarrayDup(delta);
    Ddi_Bdd_t *tfCex = Ddi_BddPartRead(cex, i);
    Ddi_Vararray_t *tfCexSupp = Ddi_BddSuppVararray(tfCex);
    Ddi_Vararray_t *tfCexSuppRef = Trav_RefPiVars(travMgr, tfCexSupp);
    Ddi_Bdd_t *tfCexRef = Ddi_BddSubstVars(tfCex, tfCexSupp, tfCexSuppRef);

    if (doPrint) {
      int j;

      printf("[%d] ", i);
      for (j = 0; j < Ddi_BddarrayNum(stateArray); j++) {
        Ddi_Bdd_t *l = Ddi_BddarrayRead(stateArray, j);

        printf("%c", Ddi_BddIsZero(l) ? '0' : '1');
      }
      printf("\n");
    }


    Ddi_Free(tfCexSupp);
    Ddi_Free(tfCexSuppRef);

    Ddi_BddarrayComposeAcc(newStateArray, ps, stateArray);
    Ddi_AigarrayConstrainCubeAcc(newStateArray, tfCexRef);

    if (i == part - 1) {
      Ddi_Bdd_t *myProp = Ddi_BddDup(deltaPropPart);

      Ddi_BddComposeAcc(myProp, ps, stateArray);
      Ddi_AigConstrainCubeAcc(myProp, tfCexRef);
      res = Ddi_BddarrayMakeFromBddPart(myProp);
      Ddi_Free(myProp);
    } else {
      Ddi_Bdd_t *myProp = Ddi_BddDup(deltaPropPart);

      Ddi_BddComposeAcc(myProp, ps, stateArray);
      Ddi_AigConstrainCubeAcc(myProp, tfCexRef);
      if (Ddi_BddIsZero(Ddi_BddPartRead(myProp, 0))) {
        printf("FAILED at cex step %d\n", i);
        res = Ddi_BddarrayMakeFromBddPart(myProp);
        failed = 1;
      }
      Ddi_Free(myProp);
    }

    Ddi_Free(stateArray);
    stateArray = newStateArray;
    Ddi_Free(tfCexRef);
  }

  Ddi_Free(stateArray);

  return res;
}

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/



/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
innerLoopInitFwd(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Ddi_Bdd_t * kCone,
  Ddi_Bdd_t * init,
  Ddi_Vararray_t * constrainVarsOut,
  Ddi_Bddarray_t * constrainSubstLitsOut,
  int nSteps,
  Ddi_Bdd_t * careBwd,
  Trav_ItpMgr_t * itpMgr,
  int *pAbort,
  int optLevel,
  unsigned long time_limit
)
{
  Ddi_Mgr_t *ddm;
  Ddi_Bddarray_t *initStub = itpMgr->initStub;
  Ddi_Vararray_t *pi = itpMgr->pi;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Bddarray_t *psLit = itpMgr->psLit;
  Ddi_Bddarray_t *nsLit = itpMgr->nsLit;
  Ddi_Bddarray_t *delta = itpMgr->delta;

  Ddi_Bddarray_t *fromArray = NULL;

  Ddi_Vararray_t *constrainVars = NULL;
  Ddi_Bddarray_t *constrainSubstLits = NULL;

  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);

  Ddi_Varset_t *nsvars = Ddi_VarsetMakeFromArray(ns);
  Ddi_Varset_t *psvars = Ddi_VarsetMakeFromArray(ps);

  int step;
  int eqConstr = 1, constConstr = 1;

  if (initStub != NULL) {
    fromArray = Ddi_BddarrayDup(initStub);
  } else {
    Pdtutil_Assert(init != NULL, "MISSING INIT");
    Pdtutil_Assert(Ddi_BddIsCube(init), "init cube required");
    fromArray = Ddi_BddarrayDup(itpMgr->psLit);
    Ddi_AigarrayConstrainCubeAcc(fromArray, init);
  }
  ddm = Ddi_ReadMgr(fromArray);

  for (step = 0; step < nSteps; step++) {

    Ddi_Bdd_t *from, *localCone = NULL;

    /* compose new time frame */

    Ddi_Bddarray_t *fromArray0;
    char suffix[20];

    sprintf(suffix, "%d", step);

    fromArray0 = fromArray;
    Ddi_Vararray_t *newPiVars =
      Ddi_VararrayMakeNewVars(pi, "PDT_ITP_INITFWD_PI", suffix, 1);
    Ddi_Bddarray_t *newPiLits = Ddi_BddarrayMakeLiteralsAig(newPiVars, 1);

    fromArray = Ddi_BddarrayDup(itpMgr->delta);
    Ddi_BddarrayComposeAcc(fromArray, pi, newPiLits);

    /* apply equiv constraints */
    if (constrainVars != NULL && Ddi_VararrayNum(constrainVars) > 0) {
      int i, j, n = Ddi_VararrayNum(constrainVars);

      Ddi_AigarrayComposeAcc(constrainSubstLits, ns, psLit);
      /* GpC: this is because we miss a subst function for vararrays */
      for (i = 0; i < n; i++) {
        Ddi_Var_t *v_i = Ddi_VararrayRead(constrainVars, i);

        for (j = 0; j < Ddi_VararrayNum(ns); j++) {
          if (Ddi_VararrayRead(ns, j) == v_i) {
            Ddi_VararrayWrite(constrainVars, i, Ddi_VararrayRead(ps, j));
          }
        }
      }
      Ddi_BddarrayComposeAcc(fromArray, constrainVars, constrainSubstLits);
    }

    Ddi_BddarrayComposeAcc(fromArray, ps, fromArray0);


    Ddi_Free(fromArray0);
    Ddi_Free(newPiVars);
    Ddi_Free(newPiLits);
    Ddi_Free(constrainVars);
    Ddi_Free(constrainSubstLits);
    constrainVars = Ddi_VararrayAlloc(ddm, 0);
    constrainSubstLits = Ddi_BddarrayAlloc(ddm, 0);


    from = Ddi_BddRelMakeFromArray(fromArray, ns);
    Ddi_BddSetAig(from);
    if (kCone != NULL) {
      localCone = Ddi_BddDup(kCone);
    }

    /* const vars constraints */

    if (constConstr) {
      Ddi_Varset_t *ternaryVars = Ddi_BddSupp(from);
      Ddi_Bdd_t *ternaryFrom, *ternaryToPlus = NULL;

      Ddi_VarsetDiffAcc(ternaryVars, nsvars);
      ternaryFrom = Ddi_BddDup(from);
      DdiAigExistOverAcc(ternaryFrom, ternaryVars, NULL);
      ternaryToPlus = DdiAigImpliedVarsAcc(ternaryFrom, NULL, nsvars);

      if (ternaryToPlus != NULL) {
        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("ternary to+: %d\n", Ddi_BddSize(ternaryToPlus));
        }
        Ddi_AigConstrainCubeAcc(from, ternaryToPlus);


        if (Ddi_BddSize(ternaryToPlus) > 0 && constrainVars != NULL) {
          Ddi_Varset_t *supp = Ddi_BddSupp(ternaryToPlus);
          Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(supp, 1);
          Ddi_Bddarray_t *vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
          int i, j, n = Ddi_VararrayNum(vA), nc =
            Ddi_VararrayNum(constrainVars);

          /* check duplicates */
          for (i = 0; i < n; i++) {
            for (j = 0; j < nc; j++) {
              Pdtutil_Assert(Ddi_VararrayRead(vA, i) !=
                Ddi_VararrayRead(constrainVars, j),
                "duplicate vars in constrain array");
            }
          }

          Ddi_AigarrayConstrainCubeAcc(vLits, ternaryToPlus);
          Ddi_VararrayAppend(constrainVars, vA);
          Ddi_BddarrayAppend(constrainSubstLits, vLits);

          Ddi_Free(vA);
          Ddi_Free(vLits);
          Ddi_Free(supp);
        }

      }
      Ddi_Free(localCone);
      Ddi_Free(ternaryFrom);
      Ddi_Free(ternaryVars);
      Ddi_Free(ternaryToPlus);
    }

    /* equiv constraints */

    if (eqConstr) {
      Ddi_Bdd_t *eq;

      eq = DdiAigEquivVarsAcc(from, NULL, NULL, nsvars, localCone,
        constrainVars, constrainSubstLits);
      Ddi_Free(eq);
    }


    Ddi_Free(from);

  }

  if (constrainVarsOut != NULL && constrainVars != NULL) {
    Ddi_DataCopy(constrainVarsOut, constrainVars);
    Ddi_DataCopy(constrainSubstLitsOut, constrainSubstLits);
  }

  Ddi_Free(nsvars);
  Ddi_Free(psvars);
  Ddi_Free(constrainVars);
  Ddi_Free(constrainSubstLits);

  return fromArray;


}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_PersistentTarget(
  Fsm_Mgr_t * fsmMgr /* Fsm Manager */ ,
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Ddi_Bdd_t * target,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * ns,
  Ddi_Bddarray_t * delta
)
{
  int ret = 0;
  Ddi_Bdd_t *myTarget = Ddi_BddDup(target);
  Ddi_Bdd_t *targetPlus = NULL;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Vararray_t *newVars;
  Ddi_Var_t *vProp = NULL;
  Ddi_Var_t *vConstr = NULL;

  Ddi_BddSubstVarsAcc(myTarget, ns, ps);

  if (fsmMgr != NULL) {
    vProp = Fsm_MgrReadPdtSpecVar(fsmMgr);
    vConstr = Fsm_MgrReadPdtConstrVar(fsmMgr);
  } else if (travMgr != NULL) {
    vProp = Trav_MgrReadPdtSpecVar(travMgr);
    vConstr = Trav_MgrReadPdtConstrVar(travMgr);
  }

  if (vProp != NULL)
    Ddi_BddCofactorAcc(myTarget, vProp, 1);
  if (vConstr != NULL)
    Ddi_BddCofactorAcc(myTarget, vConstr, 1);

  targetPlus = Ddi_BddDup(myTarget);
  vA = Ddi_BddSuppVararray(targetPlus);

  Ddi_VararrayDiffAcc(vA, ps);

  newVars = Ddi_VararrayMakeNewVars(vA, "PDT_AUXV_", "", 1);
  Ddi_BddSubstVarsAcc(targetPlus, vA, newVars);
  Ddi_BddComposeAcc(targetPlus, ps, delta);

  if (vProp != NULL)
    Ddi_BddCofactorAcc(targetPlus, vProp, 1);
  if (vConstr != NULL)
    Ddi_BddCofactorAcc(targetPlus, vConstr, 1);

  Ddi_Free(newVars);
  Ddi_Free(vA);

  if (Ddi_BddIncluded(myTarget, targetPlus)) {
    printf("target bwd reachable from target\n");
    ret = 1;
  } else {
    Ddi_BddDiffAcc(myTarget, targetPlus);
    Ddi_Bdd_t *cex = Ddi_AigSatWithCex(myTarget);

    Ddi_Free(cex);
  }

  Ddi_Free(myTarget);
  Ddi_Free(targetPlus);

  return ret;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpAbstrRefCurrAbstrSetup(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t * kCone
)
{
  if (itpMgr->abstrRef == 0 || itpMgr->abstrRef > 2) {
    Ddi_Free(itpMgr->abstrCurrAbstr);
    return 0;
  }

  if (itpMgr->abstrRef > 0 && itpMgr->abstrRef <= 2) {

    Ddi_Bddarray_t *abstrSelect = itpMgr->abstrCurrAbstr;

    if (abstrSelect == NULL) {
      abstrSelect = itpMgr->abstrDoAbstr;
    }
    abstrSelect = Ddi_BddarrayDup(abstrSelect);

    if (itpMgr->delta0==NULL)
      itpMgr->delta0 = Ddi_BddarrayDup(itpMgr->delta);

    Ddi_Free(itpMgr->tr);
    Ddi_Free(itpMgr->trAux);
    Ddi_Free(itpMgr->trArray);
    Ddi_Free(itpMgr->delta);

    if (kCone != NULL) {
      Ddi_BddComposeAcc(kCone, itpMgr->abstrRefCtrl, abstrSelect);
    }
    if (kConeRings != NULL) {
      int np = Ddi_BddPartNum(kConeRings);
      int d = Ddi_BddReadMark(Ddi_BddPartRead(kConeRings, np - 1));

      Ddi_BddComposeAcc(kConeRings, itpMgr->abstrRefCtrl, abstrSelect);
      Ddi_BddWriteMark(Ddi_BddPartRead(kConeRings, np - 1), d);
    }

    itpMgr->tr = Ddi_BddDup(itpMgr->trAbstr);
    itpMgr->trAux = Ddi_BddDup(itpMgr->trAuxAbstr);
    itpMgr->trArray = Ddi_BddarrayDup(itpMgr->trArrayAbstr);

    if (itpMgr->abstrRefNnf) {
      itpAbstrRefCurrAbstrNnfJoinCtrl(itpMgr, abstrSelect);
    }

    Ddi_BddComposeAcc(itpMgr->tr, itpMgr->abstrRefCtrl, abstrSelect);
    Ddi_BddComposeAcc(itpMgr->trAux, itpMgr->abstrRefCtrl, abstrSelect);
    Ddi_BddarrayComposeAcc(itpMgr->trArray, itpMgr->abstrRefCtrl, abstrSelect);

    itpAbstrRefCurrAbstrDeltaSetup(itpMgr);

    Ddi_Free(abstrSelect);
  }
  return 1;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpAbstrRefCurrAbstrNnfJoinCtrl(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t * abstrSelect
)
{
  int i;
  const char prefix_0[] = "abstrRefCtrl_PDTRAV_NNF_RAIL_0_";
  const char prefix_1[] = "abstrRefCtrl_";

  Pdtutil_Assert(Ddi_VararrayNum(itpMgr->abstrRefCtrl) ==
    Ddi_BddarrayNum(abstrSelect), "mismatching arrays");
  for (i = 0; i < Ddi_VararrayNum(itpMgr->abstrRefCtrl); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->abstrRefPsPiVars, i);

    if (Ddi_BddIsOne(Ddi_BddarrayRead(abstrSelect, i))) {
      Ddi_VarIncrMark(v, 1);
    }
  }
  for (i = 0; i < Ddi_VararrayNum(itpMgr->abstrRefCtrl); i++) {
    Ddi_Var_t *ctrl = Ddi_VararrayRead(itpMgr->abstrRefCtrl, i);
    Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->abstrRefPsPiVars, i);

    if (Ddi_BddIsOne(Ddi_BddarrayRead(abstrSelect, i))) {
      if (Ddi_VarReadMark(v) < 2) {
        Pdtutil_Assert(Ddi_VarReadMark(v) == 1, "wrong var mark");
      }
      Ddi_BddNotAcc(Ddi_BddarrayRead(abstrSelect, i));
    }
  }

  Ddi_VararrayWriteMark(itpMgr->abstrRefPsPiVars, 0);
  return 0;

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpAbstrRefBddarrayRefine(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t * fA,
  Ddi_Bddarray_t * abstrSelect,
  int refineAndAbstr
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(fA);
  int freeSelect = 0;

  if (abstrSelect == NULL) {
    freeSelect = 1;
    if (itpMgr->abstrCurrAbstr != NULL) {
      abstrSelect = Ddi_BddarrayDup(itpMgr->abstrCurrAbstr);
    } else {
      /* full abstraction */
      abstrSelect = Ddi_BddarrayDup(itpMgr->abstrDoAbstr);
    }
  }

  if (refineAndAbstr) {
    Ddi_BddarrayComposeAcc(fA, itpMgr->abstrRefCtrl, abstrSelect);
  } else {
    int i;
    Ddi_Vararray_t *refineV = Ddi_VararrayAlloc(ddm, 0);

    for (i = 0; i < Ddi_VararrayNum(itpMgr->abstrRefCtrl); i++) {
      Ddi_Var_t *ctrl = Ddi_VararrayRead(itpMgr->abstrRefCtrl, i);

      if (Ddi_BddIsZero(Ddi_BddarrayRead(abstrSelect, i))) {
        Ddi_VararrayInsertLast(refineV, ctrl);
      }
    }
    Ddi_BddarrayVararrayCofactorAcc(fA, refineV, 0);
    Ddi_Free(refineV);
  }
  if (freeSelect)
    Ddi_Free(abstrSelect);

  return 1;

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpAbstrRefCurrAbstrDeltaSetup(
  Trav_ItpMgr_t * itpMgr
)
{
  int chk = 1, joinCtrl = 1;

  if (itpMgr->abstrCurrAbstr != NULL) {
    itpMgr->abstrRefNumRefinedLatches = 0;
    for (int i=0; i<Ddi_BddarrayNum(itpMgr->abstrCurrAbstr); i++) {
      if (Ddi_BddIsZero(Ddi_BddarrayRead(itpMgr->abstrCurrAbstr,i))) {
        itpMgr->abstrRefNumRefinedLatches++;
      }
    }
  }

  if (itpMgr->abstrRef > 0 && itpMgr->abstrRef <= 2) {
    //    Ddi_Free(itpMgr->delta);
    if (itpMgr->delta0==NULL)
      itpMgr->delta0 = Ddi_BddarrayDup(itpMgr->delta);

    if (itpMgr->abstrRefNnf) {
      Ddi_Bddarray_t *abstrSelect = NULL;

      Ddi_Free(itpMgr->nnf.delta);
      if (itpMgr->abstrCurrAbstr != NULL) {
        abstrSelect = Ddi_BddarrayDup(itpMgr->abstrCurrAbstr);
      } else {
        /* full abstraction */
        abstrSelect = Ddi_BddarrayDup(itpMgr->abstrDoAbstr);
      }
      itpAbstrRefBddarrayRefine(itpMgr, itpMgr->nnf.deltaAbstr, abstrSelect,
        0);
      itpMgr->nnf.delta = Ddi_BddarrayDup(itpMgr->nnf.deltaAbstr);
      itpAbstrRefBddarrayRefine(itpMgr, itpMgr->nnf.delta, abstrSelect, 1);
      Pdtutil_Assert(!chk || Ddi_AigarrayCheckMonotone(itpMgr->nnf.delta,
          itpMgr->abstrRefInp), "not monotone");
      Pdtutil_Assert(!chk ||
        Ddi_AigarrayCheckMonotone(itpMgr->nnf.delta,
          itpMgr->nnf.ps2), "not monotone");

      Ddi_BddarrayVararrayCofactorAcc(itpMgr->nnf.delta,
        itpMgr->abstrRefInp, 1);

      itpMgr->delta = Ddi_BddarrayDup(itpMgr->nnf.deltaAbstr);

      Ddi_BddarrayAigFromNnfAcc(itpMgr->delta, itpMgr->ps, NULL, 1);

      if (joinCtrl && itpMgr->abstrCurrAbstr != NULL) {
        itpAbstrRefCurrAbstrNnfJoinCtrl(itpMgr, abstrSelect);
      }
      itpAbstrRefBddarrayRefine(itpMgr, itpMgr->delta, abstrSelect, 1);
      Ddi_Free(abstrSelect);

      // refine PIs
#if 1
      Ddi_BddarrayAigFromNnfAcc(itpMgr->delta, itpMgr->pi, "abstrRefInp", 0);
      Ddi_BddarrayAigFromNnfAcc(itpMgr->delta, itpMgr->ps, "abstrRefInp", 0);
#endif
    } else {
      itpAbstrRefBddarrayRefine(itpMgr, itpMgr->deltaAbstr, NULL, 0);
      Ddi_Free(itpMgr->delta);
      itpMgr->delta = Ddi_BddarrayDup(itpMgr->deltaAbstr);
      itpAbstrRefBddarrayRefine(itpMgr, itpMgr->delta, NULL, 1);
      if (itpMgr->abstrRefTrConstr != NULL) {
        Ddi_Bdd_t *trConstr = Ddi_BddCompose(itpMgr->abstrRefTrConstr,
                                             itpMgr->ns,itpMgr->delta);
        int iConstr = Ddi_BddarrayNum(itpMgr->delta)-2;
        Ddi_Bdd_t *deltaConstr = Ddi_BddarrayRead(itpMgr->delta,iConstr);
        Ddi_BddSetAig(trConstr);
        Ddi_BddAndAcc(deltaConstr,trConstr);
        if (itpMgr->invarConstr!=NULL)
          Ddi_BddAndAcc(itpMgr->invarConstr,trConstr);  
        if (itpMgr->invarConstrForTr!=NULL)
          Ddi_BddAndAcc(itpMgr->invarConstrForTr,trConstr);  
        Ddi_Free(trConstr);
        trConstr = Ddi_BddCompose(itpMgr->abstrRefTrConstr,
                                             itpMgr->ns,itpMgr->deltaAbstr);
        deltaConstr = Ddi_BddarrayRead(itpMgr->deltaAbstr,iConstr);
        Ddi_BddSetAig(trConstr);
        Ddi_BddAndAcc(deltaConstr,trConstr);
        Ddi_Free(trConstr);
      }
    }
    //    Ddi_AigarrayAbcRpmAcc(itpMgr->delta,itpMgr->ps,-1,-1.0);
    if (0 && itpMgr->hints.hintsEnabled) {
      int iConstr = itpMgr->hints.invar_i;
      Ddi_Bdd_t *deltaConstr = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->delta,iConstr));
      Ddi_AigarrayConstrainCubeAcc(itpMgr->delta, itpMgr->hints.hintsConstr);
      Ddi_BddarrayWrite(itpMgr->delta,iConstr,deltaConstr);
      Ddi_Free(deltaConstr);
    }
    return 1;
  }
  return 0;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpAbstrRefCurrAbstrDeltaCheck(
  Trav_ItpMgr_t * itpMgr
)
{
  Ddi_Bddarray_t *myDelta;
  int j, n = Ddi_BddarrayNum(itpMgr->delta);

#if 0

  // todo

  for (j = 0; j < Ddi_BddarrayNum(itpMgr->delta); j++) {
    Ddi_Bdd_t *d = Ddi_BddarrayRead(itpMgr->delta, j);
    Ddi_Bdd_t *d0 = Ddi_BddarrayRead(itpMgr->delta0, j);

    if (!Ddi_BddIncluded(d, d0)) {
      printf("abstr delta inclusion problem [%d] size %d - %d\n",
        j, Ddi_BddSize(d), Ddi_BddSize(d0));
    }
  }


  if (itpMgr->abstrRefNnf) {
    //myDelta = Ddi_BddCompose(itpMgr->nnf.deltaAbstr,
    Ddi_Free(itpMgr->delta0);
    itpMgr->delta0 = itpMgr->nnf.delta;
    //      Ddi_Free(itpMgr->nnf.delta);
    itpMgr->nnf.delta = Ddi_BddarrayVararrayCofactor(itpMgr->delta,
      itpMgr->abstrRefInp, 1);
  }
  //    Ddi_AigarrayAbcRpmAcc(itpMgr->delta,itpMgr->ps,-1,-1.0);
  return 1;

#endif

  return 1;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
abstrRefCompact(
  Trav_ItpMgr_t * itpMgr
)
{
  int i;

  if (itpMgr->abstrRef > 0 && itpMgr->abstrRef <= 2) {
    for (i = 0; i < Ddi_VararrayNum(itpMgr->abstrRefCtrl); i++) {
      if (Ddi_BddIsZero(Ddi_BddarrayRead(itpMgr->abstrDoAbstr, i))) {
        // abstration refined or dummy. remove
        Ddi_VararrayWrite(itpMgr->abstrRefPsPiVars, i, NULL);
        Ddi_VararrayWrite(itpMgr->abstrRefCtrl, i, NULL);
        Ddi_BddarrayWrite(itpMgr->abstrRefFilter, i, NULL);
        Ddi_BddarrayWrite(itpMgr->abstrDoAbstr, i, NULL);
        Ddi_BddarrayWrite(itpMgr->abstrDoRefine, i, NULL);
      }
    }
    Ddi_VararrayRemoveNull(itpMgr->abstrRefPsPiVars);
    Ddi_VararrayRemoveNull(itpMgr->abstrRefCtrl);
    Ddi_BddarrayRemoveNull(itpMgr->abstrRefFilter);
    Ddi_BddarrayRemoveNull(itpMgr->abstrDoAbstr);
    Ddi_BddarrayRemoveNull(itpMgr->abstrDoRefine);
    return 1;
  }
  return 0;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpAbstrRefApplyCurrAbstr(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * f
)
{
  if (itpMgr->abstrRef > 0 && itpMgr->abstrRef <= 2) {
    if (f != NULL && itpMgr->abstrCurrAbstr != NULL) {
      Ddi_BddComposeAcc(f, itpMgr->abstrRefCtrl, itpMgr->abstrCurrAbstr);
      return 1;
    } else if (f != NULL) {
      /* full abstraction */
      Ddi_BddComposeAcc(f, itpMgr->abstrRefCtrl, itpMgr->abstrDoAbstr);
    }
  }
  return 0;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpFilterFreeNsVars(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Vararray_t * coneSupp
)
{
  Trav_Mgr_t *travMgr = itpTravMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;
  int i, n1, np = Ddi_BddarrayNum(itpTravMgr->trArray);
  Ddi_Bdd_t *auxTr = Ddi_BddMakePartConjVoid(ddm);

  Ddi_VararrayWriteMark(coneSupp, 1);
  for (i = 0; i < np; i++) {
    Ddi_Bdd_t *p_i = Ddi_BddarrayRead(itpTravMgr->trArray, i);
    Ddi_Var_t *ns_i = Ddi_VararrayRead(itpMgr->ns, i);

    if (0 || i >= np - 2 || (Ddi_VarReadMark(ns_i) == 1)) {
      Ddi_BddPartInsertLast(auxTr, p_i);
    }
  }

  Ddi_VararrayWriteMark(coneSupp, 0);
  Ddi_BddSetAig(auxTr);
  Ddi_Free(itpTravMgr->trAux);
  itpTravMgr->trAux = auxTr;
  return n1;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpTrAbstrWithItp(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * cone
)
{
  Trav_Mgr_t *travMgr = itpTravMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;

  Ddi_Bdd_t *auxTr = Ddi_BddDup(itpTravMgr->trAux);
  Ddi_Bdd_t *b = Ddi_BddDup(itpTravMgr->from);

  Ddi_Bdd_t *itpTrAbstr = itpMgr->itpTrAbstr;
  int doRefine=1, setItpTrAbstr=0;
  Ddi_BddAndAcc(b,cone);
  Ddi_BddSetAig(auxTr);
  if (itpTrAbstr!=NULL) {
    if (!Ddi_AigSatAnd(itpTrAbstr,b,0)) {
      Ddi_Free(auxTr);
      auxTr = Ddi_BddDup(itpTrAbstr);
      doRefine = 0;
      setItpTrAbstr=1;
      Ddi_Free(itpMgr->itpTrAbstr);
    }
    else {
      Ddi_BddAndAcc(auxTr,itpTrAbstr);
      Ddi_Free(itpMgr->itpTrAbstr);
    }
  }

  if (doRefine) {
    Ddi_Varset_t *psns = Ddi_VarsetUnion(itpMgr->psvars,itpMgr->nsvars);
    int sat;
    Ddi_Bdd_t *itp =
       Ddi_AigSatAndWithInterpolant(auxTr, b,
       psns, NULL, NULL, NULL, NULL, NULL, &sat, 0, 1, -1.0);
    if (itp!=NULL) {
      Ddi_Free(auxTr);
      auxTr = itp;
      setItpTrAbstr=1;
    }
    Ddi_Free(psns);
  }

  Ddi_Free(itpTravMgr->trAux);
  itpTravMgr->trAux = auxTr;
  if (setItpTrAbstr)
    itpMgr->itpTrAbstr = Ddi_BddDup(auxTr);
  Ddi_Free(b);
  return 1;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpTrAbstrWithItpRefineWithRings(
  Trav_ItpMgr_t * itpMgr,
  int first,
  int last
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Ddi_Bddarray_t * delta = itpMgr->delta;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  int size0 = 0;
  Ddi_Bdd_t *itp=NULL, *fromAndTr;
  Ddi_Bdd_t *invarPs=NULL, *invarNs=NULL;

  if (Ddi_BddarrayNum(itpMgr->fromRings)<3) return 0;
  Ddi_Bdd_t *invarConstr = Ddi_BddDup(itpMgr->invarConstr);
  if (first < 1) first = 1;
  if (last <= 0 || last>=Ddi_BddarrayNum(itpMgr->fromRings))
    last = Ddi_BddarrayNum(itpMgr->fromRings)-1;
  
  if (1) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    
    if (iv != NULL) {
      invarPs = Ddi_BddMakeLiteralAig(iv, 1);
      invarNs = Ddi_BddMakeLiteralAig(ivNs, 1);
      if (invarConstr==NULL) {
	invarConstr = Ddi_BddMakeConstAig(ddm, 1);
      }      
      Ddi_BddAndAcc(invarConstr, invarPs);
      Ddi_BddAndAcc(invarConstr, invarNs);
    }
  }


  fromAndTr = Ddi_BddRelMakeFromArray(delta, ns);
  Ddi_BddPartInsertLast(fromAndTr,invarConstr);
  Ddi_Bdd_t *reached = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *notReachedNs = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *b = Ddi_BddMakeConstAig(ddm, 0);
  for (int i=first; i<last; i++) {
    Ddi_Bdd_t *f_i = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings,i));
    Ddi_Bdd_t *f_next = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings,i+1));
    Ddi_Bdd_t *notTr = Ddi_BddNot(f_next);
    Ddi_BddSubstVarsAcc(f_i,ns,ps);
    Ddi_BddAndAcc(notTr,f_i);
    Ddi_BddOrAcc(reached,f_i);
    Ddi_BddOrAcc(notReachedNs,b);
    if (1) {
      int sat = Ddi_AigSatAnd(fromAndTr,notTr,0);
      Pdtutil_Assert(!sat,"pr,oblem in itpTrAbstr");
    }
    Ddi_BddOrAcc(b,notTr);
    Ddi_Free(f_i);
    Ddi_Free(notTr);
    Ddi_Free(f_next);
  }

  if (0) {
    int sat = Ddi_AigSatAnd(fromAndTr,b,NULL);
    Pdtutil_Assert(!sat,"problem in itpTrAbstr");
  }
  
  Ddi_Bdd_t *itpTrAbstr = itpMgr->itpTrAbstr;
  int doRefine=1, setItpTrAbstr=0;
  if (itpTrAbstr!=NULL) {
    size0 = Ddi_BddSize(itpTrAbstr);
    if (!Ddi_AigSatAnd(itpTrAbstr,b,NULL)) {
      doRefine = 0;
    }
    else {
      Ddi_BddNotAcc(itpTrAbstr);
      Ddi_BddOrAcc(b,itpTrAbstr);
      Ddi_Free(itpMgr->itpTrAbstr);
    }
  }

  if (doRefine) {
    Ddi_Varset_t *psns = Ddi_VarsetUnion(itpMgr->psvars,itpMgr->nsvars);
    int sat;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nrecomputing abstrTR [%d-%d]: %d\n",
	     first, last, size0);
    }
    Ddi_Bdd_t *itp =
       Ddi_AigSatAndWithInterpolant(fromAndTr, b,
       psns, NULL, NULL, NULL, NULL, NULL, &sat, 0, 1, -1.0);
    Ddi_AigOptByMonotoneCoreAcc(itp,fromAndTr,NULL,1,-1.0);
    Pdtutil_Assert (itp!=NULL, "NULL itp");
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("recomputed abstrTR [%d-%d]: %d -> %d\n",
	     first, last, size0, Ddi_BddSize(itp));
    }

    itpMgr->itpTrAbstr = itp;
    Ddi_Free(psns);
  }

  Ddi_Free(b);
  Ddi_Free(reached);
  Ddi_Free(notReachedNs);
  Ddi_Free(fromAndTr);
  Ddi_Free(invarConstr);

  return 1;
}

/**Function*******************************************************************
  Synopsis    []
  Descrip
tion []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpImgTrSetup(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * cone
)
{
  Trav_Mgr_t *travMgr = itpTravMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;
  int dynAbstr = Trav_MgrReadDynAbstr(travMgr);

  if (dynAbstr > 3 && !itpTravMgr->settings.computeRestartFrom) {
    if ((itpTravMgr->restartFrom != NULL) &&
      (itpTravMgr->stats.fwdUnrollSize >= 0) &&
      (Ddi_BddSize(itpTravMgr->restartFrom) +
        itpTravMgr->stats.fwdUnrollSize >
        Ddi_BddSize(itpTravMgr->from) + itpMgr->stats.deltaSize)) {
      itpTravMgr->settings.computeRestartFrom = 1;
    }
  }

  if (itpTravMgr->settings.computeRestartFrom) {
    char suffix[20];

    sprintf(suffix, "%d", itpTravMgr->stats.step + 1);
    Ddi_Free(itpTravMgr->restartFrom);
    itpTravMgr->restartFrom = Ddi_BddDup(itpTravMgr->from);
    Ddi_Free(itpTravMgr->fwdUnroll);
    itpTravMgr->fwdUnroll = Ddi_BddarrayDup(itpMgr->delta);
    Ddi_Vararray_t *newPiVars =
      Ddi_VararrayMakeNewVars(itpMgr->pi, "PDT_ITP_FWDUNR_PI", suffix, 1);
    Ddi_Bddarray_t *newPiLits = Ddi_BddarrayMakeLiteralsAig(newPiVars, 1);

    Ddi_AigarrayComposeAcc(itpTravMgr->fwdUnroll, itpMgr->pi, newPiLits);
    Ddi_Free(newPiVars);
    Ddi_Free(newPiLits);
    itpTravMgr->settings.computeRestartFrom = 0;
  } else {
    if (itpTravMgr->settings.useInitStub) {
      itpTravMgr->trArray = Ddi_BddarrayDup(itpMgr->stubTrArray);
      itpTravMgr->trAux = Ddi_BddDup(itpMgr->initStubState);
    } else {
      itpTravMgr->trArray = Ddi_BddarrayDup(itpMgr->trArray);
      itpTravMgr->trAux = Ddi_BddDup(itpMgr->trAux);
    }
    if (itpTravMgr->settings.useInvarFull && itpMgr->invarConstrForTr != NULL) {
      Ddi_BddAndAcc(itpTravMgr->trAux, itpMgr->invarConstrForTr);
    }
    Ddi_BddSetAig(itpTravMgr->trAux);
  }

  if (cone != NULL) {
    Ddi_Vararray_t *coneSupp = Ddi_BddSuppVararray(cone);

    Ddi_VararrayIntersectAcc(coneSupp, itpMgr->ns);
    itpFilterFreeNsVars(itpTravMgr, coneSupp);
    Ddi_Free(coneSupp);
    //    itpTrAbstrWithItp(itpTravMgr,cone);
  }
#if 0                           // disabled now
  /* handle BDDs */
  if (itpMgr->trBdd != NULL && (itpTravMgr->settings.itpExact ||
      Ddi_BddSize(from) < 50000)
    && !itpMgr->trBddIsAig) {
    Ddi_Bdd_t *toBdd = NULL;

    if (!itpTravMgr->settings.useInitStub) {
      if (itpTravMgr->settings.itpExact == 2) {
        int ii;
        int newSaveFrom = 0;

        if (saveFromBdd == NULL) {
          saveFromBdd = Ddi_BddDup(from);
          newSaveFrom = 1;
        }
        trBdd2 = Tr_TrDup(itpMgr->trBdd);
        if (itpTravMgr->settings.newConstrain &&
          itpTravMgr->constrainVars != NULL) {
          Ddi_Bddarray_t *cSL2 = Ddi_BddarrayDup(constrainSubstLits);

          for (ii = 0; ii < Ddi_BddarrayNum(cSL2); ii++) {
            Ddi_BddSetMono(Ddi_BddarrayRead(cSL2, ii));
          }
          Ddi_BddComposeAcc(Tr_TrBdd(trBdd2), itpTravMgr->constrainVars, cSL2);
          if (newSaveFrom) {
            Ddi_BddComposeAcc(saveFromBdd, itpTravMgr->constrainVars,
              itpTravMgr->constrainSubstLits);
          }
          Ddi_Free(cSL2);
        }
      } else {
        fromBdd = Ddi_BddMakeMono(from);
        if (Ddi_BddSize(fromBdd) < 2 * Ddi_BddSize(from)) {
          Ddi_Free(from);
          from = Ddi_BddMakeAig(fromBdd);
        }
        if (Ddi_BddSize(fromBdd) < 100000) {
          Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
          int thc = Ddi_MgrReadExistClustThresh(ddm);

          if (Ddi_MetaActive(ddm)) {
            Ddi_BddSetMeta(fromBdd);
            Tr_MgrSetImgAndExistTh(Tr_TrMgr(itpMgr->trBdd), -1);
          }
          Ddi_MgrSetOption(ddm, Pdt_DdiVerbosity_c, inum,
            Pdtutil_VerbLevelDevMax_c);
          Ddi_MgrSetExistClustThresh(ddm, -1);
          toBdd = Tr_ImgWithConstrain(itpMgr->trBdd, fromBdd, NULL);
          Ddi_MgrSetExistClustThresh(ddm, thc);
          Ddi_MgrSetOption(ddm, Pdt_DdiVerbosity_c, inum, verbosity);
          Ddi_BddSwapVarsAcc(toBdd, ps, ns);
          if (careBwdBdd != NULL) {
            toBddInCareBdd = Ddi_BddIncluded(toBdd, careBwdBdd);
          }
        }
        Ddi_Free(fromBdd);
      }
    } else {
      int i, th = 1000;
      Ddi_Bdd_t *toBddPart = Ddi_AigPartitionTop(trAux, 0);
      Ddi_Bddarray_t *toA = Ddi_BddarrayMakeFromBddPart(toBddPart);
      Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm, 0);
      Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm, 0);
      Ddi_Bddarray_t *toBddA =
        Ddi_AigarrayOptByBdd(toA, auxF, auxV, th, 0, -1, -1);
      toBdd = Ddi_BddMakePartConjFromArray(toBddA);
      for (i = 0; i < Ddi_BddarrayNum(auxF); i++) {
        Ddi_Bdd_t *auxRel = Ddi_BddMakeLiteral(Ddi_VararrayRead(auxV, i), 1);

        Ddi_BddXnorAcc(auxRel, Ddi_BddarrayRead(auxF, i));
        Ddi_BddPartInsertLast(toBdd, auxRel);
        Ddi_Free(auxRel);
      }
      Ddi_BddSetClustered(toBdd, 5000);
      for (i = 0; i < Ddi_BddPartNum(toBddPart); i++) {
        Ddi_BddSetMono(Ddi_BddPartRead(toBddPart, i));
      }
      Ddi_BddExistProjectAcc(toBdd, nsvars);
      Ddi_Free(auxF);
      Ddi_Free(auxV);
      Ddi_Free(toBddPart);
      Ddi_Free(toA);
      Ddi_Free(toBddA);
    }
    if (toBdd != NULL) {
      if (Ddi_BddSize(toBdd) > 100000) {
        Ddi_Free(toBdd);
      }
      fromBdd = toBdd;
    }
  }

  if (0 && from != NULL && fromBdd == NULL) {
    /* check tr components fed by from variables */
    int i, n = Ddi_VararrayNum(ps), used = 0, skip, again = 0;
    int *partUsed = Pdtutil_Alloc(int,
      n
    );
    Ddi_Varset_t *fSupp = Ddi_BddSupp(from);
    Ddi_Bdd_t *chk = Ddi_BddAnd(from, kCone);

    for (i = 0; i < n; i++) {
      partUsed[i] = 0;
    }
    again = 1;
    Ddi_Free(trAux);
    trAux = Ddi_BddMakeConstAig(ddm, 1);
    for (i = 0; i < n; i++) {
      Ddi_Bdd_t *t_i = Ddi_BddarrayRead(trArray, i);
      Ddi_Varset_t *s_i = Ddi_BddSupp(t_i);

      Ddi_VarsetIntersectAcc(s_i, fSupp);
      if (!Ddi_VarsetIsVoid(s_i)) {
        Ddi_BddAndAcc(trAux, t_i);
        Ddi_BddAndAcc(chk, t_i);
        used++;
        partUsed[i] = 1;
        again = 0 && Ddi_AigSat(chk);
      }
      Ddi_Free(s_i);
    }
    if (again) {
      for (i = 0; i < n && again; i++) {
        if (!partUsed[i]) {
          Ddi_Bdd_t *t_i = Ddi_BddarrayRead(trArray, i);

          Ddi_BddAndAcc(from, t_i);
          Ddi_BddAndAcc(chk, t_i);
          used++;
          partUsed[i] = 1;
          again = Ddi_AigSat(chk);
        }
      }
    }
    Ddi_Free(chk);
    Ddi_Free(fSupp);
    Pdtutil_Free(partUsed);
    skip = n - used;
    if (skip > 0) {
      printf("skipping %d trpartitions\n", skip);
    }
  }
#endif

  if ( /* fromBdd!=NULL && */ itpTravMgr->settings.useInitStub) {
    itpTravMgr->settings.useInitStub = 0;
  }

  if (itpTravMgr->from == NULL) {
    Pdtutil_Assert(itpTravMgr->to != NULL, "NULL to");
    itpTravMgr->from = Ddi_BddDup(itpTravMgr->to);
  } else if (itpTravMgr->fromBdd != NULL) {
    Ddi_Free(itpTravMgr->from);
    itpTravMgr->to = Ddi_BddMakeAig(itpTravMgr->fromBdd);
    itpTravMgr->from = Ddi_BddDup(itpTravMgr->to);
    Ddi_Free(itpTravMgr->fromBdd);
  } else if (Ddi_BddIsPartConj(itpTravMgr->from)) {
    Ddi_Bdd_t *newFrom = Ddi_BddDup(itpTravMgr->trAux);

    Pdtutil_Assert(Ddi_BddPartNum(itpTravMgr->from) == 2,
      "wrong num of partitions");
    Ddi_AigConstrainCubeAcc(newFrom, Ddi_BddPartRead(itpTravMgr->from, 1));
    Ddi_BddAndAcc(newFrom, Ddi_BddPartRead(itpTravMgr->from, 0));
    Ddi_Free(itpTravMgr->from);
    itpTravMgr->from = newFrom;
  } else if (itpTravMgr->settings.enConcurTr && itpMgr->concurTr) {
    /* img by chaining */
    char name[1000];
    int i;
    Ddi_Bdd_t *cLit;
    Ddi_Bddarray_t *cSubstPs = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_Bddarray_t *cSubst = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_Vararray_t *cVarNs = Ddi_VararrayAlloc(ddm, 0);
    Ddi_Vararray_t *cVarPs = Ddi_VararrayAlloc(ddm, 0);
    Ddi_Var_t *cV = NULL;

    sprintf(name, "Pdtrav_ConcurAuxVar");
    cV = Ddi_VarFromName(ddm, name);
    if (cV == NULL) {
      cV = Ddi_VarNew(ddm);
      Ddi_VarAttachName(cV, name);
    }
    cLit = Ddi_BddMakeLiteralAig(cV, 1);
    Ddi_BddarrayWrite(cSubst, 0, cLit);
    Ddi_Free(cLit);
    for (i = 0; i < Ddi_BddPartNum(itpMgr->concurTr); i++) {
      Ddi_Bdd_t *t_i = Ddi_BddPartRead(itpMgr->concurTr, i);

      Ddi_BddAndAcc(itpTravMgr->from, t_i);
      Ddi_VararrayWrite(cVarPs, 0, Ddi_VararrayRead(itpMgr->ps, i));
      Ddi_VararrayWrite(cVarNs, 0, Ddi_VararrayRead(itpMgr->ns, i));
      cLit = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(itpMgr->ps, i), 1);
      Ddi_BddarrayWrite(cSubstPs, 0, cLit);
      Ddi_BddComposeAcc(itpTravMgr->from, cVarPs, cSubst);
      Ddi_BddComposeAcc(itpTravMgr->from, cVarNs, cSubstPs);
      Ddi_BddExistProjectAcc(itpTravMgr->from, itpMgr->psvars);
      Ddi_Free(cLit);
    }
    Ddi_Free(cVarPs);
    Ddi_Free(cVarNs);
    Ddi_Free(cSubst);
    Ddi_Free(cSubstPs);
    Ddi_BddComposeAcc(itpTravMgr->from, itpMgr->ps, itpMgr->nsLit);
    itpTravMgr->to = Ddi_BddDup(itpTravMgr->from);
  } else {
    if (itpTravMgr->settings.newConstrain) {
      Ddi_Bdd_t *eq;
      Ddi_Bdd_t *newFrom = Ddi_BddDup(itpTravMgr->trAux);

      if (itpTravMgr->settings.implAbstr > 1 &&
        itpTravMgr->constrainVars != NULL) {
        Ddi_BddComposeAcc(itpTravMgr->from, itpTravMgr->constrainVars,
          itpTravMgr->constrainSubstLits);
        Ddi_BddComposeAcc(itpTravMgr->from0, itpTravMgr->constrainVars,
          itpTravMgr->constrainSubstLits);
        Ddi_BddComposeAcc(newFrom, itpTravMgr->constrainVars,
          itpTravMgr->constrainSubstLits);
        Ddi_AigarrayComposeAcc(itpTravMgr->trArray,
          itpTravMgr->constrainVars, itpTravMgr->constrainSubstLits);
      }
      Ddi_AigConstrainOptAcc(newFrom, itpTravMgr->from,
        itpMgr->psvars, NULL, NULL, 2);
      Ddi_Free(itpTravMgr->from);
      itpTravMgr->from = newFrom;
    } else if (Ddi_BddIsZero(itpTravMgr->from)) {
      // do nothing
    } else if (1) {
      /* this is the normal case: TR|from done */
      Ddi_Bdd_t *newFrom = Ddi_BddDup(itpTravMgr->trAux);

      Ddi_AigConstrainOptAcc(newFrom, itpTravMgr->from,
        itpMgr->psvars, NULL, NULL, 2);
      Ddi_Free(itpTravMgr->from);
      itpTravMgr->from = newFrom;
    } else {
      /* this is the normal case: from*TR done */
      Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->trAux);
    }
  }
  //  substStalledLatches(itpMgr,itpTravMgr->from);
  
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
testCones(
  Trav_ItpMgr_t *itpMgr,
  Ddi_Bdd_t *cone,
  int maxk
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cone);
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  int k, i, niter=4;
  Ddi_Bdd_t *coneK, *coneK0, *cex;
  Ddi_Vararray_t *pi = itpMgr->pi;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;

  coneK0 = Ddi_BddMakeConstAig(ddm, 0);
  for (k=10; k<maxk; k++) {
    coneK = Ddi_BddDup(cone);
    growConeBwd(itpMgr, coneK, k+1, 1, NULL, NULL, 0 , -1, 1);
    long time0 = util_cpu_time();
    Ddi_Bdd_t *cex;
    Ddi_Bdd_t *coneK1 = Ddi_BddDiff(coneK,coneK0);
    if ((cex = Ddi_AigSatWithCex(coneK1))!=NULL) {
       long time1 = util_cpu_time();
       Ddi_Bdd_t *cone2 = Ddi_BddDup(coneK1);
       fprintf(tMgrO(travMgr),
	      "\ncone[%d] (size %d) SAT in %s \n", k, Ddi_BddSize(coneK1),
	      util_print_time(time1 - time0));

       for (i=0; i<niter && cex!=NULL; i++) {
	 Ddi_Bdd_t *core = Ddi_BddDup(coneK1);
	 Ddi_AigConstrainCubeAcc(core, cex);
	 Ddi_BddDiffAcc(cone2,core);

	 fprintf(tMgrO(travMgr),
		 "iter %d -- core %d - new cone: %d ", i, 
		 Ddi_BddSize(core), Ddi_BddSize(cone2));
	 time0 = util_cpu_time();
	 cex = Ddi_AigSatWithCex(cone2);
	 time1 = util_cpu_time();
	 if (cex!=NULL) {
	   fprintf(tMgrO(travMgr), "SAT in %s \n",
	      util_print_time(time1 - time0));
	 }
	 Ddi_Free(core);
       }

       Ddi_Free(cone2);
       Ddi_Free(cex);
    }
    else {
      long time1 = util_cpu_time();
      fprintf(tMgrO(travMgr),
	      "\ncone[%d] (size %d) UNSAT in %s \n", k, Ddi_BddSize(coneK),
	      util_print_time(time1 - time0));
    }

     Ddi_Free(coneK0);
     Ddi_Free(coneK1);
     coneK0 = coneK;
     //     Ddi_Free(coneK);
  }
  Ddi_Free(coneK0);
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
itpImgConeSubsetTopAcc(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * cone,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t *coneCare,
  int step
)
{
  Trav_Mgr_t *travMgr = itpTravMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *ps = itpMgr->ps;
  int size0 = Ddi_BddSize(cone);
  int doPiConstr = 0;
  int sizeEnable = size0 > itpMgr->igr.coneSubsetSizeTh;
  
  if (kConeRings==NULL) return cone;

  if (itpTravMgr->coneSubsetTop == NULL && sizeEnable && 
      itpTravMgr->conePiConstr == NULL) {
    int np = Ddi_BddPartNum(kConeRings);
    int start_i = np - 1;
    int end_i = step;
    int boundK = (growCone > 2) ? 1 : 0;
    int nTfCone = Ddi_BddReadMark(cone); 
    int constr_i = nTfCone * (1.0-itpMgr->igr.coneSubsetPiRatio);
    int useSplitUnrollConstr = 1;
    int useNewVars = 1;
    int split_i;

    Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm,1);
    Ddi_Bdd_t *cex, *cexSplit;
    Ddi_Bdd_t *coneTop, *coneSplit;

    Pdtutil_Assert(step<np,"cone step too big");

    if (coneCare != NULL) {
      Ddi_BddAndAcc(myCare, coneCare);
    }
    if (itpTravMgr->settings.storeRings &&
        (itpMgr->nRings > step)) {
      Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings,
                                            step);
      Ddi_BddAndAcc(myCare, oldFrom);
    }
    if (itpTravMgr->constrainVars != NULL) {
      Ddi_BddComposeAcc(myCare, itpTravMgr->constrainVars,
                        itpTravMgr->constrainSubstLits);
    }
    cex = Ddi_AigSatAndWithCexAndAbort(cone,myCare,
                                       NULL,NULL,-1,NULL);
    if (cex==NULL) {
      Ddi_Free(myCare);
      return (cone);
    }
    // now work on cone top

    if (constr_i < 1) constr_i = 1;
    split_i = end_i + constr_i;

    coneSplit = Ddi_BddDup(Ddi_BddPartRead(kConeRings, np - 1));

    growConeBwdDecomp(itpMgr, coneSplit, start_i, end_i, split_i, 
                      useSplitUnrollConstr, useNewVars, NULL,
                      itpMgr->initStub, growCone != 1 ? 2 : 0 /*useRingConstr */ ,
                      -1 /*andWithRing_i*/,
                      growCone > 2 ? 1 : 0 /*boundK */);

    Pdtutil_Assert(Ddi_BddReadComposeF(coneSplit)!=NULL,
		   "split cone needed");

    Ddi_Bddarray_t *splitU = Ddi_BddReadComposeSubst(coneSplit);
    Ddi_Vararray_t *splitV = Ddi_BddReadComposeVars(coneSplit);
    Ddi_Vararray_t *splitRefV = Ddi_BddReadComposeRefVars(coneSplit);
    Ddi_Bdd_t *splitConstr = Ddi_BddReadComposeConstr(coneSplit);
    Ddi_Bdd_t *unrollRel = Ddi_BddRelMakeFromArray(splitU,splitV);
    Ddi_Bdd_t *unrollRel2 = Ddi_BddRelMakeFromArray(splitU,splitV);
    Ddi_BddAndAcc(unrollRel,splitConstr);
    Ddi_AigConstrainCubeAcc(unrollRel,cex);
    Ddi_Varset_t *sm = Ddi_VarsetMakeFromArray(itpMgr->ns);
    Ddi_AigCubeExistAcc(cex,sm);
    Ddi_Free(sm);
    
    coneTop = Ddi_BddDup(Ddi_BddReadComposeF(coneSplit));
    Ddi_AigConstrainCubeAcc(coneTop,cex);

#if 1
    cexSplit = Ddi_BddMakeConstAig(ddm,1);
#else 
    cexSplit = Ddi_AigSatAndWithCexAndAbort(unrollRel,coneTop,
                                       NULL,NULL,-1,NULL);

    Pdtutil_Assert(cexSplit!=NULL,"problem with expected cex");
    
    Ddi_BddSubstVarsAcc(cexSplit, splitV, splitRefV);
    int chk=1;
    if (chk) {
      Ddi_Vararray_t *suppCex = Ddi_BddSuppVararray(cexSplit);
      Ddi_VararrayDiffAcc(suppCex,ns);
      Pdtutil_Assert(Ddi_VararrayNum(suppCex)==0,"wrong cex supp");
      Ddi_Free(suppCex);
    }
#endif
    Ddi_Free(coneTop);
    
    coneTop = Ddi_BddDup(Ddi_BddPartRead(kConeRings, np - 1));
    Ddi_Bdd_t *target = Ddi_BddDup(coneTop);
    end_i += constr_i; // just keep top;
    growConeBwdSubsetByTarget(itpMgr, coneTop, start_i, end_i,
                 NULL,NULL,NULL,0,
                 0 /*disable useRingConstr */ ,
		 -1, boundK);
    if (1) {
      Ddi_BddSubstVarsAcc(myCare, ns, ps);
      Ddi_BddSubstVarsAcc(unrollRel2, ns, ps);
      Ddi_BddSubstVarsAcc(unrollRel2, splitV, splitRefV);
      Ddi_Bdd_t *cex3 = 
          Ddi_AigSatAndWithCexAndAbort(unrollRel2,coneTop,
                                       myCare,NULL,-1,NULL);
      Ddi_Varset_t *sm = Ddi_VarsetMakeFromArray(itpMgr->ps);
      Ddi_AigCubeExistAcc(cex3,sm);
      Ddi_Free(sm);
      Ddi_DataCopy (cex,cex3);
      sm = Ddi_VarsetMakeFromArray(itpMgr->ns);
      Ddi_AigCubeExistAcc(cex,sm);
      Ddi_AigCubeExistProjectAcc(cex3,sm);
      Ddi_Free(sm);
      Ddi_DataCopy (cexSplit,cex3);
      Ddi_Free(cex3);
    }

    Ddi_AigConstrainCubeAcc(coneTop,cex);
    int extendCex = 0;
    if (extendCex) {
      Ddi_Varset_t *sm = Ddi_VarsetMakeFromArray(itpMgr->ns);
      Ddi_Bdd_t *cex2;
      cex2 = Ddi_AigSatAndWithCexAndAbort(coneTop,cexSplit,
                                       NULL,NULL,-1,NULL);
      Ddi_AigCubeExistAcc(cex2,sm);
      Ddi_Free(sm);
      Ddi_AigConstrainCubeAcc(coneTop,cex2);
      Ddi_Free(cex2);
    }
    //    ddiAbcOptAcc(coneTop, -1.0);
    //    Ddi_AigSubsetWithCubeAcc (coneTop,cexSplit,0.95);
    if (0 && boundK) {
      Ddi_BddOrAcc(coneTop,target);
    }
    if (doPiConstr) {
      itpTravMgr->conePiConstr = cex;
      Ddi_Free(coneTop);
    }
    else {
      itpTravMgr->coneSubsetTop = coneTop;
      Ddi_Free(cex);
    }
    itpTravMgr->stats.conePiConstrTf_i = constr_i;
    itpTravMgr->stats.conePiConstrStep = step;
    itpMgr->stats.igrPiSubsetK = np;
    itpMgr->stats.igrPiSubsetRing = step;

    Ddi_Free(coneSplit);
    Ddi_Free(myCare);
    Ddi_Free(unrollRel);
    Ddi_Free(unrollRel2);
    Ddi_Free(target);
    Ddi_Free(cexSplit);
  }

  if (itpTravMgr->coneSubsetTop != NULL) {
    int np = Ddi_BddPartNum(kConeRings);
    int start_i = np - 1;
    int end_i = step;
    int boundK = (growCone > 2) ? 1 : 0;
    int nTfCone;
    Ddi_Bdd_t *coneNew = Ddi_BddDup(itpTravMgr->coneSubsetTop);
    Ddi_Bdd_t *cone0 = Ddi_BddPartRead(kConeRings, np - 1);
    int mark0 = Ddi_BddReadMark(cone0);
    
    nTfCone = Ddi_BddReadMark(coneNew);
    Pdtutil_Assert(nTfCone+itpTravMgr->stats.conePiConstrTf_i==
                   (start_i-end_i+1-mark0),
                   "problem with top cone");
    start_i = start_i - nTfCone;
    growConeBwdSubsetByTarget(itpMgr, coneNew, start_i, end_i,
                 NULL,NULL,NULL,0,
                 growCone != 1 ? 2 : 0 /*useRingConstr */ ,
		 -1, boundK);
    if (0&&boundK) {
      for (start_i--; start_i>=end_i; start_i--) {
        Ddi_Bdd_t *cone_i = Ddi_BddDup(itpTravMgr->coneSubsetTop);
        growConeBwdSubsetByTarget(itpMgr, cone_i, start_i, end_i,
                 NULL,NULL,NULL,0,
                 growCone != 1 ? 2 : 0 /*useRingConstr */ ,
		 -1, 0);
        Ddi_BddOrAcc(coneNew,cone_i);
        Ddi_Free(cone_i);
      }
    }
    Ddi_DataCopy(cone,coneNew);
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("CONE subset by PI constr: %d -> %d\n", size0,
             Ddi_BddSize(cone));
    }
    Ddi_Free(coneNew);
  }
  else if (itpTravMgr->conePiConstr != NULL) {
    Ddi_Vararray_t **tfPiVars = itpMgr->timeFrames->PiVars;
    int tfPiNum =  itpMgr->timeFrames->Num;
    int nTfCone = Ddi_BddReadMark(cone); 
    int size0 = Ddi_BddSize(cone);
    Ddi_Bdd_t *smCex = Ddi_BddDup(itpTravMgr->conePiConstr);
    Pdtutil_Assert(nTfCone<=tfPiNum,"time frame var problem");
    if (tfPiVars!=NULL && tfPiNum>0) {
      int j;
      Ddi_Varset_t *prjTot = Ddi_VarsetVoid(ddm);
      int constr_i = itpTravMgr->stats.conePiConstrTf_i;
      Ddi_VarsetSetArray(prjTot);
      //	  constr_i -= (step-itpTravMgr->stats.conePiConstrStep)/8;
      for (j=constr_i; j<nTfCone; j++) {
        Ddi_Varset_t *prjPi = Ddi_VarsetMakeFromArray(tfPiVars[j]);
        Ddi_VarsetUnionAcc(prjTot,prjPi);
        Ddi_Free(prjPi);
      }
      Ddi_BddCubeExistProjectAcc(smCex,prjTot);
      Ddi_Free(prjTot);
    }
    Ddi_AigConstrainCubeAcc(cone,smCex);
    Ddi_Free(smCex);
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("CONE subset by PI constr: %d -> %d\n", size0,
             Ddi_BddSize(cone));
    }
  }
  return cone;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
optTrConstr(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t *trConstrA0,
  int nFrames
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Bdd_t *invarConstr = NULL; 
  Ddi_Bdd_t *tr;
  Ddi_Bddarray_t *trConstrA;
  int i;
  int tryNnfExist = 1;

  if (tryNnfExist) {
    Ddi_Vararray_t *aV0 = Ddi_VararrayAlloc(ddm,0);
    Ddi_Vararray_t *aV1 = Ddi_VararrayAlloc(ddm,0);
    Ddi_Vararray_t *totvars = Ddi_BddarraySuppVararray(trConstrA0);
    Ddi_Vararray_t *vars = Ddi_VararrayAlloc(ddm,0);
    Ddi_Bddarray_t *tc2 = Ddi_AigarrayNnf (trConstrA0,
					       NULL,NULL,
					       NULL,vars,
					       aV0,aV1);
    // remove one phase
    for (int i=Ddi_BddarrayNum(tc2)-1;i>=0; i-=2)
      Ddi_BddarrayRemove(tc2,i);
    Ddi_Vararray_t *supp = Ddi_BddarraySuppVararray(tc2);
    Ddi_VararrayWriteMark (supp, 1);
    Ddi_VararrayWriteMark (ns, 1);
    int mon0Ps = 0, mon1Ps = 0, mon0Ns = 0, mon1Ns = 0, ps01 = 0, ns01=0;
    Ddi_Bdd_t *ps0 = Ddi_BddMakeConstAig(ddm, 1);
    Ddi_Bdd_t *ps1 = Ddi_BddMakeConstAig(ddm, 1);
    Ddi_Bdd_t *ns0 = Ddi_BddMakeConstAig(ddm, 1);
    Ddi_Bdd_t *ns1 = Ddi_BddMakeConstAig(ddm, 1);
    for (int i=0; i<Ddi_VararrayNum(vars); i++) {
      Ddi_Var_t *v_i = Ddi_VararrayRead(vars,i);
      Ddi_Var_t *a0_i = Ddi_VararrayRead(aV0,i);
      Ddi_Var_t *a1_i = Ddi_VararrayRead(aV1,i);
      int m0 = Ddi_VarReadMark(a0_i);
      int m1 = Ddi_VarReadMark(a1_i);
      int mV = Ddi_VarReadMark(v_i);
      if (m0==m1) {
        if (mV) ns01++;
        else ps01++;
        continue;
      }
      if (m0>0) {
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v_i, 0);
        if (mV) { mon0Ns++; Ddi_BddAndAcc(ns0,lit); }
        else { mon0Ps++; Ddi_BddAndAcc(ps0,lit); }
        Ddi_Free(lit);
      }
      else {
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v_i, 1);
        if (mV) { mon1Ns++; Ddi_BddAndAcc(ns1,lit); }
        else { mon1Ps++; Ddi_BddAndAcc(ps1,lit); }
        Ddi_Free(lit);
      }
    }
    Ddi_VararrayWriteMark (supp, 0);
    Ddi_VararrayWriteMark (ns, 0);
    Ddi_Free(supp);
    printf("NNF TR MONOTONE vars: PS: %d->0, %d->1 (01: %d), NS: %d->0, %d->1 (01: %d)\n",
           mon0Ps, mon1Ps, ps01, mon0Ns, mon1Ns, ns01);
    //    Ddi_BddarrayVararrayCofactorAcc(d2, aV0, 1);
    //Ddi_BddarrayVararrayCofactorAcc(d2, aV1, 1);
    //    Ddi_Bdd_t *aux = Ddi_BddMakePartConjFromArray(d2);
    //Ddi_BddSubstVarsAcc(aux, itpMgr->ps, itpMgr->ns);
    int s0 = Ddi_BddarraySize(trConstrA0);
    int doQuantify = 0;
    if (doQuantify) {
      Ddi_AigarrayConstrainCubeAcc(trConstrA0,ns0);
      printf ("quantifying %d nsvars - size: %d -> %d\n",
              mon0Ns, s0, Ddi_BddarraySize(trConstrA0));
      Ddi_AigarrayConstrainCubeAcc(trConstrA0,ns1);
      printf ("quantifying %d nsvars - size: %d -> %d\n",
              mon1Ns, s0, Ddi_BddarraySize(trConstrA0));
      int s1 = Ddi_BddarraySize(trConstrA0);
    }
    Ddi_Free(totvars);
    Ddi_Free(vars);
    Ddi_Free(aV0);
    Ddi_Free(aV1);
    Ddi_Free(tc2);
    Ddi_Free(ps0);
    Ddi_Free(ps1);
    Ddi_Free(ns0);
    Ddi_Free(ns1);
  }
  
  Ddi_Bdd_t *invarPs = NULL;
  Ddi_Bdd_t *invarNs = NULL;
  if (1) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    Ddi_Var_t *ipNs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
    invarConstr = Ddi_BddDup(itpMgr->invarConstr);  
    Pdtutil_Assert (iv != NULL,"missing invar var");
    invarPs = Ddi_BddMakeLiteralAig(iv, 1);
    invarNs = Ddi_BddMakeLiteralAig(ivNs, 1);
    if (invarConstr==NULL) {
      invarConstr = Ddi_BddMakeConstAig(ddm, 1);
    }      
    Ddi_BddAndAcc(invarConstr, invarPs);
    Ddi_BddAndAcc(invarConstr, invarNs);
  }

  tr = genComposedTr(itpMgr,nFrames,0,NULL);
  Ddi_AigAndCubeAcc(tr,invarPs);
  Ddi_AigAndCubeAcc(tr,invarNs);
  //  Ddi_AigConstrainCubeAcc(tr,invarConstr);

  trConstrA = Ddi_BddarrayAlloc(ddm,0);

  int doSccReduction = 0;
  Ddi_Varset_t *noSccVars = NULL;
  if (doSccReduction) {
    Ddi_SccMgr_t *sccMgr = Ddi_FsmSccTarjan(itpMgr->delta, NULL, itpMgr->ps);
    int maxSccBit = Ddi_GetSccBitWithMaxLatches (sccMgr);
    Ddi_Vararray_t *sccPs = Ddi_GetSccLatches (sccMgr, ps, maxSccBit);
    Ddi_Vararray_t *sccNs = Ddi_VararraySubstVars(sccPs,ps,ns);
    // Ddi_Vararray_t *aux = Ddi_VararrayUnion(ps,ns);
    Ddi_Vararray_t *aux = Ddi_VararrayDup(ns);
    Ddi_VararrayDiffAcc(aux,sccPs);
    Ddi_VararrayDiffAcc(aux,sccNs);
    noSccVars = Ddi_VarsetMakeFromArray(aux);
    Ddi_SccMgrFree(sccMgr);
    Ddi_Free(aux);
    Ddi_Free(sccPs);
    Ddi_Free(sccNs);
  }
  int doCoiReduction = 0;
  if (doCoiReduction) {
    int iProp = Ddi_BddarrayNum(itpMgr->delta)-1;
    Ddi_Bdd_t *deltaProp = Ddi_BddarrayRead(itpMgr->delta,iProp); 
    Ddi_Vararray_t *sccPs = Ddi_BddSuppVararray(deltaProp);
    Ddi_Vararray_t *sccNs = Ddi_VararraySubstVars(sccPs,ps,ns);
    // Ddi_Vararray_t *aux = Ddi_VararrayUnion(ps,ns);
    Ddi_Vararray_t *aux = Ddi_VararrayDup(ns);
    Ddi_VararrayDiffAcc(aux,sccPs);
    Ddi_VararrayDiffAcc(aux,sccNs);
    noSccVars = Ddi_VarsetMakeFromArray(aux);
    Ddi_Free(aux);
    Ddi_Free(sccPs);
    Ddi_Free(sccNs);
  }
  
  Ddi_Varset_t *globalVars = NULL;
  for (i=0; i<Ddi_BddarrayNum(trConstrA0); i++) {
    Ddi_Bdd_t *itp_i = Ddi_BddDup(Ddi_BddarrayRead(trConstrA0, i));
    if (noSccVars!=NULL) {
      globalVars = Ddi_BddSupp(itp_i);
      int s0 = Ddi_VarsetNum(globalVars);
      Ddi_VarsetDiffAcc(globalVars,noSccVars);
      //      Ddi_BddExistAcc(itp_i,noSccVars);
      //DdiAigExistNnfAcc(itp_i, noSccVars, NULL);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("Projected tr_o from %d to %d vars\n", s0, Ddi_VarsetNum(globalVars));
      }
    }
    int doItp2 = 2;
    while (doItp2-- > 0) {
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nAbstrRef - strengthening by ITP\n\n");
      }
      Ddi_BddNotAcc(itp_i);
      int sat1;
      Ddi_Bdd_t *itp_i1 = Ddi_AigSat22AndWithInterpolant(NULL,itp_i,
                                                       tr, NULL,
                                                       globalVars, NULL, 0, NULL, NULL, NULL,
                                                       &sat1, 0, 1, 0, -1.0);
      Pdtutil_Assert(!sat1,"sat when computing ITP");
      if (Ddi_BddSize(itp_i1) > Ddi_BddSize(itp_i)) doItp2 = 0;
      if (Ddi_BddSize(itp_i1) < Ddi_BddSize(itp_i)*1.2) {
        Ddi_DataCopy(itp_i,itp_i1);
      }
      Ddi_BddNotAcc(itp_i);
      Ddi_Free(itp_i1);
    }
  
    int doOpt = 1;
    if (doOpt) {
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nAbstrRef - strengthening by NNF\n\n");
      }
      Ddi_AigOptByMonotoneCoreAcc(itp_i,tr,NULL,1,-1.0);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\n");
      }
    }
    if (!Ddi_BddIsOne(itp_i))  {
      Ddi_BddarrayInsertLast(trConstrA,itp_i);
    }
    Ddi_Free(itp_i);
  }
  Ddi_AigarrayConstrainCubeAcc(trConstrA,invarConstr);

  //  Ddi_BddarrayCofactorAcc(trConstrA, pvarPs, 1);


  Ddi_Free(invarPs);
  Ddi_Free(invarNs);
  Ddi_Free(globalVars);
  Ddi_Free(noSccVars);
  Ddi_Free(invarConstr);
  Ddi_Free(tr);
    
  return trConstrA;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
optTrConstrForBmcCone(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t *trConstrA,
  int nFrames,
  int doItp
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Bdd_t *invarConstr = NULL; 
  Ddi_Bdd_t *invarConstrCube = NULL; 
  Ddi_Bdd_t *tr, *trConstr, *trConstrOpt;
  Ddi_Bddarray_t *trConstrOptA;
  int i;
  int doBwdRing = 0;
  
  Ddi_Bdd_t *invarPs = NULL;
  Ddi_Bdd_t *invarNs = NULL;
  if (1) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    Ddi_Var_t *ipNs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
    invarConstr = Ddi_BddDup(itpMgr->invarConstr);  
    Pdtutil_Assert (iv != NULL,"missing invar var");
    invarPs = Ddi_BddMakeLiteralAig(iv, 1);
    invarNs = Ddi_BddMakeLiteralAig(ivNs, 1);
    invarConstrCube = Ddi_BddAnd(invarPs,invarNs);
    if (invarConstr==NULL) {
      invarConstr = Ddi_BddMakeConstAig(ddm, 1);
    }      
    Ddi_BddAndAcc(invarConstr, invarPs);
    Ddi_BddAndAcc(invarConstr, invarNs);
  }

  trConstr = Ddi_BddarrayRead(trConstrA,0);
  Ddi_Vararray_t *trSupp = Ddi_BddSuppVararray(trConstr);
  Ddi_Vararray_t *constrSupp = Ddi_BddSuppVararray(invarConstr);
  Ddi_VararrayIntersectAcc(trSupp,ns);
  Ddi_VararrayUnionAcc(trSupp,constrSupp);
  tr = genComposedTr(itpMgr,nFrames,0/*shift*/,trSupp);
  // tr = genComposedTr(itpMgr,nFrames,0/*shift*/,NULL);
  Ddi_Free(trSupp);
  Ddi_Free(constrSupp);
  Ddi_AigAndCubeAcc(tr,invarConstrCube); 
  
  trConstrOptA = Ddi_BddarrayAlloc(ddm,0);


  Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelUsrMed_c) {
    Ddi_Vararray_t *supp = Ddi_BddSuppVararray(trConstr);
    int n = Ddi_VararrayNum(supp);
    Ddi_Vararray_t *psupp = Ddi_VararrayIntersect(supp,ps);
    Ddi_VararrayIntersectAcc(supp,ns);
    fprintf(dMgrO(ddm), "TR constraint (size: %d) has %d->%d (%d) ps->ns (pi) vars\n",
            Ddi_BddSize(trConstr), Ddi_VararrayNum(psupp), Ddi_VararrayNum(supp),
            n-(Ddi_VararrayNum(psupp)+Ddi_VararrayNum(supp)));
    Ddi_Free(supp);      
    Ddi_Free(psupp);
  }

  Ddi_BddSetAig(tr);
  if (doItp) {
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nAbstrRef - strengthening trConstr by ITP\n\n");
    }
    Ddi_BddNotAcc(trConstr);
    int sat1;
    trConstrOpt = Ddi_AigSat22AndWithInterpolant(NULL,trConstr,
                                                       tr, NULL,
                                                       NULL, NULL, 0, NULL, NULL, NULL,
                                                       &sat1, 0, 1, 0, -1.0);
    Ddi_BddNotAcc(trConstrOpt);
  }
  else
    trConstrOpt = Ddi_BddDup(trConstr);
  
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nAbstrRef - strengthening by NNF\n\n");
  }
  Ddi_AigOptByMonotoneCoreAcc(trConstrOpt,tr,NULL,1,-1.0);
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\n");
  }

  Ddi_BddarrayInsertLast(trConstrOptA,trConstrOpt);
  Ddi_Free(trConstrOpt);

  Ddi_AigarrayConstrainCubeAcc(trConstrOptA,invarConstr);
  Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");

  //  Ddi_BddarrayCofactorAcc(trConstrA, pvarPs, 1);
  Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelUsrMed_c) {
    Ddi_Vararray_t *supp = Ddi_BddarraySuppVararray(trConstrOptA);
    int n = Ddi_VararrayNum(supp);
    Ddi_Vararray_t *psupp = Ddi_VararrayIntersect(supp,ps);
    Ddi_VararrayIntersectAcc(supp,ns);
    fprintf(dMgrO(ddm), "Optimized TR constraint has %d->%d (%d) ps->ns (pi) vars\n",
            Ddi_VararrayNum(psupp), Ddi_VararrayNum(supp),
            n-(Ddi_VararrayNum(psupp)+Ddi_VararrayNum(supp)));
    Ddi_Free(supp);      
    Ddi_Free(psupp);      
  }

  Ddi_Free(invarPs);
  Ddi_Free(invarNs);
  Ddi_Free(invarConstr);
  Ddi_Free(invarConstrCube);
  Ddi_Free(tr);
    
  return trConstrOptA;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
genTrConstrFromBmcCone(
  Trav_ItpMgr_t * itpMgr,
  int first,
  int last,
  int bmcBound
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Bdd_t *invarConstr = NULL; 
  Ddi_Bdd_t *invarConstrCube = NULL; 
  Ddi_Bdd_t *cone = NULL;
  Ddi_Bdd_t *tr0, *tr;
  Ddi_Bddarray_t *trConstrA;
  int i;
  int doBwdRing = 0;
  
  if (first < 1) first = 1;
  if (last <= 0 || last>=bmcBound)
    last = bmcBound;
  if (first >= last) return 0;
  
  Ddi_Bdd_t *invarPs = NULL;
  Ddi_Bdd_t *invarNs = NULL;
  if (1) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    Ddi_Var_t *ipNs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
    invarConstr = Ddi_BddDup(itpMgr->invarConstr);  
    Pdtutil_Assert (iv != NULL,"missing invar var");
    invarPs = Ddi_BddMakeLiteralAig(iv, 1);
    invarNs = Ddi_BddMakeLiteralAig(ivNs, 1);
    invarConstrCube = Ddi_BddAnd(invarPs,invarNs);
    if (invarConstr==NULL) {
      invarConstr = Ddi_BddMakeConstAig(ddm, 1);
    }      
    Ddi_BddAndAcc(invarConstr, invarPs);
    Ddi_BddAndAcc(invarConstr, invarNs);
  }

  tr0 = genComposedTr(itpMgr,first,0,NULL);
  Ddi_AigAndCubeAcc(tr0,invarConstrCube);
  //  Ddi_AigConstrainCubeAcc(tr0,invarConstr);
  if (itpMgr->initStub!=NULL) {
    Ddi_BddComposeAcc(tr0,itpMgr->ps,itpMgr->initStub);
  }
  else {
    Ddi_AigConstrainCubeAcc(tr0, itpMgr->init);
  }
  Ddi_BddSubstVarsAcc(tr0,itpMgr->ns,itpMgr->ps);

#if 0 // to check BWD cone
  if (last == bmcBound) {
    cone = Ddi_BddMakeConstAig(ddm, 1);
    tr = Ddi_BddDup(itpMgr->target);
    Ddi_BddWriteMark (tr, first);
    
    Ddi_BddSubstVarsAcc(tr, itpMgr->ps, itpMgr->ns);
    
    growConeBwd(itpMgr, tr, bmcBound-1, first, NULL,
                          NULL, 0, -1, 0 /*boundK */ );
    Ddi_BddSubstVarsAcc(tr, itpMgr->ns, itpMgr->ps);
    doBwdRing = 1;
  }
  else
#endif
  {
    cone = Ddi_BddDup(itpMgr->target);
    Ddi_BddWriteMark (cone, last);
    Ddi_BddSubstVarsAcc(cone, itpMgr->ps, itpMgr->ns);
    
    if (last < bmcBound)
      growConeBwd(itpMgr, cone, bmcBound-1, last, NULL,
                          NULL, 0, -1, 0 /*boundK */ );
    Ddi_AigAndCubeAcc(cone,invarNs);
    Ddi_Vararray_t *coneSupp = Ddi_BddSuppVararray(cone);
    tr = genComposedTr(itpMgr,last-first,first/*shift*/,coneSupp);
    Ddi_Free(coneSupp);
    Ddi_AigAndCubeAcc(tr,invarConstrCube); 
    //  Ddi_AigConstrainCubeAcc(tr,invarConstr);

  }
  
  trConstrA = Ddi_BddarrayAlloc(ddm,0);

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nTR abstr by INTERPOLATION from BMC\n\n");
  }

  Ddi_Bdd_t *bForItp = Ddi_BddDup(tr0);
  Ddi_BddSetPartConj(bForItp);
  Ddi_BddPartInsertLast(bForItp,cone);
  //    Ddi_AigConstrainCubeAcc(bForItp,invarConstr);
    //    Ddi_BddPartInsertLast(bForItp,invarConstr);
  Ddi_BddSetFlattened(bForItp);
  int sat;
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    if (doBwdRing)
      printf("\nBWD RING abstr by INTERPOLATION from bmc %d-(tr)-%d - Bound: %d\n\n",
           first, last, bmcBound-last, bmcBound);
    else 
      printf("\nTR abstr by INTERPOLATION from bmc %d-(tr)-%d - (cone: %d) Bound: %d\n\n",
           first, last, bmcBound-last, bmcBound);
  }

  Ddi_Bdd_t *itp_i = Ddi_AigSat22AndWithInterpolant(NULL,tr,bForItp,NULL,
                                                    NULL, NULL,NULL,0,NULL/*bwdCare*/,NULL,
                                                    &sat, 0, 1, 0, -1.0);

  if (!doBwdRing)
    Ddi_AigAndCubeAcc(itp_i,invarConstrCube);
  Ddi_Varset_t *supp = Ddi_BddSupp(itp_i);
  if (Ddi_VarsetNum(supp) < 100) {
    int s0 = Ddi_BddSize(itp_i);
    Ddi_AigOptByBdd(itp_i,20,100000);
    Ddi_BddSetMono(itp_i);
    Ddi_BddSetAig(itp_i);
  }
  Ddi_Free(supp);
  
  Ddi_Free(bForItp);
  int enBddOpt = 0;
  Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelUsrMed_c) {
    Ddi_Vararray_t *supp = Ddi_BddSuppVararray(itp_i);
    int n = Ddi_VararrayNum(supp);
    Ddi_Vararray_t *psupp = Ddi_VararrayIntersect(supp,ps);
    Ddi_VararrayIntersectAcc(supp,ns);
    fprintf(dMgrO(ddm), "TR constraint has %d->%d (%d) ps->ns (pi) vars\n",
            Ddi_VararrayNum(psupp), Ddi_VararrayNum(supp),
            n-(Ddi_VararrayNum(psupp)+Ddi_VararrayNum(supp)));
    Ddi_Free(supp);      
    Ddi_Free(psupp);
    if (n<250) enBddOpt = 0;
  }
  
  int doItp2 = Ddi_BddSize(itp_i)>5000 ? 2: 0;
  while (doItp2-- > 0) {
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nAbstrRef - strengthening by ITP\n\n");
    }
    Ddi_BddNotAcc(itp_i);
    if (enBddOpt)
      Ddi_AigOptByBddSweepTop(itp_i, NULL, 1);
    int sat1;
    Ddi_Bdd_t *itp_i1 = Ddi_AigSat22AndWithInterpolant(NULL,itp_i,
                                                       tr, NULL,
                                                       NULL, NULL, 0, NULL, NULL, NULL,
                                                       &sat1, 0, 1, 0, -1.0);
    if (Ddi_BddSize(itp_i1) > Ddi_BddSize(itp_i)) doItp2 = 0;
    if (Ddi_BddSize(itp_i1) < Ddi_BddSize(itp_i)*1.2) {
      Ddi_DataCopy(itp_i,itp_i1);
    }
    Ddi_BddNotAcc(itp_i);
    Ddi_Free(itp_i1);
  }
  
  int doOpt = 1;
  if (doOpt) {
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nAbstrRef - strengthening by NNF\n\n");
    }
    Ddi_AigOptByMonotoneCoreAcc(itp_i,tr,NULL,1,-1.0);
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\n");
    }
  }
  Pdtutil_Assert(!sat,"sat when computing ITP");
  if (!Ddi_BddIsOne(itp_i))  {
    Ddi_BddarrayInsertLast(trConstrA,itp_i);
  }
  Ddi_Free(itp_i);

  Ddi_AigarrayConstrainCubeAcc(trConstrA,invarConstr);
  Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");

  //  Ddi_BddarrayCofactorAcc(trConstrA, pvarPs, 1);
  Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelUsrMed_c) {
    Ddi_Vararray_t *supp = Ddi_BddarraySuppVararray(trConstrA);
    int n = Ddi_VararrayNum(supp);
    Ddi_Vararray_t *psupp = Ddi_VararrayIntersect(supp,ps);
    Ddi_VararrayIntersectAcc(supp,ns);
    fprintf(dMgrO(ddm), "Optimized TR constraint has %d->%d (%d) ps->ns (pi) vars\n",
            Ddi_VararrayNum(psupp), Ddi_VararrayNum(supp),
            n-(Ddi_VararrayNum(psupp)+Ddi_VararrayNum(supp)));
    Ddi_Free(supp);      
    Ddi_Free(psupp);      
  }

  Ddi_Free(invarPs);
  Ddi_Free(invarNs);
  Ddi_Free(invarConstr);
  Ddi_Free(invarConstrCube);
  Ddi_Free(tr);
  Ddi_Free(tr0);
  Ddi_Free(cone);
    
  return trConstrA;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
genTrConstrFromItpRings(
  Trav_ItpMgr_t * itpMgr,
  int first,
  int last,
  int nFrames
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitCare = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Vararray_t *splitRefV = NULL;
  Ddi_Bdd_t *splitConstr=NULL;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *ps = itpMgr->ps;
  if (Ddi_BddarrayNum(itpMgr->fromRings)<3) return NULL;
  Ddi_Bdd_t *invarConstr = Ddi_BddDup(itpMgr->invarConstr);
  Ddi_Bdd_t *tr;
  Ddi_Bddarray_t *trConstrA;
  int i;
  
  if (first < 0) first = 0;
  if (last <= 0 || last>=Ddi_BddarrayNum(itpMgr->fromRings))
    last = Ddi_BddarrayNum(itpMgr->fromRings)-1;

  if (1) {
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");
    
    if (iv != NULL) {
      Ddi_Bdd_t *invarPs = Ddi_BddMakeLiteralAig(iv, 1);
      Ddi_Bdd_t *invarNs = Ddi_BddMakeLiteralAig(ivNs, 1);
      if (invarConstr==NULL) {
	invarConstr = Ddi_BddMakeConstAig(ddm, 1);
      }      
      Ddi_BddAndAcc(invarConstr, invarPs);
      Ddi_BddAndAcc(invarConstr, invarNs);
      Ddi_Free(invarPs);
      Ddi_Free(invarNs);
    }
  }

  tr = genComposedTr(itpMgr,nFrames,0,NULL);
  Ddi_AigConstrainCubeAcc(tr,invarConstr);

  int doSccReduction = 0;
  Ddi_Varset_t *sccNsVars = NULL;
  if (doSccReduction) {
    Ddi_SccMgr_t *sccMgr = Ddi_FsmSccTarjan(itpMgr->delta, NULL, itpMgr->ps);
    int maxSccBit = Ddi_GetSccBitWithMaxLatches (sccMgr);
    Ddi_Vararray_t *sccPs = Ddi_GetSccLatches (sccMgr, ps, maxSccBit);
    Ddi_Vararray_t *sccNs = Ddi_VararraySubstVars(sccPs,itpMgr->ps,itpMgr->ns);
    sccNsVars = Ddi_VarsetMakeFromArray(sccNs);
    Ddi_SccMgrFree(sccMgr);
    Ddi_Free(sccPs);
    Ddi_Free(sccNs);
  }
  
  trConstrA = Ddi_BddarrayAlloc(ddm,0);

  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nTR abstr by INTERPOLATION from rings\n\n");
  }

  for (i=first; (i+nFrames)<=last; i++) {
    Ddi_Bdd_t *r_0 = Ddi_BddSubstVars(Ddi_BddarrayRead(itpMgr->fromRings,i),ns,ps);
    Ddi_Bdd_t *bForItp = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings,i+nFrames));
    int s0 = Ddi_BddSize(bForItp);
    if (sccNsVars!=NULL) {
      Ddi_BddExistProjectAcc(bForItp,sccNsVars);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("Projected ring to SCC: %d -> %d\n", s0, Ddi_BddSize(bForItp));
      }
    }
    Ddi_BddNotAcc(bForItp);
    Ddi_BddSetPartConj(bForItp);
    if (0 && Ddi_BddIsZero(r_0)) {
      Pdtutil_Assert(i==0 && itpMgr->initStub!=NULL,"invalid zero init state");
      Ddi_Free(r_0);
      r_0 = Ddi_BddRelMakeFromArray(itpMgr->initStub,itpMgr->ps);
      Ddi_AigConstrainCubeAcc(r_0,invarConstr);
    }
    Ddi_BddPartInsertLast(bForItp,r_0);
    Ddi_AigConstrainCubeAcc(bForItp,invarConstr);
    //    Ddi_BddPartInsertLast(bForItp,invarConstr);
    Ddi_BddSetFlattened(bForItp);
    Ddi_Free(r_0);
    int sat;
    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nTR abstr by INTERPOLATION from rings %d-(tr)-%d\n\n", i, i+nFrames);
    }

    Ddi_Bdd_t *itp_i = Ddi_AigSat22AndWithInterpolant(NULL,tr,bForItp,NULL,
		  NULL, NULL,NULL,0,NULL/*bwdCare*/,NULL,
		  &sat, 0, 1, 0, -1.0);
    Ddi_Free(bForItp);

    int doItp2 = 1;
    if (doItp2) {
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nAbstrRef - strengthening by ITP\n\n");
      }
      Ddi_BddNotAcc(itp_i);
      int sat1;
      Ddi_Bdd_t *itp_i1 = Ddi_AigSat22AndWithInterpolant(NULL,itp_i,
                                                         tr, NULL,
                                                         NULL, NULL, 0, NULL, NULL, NULL,
                                                         &sat1, 0, 1, 0, -1.0);
      if (Ddi_BddSize(itp_i1) < Ddi_BddSize(itp_i)*1.2) {
        Ddi_DataCopy(itp_i,itp_i1);
      }
      Ddi_BddNotAcc(itp_i);
      Ddi_Free(itp_i1);
    }

    int doOpt = 1;
    if (doOpt) {
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nAbstrRef - strengthening by NNF\n\n");
      }
      Ddi_AigOptByMonotoneCoreAcc(itp_i,tr,NULL,1,-1.0);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\n");
      }
    }
    Pdtutil_Assert(!sat,"sat when computing ITP");
    if (!Ddi_BddIsOne(itp_i))  {
      Ddi_BddarrayInsertLast(trConstrA,itp_i);
    }
    Ddi_Free(itp_i);
  }

  Ddi_AigarrayConstrainCubeAcc(trConstrA,invarConstr);
  Ddi_Var_t *pvarPs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");

  //  Ddi_BddarrayCofactorAcc(trConstrA, pvarPs, 1);


  Ddi_Free(sccNsVars);
  Ddi_Free(invarConstr);
  Ddi_Free(tr);
  
  return trConstrA;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
getConeWithTrAbstrItp(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *cone,
  Ddi_Bdd_t *from,
  int start_i,
  int end_i,
  int split_i,
  int boundk
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int trAbstrItpMaxFwdStep = travMgr->settings.aig.trAbstrItpMaxFwdStep;
  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitCare = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Vararray_t *splitRefV = NULL;
  Ddi_Bdd_t *splitConstr=NULL;
  
  growConeBwdDecomp(itpMgr, cone, start_i, end_i, split_i, 
                    0, 1 /*useNewVars*/, NULL,
                    NULL, 0 /*useRingConstr */ ,
                    -1 /*andWithRing_i*/,
                    boundk);

  Pdtutil_Assert(Ddi_BddReadComposeF(cone)!=NULL,"no split cone");
  splitB = Ddi_BddReadComposeF(cone);
  splitCare = Ddi_BddReadComposeCare(cone);
  splitU = Ddi_BddReadComposeSubst(cone);
  splitV = Ddi_BddReadComposeVars(cone);
  splitRefV = Ddi_BddReadComposeRefVars(cone);
  splitRel = Ddi_BddRelMakeFromArray(splitU,splitV);
  splitConstr = Ddi_BddReadComposeConstr(cone);

  Ddi_Bdd_t *myB = Ddi_BddDup(from);
  Ddi_BddSetPartConj(myB);
  Ddi_BddPartInsertLast(myB,splitB);
  Ddi_BddPartInsertLast(myB,splitCare);
  if (splitConstr!=NULL)
    Ddi_BddPartInsertLast(myB,splitConstr);

  int sat=0;
  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
    printf("\nTR abstr by INTERPOLATION\n\n");
  }

  Ddi_Bdd_t *myTrAbstr;
  int computeTrAbstr = end_i<=(trAbstrItpMaxFwdStep+1);

  computeTrAbstr &= itpMgr->trItpAbstr.enCompute;
  
  if (!computeTrAbstr)
    myTrAbstr = Ddi_BddMakeConstAig(ddm,1);
  else 
    myTrAbstr = Ddi_AigSat22AndWithInterpolant(NULL,splitRel,myB,NULL,
		  NULL, NULL,NULL,0,NULL/*bwdCare*/,NULL,
		  &sat, 0, 1, 0, -1.0);
  Ddi_Free(myB);
  int doSubst = 0;
  if (!sat || !computeTrAbstr) {
    Ddi_Bddarray_t *psNsConstr = itpMgr->trItpAbstr.psNsConstr;
    if (psNsConstr==NULL) {
      psNsConstr = Ddi_BddarrayAlloc(ddm,0);
      itpMgr->trItpAbstr.psNsConstr = psNsConstr;
    }
    else {
      Pdtutil_Assert(itpMgr->trItpAbstr.nFrames == split_i - end_i,"wrong num of frames");
#if 1
      Ddi_BddAndAcc(myTrAbstr,Ddi_BddarrayRead(psNsConstr,0));
      Ddi_Free(itpMgr->trItpAbstr.psNsConstr);
      psNsConstr = Ddi_BddarrayAlloc(ddm,0);
      itpMgr->trItpAbstr.psNsConstr = psNsConstr;
      doSubst=1;
#endif
    }
    int doOpt = 0&&!Ddi_BddIsOne(myTrAbstr);
    if (doOpt) {
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nAbstrRef - strengthening by NNF\n\n");
      }
      Ddi_AigOptByMonotoneCoreAcc(myTrAbstr,splitRel,NULL,1,-1.0);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\n");
      }
    }
    //    itpMgr->trItpAbstr.psNsConstr = Ddi_BddDup(myTrAbstr);
    Ddi_BddarrayInsertLast(itpMgr->trItpAbstr.psNsConstr,myTrAbstr);
    if (doSubst) {
      Ddi_BddSubstVarsAcc(myTrAbstr,splitRefV,splitV);
      Ddi_BddSubstVarsAcc(myTrAbstr,itpMgr->ps,itpMgr->ns);
    }
    itpMgr->trItpAbstr.nFrames = split_i - end_i;
    char *store = travMgr->settings.aig.trAbstrItpStore;
    if (store != NULL) {
      char fname[500];
      strcpy(fname,store);
      char *s = strstr(fname,".");
      if (s==NULL) s = fname+strlen(fname);
      sprintf(s,"_%d_%d.aig", end_i, itpMgr->trItpAbstr.nFrames);
      Ddi_Bddarray_t *psNsConstrStore = Ddi_BddarrayDup(itpMgr->trItpAbstr.psNsConstr);
      Ddi_BddarraySubstVarsAcc(psNsConstrStore,itpMgr->ns,itpMgr->ps);
      Ddi_BddarraySubstVarsAcc(psNsConstrStore,splitV,splitRefV);
      Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nAbstrRef - storing tr constraint [%d] (size: %d) to file %s\n\n",
               Ddi_BddarrayNum(psNsConstrStore), Ddi_BddarraySize(psNsConstrStore), fname);
      }
      Ddi_AigarrayNetStoreAiger(psNsConstrStore, 0, fname);
      Ddi_Free(psNsConstrStore);
    }
    Ddi_BddComposeAcc(myTrAbstr,splitV,splitU);
    Ddi_BddAndAcc(cone,myTrAbstr);
  }
  Ddi_Free(myTrAbstr);
  Ddi_Free(splitRel);
  
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
itpImgGetCone(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * kCone,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t *coneCare,
  int step,
  int phase,
  int doSplit,
  int doLookahead,
  int doSubset,
  int assumeSafeBound,
  int coneRelational
)
{
  Trav_Mgr_t *travMgr = itpTravMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int enStructAbstractionWithCone = travMgr->settings.aig.itpStructAbstr;
  Ddi_Bdd_t *localCone = NULL;
  int innerWithReducedCone = itpTravMgr->settings.innerWithReducedCone;

  doSubset |= itpTravMgr->conePiConstr!=NULL;

  //  coneRelational = 1;
  if (phase <= 0) {

    //    itpTravMgr->settings.bwdReach_k = 0;
    
    if (kConeRings != NULL) {
      if (itpTravMgr->settings.useBwdReachAsCone != 0) {
        int np = Ddi_BddPartNum(kConeRings);
        int iRing = (step >= np ? np - 1 : step);
        int start_i = np - 1;
        int end_i = iRing;
        int sat;
        int minBound = travMgr->settings.aig.igrFwdBwd;
        Ddi_Bdd_t *cone0 = Ddi_BddPartRead(kConeRings, np - 1);
        int noCheck = itpTravMgr->settings.tryInnerRing == 0;
        int noSplit = minBound<5;
        
        if (itpTravMgr->settings.tryInnerRing == -2 && 
            itpTravMgr->settings.bwdReach_k > 0) {
          noCheck = 1;
        }
        if (itpTravMgr->settings.tryInnerRing == -1 || 
            itpTravMgr->settings.tryInnerRing > 2) {
          if (iRing>0)
            start_i++;
        }
        else if (itpTravMgr->settings.tryInnerRing == 1 /* ||
                 itpTravMgr->settings.tryInnerRing == 0 */) {
          start_i--;
        }
        itpTravMgr->settings.bwdReach_k = 0;
        if ((start_i-end_i) > (minBound + (noSplit?1:0)) &&
            end_i>=0) {
          int bwd_k = refineBwdRingForCone(itpTravMgr,
                        cone0,start_i,end_i,minBound,&sat,
                        noCheck,noSplit);
          if (!sat && bwd_k>0) {
            itpTravMgr->settings.bwdReach_k = bwd_k;
          }
        }
      }
    }
    if (growCone && (kConeRings != NULL)) {
      int np = Ddi_BddPartNum(kConeRings);
      int iRing = (step >= np ? np - 1 : step);

      if (1 || iRing > 0) {
        // if (!Ddi_AigSatAnd(from,localCone,NULL)) {
        if (itpTravMgr->settings.tryInnerRing < -1) {
          // start the process
          itpMgr->igr.sameConeFail = -1;
          itpTravMgr->settings.tryInnerRing = -1;
        } else {
          if (iRing==0) {
            localCone = NULL;
          }
          else {
            Pdtutil_Assert(iRing > 0, "wrong ring index");
            localCone = Ddi_BddPartRead(kConeRings, iRing - 1);
          }
          if (itpTravMgr->settings.tryInnerRing < 0) {
            // start the process
            itpTravMgr->settings.tryInnerRing = 3;
          }
          if (itpTravMgr->settings.tryInnerRing == 1) {
            Ddi_BddPartRemove(kConeRings, iRing);
            itpTravMgr->settings.tryInnerRing = 0;
            itpTravMgr->stats.coneHit = 1;
            if (itpTravMgr->settings.checkCompleteness == 1)
              itpTravMgr->settings.checkCompleteness = 0;
            itpMgr->igr.sameConeFail = iRing;
            localCone = NULL;   // need to recompute
          } else if (itpTravMgr->settings.tryInnerRing == 2) {
            itpTravMgr->settings.tryInnerRing = 0;
	    //            itpTravMgr->stats.coneHit = 1;
            if (itpTravMgr->settings.checkCompleteness == 1)
              itpTravMgr->settings.checkCompleteness = 0;
            itpMgr->igr.sameConeFail = iRing;
            localCone = NULL;   // need to recompute
          } else if (itpTravMgr->settings.tryInnerRing > 2) {
	    if (phase == 0) {
	      Ddi_BddPartInsert(kConeRings, iRing, localCone);
	      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
		printf("  Reusing SAME CONE ring\n");
		fflush(tMgrO(travMgr));
	      }
	    }
	    else {
	      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
		printf("  Reusing SAME CONE ring (2nd run)\n");
		fflush(tMgrO(travMgr));
	      }
	    }
          }
        }
      }
    }

    if (itpMgr->dynAbstr && (enStructAbstractionWithCone > 1)) {
      /* setup cone for standard check */
      int nAbstr, myHit;

      if (kConeRings != NULL) {
        int np = Ddi_BddPartNum(kConeRings);
        int iRing = (step >= np ? np - 1 : step);

        localCone = Ddi_BddPartRead(kConeRings, iRing);
      } else {
        localCone = kCone;
      }
      myHit = -1;               // disabled // Ddi_AigSatAnd(from,localCone,NULL);
      nAbstr = interpolantStructAbstrFrom(itpTravMgr->from,
        itpTravMgr->from0, localCone,
        itpMgr->ns, itpMgr->nsvars, itpMgr->trArray);
      if (itpMgr->invarConstr != NULL) {
        Ddi_BddAndAcc(itpTravMgr->from, itpMgr->invarConstr);
      }
      if (myHit == 0) {
        Pdtutil_Assert(!Ddi_AigSatAnd(itpTravMgr->from, localCone, NULL),
          "error");
      }
      localCone = NULL;
    }

  } else {

    /* setup cone for standard check */
    if (kConeRings != NULL) {
      int rewinding = 0 && (itpTravMgr->settings.tryInnerRing == 0);
      int np = Ddi_BddPartNum(kConeRings);
      int iRing = (step >= np ? np - 1 : step - 1);
      int enShiftCone = 1;
      int start_i = np - 1;
      int end_i = iRing + 1;
      int doTrAbstrItp = travMgr->settings.aig.trAbstrItp;
      int trAbstrItpMaxFwdStep = travMgr->settings.aig.trAbstrItpMaxFwdStep;
      if (doTrAbstrItp) {
        if (end_i+doTrAbstrItp>=start_i) doTrAbstrItp=0;
      }

      localCone = Ddi_BddDup(Ddi_BddPartRead(kConeRings, iRing));
      if (itpTravMgr->settings.useBwdReachAsCone != 0) {
        if (itpTravMgr->settings.bwdReach_k > 0) {
          Ddi_Free(localCone);
        }
      }
      if (doSplit || doTrAbstrItp && end_i<=(trAbstrItpMaxFwdStep+1)) {
	Ddi_Free(localCone);
      }
      if (localCone!=NULL && !Ddi_BddIsZero(localCone)) {
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("taking cone[%d/%d] of size: %d - bound: %d\n",
                 iRing, np, Ddi_BddSize(localCone),
                 Ddi_BddReadMark(localCone));
        }
      } else {
	int boundK = (!rewinding && (growCone > 2)) ? 1 : 0;

	if (0 && rewinding) {
	  start_i -= 2;
	  if (start_i < end_i) start_i = end_i;
	}

        if (innerWithReducedCone > 0 && start_i - end_i > 5) {
          start_i -= innerWithReducedCone;
        }

        Ddi_Free(localCone);
        if (itpTravMgr->settings.useBwdReachAsCone != 0 &&
            itpTravMgr->settings.bwdReach_k > 0) {
          int bwd_k = itpTravMgr->settings.bwdReach_k;
          localCone = Ddi_BddDup(Ddi_BddarrayRead(
                        itpMgr->bckReachedRings,bwd_k));
          Ddi_BddSubstVarsAcc(localCone,itpMgr->ps,itpMgr->ns);
          Ddi_BddWriteMark(localCone, bwd_k);
          start_i -= bwd_k;
        }
        else {
          localCone = Ddi_BddDup(Ddi_BddPartRead(kConeRings, np- 1));
        }

	if (doSplit && doLookahead) {
	  Ddi_Bdd_t *safeRing; 
	  int mark;
          int saveStart_i = start_i, saveStep = step;
	  int ok = itpLookaheadRingsFwd(itpTravMgr,kConeRings,kCone,
		 end_i-1,doSplit+1,growCone != 1 ? 2 : 0,boundK);
	  if (ok) {
	    doSplit = 0;
	  }
	  else if (ok) {
	    start_i = ok;
	    Pdtutil_Assert(start_i<=end_i+doSplit,
			   "wrokg ret from cone lookahead");
	    safeRing = Ddi_BddarrayRead(itpMgr->fromRings, start_i);
	    Ddi_Free(localCone);
	    localCone = Ddi_BddNot(safeRing);
	    mark = Trav_ItpMgrReadConeBoundOK(itpMgr,start_i);
	    Ddi_BddWriteMark(localCone, mark);
	    start_i--;
	    doSplit = 0;
	    if (1) {
	      Ddi_Bdd_t *fromRing = Ddi_BddarrayRead(itpMgr->fromRings, end_i-1);
	      Ddi_Bdd_t *auxCone = Ddi_BddDup(localCone);
	      growConeBwd(itpMgr, auxCone, start_i, end_i-1, NULL,
			itpMgr->initStub, growCone != 1 ? 2 : 0 /*useRingConstr */ ,
			  -1, boundK);
	      int sat = Ddi_AigSatAnd(fromRing,auxCone,NULL);
	      printf("lookahead cone OK: %d\n", sat);
	      Ddi_Free(auxCone);
              if (sat) {
                start_i = saveStart_i;
                step = saveStep;
              }
              else {
		Pdtutil_Assert(!sat,"wrong cone lookahead");
              }
	    }
	  }
	}
        if (doSplit) {
	  if (end_i+doSplit>start_i) doSplit=0;
	}
        if (doTrAbstrItp) {
	  int useSplitUnrollConstr = phase<=2;
	  int useNewVars = phase<=2;
          int split_i = end_i + doTrAbstrItp;
          getConeWithTrAbstrItp(itpMgr, localCone, itpTravMgr->from,start_i,
                                end_i, split_i, growCone > 2 ? 1 : 0);
        } else if (doSplit) {
	  int useSplitUnrollConstr = phase<=2;
	  int useNewVars = phase<=2;
          int split_i = end_i + doSplit;


          growConeBwdDecomp(itpMgr, localCone, start_i, end_i, split_i, 
			    useSplitUnrollConstr, useNewVars, NULL,
            itpMgr->initStub, growCone != 1 ? 2 : 0 /*useRingConstr */ ,
			    -1 /*andWithRing_i*/,
			    growCone > 2 ? 1 : 0 /*boundK */);
        } else {
          if (0 && itpTravMgr->stats.coneHit) {
            // boundK = -1;
          }
          if (coneRelational) {
            growConeBwdRelational(itpMgr, localCone, start_i, end_i, NULL,
              itpMgr->initStub, growCone != 1 ? 2 : 0 /*useRingConstr */ ,
              boundK);
          } else {
            int tryTargetSubset = 0; // 8;
            if (itpMgr->antecedents!=NULL) {
              Ddi_Free(itpTravMgr->observedGates);
              itpTravMgr->observedGates = Ddi_BddarrayAlloc(ddm,0);
            }
            growConeBwdSubsetByTarget(itpMgr, localCone, start_i, end_i, NULL,
                 itpMgr->initStub,
                 itpTravMgr->observedGates,
                 tryTargetSubset,
                 growCone != 1 ? 2 : 0 /*useRingConstr */ ,
		 -1, boundK);
            if (ddm->aig.actVars!=NULL) {
              Ddi_Unlock(ddm->aig.actVars);
              Ddi_Free(ddm->aig.actVars);
            }
            if (travMgr->settings.aig.itpPartCone > 0
                //&& ddm->settings.aig.itpDrup
                ) {
              int npMax = travMgr->settings.aig.itpPartCone;
              int npMin = npMax/2;
              if ((start_i-end_i) >= npMin) {
                Ddi_Bdd_t *newCone = Ddi_AigDisjDecomp (localCone,
                                                      npMin,npMax);
                Ddi_DataCopy(localCone,newCone); // keep compose info
                Ddi_Free(newCone);
              }
            }
          }
        }
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("ring cone %s - generated part[%d/%d] of size: %d - bound: %d\n",
            boundK ? "(k)" : ((growCone > 1) ? "(e)" : ""),
                 iRing, start_i+1, Ddi_BddSize(localCone),
                 Ddi_BddReadMark(localCone));
        }
	enShiftCone &= itpMgr->igr.useRings==0;
        enShiftCone &= (itpMgr->eqRings != NULL && phase > 1 &&
          Ddi_BddarrayNum(itpMgr->eqRings) <= iRing + 1);
	if (enShiftCone) {
          Ddi_Bdd_t *ringCone = Ddi_BddPartRead(kConeRings, iRing);

          if (ringCone != NULL) {
            int mark = Ddi_BddReadMark(localCone);

            Ddi_DataCopy(ringCone, localCone);
            Ddi_BddWriteMark(ringCone, mark);
          }
        }
      }
      if (assumeSafeBound>1 && (start_i - end_i) >= assumeSafeBound) {
        Ddi_Var_t *pvarNs = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$NS");
	Ddi_Bdd_t *cone0 = Ddi_BddMakeLiteralAig(pvarNs, 0);
        Ddi_BddWriteMark(cone0, 0);
        growConeBwd(itpMgr, cone0, end_i+assumeSafeBound-1, end_i, NULL,
              itpMgr->initStub, growCone != 1 ? 2 : 0 /*useRingConstr */ ,
			  -1, 1);
	Pdtutil_Assert(cone0!=NULL,"missing assumed cone");
        Ddi_BddNotAcc(cone0);
        Ddi_BddAndAcc(localCone,cone0);
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("assuming cone of size: %d - bound: %d - total size: %d\n",
                 Ddi_BddSize(cone0), assumeSafeBound, Ddi_BddSize(localCone));
        }
        Ddi_Free(cone0);
      }
    } else {
      localCone = Ddi_BddDup(kCone);
    }
    if (doSubset) {
      itpImgConeSubsetTopAcc(itpTravMgr,localCone,kConeRings,
                                      coneCare,step);
    }
    if (1 && (itpTravMgr->careForBwdCone != NULL)) {
      Pdtutil_Assert(Ddi_BddIncluded(kCone,itpTravMgr->careForBwdCone),
				     "error with careBwdForCone");
      if (Ddi_BddSize(localCone)>100) {
	Ddi_BddAndAcc(localCone,itpTravMgr->careForBwdCone);
      }
    }
  }

  //  NOT valid as reached states can be under-approximated !!
  //  itpTravMgrConstrainWithSplitCex(itpTravMgr,kConeRings, step);

  return localCone;
}

static void checkEqConstr (
  Ddi_Vararray_t *vA,
  Ddi_Bddarray_t *subst
)
{
  int i;

  for (i=0; i<Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA,i);
    Pdtutil_Assert(Ddi_VarReadMark(v) == 0,"0 var mark required");
    Ddi_VarWriteMark(v,1);
  }
  Ddi_VararrayWriteMark (vA, 0);

  Ddi_Vararray_t *suppA = Ddi_BddarraySuppVararray(subst);
  Ddi_VararrayIntersectAcc(suppA,vA);
  Pdtutil_Assert(Ddi_VararrayNum(suppA)==0,"problem in eq subst");
  Ddi_Free(suppA);
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
partitionByWitnessVars(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;
  Trav_Mgr_t *travMgr = itpMgr->travMgr;

  Ddi_Var_t *v0 = Ddi_VarFromName(ddm, "PDT_BDD_PROP_WITNESS_0_VAR$NS");
  Ddi_Var_t *v1 = Ddi_VarFromName(ddm, "PDT_BDD_PROP_WITNESS_1_VAR$NS");
  Ddi_Var_t *l0 = Ddi_VarFromName(ddm, "l1082$NS");
  Ddi_Var_t *l1 = Ddi_VarFromName(ddm, "l2272$NS");
  if (v0!=NULL && v1!=NULL) {
    Ddi_Bdd_t *p0 = Ddi_BddMakeLiteralAig(v0, 1);
    Ddi_Bdd_t *p1 = Ddi_BddMakeLiteralAig(v1, 1);
    Ddi_Bdd_t *p0n = Ddi_BddNot(p0);
    Ddi_Bdd_t *p1n = Ddi_BddNot(p1);
    
    Ddi_Bdd_t *e0 = Ddi_BddMakeLiteralAig(l0, 1);
    Ddi_Bdd_t *e1 = Ddi_BddMakeLiteralAig(l1, 1);
    Ddi_Bdd_t *diffL = Ddi_BddXor(e0, e1);
    Ddi_Bdd_t *target = Ddi_BddAnd(p0n, p1n);
    int dif = Ddi_AigSatAnd(a,target,NULL);
    if (dif) {
      Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(a,target,
	      NULL, NULL, 100, NULL);
      Ddi_BddExistProjectAcc(cex,itpMgr->nsvars);
      Ddi_Free(cex);
    }
    dif = Ddi_AigSatAnd(a,diffL,p1);
    Ddi_Free(target);

    Ddi_Vararray_t *constrainVarsNs = Ddi_VararrayAlloc(ddm, 0);
    Ddi_Bddarray_t *constrainSubstLitsNs = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_Bdd_t *eq =
      DdiAigEquivVarsAcc(a, NULL, NULL,
           itpMgr->nsvars, NULL, constrainVarsNs, constrainSubstLitsNs);
    Ddi_Free(eq);
    eq = 
      DdiAigEquivVarsAcc(a, p1, NULL,
           itpMgr->nsvars, NULL, constrainVarsNs, constrainSubstLitsNs);
    Ddi_Free(eq);
    Ddi_BddComposeAcc(b,constrainVarsNs,constrainSubstLitsNs);
#if 0
    eq = 
      DdiAigEquivVarsAcc(a, p0, NULL,
           itpMgr->nsvars, NULL, constrainVarsNs, constrainSubstLitsNs);
    Ddi_Free(eq);
    eq = 
      DdiAigEquivVarsAcc(a, p0n, NULL,
           itpMgr->nsvars, NULL, constrainVarsNs, constrainSubstLitsNs);
    Ddi_Free(eq);
    eq = 
      DdiAigEquivVarsAcc(a, p1n, itpMgr->nsvars,
           itpMgr->nsvars, NULL, constrainVarsNs, constrainSubstLitsNs);
    Ddi_Free(eq);
#endif    
    Ddi_Free(constrainVarsNs);
    Ddi_Free(constrainSubstLitsNs);
    Ddi_Free(diffL);
    Ddi_Free(p0);
    Ddi_Free(p1);
    Ddi_Free(p0n);
    Ddi_Free(p1n);
  }
}


/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
itpImgPartItpByDomainCubes (
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  int invertAB,
  int itpReverse,
  int maxIter,
  Ddi_Varset_t *globalVars,
  Ddi_Vararray_t *domainA,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *itpPlus,
  Ddi_Bdd_t *toPlusCube,
  int *psat,
  int itpPart,
  int itpOdc,
  float timeLimit
)
{
  int sat_i=0;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Ddi_Bdd_t *leftover = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *itp = Ddi_BddMakeConstAig(ddm,0);
  int bTh = 1000, window = 8;
  int i, itpDone=0;
  Ddi_Vararray_t *myDomainA=NULL, *suppA;
  int useDomainA = 1;
  int doItp2 = 1;
  int doCoreFinal = useDomainA, doNnfAbstr=1;
  int removeCexVars = 1 && (domainA != NULL);
  int useIncrSatForCex=maxIter>0;
  Ddi_IncrSatMgr_t *ddiS = NULL;
  float cexSuppReduceRatio = 0.5;
  Ddi_Bdd_t *aDup=NULL;
  Ddi_Mgr_t *ddmDup = NULL;
  Ddi_Vararray_t *residualVars = NULL;
  int cexWithGates = 0;
  int sat = 0;
  if (Ddi_BddSize(b)<bTh) {
    maxIter = 1;
  }

  if (removeCexVars) {
    residualVars = Ddi_VararrayDup(domainA);
  }
  
#if 1
  if (useDomainA) 
    myDomainA = Ddi_VararrayDup(domainA);
  else {
    suppA = Ddi_BddSuppVararray(a);
    Ddi_VararrayDiffAcc(suppA,domainA);
    myDomainA = Ddi_VararrayAlloc(ddm, 0);
    for (i=0; i<Ddi_VararrayNum(suppA); i+=2) {
      if ((rand() % 100) > cexSuppReduceRatio*100){
        Ddi_VararrayInsertLast(myDomainA,Ddi_VararrayRead(suppA,i));
      }
    }
    Ddi_Free(suppA);
  }
#else
  suppA = Ddi_BddSuppVararray(a);
  Ddi_VararrayIntersectAcc(suppA,domainA);
  myDomainA = Ddi_VararrayAlloc(ddm, 0);
  for (i=0; i<Ddi_VararrayNum(suppA); i+=2) {
    Ddi_VararrayInsertLast(myDomainA,Ddi_VararrayRead(suppA,i));
  }
  Ddi_Free(suppA);
#endif

  if (useIncrSatForCex) {
    ddmDup = Ddi_MgrDup(ddm);
    ddiS = Ddi_IncrSatMgrAlloc(ddmDup, 1, 0, 0);
    aDup = Ddi_BddCopy(ddmDup,a);
    DdiAig2CnfIdInit(ddmDup);
    Ddi_AigSatMinisatLoadClausesIncrementalAsserted(ddiS,aDup);
  }
  
  for (i=0; !itpDone && itp!=NULL && i<maxIter; i++) {
    Ddi_Bdd_t *b_i, *a_i, *itp_i;
    Ddi_Bdd_t *cube = NULL;
    int andWithLeftover = 0;
    
    if (i==maxIter-1) {
      cube = Ddi_BddMakeConstAig(ddm,1);
      if (i>0) {
        andWithLeftover=1;
      }
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nITP PART BY DOMAIN VARS Last iter [%d]\n", i);
      }
    }
    else if (ddiS!=NULL) {
      Ddi_Bdd_t *leftoverDup = Ddi_BddCopy(ddmDup,leftover);
      Ddi_Bdd_t *myCheck = Ddi_BddDup(aDup);
      Ddi_Vararray_t *myDomainDup = myDomainA ? Ddi_VararrayCopy(ddmDup,myDomainA) : NULL;
      Ddi_BddSetPartConj(myCheck);
      Ddi_BddPartInsertLast(myCheck,leftoverDup);
      Ddi_Bdd_t *cubeDup;
      if (cexWithGates>0) {
        cubeDup = Ddi_AigSatMinisat22WithCexAigAndAbortIncremental(ddiS,
                myCheck, cexWithGates, 0, -1, NULL);
      }
      else {
        cubeDup = Ddi_AigSatMinisat22WithCexAndAbortIncremental(ddiS,
                myCheck, myDomainDup, 0, -1, NULL);
      }
      if (cubeDup!=NULL) {
        cube = Ddi_BddCopy(ddm,cubeDup);
      }
      Ddi_Free(myCheck);
      Ddi_Free(cubeDup);
      Ddi_Free(leftoverDup);
      Ddi_Free(myDomainDup);
    }
    else {
      cube = Ddi_AigSatAndWithCexAndAbort(a, leftover,
             NULL, myDomainA, -1, NULL);
    }
    
    if (cube==NULL) {
      itpDone = 1;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nITP PART BY DOMAIN VARS ended [%d]: NO leftover\n", i);
      }
      break;
    }
#if 0
    Ddi_Vararray_t *sA = Ddi_BddSuppVararray(cube);
    while (Ddi_VararrayNum(sA) > window) {
      int n = Ddi_VararrayNum(sA);
      Ddi_VararrayRemove(sA,n-1);
      Ddi_Free(supp); 
      supp = Ddi_VarsetMakeFromArray(sA);
      Ddi_Free(sA);
    }
    Ddi_Bdd_t *myCex = Ddi_BddDup(cube);
    if (!Ddi_AigSatMinisatWithAbortAndFinal(b,myCex,-1.0,0)) {
      Ddi_Varset_t *sm = Ddi_BddSupp(myCex);
      Ddi_VarsetSetArray(sm);
      Ddi_VarsetIntersectAcc(sm,supp);
      if (Ddi_VarsetNum(sm)>window/2) {
        Ddi_DataCopy(cube,myCex);
      }
      Ddi_Free(sm);
    }
    Ddi_Free(myCex);
    Ddi_BddExistProjectAcc(cube,supp);
#endif
    
    b_i = Ddi_BddDup(b); 
    a_i = Ddi_BddDup(a); 
    sat_i = 0;
    
    if (andWithLeftover) {
      Ddi_BddSetPartConj(a_i);
      Ddi_BddPartInsertLast(a_i,leftover);
    }
    else if (cexWithGates>0) {
      Ddi_BddPartInsertLast(a_i,cube);
      Ddi_BddSetFlattened(a_i);
      Ddi_AigStructRedRemAcc (a_i,NULL);
    }
    else {
      if (doCoreFinal && !Ddi_BddIsOne(cube)) {
        Ddi_Vararray_t *cexSupp=NULL;
        Ddi_Bdd_t *aux = Ddi_BddDup(a_i);
        Pdtutil_Assert(myDomainA!=NULL,"missing domain vars");
        Ddi_BddSetPartConj(aux);
        Ddi_BddPartInsertLast(aux,b_i);
        // int ret = Ddi_AigSatMinisatWithAbortAndFinal(aux,cube,-1.0,0);
        int ret = Ddi_AigSatMinisat22WithAbortAndFinal(aux,cube,0,-1.0);
        if (ret) {
          sat_i = 1;
        }
        cexSupp = Ddi_BddSuppVararray(cube);
        if (Ddi_VararrayNum(cexSupp)>1) {
          Ddi_Free(myDomainA);
          myDomainA = Ddi_VararrayAlloc(ddm, 0);
          int j;
          for (j=0; j<Ddi_VararrayNum(cexSupp); j++) {
            Ddi_Var_t *v_j = Ddi_VararrayRead(cexSupp,j);
            if ((rand() % 100) > cexSuppReduceRatio*100){
              Ddi_VararrayInsertLast(myDomainA,v_j);
            }
          }
        }
        Ddi_Free(aux);
        Ddi_Free(cexSupp);
      }
      if (removeCexVars) {
        Ddi_VararrayDiffAcc(residualVars,myDomainA);
        Ddi_Free(myDomainA);
        myDomainA = Ddi_VararrayDup(residualVars);
      }
      if (doNnfAbstr) {
        int np = Ddi_BddPartNum(a_i);
        if (np>1) {
          Ddi_Bdd_t *from = Ddi_BddPartExtract(a_i,np-1);
          Ddi_Bdd_t *myB = Ddi_BddDup(a_i);
          Ddi_BddPartInsertLast(myB,b_i);
          Ddi_BddSetFlattened(myB);
          Ddi_AigAndCubeAcc(from,cube);
          Ddi_AigOptByMonotoneCoreAcc(from,myB,NULL,0,-1.0);
          Ddi_BddPartInsertLast(a_i,from);
          Ddi_Free(cube);
          cube = Ddi_BddMakeConstAig(ddm,1);
          Ddi_Free(from);
          Ddi_Free(myB);
        }
      }
      Ddi_AigAndCubeAcc(a_i,cube);
    }
    
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      Ddi_Varset_t *cSupp = Ddi_BddSupp(cube);
      printf("\nITP PART BY %d/%d DOMAIN VARS [iter: %d]\n",
             Ddi_VarsetNum(cSupp), Ddi_VararrayNum(myDomainA), i);
      Ddi_Free(cSupp);
    }

    int saveItpNnfAbstrAB = ddm->settings.aig.itpNnfAbstrAB;
    int saveItpReverse = ddm->settings.aig.itpReverse;
    if (!sat_i) {
      if (invertAB) {
        // set just A
        int itpReverse = 0;//k>1;
        ddm->settings.aig.itpNnfAbstrAB = 0; // k==0?1:3;
        ddm->settings.aig.itpReverse = itpReverse;
        itp_i = Ddi_AigSat22AndWithInterpolant(NULL,b_i,a_i,NULL,
		  globalVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
		  &sat_i, 0, 1, 0, timeLimit);
        if (itp_i!=NULL) {
          Ddi_BddNotAcc(itp_i);
        }
      }
      else {
        int itpReverse = 1;//k>1;
        ddm->settings.aig.itpReverse = itpReverse;
        itp_i = Ddi_AigSat22AndWithInterpolant(NULL,a_i,b_i,NULL,
		  globalVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
		  &sat_i, 0, 1, 0, timeLimit);
      }
      ddm->settings.aig.itpNnfAbstrAB = saveItpNnfAbstrAB;
      ddm->settings.aig.itpReverse = saveItpReverse;
    }
    
    if (sat_i) {
      if (psat!=NULL) *psat = sat_i;
      Ddi_Free(itp);
      itp = NULL;
      itpDone = 1;
    }
    else {
      Pdtutil_Assert(itp_i!=NULL,"NULL itp");
      Ddi_BddOrAcc(itp,itp_i);
      Ddi_AigOptByMonotoneCoreAcc(itp,b_i,NULL,0,-1.0);
      if (doItp2 && i>0 && i<10) {
        Ddi_Bdd_t *itp2;
        int sat2;
        itp2 = Ddi_AigSat22AndWithInterpolant(NULL,itp,b_i,NULL,
		  globalVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
		  &sat2, 0, 1, 0, timeLimit);
        Ddi_AigOptByMonotoneCoreAcc(itp2,b_i,NULL,0,-1.0);
        if (Ddi_BddSize(itp2)<Ddi_BddSize(itp)) {
          Ddi_Free(itp); itp = itp2;
        }
        else {
          Ddi_Free(itp2);
        }
      }
      Ddi_Free(leftover);
      leftover = Ddi_BddNot(itp);
    }
    Ddi_Free(a_i);
    Ddi_Free(b_i);
    Ddi_Free(itp_i);
    
  }
  Ddi_Free(residualVars);
  Ddi_Free(aDup);
  Ddi_IncrSatMgrQuit(ddiS);
  Ddi_Free(leftover);
  Ddi_Free(myDomainA);
  return itp;
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpImgPartItpByDomainCubesFwdBwd (
  Ddi_Bdd_t *from,
  Ddi_Bdd_t *a0,
  Ddi_Bdd_t *a1,
  Ddi_Bdd_t *coneTop,
  Ddi_Bdd_t *coneMiddle,
  Ddi_Bdd_t *bwd0,
  Ddi_Bdd_t *bwd1,
  Ddi_Bdd_t *fwd0,
  Ddi_Bdd_t *fwd1,
  int maxIter,
  Ddi_Vararray_t *ps,
  Ddi_Vararray_t *ns,
  Ddi_Vararray_t *psAux,
  Ddi_Vararray_t *constrHintsVars,
  int noSplit,
  float timeLimit
)
{
  int sat_i=0;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  Ddi_Bdd_t *leftover = Ddi_BddMakeConstAig(ddm,1);
  Ddi_Bdd_t *itp = Ddi_BddMakeConstAig(ddm,0);
  int bTh = 1000, window = 8;
  int i, itpDone=0;
  Ddi_Vararray_t *myDomainA=NULL, *suppA;
  int useDomainA = 1;
  int doItp2 = 1;
  int doCoreFinal = useDomainA, doNnfAbstr=1;
  int removeCexVars = 1;
  int useIncrSatForCex=maxIter>0 && !noSplit;
  Ddi_IncrSatMgr_t *ddiS = NULL;
  float cexSuppReduceRatio = 0.5;
  Ddi_Bdd_t *aDup=NULL;
  Ddi_Bdd_t *bwdDup=NULL;
  Ddi_Mgr_t *ddmDup = NULL;
  Ddi_Vararray_t *residualVars = NULL;
  int cexWithGates = 0;
  int sat = 0, doOptBwd1=0, doOptBwd0=0;
  Ddi_Varset_t *nsVars  = Ddi_VarsetMakeFromArray(ns); 
  Ddi_Varset_t *psVars  = Ddi_VarsetMakeFromArray(ps); 
  long startTime, currTime;
  int useFwdRingAsConstr = 1;
  int timeLimitIncreased=0;
  
  if (coneTop!=NULL && Ddi_BddSize(coneTop)<bTh) {
    maxIter = 1;
  }
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;
  // ddm->settings.aig.aigCnfLevel = 1;

  Ddi_Bdd_t *myFrom = Ddi_BddSubstVars(from, ps, psAux);
  Ddi_Bdd_t *myA0 = Ddi_BddSubstVars(a0, ps, psAux);
  Ddi_Bdd_t *myBwd0 = Ddi_BddSubstVars(bwd0, ns, ps);
  if (useFwdRingAsConstr && fwd0!=NULL) {
    Ddi_BddPartInsertLast(myA0,fwd0);
  }
  Ddi_BddPartInsertLast(myA0,myFrom);
  Ddi_BddSubstVarsAcc(myA0, ns, ps);
  Ddi_BddAndAcc(leftover,myBwd0);
  if (useIncrSatForCex) {
    ddmDup = Ddi_MgrDup(ddm);
    ddiS = Ddi_IncrSatMgrAlloc(ddmDup, 1, 0, 0);
    aDup = Ddi_BddCopy(ddmDup,myA0);
    DdiAig2CnfIdInit(ddmDup);
    Ddi_AigSatMinisatLoadClausesIncrementalAsserted(ddiS,aDup);
    Ddi_IncrSatMgrLockAig(ddiS,aDup);
  }

  int doSingleItp=0;
  int doConstrSubset=1;
  int doSubsetStateA0A1=1;
  float bwdTimeLimit = -1;

  if (doSubsetStateA0A1) {
    doConstrSubset=0;
    maxIter = 8;
    bwdTimeLimit = 2*(float)Ddi_MgrReadAigSatTimeLimit(ddm);
    //   bwdTimeLimit = (float)Ddi_MgrReadAigSatTimeLimit(ddm)/2;
  }

  if (doConstrSubset) {
    maxIter = 16;
  }
  if (doSingleItp) {
    maxIter = 1;
  }
  if(noSplit) {
    maxIter = 1;
    bwd1 = Ddi_BddMakeConstAig(ddm,1);
    a1 = Ddi_BddSubstVars(coneMiddle, ns, ps);
  }
  int tryAbstrA0 = -1; //3*maxIter/4+1;
  for (i=0; !itpDone && itp!=NULL && i<maxIter; i++) {
    Ddi_Bdd_t *b_i=NULL, *a_i=NULL, *itp_i=NULL;
    Ddi_Bdd_t *cube = NULL;
    int andWithLeftover = 0;
    int enCoreFinal = doCoreFinal;
    int doRefineBwd0 = 0;
    Ddi_Bdd_t *myA1 = Ddi_BddDup(a1);
    int canAbstrA0 = 0;
    int useFwdRing = 0;
    int cexUndef = 0;
    
    if (noSplit) {
      cube = Ddi_AigSatAndWithCexAndAbort(myA0, leftover,
             NULL, ps, -1, NULL);
      if (cube!=NULL) {
        doRefineBwd0 = 1;
        doOptBwd0 = 1;
      }
    }
    else if (0 && (i==maxIter-1)) {
      cube = Ddi_BddDup(myA0);
      andWithLeftover = 1;
      enCoreFinal = 0;
      useFwdRing = fwd0!=NULL;
      //      timeLimit = 2*(float)Ddi_MgrReadAigSatTimeLimit(ddm);
      timeLimit = (float)Ddi_MgrReadAigSatTimeLimit(ddm)/2;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nITP PART BY DOMAIN VARS Last iter [%d]\n", i);
      }
    }
    else if (tryAbstrA0>0 && i>=tryAbstrA0) {
      cube = Ddi_BddDup(myA0);
      andWithLeftover = 1;
      canAbstrA0 = 1;
      enCoreFinal = 0;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nITP PART BY DOMAIN VARS Last iter [%d]\n", i);
      }
    }
    else if (Ddi_BddIsOne(leftover)) {
      cube = Ddi_BddDup(myA0);
      enCoreFinal = 0;
      //      useFwdRing = 0||fwd0!=NULL;
    }
    else if (ddiS!=NULL) {
      int useFwdConstrCube = i <= 1 ? 1 : 3;
      Ddi_Bdd_t *leftoverDup = Ddi_BddCopy(ddmDup,leftover);
      Ddi_Bdd_t *myCheck = Ddi_BddDup(aDup);
      Ddi_Bdd_t *myCheck0=NULL;
      Ddi_Vararray_t *cubeVarsDup = Ddi_VararrayCopy(ddmDup,ps);
      Ddi_Bdd_t *fwdConstr=Ddi_BddDup(a1);
      Ddi_Bdd_t *fwdConstrDup=NULL;
      static int cntCalls=0;
      cntCalls++;
      if (doConstrSubset || doSubsetStateA0A1) {
        useFwdConstrCube = 1;
      }
      Ddi_BddPartInsertLast(fwdConstr,bwd1);
      fwdConstrDup = Ddi_BddCopy(ddmDup,fwdConstr);
      Ddi_BddSetPartConj(myCheck);
      Ddi_BddPartInsertLast(myCheck,leftoverDup);
      if (useFwdConstrCube) {
        myCheck0 = Ddi_BddDup(myCheck);
        Ddi_BddPartInsertLast(myCheck,fwdConstrDup);
      }
      Ddi_BddSetFlattened(myCheck);
      Ddi_Bdd_t *cubeDup;
      if (useFwdConstrCube > 2) {
        Ddi_Free(cubeVarsDup);
        Ddi_Vararray_t *a0Pis = Ddi_BddSuppVararray(a0);
        Ddi_VararrayDiffAcc(a0Pis,ps);
        Ddi_VararrayDiffAcc(a0Pis,ns);
        cubeVarsDup = Ddi_VararrayCopy(ddmDup,a0Pis);
        Ddi_Free(a0Pis);
      }
      else if (useFwdConstrCube > 1) {
        Ddi_Vararray_t *noCube = cubeVarsDup;
        cubeVarsDup = Ddi_BddSuppVararray(fwdConstrDup);
        Ddi_VararrayDiffAcc(cubeVarsDup,noCube);
        Ddi_Free(noCube);
      }
      if (doConstrSubset) {
        float subsetRatio = 1/(float)((i+2)*(i+2));
        if (i>2*maxIter/3) subsetRatio /= (i+2);
        cubeDup = Ddi_AigSatMinisat22SubsetWithCexIncremental(
          ddiS,myCheck, aDup, subsetRatio, 0, -1, NULL,ddm);
        enCoreFinal = 0;
        andWithLeftover = 1;
      }
      else {
        if (doSubsetStateA0A1) {
          Ddi_Free(cubeVarsDup);
          if (constrHintsVars!=NULL)
            cubeVarsDup = Ddi_VararrayCopy(ddmDup,constrHintsVars);
          else 
            cubeVarsDup = Ddi_VararrayCopy(ddmDup,ps);
        }
        cubeDup = Ddi_AigSatMinisat22WithCexAndAbortIncremental(
                ddiS,myCheck, cubeVarsDup, 0, -1, NULL);
      }
      if (cubeDup!=NULL) {
        cube = Ddi_BddCopy(ddm,cubeDup);
        if (useFwdConstrCube > 2) {
          Ddi_Bdd_t *newCube = Ddi_BddDup(myA0);
          Ddi_AigConstrainCubeAcc(newCube,cube);
          Ddi_Free(cube);
          cube = newCube;
          Ddi_BddSetFlattened(cube);
          enCoreFinal = 0;
          andWithLeftover = 1;
        }
        else if (useFwdConstrCube > 1) {
          Ddi_AigConstrainCubeAcc(fwdConstr,cube);
          Ddi_Free(cube);
          cube = Ddi_BddDup(myA0);
          Ddi_BddPartInsertLast(myA0,fwdConstr);
          Ddi_BddSetFlattened(cube);
          enCoreFinal = 0;
          andWithLeftover = 1;
        }
      }
      else {
        cubeDup = Ddi_AigSatMinisat22WithCexAndAbortIncremental(ddiS,
                myCheck0, cubeVarsDup, 0, 2*bwdTimeLimit, &cexUndef);
        if (cubeDup!=NULL) {
          Ddi_Free(cubeDup);
          doRefineBwd0 = 1;
        }
      }
      Ddi_IncrSatMgrLockAig(ddiS,leftoverDup);
      Ddi_IncrSatMgrLockAig(ddiS,fwdConstrDup);
      Ddi_Free(fwdConstr);
      Ddi_Free(fwdConstrDup);
      Ddi_Free(myCheck0);
      Ddi_Free(myCheck);
      Ddi_Free(cubeDup);
      Ddi_Free(leftoverDup);
      Ddi_Free(cubeVarsDup);
    }
    else {
      cube = Ddi_AigSatAndWithCexAndAbort(myA0, leftover,
             NULL, ps, 2*bwdTimeLimit, &cexUndef);
    }

    itp_i = NULL;
    if (doRefineBwd0) {
      itp_i = Ddi_BddMakeConstAig(ddm,1);
      Ddi_Free(cube);
      cube = Ddi_BddDup(myA0);
      itpDone = 1;
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("\nITP PART BY DOMAIN VARS ended [%d]: refinig BWD cone\n", i);
      }
    }
    else if (cube==NULL) {
      if (cexUndef) {
        i=maxIter-2;
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("\nITP PART BY DOMAIN VARS undef [%d]\n", i);
        }
        Ddi_Free(myA1);
        continue;
      }
      else {
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("\nITP PART BY DOMAIN VARS ended [%d]: NO leftover\n", i);
        }
        itpDone = 1;
        Ddi_Free(myA1);
        break;
      }
    }
    else {
      if (i==maxIter-1) {
        cube = Ddi_BddDup(myA0);
        andWithLeftover = 1;
        enCoreFinal = 0;
        useFwdRing = fwd0!=NULL;
        //      timeLimit = 2*(float)Ddi_MgrReadAigSatTimeLimit(ddm);
        if (!timeLimitIncreased)
          timeLimit = (float)Ddi_MgrReadAigSatTimeLimit(ddm)*2;
      }
      if (0 && useFwdRing) {
        int nTry = 16, partial = 1;
        Ddi_Bdd_t *fwdR = fwd0 !=NULL ?
          Ddi_BddSubstVars(fwd0,ns,ps):Ddi_BddMakeConstAig(ddm,1);
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("doing cone subsetting: %d iterations - fwdR: %d\n\n", nTry, Ddi_BddSize(fwdR));
        }
        Ddi_Bdd_t *myCone = Ddi_BddDup(myA1);
        Ddi_BddSetPartConj(myCone);
        Ddi_BddPartInsertLast(myCone,coneTop);
        for (int i=0; i<nTry; i++) {
          Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
            printf("\nmiddle cone subsetting iter: %d\n", i);
          }
          Ddi_Bdd_t *c = Ddi_AigSatAndWithCexAndAbort(myCone, fwdR,
                           NULL, ns, -1, NULL);
          if (c==NULL) {
            Ddi_Free(cube);
            cube = Ddi_BddMakeConstAig(ddm,1);
            Ddi_Free(myCone);
            partial = 0;
            break;
          }
          Ddi_Bdd_t *aux = Ddi_BddDup(myA0);
          Ddi_BddSetPartConj(aux);
          Ddi_BddPartInsertLast(aux,myA1);
          int doGen = 1;
          int nc = (Ddi_BddSize(c)+1)/2;
          int r = Ddi_AigSatMinisat22WithAbortAndFinal(aux,c,doGen, bwdTimeLimit);
          Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
            printf("\ncube generalization: %d -> %d\n", nc, (Ddi_BddSize(c)+1)/2);
          }
          Ddi_Free(aux);
          int mySat;
          Ddi_Bdd_t *myConeIntern = Ddi_BddDup(myA1);
          Ddi_AigAndCubeAcc(myConeIntern,c);
          Ddi_Free(c);
	  Ddi_Bdd_t *cut = Ddi_AigSat22AndWithInterpolant(NULL,
                 myA0,myConeIntern,NULL/*bAbstr*/,
                 psVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
                 &mySat, 0, 1, 0, -1.0);
          Ddi_Free(myConeIntern);
          if (cut==NULL) {
            break;
          }
          Ddi_BddAndAcc(fwdR,cut);
          Ddi_BddNotAcc(fwdR);
          if (Ddi_AigSatAnd(myA0,fwdR,NULL)) {
            printf("ooo\n");
          }
          Ddi_BddNotAcc(fwdR);
          int refineByItp = 0;
          if (refineByItp) {
            int mySat1;
            Ddi_Bdd_t *bAux = Ddi_BddNot(fwdR);
            Ddi_Bdd_t *itpRef = Ddi_AigSat22AndWithInterpolant(NULL,
                 myA0,bAux,NULL/*bAbstr*/,
                 psVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
                 &mySat1, 0, 1, 0, -1.0);
            Ddi_AigOptByMonotoneCoreAcc(itpRef,myA0,NULL,1,-1.0);
            int doReplace = Ddi_BddSize(itpRef) < Ddi_BddSize(fwdR)*1.1;
            if (doReplace)
              Ddi_DataCopy(fwdR,itpRef);
            Ddi_Free(bAux);
            Ddi_Free(itpRef);
          }
          else 
            Ddi_AigOptByMonotoneCoreAcc(fwdR,myA0,NULL,1,-1.0);
          Ddi_Free(cut);
        }
        Ddi_Free(myCone);
        Ddi_BddAndAcc(cube,fwdR);
        Ddi_Free(fwdR);
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("\ncone subsetting done - %s\n\n",
                 partial ? "partial":"complete");
        }
      }
      b_i = Ddi_BddDup(coneTop); 
      a_i = Ddi_BddDup(myA1);
      if (doSingleItp) {
        Ddi_BddAndAcc(b_i,bwd1);
      }
      else {
        Ddi_BddPartInsertLast(a_i,bwd1);
      }
      if (doSubsetStateA0A1) {
        Ddi_BddPartInsertLast(a_i,myA0);
        Ddi_BddPartInsertLast(a_i,leftover);
      }
      Ddi_BddSetFlattened(a_i);
      sat_i = 0;
      if (enCoreFinal && !Ddi_BddIsOne(cube)) {
        Ddi_Bdd_t *aux = Ddi_BddDup(a_i);
        Ddi_BddSetPartConj(aux);
        Ddi_BddPartInsertLast(aux,b_i);
	startTime = util_cpu_time();
	Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	  printf("Finding CEX core: %d -> ", Ddi_BddSize(cube)/2-1);
	}
	int doGen = 1 && i>1; // performance problem
        int r = Ddi_AigSatMinisat22WithAbortAndFinal(aux,cube,doGen, bwdTimeLimit);
	currTime = util_cpu_time() - startTime;
        if (r<0) {
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    printf("UNDEF - time: %s\n", util_print_time (currTime));
	  }
          sat_i = -1;
        }
        else if (r>0) {
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    printf("SAT - time: %s\n", util_print_time (currTime));
	  }
          sat_i = 1;
        }
        else {
          if (0 && !doGen)
            r = Ddi_AigSatMinisat22WithAbortAndFinal(aux,cube,doGen,-1.0);
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    printf("%d - time: %s\n", Ddi_BddSize(cube)/2+1, 
		 util_print_time (currTime));
	  }
          Ddi_AigAndCubeAcc(a_i,cube);
        }
        Ddi_Free(aux);
      }
      else {
        Ddi_BddPartInsertLast(a_i,cube);
        if (andWithLeftover) {
          Ddi_BddPartInsertLast(a_i,leftover);
        }
        Ddi_BddSetFlattened(a_i);
      }
      
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        Ddi_Varset_t *cSupp = Ddi_BddSupp(cube);
        printf("\nITP PART BY %d/%d DOMAIN VARS [iter: %d]\n",
               Ddi_VarsetNum(cSupp), Ddi_VararrayNum(ps), i);
        Ddi_Free(cSupp);
      }
      
      if (!sat_i) {
        int saveItpNnfAbstrAB = ddm->settings.aig.itpNnfAbstrAB;
        // ddm->settings.aig.itpNnfAbstrAB = 0; // k==0?1:3;
	Ddi_Bdd_t *bAbstr = canAbstrA0 ? cube : NULL;
	int myTimeLimit = canAbstrA0 ? 120 : timeLimit;
	// int myTimeLimit = 10;
	int again = 0, j=0;
	itp_i = NULL;
	do {
	  Ddi_Bdd_t *itp_i_j;
	  again = 0;
          Ddi_Bdd_t *fwdCare = Ddi_BddMakeConstAig(ddm,1); 
          if (0 && useFwdRingAsConstr && fwd1!=NULL) {
            Ddi_BddAndAcc(fwdCare,fwd1);
          }
          int tryAppr = 0 && (i==maxIter-1);
          if (tryAppr) {
            Ddi_Vararray_t *vA = Ddi_BddSuppVararray(bwd1);
            DdiAigVararraySortByFlow(vA,bwd1);
            int maxv = 10, npart=4;
            for (int j=0; j<npart; j++) {
              int start = (j*maxv)/2;
              Ddi_Varset_t *supp = Ddi_VarsetVoid(ddm); 
              for (int i=start; i<start+maxv&&i<Ddi_VararrayNum(vA); i++)
                Ddi_VarsetAddAcc(supp,Ddi_VararrayRead(vA,i));
              int nIter = 1<<maxv;
              if (Ddi_VarsetNum(supp)>maxv/2) {
                Ddi_Bdd_t *toAppr = Ddi_BddMakeAig(a_i);
                Ddi_AigProjectAllSolutionImgAcc (toAppr,supp,bwd1,nIter,1/*unused*/);
                // Ddi_AigExistProjectAllSolutionAcc(toAppr, supp, bwd1, nIter);
                //            Ddi_AigProjectRefineOutImgAcc(toAppr, supp, bwd1,
                //                        mIter, 2);
                Ddi_BddAndAcc(fwdCare,toAppr);
                Ddi_Free(toAppr);
              }
              Ddi_Free(supp);
            }
            Ddi_Free(vA);
            startTime = util_cpu_time();
            int sat1 = Ddi_AigSatAnd(a_i,b_i,fwdCare);
            currTime = util_cpu_time() - startTime;
            Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
              printf("SAT-AND with care - time: %s\n", util_print_time (currTime));
            }
            startTime = util_cpu_time();
            int sat2 = Ddi_AigSatAnd(a_i,b_i,NULL);
            currTime = util_cpu_time() - startTime;
            Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
              printf("SAT-AND NO care - time: %s\n", util_print_time (currTime));
            }
          }
          if (!Ddi_BddIsOne(fwdCare)) {
            Ddi_Bdd_t *a_iConstr = Ddi_BddAnd(a_i,fwdCare);
            itp_i_j = Ddi_AigSat22AndWithInterpolant(NULL,b_i,a_iConstr,NULL/*bAbstr*/,
                 nsVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
                 &sat_i, 0, 1, 0, myTimeLimit);
            if (itp_i_j!=NULL) {
              Ddi_Bdd_t*aux = Ddi_AigSat22AndWithInterpolant(NULL,b_i,a_i,NULL/*bAbstr*/,
                 nsVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
                 &sat_i, 0, 1, 0, myTimeLimit);
              Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
                printf("itp with care: %d - no care: %d\n", Ddi_BddSize(itp_i_j),
                       Ddi_BddSize(aux));
              }
              // Ddi_BddNotAcc(fwdCare);
              // Ddi_BddOrAcc(itp_i_j,fwdCare);
              Ddi_Free(aux);
            }
            Ddi_Free(a_iConstr);
          }
          else  {
            int saveItpNnfAbstrAB = ddm->settings.aig.itpNnfAbstrAB;
            ddm->settings.aig.itpNnfAbstrAB = 1; // just B
            itp_i_j = Ddi_AigSat22AndWithInterpolant(NULL,a_i,b_i,NULL/*bAbstr*/,
                 nsVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
                 &sat_i, 0, 1, 0, myTimeLimit);
            if (sat_i<0) {
              Ddi_Bdd_t *constrFull = itp_i_j;
              Ddi_Bdd_t *constrA1 = Ddi_BddPartFilter (constrFull,a1);
              Ddi_Bdd_t *constrA0 = Ddi_BddPartFilter (constrFull,a0);
              int abort;
              int doA=1, doB=0;
              Ddi_Bdd_t *one = Ddi_BddMakeConstAig(ddm,1); 
              int again = 0;
              if (Ddi_BddPartNum(constrA0)>0 && doA) {
                do {
                  Ddi_Bdd_t *constrZero = Ddi_AigSatMinisat22RemoveCoreFinal(one,constrA0,
                                                                      1,(double)timeLimit,&abort);
                  again = 0;
                  if (constrZero!=NULL && Ddi_BddPartNum(constrZero)>0) {
                    for (int i=1; i<Ddi_BddPartNum(constrZero); i++) {
                      Ddi_BddPartInsertLast(constrA0,Ddi_BddPartRead(constrZero,i));
                    }
                    again = 1;
                  }
                  Ddi_Free(constrZero);
                } while (again);
                do {
                  Ddi_Bdd_t *constrFinal = Ddi_AigSatMinisat22RemoveCoreFinal(a_i,constrA0,
                                                                      1,(double)timeLimit,&abort);
                  again = 0;
                  if (constrFinal!=NULL && Ddi_BddPartNum(constrFinal)>0) {
                    for (int i=1; i<Ddi_BddPartNum(constrFinal); i++) {
                      Ddi_BddPartInsertLast(constrA0,Ddi_BddPartRead(constrFinal,i));
                    }
                    again = 1;
                  }
                  Ddi_Free(constrFinal);
                } while (again);
                Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
                  printf("\nRECOMPUTING ITP with A constraint of size %d and %d partitions\n",
                         Ddi_BddSize(constrA0), Ddi_BddPartNum(constrA0));
                }

                Ddi_BddSetAig(constrA0);
                Ddi_BddPartInsertLast(a_i,constrA0);
                Ddi_BddSetAig(cube);
                Ddi_BddAndAcc(cube,constrA0);
              }

              if (Ddi_BddPartNum(constrA1)>0 && doB) {
                do {
                  Ddi_Bdd_t *constrZero = Ddi_AigSatMinisat22RemoveCoreFinal(one,constrA1,
                                                                      1,(double)timeLimit,&abort);
                  again = 0;
                  if (constrZero!=NULL && Ddi_BddPartNum(constrZero)>0) {
                    for (int i=1; i<Ddi_BddPartNum(constrZero); i++) {
                      Ddi_BddPartInsertLast(constrA1,Ddi_BddPartRead(constrZero,i));
                    }
                    again = 1;
                  }
                  Ddi_Free(constrZero);
                } while (again);
                Ddi_Bdd_t *constrFinal = Ddi_AigSatMinisat22RemoveCoreFinal(a_i,constrA1,
                                                                      1,(double)timeLimit,&abort);
                if (constrFinal!=NULL) {
                  Ddi_Bdd_t *myA = Ddi_BddDup(myA0);
                  Ddi_Bdd_t *myB = Ddi_BddDup(myA1);
                  Ddi_BddSetPartConj(myA);
                  Ddi_BddSetPartConj(myB);
                  Ddi_BddPartInsertLast(myB,bwd1);
                  Ddi_BddPartInsertLast(myB,constrFinal);
                  Ddi_BddPartInsertLast(myA,leftover);
                  Ddi_BddSetFlattened(myA);
                  Ddi_BddSetFlattened(myB);
                  Ddi_Bdd_t *itp0Aux = Ddi_AigSat22AndWithInterpolant(NULL,myA,myB,NULL/*bAbstr*/,
                                                                      psVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
                                                                      &sat_i, 0, 1, 0, myTimeLimit);
                  if (itp0Aux != NULL) {
                  }
                  Ddi_Free(itp0Aux);
                  Ddi_Free(myA);
                  Ddi_Free(myB);
                }
              }
              itp_i_j = Ddi_AigSat22AndWithInterpolant(NULL,a_i,b_i,NULL/*bAbstr*/,
                 nsVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
                 &sat_i, 0, 1, 0, -1);
              Ddi_Free(one);
              Ddi_Free(constrFull);
              Ddi_Free(constrA0);
              Ddi_Free(constrA1);
              maxIter+=2;
              timeLimitIncreased = 1;
              bwdTimeLimit *= 1.1;
              timeLimit *= 1.1;
              //              i--; // repeat - now correct
            }
            ddm->settings.aig.itpNnfAbstrAB = saveItpNnfAbstrAB; // just B
            if (itp_i_j != NULL) {
              Ddi_BddNotAcc(itp_i_j);
            }
          }
          Ddi_Free(fwdCare);
	  if (itp_i_j == NULL) {
	    Ddi_Free(itp_i);
	  }
	  else {
	    if (itp_i==NULL)
	      itp_i = Ddi_BddDup(itp_i_j);
	    else
	      Ddi_BddOrAcc(itp_i,itp_i_j);
	    if (canAbstrA0 && !Ddi_BddIncluded(b_i,itp_i_j)) {
	      Ddi_BddDiffAcc(b_i,itp_i_j);
	      myTimeLimit *= 2;
	      again = 1;
	    }
	    Ddi_Free(itp_i_j);
	  }
	  j++;
	} while (again);
	ddm->settings.aig.itpNnfAbstrAB = saveItpNnfAbstrAB;
        if (itp_i==NULL) {
          sat_i = 1;
        }
      }
    }

    if (itp_i!=NULL) {
      int size0 = Ddi_BddSize(bwd1);
      if (doSingleItp) {
        Ddi_DataCopy(bwd1,itp_i);
      }
      else { 
        Ddi_BddAndAcc(bwd1,itp_i);
      }
      Ddi_Bdd_t *b_0 = Ddi_BddDup(myA1);
      doOptBwd1 = Ddi_BddSize(bwd1)/(float)size0 > 1.05;
      Ddi_BddAndAcc(b_0,bwd1);
      Ddi_BddSetAig(cube);
      //Ddi_Bdd_t *a_0 = Ddi_BddDiff(leftover,cube);
      //      Ddi_BddNotAcc(a_0);
      Ddi_Bdd_t *a_0 = Ddi_BddAnd(leftover,cube);
      Ddi_Bdd_t *itp_i0;
      int doItp=!Ddi_BddIsCube(cube);
      if (doSubsetStateA0A1) {
        Ddi_BddSetPartConj(a_0);
        Ddi_BddPartInsertLast(a_0,myA0);
        Ddi_BddSetFlattened(a_0);
        doItp=1;
      }
      if (doItp) {
        int saveItpNnfAbstrAB = ddm->settings.aig.itpNnfAbstrAB;
        ddm->settings.aig.itpNnfAbstrAB = 1; // just B
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("\nITP PART BY DOMAIN VARS - refining BWD0 by ITP (%d)\n",
                 Ddi_BddSize(bwd0));
        }
        itp_i0 = Ddi_AigSat22AndWithInterpolant(NULL,a_0,b_0,NULL,
                  psVars, NULL,NULL,0,NULL/*bwdCare*/,NULL,
                  //          &sat_i, 0, 1, 0, 10*timeLimit);
                  &sat_i, 0, 1, 0, -1);

        ddm->settings.aig.itpNnfAbstrAB = saveItpNnfAbstrAB; // just B
	if (itp_i0==NULL)
	  sat_i = 0;
        else {
          Ddi_BddNotAcc(itp_i0);
          if (Ddi_BddSize(itp_i0)>50000)
            doOptBwd0 = 1;
        }
      }
      else {
        itp_i0 = Ddi_BddNot(a_0);
        doOptBwd0 = 1;
      }
      if (itp_i0 != NULL) {
        Ddi_BddAndAcc(leftover,itp_i0);
        //        Ddi_Free(leftover);
        // leftover = Ddi_BddDup(itp_i0);
        Ddi_DataCopy(myBwd0,leftover);
        Ddi_Free(itp_i0);
      }
      Ddi_Free(a_0);
      Ddi_Free(b_0);
    }

    if (sat_i<0) {
      i=maxIter-2;
    }
    else if (sat_i>0) {
      sat = sat_i;
      Ddi_Free(itp);
      itp = NULL;
      itpDone = 1;
      doOptBwd0 = 0;
      doOptBwd1 = 0;
    }
    Ddi_Free(myA1);
    Ddi_Free(a_i);
    Ddi_Free(b_i);
    Ddi_Free(cube);
    Ddi_Free(itp_i);
    
  }
  if (itp==NULL) {
    sat = 1;
  }

  if (doOptBwd1) {
    float optTimeLimit = (float)Ddi_MgrReadAigSatTimeLimit(ddm)*2;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nITP PART BY DOMAIN VARS - refining BWD1 (%d)\n",
             Ddi_BddSize(bwd1));
    }
    Ddi_AigOptByMonotoneCoreAcc(bwd1,coneTop,NULL,1,optTimeLimit);
  }
  if (doOptBwd0) {
    Ddi_Bdd_t *b_0 = Ddi_BddDup(a1);
    float optTimeLimit = (float)Ddi_MgrReadAigSatTimeLimit(ddm)*2;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nITP PART BY DOMAIN VARS - refining BWD0 (%d)\n",
             Ddi_BddSize(myBwd0));
    }
    Ddi_BddAndAcc(b_0,bwd1);
    Ddi_AigOptByMonotoneCoreAcc(myBwd0,b_0,NULL,1,optTimeLimit);
    Ddi_Free(b_0);
  }
  Ddi_BddSubstVarsAcc(myBwd0, ps, ns);
  Ddi_DataCopy(bwd0,myBwd0);
  ddm->settings.aig.aigCnfLevel = aigCnfLevel;
  
  if(noSplit) {
    Ddi_Free(bwd1);
    Ddi_Free(a1);
  }
  Ddi_Free(itp);
  Ddi_Free(myBwd0);
  Ddi_Free(nsVars);
  Ddi_Free(psVars);
  Ddi_Free(myFrom);
  Ddi_Free(myA0);
  Ddi_Free(residualVars);
  Ddi_Free(aDup);
  Ddi_IncrSatMgrQuit(ddiS);
  Ddi_Free(leftover);
  Ddi_Free(myDomainA);
  return sat;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
setupCexWithGates(
  Ddi_Bdd_t *cex,
  Ddi_Bddarray_t *gates,
  float ratio
)
{
  int reversed = ratio<0;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cex);
  ratio = fabs(ratio);
  if (gates == NULL || Ddi_BddarrayNum(gates) == 0)
    return;
  ratio = ratio*ratio;
  Ddi_Bddarray_t *gateConstr=Ddi_BddarrayDup(gates);
  Ddi_Bdd_t *newCex = Ddi_BddMakeConstAig(ddm,1); 
  Ddi_AigarrayConstrainCubeAcc(gateConstr,cex);  
  int bound = ratio*Ddi_BddarrayNum(gateConstr);
  if (ratio < 0.01) bound = Ddi_BddarrayNum(gateConstr)>1?2:1;
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    printf("\ncex to gates is using %d/%d gates\n", bound,
           Ddi_BddarrayNum(gateConstr));
  }
  for (int ii=0; ii<bound; ii++) {
    int i = reversed ? Ddi_BddarrayNum(gateConstr)-1-ii : ii;
    Ddi_Bdd_t *c_i = Ddi_BddarrayRead(gateConstr,i);
    if (Ddi_BddIsConstant(c_i)) {
      Ddi_Bdd_t *c =Ddi_BddarrayRead(gates,i);
      if (Ddi_BddIsZero(c_i))
        Ddi_BddDiffAcc(newCex,c);
      else
        Ddi_BddAndAcc(newCex,c);
    }
  }
  Ddi_DataCopy(cex,newCex);
  Ddi_Free(newCex);
}

/**Function********************************************************************
  Synopsis    [Satisfiability Check on a&b with interpolant generation]
  Description [Satisfiability Check on a&b with interpolant generation.
               Sat solver is called on conjunction of a and b. If problem is
               Satisfiable ((psat=1), counterexample is returned. Otherwise,
               (*psat=0) interpolant (based on McMillan CAV2003 paper),
               is built and returned.
               This routine assumes that common variables of a and b parameters
               are passed (as variable set) on globalVars parameter).
              ]
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
itpImgPart (
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * kCone,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t *a,
  Ddi_Bdd_t *b,
  Ddi_Bdd_t *prevTo,
  int step,
  int doSplit,
  Ddi_Varset_t *globalVars,
  Ddi_Varset_t *domainVars,
  Ddi_Bdd_t *optCare,
  Ddi_Bdd_t *itpPlus,
  Ddi_Bdd_t *toPlusCube,
  int *psat,
  int itpPart,
  int itpOdc,
  float timeLimit
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(a);
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  int i, chkresSat=0, chkincr=0, 
    chkres = 0, thVars = itpPart>8 ? 8*itpPart : 1<<itpPart;
  int tryCexCore = 0;
  int doForall = 0;
  long startTime, cexTime, itpTime;
  int mark = Ddi_BddReadMark(b);
  int isSat=0, preSplit=1;
  int nnfSubset = 0, genClauses=0;
  int genCubes = 1;
  int doItpFromGenClauses = 0;
  int doItpFromGenClausesAux = 0;
  int doItpStrengthen = 0;
  Ddi_Bdd_t *itp_i=NULL, *itpTot = NULL;
  Ddi_Bdd_t *careTot = NULL, *careTotSplit = NULL, *toMinusSplit=NULL;
  Ddi_Bdd_t *careTotForCex =  NULL, *careFinal = NULL,
    *careTotForA=NULL, *careForPreimg=NULL;
  Ddi_Bdd_t *bDup = NULL;

  Ddi_Bdd_t *splitB = NULL, *splitRel = NULL, *splitRel2 = NULL, 
    *splitCare = NULL, *splitConstr = NULL;
  Ddi_Vararray_t *piAux = NULL;
  Ddi_Vararray_t *splitVaux = NULL;
  Ddi_Vararray_t *splitVaux2 = NULL;
  Ddi_Vararray_t *splitV2 = NULL;
  Ddi_Bddarray_t *splitU = NULL;
  Ddi_Vararray_t *splitV = NULL;
  Ddi_Vararray_t *splitRefV;
  Ddi_Varset_t *splitVars = NULL;
  Ddi_Bdd_t *itpNextRing = NULL;
  int itpPartTh = Ddi_MgrReadAigItpPartTh(ddm);
  int doSplit2 = 0 && (doSplit/2);
  int doSplitCare = 0, doFwdBwd = 0;
  int enLowerBoundk = 0;
  Ddi_Vararray_t **tfPiVars = itpMgr->timeFrames->PiVars;
  int tfPiNum =  itpMgr->timeFrames->Num;
  int andWithRing_i = -1;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int useRingConstr = growCone != 1 ? 2 : 0;
  static int nCalls=0;
  int enFwdCare = 0;
  int fullK = step+mark;
  int safe = Trav_ItpMgrReadConeBoundOK(itpMgr,step);
  int split_i = step+doSplit;
  int dLB = doSplit/2;
  int genNextRing = 1;
  int incrementalSat = 1;
  Ddi_IncrSatMgr_t *ddiS = NULL;
  int enPartA = 0, enDisjDecomp = itpTravMgr->observedGates==NULL;
  int completeOnSplit = 1;
  float itpRefTime = 100; // 10; // -1.0;
  int doFixedPart = 1;
  int checkStall = 0;
  int cexWithGates = 16; //itpPart*2;
  
  if (dLB>4) dLB=4;

  nCalls++;
  int tryIncrSat = 0;
  if (tryIncrSat && itpTravMgr->incrSat==NULL) {
    Ddi_Mgr_t *ddmDup = Ddi_MgrDup(ddm);
    itpTravMgr->incrSat =
      Ddi_IncrSatMgrAlloc(ddmDup, -1/*lgl*/, 0, 0);
    DdiAig2CnfIdInit(ddmDup);
  }

  if (0 && optCare!=NULL && Ddi_BddSize(optCare)> 100) {
    if (1 && Ddi_BddSize(b) > 10) {
      //      DdiAigRedRemovalControlAcc(b, optCare, 10, 30.0);
      if (!Ddi_AigSatConstrain(b,optCare,-1.0, NULL))
        return Ddi_BddDup(optCare);
    }
  }
  
  if (itpTravMgr->imgPartVars != NULL && itpMgr->hints.hintsEnabled) {
    Ddi_Bdd_t *a0, *a1, *b0, *b1, *a00, *a01,
      *itpPlus0=NULL, *itpPlus1=NULL, 
      *optCare0=NULL, *optCare1=NULL, 
      *itp0=NULL, *itp00=NULL, *itp01=NULL, *itp1=NULL, *itp=NULL;
    int iConstr0 = itpMgr->hints.invar0_i;
    int sat0=0, sat1=0;
    Ddi_Var_t *cvar0Ns = Ddi_VararrayRead(itpMgr->ns,iConstr0); 
    Ddi_Var_t *cvar0Ps = Ddi_VararrayRead(itpMgr->ps,iConstr0); 
    Ddi_Vararray_t *savePartVars = itpTravMgr->imgPartVars;
    int prevImgOk = 0, prevImgSafe = 0;
    Ddi_Bdd_t *deltaConstr0 = Ddi_BddarrayRead(itpMgr->delta,iConstr0); 
    int enNo10 = 1 && step>1 && !Ddi_BddIsZero(deltaConstr0);
    itpTravMgr->imgPartVars = NULL;
    a0 = Ddi_BddCofactor(a,cvar0Ns,0);
    a00 = Ddi_BddCofactor(a0,cvar0Ps,0);
    a01 = Ddi_BddCofactor(a0,cvar0Ps,1);
    b0 = Ddi_BddCofactor(b,cvar0Ns,0);
    a1 = Ddi_BddCofactor(a,cvar0Ns,1);
    b1 = Ddi_BddCofactor(b,cvar0Ns,1);

    if (enNo10) {
      int chk10 = 1;
      if (chk10) {
	Ddi_Bdd_t *a10 = Ddi_BddCofactor(a1,cvar0Ps,0); // no 0 -> 1 edge in tr
	//      Ddi_BddAndAcc(a10,b1);
	Ddi_Bdd_t *cex = Ddi_AigSatWithCex(a10);
	if (cex!=NULL) {
	  Ddi_Free(cex);
	}
	Ddi_Bdd_t *a11 = Ddi_BddCofactor(a1,cvar0Ps,1); // no 1 -> 1 edge in tr
	if (!Ddi_AigSat(a11)) {
	  printf("not sat a11 (within prev hint space)\n");
	}
	Ddi_Free(a10);
	Ddi_Free(a11);
      }
      
      //      Ddi_BddCofactorAcc(a1,cvar0Ps,1); // no 0 -> 1 edge in tr
    }
    if (itpPlus!=NULL) {
      itpPlus0 = Ddi_BddCofactor(itpPlus,cvar0Ns,0);
      itpPlus1 = Ddi_BddCofactor(itpPlus,cvar0Ns,1);
    }
    if (optCare!=NULL) {
      optCare0 = Ddi_BddCofactor(optCare,cvar0Ns,0);
      optCare1 = Ddi_BddCofactor(optCare,cvar0Ns,1);
      prevImgOk = Ddi_BddIncluded(a1,optCare1);
      prevImgSafe = 0 && !Ddi_AigSatAnd(b1,optCare1,NULL);
    }
    if (psat!=NULL) *psat = 0;
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("\nITP IMG partitioned by hints ->1 (to prev hint space)\n");
    }
    if (prevImgOk && prevImgSafe) {
      itp1 = Ddi_BddDup(optCare1);
    }
    else if (!Ddi_AigSat(a1)) {
      itp1 = Ddi_BddMakeConstAig(ddm,0);
    }
    else {
      itp1 = itpImgPart (itpTravMgr,kCone,kConeRings,a1,b1,prevTo,
			 step,doSplit,globalVars,domainVars,optCare1,
			 itpPlus1,toPlusCube,&sat1,itpPart,itpOdc,timeLimit);
    }
    if (sat1) {
      if (psat!=NULL) *psat = sat1;
      itp = NULL;
    }
    else {
      //      Ddi_BddDiffAcc(a01,itp1);
      //      Ddi_BddDiffAcc(a00,itp1);
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("\nITP IMG partitioned by hints 1->0 (out from prev hint space)\n");
      }
      if (!Ddi_AigSat(a01)) {
	itp01 = Ddi_BddMakeConstAig(ddm,0);
      }
      else {
	itp01 = itpImgPart (itpTravMgr,kCone,kConeRings,a01,b0,prevTo,
			  step,doSplit,globalVars,domainVars,optCare0,
			   itpPlus0,toPlusCube,&sat0,itpPart,itpOdc,timeLimit);
      }
      if (sat0) {
	if (psat!=NULL) *psat = sat0;
	itp = NULL;
	Ddi_Free(itp1);
      }
    }
    if (itp01!=NULL) {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("\nITP IMG partitioned by hints 0->0 (within new hint, out of prev hint)\n");
      }
      if (!Ddi_AigSat(a00)) {
	itp00 = Ddi_BddMakeConstAig(ddm,0);
      }
      else {
	itp00 = itpImgPart (itpTravMgr,kCone,kConeRings,a00,b0,prevTo,
			   step,doSplit,globalVars,domainVars,optCare0,
			   itpPlus0,toPlusCube,&sat0,itpPart,itpOdc,timeLimit);
      }
      if (sat0) {
	if (psat!=NULL) *psat = sat0;
	itp = NULL;
	Ddi_Free(itp1);
	Ddi_Free(itp01);
      }
      else {
	itp0 = Ddi_BddOr(itp00,itp01);
      }
      Ddi_Free(itp00);
      Ddi_Free(itp01);
      if (itp0!=NULL) {
	static int chk=0;
	int doItePart = 1;
	Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(cvar0Ns, 1);
	//       	Ddi_BddOrAcc(itp0,itp1);
	if (doItePart) {
	  Ddi_Bdd_t *itp0Part = Ddi_AigPartitionTop(itp0,0);
	  Ddi_Bdd_t *itp1Part = Ddi_AigPartitionTop(itp1,0);
	  int i;
	  for (i=0; i<Ddi_BddPartNum(itp0Part); i++)
	    Ddi_BddOrAcc(Ddi_BddPartRead(itp0Part,i),lit);
	  Ddi_BddNotAcc(lit);
	  for (i=0; i<Ddi_BddPartNum(itp1Part); i++) {
	    Ddi_Bdd_t *p_i = Ddi_BddPartRead(itp1Part,i);
	    Ddi_BddOrAcc(p_i,lit);
	    Ddi_BddPartInsertLast(itp0Part,p_i);
	  }
	  Ddi_BddNotAcc(lit);
	  itp = Ddi_BddDup(itp0Part);
	  Ddi_Free(itp0Part);
	  Ddi_Free(itp1Part);
	}
	else {
	  itp = Ddi_BddIte(lit,itp1,itp0);
	}
	if (chk) {
	  Ddi_Bdd_t *itpChk = Ddi_BddMakeAig(itp);
	  if (!Ddi_BddIncluded(a,itpChk)) {
	    Ddi_Varset_t *psv = Ddi_VarsetMakeFromArray(itpMgr->ns);
	    Ddi_VarsetSetArray(psv);
	    Ddi_Bdd_t *d = Ddi_BddDiff(a,itpChk);
	    Ddi_Bdd_t *cex = Ddi_AigSatWithCex(d);
	    Ddi_BddExistProjectAcc(cex,psv);
	    Ddi_BddCofactorAcc(cex,cvar0Ns,0);
	    Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(cvar0Ns, 1);
	    Ddi_BddAndAcc(cex,lit);
	    Ddi_Free(d);
	    Ddi_Free(lit);
	    Ddi_Free(psv);
	    Ddi_Free(cex);
	  }
	  Pdtutil_Assert(Ddi_BddIncluded(a,itpChk),"unsound ITP");
	  if (0 && Ddi_AigSatAnd(b,itpChk,optCare)) {
	    Ddi_Varset_t *psv = Ddi_VarsetMakeFromArray(itpMgr->ns);
	    Ddi_VarsetSetArray(psv);
	    Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(b,
	      itpChk, optCare, NULL, 100, NULL);
	    Ddi_BddExistProjectAcc(cex,psv);
	    Ddi_BddCofactorAcc(cex,cvar0Ns,0);
	    Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(cvar0Ns, 1);
	    Ddi_BddAndAcc(cex,lit);
	    Ddi_Free(lit);
	    Ddi_Free(psv);
	    Ddi_Free(cex);
	  }
	  Pdtutil_Assert(!Ddi_AigSatAnd(b,itpChk,optCare),"wrong ITP");
	  Ddi_Free(itpChk);
	}
	Ddi_Free(lit);
      }
    }
    Ddi_Free(optCare0);
    Ddi_Free(optCare1);
    Ddi_Free(itpPlus0);
    Ddi_Free(itpPlus1);
    Ddi_Free(itp0);
    Ddi_Free(itp1);
    Ddi_Free(a00);
    Ddi_Free(a01);
    Ddi_Free(a0);
    Ddi_Free(b0);
    Ddi_Free(a1);
    Ddi_Free(b1);
    itpTravMgr->imgPartVars = savePartVars;
    return itp;
  }
  else if (itpTravMgr->imgPartVars != NULL) {
    int doIte = 1;
    int bTh = 1000, window = 8;
    int nPart = 4;
    int i, itpDone=0;
    if (Ddi_BddSize(b)>bTh) {
      int sat_i;
      Ddi_Bdd_t *leftover = Ddi_BddMakeConstAig(ddm,1);
      Ddi_Bdd_t *itp = Ddi_BddMakeConstAig(ddm,0);
      for (i=0; !itpDone && itp!=NULL && i<nPart-1; i++) {
	Ddi_Bdd_t *b_i, *a_i, *itp_i;
	Ddi_Bdd_t *cube = NULL, *seed = Ddi_BddDup(a);
	Ddi_Varset_t *supp = Ddi_BddSupp(b);
	Ddi_Varset_t *suppC = 
	  Ddi_VarsetMakeFromArray(itpTravMgr->imgPartVars);
	Ddi_Free(itpTravMgr->imgPartVars);
	Ddi_VarsetIntersectAcc(supp,suppC);
	Ddi_Free(suppC);
	if (prevTo!=NULL) {
	  Ddi_BddDiffAcc(seed,prevTo);
	}
	Ddi_BddDiffAcc(seed,itp);
	cube = Ddi_AigSatWithCex(seed);
	Ddi_Free(seed);
	if (cube==NULL) {
	  itpDone = 1;
	  Ddi_Free(supp);
	  Ddi_Free(cube);
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    printf("\nITP IMG ended [%d]: NO leftover\n", i);
	  }
	  break;
	}
	else {
	  if (Ddi_VarsetIsVoid(supp)) {
	    Ddi_Vararray_t *sA = Ddi_BddSuppVararray(cube);
	    while (Ddi_VararrayNum(sA) > window) {
	      int n = Ddi_VararrayNum(sA);
	      Ddi_VararrayRemove(sA,n-1);
	      Ddi_Free(supp); 
	      supp = Ddi_VarsetMakeFromArray(sA);
	      Ddi_Free(sA);
	    }
	  }
	  Ddi_Bdd_t *myCex = Ddi_BddDup(cube);
	  if (!Ddi_AigSatMinisatWithAbortAndFinal(b,myCex,-1.0,0)) {
	    Ddi_Varset_t *sm = Ddi_BddSupp(myCex);
	    Ddi_VarsetSetArray(sm);
	    Ddi_VarsetIntersectAcc(sm,supp);
	    if (Ddi_VarsetNum(sm)>window/2) {
	      Ddi_DataCopy(cube,myCex);
	    }
	    Ddi_Free(sm);
	  }
	  Ddi_Free(myCex);

	  Ddi_BddExistProjectAcc(cube,supp);
	}
	Ddi_Free(supp);
	b_i = Ddi_BddDup(b); 
	a_i = Ddi_BddDup(a); 
	if (doIte) {
	  Ddi_AigConstrainCubeAcc(b_i,cube);
	  Ddi_AigConstrainCubeAcc(a_i,cube);
	}
	else {
	  Ddi_AigAndCubeAcc(a_i,cube);
	}
	Ddi_BddDiffAcc(leftover,cube);

	Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	  printf("\nITP IMG partitioned by cube [%d]\n", i);
	  DdiLogBdd(cube,0);
	}

	itp_i = itpImgPart (itpTravMgr,kCone,kConeRings,a_i,b_i,prevTo,
			   step,doSplit,globalVars,domainVars,optCare,
			   itpPlus,toPlusCube,&sat_i,itpPart,itpOdc,timeLimit);
	if (sat_i) {
	  if (psat!=NULL) *psat = sat_i;
	  Ddi_Free(itp);
	  itp = NULL;
	  itpDone = 1;
	}
	else {
	  if (doIte) {
	    Ddi_BddAndAcc(itp_i,cube);
	  }
	  Ddi_BddOrAcc(itp,itp_i);
	}
	Ddi_Free(a_i);
	Ddi_Free(b_i);

	if (itp_i!=NULL) {
	  int j, nv;
	  Ddi_Vararray_t *suppA = Ddi_BddSuppVararray(itp_i);
	  DdiAigVararraySortByFanout(suppA,itp_i);
	  itpTravMgr->imgPartVars = Ddi_VararrayAlloc(ddm, 0);
	  nv = Ddi_VararrayNum(suppA);
#if 1
	  for (j=0; j<nv && j<window; j++)
#else
	  for (j=nv-1; j>=0 && j>=(nv-window); j--)
#endif
	  {
	    Ddi_Var_t *v = Ddi_VararrayRead(suppA,j);
	    Ddi_VararrayInsertLast(itpTravMgr->imgPartVars,v);
	  }
	  //	  Ddi_VararrayPrint(suppA);
	  Ddi_Free(suppA);
	}
	  
	Ddi_Free(itp_i);
	Ddi_Free(cube);
      }
      if (!itpDone) {
	Ddi_Bdd_t *itpLeft=NULL, 
	  *bLeft=NULL, *aLeft = Ddi_BddAnd(a,leftover);
	if (!Ddi_AigSat(aLeft)) {
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    printf("\nITP IMG partitioned: NO leftover\n");
	  }
	}
	else { 
	  int sat1;
	  Ddi_Vararray_t *save = itpTravMgr->imgPartVars; 
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    printf("\nITP IMG partitioned on cube leftover\n");
	  }
	  bLeft = Ddi_BddAnd(b,leftover);
	  itpTravMgr->imgPartVars = NULL;
	  itpLeft = itpImgPart (itpTravMgr,kCone,kConeRings,aLeft,bLeft,
				prevTo,
				step,doSplit,globalVars,domainVars,optCare,
				itpPlus,toPlusCube,&sat1,itpPart,itpOdc,
				timeLimit);
	  itpTravMgr->imgPartVars = save;
	  if (sat1) {
	    if (psat!=NULL) *psat = sat1;
	    itp = NULL;
	  }
	  else {
	    if (doIte) {
	      Ddi_BddAndAcc(itpLeft,leftover);
	    }
	    Ddi_BddOrAcc(itp,itpLeft);
	    if (psat!=NULL) *psat = 0;
	  }
	}
	Ddi_Free(aLeft);
	Ddi_Free(bLeft);
	Ddi_Free(itpLeft);

      }
      return itp;
    }
  }

  int freeA = 0;
  if (itpMgr->sccs.inCoreScc!=NULL) {
    Ddi_Bdd_t *a1 = Ddi_BddDup(a);
    Ddi_Bdd_t *a2 = Ddi_BddDup(a);
    Ddi_Vararray_t *psSmoothA1 = 
      Ddi_VararrayDiff(itpMgr->ps,itpMgr->sccs.inCoreScc);
    Ddi_Varset_t *nsSmooth1 = Ddi_VarsetMakeFromArray(psSmoothA1);
    Ddi_Vararray_t *psSmoothA2 = 
      Ddi_VararrayDup(itpMgr->sccs.inCoreScc);
    Ddi_Varset_t *nsSmooth2 = Ddi_VarsetMakeFromArray(psSmoothA2);
    Ddi_VarsetSubstVarsAcc(nsSmooth1,itpMgr->ps,itpMgr->ns);
    Ddi_VarsetSubstVarsAcc(nsSmooth2,itpMgr->ps,itpMgr->ns);
    Ddi_BddExistAcc(a1,nsSmooth1);
    //    Ddi_BddExistAcc(a2,nsSmooth2);
    int sat1 = Ddi_AigSatAnd(a1,b,optCare); 
    //    int sat2 = Ddi_AigSatAnd(a2,b,optCare); 
    if (!sat1) {
      printf("sound abstraction\n");
      Ddi_DataCopy(a,a1);
    }
    Ddi_Free(nsSmooth1);
    Ddi_Free(psSmoothA1);
    Ddi_Free(nsSmooth2);
    Ddi_Free(psSmoothA2);
    Ddi_Free(a1);
    Ddi_Free(a2);
    freeA = 1;
  }

  if (checkStall) {
    int i;
    Ddi_Bdd_t *myA = Ddi_BddDup(a); 
    Ddi_Bddarray_t *psLits = Ddi_BddarrayMakeLiteralsAig(itpMgr->ps, 1);
    Ddi_Bdd_t *myEq = Ddi_BddMakeEq(itpMgr->ns, psLits);
    if (prevTo!=NULL) Ddi_BddDiffAcc(myA,prevTo);
    prevTo = NULL;
    printf("CHECKING STALLED latches\n");
    Ddi_Bdd_t *eq =
      Ddi_AigInductiveImgPlus(myA, myEq, optCare,
			      NULL, 1 /*doInductiveToPlus*/);
    if (eq != NULL) {
      Ddi_Free(eq);
    }
    Ddi_Free(myEq);
    Ddi_Free(myA);
  }

  if (prevTo!=NULL && itpPart<=8) {
    static int compareWithItp=0;
    int usePrevToWithA = 1; int useCareWithA = 0;
    int usePrevToWithB = 0; int useCareWithB = 1;
    int useDontCare = 0;
    int tryPrevImgLearning = 0;
    Ddi_Bdd_t *aNew = Ddi_BddDup(a);
    Ddi_Bdd_t *bNew = Ddi_BddDup(b);
    Ddi_Bdd_t *careAig = NULL;
    Ddi_Bdd_t *coneAux=NULL, *itp=NULL;
    if (usePrevToWithA) {
      Ddi_BddDiffAcc(aNew,prevTo);
    }
    if (usePrevToWithB) {
      Ddi_BddDiffAcc(bNew,prevTo);
    }
    if (optCare!=NULL) {
      if (useCareWithA) {
        Ddi_BddAndAcc(aNew,optCare);
      }
      if (useCareWithB) {
        Ddi_BddAndAcc(bNew,optCare);
      }
    }
    if (itpPlus!=NULL) {
      if (useCareWithA) {
        Ddi_BddAndAcc(aNew,itpPlus);
      }
      if (useCareWithB) {
        Ddi_BddAndAcc(bNew,itpPlus);
      }
    }
    if (useDontCare) {
      careAig = Ddi_BddMakePartConjVoid(ddm);
      Ddi_BddNotAcc(prevTo);
      Ddi_BddPartInsertLast(careAig,prevTo);
      Ddi_BddNotAcc(prevTo);
      if (optCare!=NULL) {
        Ddi_BddPartInsertLast(careAig,optCare);
      }
      Ddi_BddSetAig(careAig);
      ddm->settings.aig.itpUseCare = 1;
    }
    printf("Computing ItpWithNew\n");
    if (0 && itpTravMgr->prevFrom!=NULL && 
	!Ddi_BddIsOne(itpTravMgr->prevFrom)) {
      Ddi_BddDiffAcc(aNew,itpTravMgr->prevFrom);
    }
    if (Ddi_BddSize(bNew)>1000) {
      //      ddm->settings.aig.itpNoQuantify = 1;
      if (tryPrevImgLearning &&
          (itpTravMgr->careForBwdCone != NULL)
          && !Ddi_BddIsConstant(itpTravMgr->careForBwdCone)) {
        Ddi_AigSatNnfAbstrPba(bNew,itpTravMgr->careForBwdCone,aNew,
                              itpMgr->ps,itpMgr->ns);
      }
    }
    //    ddm->settings.aig.itpNoQuantify = 10000;
    //    ddm->settings.aig.itpNoQuantify = 10;
    Ddi_Bdd_t *itpNew;
    int recurPart=1;
    if (recurPart) {
      itpNew = itpImgPart (itpTravMgr,kCone,kConeRings,
                         aNew,bNew,NULL,
                         step,doSplit,globalVars,domainVars,
                         careAig,
			 itpPlus,toPlusCube,psat,itpPart,itpOdc,
                         timeLimit);
      if (itpNew!=NULL && itpPlus!=NULL) {
        Ddi_BddAndAcc(itpNew,itpPlus);
      }
    }
    else {
      itpNew = Ddi_AigSat22AndWithInterpolant(
                                          itpTravMgr->incrSat,
                                          aNew,bNew,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  careAig,itpPlus,
					  psat, itpPart, itpOdc, 
					  0,timeLimit);
    }
    if (0 && tryPrevImgLearning &&
        (itpTravMgr->careForBwdCone != NULL)
        && !Ddi_BddIsConstant(itpTravMgr->careForBwdCone)) {
      Ddi_BddAndAcc(bNew,itpTravMgr->careForBwdCone);
      printf("Computing itpNew using extra learning: %d\n",
             Ddi_BddSize(itpTravMgr->careForBwdCone));
      Ddi_Bdd_t *itpNew2 = Ddi_AigSat22AndWithInterpolant(NULL,
                                          aNew,bNew,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  careAig,itpPlus,
					  psat, itpPart, itpOdc, 
					  0,timeLimit);
      printf("Computed itpNew using extra learning\n");
      Ddi_Free(itpNew2);
    }

    ddm->settings.aig.itpNoQuantify = 0;
    ddm->settings.aig.itpUseCare = 0;
    Ddi_Free(aNew);
    Ddi_Free(bNew);
    Ddi_Free(careAig);
    if (itpNew!=NULL) {
      coneAux = Ddi_BddNot(itpNew);
      if (tryPrevImgLearning && !Ddi_BddIsConstant(coneAux)) {
	Ddi_Free(itpTravMgr->careForBwdCone);
	itpTravMgr->careForBwdCone = Ddi_BddDup(coneAux);
      }

      Ddi_BddDiffAcc(coneAux,prevTo);
      if (0&&optCare!=NULL) {
        Ddi_Bdd_t *notCare = Ddi_BddNot(optCare);
        Ddi_BddOrAcc(coneAux,notCare);
        Ddi_Free(notCare);
      }
      Ddi_Free(itpNew);
      //      Ddi_BddAndAcc(coneAux,b);
      printf("Re-Computing itp using ItpWithNew\n");
      itp = Ddi_AigSat22AndWithInterpolant(NULL,a,coneAux,NULL,
					  globalVars, domainVars,
					   tfPiVars,tfPiNum,
					   optCare,itpPlus,
					   psat, 0, itpOdc, 
					   0,timeLimit);
      Ddi_Free(coneAux);
      if (compareWithItp) {
        Pdtutil_Assert(Ddi_BddIncluded(a,itp),"problem witn NEW");
        Pdtutil_Assert(!Ddi_AigSatAnd(itp,b,optCare),"problem witn NEW");
	printf("Comparing ItpWithNew to standard ITP\n");
	Ddi_Bdd_t *itpRef = Ddi_AigSat22AndWithInterpolant(NULL,a,b,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 0, itpOdc, 
					  0,timeLimit);
	printf("ItpWithNew / std Itp: %d / %d\n", Ddi_BddSize(itp),
	     Ddi_BddSize(itpRef));
	Ddi_Free(itpRef);
      }
    }
    return itp;
  }

  if (Ddi_BddIsPartDisj(b) && Ddi_BddPartNum(b)>1) {
    Ddi_Bdd_t *b0, *b1, *bPart = Ddi_BddDup(b); 
    int m = Ddi_BddReadMark(b);

    Ddi_BddPartSortBySizeAcc(bPart,0); // decreasing size
    b0 = Ddi_BddPartExtract(bPart,0);
    b1 = Ddi_BddDup(bPart);
    Ddi_BddSetAig(b0);
    Ddi_BddSetAig(b1);
    Ddi_BddDiffAcc(b0,b1);
    Ddi_AigStructRedRemAcc (b0,NULL);

    Ddi_Free(bPart);
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("ITP by disj CONE decomp: %d -> (%d,%d)\n",
	     Ddi_BddSize(b), Ddi_BddSize(b0), Ddi_BddSize(b1));
    }
    static int trySingle = 0;
    Ddi_BddWriteMark(b0,m);
    Ddi_BddWriteMark(b1,m);

    if (trySingle) {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("ITP by disj CONE decomp: try single\n");
      }
      Ddi_Bdd_t * tmpItp = Ddi_AigSat22AndWithInterpolant(NULL,a,b,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 0, itpOdc, 
					  0,timeLimit);
      Ddi_Free(tmpItp);
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("ITP by disj CONE decomp: now partitioned\n");
      }
    }
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("ITP by disj CONE decomp part 0: %d\n",
	     Ddi_BddSize(b1));
    }
    Ddi_Bdd_t *itp0, *itp1 = 
       Ddi_AigSat22AndWithInterpolant(NULL,a,b1,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 0, itpOdc, 
					  0,timeLimit);
    if (itp1==NULL) {
      Ddi_Free(b0);
      Ddi_Free(b1);
      return NULL;
    }
    else {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("ITP by disj CONE decomp part 1: %d\n",
               Ddi_BddSize(b0));
      }
      Ddi_BddAndAcc(b0,itp1);
      itp0 = 
       Ddi_AigSat22AndWithInterpolant(NULL,a,b0,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 0, itpOdc, 
					  0,timeLimit);
      Ddi_Free(b0);
      Ddi_Free(b1);
      if (itp0==NULL) {
        Ddi_Free(itp1);
	return NULL;
      }
      else {
        int s0 = Ddi_BddSize(itp0), s1 = Ddi_BddSize(itp1);
	Ddi_BddAndAcc(itp1,itp0);
	Ddi_Free(itp0);
        Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
          printf("ITP by disj CONE decomp result: %d+%d=%d\n",
                 s0,s1,Ddi_BddSize(itp1));
        }
	return itp1;
      }
    }
  }
  else if (/*step<=1 ||*/ itpPart<=0 || Ddi_BddSize(b)<=itpPartTh) {
    Ddi_Bdd_t *b2 = Ddi_BddDup(b);
    //Ddi_Bdd_t *b2 = Ddi_BddMakeAig(b);
    int saveItpReverse = ddm->settings.aig.itpReverse;
    if (0 && step<=2 && ddm->settings.aig.itpReverse)
      ddm->settings.aig.itpReverse = -1;
#define REVERSE 0
#if REVERSE
    int saveItpNnfAbstrAB = ddm->settings.aig.itpNnfAbstrAB;
    // set just B
    ddm->settings.aig.itpNnfAbstrAB = 3;
    Ddi_Bdd_t *myB2 = Ddi_BddDup(b2);
    if (optCare!=NULL) {
      Ddi_BddNotAcc(optCare);
      Ddi_BddOrAcc(myB2,optCare);
      Ddi_BddNotAcc(optCare);
    }
    Ddi_Bdd_t *itp = Ddi_AigSat22AndWithInterpolant(NULL,myB2,a,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  NULL,NULL,
					  psat, 0, itpOdc, 
                                          0,timeLimit);
    Ddi_Free(myB2);
    ddm->settings.aig.itpNnfAbstrAB = saveItpNnfAbstrAB;
    if (itp!=NULL) {
      Ddi_BddNotAcc(itp);
    }
#else
    Ddi_Bdd_t *itp = NULL;
    static int tryThis = 0;
    if (tryThis) {
      Ddi_Bdd_t *b2b = Ddi_BddDup(b2); 
      Ddi_Varset_t *sm = Ddi_VarsetVoid(ddm);
      char *base[] = {"i_d[0]","i_d[1]","i_d[2]","i_d[3]",
                      "i_d[4]","i_d[5]","i_d[6]","i_d[7]",
                      "i_reset","i_v","i_clk","i_ce",
                      "i26","i28","i30","i32","i34",
                      "i36","i38","i40","i42","i44",
                      NULL};
      char name[100];
      int tfMax = 6;
      Ddi_VarsetSetArray(sm);
      for (int i = 0; base[i]!=NULL; i++) {
        // sprintf(name,"i_d[%d]", i);
        // Ddi_Var_t *v = Ddi_VarFromName(ddm,name);
        //        Ddi_VarsetAddAcc(sm,v);
        for (int j=tfMax; j>=0; j--) {
          sprintf(name,"PDT_TF_VAR_%s_%d", base[i],j);
          Ddi_Var_t *v = Ddi_VarFromName(ddm,name);
          if (v!=NULL)
            Ddi_VarsetAddAcc(sm,v);
        }
      }
      Ddi_BddExistAcc(b2b,sm);
      Ddi_Bdd_t *itp0 = Ddi_AigSat22AndWithInterpolant(NULL,a,b2b,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 0, itpOdc, 
					  0,timeLimit);
      itp = Ddi_BddDup(itp0);
      Ddi_Free(itp0);
      Ddi_Free(b2b);
      Ddi_Free(sm);
    }
    if (itp==NULL) {
      int doCompute = 1;
      int iteOptTh = ddm->settings.aig.itpIteOptTh;
      int tryTwice = ddm->settings.aig.itpTwice;
      ddm->settings.aig.itpTwice = 0;
      if (tryTwice != 0) {
        //        ddm->settings.aig.itpNoQuantify = 1000;
        ddm->settings.aig.itpIteOptTh = 5000000;
        itp = Ddi_AigSat22AndWithInterpolant(NULL,a,b2,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 0, itpOdc, 
					  0,timeLimit);
        //        ddm->settings.aig.itpNoQuantify = 0;
        ddm->settings.aig.itpIteOptTh = iteOptTh;
        if (itp != NULL) {
          Ddi_BddNotAcc(itp);
          //          Ddi_Free(b2);
          // b2 = Ddi_BddNot(itp);
          Ddi_BddOrAcc(b2,itp);
          Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
            printf("\nRecomputing itp: original size: %d\n",
                   Ddi_BddSize(itp));
          }
          Ddi_Free(itp);
        }
        else doCompute = 0;
      }
      if (doCompute) {
        if (ddm->aig.actVars!=NULL) {
          Ddi_Bdd_t *itp0=NULL; 
          Ddi_Bdd_t *b2Constr;
          Ddi_Bdd_t *constr =
            Ddi_BddMakePartConjFromArray(ddm->aig.actVars);
          int nv = Ddi_BddarrayNum(ddm->aig.actVars);
          Ddi_Unlock(ddm->aig.actVars);
          Ddi_Free(ddm->aig.actVars);
          b2Constr = Ddi_BddDup(constr);
          Ddi_BddPartInsertLast(b2Constr,b2);
          Ddi_BddSetFlattened(b2Constr);
          Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
            printf("\nComputing itp on %d Act Vars hint\n", nv);
          }
          Ddi_BddSetAig(b2Constr);
          int genActLits = ddm->settings.aig.itpActiveVars;
          ddm->settings.aig.itpActiveVars=0; // disable
          itp0 = Ddi_AigSat22AndWithInterpolant(NULL,a,b2Constr,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 0, itpOdc, 
					  0,timeLimit);
          ddm->settings.aig.itpActiveVars=genActLits;
          Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
            printf("\nNow Computing itp leftover for %d hints\n",
                   nv);
          }
          if (itp0!=NULL) {
            Ddi_BddSetAig(constr);
            Ddi_BddDiffAcc(b2,constr);
            Ddi_BddNotAcc(itp0);
            Ddi_BddOrAcc(b2,itp0);
          }
          Ddi_Free(itp0);
          Ddi_Free(b2Constr);
          Ddi_Free(constr);
        }
 
        itp = Ddi_AigSat22AndWithInterpolant(NULL,a,b2,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 0, itpOdc, 
					  0,timeLimit);
      }
      ddm->settings.aig.itpTwice = tryTwice;
    }
#endif
    Ddi_Free(b2);
    ddm->settings.aig.itpReverse = saveItpReverse;
    return itp;
  }
  else if (0 && itpPart<=4 && doSplit==0) {
    Ddi_Bdd_t *bPart = Ddi_BddDup(b);        
    Ddi_Bdd_t *bDup = Ddi_BddDup(b);        
    Ddi_Bdd_t *iPart = NULL, *itp=NULL,
      *myCare=Ddi_BddMakeConstAig(ddm,1);
    if (optCare!=NULL) {
      Ddi_BddAndAcc(myCare,optCare);
    }
    if (Ddi_BddPartNum(bPart)==2) {
      Ddi_BddPartSortBySizeAcc(bPart,1); // increasing size
      Ddi_Bdd_t *b0 = Ddi_BddPartRead(bPart,0);
      Ddi_Bdd_t *b1 = Ddi_BddPartRead(bPart,1);
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("ITP by disj CONE decomp: %d -> (%d,%d)\n",
	     Ddi_BddSize(b), Ddi_BddSize(b0), Ddi_BddSize(b1));
      }
      Ddi_Free(bDup);
      bDup = Ddi_BddDup(Ddi_BddPartRead(bPart,1));
      iPart = Ddi_AigSat22AndWithInterpolant(NULL,a,b0,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 0, itpOdc, 
					  0,timeLimit);
      if (iPart!=NULL) {
        Ddi_BddNotAcc(iPart);
        Ddi_BddOrAcc(bDup,iPart);
      }
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
        printf("Computing main ITP\n",
               Ddi_BddSize(b), Ddi_BddSize(b0), Ddi_BddSize(b1));
      }
    }
    Ddi_Free(bPart);
    itp = Ddi_AigSat22AndWithInterpolant(itpTravMgr->incrSat,
                                         a,bDup,NULL,
                                         globalVars, domainVars,
                                         tfPiVars,tfPiNum,
                                         myCare,itpPlus,
                                         psat, itpPart, itpOdc, 
                                         0,timeLimit);
    if (0 && itp!=NULL && iPart!=NULL) {
      Ddi_BddAndAcc(itp,iPart);
    }
    Ddi_Free(myCare);
    Ddi_Free(bDup);
    Ddi_Free(iPart);
    return itp;
  }
  else if (enDisjDecomp) {
    Ddi_Bdd_t *b0, *b1, *bPart = Ddi_AigPartitionTop(b,1); 
    int m = Ddi_BddReadMark(b);
    if (Ddi_BddPartNum(bPart) == 1) {
      Ddi_Bdd_t *conjPart, *cPart0, *cPart00;
      Ddi_Free(bPart);
      conjPart = Ddi_AigPartitionTop(b,0); 
      Ddi_BddPartSortBySizeAcc(conjPart,0); // decreasing size
      cPart0 = Ddi_BddPartRead(conjPart,0);
      bPart = Ddi_AigPartitionTop(cPart0,1); 
      Ddi_BddPartSortBySizeAcc(bPart,0); // decreasing size
      b0 = Ddi_BddDup(conjPart);
      b1 = Ddi_BddDup(conjPart);
      Ddi_Free(conjPart);
      cPart00 = Ddi_BddPartExtract(bPart,0);
      if (Ddi_BddPartNum(bPart)>10) {
	Ddi_Bdd_t *p1 = Ddi_BddPartExtract(bPart,0);
	Ddi_BddOrAcc(cPart00,p1);
	Ddi_Free(p1);
      }
      Ddi_BddSetAig(bPart);
      Ddi_BddPartWrite(b0,0,cPart00);
      Ddi_BddPartWrite(b1,0,bPart);
      Ddi_Free(cPart00);
      Ddi_Free(bPart);
      Ddi_BddSetAig(b0);
      Ddi_BddSetAig(b1);
      Ddi_BddDiffAcc(b0,b1);
      Ddi_AigStructRedRemAcc (b0,NULL);
    }
    else {
      Ddi_BddPartSortBySizeAcc(bPart,0); // decreasing size
      b0 = Ddi_BddPartExtract(bPart,0);
      b1 = Ddi_BddDup(bPart);
      Ddi_BddSetAig(b0);
      Ddi_BddSetAig(b1);
      Ddi_BddDiffAcc(b0,b1);
      Ddi_AigStructRedRemAcc (b0,NULL);
    }
    Ddi_Free(bPart);
    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("ITP by disj CONE decomp: %d -> (%d,%d)\n",
	     Ddi_BddSize(b), Ddi_BddSize(b0), Ddi_BddSize(b1));
    }
    static int trySingle = 0;
    Ddi_BddWriteMark(b0,m);
    Ddi_BddWriteMark(b1,m);

    if (trySingle) {
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("ITP by disj CONE decomp: try single\n");
      }
      Ddi_Bdd_t * tmpItp = Ddi_AigSat22AndWithInterpolant(NULL,a,b,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 0, itpOdc, 
					  0,timeLimit);
      Ddi_Free(tmpItp);
      Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	printf("ITP by disj CONE decomp: now partitioned\n");
      }
    }
    Ddi_Bdd_t *itp0, *itp1 = 
       Ddi_AigSat22AndWithInterpolant(NULL,a,b1,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 1, itpOdc, 
					  0,timeLimit);
    if (itp1==NULL) {
      Ddi_Free(b0);
      Ddi_Free(b1);
      return NULL;
    }
    else {
      Ddi_BddAndAcc(b0,itp1);
      itp0 = 
       Ddi_AigSat22AndWithInterpolant(NULL,a,b0,NULL,
					  globalVars, domainVars,
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, 1, itpOdc, 
					  0,timeLimit);
      Ddi_Free(b0);
      Ddi_Free(b1);
      if (itp0==NULL) {
        Ddi_Free(itp1);
	return NULL;
      }
      else {
	Ddi_BddAndAcc(itp1,itp0);
	Ddi_Free(itp0);
	return itp1;
      }
    }
  }
  else if (enPartA) {
    Ddi_Bdd_t *itpRes = Ddi_AigSat22AndWithInterpolantPartNnfA(NULL,a,b,
					  itpMgr->bckReachedRings,prevTo,
					  globalVars, domainVars,
					  itpMgr->ns, 
					  tfPiVars,tfPiNum,
					  optCare,itpPlus,
					  psat, itpPart, itpOdc, 
					  timeLimit);
    if (itpRes!=NULL) {
      // strengthen bwd ring
      itpStrengthenBwdRing(itpMgr,b);
    }
    return itpRes;
  }

  // 1: just split - 2: split and cut preimg
  int saveSplitConeInfo = 1 && Ddi_BddReadComposeF(b)!=NULL;
  int useCareForA = 1;
  
  itpTot = Ddi_BddMakeConstAig(ddm,1);
  careTot = Ddi_BddMakeConstAig(ddm,1);
  careTotSplit = Ddi_BddMakeConstAig(ddm,1);
  careTotForCex = Ddi_BddMakeConstAig(ddm,1);
  careFinal = Ddi_BddMakeConstAig(ddm,1);
  bDup = Ddi_BddDup(b);

  itpPlus = NULL;

  if (Ddi_BddReadComposeF(b)!=NULL) {
    splitB = Ddi_BddDup(Ddi_BddReadComposeF(b));
    splitCare = Ddi_BddDup(Ddi_BddReadComposeCare(b));
    splitConstr = Ddi_BddDup(Ddi_BddReadComposeConstr(b));
    splitU = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(b));
    splitV = Ddi_VararrayDup(Ddi_BddReadComposeVars(b));
    splitRefV = Ddi_BddReadComposeRefVars(b);
    splitRel = Ddi_BddRelMakeFromArray(splitU,splitV);
    splitVars = Ddi_VarsetMakeFromArray(splitV);

    if (splitConstr!=NULL) {
      int m = Ddi_BddReadMark(splitConstr);
      Ddi_BddAndAcc(splitRel,splitConstr);
      if (m>0) {
	andWithRing_i = m;
      }
    }

    Ddi_BddSetAig(splitRel);

    splitV2 =
      Ddi_VararrayMakeNewVars(itpMgr->ps, "PDT_ITP_SPLITV_", NULL, 1);
    splitVaux =
      Ddi_VararrayMakeNewVars(itpMgr->ps, "PDT_ITP_SPLITV_AUX_", NULL, 1);
    splitVaux2 =
      Ddi_VararrayMakeNewVars(itpMgr->ps, "PDT_ITP_SPLITV_AUX2_", NULL, 1);
    piAux =
      Ddi_VararrayMakeNewVars(itpMgr->pi, "PDT_ITP_PI_AUX_", NULL, 1);
    if (doSplit2>2) {
      int splitCare_i = step+doSplit2;
      int start_i = step+doSplit;
      int coneTopMark = Ddi_BddReadMark(splitB);
      doItpFromGenClausesAux = 0;
      splitRel2 = growUnrollRelation(itpMgr, itpMgr->ns, 
	            start_i - 1, splitCare_i,
		    itpMgr->delta, itpMgr->initStub, 
		    useRingConstr, andWithRing_i, 0, coneTopMark);
      Ddi_BddSubstVarsAcc(splitRel2, itpMgr->ns, splitV2);
      Ddi_BddSubstVarsAcc(splitRel2, itpMgr->ps, itpMgr->ns);
      if (!Ddi_AigSat(splitRel2)) {
	Ddi_Free(splitRel2);
      }
    }
    else {
      doSplitCare=0;
    }
  }

  if (mark>0 && mark < tfPiNum) {
    tfPiNum = mark;
  }

  Pdtutil_Assert(itpPart>0,"itpPart required");

  if (saveSplitConeInfo &&
      (itpTravMgr->splitConeInfo.preImg!=NULL
       || itpTravMgr->splitConeInfo.ring!=NULL)) {
    if (saveSplitConeInfo>1) {
      Ddi_Free(careTotForCex);
      careTotForCex = Ddi_BddNot(itpTravMgr->splitConeInfo.preImg);
      Ddi_BddSubstVarsAcc(careTotForCex,splitRefV,splitV);
    }
    if (useCareForA) {
      careTotForA = Ddi_BddDup(itpTravMgr->splitConeInfo.ring);
      Ddi_BddSubstVarsAcc(careTotForA,splitRefV,splitV);
    }
  }
  
  if (optCare!=NULL) {
    Ddi_BddAndAcc(careTot,optCare);
    //    Ddi_BddAndAcc(careTotForCex,optCare);
  }

#define EXTRACT_MAXP 1

  if (incrementalSat) {
    ddiS = Ddi_IncrSatMgrAlloc(ddm, 1, 1, 0);
#if 0
    Ddi_Var_t *a = Ddi_VarNewBaig(ddm,"A");
    Ddi_Var_t *b = Ddi_VarNewBaig(ddm,"B");
    Ddi_Var_t *c = Ddi_VarNewBaig(ddm,"C");
    Ddi_Var_t *d = Ddi_VarNewBaig(ddm,"D");
    Ddi_Bdd_t *la = Ddi_BddMakeLiteralAig(a, 1);
    Ddi_Bdd_t *lb = Ddi_BddMakeLiteralAig(b, 1);
    Ddi_Bdd_t *lc = Ddi_BddMakeLiteralAig(c, 1);
    Ddi_Bdd_t *ld = Ddi_BddMakeLiteralAig(d, 1);

    Ddi_Bdd_t *p0 = Ddi_BddAnd(la,lb);
    Ddi_Bdd_t *p1 = Ddi_BddOr(p0,lc);

    Ddi_IncrSatMgrResume(ddiS);
    Ddi_Bdd_t *cex0 = Ddi_AigSatMinisat22WithCexAndAbortIncremental(ddiS,
		  p0, NULL, 0, -1, NULL);
    Ddi_IncrSatMgrSuspend(ddiS);
    int x = Ddi_AigSatAnd(la,lb,lc);
    Ddi_IncrSatMgrResume(ddiS);
    Ddi_Bdd_t *cex1 = Ddi_AigSatMinisat22WithCexAndAbortIncremental(ddiS,
		  p1, NULL, 0, -1, NULL);
    Ddi_IncrSatMgrSuspend(ddiS);
    Ddi_Free(p0);
    Ddi_Free(p1);
    Ddi_Free(cex0);
    Ddi_Free(cex1);
    Ddi_Free(a);
    Ddi_Free(b);
    Ddi_Free(c);
#endif
  }

  int itpEnded=0;
  for (i=0; i<itpPart && !itpEnded; i++) {
    Ddi_Bdd_t *myB, *myBforCex, *cex=NULL, *toMinus = NULL;
    int tryLowerBoundk = enLowerBoundk && i%4==0;
    int split_i = step+doSplit;
    int d;
    int tryOK = 0;
    if (tryLowerBoundk) {
      d = dLB--;
      if (d<=1 || fullK-split_i <= 2 ||
	  Ddi_BddPartNum(kConeRings)<fullK) {
	tryLowerBoundk = enLowerBoundk = 0; // disable it
      }
      if (fullK-d-1<=split_i) tryLowerBoundk=0;
    }

    myB = Ddi_BddDup(bDup);
    myBforCex = Ddi_BddDup(bDup);

    Ddi_BddAndAcc(myB,careFinal);
    if (splitB!=NULL) {
      Ddi_Free(myBforCex);
      myBforCex = Ddi_BddDup(splitB);
      if (1&&(splitCare!=NULL)) {
	Ddi_BddAndAcc(careTotForCex,splitCare);
      }
      itpPlus = NULL;
#if 0
      Ddi_BddNotAcc(careTotSplit);
      Ddi_BddOrAcc(myBforCex,careTotSplit);
      Ddi_BddNotAcc(careTotSplit);
#endif
    }
    if (i>=0 && preSplit && splitRel) {
      //      genClauses=1; 
      if (enFwdCare) genCubes=1;
    }

    nnfSubset = 0 && (i>=1) && (i<itpPart-1);

    Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
      printf("ITP part%s: %d/%d\n", splitB?"(split)":"", i, itpPart);
    }
    if (i==itpPart) {
      //      handle final part
      itp_i =
	Ddi_AigSat22AndWithInterpolant(NULL,a,myB,NULL,
				       globalVars, domainVars,NULL,0,
				       itpTot,NULL,
				       psat, 0, itpOdc, 0, timeLimit);
    }
    else {
      Ddi_Bdd_t *itpSplit = NULL; int itpSplitDone=0;
      startTime = util_cpu_time();
      int forceSplit = 1, checkPrev=1;
      if ((forceSplit||saveSplitConeInfo) && splitRel!=NULL && i==itpPart-1) {
	/* let as it is */
        Pdtutil_Assert (preSplit && splitRel!=NULL,
                        "Wrong split cone setup");
        Ddi_BddAndAcc(myBforCex,careTotForCex);
        if (checkPrev &&
            !Ddi_BddIsOne(careTotForCex)&&!Ddi_AigSat(myBforCex)) {
          itpSplit = Ddi_BddDup(careTotForCex);
          itpSplitDone = 1;
          Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
            fprintf(dMgrO(ddm),
                    "REUSING PREVIOUS SPLIT ITP BWD RING: %d\n",
                    Ddi_BddSize(itpSplit));
          }
        }
      }
      else if (i==itpPart-1) {
	/* let as it is */
	if (preSplit && splitRel!=NULL) {
	  Ddi_Free(myB);
	  myB = Ddi_BddDup(myBforCex);
	  Ddi_BddAndAcc(myB,careTotForCex);
	  Ddi_BddComposeAcc(myB,splitV,splitU);
	  if (splitConstr!=NULL) {
	    Ddi_BddAndAcc(myB,splitConstr);
	  }
	  preSplit = 0;
	}
	Ddi_Bdd_t *bFromItp = Ddi_BddNot(itpTot);
	Ddi_BddOrAcc(myB,bFromItp);
	Ddi_Free(bFromItp);
        int tryGenCof = 0;
        itp_i = NULL;
        if (tryGenCof) {
          if (!Ddi_AigSatConstrain(myB,
                                   itpTot, -1.0, NULL)) {
            itp_i = Ddi_BddDup(itpTot);
          }
        }
        if (itp_i==NULL) 
          itp_i =
	    Ddi_AigSat22AndWithInterpolant(NULL,a,myB,NULL,
				       globalVars, domainVars,NULL,0,
				       itpTot,NULL,
				       psat, 0, itpOdc, 0, timeLimit);
	doSplitCare=0; itpEnded = 1;
      }
      else if (tryLowerBoundk) {
	Ddi_Bdd_t *target = Ddi_BddDup(Ddi_BddPartRead(kConeRings, 
						       fullK-1));
	Ddi_Bddarray_t *splitU3 = NULL;
	Ddi_Vararray_t *splitV3 = NULL;
	Ddi_Varset_t *splitVars3 = NULL;
	Ddi_Bdd_t *splitConstr3 = NULL;
	Ddi_Bdd_t *myA = NULL, *myBl = NULL;
	Ddi_Vararray_t *v1=NULL,*v2=NULL, *glbA=NULL;
	growConeBwdDecomp(itpMgr, target, fullK-d-1, step, split_i,  
			  1, 1, NULL,
			  itpMgr->initStub, useRingConstr, andWithRing_i, 0);	
	if (itpTravMgr->constrainVars != NULL && 
	    Ddi_VararrayNum(itpTravMgr->constrainVars)>0) {
	  Ddi_BddComposeAcc(target, itpTravMgr->constrainVars,
			    itpTravMgr->constrainSubstLits);
	}
	if (toPlusCube!=NULL && !Ddi_BddIsOne(toPlusCube)) {
	  Ddi_AigConstrainCubeAcc(target,toPlusCube);
	}
	
	if (Ddi_AigSat(target)) {	    
	  myBl = Ddi_BddDup(Ddi_BddReadComposeF(target));
	  splitU3 = Ddi_BddarrayDup(Ddi_BddReadComposeSubst(target));
	  splitV3 = Ddi_VararrayDup(Ddi_BddReadComposeVars(target));
	  myA =  Ddi_BddRelMakeFromArray(splitU3,splitV3);
	  splitConstr3 = Ddi_BddReadComposeConstr(target);
	  if (splitConstr3!=NULL) {
	    Ddi_BddAndAcc(myA, splitConstr);
	  }
	  splitVars3 = Ddi_VarsetMakeFromArray(splitV3);
	  Ddi_BddSetAig(myA);
	  Ddi_BddAndAcc(myA, a);
	  
	  itpSplit =
	    Ddi_AigSat22AndWithInterpolant(NULL,myA,myBl,NULL,
					   splitVars, NULL,NULL,0,
					   NULL,NULL,
					   psat, 0, itpOdc, 1, timeLimit);
	  itpSplitDone=1;
	  if (!Ddi_BddIsOne(itpSplit)) {
	    tryOK = 1;
	    if (genNextRing && fullK-d-1 > split_i+1) {
	      Ddi_Bddarray_t *d1;
	      Ddi_Bdd_t *d1Rel;
	      Ddi_Bdd_t *tNext = Ddi_BddDup(Ddi_BddPartRead(kConeRings, 
						       fullK-1));
	      growConeBwd(itpMgr, tNext, fullK-d-1, split_i+1, 
			  itpMgr->delta, itpMgr->initStub, 
			  useRingConstr, andWithRing_i, 0);

	      d1 = Ddi_BddarrayDup(itpMgr->delta);
	      Ddi_BddarraySubstVarsAcc(d1,itpMgr->ps,itpMgr->ns);

	      if (Ddi_BddarrayNum(itpMgr->eqRings) > split_i) {
		Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, split_i);
		if (eqConstr != NULL) {
		  Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
		  Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);
		  
		  Ddi_BddarrayComposeAcc(d1, vars, subst);
		}
	      }
	      
	      Ddi_BddarraySubstVarsAcc(d1,itpMgr->ns,splitV2);
	      Ddi_BddarraySubstVarsAcc(d1,itpMgr->pi,piAux);
	      d1Rel = Ddi_BddRelMakeFromArray(d1,itpMgr->ns);
	      Ddi_BddPartInsertLast(d1Rel,itpSplit);
	      itpNextRing =
		Ddi_AigSat22AndWithInterpolant(NULL,d1Rel,tNext,NULL,
					   itpMgr->nsvars, NULL,NULL,0,
					   NULL,NULL,
					   psat, 0, itpOdc, 1, timeLimit);
	      Pdtutil_Assert(itpNextRing!=NULL,"NULL itp");
	      genNextRing = 0;
	      Ddi_Free(d1);
	      Ddi_Free(d1Rel);
	      Ddi_Free(tNext);
	    }
	  }
	  else {
	    Ddi_Free(itpSplit);
	  }
	}
	else if (itpNextRing == NULL) {
	  if (itpMgr->fromRings!=NULL && 
	      Ddi_BddarrayNum(itpMgr->fromRings)>split_i+1) {
	    itpNextRing = 
	      Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, split_i+1));
	    genNextRing = 0;
	  }

	}
	Ddi_Free(myA);
	Ddi_Free(myBl);
	Ddi_Free(splitV3);
	Ddi_Free(splitVars3);
	Ddi_Free(splitU3);
	Ddi_Free(target);

	if (!tryOK) {
	  Ddi_Free(myB);
	  Ddi_Free(myBforCex);
	  continue;
	}
      }
      else if (nnfSubset) {
	Ddi_Bdd_t *myBSubs = Ddi_AigSatNnfSubset(myBforCex,
						 careTotForCex,itpPlus);
	if (myBSubs == NULL) {
	  Ddi_Free(myB);
	  Ddi_Free(myBforCex);
	  break;
	}
	Ddi_Free(myBforCex);
	myBforCex = myBSubs;
      }
      else if (genClauses) {
	int maxIter = 10; // i==0? 10 : 20;
	int res=0;
	Pdtutil_Assert (preSplit && splitRel!=NULL,"wrong setting");
	Ddi_Bdd_t *aSplit = Ddi_BddAnd(a,splitRel);
	Ddi_Bdd_t *aCare = Ddi_BddAnd(careTot,splitRel);
	Ddi_Bdd_t *aCare2 = NULL;
	Ddi_Vararray_t *v1=NULL,*v2=NULL, *glbA=NULL;
	
	if (splitRel2!=NULL) {
	  Ddi_Bdd_t *aCare2aux = Ddi_BddAnd(careTotSplit,splitRel2);
	  aCare2 = Ddi_AigPartitionTop(aCare2aux,0);
	  Ddi_Free(aCare2aux);
	}
	else {
	  aCare2 = Ddi_AigPartitionTop(aCare,0);
	}
	v1 = Ddi_VararrayMakeFromVarset(splitVars,1);
	v2 =
	  Ddi_VararrayMakeNewAigVars(v1, "shadow", NULL);
	glbA = Ddi_VararrayDup(v1);
	if (genCubes && enFwdCare) {
	  Ddi_Bdd_t *careFwd = NULL, *myToMinus=NULL;
	  if (0 && itpMgr->fromRings!=NULL && 
	      step>1 &&
	      Ddi_BddarrayNum(itpMgr->fromRings)>=step) {
	    myToMinus = Ddi_BddarrayRead(itpMgr->fromRings, 
						  step-1);
	    careFwd = Ddi_BddDiff(splitRel,myToMinus);
	  }
	  //	  enFwdCare = 0;
	  itpSplit =
	    Ddi_AigInterpolantByGenClauses(aSplit,myBforCex,careTotForCex,
					   careFwd, 
					   v2, v1, NULL, glbA, 
					   NULL, NULL, NULL, maxIter, 
					   0, &res);
	  Ddi_Free(careFwd);
	  if (res<0) {
	    genCubes=0;
	    Pdtutil_Assert(itpSplit==NULL,"null expected");
	  }
	  else if (res==1) {
	    //	    Ddi_Free(itpSplit);
	    if (careFwd!=NULL) {
	      toMinus = myToMinus;
	    }
	    itpEnded = 1;
	  }
	  else {
	    if (toMinusSplit==NULL) {
	      toMinusSplit = itpSplit;
	      Ddi_BddDiffAcc(aSplit,toMinusSplit); 
	    }
	  }
	}
	if (genClauses) { /* always enabled */
	  Ddi_Bdd_t *aPart = Ddi_AigPartitionTop(aSplit,0);
	  itpSplit =
	    Ddi_AigInterpolantByGenClauses(myBforCex,aPart,careTotForCex,
					   /*NULL*/aCare2, 
					   v2, v1, NULL, glbA, 
					   NULL, NULL, NULL, maxIter, 
					   0, &res);
	  Ddi_Free(aPart);
	  if (res==1) {
	    //	    Ddi_Free(itpSplit);
	    itpEnded = 1;
	  }
	  if (itpSplit!=NULL) {
	    Ddi_BddNotAcc(itpSplit);
	    if (!Ddi_BddIsOne(itpSplit) && !Ddi_BddIsOne(careTotForCex)) {
	      Ddi_BddAndAcc(itpSplit,careTotForCex);
	    }
	    if (toMinusSplit!=NULL) {
	      Ddi_BddOrAcc(itpSplit,toMinusSplit);
	    }
	  }
	}
	itpSplitDone=1;
	Ddi_Free(glbA);
	Ddi_Free(v1);
	Ddi_Free(v2);
	Ddi_Free(aSplit);
	Ddi_Free(aCare);
	Ddi_Free(aCare2);
	if (itpSplit!=NULL && Ddi_BddIsOne(itpSplit)) {
	  Ddi_Free(myB);
	  Ddi_Free(myBforCex);
	  Ddi_Free(itpSplit);
	  break;
	}
      }
      else {
	int undef = 0;
        int checkOnSplit = 1 && (splitVars!=NULL);
        int useCex = 1;
        int doCexWithGates = 1&&(i>0);
        if (0 && (i<1) && i<(itpPart-1)) {
          Ddi_Bdd_t *notB = Ddi_BddNot(myBforCex); 
          Ddi_Bdd_t *bPart = Ddi_AigConjDecomp (notB, 8, 0);
          int sizeMax = 3*Ddi_BddSize(myBforCex)/4;
          Ddi_Free(bDup);
          Ddi_BddNotAcc(bPart);
          Ddi_Free(notB);
          Ddi_BddPartSortBySizeAcc(bPart, 1);    // incr. size	
#if EXTRACT_MAXP
          Ddi_Free(myB);
          myB = Ddi_BddMakeConstAig(ddm, 0);
          int ii;
          for (ii=0; ii<1 && Ddi_BddPartNum(bPart)>4; ii++) {
            int n = Ddi_BddPartNum(bPart);
            Ddi_Bdd_t *p_n = Ddi_BddPartExtract(bPart,n-1);
            Ddi_BddOrAcc(myB,p_n);
            Ddi_Free(p_n);
          }
          Ddi_DataCopy(myBforCex,myB);
          Ddi_BddSetAig(bPart);
          bDup = Ddi_BddDup(bPart);
#else
          bDup = Ddi_BddMakeConstAig(ddm, 0);
          while (Ddi_BddPartNum(bPart)>4 &&
                 Ddi_BddSize(bPart)>sizeMax) {
            int i = Ddi_BddPartNum(bPart);
            Ddi_Bdd_t *p_i = Ddi_BddPartExtract(bPart,i-1);
            Ddi_BddOrAcc(bDup,p_i);
            Ddi_Free(p_i);
          }
          Ddi_BddSetAig(bPart);
          Ddi_DataCopy(myBforCex,bPart);
          Ddi_DataCopy(myB,bPart);
#endif
          useCex = 0;
          Ddi_Free(bPart);
        }
	else if (incrementalSat) {
          int invertCare = 1;
	  Ddi_Bdd_t *myCheck = Ddi_BddAnd(itpTot,bDup);
          if (checkOnSplit) {
            Ddi_Bdd_t *aSplit = Ddi_BddAnd(itpTot,splitRel);
            Ddi_Free(myCheck);
            if (invertCare) {
              Ddi_BddNotAcc(careTotForCex);
              myCheck = Ddi_BddOr(myBforCex,careTotForCex);
              //Pdtutil_Assert(!Ddi_AigSatAnd(aSplit,careTotForCex,
              //                            NULL),"Unsound care");
              Ddi_BddNotAcc(careTotForCex);
            }
            else {
              myCheck = Ddi_BddAnd(myBforCex,careTotForCex);
            }
            Ddi_BddAndAcc(myCheck,aSplit);
            if (optCare!=NULL) {
              Ddi_BddAndAcc(myCheck,optCare);
            }
            Ddi_Free(aSplit);
          }
	  if (itpPlus!=NULL) {
	    Ddi_BddAndAcc(myCheck,itpPlus);
	  }
	  Ddi_IncrSatMgrResume(ddiS);
          if (0 && doCexWithGates && cexWithGates>0) {
            cex = Ddi_AigSatMinisat22WithCexAigAndAbortIncremental(ddiS,
              myCheck, cexWithGates, 0, itpRefTime*2, NULL);
          }
          else {
            cex = Ddi_AigSatMinisat22WithCexAndAbortIncremental(ddiS,
		  myCheck, NULL, 1, itpRefTime*2, &undef);
          }
          Ddi_IncrSatMgrSuspend(ddiS);
	  if (chkincr && (cex!=NULL)) {
	    Pdtutil_Assert(Ddi_AigSatAnd(myBforCex,careTotForCex,
					 itpPlus),"SAT needed");
	    Pdtutil_Assert(Ddi_AigSatAnd(cex,myCheck,NULL),"BAD cex");
	  }
	  else if (chkincr && (cex==NULL)) {
	    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,b,
					 itpPlus),"UNSAT needed");
	  }
	  Ddi_Free(myCheck);
	}
	else {
          if (!checkOnSplit) {
            if (doCexWithGates && cexWithGates>0) {
              Ddi_Bdd_t *check = Ddi_BddDup(itpTot);
              Ddi_BddSetPartConj(itpTot);
              Ddi_BddPartInsertLast(check,b);
              if (itpPlus != NULL) {
                Ddi_BddPartInsertLast(check,b);
              }
              cex = Ddi_AigSatMinisat22WithCexAigAndAbortIncremental(NULL,
               check, cexWithGates, 0, -1, NULL);
              Ddi_Free(check);
            }       
            else {
              cex = Ddi_AigSatAndWithCexAndAbort(itpTot,b,
		  itpPlus,NULL,itpRefTime*2,&undef);
            }
          }
          else {
            int again = 1;
            int iter, maxIter=itpPart;
            int doPartial = 0;
            for (iter=0; again; iter++) {
              again = 0;
              if (iter>=maxIter) {
                if (doPartial) {
                  cex = NULL;
                }
                else {
                  cex = Ddi_AigSatAndWithCexAndAbort(itpTot,b,
                    itpPlus,NULL,itpRefTime*2,&undef);
                }
              }
              else {
                cex = Ddi_AigSatAndWithCexAndAbort(careTotForCex,
                       myBforCex,NULL,NULL,itpRefTime*2,&undef);
              }
              if (cex!=NULL) {
                Ddi_Bdd_t *bTmp = Ddi_BddDup(myB);
                Ddi_AigConstrainCubeAcc(bTmp, cex);
                if (doPartial && iter==(maxIter-1) && 
                    !Ddi_AigSatAnd(itpTot,bTmp,itpPlus)) {
                  Ddi_Free(cex);
                }
                else if (!Ddi_AigSatAnd(itpTot,bTmp,itpPlus)) {
                  Ddi_Bdd_t *itpRefine;
                  Ddi_Bdd_t *aSplit = Ddi_BddAnd(itpTot,splitRel);
                  Ddi_Bdd_t *aPart = Ddi_AigPartitionTop(aSplit,0);
                  Ddi_Bdd_t *bTmp2 = Ddi_BddDup(myBforCex);
                  Ddi_Bdd_t *cex2 = Ddi_BddExist(cex,splitVars);
                  Ddi_AigConstrainCubeAcc(bTmp2, cex2);
                  Ddi_Free(cex2);
                  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
                    fprintf(dMgrO(ddm),
                            "REFINING SPLIT ITP (iter: %d)\n",iter);
                  }
                  if (optCare!=NULL) {
                    Ddi_BddAndAcc(aSplit,optCare);
                  }
                  int chk2 = 1;
                  if (chk2) {
                    Pdtutil_Assert(Ddi_AigSatAnd(bTmp2,careTotForCex,
                             NULL),"sat required");
                  }
                  itpRefine =
                    Ddi_AigSat22AndWithInterpolant(NULL,aPart,
                         bTmp2,NULL,
                         splitVars, NULL,NULL,0,
                         NULL,NULL,
                         psat, 0, itpOdc, 1, timeLimit);
                  Ddi_Free(bTmp2);
                  Ddi_BddAndAcc(careTotForCex, itpRefine);
                  Ddi_Free(itpRefine);
                  Ddi_Free(cex);
                  again = 1;
                  Ddi_Free(aPart);
                  Ddi_Free(aSplit);
                }
                Ddi_Free(bTmp);
              }
            }
          }
        }
        if (useCex) {
          if (undef) {
            startTime = util_cpu_time();
            Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
              fprintf(dMgrO(ddm),
                      "undef CEX with b - retrying on split cone\n");
              cex = Ddi_AigSatAndWithCexAndAbort(myBforCex,careTotForCex,
                                                 itpPlus,NULL,-1,NULL);
            }
          }
          cexTime = util_cpu_time() - startTime;
          Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
            fprintf(dMgrO(ddm),"CEX time %s= %s\n", cex==NULL ? "(unsat) ":"",
                    util_print_time (cexTime));
            if (cex!=NULL) {
              fprintf(dMgrO(ddm),"CEX size = %d\n",
                      Ddi_BddSize(cex));
            }
          }
          if (2*cexTime > itpRefTime) {
            itpRefTime = 2*cexTime;
          }
          if (cex==NULL) {
            Ddi_Free(myB);
            Ddi_Free(myBforCex);
            break;
          }
          if (doCexWithGates && cexWithGates>0) {
            float ratio = ((float) (itpPart-i+1)) / itpPart;
            int reversed = 0;
            if (ratio > 1) ratio = 1.0;
            //            if (i==itpPart-2) ratio = 0;
            if (reversed) ratio = -ratio;
            setupCexWithGates(cex,itpTravMgr->observedGates,ratio);
            Ddi_BddAndAcc(myB, cex); 
            Ddi_BddAndAcc(myBforCex, cex);
            Ddi_AigStructRedRemAcc (myB,NULL);
            Ddi_AigStructRedRemAcc (myBforCex,NULL);
          }
          else {
            tfPiVars = itpMgr->timeFrames->PiVars;
	
            Ddi_BddExistAcc(cex,globalVars);
            if (splitVars!=NULL) {
              Ddi_BddExistAcc(cex,splitVars);
            }
            if (tfPiVars!=NULL && tfPiNum>0 && splitB!=NULL) {
              int j;
              int coneTopMark = Ddi_BddReadMark(splitB);
              int nSmooth = tfPiNum - 2*coneTopMark/2;
              for (j=0; j<nSmooth && j<tfPiNum; j++) {
                Ddi_Varset_t *smPi = Ddi_VarsetMakeFromArray(tfPiVars[j]);
                Ddi_BddExistAcc(cex,smPi);
                Ddi_Free(smPi);
              }
            }
            Ddi_AigConstrainCubeAcc(myB, cex); 
            Ddi_AigConstrainCubeAcc(myBforCex, cex);
          }
        }
        else {
          if (undef) {
            itp_i = Ddi_BddMakeConstAig(ddm, 1);
            i = itpPart-2;
          }
        }
      }
      if (preSplit && splitRel!=NULL) {
        int doReverse = 1;
	Ddi_Bdd_t *aSplit = Ddi_BddAnd(a,splitRel);
	int checkTime=0;
	Ddi_Bdd_t *aPart = Ddi_AigPartitionTop(aSplit,0);
	if (optCare!=NULL) {
          Ddi_BddAndAcc(aSplit,optCare);
          Ddi_BddPartInsertLast(aPart,optCare);
	}
	if (!itpSplitDone) {
          if (careTotForA!=NULL) {
            if (doReverse) 
              Ddi_BddPartInsertLast(aPart,careTotForA);
            else 
              Ddi_BddAndAcc(myBforCex,careTotForA);
          }
          int saveItpNnfAbstrAB = ddm->settings.aig.itpNnfAbstrAB;
          int saveItpReverse = ddm->settings.aig.itpReverse;
          // set just A
          ddm->settings.aig.itpNnfAbstrAB = 2;
          ddm->settings.aig.itpReverse = doReverse;
	  itpSplit =
	    Ddi_AigSat22AndWithInterpolant(NULL,aPart,myBforCex,NULL,
					   splitVars, NULL,NULL,0,
					   NULL,NULL,
					   psat, 0, itpOdc, 1, timeLimit);
          ddm->settings.aig.itpNnfAbstrAB = saveItpNnfAbstrAB;
          ddm->settings.aig.itpReverse = saveItpReverse;
          if (1 && itpSplit!=NULL && careTotForA!=NULL) {
            int doItp = 1;
            int doNnfAbstrA = 1;
            int doNnfAbstrB = 1;
            if (careForPreimg==NULL) {
              careForPreimg = Ddi_BddMakeConstAig(ddm, 1);
            }
            Ddi_BddAndAcc(careForPreimg,itpSplit);
            Ddi_BddNotAcc(careTotForA);
            Ddi_BddOrAcc(itpSplit,careTotForA);
            Ddi_BddNotAcc(careTotForA);
            int size0 = Ddi_BddSize(itpSplit);
            Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
              printf("\nNNF abstr split ITP\n");
            }
            if (doItp) {
              Ddi_Bdd_t *refB = Ddi_BddNot(itpSplit);
              Ddi_Bdd_t *itpSplit1 =
                Ddi_AigSat22AndWithInterpolant(NULL,aSplit,
                       refB,NULL,splitVars, NULL,NULL,0,
                       NULL,NULL,psat, 0, itpOdc, 1, timeLimit);
              Pdtutil_Assert(itpSplit1!=NULL,"Missing itp");
              if (Ddi_BddSize(itpSplit1) < Ddi_BddSize(itpSplit)) {
                Ddi_DataCopy(itpSplit,itpSplit1);
                doNnfAbstrB = 0;
              }
              Ddi_Free(itpSplit1);
              Ddi_Free(refB);
            }
            if (doNnfAbstrA) {
              Ddi_AigOptByMonotoneCoreAcc(itpSplit,aSplit,NULL,1,
                                          -1.0);
            }
            if (doNnfAbstrB) {
              Ddi_AigOptByMonotoneCoreAcc(itpSplit,myBforCex,NULL,0,
                                        -1.0);
            }
            Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
              printf("NNF abstr split ITP done: %d->%d\n",
                     size0, Ddi_BddSize(itpSplit));
            }
          }
        }
	else if (doItpFromGenClauses && (itpSplit!=NULL)) {
	  Ddi_Free(myBforCex);
	  myBforCex = Ddi_BddNot(itpSplit);
	  Ddi_Free(itpSplit);
	  itpSplit =
	    Ddi_AigSat22AndWithInterpolant(NULL,aPart,myBforCex,NULL,
					   splitVars, NULL,NULL,0,
					   NULL,NULL,
					   psat, 0, itpOdc, 1, timeLimit);
	}
	if (doItpFromGenClausesAux && (itpSplit!=NULL)) {
	  Ddi_Bddarray_t *d0,*d1;
	  Ddi_Bdd_t *itpSplit2, *itpSplit3;
	  Ddi_Varset_t *itpVars = Ddi_VarsetMakeFromArray(splitV2);
	  Ddi_Bdd_t *miter=NULL;
	  int tfShift = doSplit;
	  Ddi_Vararray_t *tfpi = itpMgr->timeFrames->PiVars[tfShift];
	  Ddi_Bdd_t *nextRing = NULL;
	  Ddi_Bdd_t *auxCone = NULL;
	  Ddi_Bdd_t *savedSeedStates = NULL;
	  int useSeedStates = 1; // itpNextRing==NULL

	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    printf("Enlarging SPLIT ITP (%d) by fwd-bwd delta\n", 
		   Ddi_BddSize(itpSplit));
	  }
	  Ddi_Free(myBforCex);
	  myBforCex = Ddi_BddNot(itpSplit);
	  Ddi_BddSubstVarsAcc(myBforCex,splitV2,splitVaux);

	  if (itpMgr->fromRings!=NULL && 
	      Ddi_BddarrayNum(itpMgr->fromRings)>split_i) {
	    Ddi_Bdd_t *ring = 
	      Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, split_i));
	    Ddi_BddSubstVarsAcc(ring,itpMgr->ns,splitVaux);
	    Ddi_BddAndAcc(myBforCex,ring);
	    Ddi_Free(ring);
	    if (Ddi_BddarrayNum(itpMgr->fromRings)>split_i+1) {
	      nextRing = Ddi_BddarrayRead(itpMgr->fromRings, split_i+1);
	    }
	  }
	  savedSeedStates = Ddi_BddDup(myBforCex);

	  d0 = Ddi_BddarrayDup(itpMgr->delta);
	  d1 = Ddi_BddarrayDup(itpMgr->delta);
	  Ddi_BddarraySubstVarsAcc(d0,itpMgr->ps,itpMgr->ns);
	  Ddi_BddarraySubstVarsAcc(d1,itpMgr->ps,itpMgr->ns);

	  if (Ddi_BddarrayNum(itpMgr->eqRings) > split_i) {
	    Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, split_i);
	    if (eqConstr != NULL) {
	      Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
	      Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);
	      
	      Ddi_BddarrayComposeAcc(d0, vars, subst);
	      Ddi_BddarrayComposeAcc(d1, vars, subst);
	    }
	  }

	  Ddi_BddarraySubstVarsAcc(d0,itpMgr->ns,splitVaux);
	  Ddi_BddarraySubstVarsAcc(d0,itpMgr->pi,piAux);
	  Ddi_BddarraySubstVarsAcc(d1,itpMgr->ns,splitV2);
	  Ddi_BddarraySubstVarsAcc(d1,itpMgr->pi,tfpi);

	  if (itpNextRing != NULL) {
	    auxCone = Ddi_BddNot(itpNextRing);
	    Ddi_BddSubstVarsAcc(auxCone,itpMgr->ns,splitVaux2);
	  } 
	  else if (nextRing != NULL) {
	    auxCone = Ddi_BddNot(nextRing);
	    Ddi_BddSubstVarsAcc(auxCone,itpMgr->ns,splitVaux2);
	  }
	  if (auxCone!=NULL) {
	    Ddi_Bdd_t *auxA = Ddi_BddDup(aPart), *auxApart;
	    Ddi_Bdd_t *d0Rel = Ddi_BddRelMakeFromArray(d0,splitVaux2);
	    Ddi_Bdd_t *d1Rel = Ddi_BddRelMakeFromArray(d1,splitVaux2);
	    Ddi_Bdd_t *auxItp = NULL;
	    Ddi_BddPartInsertLast(auxA,d1Rel);
            if (useSeedStates) { 
	      Ddi_BddPartInsertLast(auxA,d0Rel);
	      Ddi_BddPartInsertLast(auxA,myBforCex);
	    }
	    Ddi_BddSetAig(auxA);
	    auxApart = Ddi_AigPartitionTop(auxA,0);
	    Ddi_Free(auxA);
	    if (Ddi_BddSize(auxCone)==1) {
	      Ddi_Free(myBforCex);
	      myBforCex = Ddi_BddDup(auxCone);
	      Ddi_BddComposeAcc(myBforCex, splitVaux2, d1);
	    }
	    else if (Ddi_AigSat(auxApart)) {
	      auxItp = 
		Ddi_AigSat22AndWithInterpolant(NULL,auxApart,auxCone,NULL,
					   itpMgr->nsvars, NULL,NULL,0,
					   itpSplit,NULL,
					   psat, 0, itpOdc, 1, timeLimit);
	      Pdtutil_Assert(auxItp!=NULL,"NULL itp");
	      Ddi_BddNotAcc(auxItp);
	      Ddi_BddComposeAcc(auxItp, splitVaux2, d1);
	      Ddi_Free(myBforCex);
	      myBforCex = Ddi_BddDup(auxItp);
	    }
	    {
	      miter = Ddi_BddMiterMakeFromArray(d0, d1);
	      Ddi_BddSetAig(miter);
	    
	      Ddi_AigConstrainCubeAcc(miter,savedSeedStates);
	      Ddi_BddAndAcc(miter,savedSeedStates);
	      Ddi_BddAndAcc(myBforCex,miter);
	    }

	    Ddi_Free(auxItp);
	    Ddi_Free(d1Rel);
	    Ddi_Free(d0Rel);
	    Ddi_Free(auxApart);
	    Ddi_Free(auxCone);
	  }
	  else {
	    miter = Ddi_BddMiterMakeFromArray(d0, d1);
	    Ddi_BddSetAig(miter);
	    
	    Ddi_AigConstrainCubeAcc(miter,myBforCex);

	    Ddi_BddAndAcc(myBforCex,miter);
	    Ddi_BddAndAcc(myBforCex,splitB);
	  }
	  Ddi_Free(savedSeedStates);

	  itpSplit2 =
	    Ddi_AigSat22AndWithInterpolant(NULL,aPart,myBforCex,NULL,
					   itpVars, NULL,NULL,0,
					   itpSplit,NULL,
					   psat, 0, itpOdc, 1, timeLimit);
	  if (itpSplit2==NULL) {
	    // SAT !
	    Ddi_Free(itpSplit);
	  } 
	  else {
	    Ddi_BddAndAcc(itpSplit,itpSplit2);
#if 0
	    itpSplit3 =
	      Ddi_AigSat22AndWithInterpolant(NULL,aPart,splitB,NULL,
					   itpVars, NULL,NULL,0,
					   NULL,NULL,
					   psat, 0, itpOdc, 1, timeLimit);
	    Ddi_Free(itpSplit3);
#endif
	  }
	  Ddi_Free(auxCone);
	  Ddi_Free(itpSplit2);
	  Ddi_Free(myBforCex);
	  Ddi_Free(miter);
	  Ddi_Free(itpVars);
	  Ddi_Free(d0);
	  Ddi_Free(d1);
	}
	else if (doItpStrengthen && 
		 (itpSplit!=NULL) && (itpNextRing != NULL)) {
	  Ddi_Bddarray_t *d0;
	  Ddi_Bdd_t *d0Rel;
	  Ddi_Bdd_t *itpSplit2, *itpSplit3;
	  Ddi_Bdd_t *itpCurr = NULL, *itpNext = NULL;
	  Ddi_Varset_t *itpVars = Ddi_VarsetMakeFromArray(splitV2);
	  Ddi_Varset_t *itpVarsAux = Ddi_VarsetMakeFromArray(splitVaux);
	  Ddi_Bdd_t *miter=NULL;
	  int tfShift = doSplit;
	  Ddi_Vararray_t *tfpi = itpMgr->timeFrames->PiVars[tfShift];
	  Ddi_Bdd_t *nextRing = NULL;
	  Ddi_Bdd_t *auxCone = NULL;
	  Ddi_Bdd_t *savedSeedStates = NULL;
	  int useSeedStates = 1; // itpNextRing==NULL
	  Ddi_Bdd_t *auxA = NULL, *auxApart;

	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    printf("Strengthening SPLIT ITP (%d) by fwd-bwd delta\n", 
		   Ddi_BddSize(itpSplit));
	  }
	  itpCurr = Ddi_BddDup(itpSplit);
	  itpNext = Ddi_BddDup(itpNextRing);
	  if (!Ddi_BddIsOne(careTotForCex)) {
	    Ddi_BddAndAcc(itpCurr,careTotForCex);
	  }

	  if (itpMgr->fromRings!=NULL && 
	      Ddi_BddarrayNum(itpMgr->fromRings)>split_i) {
	    Ddi_Bdd_t *ring = 
	      Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, split_i));
	    Ddi_BddSubstVarsAcc(ring,itpMgr->ns,splitV2);
	    //	    Ddi_BddAndAcc(itpCurr,ring);
	    Ddi_Free(ring);
	    if (Ddi_BddarrayNum(itpMgr->fromRings)>split_i+1) {
	      nextRing = Ddi_BddarrayRead(itpMgr->fromRings, split_i+1);
	      Ddi_BddAndAcc(itpNext,nextRing);
	    }
	  }
	  Ddi_BddSubstVarsAcc(itpNext,itpMgr->ns,splitVaux);

	  /* strengthen itpNext */

	  d0 = Ddi_BddarrayDup(itpMgr->delta);
	  Ddi_BddarraySubstVarsAcc(d0,itpMgr->ps,itpMgr->ns);
	  Ddi_BddarraySubstVarsAcc(d0,itpMgr->pi,piAux);
	  d0Rel = Ddi_BddRelMakeFromArray(d0,splitVaux);

	  itpMgrApplyRingEq(itpMgr,itpCurr,NULL,splitV2,split_i,0);
	  itpMgrApplyRingEq(itpMgr,d0Rel,NULL,NULL,split_i,0);
	  itpMgrApplyRingEq(itpMgr,d0Rel,NULL,splitVaux,split_i+1,0);
	  itpMgrApplyRingEq(itpMgr,itpNext,NULL,splitVaux,split_i+1,0);

	  Ddi_BddSubstVarsAcc(d0Rel,itpMgr->ns,splitV2);
	  Ddi_BddarraySubstVarsAcc(d0,itpMgr->ns,splitV2);

	  auxA = Ddi_BddDup(itpCurr);
	  Ddi_BddSetPartConj(auxA);
	  Ddi_BddPartInsertLast(auxA,d0Rel);
	  Ddi_BddSetAig(auxA);
	  auxApart = Ddi_AigPartitionTop(auxA,0);
	  Ddi_Free(auxA);

	  auxCone = Ddi_BddNot(itpNext);

	  if (Ddi_AigSat(auxApart)) {
	    Ddi_Bdd_t *auxItp = 
	      Ddi_AigSat22AndWithInterpolant(NULL,auxApart,auxCone,NULL,
					   itpVarsAux, NULL,NULL,0,
					   NULL,NULL,
					   psat, 0, itpOdc, 1, timeLimit);
	    Pdtutil_Assert(auxItp!=NULL,"NULL itp");
	    Ddi_Free(myBforCex);
	    myBforCex = Ddi_BddNot(auxItp);
	    Ddi_BddSubstVarsAcc(auxItp,splitVaux,itpMgr->ns);
	    Ddi_BddAndAcc(itpNextRing,auxItp);
	    Ddi_BddSetAig(d0Rel);
	    Ddi_BddAndAcc(myBforCex,d0Rel);
	    //	    Ddi_BddComposeAcc(myBforCex, itpMgr->ns, d0);
	    Ddi_Free(auxItp);
	  }
	  Ddi_Free(itpCurr);
	  Ddi_Free(itpNext);
	  Ddi_Free(d0Rel);
	  Ddi_Free(auxApart);
	  Ddi_Free(auxCone);

	  itpSplit2 =
	    Ddi_AigSat22AndWithInterpolant(NULL,aPart,myBforCex,NULL,
					   itpVars, NULL,NULL,0,
					   itpSplit,NULL,
					   psat, 0, itpOdc, 1, timeLimit);
	  Ddi_Free(auxApart);

	  if (itpSplit2==NULL) {
	    // SAT !
	    Ddi_Free(itpSplit);
	  } 
	  else {
	    Ddi_BddAndAcc(itpSplit,itpSplit2);

	  }
	  Ddi_Free(auxCone);
	  Ddi_Free(itpSplit2);
	  Ddi_Free(itpVarsAux);
	  Ddi_Free(myBforCex);
	  Ddi_Free(miter);
	  Ddi_Free(itpVars);
	  Ddi_Free(d0);
	}

	Ddi_Free(aPart);
	if (itpSplit!=NULL) {
	  printf("\nSPLIT ITP: %d (now computing part ITP)\n", 
		 Ddi_BddSize(itpSplit));
	}
	if (itpSplit!=NULL) {
	  Ddi_Bdd_t *myB2;
          //	  Ddi_AigOptByMonotoneCoreAcc(itpSplit,aSplit,careTotForCex,
          //			      1,-1.0);
	  if (cex!=NULL) {
	    int sat;
	    Ddi_Bdd_t *prod = Ddi_BddDup(itpSplit);
	    if (splitB!=NULL) {
	      Ddi_BddAndAcc(prod,splitB);
	    }
	    else {
	      Ddi_BddAndAcc(prod,bDup);
	    }
	    Ddi_BddAndAcc(prod,careTotForCex);
	    sat = Ddi_AigSatMinisatWithAbortAndFinal(prod,cex,-1.0,1);
	    Ddi_BddSetAig(cex);
	    Pdtutil_Assert(!sat,"unsat required");
	    Ddi_BddDiffAcc(careFinal,cex);
	    Ddi_Free(prod);
	  }
	  myB2 = Ddi_BddNot(itpSplit);
	  Ddi_BddAndAcc(careTotForCex, itpSplit);
          if (i==itpPart-1) {
            if ((saveSplitConeInfo>1) &&
                itpTravMgr->splitConeInfo.preImg!=NULL) {
              Ddi_Bdd_t *prevBwd =
                Ddi_BddDup(itpTravMgr->splitConeInfo.preImg);
              Ddi_BddSubstVarsAcc(prevBwd,splitRefV,splitV);
              Ddi_BddOrAcc(myB2,prevBwd);
              Ddi_Free(prevBwd);
            }
          }
          //	  Ddi_BddAndAcc(careTotSplit, itpSplit);
	  Ddi_BddComposeAcc(myB2,splitV,splitU);
	  if (splitConstr!=NULL) {
	    Ddi_BddAndAcc(myB2, splitConstr);
	  }
	  itp_i =
	    Ddi_AigSat22AndWithInterpolant(NULL,a,myB2,NULL,
					   globalVars, domainVars,NULL,0,
					   optCare,NULL,
					   psat, 0, itpOdc, 0, timeLimit);
	  //Pdtutil_Assert(itp_i!=NULL,"NULL itpSplit");
	  Ddi_Free(aSplit);
	  Ddi_Free(myB2);
	}
	else {
	  itp_i = NULL;
	}
	Ddi_Free(aSplit);
      }
      else if (itp_i==NULL) {
#if 1
        startTime = util_cpu_time();
	itp_i =
	  Ddi_AigSat22AndWithInterpolant(NULL,a,myB,NULL,
					 globalVars, domainVars,NULL,0,
					 optCare,NULL,
					 psat, 0, itpOdc, 0, timeLimit);
        itpTime = util_cpu_time() - startTime;
        if (itpTime > itpRefTime) {
          itpRefTime = itpTime;
        }
#else
	itp_i = Ddi_BddNot(myB);
#endif
      }
      Ddi_Free(cex);
      if ((itp_i!=NULL)&&toMinus!=NULL) {
	Ddi_BddOrAcc(itp_i,toMinus);
      }
      if ((itp_i!=NULL)&&Ddi_BddIsOne(itp_i)) {
	// skip
	// go to next iteration
      }
      else if ((itp_i!=NULL)&&
	       (Ddi_AigOptByMonotoneCoreAcc(itp_i,a,careTot,1,-1.0)==NULL)) {
	// SAT
	Ddi_Free(itp_i);
      }  
      else if (itp_i!=NULL && doSplitCare) {
	//    Ddi_Bdd_t *myCone = Ddi_BddDup(f_j0);
	Ddi_Bdd_t *myB2Ref = Ddi_BddNot(itpSplit);
	Ddi_Bdd_t *myB3 = Ddi_BddNot(itpSplit);
	//	Ddi_Bdd_t *myB4 = Ddi_BddDup(splitB);
	Ddi_Bdd_t *myB4 = Ddi_BddNot(itpSplit);
	Ddi_Bdd_t *myB2 = Ddi_BddNot(itpSplit);
	Ddi_Bdd_t *myConeRel=NULL, *itpSplitCare_i=NULL;
	Ddi_Bdd_t *myA = NULL;
      
	Ddi_Vararray_t *nsSupp = NULL;
	int splitCare_i = step+doSplit2;
	int start_i = step+doSplit, coneTopMark = 0;
      
	if (0 && !Ddi_BddIsOne(careTotForCex)) {
	  Ddi_BddAndAcc(myB4,careTotForCex);
	  Ddi_BddAndAcc(myB2,careTotForCex);
	  Ddi_BddAndAcc(myB2Ref,careTotForCex);
	  Ddi_BddAndAcc(myB3,careTotForCex);
	}
	Ddi_BddSubstVarsAcc(myB4, splitV2, itpMgr->ns);
	Ddi_BddSubstVarsAcc(myB2, splitV2, itpMgr->ns);
	//	Ddi_BddSubstVarsAcc(myB2Ref, splitV2, itpMgr->ns);
      
	//	Ddi_BddWriteMark(myB2, doSplit+1);
	Ddi_BddWriteMark(myB2, 0);
	Ddi_BddWriteMark(myB2Ref, 0);
	Ddi_BddWriteMark(myB4, 0);
      
	growConeBwd(itpMgr, myB2, start_i - 1, splitCare_i, itpMgr->delta,
		    itpMgr->initStub, useRingConstr, andWithRing_i, 1);
	coneTopMark = Ddi_BddReadMark(myB2);
	//	growConeBwd(itpMgr, myB2Ref, start_i-1, step, itpMgr->delta,
	//	    itpMgr->initStub, 1, 1);
	growConeBwd(itpMgr, myB4, start_i-1, step, itpMgr->delta,
		    itpMgr->initStub, useRingConstr, andWithRing_i, 1);
	Ddi_BddComposeAcc(myB2Ref,splitV,splitU);
	Ddi_BddComposeAcc(myB3,splitV,splitU);
      
	nsSupp = Ddi_BddSuppVararray(myB2);
	Ddi_VararrayIntersectAcc(nsSupp, itpMgr->ns);
      
	//problema cone
	myConeRel = growUnrollRelation(itpMgr, nsSupp, 
				       splitCare_i - 1, step,
				       itpMgr->delta, itpMgr->initStub, useRingConstr, 
				       andWithRing_i, 1, coneTopMark);
      
	if (Ddi_AigSat(myConeRel)) {
	  if (itpTravMgr->constrainVars != NULL && 
	      Ddi_VararrayNum(itpTravMgr->constrainVars)>0) {
	    Ddi_Vararray_t *v = Ddi_VararrayDup(itpTravMgr->constrainVars);
	    Ddi_Bddarray_t *s = Ddi_BddarrayDup(itpTravMgr->constrainSubstLits);
	    Ddi_BddarraySubstVarsAcc(s, itpMgr->ns, itpMgr->ps);
	    Ddi_VararraySubstVarsAcc(v, itpMgr->ns, itpMgr->ps);
	    Ddi_BddComposeAcc(myConeRel, v, s);
	    Ddi_Free(v);
	    Ddi_Free(s);
	  }
	  if (toPlusCube!=NULL && !Ddi_BddIsOne(toPlusCube)) {
	    Ddi_Bdd_t *t = Ddi_BddDup(toPlusCube);
	    Ddi_BddSubstVarsAcc(t, itpMgr->ns, itpMgr->ps);
	    Ddi_AigConstrainCubeAcc(myConeRel,t);
	    Ddi_Free(t);
	  }
	
	  myA = Ddi_BddDup(itp_i);
	  Ddi_BddSubstVarsAcc(myA, itpMgr->ns, itpMgr->ps);
	  //    chk = Ddi_BddCofactor(f_jj,pvarNs,1);
	  Ddi_BddAndAcc(myA, myConeRel);
	
	  if (!Ddi_AigSat(myA)) {
	    itpSplitCare_i = Ddi_BddMakeConstAig(ddm, 0);
	    itpEnded = 1;
	  }
	  else {
	    itpSplitCare_i =
	      Ddi_AigSat22AndWithInterpolant(NULL,myA,myB2,NULL,
					     globalVars, domainVars,NULL,0,
					     NULL,NULL,
					     psat, 0, itpOdc, 0, timeLimit);
	  }
	  Pdtutil_Assert(itpSplitCare_i != NULL, "UNSAT REQUIRED");
	  Ddi_BddAndAcc(careTotSplit, itpSplitCare_i);
	}
      
	Ddi_Free(myA);
	Ddi_Free(myConeRel);
	Ddi_Free(itpSplitCare_i);
	Ddi_Free(myB4);
	Ddi_Free(myB2);
	Ddi_Free(myB3);
	Ddi_Free(myB2Ref);
	Ddi_Free(nsSupp);  
      
      }
      if (completeOnSplit) {
	if (itpSplit!=NULL) {
	  Ddi_BddAndAcc(careTotForCex, itpSplit);
	}    
      }
      Ddi_Free(itpSplit);
      Ddi_Free(myB);
    }
  
    if (itp_i != NULL && i<itpPart-1) {
      if (!completeOnSplit && splitRel==NULL) {
	Ddi_BddAndAcc(careTotForCex, itp_i);
      }
      else if (!preSplit) {
	Ddi_Bdd_t *itpSplit, *aSplit = Ddi_BddAnd(itp_i,splitRel);
	int checkTime=0;
	if (optCare!=NULL) {
	  Ddi_BddAndAcc(aSplit,optCare);
	}
	itpSplit =
	  Ddi_AigSat22AndWithInterpolant(NULL,aSplit,myBforCex,NULL,
					 splitVars, NULL,NULL,0,
					 NULL,NULL,
					 psat, 0, itpOdc, 0, timeLimit);
	Pdtutil_Assert(itpSplit!=NULL,"NULL itpSplit");
	Ddi_AigOptByMonotoneCoreAcc(itpSplit,aSplit,careTotForCex,
				    1,-1.0);
	if (checkTime) {
	  long time0, time1;
	  Ddi_Bdd_t *itp2, *bSplit = Ddi_BddAnd(itpSplit,splitRel);
	  time0 = util_cpu_time();
	
	  itp2 =
	    Ddi_AigSat22AndWithInterpolant(NULL,a,bSplit,NULL,
					   splitVars, NULL,NULL,0,
					   optCare,NULL,
					   psat, 0, itpOdc, 0, timeLimit);
	  time1 = util_cpu_time() - time0;
	  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
	    fprintf(dMgrO(ddm),"ITP2 time = %s\n", util_print_time (time1));
	  }
	  Ddi_Free(bSplit);
	  Ddi_Free(itp2);
	}
      
	Ddi_BddAndAcc(careTotForCex, itpSplit);
	Ddi_Free(itpSplit);
	Ddi_Free(aSplit);
      }
    }
  
    Ddi_Free(toMinusSplit);
    Ddi_Free(myB);
    Ddi_Free(myBforCex);
  
    if (itp_i != NULL) {
      Ddi_BddAndAcc(itpTot, itp_i);
      Ddi_BddAndAcc(careTot, itp_i);
    
      if (doFwdBwd) {
	Ddi_Bdd_t *itpSplit2, *itp_i2;
	Ddi_Bdd_t *myA2 = Ddi_BddAnd(itpTot,splitRel);
	Ddi_Bdd_t *myB2 = Ddi_BddNot(careTotForCex);	
	itpSplit2 =
	    Ddi_AigSat22AndWithInterpolant(NULL,myA2,myB2,NULL,
					   globalVars, NULL,NULL,0,
					   NULL,NULL,
					   psat, 0, itpOdc, 0, timeLimit);
	
        Pdtutil_Assert(itpSplit2!=NULL,"NULL ITP");
	Ddi_Free(myA2);
	Ddi_Free(myB2);
	
	myB2 = Ddi_BddNot(itpSplit2);
	Ddi_BddAndAcc(careTotForCex,itpSplit2);
	Ddi_BddComposeAcc(myB2,splitV,splitU);
	Ddi_Free(itpSplit2);
	if (splitConstr!=NULL) {
	  Ddi_BddAndAcc(myB2, splitConstr);
	}
	itp_i2 =
	    Ddi_AigSat22AndWithInterpolant(NULL,a,myB2,NULL,
					   globalVars, domainVars,NULL,0,
					   optCare,NULL,
					   psat, 0, itpOdc, 0, timeLimit);


	Pdtutil_Assert(itp_i2!=NULL,"NULL itpSplit");
	Ddi_Free(myB2);

	Ddi_AigOptByMonotoneCoreAcc(itp_i,a,careTot,1,-1.0);

	Ddi_BddAndAcc(itpTot, itp_i2);
	Ddi_BddAndAcc(careTot, itp_i2);
      
      }

      Ddi_Free(itp_i);

    }
    else {
      Ddi_Free(itpTot);
      break;
    }
  
  }

  static int chkItp = saveSplitConeInfo>1;
  if (saveSplitConeInfo && itpTot!=NULL) {
    Ddi_Bdd_t *bwdRing = Ddi_BddNot(careTotForCex);
    Ddi_Bdd_t *prevRing = NULL;
    int bound = Ddi_BddReadMark(splitB), ring_i = step+doSplit;
    Ddi_BddSubstVarsAcc(bwdRing,splitV,splitRefV);
    Ddi_Free(itpTravMgr->splitConeInfo.ring);
    itpTravMgr->splitConeInfo.ring = Ddi_BddDup(bwdRing);
    if (saveSplitConeInfo>1) {
      if (itpTravMgr->splitConeInfo.preImg!=NULL) {
        prevRing = Ddi_BddDup(itpTravMgr->splitConeInfo.preImg);
        Ddi_Free(itpTravMgr->splitConeInfo.preImg);
      }
      int saveItpReverse = ddm->settings.aig.itpReverse;
      //ddm->settings.aig.itpReverse = 0;
      if (careForPreimg!=NULL) {
        Ddi_Free(bwdRing);
        bwdRing = Ddi_BddNot(careForPreimg);
        Ddi_BddSubstVarsAcc(bwdRing,splitV,splitRefV);
        Ddi_BddOrAcc(bwdRing,prevRing);
      }
      itpTravMgr->splitConeInfo.preImg =
        itpBwdRingPreimg(itpMgr,bwdRing,prevRing,ring_i,bound);
      ddm->settings.aig.itpReverse = saveItpReverse;
      Ddi_Free(prevRing);
    }
    if (chkItp) {
      Ddi_Bdd_t *chkA = Ddi_BddDup(a);
      if (optCare!=NULL) {
        Ddi_BddAndAcc(chkA,optCare);
      }
      Pdtutil_Assert(Ddi_BddIncluded(chkA,itpTot),"wrong itp - A side");
      Ddi_Free(chkA);
      Pdtutil_Assert(!Ddi_AigSatAnd(b,itpTot,optCare),
                     "wrong itp - B side");
      Ddi_Bdd_t *chkRingFwd = Ddi_BddDup(itpTot);
      if (optCare!=NULL) {
        Ddi_BddAndAcc(chkRingFwd,optCare);
      }
      int res = itpCheckConeAtRing(itpMgr,chkRingFwd,bwdRing,step,doSplit-1,0);
      int res1 = itpCheckConeAtRing(itpMgr,chkRingFwd,
        itpTravMgr->splitConeInfo.preImg,step,doSplit,0);
      assert(0 || !res && !res1);
      Ddi_Free(chkRingFwd);
    }
    Ddi_Free(bwdRing);
  }
  
  Ddi_Free(itpNextRing);
  Ddi_Free(splitV2);
  Ddi_Free(piAux);
  Ddi_Free(splitVaux);
  Ddi_Free(splitVaux2);
  Ddi_Free(splitB);
  Ddi_Free(splitCare);
  Ddi_Free(splitConstr);
  Ddi_Free(splitU);
  Ddi_Free(splitV);
  Ddi_Free(splitRel);
  Ddi_Free(splitRel2);
  Ddi_Free(splitVars);

  Ddi_Free(bDup);
  Ddi_Free(careTot);
  Ddi_Free(careFinal);
  Ddi_Free(careTotSplit);
  Ddi_Free(careTotForCex);
  Ddi_Free(careTotForA);
  Ddi_Free(careForPreimg);

  Ddi_IncrSatMgrQuitKeepDdi(ddiS);

  if (itpTot!=NULL && !Ddi_BddIsConstant(itpTot)) {
    Ddi_AigOptByMonotoneCoreAcc (itpTot,a,careTot,1,-1.0);
  }

  if (itpTot==NULL && psat!=NULL) {
    *psat=1;
  }

  if (chkres && itpTot!=NULL) {
    if (0 && Ddi_AigSatAnd(itpTot,b,optCare)) {
      printf("WARNING: partial interpolant\n");
    }
    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,b,optCare),"wrong part itp");
    Ddi_BddNotAcc(itpTot);
    Pdtutil_Assert(!Ddi_AigSatAnd(itpTot,a,optCare),"wrong part itp");
    Ddi_BddNotAcc(itpTot);
  }
  else if (chkresSat && itpTot!=NULL && psat!=NULL && *psat) {
    Pdtutil_Assert(Ddi_AigSatAnd(itpTot,b,optCare),"wrong itp sat");
  }
  else if (chkresSat && itpTot==NULL && psat!=NULL && *psat) {
    Pdtutil_Assert(Ddi_AigSatAnd(a,b,optCare),"wrong itp sat");
  }

  return itpTot;
}



/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
itpImg(
  Trav_ItpTravMgr_t * itpTravMgr,
  Ddi_Bdd_t * kCone,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t * kConeOld,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * careOut,
  int *pAbort,
  int optLevel,
  int maxIter
)
{
  Trav_Mgr_t *travMgr = itpTravMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Trav_ItpMgr_t *itpMgr = itpTravMgr->itpMgr;
  Ddi_Bddarray_t *initStub = itpMgr->initStub;
  Ddi_Vararray_t *pi = itpMgr->pi;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Bddarray_t *psLit = itpMgr->psLit;
  Ddi_Bddarray_t *nsLit = itpMgr->nsLit;
  Ddi_Vararray_t *dynAbstrAux = itpMgr->dynAbstrAux;
  Ddi_Vararray_t *dynAbstrCut = itpMgr->dynAbstrCut;
  Ddi_Bddarray_t *dynAbstrCutLits = itpMgr->dynAbstrCutLits;
  unsigned char *enAbstr = itpMgr->enAbstr;
  Ddi_Vararray_t *abstrRefCtrl = itpMgr->abstrRefCtrl;
  Ddi_Bddarray_t *abstrDoAbstr = itpMgr->abstrDoAbstr;
  Ddi_Bddarray_t *abstrDoRefine = itpMgr->abstrDoRefine;
  Ddi_Varset_t *ternarySmooth = NULL;
  Ddi_Varset_t *nsvars = itpMgr->nsvars;
  Ddi_Varset_t *psvars = itpMgr->psvars;
  Ddi_Bdd_t *savePreviousFrom = NULL;
  Ddi_Bdd_t *bReached = NULL, *checkReached = NULL, *saveFromBdd = NULL;
  int step = itpTravMgr==NULL ? 0 : itpTravMgr->stats.step, sat;
  int enCheckReached = 0;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int dynAbstr = Trav_MgrReadDynAbstr(travMgr);
  int ternaryAbstr = Trav_MgrReadTernaryAbstr(travMgr);
  int implAbstr = Trav_MgrReadImplAbstr(travMgr);
  int abstrWithCone = travMgr->settings.aig.itpTrAbstr;
  int abstrRef = Trav_MgrReadAbstrRef(travMgr) % 100;
  int abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  int redRem = Ddi_MgrReadAigRedRemLevel(ddm);
  int useAbstrTr = 0;
  int again;
  int optReachedThresh = 10000;
  int optFromThresh = 5000;
  int optToThresh = 5000;
  int abortedTo = 0;
  int enDynAbstrOpt = /*dynAbstr==3 || */ dynAbstr > 5 || ternaryAbstr > 0;
  int enDynAbstrBase = dynAbstr > 0;
  int maxFailBddFwd = 1;
  int enBwdCareSimplify = 1;
  int useCareBwd;
  int enToPlusImage = Trav_MgrReadItpEnToPlusImg(travMgr);
  int itpPart = Trav_MgrReadItpPart(travMgr);
  int itpPartTh = Ddi_MgrReadAigItpPartTh(ddm);
  int enItpBdd = Trav_MgrReadItpBdd(travMgr);
  int itpAppr = Trav_MgrReadItpAppr(travMgr);
  int useFwdUnroll = 0;
  float itpTimeLimit = -1.0;
  int useTimedItp = 1 || itpMgr->boundkOptPis != NULL;
  int enDynAbstr = 1, enDynAbstr0 = 1, maxNoAbstr0 = 2, maxNoAbstr = 2;
  int enToPlusCubeSat = implAbstr > 1;
  Ddi_Bdd_t *myInvarConstr = NULL;
  int doInductiveToPlus = Trav_MgrReadItpInductiveTo(travMgr);
  int initAbstr = Trav_MgrReadItpInitAbstr(travMgr);
  int endAbstr = Trav_MgrReadItpEndAbstr(travMgr);
  int minDynAbstrStep = Trav_MgrReadDynAbstrInitIter(travMgr);
  int imgApprEn = 400;
  int eqBeforeDynAbstr = dynAbstr>0 && dynAbstr<=2;
  int eqAfterDynAbstr = !eqBeforeDynAbstr;
  int tightenOrLoosen = (doInductiveToPlus > 6);
  int doInductiveToPlus2 = (doInductiveToPlus > 2);
  int refineToPlus = 1 || (itpAppr > 1 || doInductiveToPlus > 7);
  int useTrRange = 0;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int enRewind = travMgr->settings.aig.igrRewind
    && Trav_MgrReadIgrGrowCone(travMgr) >= 0;
  Trav_Shared_t *travPdrShared = NULL, *travShared = NULL;
  int itpExact = Trav_MgrReadItpExact(travMgr);
  int incompleteTrav = 0;
  int itpConstrLevel = Trav_MgrReadItpConstrLevel(travMgr);
  int useNewFwd = travMgr->settings.aig.itpNew;
  //  int useCareFwd = 1 || Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c
  //  || Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectCofactor_c;
  int useCareFwd = 0 &&(Trav_MgrReadFromSelect(travMgr) != Trav_FromSelectReached_c); // XXX
  int maxTernary = 20;
  Ddi_Bdd_t *reached1 = NULL;
  int itpGenMaxIter = Trav_MgrReadItpGenMaxIter(travMgr);
  int cegarAbstrRef = 0;
  Ddi_Bdd_t *fullInit = NULL;
  int enStructAbstractionWithCone = travMgr->settings.aig.itpStructAbstr;
  int implAbstrInitIter = Trav_MgrReadDynAbstrInitIter(travMgr);
  int doMonotoneGen = 0;
  int monotoneRedRemTh = 0;     //20000;
  // enable for igrpdr
  int doAbstrRefinedTo = travMgr->settings.ints.doAbstrRefinedTo;
  //int doAbstrStoredTo = 1; // growCone>2;
  int doAbstrStoredTo = 1; // doInductiveToPlus>2 && growCone>2; // XXX
  int enItpAbort = 0, enItpSeq = 0, prevToSize = -1;
  int rpmTh = travMgr->settings.aig.itpRpm;
  int chkSupp = 1;
  int chkRings = 0;
  int enFpChk = 1;
  int useMinisat22 = 1; // ddm->settings.aig.itpDrup; // use 2 for true incremental SAT 
  Ddi_IncrSatMgr_t *ddiS = NULL;
  Ddi_Mgr_t *ddmDup=NULL;
  int step0 = step;
  int maxIgrSame = -1;
  int coneBoundOK = -1;
  int reImgOnWeakening=travMgr->settings.aig.itpReImg, 
    suspendReImg=0;
  int fromNewLevel = travMgr->settings.aig.itpFromNewLevel;
  int enItpStrengthen=1;
  int sizeFrom;
  int piConstrBoundTh = itpMgr->igr.coneSubsetBound;
  int doPiConstr = 0;
  float coneSplitRatio = travMgr->settings.aig.igrConeSplitRatio;
  int enConeSplit = 0 && (coneSplitRatio < 0.99);
  int usePrevTo = 0;
  int abstrCareVarsWithDynAbstr = 1;

  if (fromNewLevel >= 10) {
    fromNewLevel = 0;
    usePrevTo = 1;
  }

  itpTravMgr->settings.enItpSeq = 0;

  if (doInductiveToPlus2) {
    doInductiveToPlus--;
  }

  if (enRewind && (travMgr->settings.aig.igrRewind > 1)) {
    maxIgrSame = travMgr->settings.aig.igrRewind;
    enRewind = 0;
  }

  if (strcmp(ddm->settings.aig.satSolver,"minisat114")==0) {
    useMinisat22=0;
  }

  if (useMinisat22>1) {
    //    ddiS = Ddi_IncrSatMgrAlloc(NULL, 1, 1, 0);
    ddmDup = Ddi_MgrDup(ddm);
    ddiS = Ddi_IncrSatMgrAlloc(ddmDup, 0 /* minisat 1.4 */, 1, 0);
    //    itpTravMgr->incrSat = ddiS;
  }

#if 1
  if (initStub != NULL && (itpTravMgr->settings.storeRings ||
      (itpMgr->nRings > 2))) {
    useCareFwd = 0;
  }
  if (itpTravMgr->careBwd != NULL && !Ddi_BddIsOne(itpTravMgr->careBwd)) {
    useCareFwd = 0;
  }
  if (Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectReached_c ||
    Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectTo_c) {
    useCareFwd = 0;
  }
#endif
  /* THIS IS THE TRAVERSAL LOOP !!! */

  do {
    int sizeAig;
    Ddi_Bdd_t *prevTo = NULL, *newFwd = NULL, *toMinusTot = NULL;
    Ddi_Bdd_t *fpCheck;
    Ddi_Bdd_t *localCone = NULL, *careCone = NULL, *toPlus = NULL,
      *toPlusCube = NULL, *itpCare = NULL, *itpFullCare = NULL;
    Ddi_Varset_t *abstrVars = NULL;
    Ddi_Bddarray_t *implArray = NULL;
    int useApproxToPlus = 0;
    int toBddInCareBdd = 0;
    Tr_Tr_t *trBdd2 = NULL;
    Ddi_Bdd_t *inductiveTo = NULL, *inductiveTo2 = NULL,
      *myCareBwd = Ddi_BddDup(itpTravMgr->careBwd);
    int undoCex = 0;
    int enGeneralizedItp = 0;
    int itpDone = 0;
    int conePhase_0 = 0;
    int enFromNew = 0;
    int useCareOpt = 0;
    
    itpPart = Trav_MgrReadItpPart(travMgr);
    itpPartTh = Ddi_MgrReadAigItpPartTh(ddm);

    static int nIter = 0;

    /* settings for this image */

    if (itpTravMgr->settings.tryInnerRing > 2 &&
        (enRewind || maxIgrSame > 0)) {
      if (maxIgrSame > 0) {
	if ((step-step0) >= maxIgrSame) {
          itpTravMgr->settings.tryInnerRing = 2;
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
				 fprintf(tMgrO(travMgr),
            "\nMAX SAME REACHED - CONE REWIND STARTED.\n\n")
          );
          itpMgr->igr.sameConeFail = step+1;
          itpTravMgr->settings.checkCompleteness = 0;
          Ddi_BddPartRemove(kConeRings,0);
          *pAbort = 1;

          itpMgr->stats.igrRewindRing = step; 
	  itpTravMgr->settings.enItpSeq = travMgr->settings.aig.igrItpSeq;
          if (itpTravMgr->settings.storeRings) {
            Ddi_BddarrayWrite(itpMgr->fromRings, step, itpTravMgr->from);
          }
          step++;
          Ddi_Free(myCareBwd);
          break;

	}
      }
    }
    else if (itpTravMgr->settings.tryInnerRing == -2) {
       itpTravMgr->settings.enItpSeq = 
         travMgr->settings.aig.igrItpSeq;
    }
    if (itpTravMgr->settings.enItpSeq) {
      useMinisat22=0;
    }
    enFpChk = !(growCone && itpTravMgr->stats.coneHit)
      || itpMgr->abstrRefNnf;
    nIter++;
    //    || travMgr->settings.aig.igrMaxExact>10000;
    /* itpTravMgr->careBwd comes fro upper level routines: and with from if
       necessary */
    //    Ddi_MgrConsistencyCheck (ddm);


    if (itpMgr->inductiveRplusLocal != NULL) {
      Ddi_BddAndAcc(myCareBwd, itpMgr->inductiveRplusLocal);
    }

    if (travMgr->settings.aig.pdrShareReached ||
      travMgr->settings.aig.itpShareReached) {
      travShared = &(travMgr->xchg.shared);
      travPdrShared = travShared->sharedLink;
    }

    if (itpTravMgr->from == NULL) {
      if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        printf("  Aig interpolant inner iteration %d: (from=NULL) -> ", step);
        fflush(tMgrO(travMgr));
      }
    } else {

      /* this is the normal case */

      if (0 && (itpGenMaxIter >= 0)) {
        Ddi_Free(itpTravMgr->constrainVars);
        Ddi_Free(itpTravMgr->constrainSubstLits);
        itpTravMgr->constrainVars = Ddi_VararrayAlloc(ddm, 0);
        itpTravMgr->constrainSubstLits = Ddi_BddarrayAlloc(ddm, 0);
      }

      if (itpTravMgr->settings.useInitStub) {
        Ddi_Free(itpTravMgr->from);
        Ddi_Free(savePreviousFrom);
        itpTravMgr->from = Ddi_BddMakeConstAig(ddm, 1);
      }

      /* handle stored rings */
      if (itpTravMgr->settings.storeRings) {

        int doRingWeakening = travMgr->settings.aig.itpWeaken;
        int doRingStrengthening = travMgr->settings.aig.itpStrengthen;
	Ddi_Bdd_t *prevStoredConstr = NULL;
	Ddi_Bdd_t *prevStoredFrom = NULL;

        if (step == 0) {
          Ddi_BddarrayWrite(itpMgr->reachedRings, step, itpTravMgr->reached);
          if (itpMgr->initStub==NULL) {
	    Ddi_BddarrayWrite(itpMgr->fromRings, step, itpTravMgr->from);
          }
        }
        else {
	  if (itpTravMgr->prevStoredFrom!=NULL) {
	    prevStoredFrom = Ddi_BddDup(itpTravMgr->prevStoredFrom);
	  }
	  else if (Ddi_BddarrayNum(itpMgr->fromRings)>step) {
	    prevStoredFrom = 
	      Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, step));
	  }
	  else {
	    prevStoredFrom = Ddi_BddMakeConstAig(ddm, 1);
	  }
	  Ddi_BddarrayWrite(itpMgr->fromRings, step, itpTravMgr->from);
	  
	}

	if (coneBoundOK>=0) {
	  Trav_ItpMgrSetConeBoundOK(itpMgr,step,coneBoundOK);
	  Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
	    printf("ring %d - safe for bound %d\n", step, coneBoundOK);
	  }
	}
        itpMgr->nRings = Ddi_BddarrayNum(itpMgr->fromRings);
        if (0 && itpConstrLevel > 1 && myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(Ddi_BddarrayRead(itpMgr->reachedRings, step),
            myInvarConstr);
          Ddi_AigAndCubeAcc(Ddi_BddarrayRead(itpMgr->fromRings, step),
            myInvarConstr);
        }
        if (itpMgr->eqRings != NULL) {
          if (itpTravMgr->constrainVars != NULL) {
            Ddi_Bdd_t *myConstr = Ddi_BddMakeEq(itpTravMgr->constrainVars,
              itpTravMgr->constrainSubstLits);
	    checkEqConstr(itpTravMgr->constrainVars,itpTravMgr->constrainSubstLits);

	    if (step>1) {
	      while (Ddi_BddarrayNum(itpMgr->eqRings)<step) {
		Ddi_Vararray_t *eqV = Ddi_VararrayAlloc(ddm, 0);
		Ddi_Bddarray_t *eqS = Ddi_BddarrayAlloc(ddm, 0);
		Ddi_Bdd_t *myC = Ddi_BddMakeEq(eqV,eqS);
		Ddi_BddarrayInsertLast(itpMgr->eqRings, myC);
		Ddi_Free(myC);
		Ddi_Free(eqV);
		Ddi_Free(eqS);
	      }
	    }
	    if (Ddi_BddarrayNum(itpMgr->eqRings)>step) {
	      prevStoredConstr = 
		Ddi_BddDup(Ddi_BddarrayRead(itpMgr->eqRings, step));
	    }
	    else {
	      Ddi_Vararray_t *eqV = Ddi_VararrayAlloc(ddm, 0);
	      Ddi_Bddarray_t *eqS = Ddi_BddarrayAlloc(ddm, 0);
	      prevStoredConstr = Ddi_BddMakeEq(eqV,eqS);
	      Ddi_Free(eqV);
	      Ddi_Free(eqS);
	    }
            Ddi_BddarrayWrite(itpMgr->eqRings, step, myConstr);
            if (chkRings) {
              Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->from, myConstr),
                "eq inclusion problem in from rings");
            }
            Ddi_Free(myConstr);
          }
        }
        if (chkRings && step > 1) {
          Ddi_Bdd_t *bck = Ddi_BddNot(itpTravMgr->from);
          Ddi_Bdd_t *constr = NULL;

          if (itpMgr->invarConstr != NULL) {
            constr =
              Ddi_BddSubstVars(itpMgr->invarConstr, itpMgr->ps, itpMgr->ns);
            Ddi_BddAndAcc(bck, constr);
          }
          Ddi_BddComposeAcc(bck, itpMgr->ns, itpMgr->delta);
          Ddi_BddSubstVarsAcc(bck, itpMgr->ps, itpMgr->ns);
          Pdtutil_Assert(!Ddi_AigSatAnd(Ddi_BddarrayRead(itpMgr->fromRings,
                step - 1), bck, constr), "img problem in from rings");
          Ddi_Free(bck);
          Ddi_Free(constr);
        }
        if (step > 0 && chkRings
          && (step + 1) < Ddi_BddarrayNum(itpMgr->fromRings)) {
          Ddi_Bdd_t *bck =
            Ddi_BddNot(Ddi_BddarrayRead(itpMgr->fromRings, step + 1));
          Ddi_BddComposeAcc(bck, itpMgr->ns, itpMgr->delta);
          Ddi_BddSubstVarsAcc(bck, itpMgr->ps, itpMgr->ns);
          if (Ddi_AigSatAnd(itpTravMgr->from, bck, NULL)) {
            Ddi_Bdd_t *bck0 =
              Ddi_BddNot(Ddi_BddarrayRead(itpMgr->fromRings, step + 1));
            Ddi_BddComposeAcc(bck0, itpMgr->ns, itpMgr->delta0);
            Ddi_BddSubstVarsAcc(bck0, itpMgr->ps, itpMgr->ns);
            int j;

            for (j = 0; j < Ddi_BddarrayNum(itpMgr->delta); j++) {
              Ddi_Bdd_t *d = Ddi_BddarrayRead(itpMgr->delta, j);
              Ddi_Bdd_t *d0 = Ddi_BddarrayRead(itpMgr->delta0, j);

              if (!Ddi_BddIncluded(d, d0)) {
                printf("abstr delta inclusion problem [%d] size %d - %d\n",
                  j, Ddi_BddSize(d), Ddi_BddSize(d0));
              }
            }

            Pdtutil_Assert(!Ddi_AigSatAnd(itpTravMgr->from, bck0, NULL),
              "img problem in from rings");
            Ddi_Free(bck0);
          }
          Pdtutil_Assert(!Ddi_AigSatAnd(itpTravMgr->from, bck, NULL),
            "img problem in from rings");
          Ddi_Free(bck);
        }
        if (itpTravMgr->toItpSeq != NULL) {
          int jj;

          for (jj = 0; jj < Ddi_BddarrayNum(itpTravMgr->toItpSeq); jj++) {
            Ddi_Bdd_t *r_s_jj = NULL;
            Ddi_Bdd_t *itp_jj = Ddi_BddarrayRead(itpTravMgr->toItpSeq, jj);

            if (Ddi_BddarrayNum(itpMgr->fromRings) > step + jj + 1) {
              r_s_jj = Ddi_BddarrayRead(itpMgr->fromRings, step + jj + 1);
              Ddi_BddAndAcc(itp_jj, r_s_jj);
            }
            Ddi_BddarrayWrite(itpMgr->fromRings, step + jj + 1, itp_jj);
          }
          //      Ddi_Free(itpTravMgr->toItpSeq);
          itpMgr->nRings = Ddi_BddarrayNum(itpMgr->fromRings);
          step += Ddi_BddarrayNum(itpTravMgr->toItpSeq) + 1;
        }

        if ((((doRingWeakening>1) && (Ddi_BddSize(itpTravMgr->from) > doRingWeakening))  || 
            ((doRingStrengthening>1) && (Ddi_BddSize(itpTravMgr->from) > doRingStrengthening))) && 
            step > 2 && (step > step0) && itpTravMgr->toItpSeq == NULL) {
          int jj, r0;
	  Ddi_Bdd_t *prevRing = Ddi_BddarrayRead(itpMgr->fromRings, step-1);
	  int prevRingSize = Ddi_BddSize(prevRing);
	  int enReImg=1;
          Ddi_Free(itpTravMgr->from);
	  Ddi_Bddarray_t *myDelta = (itpMgr->deltaAbstr)?
	    itpMgr->delta0:itpMgr->delta;
          itpSimplifyRingsBwdFwd(itpMgr, step, 2, myDelta, -1, 1, 
				 &enItpStrengthen,0);
          if (0 && (Ddi_BddSize(Ddi_BddarrayRead(itpMgr->fromRings, step)) >
		    2 * doRingWeakening)) {
            itpSimplifyRingsBwdFwd(itpMgr, step, 2, itpMgr->delta, -1, 1, 
				   &enItpStrengthen,0);
          }
	  prevRing = Ddi_BddarrayRead(itpMgr->fromRings, step-1);
	  enReImg = prevRingSize >= Ddi_BddSize(prevRing)*1.2;
	  if (enReImg && suspendReImg!=step && reImgOnWeakening) {
	    suspendReImg = step;
	    Pdtutil_Assert(step>0,"step>0 needed");

	    if (1 && prevStoredFrom!=NULL) {
	      Ddi_BddarrayWrite(itpMgr->fromRings, step, prevStoredFrom);
	    }
	    if (1 && prevStoredConstr!=NULL) {
	      Ddi_BddarrayWrite(itpMgr->eqRings, step, prevStoredConstr);
	    }
	    step--;
	    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
	      printf("\nRecomputing ring %d after weakening/strengthening step\n", step);
	    }
	    conePhase_0 = -1;
	    
	  }
          if (itpTravMgr->prevFrom != NULL) {
            Ddi_Free(itpTravMgr->prevFrom);
            itpTravMgr->prevFrom = Ddi_BddDup(prevRing);
            Ddi_BddComposeAcc(itpTravMgr->prevFrom, itpMgr->ns, itpMgr->psLit);
          }
          itpTravMgr->from =
            Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, step));
          Ddi_Free(itpTravMgr->reached);
          if (Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectReached_c) {
            itpTravMgr->reached = Ddi_BddDup(itpTravMgr->from);
          } else {
            int useOnlyFrom = 1;
            if (useOnlyFrom) {
              r0 = 0;
              Ddi_Bdd_t *f_0 = Ddi_BddarrayRead(itpMgr->fromRings,0);
              if (f_0!=NULL) {
                itpTravMgr->reached =Ddi_BddDup(f_0);
              }
              else {
                itpTravMgr->reached = Ddi_BddMakeConstAig(ddm, 0);
              }
            }
            else {
              r0 = step - 3;
              if (r0<0) r0=0;
              if (r0 >= Ddi_BddarrayNum(itpMgr->reachedRings)) {
                r0 = Ddi_BddarrayNum(itpMgr->reachedRings) - 1;
              }
              itpTravMgr->reached =
                Ddi_BddDup(Ddi_BddarrayRead(itpMgr->reachedRings, r0));
            }
            for (jj = r0 + 1; jj <= step; jj++) {
              Ddi_BddOrAcc(itpTravMgr->reached,
                Ddi_BddarrayRead(itpMgr->fromRings, jj));
              Ddi_BddSetAig(itpTravMgr->reached);
              Ddi_BddarrayWrite(itpMgr->reachedRings, jj, itpTravMgr->reached);
            }
          }

          if (savePreviousFrom != NULL) {
            Ddi_Free(savePreviousFrom);
            savePreviousFrom = Ddi_BddDup(itpTravMgr->from);
          }
        }
	Ddi_Free(prevStoredConstr);
	Ddi_Free(prevStoredFrom);

	if (0 && (travMgr->settings.aig.itpTrAbstr>0)) {
	  itpTrAbstrWithItpRefineWithRings(itpMgr,step-1,step);
	}

        int nrings = Ddi_BddarrayNum(itpMgr->fromRings);
        if (travMgr->settings.aig.itpStoreRings != NULL && nrings > 2) {
          Ddi_Bddarray_t *benchArray;
          char filename[100];
          benchArray = Ddi_BddarrayDup(itpMgr->fromRings);
          if (Ddi_BddarrayRead(benchArray,0)==NULL) {
            Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
            Ddi_BddarrayWrite(benchArray,0,myZero);
            Ddi_Free(myZero);
          }
          while (Ddi_BddIsOne(Ddi_BddarrayRead(benchArray,Ddi_BddarrayNum(benchArray)-1)))
            Ddi_BddarrayRemove(benchArray,Ddi_BddarrayNum(benchArray)-1);
          nrings = Ddi_BddarrayNum(benchArray);
          if (nrings>2) {      
            int safe = Trav_ItpMgrReadConeBoundOK(itpMgr,nrings-1);
            strcpy(filename, travMgr->settings.aig.itpStoreRings);
            char *s = strstr(filename,".aig");
            if (s==NULL) s = filename+strlen(filename);
            sprintf(s, "_ITP_sequence_%d_%d.aig", nrings, safe);
            if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
              printf("Writing itp rings to %s\n", filename);
            }
            Ddi_AigarrayNetStoreAiger(benchArray, 0, filename);
          }
          Ddi_Free(benchArray);
        }
        
      }

      if (itpTravMgr->toItpSeq != NULL) {
        *pAbort = 1;
        again = 0;
        Ddi_Free(itpTravMgr->toItpSeq);
        break;
      }

      if (1 && !dynAbstr && optLevel > 0 &&
        itpTravMgr->careFwd != NULL && (0
          && (Ddi_BddSize(itpTravMgr->careFwd) <
            Ddi_BddSize(itpTravMgr->from))) || (itpTravMgr->careFwd != NULL
          && Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c)) {
        Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->careFwd);
      }

      itpTravMgr->to = NULL;
      if (doInductiveToPlus) {
        if (step >= ((initAbstr > 2) ? initAbstr : initAbstr)) {
	  if (endAbstr <=0 || step <= endAbstr) {
	    inductiveTo = Ddi_BddDup(itpTravMgr->from);
	  }
        }
      }

      if (0 && !Ddi_BddIsOne(itpTravMgr->from)) {
        prevTo = Ddi_BddDup(itpTravMgr->from);
        //Pdtutil_Assert(!Ddi_AigSatAnd(prevTo,kCone,NULL),"wrong prev itp");
      }

      Ddi_Free(itpTravMgr->careFwd);
      if (useCareFwd) {
        //
        if (itpTravMgr->settings.storeRings) {
          if (itpMgr->nRings > 0 && itpMgr->initStub==NULL) {
            itpTravMgr->careFwd =
              Ddi_BddNot(Ddi_BddarrayRead(itpMgr->fromRings, 0));
          } else {
            itpTravMgr->careFwd = Ddi_BddMakeConstAig(ddm, 1);
          }
        } else {
          if (itpMgr->initStub==NULL) {
            itpTravMgr->careFwd = Ddi_BddNot(itpTravMgr->from);
          }
          else {
            itpTravMgr->careFwd = Ddi_BddMakeConstAig(ddm, 1);
          }
        }
      } else {
        itpTravMgr->careFwd = Ddi_BddMakeConstAig(ddm, 1);
      }

      if (0 && !Ddi_BddIsOne(itpTravMgr->from) && growCone>2) {
	Ddi_Free(itpTravMgr->careForBwdCone);
	itpTravMgr->careForBwdCone = Ddi_BddNot(itpTravMgr->from);
      }

      if (itpTravMgr->careBwd != NULL
        && !Ddi_BddIncluded(itpTravMgr->from, itpTravMgr->careBwd)) {
        Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->careBwd);   /* @@@@ first iteration */
      }
      // Pdtutil_Assert(!Ddi_AigSatAnd(from,kCone,careBwd),
      //         "WRONG initial FROM\n");

      enFromNew = Ddi_BddSize(itpTravMgr->from) > 
        travMgr->settings.aig.itpWeaken;

      if (fromNewLevel > 0 || usePrevTo != 0) { 
        Ddi_Free(itpTravMgr->prevTo);
        if (step>0 && Ddi_BddSize(itpTravMgr->from) > 0) {
          itpTravMgr->prevTo = Ddi_BddDup(itpTravMgr->from);
        }
      }

      if (0 && step>0 && itpMgr->hints.hintsEnabled>1) {
	int iConstr0 = itpMgr->hints.invar0_i;
	Ddi_Var_t *cvar0Ns = Ddi_VararrayRead(itpMgr->ns,iConstr0); 
	Ddi_Bdd_t *f0 = Ddi_BddCofactor(itpTravMgr->from,cvar0Ns,0);
	Ddi_Bdd_t *f1 = Ddi_BddCofactor(itpTravMgr->from,cvar0Ns,1);
	Ddi_Bdd_t *lit1 = Ddi_BddMakeLiteralAig(cvar0Ns, 1);
	Ddi_BddDiffAcc(f0,f1);
	Ddi_Free(itpTravMgr->from);
	itpTravMgr->from = Ddi_BddIte(lit1,f1,f0);
	Ddi_Free(f0);
	Ddi_Free(f1);
	Ddi_Free(lit1);
      }

      sizeFrom = Ddi_BddSize(itpTravMgr->from);

      Ddi_BddComposeAcc(itpTravMgr->from, itpMgr->ns, itpMgr->psLit);

      if (fromNewLevel > 0 || usePrevTo != 0) { 
        Ddi_Free(itpTravMgr->currFrom);
        itpTravMgr->currFrom = Ddi_BddDup(itpTravMgr->from);
      }

      if (chkSupp) {
        Ddi_Varset_t *fSupp = Ddi_BddSupp(itpTravMgr->from);

        Ddi_VarsetDiffAcc(fSupp, psvars);
        Pdtutil_Assert(Ddi_VarsetIsVoid(fSupp), "non state var in from");
        Ddi_Free(fSupp);
      }
      // printf("FROM*TR-AUX = %d\n", Ddi_AigSatAnd(from,kCone,itpMgr->trAux));

      if (1 && Trav_MgrReadAssume(travMgr) != NULL) {
        Ddi_BddAndAcc(itpTravMgr->from, Trav_MgrReadAssume(travMgr));
      }

      if (0 && itpMgr->invarConstr != NULL) {
        Ddi_BddOrAcc(itpTravMgr->from, itpMgr->invarConstr);
      } else if (1) {
        Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");

        if (iv != NULL) {
          Ddi_Bdd_t *invarIn = Ddi_BddMakeLiteralAig(iv, 1);

          Ddi_BddAndAcc(itpTravMgr->from, invarIn);
          Ddi_Free(invarIn);
        }
      }

      if (itpTravMgr->constrainVars != NULL) {
        int i, j, n = Ddi_VararrayNum(itpTravMgr->constrainVars);

	/* keep prev equivs as candidate for new */
	Ddi_Free(itpTravMgr->saveConstrainVars);
	Ddi_Free(itpTravMgr->saveConstrainSubstLits);
	itpTravMgr->saveConstrainVars = 
	  Ddi_VararrayDup(itpTravMgr->constrainVars);
	itpTravMgr->saveConstrainSubstLits = 
	  Ddi_BddarrayDup(itpTravMgr->constrainSubstLits);

        Ddi_BddarraySubstVarsAcc(itpTravMgr->constrainSubstLits,
          itpMgr->ns, itpMgr->ps);
	Ddi_VararraySubstVarsAcc(itpTravMgr->constrainVars,
				 itpMgr->ns,itpMgr->ps);
      }

      /* take the from set */

      //      useTrRange=step>2;

      if (useTrRange) {
        Pdtutil_Assert(!Ddi_BddIsPartConj(itpTravMgr->from)
          && !itpTravMgr->settings.useInitStub, "wrong from format");
        Ddi_BddAndAcc(itpTravMgr->from, itpMgr->trRange);
      }

      if (Ddi_BddIsPartConj(itpTravMgr->from)) {
        /* BDDs used */
        itpTravMgr->from0 = Ddi_BddDup(Ddi_BddPartRead(itpTravMgr->from, 0));
        Ddi_BddAndAcc(itpTravMgr->from0, Ddi_BddPartRead(itpTravMgr->from, 1));
      } else {
        itpTravMgr->from0 = Ddi_BddDup(itpTravMgr->from);
      }

      /* prepare transition relation */

      localCone = itpImgGetCone(itpTravMgr, kCone, kConeRings, NULL, step, 
				conePhase_0, 0, 0, 0, -1, 0);

      if (step>0 && abstrWithCone) {
        if (localCone == NULL || Ddi_BddIsZero(localCone)) {
          localCone =
            itpImgGetCone(itpTravMgr, kCone, kConeRings, NULL, 
			  step + 1, 1, 0, 0, 0, -1, 0);
          itpImgTrSetup(itpTravMgr, localCone);
          Ddi_Free(localCone);
        } else {
          itpImgTrSetup(itpTravMgr, localCone);
        }
      } else {
        itpImgTrSetup(itpTravMgr, NULL);
      }

      if (0 && (step>=10)) {
        Ddi_Bdd_t *fromDup = Ddi_BddDup(itpTravMgr->from);
        partitionByWitnessVars(itpTravMgr,fromDup,NULL);
        Ddi_Free(fromDup);
      }
      
      sizeAig = Ddi_BddSize(itpTravMgr->trAux);
      // printf("FROM*TR = %d\n", Ddi_AigSatAnd(from,kCone,careBwd));
      /* start checks */
      if (itpOutOfLimits(itpMgr)) {
        /* abort for time limit */
        Ddi_Free(itpTravMgr->from0);
        Ddi_Free(myCareBwd);
        Ddi_Free(inductiveTo);
        step++;
        itpTravMgr->settings.checkCompleteness = 0;
        *pAbort = 1;
        break;
      }

      if (!toBddInCareBdd) {
        Ddi_Bdd_t *fromConstrained = Ddi_BddDup(itpTravMgr->from);

        if (myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(fromConstrained, myInvarConstr);
        }
        if (itpMgr->invarConstr != NULL) {
          Ddi_BddAndAcc(fromConstrained, itpMgr->invarConstr);
        }
        if (!Ddi_BddIncluded(fromConstrained, itpTravMgr->careBwd)) {
          Ddi_BddAndAcc(fromConstrained, itpTravMgr->careBwd);
        }
        if (0&&!Ddi_BddIncluded(fromConstrained, itpTravMgr->careBwd)) {
          /* traversal hits back cone through careBwd */
          if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
            printf("Inner loop REACHES back cone (chk 0)\n");
            fflush(tMgrO(travMgr));
          }
          Ddi_Free(fromConstrained);
          Ddi_Free(toMinusTot);
          Ddi_Free(itpTravMgr->from0);
          Ddi_Free(myCareBwd);
          step++;
          itpTravMgr->settings.checkCompleteness = 0;
          *pAbort = 1;
          break;
        }
        Ddi_Free(fromConstrained);
      }
      /* fix point check: exact image in reached ? */

      if (enFpChk) {

        long chkTime0, chkTime1;

	if (travMgr->settings.aig.itpGfp<=0 &&
            itpMgr->hints.hintsEnabled) {
	  int iConstr0 = itpMgr->hints.invar0_i;
	  Ddi_Var_t *cvar0Ns = Ddi_VararrayRead(itpMgr->ns,iConstr0); 
	  Ddi_Bdd_t *r = Ddi_BddCofactor(itpTravMgr->reached,cvar0Ns,0);
	  fpCheck = Ddi_BddDiff(itpTravMgr->from, r);
	  Ddi_Free(r);
	  r = Ddi_BddCofactor(itpTravMgr->reached,cvar0Ns,1);
	  Ddi_BddDiffAcc(fpCheck, r);
	  Ddi_Free(r);
	}
	else {
	  fpCheck = Ddi_BddDiff(itpTravMgr->from, itpTravMgr->reached);
	}
        chkTime0 = util_cpu_time();

        if (0 && !useTrRange && itpMgr->trRange != NULL) {
          Ddi_BddAndAcc(fpCheck, itpMgr->trRange);
        }
        useTrRange = 0;
        if (0 && itpTravMgr->careBwd != NULL) {
          Ddi_BddAndAcc(fpCheck, itpTravMgr->careBwd);
        }
        if (myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(fpCheck, myInvarConstr);
        }
        if (itpTravMgr->settings.enConcurTr && !Ddi_AigSat(fpCheck)) {
          /* fix point reached */
          itpTravMgr->settings.enConcurTr = 0;
          Ddi_Free(fpCheck);
          fpCheck = Ddi_BddNot(itpTravMgr->reached);
          Ddi_BddComposeAcc(itpTravMgr->from, itpMgr->ns, itpMgr->psLit);
          Ddi_BddDiffAcc(itpTravMgr->from, itpMgr->concurStall);
          Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->trAux);
          Ddi_BddAndAcc(fpCheck, itpTravMgr->from);
          Ddi_Free(inductiveTo);
          Ddi_Free(itpTravMgr->to);
        }
        if (!Ddi_AigSat(fpCheck)) {
          if (step == 0)
            step++;             /* correct fp on init state !! */
          Ddi_Free(itpTravMgr->from0);
          Ddi_Free(fpCheck);
          Ddi_Free(itpTravMgr->trArray);
          Ddi_Free(itpTravMgr->trAux);
          Ddi_Free(inductiveTo);
          Ddi_Free(itpTravMgr->careFwd);
          Ddi_Free(prevTo);
          Ddi_Free(newFwd);
          Ddi_Free(itpTravMgr->to);
          Ddi_Free(myCareBwd);
          if (fullInit != NULL) {
            incompleteTrav = 1;
            Ddi_BddOrAcc(itpTravMgr->reached, fullInit);
            Ddi_Free(fullInit);
          }
          if (incompleteTrav) {
            Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c,
              fprintf(stdout,
                "FWD ITP INCOMPLETE fix-point - restarting from reached\n"));
            incompleteTrav = 0;
            itpTravMgr->from = Ddi_BddDup(itpTravMgr->reached);
            continue;
          }
	  itpMgr->lastRingId = step;
          Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c, fprintf(stdout,
              "FWD ITP fix-point at depth %d\n", step));
          break;
        }
        Ddi_Free(fpCheck);

        chkTime1 = util_cpu_time();

        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("fp chkTime: %s\n", util_print_time(chkTime1-chkTime0));
          fflush(tMgrO(travMgr));
        }

        if (itpMgr->hints.hintsEnabled) {
          int hintsMaxStep = itpMgr->hints.hintsMaxStep;
          if (hintsMaxStep>0 && hintsMaxStep <= step) {
            Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c, fprintf(stdout,
                                                                       "FWD ITP stopped: max step: %d reached\n", step));
            itpMgr->lastRingId = step;
            break;
          }
        }
      }

      Ddi_Free(itpTravMgr->trAux);
      if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        printf("  Aig interpolant inner iteration %d: |from:%d| -> ",
          step, Ddi_BddSize(itpTravMgr->from));
        fflush(tMgrO(travMgr));
      }
    }

    /* NEW IMG STEP STARTS */
    step++;
    int safe = -1;
    if (step >= 1 && itpMgr->fromRings != NULL &&
      Ddi_BddarrayNum(itpMgr->fromRings) > step) {
      safe = Trav_ItpMgrReadConeBoundOK(itpMgr,step);
      if (safe >= 0) {
        Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
          printf("previous ring %d - safe for bound %d\n", step, safe);
        }
      }
    }
    if (chkRings && step > 1 && itpMgr->fromRings != NULL &&
      Ddi_BddarrayNum(itpMgr->fromRings) > step) {
      Ddi_Bdd_t *ring = Ddi_BddarrayRead(itpMgr->fromRings, step);

      Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->from, ring),
        "img problem in from rings");
    }

    if (optLevel >= 0 && Ddi_BddSize(itpTravMgr->reached) > optReachedThresh) {
      int mySize;
      int growthFactor = 2;
      int rrp = Ddi_MgrReadAigRedRemMaxCnt(ddm);

      if (itpExact)
        growthFactor *= 2;
      if (enBwdCareSimplify) {
        Ddi_BddAndAcc(itpTravMgr->reached, itpTravMgr->careBwd);
      }
      if (0 && step > 3 && itpTravMgr->careBwd != NULL
        && Ddi_BddSize(itpTravMgr->careBwd) > 100 && optReachedThresh < 10000)
        Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, 1);
      DdiAigRedRemovalAcc(itpTravMgr->reached, itpTravMgr->careBwd, -1,
        travMgr->settings.aig.lazyTimeLimit);
      Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, rrp);
      mySize = Ddi_BddSize(itpTravMgr->reached);
      if (mySize * growthFactor > optReachedThresh) {
        optReachedThresh = mySize * growthFactor;
        //      optReachedThresh *= 2;
      }
    }

    if (0 && (itpGenMaxIter > 0)) {
      int res;
      Ddi_Bdd_t *itpGen;
      Ddi_Vararray_t *glbA;
      Ddi_Bdd_t *fromTot = Ddi_BddAnd(itpTravMgr->from, itpTravMgr->careFwd);
      Ddi_Varset_t *glbVars = Ddi_BddSupp(fromTot);
      int maxIter = itpGenMaxIter;

      if (itpConstrLevel > 1 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(fromTot, myInvarConstr);
      }

      Ddi_VarsetIntersectAcc(glbVars, nsvars);
      glbA = Ddi_VararrayMakeFromVarset(glbVars, 1);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "|to-GENeralization:%d|.\n",
          Ddi_BddSize(fromTot))
        );
      itpGen =
        Ddi_AigInterpolantByGenClauses(fromTot, kCone, myCareBwd, NULL, ps,
        ns, NULL, glbA, NULL, NULL, NULL, maxIter, 0, &res);
      Ddi_Free(glbA);
      Ddi_Free(glbVars);
      Ddi_Free(fromTot);
      if (res > 0) {
        itpTravMgr->to = itpGen;
        itpGen = NULL;
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "|to-GEN:%d|\n", Ddi_BddSize(itpTravMgr->to))
          );
        if (1) {
          Ddi_Bdd_t *chk = Ddi_BddDiff(itpTravMgr->from, itpTravMgr->to);

          Ddi_BddAndAcc(chk, itpTravMgr->careFwd);
          if (itpConstrLevel > 1 && myInvarConstr != NULL) {
            Ddi_AigAndCubeAcc(chk, myInvarConstr);
          }
          Pdtutil_Assert(!Ddi_AigSat(chk), "to minus problem");
          Ddi_Free(chk);
          Pdtutil_Assert(!Ddi_AigSatAnd(itpTravMgr->to, kCone, NULL),
            "to minus problem");
        }
      } else if (res == 0) {
        /* partial */
        toMinusTot = itpGen;
        Pdtutil_Assert(!Ddi_AigSatAnd(toMinusTot, kCone, NULL),
          "to minus problem");
        itpGen = NULL;
        Ddi_BddDiffAcc(itpTravMgr->careFwd, toMinusTot);
        if (0 && itpConstrLevel > 1 && myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(toMinusTot, myInvarConstr);
        }
      }
      Ddi_Free(itpGen);
    }

    if (0 && (itpMgr->invarConstr != NULL)) {
      Ddi_Bdd_t *invarConstrNs =
        Ddi_BddCompose(itpMgr->invarConstr, ns, psLit);
      Ddi_BddAndAcc(itpTravMgr->careFwd, invarConstrNs);
      Ddi_Free(invarConstrNs);
    }
#if 0
    if (0) {
      int i, update = 0, n = Ddi_VararrayNum(ps);

      again = 1;
      for (i = 0; i < n; i++) {
        int changed = 0;
        Ddi_Var_t *v = Ddi_VararrayRead(ns, i);
        Ddi_Bdd_t *d_i = Ddi_BddCofactor(Ddi_BddarrayRead(trArray, i), v, 1);
        Ddi_Bdd_t *implied = DdiAigImpliedVarsAcc(d_i, from0, NULL);

        if (implied != NULL) {
          Ddi_BddAndAcc(d_i, implied);
          Ddi_Free(implied);
          changed = update = 1;
        }
        Ddi_BddNotAcc(d_i);
        implied = DdiAigImpliedVarsAcc(d_i, from, NULL);
        if (implied != NULL) {
          Ddi_BddAndAcc(d_i, implied);
          Ddi_Free(implied);
          changed = update = 1;
        }
        if (changed) {
          Ddi_Bdd_t *vLit = Ddi_BddMakeLiteralAig(v, 1);

          Ddi_BddNotAcc(d_i);
          Ddi_BddXnorAcc(d_i, vLit);
          Ddi_BddarrayWrite(trArray, i, d_i);
          Ddi_Free(vLit);
        }
        Ddi_Free(d_i);
        Ddi_Free(implied);
      }
      if (update) {
        int size0 = Ddi_BddSize(from);

        Ddi_Free(from);
        from = Ddi_BddMakeConstAig(ddm, 1);
        for (i = 0; i < n; i++) {
          Ddi_BddAndAcc(from, Ddi_BddarrayRead(trArray, i));
        }
        if (newConstrain) {
          Ddi_AigConstrainOptAcc(from, from0, psvars, NULL, NULL, 2);
        } else {
          Ddi_BddAndAcc(from, from0);
        }
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "new from after impl red %d->%d.\n",
            size0, Ddi_BddSize(from))
          );
      }
    }
#endif

    if (useFwdUnroll && itpTravMgr->from != NULL) {
      sat = Ddi_AigSatAnd(itpTravMgr->from, kCone, itpTravMgr->careBwd);
      if (sat) {
        Ddi_Free(itpTravMgr->from);
      }
    }

    if (((dynAbstr && enDynAbstrBase || useFwdUnroll) &&
        (itpTravMgr->from != NULL || abortedTo)) && itpTravMgr->to == NULL) {
      int j;
      int nState = Ddi_VararrayNum(ns);

      if (dynAbstr > 3 && enDynAbstrOpt || useFwdUnroll) {

        /* use restart info */
        if (ternarySmooth == NULL) {
          ternarySmooth = Ddi_VarsetVoid(ddm);
        }
        Ddi_Free(itpTravMgr->from);
        Ddi_Free(itpTravMgr->from0);
        Pdtutil_Assert(itpTravMgr->restartFrom != NULL, "NULL restartFrom");
        Ddi_BddSetAig(itpTravMgr->restartFrom);
        itpTravMgr->from0 = Ddi_BddDup(itpTravMgr->restartFrom);
        itpTravMgr->from = Ddi_BddDup(itpTravMgr->restartFrom);
        Pdtutil_Assert(itpTravMgr->fwdUnroll != NULL, "NULL fwd unroll");
        Ddi_Free(itpTravMgr->trArray);
        itpTravMgr->trArray = Ddi_BddarrayDup(itpTravMgr->fwdUnroll);
        for (j = 0; j < nState; j++) {
          Ddi_Bdd_t *nsLit_j = Ddi_BddarrayRead(itpMgr->nsLit, j);

          Ddi_BddXnorAcc(Ddi_BddarrayRead(itpTravMgr->trArray, j), nsLit_j);
          Ddi_BddAndAcc(itpTravMgr->from,
            Ddi_BddarrayRead(itpTravMgr->trArray, j));
        }
        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("DYN-ABSTR: |new from|=%d\n", Ddi_BddSize(itpTravMgr->from));
        }
        if (travMgr->settings.aig.selfTuningLevel == 0 && ternarySmooth) {
          DdiAigExistOverAcc(itpTravMgr->from, ternarySmooth, NULL);
          if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
            printf("DYN-ABSTR: |new from after 3-ary sm|=%d\n",
              Ddi_BddSize(itpTravMgr->from));
          }
        }
      }

    }

    careCone = Ddi_BddDup(kCone);
    if (itpConstrLevel > 1 && myInvarConstr != NULL) {
      Ddi_AigAndCubeAcc(itpTravMgr->from, myInvarConstr);
    }

    if (0 && itpTravMgr->to == NULL && itpTravMgr->from != NULL &&
      itpTravMgr->careBwd != NULL) {
      Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->from,
          itpTravMgr->careBwd), "wrong inclusion check");
      /* this is probably redundant as already checked */
      //      Ddi_Free(from);
      //      from = localCone = NULL;
    }

    Ddi_Free(itpTravMgr->constrainVars);
    Ddi_Free(itpTravMgr->constrainSubstLits);
    itpTravMgr->constrainVars = Ddi_VararrayAlloc(ddm, 0);
    itpTravMgr->constrainSubstLits = Ddi_BddarrayAlloc(ddm, 0);
    if (0 && itpTravMgr->settings.storeRings && (itpMgr->nRings == step)) {
      if (1 && inductiveTo != NULL
	  && (step-2 >= ((initAbstr > 2) ? 2 : initAbstr))) {
        inductiveTo2 =
          Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, step - 2));
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "|extra-ind-cand:%d|.\n",
            Ddi_BddSize(inductiveTo2))
          );
	Ddi_BddOrAcc(inductiveTo,inductiveTo2);
	Ddi_Free(inductiveTo2);
      }
    }
    if (itpMgr->eqRings != NULL
        && Ddi_BddarrayNum(itpMgr->eqRings) > step) {
      Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, step);
      Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
      Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);
      Ddi_VararrayAppend(itpTravMgr->constrainVars,vars);
      Ddi_BddarrayAppend(itpTravMgr->constrainSubstLits,subst);
      //checkEqConstr(itpTravMgr->constrainVars,itpTravMgr->constrainSubstLits);

      Ddi_BddComposeAcc(itpTravMgr->from, itpTravMgr->constrainVars,
          itpTravMgr->constrainSubstLits);
      if (itpTravMgr->careFwd != NULL && 
	  !Ddi_BddIsOne(itpTravMgr->careFwd)) {
	Ddi_BddComposeAcc(itpTravMgr->careFwd, 
			  itpTravMgr->constrainVars,
			  itpTravMgr->constrainSubstLits);
      }

    }
    
    if (itpTravMgr->to == NULL && implAbstr > 1 && step >= implAbstrInitIter) {
      /* tightening by implied vars */
      Ddi_Bdd_t *ternaryToPlus = NULL;
      Ddi_Bdd_t *myFrom = NULL;
      Ddi_Bdd_t *ternaryFrom = NULL;
      Ddi_Varset_t *ternaryVars;
      int nCube;

      if (itpExact) {
        /* use forward unroll */
        int j;
        int nState = Ddi_VararrayNum(ns);
        Ddi_Bdd_t *myFrom = Ddi_BddMakeConstAig(ddm, 1);

        for (j = 0; j < nState; j++) {
          Ddi_Bdd_t *tr_j = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->nsLit, j));

          Ddi_BddXnorAcc(tr_j, Ddi_BddarrayRead(itpTravMgr->fwdUnroll, j));
          Ddi_BddAndAcc(myFrom, tr_j);
          Ddi_Free(tr_j);
        }
      } else {
        myFrom = Ddi_BddDup(itpTravMgr->from);
      }

      ternaryVars = Ddi_BddSupp(myFrom);
      if (Ddi_VarsetIsArray(ternaryVars)) {
        Ddi_VarsetSetArray(nsvars);
      }
      if (Ddi_VarsetIsArray(nsvars)) {
        Ddi_VarsetSetArray(ternaryVars);
      }
      Ddi_VarsetDiffAcc(ternaryVars, nsvars);
      ternaryFrom = Ddi_BddDup(myFrom);
      DdiAigExistOverAcc(ternaryFrom, ternaryVars, NULL);
      ternaryToPlus =
        DdiAigImpliedVarsAcc(ternaryFrom, itpTravMgr->careFwd, nsvars);
      Ddi_Free(ternaryVars);
      Ddi_Free(ternaryFrom);
      if (ternaryToPlus != NULL) {
        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("ternary to+: %d\n", Ddi_BddSize(ternaryToPlus));
        }
        Ddi_AigConstrainCubeAcc(myFrom, ternaryToPlus);
        Ddi_AigConstrainCubeAcc(itpTravMgr->careFwd, ternaryToPlus);    /* @@@ */
      }

      if (enToPlusCubeSat && (0 || (minDynAbstrStep < 0 && step < 4)
          || step <= (minDynAbstrStep + 3))) {
        toPlusCube = DdiAigImpliedVarsAcc(myFrom, itpTravMgr->careFwd, nsvars);
      }
      if (toPlusCube == NULL) {
        toPlusCube = Ddi_BddMakeConstAig(ddm, 1);
      }
      if (ternaryToPlus != NULL) {
        Ddi_BddAndAcc(toPlusCube, ternaryToPlus);
        Ddi_Free(ternaryToPlus);
      }
      Ddi_Free(myFrom);
      nCube = Ddi_BddSize(toPlusCube);
      if (nCube == 0) {
        Ddi_Free(toPlusCube);
      } else {
        int sizeF = Ddi_BddSize(itpTravMgr->from);

        if (itpTravMgr->careFwd != NULL && !Ddi_BddIsOne(itpTravMgr->careFwd)) {
          Ddi_Bddarray_t *t2 = Ddi_BddarrayDup(itpTravMgr->trArray);
          Ddi_Bdd_t *trConstr = NULL;
          int j;

          for (j = 0; j < Ddi_VararrayNum(ns); j++) {
            Ddi_BddCofactorAcc(Ddi_BddarrayRead(t2, j),
              Ddi_VararrayRead(ns, j), 1);
          }
          trConstr = Ddi_BddCompose(toPlusCube, ns, t2);
          Ddi_BddAndAcc(itpTravMgr->from0, trConstr);
          Ddi_Free(trConstr);
          Ddi_Free(t2);
          Ddi_AigConstrainCubeAcc(itpTravMgr->careFwd, toPlusCube);
        }
        Ddi_AigConstrainCubeAcc(itpTravMgr->from, toPlusCube);
        Ddi_AigConstrainCubeAcc(myCareBwd, toPlusCube);
        nCube = nCube / 2 + 1;
        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("TO+IMG-cube: %d (f:%d->%d)\n",
            nCube, sizeF, Ddi_BddSize(itpTravMgr->from));
        }
      }

      // DdiAigEquivVarsAcc(from,NULL);

      if (implAbstr > 5 && eqBeforeDynAbstr) {
        Ddi_Vararray_t *constrainVarsPs = Ddi_VararrayAlloc(ddm, 0);
        Ddi_Bddarray_t *constrainSubstLitsPs = Ddi_BddarrayAlloc(ddm, 0);
        Ddi_Bdd_t *eq;
        Ddi_Varset_t *pipsvars = Ddi_VarsetMakeFromArray(pi);

        Ddi_VarsetUnionAcc(pipsvars, psvars);
        eq =
          DdiAigEquivVarsAcc(itpTravMgr->from, itpTravMgr->careFwd, NULL,
          pipsvars, NULL, constrainVarsPs, constrainSubstLitsPs);
        if (eq != NULL) {
          Ddi_BddComposeAcc(itpTravMgr->from, constrainVarsPs,
            constrainSubstLitsPs);
          Ddi_BddComposeAcc(itpTravMgr->from0, constrainVarsPs,
            constrainSubstLitsPs);
          Ddi_BddarrayComposeAcc(itpTravMgr->trArray, constrainVarsPs,
            constrainSubstLitsPs);
          Ddi_Free(eq);
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "PIPS EQ found\n")
            );
        }

        Ddi_Free(pipsvars);
        Ddi_Free(constrainVarsPs);
        Ddi_Free(constrainSubstLitsPs);
      }
      if (implAbstr > 2 && eqBeforeDynAbstr && step >= implAbstrInitIter) {
        Ddi_Bdd_t *eq;

        eq = DdiAigEquivVarsAcc(itpTravMgr->from, itpTravMgr->careFwd,
          NULL, nsvars, localCone,
          itpTravMgr->constrainVars, itpTravMgr->constrainSubstLits);
        if (eq != NULL) {
          Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from);
          if (toPlus == NULL) {
            toPlus = Ddi_BddDup(eq);
          } else {
            Ddi_BddAndAcc(toPlus, eq);
          }

          if (itpTravMgr->careFwd != NULL
            && !Ddi_BddIsOne(itpTravMgr->careFwd)) {
            Ddi_Bddarray_t *t2 = Ddi_BddarrayDup(itpTravMgr->trArray);
            Ddi_Bdd_t *trConstr = NULL;
            int j;

            for (j = 0; j < Ddi_VararrayNum(ns); j++) {
              Ddi_BddCofactorAcc(Ddi_BddarrayRead(t2, j),
                Ddi_VararrayRead(ns, j), 1);
            }
            trConstr = Ddi_BddCompose(eq, ns, t2);
            Ddi_BddAndAcc(itpTravMgr->from0, trConstr);
            Ddi_Free(trConstr);
            Ddi_Free(t2);
          }
          //      if (careFwd != NULL) Ddi_BddAndAcc(toPlus,careFwd);
          if (Ddi_VarsetIsArray(nsvars)) {
            Ddi_VarsetSetArray(sm);
          }
          Ddi_VarsetDiffAcc(sm, nsvars);
          if (Ddi_VarsetNum(sm) < 4) {
            itpTravMgr->to =
              Ddi_BddExistProject(itpTravMgr->from, itpMgr->nsvars);
            sat = 0;
          }
          Ddi_Free(sm);
        }
        Ddi_Free(eq);
      }
      if (0 && itpTravMgr->to == NULL && itpTravMgr->settings.implAbstr > 5) {
        Ddi_Bdd_t *eq;

        implArray = Ddi_BddarrayAlloc(ddm, 0);
        itpTravMgr->to = DdiAigImplicationsAcc(itpTravMgr->from,
          NULL, NULL, nsvars, implArray);
        if (0) {
          Ddi_Bdd_t *chk = Ddi_BddDiff(itpTravMgr->from, itpTravMgr->to);

          Pdtutil_Assert(!Ddi_AigSat(chk), "wrong implication img+");
          Ddi_Free(chk);
        }
        eq = Ddi_BddAnd(itpTravMgr->to, localCone);
        if (Ddi_AigSat(eq)) {
          if (!Ddi_BddIsOne(itpTravMgr->to)) {
            Ddi_AigConstrainImplAcc(localCone, implArray);
            Ddi_BddAndAcc(localCone, itpTravMgr->to);
            if (toPlus == NULL) {
              toPlus = Ddi_BddDup(itpTravMgr->to);
            } else {
              Ddi_BddAndAcc(toPlus, itpTravMgr->to);
            }
          }
          Ddi_Free(itpTravMgr->to);
        } else {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMin_c,
            fprintf(tMgrO(travMgr), "FOUND IMPL INTERPOLANT\n"));
          sat = 0;
        }
        Ddi_Free(eq);
      }
    }

    if (itpTravMgr->to == NULL && (kConeOld != NULL)) {
      localCone = Ddi_BddMakeConstAig(ddm, 0);
      if (kConeOld != NULL) {
        Ddi_BddOrAcc(localCone, kConeOld);
      }
      if (useCareBwd) {         /* --- */
        Ddi_Bdd_t *r = Ddi_BddNot(itpTravMgr->careBwd);

        Ddi_BddOrAcc(localCone, r);
        Ddi_Free(r);
      }
      if (itpTravMgr->from != NULL && !Ddi_BddIsZero(localCone)
        && Ddi_AigSat(localCone)) {
        Ddi_Bdd_t *from1;

        // ??????? DYNABSTR
        if (toPlusCube != NULL) {
          int sizeC = Ddi_BddSize(localCone);

          Ddi_AigConstrainCubeAcc(localCone, toPlusCube);
          if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
            printf("TO+IMG-cube: (c0:%d->%d)\n", sizeC,
              Ddi_BddSize(localCone));
          }
        }
        if (itpTravMgr->constrainVars != NULL &&
          Ddi_VararrayNum(itpTravMgr->constrainVars) > 0) {
          Ddi_BddComposeAcc(localCone, itpTravMgr->constrainVars,
            itpTravMgr->constrainSubstLits);
        }

        if (!Ddi_AigSatAnd(localCone, myCareBwd, NULL)) {
          from1 = Ddi_BddMakeConstAig(ddm, 1);
        } else {
          from1 = Ddi_BddDup(itpTravMgr->from);
        }
        sat = -1;
        if (enDynAbstr0 && (minDynAbstrStep >= 0 && step > minDynAbstrStep)
          && optLevel > 1 /* >= 1 */  && dynAbstr) {

          int nAbstr;

          if (0 && Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c) {
            Ddi_BddDiffAcc(localCone, itpTravMgr->reached);
          }
          abstrVars =
            interpolantDynAbstrFrom(from1, itpTravMgr->from0, localCone,
            /* NULL *//*myCareBwd */ toPlus, itpMgr->invarConstr,
	    ns, nsvars, NULL,dynAbstrCut, dynAbstrAux, dynAbstrCutLits,
            itpTravMgr->trArray, enAbstr, NULL, 0, &nAbstr);
          if (nAbstr == 0) {
            if (--maxNoAbstr0 <= 0) {
              enDynAbstr0 = 0;
            }
          }
          if (abstrVars == NULL) {
            //      toPlus = NULL;
            sat = 1;
          } else if (step > 4 && !Ddi_BddIsOne(from1) && ternaryAbstr > 0) {
            Ddi_Varset_t *mySmooth = Ddi_VarsetVoid(ddm);
            int totN;
            Ddi_Varset_t *sm = Ddi_BddSupp(from1);

            Ddi_VarsetIntersectAcc(sm, nsvars);
            totN = Ddi_VarsetNum(sm);
            Ddi_Free(sm);
            if (totN > 20) {

              Ddi_VarsetSetArray(mySmooth);
              interpolantTernaryAbstr(travMgr, from1, localCone, NULL,
                nsvars, NULL, mySmooth, dynAbstr, enDynAbstrOpt, 1);
              if (ternarySmooth != NULL) {
                Ddi_VarsetSetArray(ternarySmooth);
                Ddi_VarsetUnionAcc(ternarySmooth, mySmooth);
              }
              // DdiAigExistOverAcc (from1,mySmooth,NULL);
              if (ternaryAbstr > 1 && !Ddi_BddIsOne(from1))
                interpolantTernaryAbstr(travMgr, from1, localCone, NULL,
                  nsvars, NULL, ternarySmooth, dynAbstr, enDynAbstrOpt, 2);
            }
            Ddi_Free(mySmooth);
          }
          Ddi_Free(abstrVars);
        }
        if (sat == -1) {
          int j, useBddAppr = 0;
          Ddi_Bdd_t *toPlusBdd = Ddi_BddMakeConst(ddm, 1);

          if (toPlusCube != NULL) {
            Ddi_AigConstrainCubeAcc(from1, toPlusCube);
          }
          if (1 && itpAppr > 1 && toPlus == NULL &&
            itpMgr->trBdd != NULL && (itpMgr->trBddIsAig)) {
            Ddi_Varset_t *sFrom = Ddi_BddSupp(from1);

            Ddi_VarsetIntersectAcc(sFrom, nsvars);
            if (Ddi_VarsetIsVoid(sFrom)) {
              toPlus = Ddi_BddMakeConstAig(ddm, 1);
            } else {
              toPlus = interpolantSatApprImg(itpMgr,
                travMgr, from1, itpTravMgr->careFwd, NULL, 16, 0);
              if (Ddi_AigSatAnd(toPlus, localCone, NULL)) {
                Ddi_BddAndAcc(localCone, toPlus);
                Ddi_Free(toPlus);
              }
            }
            Ddi_Free(sFrom);
          }
          if (0 && implAbstr > 2) { /* BDD approx */
            Ddi_Varset_t *projPart, *nsFrom = Ddi_BddSupp(from1);
            Ddi_Vararray_t *nsFromArray = NULL;

            Ddi_VarsetIntersectAcc(nsFrom, nsvars);
            nsFromArray = Ddi_VararrayMakeFromVarset(nsFrom, 1);
            Ddi_BddSetPartConj(toPlusBdd);
            projPart = Ddi_VarsetVoid(ddm);
            for (j = 0; j < Ddi_VararrayNum(nsFromArray); j++) {
              Ddi_VarsetAddAcc(projPart, Ddi_VararrayRead(nsFromArray, j));
              if (j > 0 && (j % 12 == 0
                  || j == (Ddi_VararrayNum(nsFromArray) - 1))) {
                Ddi_Bdd_t *to_j =
                  DdiAigExistProjectByBdd(from1, NULL, 20000, projPart, -1.0,
                  0, 1);

                if (to_j != NULL && !Ddi_BddIsConstant(to_j)) {
                  Ddi_BddPartInsertLast(toPlusBdd, to_j);
                  useBddAppr = 1;
                }
                Ddi_Free(to_j);
                Ddi_Free(projPart);
                projPart = Ddi_VarsetVoid(ddm);
              }
            }
            Ddi_Free(projPart);
            Ddi_Free(nsFrom);
            Ddi_Free(nsFromArray);
          }
          Ddi_BddSetAig(toPlusBdd);
          if (useBddAppr) {
            if (Ddi_BddSize(toPlusBdd) > 1000) {
              DdiAigRedRemovalAcc(toPlusBdd, NULL, 1000, 30.0);
            }
            Ddi_BddAndAcc(localCone, toPlusBdd);
          }
          if (0 && toPlus == NULL) {
            toPlus = Ddi_AigSatAndWithInterpolant(from1, localCone,
              nsvars, psvars, NULL, NULL, NULL, NULL, &sat, itpPart, 0, -1.0);
          }
          if (toPlus == NULL) {
            toPlus = Ddi_BddMakeConstAig(ddm, 1);
          }
          Ddi_BddAndAcc(toPlus, toPlusBdd);
          Ddi_Free(toPlusBdd);
        }
        Ddi_Free(from1);
        Ddi_Free(localCone);
      }
    }

    if ( /*step>1 && */ doInductiveToPlus && inductiveTo != NULL) {
      int incremental = 1;
      Ddi_Bdd_t *myToPlus;

      if (itpTravMgr->constrainVars != NULL) {
        Ddi_BddComposeAcc(inductiveTo, itpTravMgr->constrainVars,
          itpTravMgr->constrainSubstLits);
      }

      if (toPlusCube != NULL) {
        Ddi_Bdd_t *inductiveTo2 = Ddi_BddDup(inductiveTo);

        Ddi_AigConstrainCubeAcc(inductiveTo, toPlusCube);
        if (Ddi_BddIsZero(inductiveTo)) {
          int j;
          Ddi_Bdd_t *partTo = Ddi_AigPartitionTop(inductiveTo2, 0);
          Ddi_Bddarray_t *arrayTo = Ddi_BddarrayMakeFromBddPart(partTo);

          Ddi_AigarrayConstrainCubeAcc(arrayTo, toPlusCube);
          Ddi_Free(inductiveTo);
          inductiveTo = Ddi_BddMakePartConjVoid(ddm);
          for (j = 0; j < Ddi_BddarrayNum(arrayTo); j++) {
            Ddi_Bdd_t *p_j = Ddi_BddarrayRead(arrayTo, j);

            if (!Ddi_BddIsZero(p_j)) {
              Ddi_BddPartInsertLast(inductiveTo, p_j);
            }
          }
          Ddi_BddSetAig(inductiveTo);
          Ddi_Free(partTo);
          Ddi_Free(arrayTo);
        }
        Ddi_Free(inductiveTo2);
      }
      if (incremental) {
        myToPlus = Ddi_AigInductiveImgPlus(itpTravMgr->from,
          inductiveTo, itpTravMgr->careFwd, toPlus, doInductiveToPlus);
        if (useNewFwd) {
          newFwd = Ddi_BddNot(inductiveTo);
          if (toPlusCube != NULL) {
            int s1, s = Ddi_BddSize(newFwd);

            Ddi_AigConstrainCubeAcc(newFwd, toPlusCube);
            if (0 && ((s1 = Ddi_BddSize(newFwd)) < s)) {
              printf("newFwd: %d -> %d\n", s, s1);
            }
          }
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "newFwd: %d\n", Ddi_BddSize(newFwd))
            );
        }
	if (myToPlus != NULL && doInductiveToPlus2) {
	  static int enToPlus2=1;
	  Ddi_Vararray_t *aV0 = Ddi_VararrayAlloc(ddm,0);
	  Ddi_Vararray_t *aV1 = Ddi_VararrayAlloc(ddm,0);
	  Ddi_Vararray_t *vars = Ddi_BddarraySuppVararray(itpMgr->delta);
	  Ddi_VararrayDiffAcc(vars,itpMgr->ps);
	  Ddi_Bddarray_t *d2 = Ddi_AigarrayNnf (itpMgr->delta,
					       vars,0,
					       NULL,NULL,
					       aV0,aV1);
	  Ddi_BddarrayVararrayCofactorAcc(d2, aV0, 1);
	  Ddi_BddarrayVararrayCofactorAcc(d2, aV1, 1);
	  Ddi_Free(vars);
	  Ddi_Free(aV0);
	  Ddi_Free(aV1);
	  Ddi_Bdd_t *aux = Ddi_BddMakePartConjFromArray(d2);
	  Ddi_BddSubstVarsAcc(aux, itpMgr->ps, itpMgr->ns);
	  Ddi_Free(d2);
	  if (itpTravMgr->constrainVars != NULL) {
	    Ddi_BddComposeAcc(aux, itpTravMgr->constrainVars,
			      itpTravMgr->constrainSubstLits);
	  }
	  if (toPlusCube != NULL) {
	    Ddi_AigConstrainCubeAcc(aux, toPlusCube);
	  }
          Ddi_Bdd_t *toPlus2 =
            Ddi_AigInductiveImgPlus(itpTravMgr->from, aux, myToPlus,
            toPlus, doInductiveToPlus);
	  if (enToPlus2 && toPlus2!=NULL && !Ddi_BddIsOne(toPlus2)) {
	    Ddi_BddAndAcc(myToPlus, toPlus2);
	    //	    Ddi_AigStructRedRemAcc (myToPlus,NULL);
	  }
          if (0 && myToPlus != NULL && toPlus2 != NULL) {
	    Ddi_Varset_t *s = Ddi_BddSupp(toPlus2);
	    Ddi_VarsetDiffAcc(s,nsvars);
	    if (Ddi_VarsetIsVoid(s)) {
	      Ddi_BddAndAcc(myToPlus, toPlus2);
	    }
            Ddi_Free(s);
            Ddi_Free(toPlus2);
          }
	  Ddi_Free(toPlus2);
	  Ddi_Free(aux);
	}
        if (myToPlus != NULL && inductiveTo2 != NULL) {
          Ddi_Bdd_t *toPlus2 =
            Ddi_AigInductiveImgPlus(itpTravMgr->from, inductiveTo2, myToPlus,
            toPlus, doInductiveToPlus);

          if (myToPlus != NULL && toPlus2 != NULL) {
            Ddi_BddAndAcc(myToPlus, toPlus2);
            Ddi_Free(toPlus2);
          }
        }
      } else {
        myToPlus = InductiveImgPlus(itpTravMgr->from, inductiveTo);
      }

      if (myToPlus != NULL) {
        if (doInductiveToPlus > 2 && Ddi_BddSize(myToPlus) > 1) {
          Ddi_Bdd_t *newRplus = InductiveImgInf(itpMgr, myToPlus,
            itpMgr->inductiveRplusLocal, itpMgr->trAux, NULL, localCone);

          if (newRplus != NULL) {
            Ddi_BddAndAcc(myCareBwd, newRplus);
            if (itpMgr->inductiveRplusLocal == NULL) {
              itpMgr->inductiveRplusLocal = Ddi_BddDup(newRplus);
            } else {
              Ddi_BddAndAcc(itpMgr->inductiveRplusLocal, newRplus);
            }
            Ddi_Free(newRplus);
          }
        }
        if (toPlus == NULL) {
          toPlus = Ddi_BddMakeConstAig(ddm, 1);
        }
        Ddi_BddAndAcc(toPlus, myToPlus);
        Ddi_Free(myToPlus);
      }

    }

    int doSplit = enConeSplit && (itpPart>0);
    int doLookahead = 0;

    if (enConeSplit && itpPart>0 /* && itpPart<3 */ && kConeRings!=NULL && step>1) {
      int np = Ddi_BddPartNum(kConeRings);
      if (np-step > 8) {
	doSplit = (coneSplitRatio*(np-step));
	if (0 && ((doSplit+4)<(np-step))) {
	  doSplit = np-step-4;
	}
	//     	doSplit = np-step-1;
	doLookahead = 0;
      }
      else {
	itpPart=0;
      }
    }

    int bound = kConeRings==NULL ? 0 : Ddi_BddPartNum(kConeRings)-step;
    // doPiConstr = 0; 
    doPiConstr = step>(step0+1) && (piConstrBoundTh>0) && (bound > piConstrBoundTh);
    int enAssumeSafeBound = travMgr->settings.aig.igrAssumeSafeBound;
    int assumeSafeBound = enAssumeSafeBound ? safe : -1;
    localCone = itpImgGetCone(itpTravMgr, kCone, kConeRings, toPlus, step, 
      2, doSplit, doLookahead, doPiConstr, assumeSafeBound, 
      itpTravMgr->settings.enItpSeq);

    int doNnConstr = 0;
    if (doNnConstr) {
      coneNearestNeighbourConstr(itpMgr,localCone);
    }
    
    coneBoundOK = Ddi_BddReadMark(localCone);

    if (0) {
      static int dbgCalls = 0;
      printf("CONE SIZE: %d - SAT: %d (calls: %d)\n", 
	     Ddi_BddSize(localCone), Ddi_AigSat(localCone), dbgCalls++);
    }

    if (toPlusCube != NULL) {
      Ddi_AigConstrainCubeAcc(localCone, toPlusCube);
      if (0 && !Ddi_AigSat(localCone)) {
	Ddi_Free(localCone);
	localCone = Ddi_BddMakeConstAig(ddm, 0);
      }
      if (prevTo != NULL) {
        Ddi_AigConstrainCubeAcc(prevTo, toPlusCube);
      }
    }
    if (itpTravMgr->constrainVars != NULL &&
      Ddi_VararrayNum(itpTravMgr->constrainVars) > 0) {
      Ddi_BddComposeAcc(localCone, itpTravMgr->constrainVars,
        itpTravMgr->constrainSubstLits);
      if (itpTravMgr->observedGates!=NULL) {
        Ddi_BddarrayComposeAcc(itpTravMgr->observedGates,
            itpTravMgr->constrainVars,
            itpTravMgr->constrainSubstLits);
      }
    }
    if (0 && (toPlus != NULL)) { /* @@@@@ check this one !!! */
      Ddi_AigConstrainCubeAcc(localCone, toPlus);
      //  DdiAigRedRemovalAcc(localCone, toPlus, -1, 30.0);
    }
    if (doMonotoneGen) {
      if (!Ddi_AigSatAnd(itpTravMgr->from, localCone, 0)) {
        Ddi_Bdd_t *myCone = Ddi_BddNot(localCone);

        Ddi_AigSplitMonotoneGenAcc(myCone, itpTravMgr->from, 0);
        Ddi_Free(localCone);
        localCone = Ddi_BddNot(myCone);
        Ddi_Free(myCone);
      }
    }

    if (abstrRef > 2) {
      /* pba */
      int mySat;
      Ddi_Bdd_t *fromAndCone = Ddi_BddAnd(itpTravMgr->from, localCone);
      Ddi_Bddarray_t *currAbstr = (step <= 2) ? NULL : itpMgr->abstrCurrAbstr;
      Ddi_Bddarray_t *abstrRefA =
        (abstrRef > 5) ? Ddi_AigAbstrRefinePba(fromAndCone,
        abstrRefCtrl, abstrDoRefine, currAbstr,
        &mySat,-1.0) : Ddi_AigAbstrRefineCegarPba(fromAndCone,
                      abstrRefCtrl, abstrDoRefine, currAbstr, &mySat, -1.0);

      if (!mySat && abstrRefA != NULL) {
        if (1 && (abstrRef <= 5)) {
          Ddi_Bddarray_t *abstrRefA0 = abstrRefA;

          abstrRefA =
            Ddi_AigAbstrRefinePba(fromAndCone,
                                  abstrRefCtrl, abstrRefA0, NULL, &mySat,-1.0);
          Pdtutil_Assert(abstrRefA != NULL && !mySat, "error in pba ref.");
          Ddi_Free(abstrRefA0);
        }
        Ddi_BddComposeAcc(localCone, abstrRefCtrl, abstrRefA);
      }
      Ddi_Free(fromAndCone);
      Ddi_Free(itpMgr->abstrCurrAbstr);
      itpMgr->abstrCurrAbstr = abstrRefA;   // Ddi_Free(abstrRefA);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(stdout, "abstrCONE: %d\n", Ddi_BddSize(localCone)));
    }

    if (step > (doInductiveToPlus ? 1 : 2) && enToPlusImage &&
	itpTravMgr->to == NULL && /* toPlus != NULL && */
      itpTravMgr->from != NULL && localCone != NULL) {
      int satRes;
      Ddi_Bdd_t *chkToPlus = Ddi_BddDup(localCone);

      if (toPlus != NULL) {
        Ddi_BddAndAcc(chkToPlus, toPlus);
      }
      if (itpTravMgr->careBwd != NULL) {
        Ddi_BddAndAcc(chkToPlus, myCareBwd);
      }
      satRes = Ddi_AigSatWithAbort(chkToPlus, 10.0);
      useApproxToPlus = satRes == 0;
      Ddi_Free(chkToPlus);
      if (useApproxToPlus) {
        /* toPlus is already OK with cone. Stop image computation */
        Ddi_Free(itpTravMgr->from);
        itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
      }
    }

    if (0 && Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c) {
      Ddi_BddDiffAcc(localCone, itpTravMgr->reached);
    }

    if (dynAbstr && itpTravMgr->from != NULL
      && enStructAbstractionWithCone == 1) {

      int nAbstr;

      Pdtutil_Assert(!itpTravMgr->settings.newConstrain, "not yet supported");
      if (itpTravMgr->settings.useInvarFull && itpMgr->invarConstr != NULL) {
        Ddi_BddAndAcc(itpTravMgr->from0, itpMgr->invarConstr);
      }
      // structural abstraction
      nAbstr = interpolantStructAbstrFrom(itpTravMgr->from,
        itpTravMgr->from0,
        localCone, itpMgr->ns, itpMgr->nsvars, itpTravMgr->trArray);
      if (itpConstrLevel > 1 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(itpTravMgr->from, myInvarConstr);
      }

      if (toPlusCube != NULL) {
        Ddi_AigConstrainCubeAcc(itpTravMgr->from, toPlusCube);
      }
    }

    if (dynAbstr && enDynAbstrBase && (itpTravMgr->from != NULL || abortedTo)) {
      int j;
      unsigned char *abstrMask = NULL;
      int nState = Ddi_VararrayNum(ns);

      itpCare = NULL;
      itpFullCare = Ddi_BddDup(myCareBwd);
      //      itpFullCare = Ddi_BddMakeConstAig(ddm, 1);
      if (toPlus != NULL) {
        Ddi_BddAndAcc(itpFullCare, toPlus);
      }
      if (optLevel >= 0 && step>=1) {
        //        itpCare = toPlus; // produces false failures !
        itpCare = itpFullCare;
      }
      if (optLevel > 2) {
        itpCare = itpFullCare;
      }
      if (step>1 && itpTravMgr->settings.storeRings && (itpMgr->nRings > step)) {
        Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings, step);
	if (itpCare==NULL) {
	  itpCare=Ddi_BddDup(oldFrom);
	}
	else {
	  Ddi_BddAndAcc(itpCare, oldFrom);
	}
      }
      if (itpTravMgr->from == NULL) {
        abstrVars = NULL;
      } else if (enDynAbstr && (minDynAbstrStep >= 0 && step > minDynAbstrStep)
        && itpTravMgr->to == NULL && !(itpExact == 1)) {
        Ddi_Bdd_t *saveFrom0 = NULL;
        int nAbstr;

        if (itpTravMgr->settings.useInvarFull && itpMgr->invarConstr != NULL) {
          Ddi_BddAndAcc(itpTravMgr->from0, itpMgr->invarConstrForTr);
        }
        if (itpTravMgr->settings.newConstrain) {
#if 1
          saveFrom0 = itpTravMgr->from0;
          itpTravMgr->from0 = Ddi_BddMakeConstAig(ddm, 1);
#endif
        }
#if 0
        if (!Ddi_AigSatAnd(itpMgr->initStubState, localCone, 0)) {
          Ddi_Bdd_t *myTr = Ddi_BddMakePartConjFromArray(trArray);

          printf("SAT: %d\n", Ddi_AigSatAnd(myTr, localCone, 0));
          Ddi_Free(myTr);
        }
#endif

        if (cegarAbstrRef > 1 && step > 1 && Ddi_BddSize(localCone) > 1) {
          Ddi_AigSatAndFlowAbstraction(localCone, itpTravMgr->from);
        }

        /* GPC: fix abstraction with CARE */

        if (!abstrCareVarsWithDynAbstr) 
	if (itpTravMgr->settings.storeRings &&
	    (itpMgr->nRings > step)) {
	  Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings,
						step);
	  Ddi_Vararray_t *noAbstr = Ddi_BddSuppVararray(oldFrom);
	  Ddi_VararrayUnionAcc(itpTravMgr->noDynAbstr,noAbstr);
	  Ddi_Free(noAbstr);
	}
        if (!abstrCareVarsWithDynAbstr) 
	if (toPlus!=NULL) {
	  Ddi_Vararray_t *noAbstr = Ddi_BddSuppVararray(toPlus);
	  Ddi_VararrayUnionAcc(itpTravMgr->noDynAbstr,noAbstr);
	  Ddi_Free(noAbstr);
	}
	
        abstrVars = interpolantDynAbstrFrom(itpTravMgr->from,
          itpTravMgr->from0, localCone,
          /* careBwd DISABLED */ itpCare, itpMgr->invarConstrForTr,
	  ns, nsvars,
          abstrCareVarsWithDynAbstr?NULL:itpTravMgr->noDynAbstr,
          dynAbstrCut, dynAbstrAux,
          dynAbstrCutLits, itpTravMgr->trArray,
          enAbstr, abstrMask, 1, &nAbstr);
	//	substStalledLatches(itpMgr,itpTravMgr->from);
        if (abstrVars!=NULL && nAbstr == 0 && --maxNoAbstr <= 0) {
          enDynAbstr = dynAbstr = 0;    //implAbstr = 0;
        }
        if (itpTravMgr->settings.newConstrain) {
          Ddi_Free(itpTravMgr->from0);
          itpTravMgr->from0 = saveFrom0;
        }
        if (itpConstrLevel > 1 && myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(itpTravMgr->from, myInvarConstr);
        }
        if (itpCare != NULL) {
          Ddi_BddAndAcc(localCone, itpCare);
          useCareOpt = 1;
        }
        if (0 && (itpConstrLevel > 1) && itpMgr->invarConstr != NULL)  {
          Ddi_Bdd_t *coneConstr = Ddi_BddSubstVars(
                     itpMgr->invarConstr,itpMgr->ps,itpMgr->ns);  
          Ddi_BddAndAcc(localCone,coneConstr);
          Ddi_Free(coneConstr);
        }
        
        if (itpTravMgr->settings.newConstrain) {
          // disabled as already composed in from0, and constrainVars updated
          Ddi_BddComposeAcc(itpTravMgr->from, itpTravMgr->constrainVars,
            itpTravMgr->constrainSubstLits);
          // wrong as from 0 contains PI variables (not a state set) */
          // to consider backward propagation of toPlusCube
          // constraints (NOW DISABLED)
          // Ddi_AigConstrainOptAcc(from,from0,psvars,NULL,NULL,1);
          Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->from0);
          if (itpMgr->nFreeDelta > 0) {
            int j, eqFound = 0, nEqTot;
            Ddi_Vararray_t *vars = Ddi_VararrayAlloc(ddm, 0);
            Ddi_Bddarray_t *lits = Ddi_BddarrayAlloc(ddm, 0);
            Ddi_Varset_t *supp = Ddi_BddSupp(itpTravMgr->from);

            Ddi_VarsetIntersectAcc(supp, nsvars);
            for (j = 0; j < Ddi_VararrayNum(itpMgr->freeDeltaPi); j++) {
              Ddi_Varset_t *nsv =
                Ddi_BddSupp(Ddi_BddarrayRead(itpMgr->freeDeltaNsLit, j));
              if (Ddi_VarInVarset(supp, Ddi_VarsetTop(nsv))) {
                Ddi_VararrayInsertLast(vars,
                  Ddi_VararrayRead(itpMgr->freeDeltaPi, j));
                Ddi_BddarrayInsertLast(lits,
                  Ddi_BddarrayRead(itpMgr->freeDeltaNsLit, j));
              }
              Ddi_Free(nsv);
            }
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
              fprintf(tMgrO(travMgr),
                "(Exist by composition on free deltas: %d",
                Ddi_BddSize(itpTravMgr->from))
              );
            Ddi_BddComposeAcc(itpTravMgr->from, vars, lits);
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
              printf(" -> %d)\n", Ddi_BddSize(itpTravMgr->from))
              );
            do {
              Ddi_Bdd_t *eq = NULL;

              /*DdiAigEquivVarsSimpleAcc(from,NULL,
                 nsvars,NULL,localCone,NULL,NULL,&nEqTot); */
              eqFound = 0;
              if (eq != NULL) {
                Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from);

                if (toPlus != NULL)
                  Ddi_BddAndAcc(toPlus, eq);
                else
                  toPlus = Ddi_BddDup(eq);
                Ddi_VarsetDiffAcc(sm, nsvars);
                if (Ddi_VarsetNum(sm) < 3) {
                  itpTravMgr->to = Ddi_BddExistProject(itpTravMgr->from,
                    nsvars);
                  sat = 0;
                }
                Ddi_Free(sm);
                Ddi_Free(eq);
                eqFound = 1;
              }
            } while (itpTravMgr->to != NULL && (eqFound || nEqTot > 0));
            Ddi_Free(vars);
            Ddi_Free(lits);
            Ddi_Free(supp);
          }
        }
        if (0 && myCareBwd != NULL && Ddi_BddSize(myCareBwd) < 2) {
          Ddi_AigConstrainCubeAcc(itpTravMgr->from, myCareBwd);
        }
        if (toPlusCube != NULL) {
          Ddi_AigConstrainCubeAcc(itpTravMgr->from, toPlusCube);
        }
        if (0 && nAbstr > 0) {
          Ddi_Varset_t *supp = Ddi_BddSupp(itpTravMgr->from);

          Ddi_VarsetIntersectAcc(supp, nsvars);
          if (Ddi_VarsetNum(supp) < 10) {
            printf("\nKEPT-VARS: ");
            Ddi_VarsetPrint(supp, 0, 0, tMgrO(travMgr));
            printf("\n");
          }
          Ddi_Free(supp);
        }

        if (cegarAbstrRef > 0 && step > 1 && Ddi_BddSize(localCone) > 1) {
          Ddi_AigSatAndFlowAbstraction(localCone, itpTravMgr->from);
        }

        if (step > 2 && !Ddi_BddIsOne(itpTravMgr->from) &&
          dynAbstr > 1 && enDynAbstrOpt && ternaryAbstr > 0) {
          int doTernary, totN;
          Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from);

          if (Ddi_VarsetIsArray(nsvars)) {
            Ddi_VarsetSetArray(sm);
          }
          Ddi_VarsetIntersectAcc(sm, nsvars);
          totN = Ddi_VarsetNum(sm);
          Ddi_Free(sm);
          if (totN > 20) {

            interpolantTernaryAbstr(travMgr, itpTravMgr->from,
              localCone, itpCare,
              nsvars, NULL, ternarySmooth, dynAbstr, enDynAbstrOpt, 1);
            if (ternaryAbstr > 1 && !Ddi_BddIsOne(itpTravMgr->from))
              interpolantTernaryAbstr(travMgr, itpTravMgr->from, localCone,
                itpCare, itpMgr->nsvars, NULL, ternarySmooth,
                dynAbstr, enDynAbstrOpt, 2);
            sm = Ddi_BddSupp(itpTravMgr->from);
            if (Ddi_VarsetIsArray(itpMgr->nsvars)) {
              Ddi_VarsetSetArray(sm);
            }
            Ddi_VarsetIntersectAcc(sm, itpMgr->nsvars);
            if (maxTernary > 0 && --maxTernary <= 0) {
              /* disable ternary */
              ternaryAbstr = 0;
            }
            Ddi_Free(sm);
          }
        }

      }

      if (enDynAbstr && (minDynAbstrStep >= 0 && step > minDynAbstrStep)
        && itpTravMgr->to == NULL && abstrVars == NULL) {
        //      Pdtutil_Assert(chkInnerCone, "wrong inner appr");
        if (0 && careOut != NULL) {
          int jj;
          Ddi_Bdd_t *fromBck = Ddi_BddDup(localCone);
          Ddi_Bdd_t *reachedBck = Ddi_BddMakeConstAig(ddm, 0);
          Ddi_Bdd_t *reachedPs = Ddi_BddCompose(itpTravMgr->reached,
            itpMgr->ns, itpMgr->psLit);

          if (toPlusCube != NULL) {
            Ddi_BddAndAcc(fromBck, toPlusCube);
          }
          if (itpMgr->trRange != NULL) {
            Ddi_BddAndAcc(reachedPs, itpMgr->trRange);
          }
          for (jj = 0; jj < 2 * step; jj++) {
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
              fprintf(tMgrO(travMgr), "BCK partial preimage step: %d\n", jj)
              );
            Ddi_BddAndAcc(fromBck, itpMgr->tr); {
              Ddi_Varset_t *sm = Ddi_BddSupp(fromBck);

              Ddi_VarsetDiffAcc(sm, psvars);
              Ddi_AigExistSubsetAcc(fromBck, sm, reachedPs, NULL, 1, -1.0);
              Ddi_Free(sm);
            }
            Ddi_AigExistProjectAllSolutionAcc(fromBck, psvars, reachedPs, 10);
            Ddi_BddOrAcc(reachedBck, fromBck);
            Ddi_BddComposeAcc(fromBck, ps, nsLit);
            if (Ddi_BddSize(fromBck) == 0) {
              if (jj == 0)
                undoCex = 1;
              break;
            }
          }
          if (!undoCex && savePreviousFrom != NULL) {
            Ddi_BddDiffAcc(savePreviousFrom, reachedBck);
            undoCex = 1;
          }
          if (!undoCex)
            Ddi_BddAndAcc(careOut, reachedBck);
          Ddi_Free(reachedPs);
          Ddi_Free(fromBck);
          Ddi_Free(reachedBck);
        }
        Ddi_Free(itpTravMgr->from);
      }

      Ddi_Free(itpFullCare);
    } else {
      if (itpTravMgr->settings.newConstrain && !enDynAbstrOpt) {
        if (itpMgr->nFreeDelta > 0) {
          int j;
          Ddi_Vararray_t *vars = Ddi_VararrayAlloc(ddm, 0);
          Ddi_Bddarray_t *lits = Ddi_BddarrayAlloc(ddm, 0);
          Ddi_Varset_t *supp = Ddi_BddSupp(itpTravMgr->from);

          Ddi_VarsetIntersectAcc(supp, nsvars);
          for (j = 0; j < Ddi_VararrayNum(itpMgr->freeDeltaPi); j++) {
            Ddi_Varset_t *nsv =
              Ddi_BddSupp(Ddi_BddarrayRead(itpMgr->freeDeltaNsLit, j));
            if (Ddi_VarInVarset(supp, Ddi_VarsetTop(nsv))) {
              Ddi_VararrayInsertLast(vars,
                Ddi_VararrayRead(itpMgr->freeDeltaPi, j));
              Ddi_BddarrayInsertLast(lits,
                Ddi_BddarrayRead(itpMgr->freeDeltaNsLit, j));
            }
            Ddi_Free(nsv);
          }
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
            fprintf(tMgrO(travMgr),
              "(Exist by composition on free deltas: %d",
              Ddi_BddSize(itpTravMgr->from))
            );
          Ddi_BddComposeAcc(itpTravMgr->from, vars, lits);
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
            fprintf(tMgrO(travMgr), " -> %d)\n", Ddi_BddSize(itpTravMgr->from))
            );
          Ddi_Free(vars);
          Ddi_Free(lits);
          Ddi_Free(supp);
        }
      }
    }

    if (itpExact ||
      (itpTravMgr->from != NULL && (dynAbstr > 3 && enDynAbstrOpt ||
          useFwdUnroll))) {
      char suffix[20];
      Ddi_Bddarray_t *newFwdUnroll = NULL;
      int constrainFwdUnroll = 0;

      sprintf(suffix, "%d", step + 1);
      //      abstrMask = Pdtutil_Alloc(unsigned char,nState);
      newFwdUnroll = Ddi_BddarrayDup(itpMgr->delta);
      Ddi_Vararray_t *newPiVars =
        Ddi_VararrayMakeNewVars(pi, "PDT_ITP_FWDUNR_PI", suffix, 1);
      Ddi_Bddarray_t *newPiLits = Ddi_BddarrayMakeLiteralsAig(newPiVars, 1);

      Ddi_VararrayAppend(Tr_MgrReadI(Tr_TrMgr(itpMgr->trBdd)), newPiVars);
      Ddi_AigarrayComposeAcc(newFwdUnroll, pi, newPiLits);
      Ddi_Free(newPiVars);
      Ddi_Free(newPiLits);
      Pdtutil_Assert(itpExact || dynAbstr > 3
        || useFwdUnroll, "wrong dynabstr");
      /* ps possono essere in fwdUnroll */
      Ddi_AigarrayComposeAcc(newFwdUnroll, ps, itpMgr->nsLit);
      if (toPlusCube != NULL && constrainFwdUnroll) {
        Ddi_AigarrayConstrainCubeAcc(newFwdUnroll, toPlusCube);
      }
      Ddi_AigarrayComposeAcc(newFwdUnroll, ns, itpTravMgr->fwdUnroll);
      //      Ddi_Free(fwdUnroll);
      Ddi_Free(itpTravMgr->prevFwdUnroll);
      itpTravMgr->prevFwdUnroll = itpTravMgr->fwdUnroll;
      itpTravMgr->fwdUnroll = Ddi_BddarrayDup(newFwdUnroll);
      itpTravMgr->stats.fwdUnrollSize =
        Ddi_BddarraySize(itpTravMgr->fwdUnroll);
      Ddi_Free(newFwdUnroll);
    }

    if (itpTravMgr->from == NULL && itpTravMgr->to == NULL) {
      sat = 1;
    } else if (itpTravMgr->to == NULL) {

      if (0 && optLevel >= 0 && (dynAbstr <= 3 || !enDynAbstrOpt)
        && Ddi_BddSize(itpTravMgr->from) > optFromThresh) {
        int mySize;
        int rrp = Ddi_MgrReadAigRedRemMaxCnt(ddm);

        if (step > 3 && myCareBwd != NULL && Ddi_BddSize(myCareBwd) > 100
          && optFromThresh < 10000) {
          Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, 1);
        }
        DdiAigRedRemovalAcc(itpTravMgr->from,
          myCareBwd, 1000, travMgr->settings.aig.lazyTimeLimit);
        Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, rrp);
        mySize = Ddi_BddSize(itpTravMgr->from);
        if (mySize * 2 > optFromThresh) {
          optFromThresh = mySize * 2;
        }
      }

      if (abstrRef > 4) {
        if (useAbstrTr) {
          Ddi_BddComposeAcc(itpTravMgr->from, abstrRefCtrl, abstrDoAbstr);
        } else {
          Ddi_BddComposeAcc(itpTravMgr->from, abstrRefCtrl, abstrDoRefine);
        }
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMin_c,
          fprintf(tMgrO(travMgr), "(Abstr -> %d)",
            Ddi_BddSize(itpTravMgr->from))
          );
      }

      if (optLevel > 2 && (dynAbstr <= 3 && dynAbstr >= 1 || !enDynAbstrOpt)
        && Ddi_BddSize(itpTravMgr->from) < 5000) {
        Ddi_Varset_t *sm;

        Ddi_AigExistProjectAcc(itpTravMgr->from, itpMgr->nsvars, toPlus, 2,
          0, 100.0);
        sm = Ddi_BddSupp(itpTravMgr->from);
        Ddi_VarsetDiffAcc(sm, nsvars);
        if (Ddi_VarsetIsVoid(sm)) {
          itpTravMgr->to = Ddi_BddDup(itpTravMgr->from);
          sat = 0;
        } else {
          itpTravMgr->to =
            Ddi_BddMakeFromAigWithAbort(itpTravMgr->from, 100000);
          if (itpTravMgr->to != NULL) {
            Ddi_BddExistAcc(itpTravMgr->to, sm);
            Ddi_BddSetAig(itpTravMgr->to);
            sat = 0;
          }
        }
        Ddi_Free(sm);
      }

      if (itpTravMgr->to == NULL) {
        if (optLevel > 2 && abstrVars != NULL && !Ddi_VarsetIsVoid(abstrVars)) {
          Ddi_AigExistAcc(localCone, abstrVars, toPlus, 2, 0, 100.0);
        }
        abortedTo = 0;
        if (implAbstr > 5) {
          Ddi_Vararray_t *constrainVarsPsNs = Ddi_VararrayAlloc(ddm, 0);
          Ddi_Bddarray_t *constrainSubstLitsPsNs = Ddi_BddarrayAlloc(ddm, 0);
          Ddi_Bdd_t *eq;

          eq =
            DdiAigEquivVarsAcc(itpTravMgr->from, itpTravMgr->careFwd, nsvars,
            NULL, NULL, constrainVarsPsNs, constrainSubstLitsPsNs);
          if (eq != NULL) {
            Ddi_BddComposeAcc(itpTravMgr->from, constrainVarsPsNs,
              constrainSubstLitsPsNs);
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
              fprintf(tMgrO(travMgr), "PIPS->NS EQ found\n")
              );
          }
          Ddi_Free(eq);
          Ddi_Free(constrainVarsPsNs);
          Ddi_Free(constrainSubstLitsPsNs);
        }
        if (implAbstr > 2 && eqAfterDynAbstr && step >= implAbstrInitIter) {
          Ddi_Bdd_t *eq;

          if (toPlus != NULL && Ddi_BddSize(toPlus) > 0) {
            Ddi_Bdd_t *toPlus2 = Ddi_BddDup(toPlus);
#if 0
            eq = DdiAigEquivVarsAcc(toPlus2, itpTravMgr->careFwd, 
				    NULL, nsvars,
              localCone, itpTravMgr->constrainVars,
              itpTravMgr->constrainSubstLits);
#else
            eq = DdiAigEquivVarsEqGivenAcc(toPlus2, itpTravMgr->careFwd, 
				    NULL, nsvars, localCone, 
	      itpTravMgr->saveConstrainVars,
	      itpTravMgr->saveConstrainSubstLits,
	      itpTravMgr->constrainVars,
              itpTravMgr->constrainSubstLits);
#endif
            if (Ddi_VararrayNum(itpTravMgr->constrainVars) > 0) {
              Ddi_BddComposeAcc(itpTravMgr->from, itpTravMgr->constrainVars,
                itpTravMgr->constrainSubstLits);
            }
            Ddi_Free(eq);
            Ddi_Free(toPlus2);
          }
#if 0
          eq = DdiAigEquivVarsAcc(itpTravMgr->from, itpTravMgr->careFwd, NULL,
            itpMgr->nsvars, localCone, itpTravMgr->constrainVars,
            itpTravMgr->constrainSubstLits);
#else
          eq = DdiAigEquivVarsEqGivenAcc(itpTravMgr->from, itpTravMgr->careFwd, NULL,
            itpMgr->nsvars, localCone,
	    itpTravMgr->saveConstrainVars,
	    itpTravMgr->saveConstrainSubstLits,
            itpTravMgr->constrainVars,
            itpTravMgr->constrainSubstLits);
#endif
	  checkEqConstr(itpTravMgr->constrainVars,itpTravMgr->constrainSubstLits);

          Pdtutil_Assert(itpTravMgr->to == NULL, "null to required");
          if (implAbstr > 4 && step > 1 && step <= 3) {
            implArray = Ddi_BddarrayAlloc(ddm, 0);
            itpTravMgr->to =
              DdiAigImplicationsAcc(itpTravMgr->from, NULL, NULL, nsvars,
              implArray);
            if (0) {
              Ddi_Bdd_t *chk = Ddi_BddDiff(itpTravMgr->from, itpTravMgr->to);

              Pdtutil_Assert(!Ddi_AigSat(chk), "wrong implication img+");
              Ddi_Free(chk);
            }
            Ddi_AigConstrainImplAcc(localCone, implArray);
            Ddi_BddAndAcc(localCone, itpTravMgr->to);
            if (toPlus == NULL) {
              toPlus = Ddi_BddDup(itpTravMgr->to);
            } else {
              Ddi_BddAndAcc(toPlus, itpTravMgr->to);
            }
            Ddi_Free(itpTravMgr->to);
            Ddi_Free(implArray);
          }
	  checkEqConstr(itpTravMgr->constrainVars,itpTravMgr->constrainSubstLits);
	  Ddi_Free(eq);

	  if (Ddi_VararrayNum(itpTravMgr->constrainVars) > 0) {
            Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from);
            Ddi_Bdd_t *myConstr = Ddi_BddMakeEq(itpTravMgr->constrainVars,
              itpTravMgr->constrainSubstLits);

	    eq = Ddi_BddMakeAig(myConstr);
	    Ddi_Free(myConstr);
            if (toPlus == NULL) {
              toPlus = Ddi_BddDup(eq);
            } else {
              Ddi_BddComposeAcc(toPlus, itpTravMgr->constrainVars,
                itpTravMgr->constrainSubstLits);
              Ddi_BddAndAcc(toPlus, eq);
            }

            if (0 && Ddi_BddSize(localCone) > 10) {
              DdiAigRedRemovalControlAcc(localCone, itpTravMgr->from, 10,
                30.0);
            }
            //      if (careFwd != NULL) Ddi_BddAndAcc(toPlus,careFwd);
            if (Ddi_VarsetIsArray(nsvars)) {
              Ddi_VarsetSetArray(sm);
            }
            Ddi_VarsetDiffAcc(sm, nsvars);
            if (Ddi_VarsetNum(sm) < 4) {
              itpTravMgr->to =
                Ddi_BddExistProject(itpTravMgr->from, itpMgr->nsvars);
              sat = 0;
            } else if (0 && (step > 1)) {
              Ddi_Bdd_t *chk = Ddi_BddCompose(localCone, itpMgr->ns,
                itpMgr->delta);

              if (!Ddi_AigSatWithAbort(chk, 10.0)) {
                itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
                sat = 0;
              }
              Ddi_Free(chk);
            }
            Ddi_Free(sm);
          }
          Ddi_Free(eq);
          if (implAbstr > 3) {
            Ddi_Bdd_t *eq;
            Ddi_Bdd_t *constr = Ddi_BddDup(itpTravMgr->from);
            int size = Ddi_BddSize(localCone);
            int maxDepth = 20;

            if (itpTravMgr->careFwd != NULL) {
              Ddi_BddAndAcc(constr, itpTravMgr->careFwd);
            }
            eq = DdiAigFindEquiv(localCone, constr, maxDepth, 1, 30.0);
            if (eq != NULL && Ddi_BddSize(eq) > 0) {
              Ddi_BddSetAig(eq);
              if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
                int size1 = Ddi_BddSize(localCone);
                int sizeEq = Ddi_BddSize(eq);

                printf("EQ reduction (lev: %d) |Cone|: %d->%d, |EQ|: %d\n",
                  maxDepth, size, size1, sizeEq);
              }
              if (toPlus == NULL) {
                toPlus = Ddi_BddDup(eq);
              } else {
                Ddi_BddAndAcc(toPlus, eq);
              }
            }
            Ddi_Free(eq);
            Ddi_Free(constr);
          }
          //  Pdtutil_Assert(to==NULL,"numm to required");

        }

        if (itpTravMgr->to != NULL) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
            fprintf(tMgrO(travMgr), "NO INTERPOLANT DONE\n")
            );
        } else
          if (0 && toPlusCube != NULL
          && Ddi_BddSize(itpTravMgr->from) < 1000) {
          int j;
          Ddi_Bdd_t *partF = Ddi_AigPartitionTop(itpTravMgr->from, 0);

          for (j = 0; j < Ddi_BddPartNum(partF); j++) {
            Ddi_BddSetMono(Ddi_BddPartRead(partF, j));
          }
          //          Ddi_AigExistProjectAcc(from1,nsvars,NULL,0,0,100.0);
          Ddi_BddExistProjectAcc(partF, nsvars);
          Ddi_BddSetAig(partF);
          itpTravMgr->to = Ddi_BddDup(partF);
          Ddi_Free(partF);
        } else {
          int nv, ret;
          Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from); /* @@@ */
          int totN = Ddi_VarsetNum(sm);
          int exact;
          Ddi_Bdd_t *toAppr = NULL;

          if (Ddi_VarsetIsArray(nsvars)) {
            Ddi_VarsetSetArray(sm);
          }
          Ddi_VarsetIntersectAcc(sm, nsvars);
          sat = 0;
          if (!(itpExact)
            && (nv = Ddi_VarsetNum(sm)) < 150 && totN < 400 && nv > 10
            && Ddi_BddSize(localCone) > 5000
            && maxFailBddFwd > 0 && dynAbstr > 0 /*&& implAbstr>0 */ ) {
            Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm, 1);

            if (toPlus != NULL) {
              Ddi_BddAndAcc(myCare, toPlus);
            }
            if (myCareBwd != NULL) {
              Ddi_BddAndAcc(myCare, myCareBwd);
            }
            if (step>1 && itpTravMgr->settings.storeRings && (itpMgr->nRings > step)) {
              Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings, step);
              Ddi_BddAndAcc(myCare, oldFrom);
              Ddi_BddComposeAcc(myCare, itpTravMgr->constrainVars,
                itpTravMgr->constrainSubstLits);
            }
            
            // if (!Ddi_AigSatAnd(from,localCone,careBwd)) {
            if ((ret = Ddi_AigSatAndWithAbort(itpTravMgr->from,
                  localCone, myCare, 100.0)) != 1) {
              /* undefined result speculatively assumed UNSAT. If
                 wrong, check done later */
              if (ret < 0) {
                if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
                  printf("undef result - UNSAT speculated\n");
                }
              }
              exact = 0;
              if (0 && itpAppr > 0
                && itpMgr->trBdd != NULL && itpMgr->trBddIsAig) {
                toAppr = interpolantSatApprImg(itpMgr, travMgr,
                  itpTravMgr->from, itpTravMgr->careFwd, &exact, 16, 0);
              }
              if (exact) {
                itpTravMgr->to = toAppr;
              } else if (0) {
                int sizeTh = 20000 * 100 / nv;

                if (Ddi_BddSize(itpTravMgr->from) > 5000)
                  sizeTh *= 2;
                itpTravMgr->to = DdiAigExistProjectByBdd(itpTravMgr->from,
                  toAppr, sizeTh, nsvars, -1.0, 0, 0);
                if (itpTravMgr->to == NULL) {
                  itpTravMgr->to = DdiAigExistProjectByBdd(itpTravMgr->from,
                    toAppr, 5 * sizeTh, nsvars, -1.0, 0, 0);
                }
                if (itpTravMgr->to != NULL && toAppr != NULL) {
                  Ddi_BddAndAcc(itpTravMgr->to, toAppr);
                }
                Ddi_Free(toAppr);
              } else {
                if (toPlus == NULL && toAppr != NULL) {
                  toPlus = Ddi_BddDup(toAppr);
                }
                Ddi_Free(toAppr);
              }
              sat = 0;
              if (itpTravMgr->to != NULL) {
                Ddi_Bdd_t *chk = Ddi_BddDiff(itpTravMgr->from, itpTravMgr->to);

                Pdtutil_Assert(1 || !Ddi_AigSat(chk), "UNDERAPPR BDD IMG"); /*@@@ */
                Ddi_Free(chk);
                Ddi_Free(sm);
                sm = Ddi_BddSupp(itpTravMgr->to);
                Ddi_VarsetDiffAcc(sm, nsvars);
                if (!Ddi_VarsetIsVoid(sm)) {
                  Ddi_AigExistProjectAcc(itpTravMgr->to, itpMgr->nsvars,
                    NULL, 3, 0, 30.0);
                }
                Ddi_Free(sm);
                sm = Ddi_BddSupp(itpTravMgr->to);
                Ddi_VarsetDiffAcc(sm, nsvars);
                if (!Ddi_VarsetIsVoid(sm)) {
                  Ddi_Free(itpTravMgr->to);
                  maxFailBddFwd--;
                  //            maxFailBddFwd += 2;
                }
              } else {
                maxFailBddFwd--;
              }
            } else {
              sat = 1;
            }
            Ddi_Free(myCare);
          }
          Ddi_Free(sm);
          if (travPdrShared != NULL && travMgr->settings.aig.pdrShareReached) {

            if (travPdrShared->clauseShared != NULL) {
              int j;
              int nState = Ddi_VararrayNum(ps);
              Ddi_SatSolver_t *solver = Ddi_SatSolverAlloc();
              Ddi_ClauseArray_t *toClauses;
              Ddi_ClauseArray_t *cubeClauses = Ddi_ClauseArrayAlloc(40);
              Ddi_Bdd_t *refineTo = Ddi_BddMakePartConjVoid(ddm);
              bAig_Manager_t *bmgr = ddm->aig.mgr;

              DdiAig2CnfIdInit(ddm);
              for (j = 0; j < nState; j++) {
                Ddi_Var_t *ps_j = Ddi_VararrayRead(ps, j);
                Ddi_Var_t *ns_j = Ddi_VararrayRead(ns, j);
                bAigEdge_t psBaig = Ddi_VarToBaig(ps_j);
                bAigEdge_t nsBaig = Ddi_VarToBaig(ns_j);
                int psCnf, nsCnf;

                /* swap ps and ns because to is in ns space */
                nsCnf = DdiAig2CnfId(bmgr, nsBaig);
                psCnf = DdiAig2CnfId(bmgr, psBaig);
                Pdtutil_Assert(nsCnf == 2 * (j) + 1, "Wrong cnf id");
                Pdtutil_Assert(psCnf == 2 * (j + 1), "Wrong cnf id");
              }
              toClauses = Ddi_AigClauses(itpTravMgr->from, 0, NULL);
              DdiAig2CnfIdClose(ddm);
              Ddi_SatSolverAddClauses(solver, toClauses);
              pthread_mutex_lock(&travPdrShared->mutex);
              for (j = 0;
                j < Ddi_ClauseArrayNum(travPdrShared->clauseShared); j++) {
                Ddi_Clause_t *cl =
                  Ddi_ClauseArrayRead(travPdrShared->clauseShared, j);
                Ddi_Clause_t *cl2 = Ddi_ClauseNegLits(cl);

                Ddi_ClauseArrayPush(cubeClauses, cl2);
              }

              pthread_mutex_unlock(&travPdrShared->mutex);
              for (j = 0; j < Ddi_ClauseArrayNum(cubeClauses); j++) {
                Ddi_Clause_t *cube = Ddi_ClauseArrayRead(cubeClauses, j);

                if (!Ddi_SatSolve(solver, cube, -1)) {
                  /* to not included in cube: use cube */
                  Ddi_Clause_t *cl = Ddi_ClauseNegLits(cube);
                  Ddi_Bdd_t *clauseAig = Ddi_BddMakeFromClauseWithVars(cl, ns);

                  Ddi_ClauseFree(cl);
                  Ddi_BddPartInsertLast(refineTo, clauseAig);
                  Ddi_Free(clauseAig);
                }
              }

              Ddi_ClauseArrayFree(cubeClauses);
              Ddi_SatSolverQuit(solver);
              Ddi_BddSetAig(refineTo);
              if (toPlus != NULL) {
                Ddi_BddAndAcc(toPlus, refineTo);
              } else {
                toPlus = Ddi_BddDup(refineTo);
              }

              Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                fprintf(tMgrO(travMgr), "|to+pdrR:%d|.\n",
                  Ddi_BddSize(refineTo))
                );
              Ddi_Free(refineTo);
            }
          }


          if (itpAppr > 0
            && itpTravMgr->to == NULL && (itpAppr == 1 ||
              itpMgr->trBdd != NULL && (itpMgr->trBddIsAig))) {
            int exact, imgPlusSat = itpAppr == 1;
            Ddi_Bdd_t *myCare = Ddi_BddDup(itpTravMgr->careFwd);

            if (toPlus != NULL) {
              Ddi_BddAndAcc(myCare, toPlus);
            }
            if (imgPlusSat) {
              itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
              exact = 0;
              enToPlusImage = 0;
            } else {
              itpTravMgr->to = interpolantSatApprImg(itpMgr,
                travMgr, itpTravMgr->from, myCare, &exact, 10, 0);
              if (0 && itpAppr > 1 && itpTravMgr->to != NULL && nv > 10) {
                Ddi_Bdd_t *to2;

                Ddi_BddAndAcc(myCare, itpTravMgr->to);
                to2 = interpolantSatApprImg(itpMgr, travMgr,
                  itpTravMgr->from, myCare, &exact, nv, itpAppr - 1);
                if (to2 != NULL) {
                  Ddi_BddAndAcc(itpTravMgr->to, to2);
                }
                Ddi_Free(to2);
              }
              if (itpTravMgr->to != NULL && Ddi_BddSize(itpTravMgr->to) < 4) {
                if (--imgApprEn == 0) {
                  itpAppr = 0;
                }
              } else {
                imgApprEn++;
              }
            }
            Ddi_Free(myCare);
            if (toPlus == NULL) {
              toPlus = Ddi_BddDup(itpTravMgr->to);
            } else {
              Ddi_BddAndAcc(toPlus, itpTravMgr->to);
            }
            if (!exact && (!enToPlusImage ||
                (imgPlusSat = Ddi_AigSatAnd(toPlus, localCone, myCareBwd)))) {
              Ddi_Free(itpTravMgr->to); /* sbaglia con exact e failure !!! */
#if 1
              if (imgPlusSat) {
                int res;
                Ddi_Bdd_t *itpGen;
                int nState = Ddi_VararrayNum(ps);

                // Ddi_Bdd_t *a = Ddi_BddAnd(toPlus,localCone);
                Ddi_Vararray_t *glbA;
                Ddi_Varset_t *glbVars = Ddi_BddSupp(itpTravMgr->from);
                Ddi_Varset_t *toPlusVars = Ddi_BddSupp(toPlus);
                Ddi_Varset_t *coneVars = Ddi_BddSupp(localCone);
                int maxGen = 4 * nState;
                Ddi_Vararray_t *dynAC = NULL, *dynAA = NULL;
                Ddi_Bddarray_t *dynACL = NULL;
                int useDynAbstr = 1;
                Ddi_Bdd_t *fromAndNew = NULL, *localConeAndNew = NULL;;
                if (useDynAbstr) {
                  dynAA = dynAbstrAux;
                  dynAC = dynAbstrCut;
                  dynACL = dynAbstrCutLits;
                }

                if (itpGenMaxIter > 0) {
                  maxGen = itpGenMaxIter;
                }

                if (Ddi_VarsetIsArray(glbVars)) {
                  Ddi_VarsetSetArray(toPlusVars);
                }
                if (Ddi_VarsetIsArray(toPlusVars)) {
                  Ddi_VarsetSetArray(glbVars);
                }
                Ddi_VarsetUnionAcc(glbVars, toPlusVars);
                if (Ddi_VarsetIsArray(nsvars)) {
                  Ddi_VarsetSetArray(glbVars);
                }
                Ddi_VarsetIntersectAcc(glbVars, nsvars);
                if (Ddi_VarsetIsArray(coneVars)) {
                  Ddi_VarsetSetArray(glbVars);
                }
                Ddi_VarsetIntersectAcc(glbVars, coneVars);
                Ddi_Free(toPlusVars);
                Ddi_Free(coneVars);
                glbA = Ddi_VararrayMakeFromVarset(glbVars, 1);
                Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                  fprintf(tMgrO(travMgr), "|to+GENeralization:%d|.\n",
                    Ddi_BddSize(toPlus))
                  );
                fromAndNew = Ddi_BddDup(itpTravMgr->from);
                localConeAndNew = Ddi_BddDup(localCone);
                if (newFwd != NULL) {
                  Ddi_BddAndAcc(fromAndNew, newFwd);
                  if (!Ddi_BddIncluded(localCone, newFwd)) {
                    Ddi_BddAndAcc(localConeAndNew, newFwd);
                  }
                }
                itpGen = Ddi_AigInterpolantByGenClauses(localConeAndNew,
                  fromAndNew, myCareBwd, toPlus,
                  ps, ns, NULL, glbA, dynAC, dynAA, dynACL, maxGen, 0, &res);
                Ddi_Free(fromAndNew);
                Ddi_Free(localConeAndNew);
                //  Ddi_Free(a);
                Ddi_Free(glbA);
                Ddi_Free(glbVars);
                if (res >= 0) {
                  Ddi_BddNotAcc(itpGen);
                  if (newFwd != NULL) {
                    Ddi_BddNotAcc(newFwd);
                    if (!Ddi_BddIncluded(itpTravMgr->from, itpGen)) {
                      int s = Ddi_BddSize(itpGen);

                      Ddi_BddOrAcc(itpGen, newFwd);
                      Pdtutil_VerbosityLocal(verbosity,
                        Pdtutil_VerbLevelUsrMax_c, fprintf(tMgrO(travMgr),
                          "|OR !new:%d->%d|\n", s, Ddi_BddSize(itpGen))
                        );
                    }
                    Ddi_BddNotAcc(newFwd);
                    if (useNewFwd < 2)
                      Ddi_Free(newFwd);
                  }
                  if (0) {
                    Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->from, itpGen),
                      "wrong itp gen");
                  }
                  Ddi_BddAndAcc(toPlus, itpGen);
                  Pdtutil_VerbosityLocal(verbosity,
                    Pdtutil_VerbLevelUsrMax_c, fprintf(tMgrO(travMgr),
                      "|to+GEN:%d|\n", Ddi_BddSize(toPlus))
                    );
                  if (res > 0) {
                    /* to+ is adequate */
                    itpTravMgr->to = Ddi_BddDup(toPlus);
                  } else {
                    //          enGeneralizedItp=1;
                  }
                }
                Ddi_Free(itpGen);
              }
#endif
            } else {
              Ddi_Free(itpTravMgr->from);
              if (exact && Ddi_AigSatAnd(toPlus, localCone, myCareBwd)) {
                Ddi_Free(itpTravMgr->to);
                sat = 1;
              }
            }
          }

          if (itpTravMgr->to == NULL && !sat) {
            if ((toPlus != NULL || toPlusCube != NULL)) {
              Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                fprintf(stdout, "computing interpolant in TO+\n"));
              if (monotoneRedRemTh > 0
                && Ddi_BddSize(localCone) > monotoneRedRemTh) {
                Ddi_Bdd_t *notCone = Ddi_BddNot(localCone);
                Ddi_Bdd_t *myCare = Ddi_BddDup(toPlus);

                Ddi_AigOptByMonotoneCoreAcc(localCone, notCone, myCare, 0,
                  -1.0);
                //DdiAigRedRemovalControlAcc (localCone,myCare,-1,30.0);
                Ddi_Free(myCare);
                Ddi_Free(notCone);
              }
            }
          }

          if (itpTravMgr->to == NULL && !sat) {

            int sizeFrom = Ddi_BddSize(itpTravMgr->from);
            int sizeCone = Ddi_BddSize(localCone);
            int sizeTot = sizeFrom + sizeCone;
            int disableItp = 0, enableItpBdd = (enItpBdd > 0);

            itpCare = NULL;
            if (optLevel >= 1 && (toPlus != NULL || myCareBwd != NULL)) {
              itpCare = Ddi_BddMakeConstAig(ddm, 1);
              if (1 && toPlus != NULL && Ddi_BddSize(itpCare) < 5000
                && Ddi_BddSize(toPlus) < 10000) {
                Ddi_BddAndAcc(itpCare, toPlus);
                // /* @@@@ */ Ddi_AigConstrainOptAcc(localCone,toPlus,
                //  NULL,NULL,NULL,3);
              }
              if (myCareBwd != NULL)
                Ddi_BddAndAcc(itpCare, myCareBwd);
            }

            itpTimeLimit = useTimedItp ?
              1.0 * sizeTot / 800000 * travMgr->settings.aig.lazyTimeLimit
              : -1.0;
            if (itpTimeLimit > 0
              && itpTimeLimit < travMgr->settings.aig.lazyTimeLimit) {
              itpTimeLimit = travMgr->settings.aig.lazyTimeLimit;
            }
            if (0 && myInvarConstr != NULL) {
              Ddi_AigAndCubeAcc(itpTravMgr->from, myInvarConstr);
#if 0
              Ddi_BddNotAcc(myInvarConstr);
              Ddi_BddOrAcc(localCone, myInvarConstr);
              Ddi_BddNotAcc(myInvarConstr);
#endif
            }

            if (toPlus != NULL && refineToPlus) {
              int jj, done;
              int tryGenCof = 0;
	      int tryRedRemCone = 0 && sizeFrom>20000 && sizeCone>200000;

	      int reCheckTarget = 0 && itpTravMgr->settings.storeRings &&
		(itpMgr->nRings > step);

	      /* diaable this check with dynAbstr */
              if (tryGenCof) {
		if (!Ddi_AigSatConstrain(localCone,
                                         toPlus, -1.0, NULL)) {
                  disableItp = 1;
                }
              }
              else if (!useMinisat22 && 
		  Ddi_AigSatAndWithAbort(itpTravMgr->from, localCone,
                  itpCare, 10.0) == 1) {
                disableItp = 1;
              } else {
                if (itpAppr > 2) {
                  Ddi_Bdd_t *to2;
                  int nv = Ddi_VararrayNum(ps);

                  to2 = interpolantSatApprImg(itpMgr,
                    travMgr, itpTravMgr->from, itpCare, NULL, nv, itpAppr - 1);
                  if (to2 != NULL) {
                    Ddi_BddAndAcc(toPlus, to2);
                    Ddi_BddAndAcc(itpCare, to2);
                    reCheckTarget = 1;
                  }
                  Ddi_Free(to2);
                }
              }

              if (!disableItp && Ddi_BddSize(toPlus) > 8
                && doInductiveToPlus > 7) {
                for (jj = done = 0; jj < 3 && !done; jj++) {
                  Ddi_Bdd_t *ref = Ddi_BddDup(localCone);

                  Ddi_AigExistProjectAllSolutionAcc(ref, nsvars, toPlus, 1);
                  if (Ddi_BddIsZero(ref)) {
                    done = 1;
                    disableItp = 1;
                    itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
                  } else {
                    if (0 && itpTravMgr->careBwd != NULL) {
                      Ddi_BddDiffAcc(itpTravMgr->careBwd, ref);
                    }
                    interpolantTernaryAbstr(travMgr, ref,
                      itpTravMgr->from, itpCare, nsvars, NULL, NULL, 2, 1, 0);
                    Pdtutil_Assert(!Ddi_AigSatAnd(ref, itpTravMgr->from,
                        itpCare), "Wrong to+ ref.");
                    Ddi_BddDiffAcc(toPlus, ref);
                    Ddi_BddDiffAcc(itpCare, ref);
                    reCheckTarget = 1;
                  }
                  Ddi_Free(ref);
                }
              }
              ddiAbcOptAcc(toPlus, -1.0);
	      if (tryRedRemCone) {
		DdiAigRedRemovalAcc (localCone,toPlus,50000,60.0);
	      }
              if (reCheckTarget) {
		Ddi_Bdd_t *myToPlus = Ddi_BddDup(toPlus);
                Ddi_Bdd_t *myCone = Ddi_BddMakeAig(localCone); 
		if (itpTravMgr->settings.storeRings &&
		    (itpMgr->nRings > step)) {
		  Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings,
							step);
		  Ddi_BddAndAcc(myToPlus, oldFrom);
		}
                disableItp =
                  !Ddi_AigSatAnd(myToPlus, myCone, itpTravMgr->careBwd);
		Ddi_Free(myToPlus);
		Ddi_Free(myCone);
                if (disableItp) {
                  itpTravMgr->to = toPlus;
                  toPlus = NULL;
                }
              }
            }

	    if ((toPlusCube!=NULL||toPlus!=NULL) &&
                !disableItp && Ddi_BddIsZero(localCone)) {
	      Pdtutil_Assert(toPlusCube!=NULL||toPlus!=NULL,
			     "missing to plus");
	      disableItp = 1;
	      itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
	      if (toPlus!=NULL) {
		Ddi_BddAndAcc(itpTravMgr->to,toPlus);
	      }
	      if (toPlusCube!=NULL) {
		Ddi_BddAndAcc(itpTravMgr->to,toPlusCube);
	      }
	    }
            if (!disableItp && !enableItpBdd) {
              Ddi_Bdd_t *toMinus = NULL;
              int saveItpAbortTh = ddm->settings.aig.itpAbortTh;

              if (enGeneralizedItp) {
                int res;
                Ddi_Bdd_t *itpGen;
                int nState = Ddi_VararrayNum(ps);
                Ddi_Vararray_t *glbA;
                Ddi_Varset_t *glbVars = Ddi_BddSupp(itpTravMgr->from);
                int maxGen = 4 * nState;

                if (itpGenMaxIter > 0) {
                  maxGen = itpGenMaxIter;
                }

                Ddi_VarsetIntersectAcc(glbVars, nsvars);
                glbA = Ddi_VararrayMakeFromVarset(glbVars, 1);
                Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                  fprintf(tMgrO(travMgr), "|to-GENeralization:%d|.\n",
                    Ddi_BddSize(itpTravMgr->from))
                  );
                /* from ^ careFwd !!! */
                itpGen = Ddi_AigInterpolantByGenClauses(itpTravMgr->from,
                  localCone, myCareBwd, NULL,
                  ps, ns, NULL, glbA, NULL, NULL, NULL, maxGen, 0, &res);
                Ddi_Free(glbA);
                Ddi_Free(glbVars);
                if (res > 0) {
                  itpTravMgr->to = itpGen;
                  itpGen = NULL;
                  Pdtutil_VerbosityLocal(verbosity,
                    Pdtutil_VerbLevelUsrMax_c, fprintf(tMgrO(travMgr),
                      "|to-GEN:%d|\n", Ddi_BddSize(itpTravMgr->to))
                    );
                } else if (res == 0) {
                  /* partial */
                  toMinus = itpGen;
                  itpGen = NULL;
                }
                Ddi_Free(itpGen);
              }
#if 0
              to =
                Ddi_AigSatAndWithInterpolant(from, localCone, nsvars, psvars,
                /* careBwd DISABLED */ itpCare, NULL,
                implArray, &sat, itpPart, 0, itpTimeLimit);
              Ddi_Free(to);
#endif
              if (itpTravMgr->to == NULL) {
                Ddi_Bdd_t *fromAndNew = Ddi_BddDup(itpTravMgr->from);
		int isSat=0;

                if (toMinus != NULL) {
                  if (itpCare == NULL) {
                    itpCare = Ddi_BddMakeConstAig(ddm, 1);
                  }
                  Ddi_BddDiffAcc(itpCare, toMinus);
                }
                if (0 && Ddi_BddSize(localCone) > 20000) {
                  Ddi_AigOptByBddSweepTop(localCone, itpCare, 1);
                }

                if (useNewFwd > 1 && newFwd != NULL)
                  Ddi_BddAndAcc(fromAndNew, newFwd);
                if (enItpAbort
                  && prevToSize > ddm->settings.aig.itpIteOptTh * 2) {
                  ddm->settings.aig.itpAbortTh = prevToSize * 2;
                }
                if (0 && enItpAbort) {
                  ddm->settings.aig.itpAbortTh = saveItpAbortTh;
                }
                if ((rpmTh > 0) && (Ddi_BddSize(localCone) > rpmTh)) {
                  if (!Ddi_AigSat(localCone)) {
                    Ddi_Free(localCone);
                    localCone = Ddi_BddMakeConstAig(ddm, 0);
                  } else {
                    Ddi_Vararray_t *nsCommon = Ddi_VararrayDup(ns);
                    Ddi_Vararray_t *fromSupp = Ddi_BddSuppVararray(itpTravMgr->from);
                    Ddi_VararrayIntersectAcc(nsCommon,fromSupp);
                    Ddi_AigAbcRpmAcc(localCone, nsCommon, -1, -1.0);
                    Ddi_Free(nsCommon);
                    Ddi_Free(fromSupp);
                  }
                }
                if (itpTravMgr->settings.enItpSeq && (itpTravMgr->settings.enItpSeq<step) &&
                  Ddi_BddIsPartConj(localCone)) {
                  int jj, chk = 1;
                  Ddi_Vararray_t *seqRef = itpMgr->ns;
                  int nCuts = Ddi_BddPartNum(localCone);

		  itpMgr->igr.sameConeFail = -1;
		  itpTravMgr->settings.enItpSeq = 0;
		  //                  enItpSeq = 0;
                  Pdtutil_Assert(Ddi_BddIsPartConj(localCone),
                    "partconj needed by itpseq");
                  itpTravMgr->toItpSeq =
                    Ddi_AigSatAndWithInterpolantSequence(fromAndNew,
                    localCone, &sat, nCuts, itpTimeLimit);
                  Pdtutil_Assert(!sat && itpTravMgr->toItpSeq != NULL,
                    "unsat needed");
                  itpTravMgr->to =
                    Ddi_BddarrayExtract(itpTravMgr->toItpSeq, 0);
                  if (chk) {
                    Ddi_Varset_t *supp = Ddi_BddSupp(itpTravMgr->to);
		    Ddi_VarsetSetArray(supp);
                    Ddi_VarsetDiffAcc(supp, itpMgr->nsvars);
                    Pdtutil_Assert(Ddi_VarsetIsVoid(supp),
                      "non state var in itpseq");
                    Ddi_Free(supp);
                  }
                  for (jj = 0; jj < Ddi_BddarrayNum(itpTravMgr->toItpSeq);
                    jj++) {
                    Ddi_Vararray_t *seqv = itpMgr->timeFrames->vars[jj + 1];
                    Ddi_Bdd_t *itp_jj =
                      Ddi_BddarrayRead(itpTravMgr->toItpSeq, jj);
                    Ddi_BddSubstVarsAcc(itp_jj, seqv, seqRef);
                    if (chk) {
                      Ddi_Varset_t *supp = Ddi_BddSupp(itp_jj);
		      Ddi_VarsetSetArray(supp);

                      Ddi_VarsetDiffAcc(supp, itpMgr->nsvars);
                      Pdtutil_Assert(Ddi_VarsetIsVoid(supp),
                        "non state var in itpseq");
                      Ddi_Free(supp);
                    }
                  }
                } else {
                  Ddi_Bdd_t *itpPlus = NULL; 
                  int enRingsAsCare = 0;

                  if (itpTravMgr->settings.storeRings &&
                      (itpMgr->nRings > step) && toPlus==NULL) {
                    toPlus = Ddi_BddMakeConstAig(ddm, 1);
                  }
                  if (toPlus != NULL) {
                    itpPlus = Ddi_BddDup(toPlus);
                    if (itpCare != NULL) {
                      Ddi_BddAndAcc(itpPlus, itpCare);
                    }
                    if (itpTravMgr->settings.storeRings && enRingsAsCare &&
                      (itpMgr->nRings > step)) {
                      Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings,
                        step);

                      Ddi_BddAndAcc(itpPlus, oldFrom);
                    }
		    if (itpTravMgr->constrainVars != NULL) {
		      Ddi_BddComposeAcc(itpPlus, itpTravMgr->constrainVars,
					itpTravMgr->constrainSubstLits);
		    }
                    if (toPlusCube != NULL) {
                      Ddi_AigConstrainCubeAcc(itpPlus, toPlusCube);
                    }
                    Pdtutil_Assert(enDynAbstr&&
                                   abstrCareVarsWithDynAbstr ||
                                   Ddi_BddIncluded(fromAndNew,
                        itpPlus),"problem with itpPlus");
                  }

                  if (enFromNew && (fromNewLevel > 0) && 
                    step>2 && itpTravMgr->prevTo!=NULL &&
                    itpTravMgr->prevFrom!=NULL) {
		    if (itpTravMgr->constrainVars != NULL) {
		      Ddi_BddComposeAcc(itpTravMgr->prevTo, itpTravMgr->constrainVars,
					itpTravMgr->constrainSubstLits);
		    }
                    if (fromNewLevel == 2)
                      Ddi_BddDiffAcc(fromAndNew,itpTravMgr->prevFrom);
                    else if (fromNewLevel == 3)
                      Ddi_BddDiffAcc(fromAndNew,itpTravMgr->prevTo);
                    Pdtutil_VerbosityLocalIf(verbosity, Pdtutil_VerbLevelUsrMax_c) {
                      printf("using fromNew level %d\n", 
                             fromNewLevel);
                    }
                  }
		  else if (usePrevTo && itpTravMgr->prevFrom!=NULL) {
		    if (itpTravMgr->constrainVars != NULL) {
		      Ddi_BddComposeAcc(itpTravMgr->prevTo, 
					itpTravMgr->constrainVars,
					itpTravMgr->constrainSubstLits);
		    }
		  }
#if 1
		  int abort;
		  if (1&&useMinisat22) {
		    Ddi_Bdd_t *a=fromAndNew, *b=localCone, *c=itpCare;
		    if (0 && (ddiS != NULL)) {
		      a = Ddi_BddCopy(ddmDup,fromAndNew);
		      b = Ddi_BddCopy(ddmDup,localCone);
                      Ddi_BddWriteMark(b, Ddi_BddReadMark(localCone));
		      if (c!=NULL) {
			c = Ddi_BddCopy(ddmDup,itpCare);
		      }
		      if (itpPart>0 /* && itpPart<3 */) {
			Ddi_Free(c);
			c = Ddi_BddCopy(ddmDup,itpPlus);
		      }
		    }
                    else {
		      if (itpPart<=1/* && itpPart<3*/) c = itpPlus;
		      else if (itpPart==0) {
			if (itpTravMgr->settings.storeRings &&
			    (itpMgr->nRings > step)) {
			  Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings,
								step);
			  
			  c = oldFrom;
			}
		      }
		    }
		    int trypart=0&&itpMgr->hints.hintsEnabled;
		    if (trypart) {
		      if (itpTravMgr->imgPartVars==NULL) {
			int iConstr0 = itpMgr->hints.invar0_i;
			Ddi_Var_t *cvar0Ns = Ddi_VararrayRead(itpMgr->ns,iConstr0); 
			//			Ddi_Var_t *v = Ddi_VarFromName(ddm, "l566$NS");
			itpTravMgr->imgPartVars = Ddi_VararrayAlloc(ddm, 1);
			Ddi_VararrayWrite(itpTravMgr->imgPartVars,0,cvar0Ns);
		      }
		    }
                    int careOpt = ddm->settings.aig.itpUseCare;
                    useCareOpt |= itpMgr->invarConstr!=NULL;
                    ddm->settings.aig.itpUseCare = useCareOpt;
                    if (itpTravMgr->prevTo!=NULL) {
                      Ddi_BddDiffAcc(b,itpTravMgr->prevTo);
                    }
                    if (safe>0) {
                    }
                    int tryConstrain = 0;
                    if (tryConstrain &&
                        (c != NULL) && (Ddi_BddSize(c)>1000)
                        && (Ddi_BddSize(b)>200000)) { 
                      Ddi_Bdd_t *newCone =
                        Ddi_AigSat22Constrain(b,c,a);
                      if (newCone!=NULL) {
                        Ddi_DataCopy(b,newCone);      
                        Ddi_Free(newCone);
                      }
                    }                    
                    Ddi_Bdd_t *to22 =
		      itpImgPart(itpTravMgr,kCone,kConeRings,a,b,
                        NULL/*itpTravMgr->prevTo*/,step,doSplit,
			nsvars, psvars,
			/* careBwd DISABLED */ c, itpPlus, toPlusCube,
                        &sat, itpPart, 1, itpTimeLimit);
                    ddm->settings.aig.itpUseCare = careOpt;
		    isSat = to22==NULL;
		    static int checkRing = 0 && sat;
		    if (step>1 && checkRing && kConeRings) {
		      int myend = step-1;
		      int mystart = myend+Ddi_BddReadMark(localCone);;

		      int chk2, chk3, chk = itpCheckConeAtRing(itpMgr,itpTravMgr->reached,NULL,
						   myend,mystart-myend,2);
		      printf("ring check(%d,%d): %s\n", 
			     mystart,myend,chk?"SAT":"UNSAT");
		      if (!sat && chk) {
			Ddi_Bdd_t *ring = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings,myend));
			Ddi_Bdd_t *deltaProp = Ddi_BddarrayRead(itpMgr->delta,1127);
			Ddi_Bdd_t *deltaConstr = Ddi_BddarrayRead(itpMgr->delta,1126);
			Ddi_BddSubstVarsAcc(ring,itpMgr->ns,itpMgr->ps);
			Ddi_Free(ring);
		      }
		      if (sat && !chk) {
			Ddi_Bdd_t *tr0 = Ddi_BddRelMakeFromArray(itpMgr->delta, itpMgr->ns);
			Ddi_BddSubstVarsAcc(tr0,itpMgr->pi,itpMgr->auxVarPis);
			Ddi_BddSetAig(tr0);
			int eq = Ddi_BddEqualSat(tr0,itpMgr->tr);


			Ddi_Bdd_t *myRing = Ddi_BddSubstVars(Ddi_BddarrayRead(itpMgr->fromRings,myend),itpMgr->ns,itpMgr->ps);
			Ddi_BddAndAcc(tr0,myRing);
			Ddi_Bdd_t *ringAndTr = Ddi_BddAnd(myRing,itpMgr->tr);
			chk2 = itpCheckConeAtRing(itpMgr,ringAndTr,NULL,
						  myend+1,mystart-myend-1,0);
			Ddi_BddSubstVarsAcc(myRing,itpMgr->ps,itpMgr->ns);
			chk3 = itpCheckConeAtRing(itpMgr,myRing,NULL,
						   myend,mystart-myend,0);

			Ddi_Free(myRing);
			Ddi_Free(ringAndTr);
			Ddi_Free(tr0);

			Ddi_Bdd_t *cex = Ddi_AigSatAndWithCexAndAbort(a,
			  b,itpPlus, NULL, 100, NULL);
			Ddi_Varset_t *nsv = Ddi_VarsetMakeFromArray(itpMgr->ns);
			Ddi_Varset_t *psv = Ddi_VarsetMakeFromArray(itpMgr->ps);
			Ddi_Bdd_t *cexState = Ddi_BddCubeExistProject(cex, nsv);
			Ddi_Bdd_t *cexState0 = Ddi_BddCubeExistProject(cex, psv);
			Ddi_BddSubstVarsAcc(cexState0,itpMgr->ps,itpMgr->ns);

			Ddi_Bdd_t *tr1 = Ddi_BddCompose(cexState,itpMgr->ns,itpMgr->delta);
			Ddi_BddSubstVarsAcc(tr1,itpMgr->ps,itpMgr->ns);
			int sat0 = Ddi_AigSatAnd(tr1,Ddi_BddarrayRead(itpMgr->fromRings,step-1),NULL);
			Ddi_Free(cexState);
			Ddi_Free(cexState0);
			Ddi_Free(tr1);
			Ddi_Free(cex);
			Ddi_Free(nsv);
			Ddi_Free(psv);
		      }
		      Pdtutil_Assert(1||chk==sat,"wrong interpolant computed");
		    }
		    if (to22!=NULL) {
		      Ddi_Varset_t *supp = Ddi_BddSupp(to22);
		      Ddi_VarsetSetArray(supp);
		      Ddi_VarsetDiffAcc(supp,nsvars);
		      Pdtutil_Assert(Ddi_VarsetIsVoid(supp),"wrong to supp");
		      Ddi_Free(supp);
		    }
		    if (0 && to22!=NULL && Ddi_AigSatAnd(to22,b,c)){
		      Ddi_BddAndAcc(to22,itpPlus);
		    }
		    if (0 && ddiS != NULL) {
		      if (to22!=NULL) {
			itpTravMgr->to = Ddi_BddCopy(ddm,to22);
			Ddi_Free(to22);
		      }
		      Ddi_Free(a);
		      Ddi_Free(b);
		      Ddi_Free(c);
		    }
		    else {
		      itpTravMgr->to = to22;
		    }
		    if (0 && (itpTravMgr->to!=NULL)) {
		      if (Ddi_AigSatAnd(itpTravMgr->to,localCone,itpCare)) {
			printf("itp-B failure\n");
			Pdtutil_Assert(0,"exit");
		      }
		      Ddi_BddNotAcc(itpTravMgr->to);
		      if (Ddi_AigSatAnd(itpTravMgr->to,fromAndNew,itpCare)) {
			printf("itp-A failure\n");
			Pdtutil_Assert(0,"exit");
		      }
		      Ddi_BddNotAcc(itpTravMgr->to);
		      //		      Ddi_Free(to22);
		    }
		  }
                  int tryIncrItp = 0;
		  if (!sat && ddiS != NULL && tryIncrItp) {
                    int sat2;
                    Ddi_Bdd_t *to2;
		    Ddi_Bdd_t *a2 = Ddi_BddCopy(ddmDup,fromAndNew);
		    Ddi_Bdd_t *b2 = Ddi_BddCopy(ddmDup,localCone);
                    Ddi_Bdd_t *itpCare2 = NULL;
                    Ddi_Varset_t *ns2 = Ddi_VarsetCopy(ddmDup,nsvars);
                    Ddi_Varset_t *ps2 = Ddi_VarsetCopy(ddmDup,psvars);
		    if (itpPlus!=NULL && !Ddi_BddIsOne(itpPlus)) {
		      itpCare2 = Ddi_BddCopy(ddmDup,itpPlus);
		    }
		    long time22 = util_cpu_time();
                    static int useIncr = 1;
                    if (!useIncr) {
                      Ddi_IncrSatMgrSuspend(ddiS);
                      Ddi_IncrSatMgrLockAig(ddiS,a2);
                      Ddi_IncrSatMgrLockAig(ddiS,b2);
                      to2 = Ddi_AigSatAndWithInterpolantIncr(NULL,
                        a2, b2, ns2, ps2,
                        /* careBwd DISABLED */ itpCare2, NULL,
                        NULL, NULL, &sat2, NULL, 0, itpTimeLimit);
                      Ddi_IncrSatMgrResume(ddiS);
                    }
                    else {
                      fprintf(tMgrO(travMgr),
			    "\n*** Incremental Interpolant ***\n",
			    util_print_time((util_cpu_time() - time22))
			    );
                      if (!DdiAig2CnfIdIsOpen(ddmDup)) {
                        DdiAig2CnfIdInit(ddmDup);
                      }
                      to2 = Ddi_AigSatAndWithInterpolantIncr(ddiS,
                        a2, b2, ns2, ps2,
                        /* careBwd DISABLED */ itpCare2, NULL,
                        NULL, NULL, &sat2, NULL, 0, itpTimeLimit);
                    }
		    fprintf(tMgrO(travMgr),
			    "\n*** Incr Minisat time: %s ***\n",
			    util_print_time((util_cpu_time() - time22))
			    );
                    Ddi_Free(to2);
		    Ddi_IncrSatPrintStats(ddmDup,ddiS,0);
                    Ddi_Free(ns2);
                    Ddi_Free(ps2);
                    Ddi_Free(a2);
                    Ddi_Free(b2);
                    Ddi_Free(itpCare2);
                  }
		  else if (ddiS != NULL) {
		    Ddi_Bdd_t *cex;
		    Ddi_Bdd_t *checkPart =
		      Ddi_AigPartitionTopWithXor(fromAndNew,0,1);
		    Ddi_BddSetPartConj(checkPart);
		    Ddi_BddPartInsertLast(checkPart, localCone);
		    if (itpCare!=NULL && !Ddi_BddIsOne(itpCare)) {
		      Ddi_BddPartInsertLast(checkPart, itpCare);
		    }
		    // Ddi_AigSatMinisatLoadClausesIncremental(ddiS, checkPart);
                    Ddi_BddSetFlattened(checkPart);
		    Ddi_Bdd_t *check2 = Ddi_BddCopy(ddmDup,checkPart);
		    //		    Ddi_BddSetAig(check2);
		    if (!DdiAig2CnfIdIsOpen(ddmDup)) {
		      DdiAig2CnfIdInit(ddmDup);
		    }
		    //		    DdiAig2CnfIdClose(ddmDup);
		    //		    DdiAig2CnfIdInit(ddmDup);
                    Ddi_AigSatMinisatLoadClausesIncremental(ddiS, check2,NULL);
		    //		    DdiAig2CnfIdClose(ddmDup);
		    //		    DdiAig2CnfIdInit(ddmDup);
		    // Ddi_AigSatMinisatLoadClausesIncremental(ddiS, a2, b2);
		    long time22 = util_cpu_time();
#if 1
                    cex = Ddi_AigSatMinisatWithCexAndAbortIncremental(ddiS,
		      check2, NULL,
                      (itpMgr->time_limit-util_cpu_time())/1000.0,
                      &abort);
#else 
                    cex = Ddi_AigSatMinisat22WithCexAndAbortIncremental(ddiS,
			   check2, NULL,0,
			  (itpMgr->time_limit - util_cpu_time()) / 1000.0, &abort);
#endif
                    if (cex!=NULL) {
			isSat=1;
			// SAT
                    }
                    Ddi_Free(cex);
		    fprintf(tMgrO(travMgr),
			    "\n*** Incre Minisat time: %s ***\n",
			    util_print_time((util_cpu_time() - time22))
			    );
		    Ddi_IncrSatPrintStats(ddmDup,ddiS,
                                          0);

		    //		    Ddi_IncrSatMgrQuit(ddiS);
		    //		    ddiS = Ddi_IncrSatMgrAlloc(1, 1);

		    if (save2==NULL) {
		      save2 = Ddi_BddarrayAlloc(ddmDup,0);
		    }
		    //		    Ddi_BddSetAig(check2);
		    Ddi_BddarrayInsertLast(save2,check2);
#if 0
		    fprintf(tMgrO(travMgr),
			    "\n*** Incre DDIM aigs: %d ***\n",
			    Ddi_BddarraySize(save2)
			    );
#endif
		    Ddi_Free(check2);
		    Ddi_Free(checkPart);
		  }
#endif
		  if (!useMinisat22) {
                    Ddi_Bdd_t *myPrevTo = NULL;
                    if (enFromNew && (fromNewLevel == 1)) 
                      myPrevTo = itpTravMgr->prevTo;
		    itpTravMgr->to =
		      Ddi_AigSatAndWithInterpolant(fromAndNew, localCone,
			nsvars, psvars, /* careBwd DISABLED */ itpCare,
                        // NULL /*itpPlus */ , NULL,
                        myPrevTo /*itpTravMgr->prevTo*/ /*itpPlus/prevTp */ , NULL,
                        implArray, &sat, itpPart, 1, itpTimeLimit);
		  }
                  Ddi_Free(itpPlus);
                  // if (itpTravMgr->to!=NULL) Ddi_BddNotAcc(itpTravMgr->to)
		  if (1&&useMinisat22) {
		    if (isSat) {
		      Pdtutil_Assert(itpTravMgr->to==NULL,"Solver mismatch");
		    }
		    else {
		      Pdtutil_Assert(itpTravMgr->to!=NULL,"Solver mismatch");
		    }
		  }
                }
                Ddi_Free(fromAndNew);

                if (0 && enFromNew && (step>2) && itpTravMgr->prevTo!=NULL && itpTravMgr->to != NULL) {
                  Ddi_BddOrAcc(itpTravMgr->to,itpTravMgr->prevTo);
                }

                itpDone = itpTravMgr->to != NULL
                  && !Ddi_BddIsOne(itpTravMgr->to);
                if (enItpAbort && prevToSize > 0) {
                  ddm->settings.aig.itpAbortTh = saveItpAbortTh;
                }
                if (0 && enItpAbort) {
                  ddm->settings.aig.itpAbortTh = saveItpAbortTh;
                }
                if (itpDone && enItpAbort) {
                  prevToSize = Ddi_BddSize(itpTravMgr->to);
                }

                if (itpDone && newFwd != NULL && useNewFwd > 1) {
                  Ddi_BddNotAcc(newFwd);
                  if (!Ddi_BddIncluded(newFwd, itpTravMgr->to)) {
                    if (!Ddi_BddIncluded(itpTravMgr->from, itpTravMgr->to)) {
                      Ddi_BddOrAcc(itpTravMgr->to, newFwd);
                    } else {
                      printf("false include\n");
                    }
                  }
                  Ddi_Free(newFwd);
                }

                if (doInductiveToPlus > 1 && itpDone &&
                  itpTravMgr->to != NULL && step > 1) {
                  Ddi_Bdd_t *to1, *to0 = Ddi_BddDup(itpTravMgr->to);

                  //  Ddi_Bdd_t *to0 = to;
                  int size, size0 = Ddi_BddSize(to0);

                  to1 = Ddi_AigImgSimplify(to0, toPlus, NULL /*kCone */ , 2);
                  Ddi_Free(itpTravMgr->to);
                  itpTravMgr->to = to1;
                  size = Ddi_BddSize(itpTravMgr->to);
                  Ddi_Free(to0);
                  if (size != size0) {
                    Pdtutil_VerbosityLocal(verbosity,
                      Pdtutil_VerbLevelUsrMax_c, fprintf(tMgrO(travMgr),
                        "|to simplify: %d->%d|.\n", size0, size)
                      );
                  }
                }
		else if (itpTravMgr->to != NULL) {
		  Ddi_BddSetAig(itpTravMgr->to);
		}

                if (doInductiveToPlus > 5 && itpTravMgr->to != NULL) {
                  Ddi_AigGeneralizeItpAcc(itpTravMgr->from, itpTravMgr->to,
                    itpCare, 0);
                }
                if (itpTravMgr->to != NULL && toMinus != NULL) {
                  Ddi_BddOrAcc(itpTravMgr->to, toMinus);
                }
                Ddi_Free(toMinus);
              }
              if (sat == -2) {
                sat = 0;
                incompleteTrav = 1;
              }
              if (0 && itpTravMgr->to == NULL && itpMgr->trRange != NULL) {
                Ddi_Bdd_t *from2 = Ddi_BddCompose(itpTravMgr->reached,
                  itpMgr->ns, itpMgr->psLit);

                Ddi_BddAndAcc(from2, itpMgr->trRange);
                Ddi_BddAndAcc(from2, itpMgr->tr);
                if (toPlusCube != NULL) {
                  Ddi_AigConstrainCubeAcc(from2, toPlusCube);
                }
                if (!Ddi_AigSatAnd(from2, localCone, itpCare)) {
                  itpTravMgr->to = Ddi_AigSatAndWithInterpolant(from2, localCone, itpMgr->nsvars, itpMgr->psvars,   /* careBwd DISABLED */
                    itpCare, NULL, NULL,
                    implArray, &sat, itpPart, 1, itpTimeLimit);
                }
                Ddi_Free(from2);
              } else if (itpTravMgr->to != NULL && tightenOrLoosen) {
                int myDbg = 0;
                Ddi_Bdd_t *to0 = itpTravMgr->to;

#if 1
                // to = Ddi_AigTightenOrLoosen (to0,
                //   from, itpCare, tightenOrLoosen);
                //#else
                //          if (Ddi_BddSize(to)!=Ddi_BddSize(to0)) {
                // Ddi_Free(to);
                itpTravMgr->to = Ddi_BddNot(to0);
                interpolantTernaryAbstr(travMgr, itpTravMgr->to,
                  itpTravMgr->from, itpCare, itpMgr->nsvars, NULL, NULL, 2,
                  1, 0);
                Ddi_BddNotAcc(itpTravMgr->to);
                //          }
#endif
                // should be extended to itpCare !!!
                if (myDbg) {
                  Ddi_Bdd_t *chk =
                    Ddi_BddDiff(itpTravMgr->from, itpTravMgr->to);
                  if (itpCare != NULL) {
                    Ddi_BddAndAcc(chk, itpCare);
                  }
                  Pdtutil_Assert(!Ddi_AigSat(chk), "INVALID TIGHT");
                  Ddi_Free(chk);
                  chk = Ddi_BddDiff(itpTravMgr->to, to0);
                  if (itpCare != NULL) {
                    Ddi_BddAndAcc(chk, itpCare);
                  }
                  Pdtutil_Assert(!Ddi_AigSat(chk), "INVALID TIGHT");
                  Ddi_Free(chk);
                }
                Ddi_Free(to0);
                //          }
              }
            }

            if (itpTravMgr->to == NULL && !sat && itpMgr->boundkOptPis != NULL) {
              /* undefinedResult */
              Ddi_Bdd_t *to2;
              int j, k, n = itpMgr->boundkOptNumVars;

              itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
              for (j = 0; j < n; j++) {
                Ddi_Bdd_t *myConeAux = Ddi_BddDup(localCone);

                for (k = 0; k < n; k++) {
                  Ddi_Var_t *boundkV =
                    Ddi_VararrayRead(itpMgr->boundkOptPis, 2 * k);
                  Ddi_Var_t *boundkV2 =
                    Ddi_VararrayRead(itpMgr->boundkOptPis, 2 * k + 1);
                  if (k < j) {
                    Ddi_BddCofactorAcc(myConeAux, boundkV2, 0);
                    Ddi_BddCofactorAcc(myConeAux, boundkV, 1);
                  } else if (k > j) {
                    Ddi_BddCofactorAcc(myConeAux, boundkV2, 1);
                    Ddi_BddCofactorAcc(myConeAux, boundkV, 0);
                  }
                }
                if (Ddi_AigSatAnd(itpTravMgr->to, myConeAux, itpCare)) {
                  to2 = Ddi_AigSatAndWithInterpolant(itpTravMgr->from, myConeAux, nsvars, psvars,   /* careBwd DISABLED */
                    itpCare, NULL, NULL, implArray, &sat, itpPart, 1, -1.0);
                  if (to2 == NULL) {
                    Ddi_Free(itpTravMgr->to);
                    Ddi_Free(myConeAux);
                    break;
                  }
                  Ddi_BddAndAcc(itpTravMgr->to, to2);
                  //                  Ddi_BddAndAcc(itpCare,to2);
                  Ddi_Free(to2);
                }
                Ddi_Free(myConeAux);
              }
              Pdtutil_Assert(itpTravMgr->to == NULL ||
                !Ddi_AigSatAnd(itpTravMgr->to, localCone, itpCare),
                "wrong partitioned itp");
            }
            Ddi_Free(itpCare);
            if (itpTravMgr->to == NULL) {
              if (!sat && itpExact == 2) {
                /* aborted */
                itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
              }
              //            Pdtutil_Assert(chkInnerCone, "wrong inner appr");
            }
            //            toPlus,implArray,&sat,0,30.0);
            if (enableItpBdd || (0 && itpTravMgr->to != NULL &&
                Ddi_BddSize(itpTravMgr->to) > 100000)) {
              Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from);
              Ddi_Bdd_t *to2;

              Ddi_VarsetIntersectAcc(sm, nsvars);
              if (Ddi_VarsetNum(sm) < 80 &&
                Ddi_BddSize(itpTravMgr->from) < 10000) {
                to2 = DdiAigExistProjectByBdd(itpTravMgr->from,
                  toPlus, 50000, nsvars, -1.0, 0, 0);
                sat = 0;
                if (to2 != NULL) {
                  Ddi_Bdd_t *chk = Ddi_BddDiff(itpTravMgr->from, to2);

                  Pdtutil_Assert(!Ddi_AigSat(chk), "UNDERAPPR BDD IMG");
                  Ddi_Free(chk);
                  Ddi_Free(sm);
                  sm = Ddi_BddSupp(to2);
                  Ddi_VarsetDiffAcc(sm, nsvars);
                  Pdtutil_Assert(Ddi_VarsetIsVoid(sm), "wrong bdd exist");
                  Ddi_Free(itpTravMgr->to);
                  itpTravMgr->to = to2;
                } else {
                  //                sat = 1;
                }
              }
              Ddi_Free(sm);
            }
          }

        }


        if(itpTravMgr->currFrom != NULL) {
          Ddi_Free(itpTravMgr->prevFrom);
          itpTravMgr->prevFrom = itpTravMgr->currFrom;
          itpTravMgr->currFrom = NULL;
        }



        if (itpTravMgr->to == NULL && !sat) {
          abortedTo = 1;
          sat = 1;
        } else if (0 && (itpTravMgr->to != NULL) &&
          Ddi_BddSize(itpTravMgr->to) > itpPartTh * 4
          && dynAbstr > 1 && !enDynAbstrOpt) {
          Ddi_Free(itpTravMgr->to);
          //        sat = 1;
        } else if (itpTravMgr->to != NULL
          && Ddi_BddSize(itpTravMgr->to) <= 2000 && dynAbstr > 1
          && enDynAbstrOpt) {
          // DISABLED ! It doesn't seem to work disabling it again!
          if (travMgr->settings.aig.selfTuningLevel > 1) {
            enDynAbstrOpt = 0;
          }
        }
        if (0 && (itpTravMgr->to == NULL
            || Ddi_BddSize(itpTravMgr->to) > 20000)) {
          Ddi_Varset_t *mySm = Ddi_BddSupp(itpTravMgr->from);


          Ddi_VarsetDiffAcc(mySm, nsvars);
          Ddi_Free(itpTravMgr->to);
#if 1
          Ddi_AigOptByMinCut(itpTravMgr->from, itpTravMgr->careFwd, nsvars,
            1, 1, -1.0);
          Ddi_AigExistProjectAcc(itpTravMgr->from, nsvars,
            itpTravMgr->careFwd, 3, 0, 200.0);
          itpTravMgr->to =
            Ddi_AigSatAndWithInterpolant(itpTravMgr->from, localCone, nsvars,
            psvars, NULL, NULL, NULL, NULL, &sat, 0, 0, 30.0);
#else
          to = Ddi_BddDup(from);
          Ddi_AigExistProjectAcc(to, nsvars, NULL, 3, 0, -1.0);
          Ddi_AigExistProjectAcc(to, nsvars, NULL, 0, 0, -1.0);
          toAndkCone = Ddi_BddAnd(to, localCone);
          sat = Ddi_AigSat(toAndkCone);
          Ddi_Free(toAndkCone);
#endif
          Ddi_Free(mySm);
        }
      }

      if (itpTravMgr->to != NULL) {
        int i;

        Ddi_Vararray_t *vs = Ddi_BddSuppVararray(itpTravMgr->to);

        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("TO: %d (supp: %d) - AIG nodes %d\n",
            Ddi_BddSize(itpTravMgr->to), Ddi_VararrayNum(vs),
            Ddi_MgrReadAigNodesNum(ddm));
          //logBddSupp(itpTravMgr->to);
        }
        //      DdiLogBdd(to,0);
	Ddi_VararrayWriteMark(vs, 1);
        for (i = 0; i < Ddi_VararrayNum(ns); i++) { // @@@
          if (Ddi_VarReadMark(Ddi_VararrayRead(ns, i))>0) {
            itpMgr->coreVarsCnt[i]++;
          }
        }
	Ddi_VararrayWriteMark(vs, 0);
        Ddi_Free(vs);
      }

    } else {
      /* to != NULL */
      sat = 0;
    }

    Ddi_Free(itpTravMgr->trArray);
    if (enCheckReached && careCone != NULL && !Ddi_BddIsZero(careCone) &&
      3 * Ddi_BddSize(careCone) < 2 * Ddi_BddSize(kCone)) {
      Ddi_Varset_t *sm = Ddi_BddSupp(careCone);

      Ddi_VarsetDiffAcc(sm, nsvars);
      if (checkReached != NULL) {
        Ddi_Bdd_t *chk = Ddi_BddDiff(careCone, checkReached);

        Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
        Pdtutil_Assert(!Ddi_AigSat(chk), "overappr-carecone");
        Ddi_Free(chk);
      }

      {
        int maxIter = Ddi_MgrReadAigMaxAllSolutionIter(ddm);

        Ddi_MgrSetAigMaxAllSolutionIter(ddm, 4);
        Ddi_AigExistSubsetAcc(careCone, sm, NULL, NULL, -2, 100.0);
        Ddi_MgrSetAigMaxAllSolutionIter(ddm, maxIter);
      }

      if (checkReached != NULL) {
        Ddi_Bdd_t *chk = Ddi_BddDiff(careCone, checkReached);

        Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
        Pdtutil_Assert(!Ddi_AigSat(chk), "overappr-carecone");
        Ddi_Free(chk);
      }


      if (bReached == NULL) {
        bReached = Ddi_BddDup(careCone);
      } else {
        Ddi_BddOrAcc(bReached, careCone);
      }
      Ddi_Free(sm);
    }

    if (itpExact == 2 && itpTravMgr->to != NULL &&
      trBdd2 != NULL && kConeOld != NULL) {
      Ddi_Bdd_t *toBdd = NULL, *toBddAppr;
      Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
      int thc = Ddi_MgrReadExistClustThresh(ddm);
      Ddi_Bdd_t *imgConstr = NULL;
      int exact;
      Ddi_Bdd_t *myTrBdd = Ddi_BddDup(itpMgr->trAux);

      Ddi_MgrSetExistClustThresh(ddm, -1);
      if (toPlusCube != NULL) {
        /* early quantification for IMAGE */
        Ddi_AigConstrainCubeAcc(myTrBdd, toPlusCube);
        Ddi_BddSetMono(toPlusCube);
        Ddi_BddExistProjectAcc(toPlusCube, nsvars);
        Ddi_BddConstrainAcc(Tr_TrBdd(trBdd2), toPlusCube);
      }
      imgConstr = Ddi_BddDup(itpTravMgr->to);
      if (toPlus != NULL) {
        Ddi_BddAndAcc(imgConstr, toPlus);
      }
      Ddi_BddSetMono(imgConstr);
      if (Ddi_BddSize(imgConstr) > 1) {
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMin_c,
          fprintf(tMgrO(travMgr), "Image Constraint Size: %d.\n",
            Ddi_BddSize(imgConstr))
          );
      }

      if (itpMgr->trAig != NULL) {
        Ddi_Bdd_t *toBddPart;
        Ddi_Bdd_t *myFrom = Ddi_BddMakeAig(saveFromBdd);
        int j;

        Ddi_BddSetPartConj(imgConstr);
        Ddi_BddAndAcc(myFrom, myTrBdd);
        toBddAppr = interpolantSatApprImg(itpMgr,
          travMgr, myFrom, itpTravMgr->careFwd, &exact, 10, 0);
        Ddi_BddAndAcc(itpTravMgr->to, toBddAppr);
        toBddPart = Ddi_AigPartitionTop(toBddAppr, 0);
        for (j = 0; j < Ddi_BddPartNum(toBddPart); j++) {
          Ddi_Bdd_t *t_j = Ddi_BddPartRead(toBddPart, j);

          Ddi_BddSetMono(t_j);
          Ddi_BddPartInsertLast(imgConstr, t_j);
        }
        Ddi_Free(myFrom);
        Ddi_Free(toBddPart);
        Ddi_Free(toBddAppr);
      }
      Ddi_Free(myTrBdd);
      if (0 && itpTravMgr->prevFwdUnroll != NULL && step > 4
        /*Ddi_BddSize(saveFromBdd) > 2000 */ ) {
        int th = -1;            // Fsm_MgrReadCutThresh(fsmMgr);
        Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm, 0);
        Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm, 0);
        Ddi_Bddarray_t *fwdBdd =
          Ddi_AigarrayOptByBdd(itpTravMgr->prevFwdUnroll, auxF, auxV, th, 0, -1,
          -1);

        Ddi_Free(auxF);
        Ddi_Free(auxV);
        Ddi_BddComposeAcc(Tr_TrBdd(trBdd2), ps, fwdBdd);
        Ddi_Free(fwdBdd);
        Ddi_Free(saveFromBdd);
        saveFromBdd = Ddi_BddMakeConst(ddm, 1);
      }

      if (0 && Ddi_BddSize(saveFromBdd) > 5000) {
        int j, n10, n5;
        Ddi_Varset_t *sf = Ddi_BddSupp(saveFromBdd);
        Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(sf, 1);

        Ddi_Free(sf);
        for (j = n10 = n5 = 0; j < Ddi_VararrayNum(vA); j++) {
          Ddi_Var_t *v_j = Ddi_VararrayRead(vA, j);
          Ddi_Bdd_t *cof0 = Ddi_BddCofactor(saveFromBdd, v_j, 0);
          Ddi_Bdd_t *cof1 = Ddi_BddCofactor(saveFromBdd, v_j, 1);
          int size0 = Ddi_BddSize(cof0);
          int size1 = Ddi_BddSize(cof1);

          if (size0 > size1 * 10 || size1 > size0 * 10)
            n10++;
          if (size0 > size1 * 5 || size1 > size0 * 5)
            n5++;
          Ddi_Free(cof0);
          Ddi_Free(cof1);
        }
        if (n5 > 0) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
            fprintf(tMgrO(travMgr), "unbalanced cofactors: (%d,%d)/%d\n",
              n5, n10, Ddi_VararrayNum(vA))
            );
        }
        Ddi_Free(vA);
      }

      if (Ddi_MetaActive(ddm) && step > 6) {
        Ddi_Varset_t *metaVars = Ddi_BddSupp(Tr_TrBdd(trBdd2));
        Ddi_Varset_t *meta2Vars = Ddi_BddSupp(saveFromBdd);
        int gSize = ddm->settings.meta.groupSizeMin;

        Ddi_VarsetUnionAcc(metaVars, meta2Vars);
        Ddi_Free(meta2Vars);
        if (Ddi_VarsetNum(metaVars) / gSize > 20) {
          gSize = Ddi_VarsetNum(metaVars) / 20;
        }
        Ddi_MetaInit(ddm, Ddi_Meta_FilterVars, NULL, metaVars, NULL, NULL,
          gSize);
        Ddi_Free(metaVars);
        Ddi_BddSetMeta(saveFromBdd);
        //      Ddi_BddSetMeta(imgConstr);
        Tr_MgrSetImgAndExistTh(Tr_TrMgr(itpMgr->trBdd), -1);
      } else {
        Ddi_BddSetMono(saveFromBdd);
      }

      //      Ddi_BddAndAcc(saveFromBdd,imgConstr);

      Ddi_BddConstrainAcc(Tr_TrBdd(trBdd2), imgConstr);
      toBdd = Tr_ImgWithConstrain(trBdd2, saveFromBdd, NULL);
      Ddi_BddSwapVarsAcc(imgConstr, ps, ns);
      Ddi_Free(saveFromBdd);
      saveFromBdd = Ddi_BddDup(toBdd);
      Ddi_BddSetPartConj(saveFromBdd);
      Ddi_BddPartInsert(saveFromBdd, 0, imgConstr);
      Ddi_BddSetFlattened(saveFromBdd);
      Ddi_Free(imgConstr);
      Ddi_MgrSetExistClustThresh(ddm, thc);
      Ddi_BddSwapVarsAcc(toBdd, ps, ns);
      Ddi_BddSetAig(toBdd);
      Ddi_BddAndAcc(itpTravMgr->to, toBdd);
      Ddi_Free(toBdd);
    }

    if (doMonotoneGen && itpTravMgr->to != NULL &&
      Ddi_BddSize(itpTravMgr->to) > 0 &&
      Ddi_BddIncluded(itpTravMgr->from, itpTravMgr->to)) {
      Ddi_Bdd_t *care = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);

      if (itpTravMgr->careBwd != NULL) {
        Ddi_BddAndAcc(care, itpTravMgr->careBwd);
      }
      if (toPlus != NULL) {
        Ddi_BddAndAcc(care, toPlus);
      }
      if (itpTravMgr->settings.storeRings && (itpMgr->nRings > step)) {
        Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings, step);

        Ddi_BddAndAcc(care, oldFrom);
      }
      //      Ddi_AigSplitMonotoneGenAcc (to,from,care);

      Ddi_Free(care);
      Ddi_Free(myOne);
    }

    if (itpTravMgr->to != NULL && (toPlus != NULL || toPlusCube != NULL)) {

      if (toPlus != NULL) {
        Ddi_BddAndAcc(itpTravMgr->to, toPlus);
      }

      if (toPlusCube != NULL) {
        /* early quantification for IMAGE */
        Ddi_BddSetMono(toPlusCube);
        Ddi_BddExistProjectAcc(toPlusCube, nsvars);
        Ddi_BddSetAig(toPlusCube);
#if 1
        Ddi_BddAndAcc(itpTravMgr->to, toPlusCube);
#else
        Ddi_BddSetPartConj(itpTravMgr->to);
        Ddi_BddPartInsertLast(itpTravMgr->to, toPlusCube);
#endif
      }
      if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        Ddi_Varset_t *vs = Ddi_BddSupp(itpTravMgr->to);

        printf("TO*TO+: %d (supp: %d)\n", Ddi_BddSize(itpTravMgr->to),
          Ddi_VarsetNum(vs));
        Ddi_Free(vs);
        if (0) {
          Ddi_Bdd_t *r = Ddi_BddMakeMono(itpTravMgr->to);

          printf("# TO states = %20.16g\n",
            Ddi_BddCountMinterm(r, Ddi_VararrayNum(itpMgr->ps)));
          Ddi_Free(r);
        }
      }
    }

    if (toPlusCube != NULL && !sat &&
      Ddi_BddSize(toPlusCube) > 0 && itpTravMgr->constrainVars != NULL) {
      Ddi_Varset_t *supp = Ddi_BddSupp(toPlusCube);
      Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(supp, 1);
      Ddi_Bddarray_t *vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
      int i, j, n = Ddi_VararrayNum(vA);
      int nc = Ddi_VararrayNum(itpTravMgr->constrainVars);

      Ddi_AigarrayConstrainCubeAcc(vLits, toPlusCube);
      // cibe lits can be literals in constrainSubLits
      Ddi_AigarrayConstrainCubeAcc(itpTravMgr->constrainSubstLits, toPlusCube);
      Ddi_VararrayAppend(itpTravMgr->constrainVars, vA);
      Ddi_BddarrayAppend(itpTravMgr->constrainSubstLits, vLits);
      Ddi_Free(vA);
      Ddi_Free(vLits);
      Ddi_Free(supp);
    }

    if (sat && itpTravMgr->to == NULL && careOut != NULL) {
      int jj;
      Ddi_Bdd_t *fromBck = Ddi_BddDup(localCone);
      Ddi_Bdd_t *reachedBck = Ddi_BddMakeConstAig(ddm, 0);
      Ddi_Bdd_t *reachedPs = Ddi_BddCompose(itpTravMgr->reached, ns, psLit);

      if (toPlusCube != NULL) {
        Ddi_BddAndAcc(fromBck, toPlusCube);
      }
      if (itpMgr->trRange != NULL) {
        Ddi_BddAndAcc(reachedPs, itpMgr->trRange);
      }
      for (jj = 0; jj < 2 * step; jj++) {
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "BCK partial preimage step: %d\n", jj)
          );
        Ddi_BddAndAcc(fromBck, itpMgr->tr);
        {
          Ddi_Varset_t *sm = Ddi_BddSupp(fromBck);
          Ddi_Bdd_t *prod = Ddi_BddAnd(fromBck, reachedPs);
          Ddi_Bdd_t *cex = Ddi_AigSatWithCex(prod);

          Ddi_VarsetDiffAcc(sm, psvars);
          Ddi_AigExistSubsetAcc(fromBck, sm, reachedPs, cex, 1, -1.0);
          Ddi_Free(sm);
          Ddi_Free(cex);
          Ddi_Free(prod);
        }
        Ddi_AigExistProjectAllSolutionAcc(fromBck, psvars, reachedPs, -1);
        Ddi_BddOrAcc(reachedBck, fromBck);
        Ddi_BddDiffAcc(reachedPs, fromBck);
        Ddi_BddComposeAcc(fromBck, ps, nsLit);
        if (Ddi_BddSize(fromBck) == 0) {
          if (jj == 0)
            undoCex = 1;
          break;
        }
      }
      if (!undoCex && savePreviousFrom != NULL) {
        Ddi_BddDiffAcc(savePreviousFrom, reachedBck);
        undoCex = 1;
      }
      if (!undoCex)
        Ddi_BddAndAcc(careOut, reachedBck);
      Ddi_Free(fromBck);
      Ddi_Free(reachedBck);
      Ddi_Free(reachedPs);
    }

    if (0 && itpTravMgr->settings.storeRings && sat && toPlus != NULL) {
      /* causes fix points intersecting target (unsound PASS) */
      if (toPlusCube != NULL) {
        Ddi_BddAndAcc(toPlus, toPlusCube);
      }
      Ddi_BddOrAcc(itpTravMgr->reached, toPlus);
      Ddi_BddarrayWrite(itpMgr->fromRings, step, toPlus);
      Ddi_BddarrayWrite(itpMgr->reachedRings, step, itpTravMgr->reached);
      itpMgr->nRings = Ddi_BddarrayNum(itpMgr->fromRings);
    }

    Ddi_Free(toPlusCube);
    if (Ddi_VararrayNum(itpTravMgr->constrainVars) == 0) {
      Ddi_Free(itpTravMgr->constrainVars);
      Ddi_Free(itpTravMgr->constrainSubstLits);
    }

    Ddi_Free(abstrVars);
    Ddi_Free(localCone);
    Ddi_Free(careCone);
    Ddi_Free(implArray);
    Ddi_Free(toPlus);
    Ddi_Free(inductiveTo);
    Ddi_Free(inductiveTo2);
    //    Ddi_Free(saveFromBdd);
    if (trBdd2 != NULL) {
      Tr_TrFree(trBdd2);
    }

    if (0 && redRem && itpTravMgr->to != NULL) {
      DdiAigRedRemovalAcc(itpTravMgr->to, itpTravMgr->careFwd, -1, -1.0);
      DdiAigRedRemovalAcc(itpTravMgr->to, itpTravMgr->careBwd, -1, -1.0);
    }


    if (sat && undoCex)
      sat = 0;
    if (sat) {

      Ddi_Free(itpTravMgr->to);
      Ddi_Free(toMinusTot);
      Ddi_Free(itpTravMgr->from0);
      Ddi_Free(itpTravMgr->careFwd);
      Ddi_Free(prevTo);
      Ddi_Free(newFwd);
      Ddi_Free(myCareBwd);
      Ddi_Free(inductiveTo);
      Ddi_Free(inductiveTo2);
      if (itpTravMgr->settings.tryInnerRing > 2 && enRewind) {
        if (growCone && (kConeRings != NULL)) {
          int np = Ddi_BddPartNum(kConeRings);

          if (step >= np) {
            itpTravMgr->settings.tryInnerRing = 0;
          }
        }
      }

      if (itpTravMgr->settings.tryInnerRing > 2 && enRewind) {

        itpTravMgr->settings.tryInnerRing = 1;
        if (0 && (Ddi_BddPartNum(kConeRings)>step+2)) {
          Ddi_BddPartRemove(kConeRings, step);
          Ddi_BddPartRemove(kConeRings, step);
        }
        itpMgr->igr.sameConeFail = step;
        Ddi_Free(itpTravMgr->from);
        itpTravMgr->from = Ddi_BddDup(savePreviousFrom);
        again = 1;
        step--;
        Ddi_Free(itpTravMgr->constrainVars);
        Ddi_Free(itpTravMgr->constrainSubstLits);
        if (itpTravMgr->saveConstrainVars != NULL) {
          itpTravMgr->constrainVars =
            Ddi_VararrayDup(itpTravMgr->saveConstrainVars);
          itpTravMgr->constrainSubstLits =
            Ddi_BddarrayDup(itpTravMgr->saveConstrainSubstLits);
        }

        Ddi_Free(itpTravMgr->currFrom);
        Ddi_Free(itpTravMgr->prevFrom);

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr),
            "\nSAME CONE HIT - TO computation resuming at previous step.\n\n")
          );
        itpTravMgr->settings.enItpSeq = travMgr->settings.aig.igrItpSeq;
        enItpAbort = 1;
        goto end_loop;
      } else {

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "Inner loop REACHES back cone.\n")
          );
        if (itpMgr->igr.sameConeFail < 0)
          itpMgr->igr.sameConeFail = step;
        itpTravMgr->settings.checkCompleteness = 0;
        *pAbort = 1;
        if (step == 1 && initStub != NULL) {
          // this is a true failure
          *pAbort = 3;
        }
        break;
      }

    }

    if (0 && itpTravMgr->careBwd != NULL && !Ddi_BddIncluded(itpTravMgr->to,
        itpTravMgr->careBwd)) {
      Ddi_BddAndAcc(itpTravMgr->to, itpTravMgr->careBwd);   /* @@@@ first iteration */
    }

    if (itpTravMgr->to != NULL && optLevel >= 0 &&
      Ddi_BddSize(itpTravMgr->to) > optToThresh) {
      int mySize;
      int rrp = Ddi_MgrReadAigRedRemMaxCnt(ddm);

      if (step > 3 && itpTravMgr->careBwd != NULL &&
        Ddi_BddSize(itpTravMgr->careBwd) > 100 && optToThresh < 10000)
        Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, 1);
      if (0 && itpTravMgr->careFwd != NULL) {
        Ddi_BddAndAcc(itpTravMgr->to, itpTravMgr->careFwd);
      }
      if (0 && itpTravMgr->careBwd != NULL) {
        Ddi_BddAndAcc(itpTravMgr->to, itpTravMgr->careBwd);
      }
      DdiAigRedRemovalAcc(itpTravMgr->to, itpTravMgr->careBwd, 1000,
        travMgr->settings.aig.lazyTimeLimit);
      Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, rrp);
      mySize = Ddi_BddSize(itpTravMgr->to);
      if (0 && mySize > 50 * optToThresh) {
        *pAbort = 2;            /* aborted */
      }
      if (mySize * 2 > optToThresh) {
        optToThresh = mySize * 2;
      } else {
        optToThresh *= 1.2;
      }
    }

    if (itpTravMgr->to != NULL && optLevel >= 0 &&
      (*pAbort == 2 || Ddi_BddSize(itpTravMgr->to) > 2 * optToThresh)) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "Inner loop ABORTED.\n")
        );
      Ddi_Free(itpTravMgr->to);
      Ddi_Free(itpTravMgr->from0);
      Ddi_Free(itpTravMgr->careFwd);
      Ddi_Free(prevTo);
      Ddi_Free(newFwd);
      Ddi_Free(myCareBwd);
      Ddi_Free(inductiveTo);
      Ddi_Free(inductiveTo2);
      Ddi_BddOrAcc(init, itpTravMgr->reached);
      itpTravMgr->settings.checkCompleteness = 0;
      *pAbort = 2;              /* aborted */
      break;
    }

    if (itpTravMgr->to != NULL) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "|to:%d|.\n", Ddi_BddSize(itpTravMgr->to))
        );
    }
    //        DdiAigRedRemovalAcc (to,careAig,-1);

    Ddi_Free(itpTravMgr->from);
    Ddi_Free(itpTravMgr->prevStoredFrom);
    if (itpTravMgr->to != NULL) {

      if (1 && itpTravMgr->settings.storeRings && (itpMgr->nRings > step)) {
        Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings, step);
	/* old from here @@@ */
        // Ddi_Bdd_t *oldFrom =
        //             Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings,step));
        //Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->reachedRings,step);
	itpTravMgr->prevStoredFrom = Ddi_BddDup(oldFrom);

        if (!Ddi_BddIncluded(itpTravMgr->to, oldFrom)) {
          if (doAbstrRefinedTo) {
            Ddi_Bdd_t *myToPlus = Ddi_AigInductiveImgPlus(NULL,
              itpTravMgr->to, itpTravMgr->careFwd, oldFrom,
              2 /*doInductiveToPlus*/);
            if (myToPlus != NULL) {
              Ddi_DataCopy(itpTravMgr->to, myToPlus);
              Ddi_Free(myToPlus);
            }
	    Ddi_BddAndAcc(itpTravMgr->to, oldFrom);
          } else if (doAbstrStoredTo) {
            Ddi_Bdd_t *myToPlus = Ddi_AigInductiveImgPlus(NULL,
              oldFrom, itpTravMgr->careFwd, itpTravMgr->to,
              2 /*doInductiveToPlus */ );

            if (myToPlus == NULL) {
              Ddi_BddAndAcc(itpTravMgr->to, oldFrom);
            } else {
              Ddi_BddAndAcc(itpTravMgr->to, myToPlus);
              Ddi_Free(myToPlus);
            }
          } else {
            Ddi_BddAndAcc(itpTravMgr->to, oldFrom);
            if (itpTravMgr->careFwd!=NULL) {
              Ddi_BddAndAcc(itpTravMgr->to, itpTravMgr->careFwd);
            }
          }
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "|to&oldTo:%d|.\n",
              Ddi_BddSize(itpTravMgr->to)););
        }
        if (chkRings && step > 1) {
          Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->to, oldFrom),
            "img problem in from rings");
        }
        //        Ddi_Free(oldFrom);

      }
      //      if (itpMgr->nPdrRings>step) {
      if (0 && (travPdrShared != NULL)) {

        if (travPdrShared->clauseShared != NULL) {
          int j, k, j2, nR;
          int nState = Ddi_VararrayNum(ps);
          Ddi_SatSolver_t *solver = Ddi_SatSolverAlloc();
          Ddi_SatSolver_t *solverR = Ddi_SatSolverAlloc();
          Ddi_ClauseArray_t *toClauses;
          Ddi_ClauseArray_t *reachedClauses;
          Ddi_ClauseArray_t *cubeClauses = Ddi_ClauseArrayAlloc(40);
          Ddi_Bdd_t *refineTo = Ddi_BddMakePartConjVoid(ddm);
          Ddi_Bdd_t *refineReached = Ddi_BddMakePartConjVoid(ddm);
          bAig_Manager_t *bmgr = ddm->aig.mgr;

          DdiAig2CnfIdInit(ddm);
          for (j = 0; j < nState; j++) {
            Ddi_Var_t *ps_j = Ddi_VararrayRead(ps, j);
            Ddi_Var_t *ns_j = Ddi_VararrayRead(ns, j);
            bAigEdge_t psBaig = Ddi_VarToBaig(ps_j);
            bAigEdge_t nsBaig = Ddi_VarToBaig(ns_j);
            int psCnf, nsCnf;

            /* swap ps and ns because to is in ns space */
            nsCnf = DdiAig2CnfId(bmgr, nsBaig);
            psCnf = DdiAig2CnfId(bmgr, psBaig);
            Pdtutil_Assert(nsCnf == 2 * (j) + 1, "Wrong cnf id");
            Pdtutil_Assert(psCnf == 2 * (j + 1), "Wrong cnf id");
          }
          toClauses = Ddi_AigClauses(itpTravMgr->to, 0, NULL);
          reachedClauses = Ddi_AigClauses(itpTravMgr->reached, 0, NULL);
          DdiAig2CnfIdClose(ddm);
          Ddi_SatSolverAddClauses(solver, toClauses);
          Ddi_SatSolverAddClauses(solverR, reachedClauses);
          Ddi_ClauseArrayFree(reachedClauses);
          pthread_mutex_lock(&travPdrShared->mutex);
          for (j = k = nR = 0;
            j < Pdtutil_IntegerArrayNum(travPdrShared->clauseSharedNum); j++) {
            int n =
              Pdtutil_IntegerArrayRead(travPdrShared->clauseSharedNum, j);
            if (j < step - 2) {
              k += n;
              continue;
            }
            for (j2 = 0; j2 < n; j2++) {
              Ddi_Clause_t *cl =
                Ddi_ClauseArrayRead(travPdrShared->clauseShared, k++);
              Ddi_Clause_t *cl2 = Ddi_ClauseNegLits(cl);

              Ddi_ClauseArrayPush(cubeClauses, cl2);
            }
            if (j == step - 1) {
              nR = Ddi_ClauseArrayNum(cubeClauses);
              /* previous ring: to be used for R */
            }
          }
          pthread_mutex_unlock(&travPdrShared->mutex);
          for (j = 0; j < Ddi_ClauseArrayNum(cubeClauses); j++) {
            Ddi_Clause_t *cube = Ddi_ClauseArrayRead(cubeClauses, j);

            if (j > nR && Ddi_SatSolve(solver, cube, -1)) {
              /* to not included in cube: use cube */
              Ddi_Clause_t *cl = Ddi_ClauseNegLits(cube);
              Ddi_Bdd_t *clauseAig = Ddi_BddMakeFromClauseWithVars(cl, ns);

              Ddi_ClauseFree(cl);
              Ddi_BddPartInsertLast(refineTo, clauseAig);
              Ddi_Free(clauseAig);
            }
            if (Ddi_SatSolve(solverR, cube, -1)) {
              /* reached not included in cube: use cube */
              Ddi_Clause_t *cl = Ddi_ClauseNegLits(cube);
              Ddi_Bdd_t *clauseAig = Ddi_BddMakeFromClauseWithVars(cl, ns);

              Ddi_ClauseFree(cl);
              Ddi_BddPartInsertLast(refineReached, clauseAig);
              Ddi_Free(clauseAig);
            }
          }

          Ddi_ClauseArrayFree(cubeClauses);
          Ddi_SatSolverQuit(solver);
          Ddi_SatSolverQuit(solverR);
          Ddi_BddSetAig(refineTo);
          Ddi_BddSetAig(refineReached);
          Ddi_BddAndAcc(itpTravMgr->to, refineTo);
          Ddi_BddAndAcc(itpTravMgr->reached, refineReached);
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "|to&pdrR:%d|.\n",
              Ddi_BddSize(itpTravMgr->to))
            );
          Ddi_Free(refineTo);
          Ddi_Free(refineReached);
        }
      }

      if (0 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(itpTravMgr->to, myInvarConstr);
      }

      if (toMinusTot != NULL) {
        Ddi_BddOrAcc(itpTravMgr->to, toMinusTot);
      }
      //      if (Ddi_BddIncluded(cexState,to)) {
      //    printf("included\n");
      //      }

      itpTravMgr->from = Ddi_BddDiff(itpTravMgr->to, itpTravMgr->reached);
      if (itpTravMgr->careBwd != NULL) {
        Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->careBwd);
      }

      Ddi_BddSetAig(itpTravMgr->from);
      if (itpConstrLevel > 1 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(itpTravMgr->from, myInvarConstr);
      }

      again = !enFpChk || useFwdUnroll || Ddi_AigSat(itpTravMgr->from) == 1;
      //    check theory of dynAbstr > 3 !
      //    again = dynAbstr < 4 && Ddi_AigSat(from)==1;
      Ddi_Free(itpTravMgr->from);
      if (!again) {
        if (itpTravMgr->settings.storeRings) {
	  Ddi_BddarrayWrite(itpMgr->fromRings, step, itpTravMgr->to);
        }
	itpMgr->lastRingId = step;
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "FWD ITP fix-point (0).\n"));
      }

      if (!again && dynAbstr > 3 && ternaryAbstr) {
        itpTravMgr->from = Ddi_BddDup(itpTravMgr->reached);
        again = 1;
      } else {
        if (!itpTravMgr->settings.storeRings &&
            Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c
          && (1 || (Ddi_BddSize(itpTravMgr->reached) < 10000) ||
            4 * Ddi_BddSize(itpTravMgr->reached) <
            Ddi_BddSize(itpTravMgr->to)) && reached1 != NULL) {
          //      from = Ddi_BddDiff(to,reached);
          itpTravMgr->from = Ddi_BddDiff(itpTravMgr->to, reached1);
        } else {
          itpTravMgr->from = Ddi_BddDup(itpTravMgr->to);
        }
      }

      if (Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectReached_c) {

        if (0&&(step>1)) {
           int included = Ddi_BddIncluded(itpTravMgr->reached,
                                         itpTravMgr->to);
          Pdtutil_Assert(included,"error in reached set inclusion");
        }

        Ddi_Free(itpTravMgr->reached);
        itpTravMgr->reached = Ddi_BddDup(itpTravMgr->to);
      } else {
        Ddi_BddOrAcc(itpTravMgr->reached, itpTravMgr->to);
      }

      if (0 && itpMgr->nRings > 0 && step > 1) {
        int jj = step;
        Ddi_Bdd_t *from00 = Ddi_BddarrayRead(itpMgr->fromRings, jj - 1);
        Ddi_Bdd_t *f00AndTr = Ddi_BddCompose(from00, ns, psLit);

        Ddi_BddAndAcc(f00AndTr, itpMgr->trAux);
        if (itpTravMgr->settings.useInvarFull && itpMgr->invarConstr != NULL) {
          Ddi_BddAndAcc(f00AndTr, itpMgr->invarConstr);
        }
        if (itpConstrLevel > 1 && myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(f00AndTr, myInvarConstr);
        }
        Pdtutil_Assert(Ddi_BddIncluded(f00AndTr, itpTravMgr->reached),
          "wrong ring IMG");
        Ddi_Free(f00AndTr);
      }

      if (reached1 == NULL) {
        reached1 = Ddi_BddDup(itpTravMgr->reached);
      } else {
        Ddi_DataCopy(reached1, itpTravMgr->reached);
      }
      if (0 && verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        Ddi_Bdd_t *r = Ddi_BddMakeMono(itpTravMgr->reached);

        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "# Reached states = %g.\n",
            Ddi_BddCountMinterm(r, Ddi_VararrayNum(itpMgr->ps)))
          );
        Ddi_Free(r);
      }

      if (useFwdUnroll) {
        Ddi_Bdd_t *chkTr = Ddi_BddDup(itpMgr->trAux);
        Ddi_Bdd_t *chk = Ddi_BddDup(itpTravMgr->reached);

        if (itpTravMgr->careBwd != NULL) {
          Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
        }
        Ddi_BddComposeAcc(chk, ns, psLit);
        Ddi_BddAndAcc(chk, chkTr);
        Ddi_Free(chkTr);
        Ddi_BddDiffAcc(chk, itpTravMgr->reached);
        if (itpTravMgr->careBwd != NULL) {
          Ddi_BddNotAcc(itpTravMgr->careBwd);
          Pdtutil_Assert(!Ddi_AigSatAnd(chk, itpTravMgr->careBwd, NULL),
            "Care set problem - Missed Failure");
          Ddi_BddNotAcc(itpTravMgr->careBwd);
          Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
        }
        again = Ddi_AigSat(chk);
        Ddi_Free(chk);
      }

      if (0 && redRem && itpTravMgr->careBwd != NULL) {
        DdiAigRedRemovalAcc(itpTravMgr->reached, itpTravMgr->careBwd, 1000,
          30.0);
      }

      Ddi_Free(itpTravMgr->careFwd);
      Ddi_Free(prevTo);
      Ddi_Free(newFwd);
      Ddi_Free(myCareBwd);
      Ddi_Free(itpTravMgr->to);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "   |tr|=%d |reached|=%d.\n",
          sizeAig, Ddi_BddSize(itpTravMgr->reached))
        );
      if (0) {
        fprintf(stdout, "#ReachedStates(estimated)=%g\n",
          Ddi_AigEstimateMintermCount(itpTravMgr->reached,
            Ddi_VararrayNum(ps)));
      }

    } else {
      Ddi_Free(newFwd);
      Ddi_Free(itpTravMgr->careFwd);
      Ddi_Free(prevTo);
      Ddi_Free(myCareBwd);
      if ((!enDynAbstrOpt || undoCex) && savePreviousFrom != NULL) {
        itpTravMgr->from = Ddi_BddDup(savePreviousFrom);
        again = 1;
        if (!undoCex) {
          enDynAbstrOpt = enDynAbstrBase = 1;
          itpTravMgr->settings.computeRestartFrom = (dynAbstr > 3);
        } else {
          useTrRange = 1;
        }

        step--;
        if (itpTravMgr->saveConstrainVars != NULL) {
          Ddi_Free(itpTravMgr->constrainVars);
          Ddi_Free(itpTravMgr->constrainSubstLits);
          itpTravMgr->constrainVars =
            Ddi_VararrayDup(itpTravMgr->saveConstrainVars);
          itpTravMgr->constrainSubstLits =
            Ddi_BddarrayDup(itpTravMgr->saveConstrainSubstLits);
        }

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr),
            " TO computation ABORTED - resuming at previous step.\n")
          );
      } else {
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "   TO computation ABORTED.\n")
          );
        again = 0;
        *pAbort = 2;            /* aborted */
      }
    }

  end_loop:

    Ddi_Free(itpTravMgr->from0);
    if (itpTravMgr->from != NULL) {
      Ddi_Free(savePreviousFrom);
      savePreviousFrom = Ddi_BddDup(itpTravMgr->from);
    }
    Ddi_Free(itpTravMgr->saveConstrainVars);
    Ddi_Free(itpTravMgr->saveConstrainSubstLits);
    if (itpTravMgr->constrainVars != NULL) {
      itpTravMgr->saveConstrainVars =
        Ddi_VararrayDup(itpTravMgr->constrainVars);
      itpTravMgr->saveConstrainSubstLits =
        Ddi_BddarrayDup(itpTravMgr->constrainSubstLits);
    }

    if (travShared != NULL && travMgr->settings.aig.itpShareReached) {

      if (Ddi_BddSize(itpTravMgr->reached) > 20000) {
        travMgr->settings.aig.itpShareReached = 0;
        printf("reached is too large: disable SHARING\n");
      } else {
        int ii = step;
        Ddi_Bdd_t *rX;
        Ddi_Mgr_t *ddmX;

        Pdtutil_Assert(ii >= 0, "wrong step Number");
        pthread_mutex_lock(&travShared->mutex);
        if (travShared->ddmXchg == NULL) {
          travShared->ddmXchg = Ddi_MgrDup(ddm);
        }

        ddmX = travShared->ddmXchg;
        rX = Ddi_BddCopy(ddmX, itpTravMgr->reached);
        if (travShared->itpRchShared == NULL) {
          Pdtutil_Assert(travShared->ddmXchg != NULL, "null ddi xchg mgr");
          travShared->itpRchShared = Ddi_BddarrayAlloc(travShared->ddmXchg, 1);
          Ddi_BddarrayWrite(travShared->itpRchShared, 0, rX);
        }

        if (Ddi_BddarrayNum(travShared->itpRchShared) <= ii) {
          while (Ddi_BddarrayNum(travShared->itpRchShared) < ii) {
            Ddi_BddarrayInsertLast(travShared->itpRchShared, rX);
          }
          Pdtutil_Assert(Ddi_BddarrayNum(travShared->itpRchShared) == ii,
            "bad share ring");
          Ddi_BddarrayWrite(travShared->itpRchShared, ii, rX);
        } else {
          Ddi_Bdd_t *rX0 = Ddi_BddarrayRead(travShared->itpRchShared, ii);

          Ddi_BddAndAcc(rX0, rX);
        }
        Ddi_Free(rX);
        pthread_mutex_unlock(&travShared->mutex);
      }
    }

    Ddi_Free(toMinusTot);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr),
        "*** Trav time: %s ***\n",
        util_print_time((util_cpu_time() - travMgr->travTime)))
      );
    if (again && maxIter > 0 && step > maxIter) {
      *pAbort = 1;
      again = 0;
    }

  } while (again);


  if (useMinisat22>1) {
    Ddi_IncrSatMgrQuit(ddiS);
    Ddi_Free(save2);
    Ddi_MgrQuit(ddmDup);
  }

  Ddi_Free(reached1);
  Ddi_Free(savePreviousFrom);

  return step;
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
interpolantInnerLoop(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Ddi_Bdd_t * kCone,
  Ddi_Bdd_t * kConeOld,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * careBwd,
  Ddi_Bdd_t * careBwdBdd,
  Ddi_Bdd_t * rOut,
  Ddi_Bdd_t * careOut,
  Ddi_Bddarray_t * kConeOldAuxLits,
  Trav_ItpMgr_t * itpMgr,
  int *pAbort,
  int optLevel,
  int firstIter,
  int maxIter,
  unsigned long time_limit
)
{
  /* INTERPOLANT INNER LOOP */

  Ddi_Bddarray_t *initStub = itpMgr->initStub;
  Ddi_Vararray_t *pi = itpMgr->pi;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Bddarray_t *psLit = itpMgr->psLit;
  Ddi_Bddarray_t *nsLit = itpMgr->nsLit;
  // Ddi_Vararray_t *dynAbstrAux = itpMgr->dynAbstrAux;
  // Ddi_Vararray_t *dynAbstrCut = itpMgr->dynAbstrCut;
  // Ddi_Bddarray_t *dynAbstrCutLits = itpMgr->dynAbstrCutLits;
  // unsigned char *enAbstr = itpMgr->enAbstr;
  // Ddi_Vararray_t *abstrRefCtrl = itpMgr->abstrRefCtrl;
  // Ddi_Bddarray_t *abstrDoAbstr = itpMgr->abstrDoAbstr;
  // Ddi_Bddarray_t *abstrDoRefine = itpMgr->abstrDoRefine;
  Ddi_Varset_t *ternarySmooth = NULL;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(kCone);
  // int extRef = Ddi_MgrReadExtRef(ddm);
  Ddi_Varset_t *nsvars = Ddi_VarsetMakeFromArray(ns);
  Ddi_Varset_t *psvars = Ddi_VarsetMakeFromArray(ps);
  Ddi_Bdd_t *savePreviousFrom = NULL;
  Ddi_Bdd_t *bReached = NULL, *checkReached = NULL, *fromBdd = NULL,
    *saveFromBdd = NULL;
  Trav_ItpTravMgr_t *itpTravMgr = NULL;
  int step = 0, sat;
  int enCheckReached = 0;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int dynAbstr = Trav_MgrReadDynAbstr(travMgr);
  int ternaryAbstr = Trav_MgrReadTernaryAbstr(travMgr);
  int implAbstr = Trav_MgrReadImplAbstr(travMgr);
  int abstrWithCone = 0;
  int abstrRef = Trav_MgrReadAbstrRef(travMgr) % 100;
  int abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  // int redRem = Ddi_MgrReadAigRedRemLevel(ddm);
  // int abcOpt = Ddi_MgrReadAigAbcOptLevel(ddm);
  // int useAbstrTr = 0;
  // int again;
  // int optReachedThresh = 10000;
  // int optFromThresh = 5000;
  // int optToThresh = 5000;
  // int abortedTo = 0;
  int enDynAbstrOpt = /*dynAbstr==3 || */ dynAbstr > 5 || ternaryAbstr > 0;
  int enDynAbstrBase = dynAbstr > 0;
  // int maxFailBddFwd = 1;
  int enBwdCareSimplify = 1;
  // int itpOpt = itpMgr->itpOpt;
  int useCareBwd;
  // int enToPlusImage = Trav_MgrReadItpEnToPlusImg(travMgr);
  // int itpPart = Trav_MgrReadItpPart(travMgr);
  // int itpPartTh = Ddi_MgrReadAigItpPartTh(ddm);
  // int enItpBdd = Trav_MgrReadItpBdd(travMgr);
  int itpAppr = Trav_MgrReadItpAppr(travMgr);
  int unsoundProof = 0;
  int useFwdUnroll = 0;
  // float itpTimeLimit = -1.0;
  // int useTimedItp = 1 || itpMgr->boundkOptPis != NULL;
  int enDynAbstr = 1, enDynAbstr0 = 1, maxNoAbstr0 = 2, maxNoAbstr = 2;
  // int enToPlusCubeSat = implAbstr > 1;
  char *storeReached = NULL;    //"ITP-RP";

  // char *storeReached="ITP-RP";
  Ddi_Bdd_t *myInvarConstr = NULL;
  // int doFirstPass = 0;
  int minConeRing = 0;
  // static int nFreeVars = 0;
  int doInductiveToPlus = Trav_MgrReadItpInductiveTo(travMgr);
  int initAbstr = Trav_MgrReadItpInitAbstr(travMgr);
  // int minDynAbstrStep = Trav_MgrReadDynAbstrInitIter(travMgr);
  // int imgApprEn = 400;
  int eqBeforeDynAbstr = 0;
  int eqAfterDynAbstr = 1;
  int tightenOrLoosen = (doInductiveToPlus > 6);
  // int refineToPlus = 1 || (itpAppr > 1 || doInductiveToPlus > 7);
  // int useTrRange = 0;
  Ddi_Bdd_t *myTrRange = NULL;
  // int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  // int enRewind = travMgr->settings.aig.igrRewind
  //  && Trav_MgrReadIgrGrowCone(travMgr) >= 0;
  // Trav_Shared_t *travPdrShared = NULL, *travShared = NULL;
  int itpExact = Trav_MgrReadItpExact(travMgr);
  int freeInitStub = 0;
  int initFwdSteps = itpExact;
  // int incompleteTrav = 0;
  int itpConstrLevel = Trav_MgrReadItpConstrLevel(travMgr);
  // int useNewFwd = travMgr->settings.aig.itpNew;
  int useCareFwd = 1 || Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c
    || Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectCofactor_c;
  // int maxTernary = 2;
  int estimateR = travMgr->settings.bdd.countReached;
  Ddi_Bdd_t *reached1 = NULL;
  int reuseRings = 0;
  // int itpGenMaxIter = Trav_MgrReadItpGenMaxIter(travMgr);
  // Ddi_Bdd_t *cexState = NULL;
  // int cegarAbstrRef = 0;
  int initMinterm = -1;
  Ddi_Bdd_t *fullInit = NULL;
  int nOrInnerRings = 0;
  int enStructAbstractionWithCone = travMgr->settings.aig.itpStructAbstr;
  int implAbstrInitIter = 0;
  // int doMonotoneGen = 0;
  // int monotoneRedRemTh = 0;     //20000;

  // int doAbstrStoredTo = 1;
  // int enItpAbort = 0, enItpSeq = 0, prevToSize = -1;
  // int rpmTh = travMgr->settings.aig.itpRpm;
  // int chkSupp = 1;
  // int chkRings = 0;
  int enFpChk = 1;
  // Ddi_Bdd_t *l1, *l2;

  if (abstrRef == 3) {
    abstrRef = 2;
  }

  if (implAbstr == 2) {
    implAbstr++;
    abstrWithCone = 1;
  }

  itpMgr->stats.igrRewindRing = -1;
  itpMgr->stats.igrPiSubsetK = -1;
  itpMgr->stats.igrPiSubsetRing = -1;

  itpTravMgr = itpTravMgrInit(travMgr, itpMgr);
  if (careBwd != NULL) {
    itpTravMgr->careBwd = Ddi_BddDup(careBwd);
    int checkCareBwd = 1;
    Ddi_Bddarray_t * delta = (itpMgr->deltaAbstr)?
      itpMgr->delta0:itpMgr->delta;
    if (delta==NULL) delta = itpMgr->delta;
    if (checkCareBwd) {
      int sat = checkRingIsFixPoint(itpMgr->ps,itpMgr->ns,
                                    delta,careBwd);
      Pdtutil_Assert (!sat,"problem with carebwd");
    }
  }

  if (initAbstr < 0) {
    implAbstrInitIter = initAbstr = -initAbstr;
  }

  if (travMgr->settings.aig.igrFwdBwd) {
    itpTravMgr->settings.useBwdReachAsCone = 1;
  }

  if (enStructAbstractionWithCone == 1) {
    itpTravMgr->settings.newConstrain = 0;
  }
  //  cexState = Ddi_AigNetLoadBench(ddm, "cex2", NULL);

  itpExact = 0;
  if (doInductiveToPlus > 7)
    tightenOrLoosen = 2;
  if (implAbstr > 5) {
    eqBeforeDynAbstr = 1;
    eqAfterDynAbstr = 0;
  }
  if (doInductiveToPlus && dynAbstr < 2) {
    eqBeforeDynAbstr = 1;
    eqAfterDynAbstr = 0;
  }

  if (kConeRings != NULL) {
    minConeRing = 1;
    //    minConeRing = Ddi_BddPartNum(kConeRings)/2;
  }

  if (0 && itpMgr->trRange != NULL) {
    myTrRange = Ddi_BddCompose(itpMgr->trRange, ps, nsLit);
  }

  /* Initializations */

  if (ternaryAbstr > 2)
    dynAbstr = 3;
  if (travMgr->settings.aig.selfTuningLevel == 0) {
    enDynAbstrOpt = enDynAbstrBase = 1;
  }

  if (dynAbstr == 0) {
    dynAbstr = 1;
    enDynAbstr = 0;
    enDynAbstr0 = 0;
  }

  *pAbort = 0;
  enBwdCareSimplify = itpTravMgr->careBwd != NULL
    && Ddi_BddSize(itpTravMgr->careBwd) > 2;
  if (initFwdSteps > 0) {
    freeInitStub = 1;
    Ddi_Free(itpMgr->initStubState);
    itpTravMgr->constrainVars = Ddi_VararrayAlloc(ddm, 0);
    itpTravMgr->constrainSubstLits = Ddi_BddarrayAlloc(ddm, 0);
    initStub =
      innerLoopInitFwd(travMgr, kCone, init, itpTravMgr->constrainVars,
      itpTravMgr->constrainSubstLits, initFwdSteps, NULL, itpMgr, NULL, 0, -1);
  }


  if (initStub != NULL && (itpTravMgr->settings.storeRings ||
      (itpMgr->nRings > 2))) {
    useCareFwd = 0;
  }
  if (itpTravMgr->careBwd != NULL && !Ddi_BddIsOne(itpTravMgr->careBwd)) {
    useCareFwd = 0;
  }
  if (Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectReached_c ||
    Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectTo_c) {
    useCareFwd = 0;
    printf("CF=0\n");
  }
  useCareFwd = 0;
  if (initMinterm >= 0) {
    Ddi_Varset_t *initSupp = Ddi_BddSupp(init);
    Ddi_Varset_t *forceVars = Ddi_VarsetMakeFromArray(ns);

    Ddi_VarsetDiffAcc(forceVars, initSupp);
    Ddi_Free(initSupp);
    Pdtutil_Assert(initMinterm <= 1,
      "invalid initMinterm value (0/1 allowed)");
    if (!Ddi_VarsetIsVoid(forceVars)) {
      Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(forceVars, 1);
      int j;

      fullInit = Ddi_BddDup(init);
      for (j = 0; j < Ddi_VararrayNum(vA); j++) {
        Ddi_Var_t *v = Ddi_VararrayRead(vA, j);
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, initMinterm);

        Ddi_BddAndAcc(init, lit);
        Ddi_Free(lit);
      }
      Ddi_Free(vA);
    }
    Ddi_Free(forceVars);
  }

  itpAbstrRefCurrAbstrSetup(itpMgr, kConeRings, kCone);
  itpTravMgr->stats.step = step = 0;

  if (0 && itpMgr->nRings > 3) {
    /* new handling */
    int k;

    step = itpMgr->nRings - 3;
    if (step < 0)
      step = 0;
    itpTravMgr->reached =
      Ddi_BddDup(Ddi_BddarrayRead(itpMgr->reachedRings, step));
    itpTravMgr->from = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, step));
    for (k = itpMgr->nRings - 1; k > step; k--) {
      Ddi_BddarrayRemove(itpMgr->reachedRings, k);
      Ddi_BddarrayRemove(itpMgr->fromRings, k);
    }
  } else if (1 && itpMgr->nRings > 0) {

    /* use previously saved forward rings */

    int checkInner, stopHere;
    Ddi_Bdd_t *fullBwdReached =
      itpTravMgr->careBwd != NULL ? Ddi_BddNot(itpTravMgr->careBwd) : NULL;
    Pdtutil_Assert(!Ddi_BddIsPartDisj(kCone), "invalid disj kcone");
    if (kConeRings == NULL) {
      int in2out = 1;

      if (firstIter >= 0) {
        step = firstIter;
      } else if (itpTravMgr->settings.storeRings < 2) {
        step = 0;
      } else {
        if (in2out) {
          if (itpMgr->nRings <= 1)
            step = 0;
          else {
            for (step = 1, stopHere = 0; !stopHere;) {
              Ddi_Bdd_t *ring = Ddi_BddarrayRead(itpMgr->fromRings, step);

              if (step == itpMgr->nRings - 1)
                break;
              stopHere = fullBwdReached != NULL &&
                Ddi_AigSatAnd(ring, fullBwdReached, NULL);
              stopHere = stopHere
                || Ddi_AigSatAnd(ring, kCone, itpTravMgr->careBwd);
              if (!stopHere) {
                //Ddi_BddarrayRemove(itpMgr->reachedRings,step);
                //Ddi_BddarrayRemove(itpMgr->fromRings,step);
                step++;
              }
            }
            step--;
          }
        } else {
          for (step = itpMgr->nRings - 1, checkInner = 1; checkInner;) {
            Ddi_Bdd_t *ring = Ddi_BddarrayRead(itpMgr->fromRings, step);

            if (step == 0)
              break;
            checkInner = fullBwdReached != NULL &&
              Ddi_AigSatAnd(ring, fullBwdReached, NULL);
            checkInner = checkInner
              || Ddi_AigSatAnd(ring, kCone, itpTravMgr->careBwd);
            if (checkInner) {
              //Ddi_BddarrayRemove(itpMgr->reachedRings,step);
              //Ddi_BddarrayRemove(itpMgr->fromRings,step);
              step--;
            }
          }
        }
      }

    } else if (firstIter >= 0) {
      int np = Ddi_BddPartNum(kConeRings);

      step = firstIter;
      Pdtutil_Assert(np > step, "missing part cone rings");
    } else {
      for (step = 0; step < Ddi_BddPartNum(kConeRings); step++) {
        if (Ddi_BddSize(Ddi_BddPartRead(kConeRings, step)) > 0)
          break;
      }

    }

    if (nOrInnerRings > 0 && kConeRings != NULL) {
      int np = Ddi_BddPartNum(kConeRings);

      if ((np - step) > nOrInnerRings) {
        int jj;

        for (jj = step + (np - step) / 2 + 1; jj < Ddi_BddPartNum(kConeRings);
          jj++) {
          Ddi_Bdd_t *a = Ddi_BddPartRead(kConeRings, jj - 1);
          Ddi_Bdd_t *b = Ddi_BddPartRead(kConeRings, jj);

          Ddi_BddOrAcc(b, a);
        }
      }
    }
    Ddi_Free(fullBwdReached);
    if (step > 0  && step < Ddi_BddarrayNum(itpMgr->fromRings)) {
      int jj;

#if 0
      reached = Ddi_BddarrayExtract(itpMgr->reachedRings, step);
      from = Ddi_BddarrayExtract(itpMgr->fromRings, step);
      itpMgr->nRings = step;
#else
      // reached = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->reachedRings,step));
      if (Ddi_BddarrayNum(itpMgr->reachedRings) == 0) {
        Pdtutil_Assert(Ddi_BddarrayNum(itpMgr->fromRings) > 0,
          "missing from ring");
        Ddi_Bdd_t *f0 = init;

        Ddi_BddarrayWrite(itpMgr->reachedRings, 0, f0);
      }
      itpTravMgr->reached =
        Ddi_BddDup(Ddi_BddarrayRead(itpMgr->reachedRings, 0));
      Ddi_BddSetPartDisj(itpTravMgr->reached);
      for (jj = 1; jj <= step; jj++) {
        itpTravMgr->from = Ddi_BddarrayRead(itpMgr->fromRings, jj);
        Ddi_BddPartInsertLast(itpTravMgr->reached, itpTravMgr->from);
      }
      Ddi_BddSetAig(itpTravMgr->reached);
      itpTravMgr->from = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, step));
#endif
      if (itpMgr->hints.hintsEnabled && itpMgr->hints.hintsFirst) {
	int iConstr0 = itpMgr->hints.invar0_i;
	Ddi_Var_t *cvar0Ns = Ddi_VararrayRead(itpMgr->ns,iConstr0); 
	Ddi_Bdd_t *lit1 = Ddi_BddMakeLiteralAig(cvar0Ns, 1);
	Ddi_AigAndCubeAcc(itpTravMgr->reached,lit1);
	Ddi_AigAndCubeAcc(itpTravMgr->from,lit1);
	Ddi_Free(lit1);
      }
      reuseRings = 1;
      //    itpAppr++;
    }

  }

  itpTravMgr->stats.step = step;
  if (!reuseRings) {

    /* normal case: no stored rings */

    /* init & reached state sets */

    if (initStub != NULL) {
      int i;
      Ddi_Bdd_t *newR;
      Ddi_Varset_t *rVars = NULL;

      if (itpMgr->initStubState != NULL) {
        itpTravMgr->reached = Ddi_BddDup(itpMgr->initStubState);
      } else if (dynAbstr > 5) {
        itpTravMgr->reached = Ddi_BddMakeConstAig(ddm, 0);
      } else {
        Ddi_Free(itpMgr->stubTrArray);
        itpMgr->stubTrArray = Ddi_BddarrayAlloc(ddm, 0);
        itpTravMgr->reached = Ddi_BddMakeConstAig(ddm, 1);
        for (i = 0; i < Ddi_BddarrayNum(initStub); i++) {
          Ddi_Bdd_t *nsLit_i =
            Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
          Ddi_Bdd_t *tr_i =
            Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(initStub, i));
          Ddi_BddAndAcc(itpTravMgr->reached, tr_i);
          Ddi_BddarrayInsertLast(itpMgr->stubTrArray, tr_i);
          Ddi_Free(tr_i);
          Ddi_Free(nsLit_i);
        }
        // Disabled as too expensive
        // Ddi_AigExistProjectAcc(reached,nsvars,NULL,3,0,30.0);
        Ddi_Free(itpMgr->initStubState);
        itpMgr->initStubState = Ddi_BddDup(itpTravMgr->reached);
      }
      rVars = Ddi_BddSupp(itpTravMgr->reached);
      Ddi_VarsetDiffAcc(rVars, nsvars);
      // force using init stub
      if (1 || !Ddi_VarsetIsVoid(rVars)) {
        /* avoid quantification. Prefer void initial reached */
        Ddi_Free(itpTravMgr->reached);
        itpTravMgr->reached = Ddi_BddMakeConstAig(ddm, 0);
        itpTravMgr->settings.useInitStub = 1;
        //  step--;
      }
      Ddi_Free(rVars);
      //      step++;
    } else {
      itpTravMgr->reached = Ddi_BddDup(init);
    }

    itpTravMgr->from = Ddi_BddDup(itpTravMgr->reached);
    /* forward unrolling (normally disabled) */
    if (dynAbstr > 3 || useFwdUnroll || itpExact) {
      Ddi_Vararray_t *newPiVars =
        Ddi_VararrayMakeNewVars(pi, "PDT_ITP_FWDUNR_PI", "0", 1);
      Ddi_Bddarray_t *newPiLits = Ddi_BddarrayMakeLiteralsAig(newPiVars, 1);

      itpTravMgr->fwdUnroll = Ddi_BddarrayDup(itpMgr->delta);
      Ddi_AigarrayComposeAcc(itpTravMgr->fwdUnroll, pi, newPiLits);
      if (initStub != NULL) {
        Ddi_AigarrayComposeAcc(itpTravMgr->fwdUnroll, ps, initStub);
        /* dummy const: will be replaced */
        itpTravMgr->restartFrom = Ddi_BddMakeConstAig(ddm, 1);
      } else {
        Ddi_Bdd_t *myInit = Ddi_BddCompose(init, itpMgr->ns, itpMgr->psLit);

        Ddi_AigarrayConstrainCubeAcc(itpTravMgr->fwdUnroll, myInit);
        Ddi_Free(myInit);
        itpTravMgr->restartFrom = Ddi_BddMakeConstAig(ddm, 1);
      }
      Ddi_Free(newPiVars);
      Ddi_Free(newPiLits);
    }

  }

  /* invar constraint */

  if (0 && itpMgr->invarConstr != NULL) {
    Ddi_BddNotAcc(itpMgr->invarConstr);
    Ddi_BddOrAcc(itpTravMgr->reached, itpMgr->invarConstr);
    Ddi_BddNotAcc(itpMgr->invarConstr);
  } else if (itpConstrLevel > 0) {
    /* GPC:  HERE for constraint handling !!! */
    /* handle invar space */
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");

    if (iv != NULL) {
#if 1
      /* initially cofactored to both from and reached */
      //      Ddi_BddCofactorAcc(reached,iv,1);
      //      Ddi_BddCofactorAcc(from,iv,1);
      myInvarConstr = Ddi_BddMakeLiteralAig(ivNs, 1);
#else
      /* alternative: initially added full out-of-constraint-spece */
      Ddi_Bdd_t *invarOut = Ddi_BddMakeLiteralAig(iv, 0);

      Ddi_BddOrAcc(reached, invarOut);
      //      Ddi_BddCofactorAcc(from,iv,1);
      //      Ddi_BddOrAcc(from,invarOut);
      Ddi_Free(invarOut);
#endif
    }
  }

  /* from saved for restart after abort */
  savePreviousFrom = Ddi_BddDup(itpTravMgr->from);
  itpMgr->stats.deltaSize = Ddi_BddarraySize(itpMgr->delta);
  if (enCheckReached) {
    checkReached = Ddi_BddDup(kCone);
    Ddi_BddExistProjectAcc(checkReached, nsvars);
  }

  useCareBwd = 0;
  if (itpTravMgr->careBwd != NULL) {    /* --- */
    Ddi_Bdd_t *r = Ddi_BddNot(itpTravMgr->careBwd);

    useCareBwd = !Ddi_BddIncluded(r, kCone);
    Ddi_Free(r);
  }

  Ddi_Free(itpMgr->inductiveRplusLocal);
  if (itpMgr->inductiveRplus != NULL) {
    itpMgr->inductiveRplusLocal = Ddi_BddDup(itpMgr->inductiveRplus);
  }

  step = itpImg(itpTravMgr,kCone,kConeRings,kConeOld,init,careOut,pAbort,optLevel,maxIter);

  Ddi_Free(saveFromBdd);
  if (itpMgr->inductiveRplusLocal != NULL) {
    Ddi_Bdd_t *myInit, *newRplus, *myRplus;

    myRplus = Ddi_BddDup(itpMgr->inductiveRplusLocal);
    if (itpMgr->initStubState != NULL) {
      myInit = Ddi_BddDup(itpMgr->initStubState);
    } else {
      myInit = Ddi_BddDup(init);
    }
    newRplus = InductiveImgInf(itpMgr, myRplus,
      itpMgr->inductiveRplus, itpMgr->trAux, myInit, NULL);
    Ddi_Free(myInit);
    Ddi_Free(myRplus);
    if (newRplus != NULL) {
      if (itpMgr->inductiveRplus == NULL) {
        itpMgr->inductiveRplus = Ddi_BddDup(newRplus);
      } else {
        Ddi_BddAndAcc(itpMgr->inductiveRplus, newRplus);
      }
      Ddi_Free(newRplus);
    }
  }

  if (rOut != NULL) {
    if ((*pAbort) && travMgr->settings.ints.igrSingleRewind > 0) {
      *pAbort = 0;
      Ddi_Bdd_t *r = Ddi_BddSubstVars(
        Trav_MgrReadReached(travMgr),itpMgr->ps,itpMgr->ns);
      Ddi_Bddarray_t *fromRings = itpMgr->fromRings;
      if (step == (Ddi_BddarrayNum(fromRings)-1)) {
        // last ring - add one
        Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
        Ddi_BddarrayInsertLast(fromRings,myOne);
        Ddi_Free(myOne);
      }
      while (step<Ddi_BddarrayNum(fromRings)) {
        Ddi_Bdd_t *f_step = Ddi_BddarrayRead(fromRings,step);
        if (Ddi_BddIsOne(f_step)) {
          Ddi_DataCopy(f_step,r);
          break;
        }
        step++;
      }
      if (step==Ddi_BddarrayNum(fromRings)) {
        Ddi_BddarrayInsertLast(fromRings,r);
      }
      Ddi_BddOrAcc(itpTravMgr->reached,r);
      Ddi_Free(r);
    }
    int doGfp = travMgr->settings.ints.igrSingleRewind<=0 &&
      (!(*pAbort) || itpMgr->stats.itpOutOfLimits > 0);
    doGfp &= travMgr->settings.aig.itpGfp>0;
    if (doGfp && (*pAbort)) {
      Pdtutil_Assert(itpMgr->stats.itpOutOfLimits > 0,
		     "out of limits required here");
      int lastGfpRing = travMgr->settings.ints.igrFpRing;
      step--;
      if (lastGfpRing<0) doGfp=0;
      else {
	if (lastGfpRing>step) {
	  step = lastGfpRing;
	}
	int last = Ddi_BddarrayNum(itpMgr->fromRings)-1;
	while (last>step) {
	  Ddi_BddarrayRemove(itpMgr->fromRings,last);
	  last--;
	}
	Ddi_Bdd_t *r = Trav_MgrReadReached(travMgr);
	Ddi_Bdd_t *fpR = NULL;
        if (r != NULL) {
          fpR = Ddi_BddSubstVars(r,itpMgr->ps,itpMgr->ns);
          Ddi_Free(itpTravMgr->reached);
        }
        else {
          fpR = Ddi_BddMakeConstAig(ddm, 1);
        }
        itpTravMgr->reached = Ddi_BddDup(fpR);
	Ddi_BddarrayInsertLast(itpMgr->fromRings,fpR);
	step++;
	Ddi_Free(fpR);
      }
    }
    if (doGfp) {
      int nIter = travMgr->settings.aig.itpGfp;
      int lastRing = step;
      for (int i=0; i<nIter; i++) {
	int size0 = Ddi_BddSize(itpTravMgr->reached);
        int ret = itpStrengthenReachedGfp(itpTravMgr, &lastRing,
					  1&&(i<nIter-1),0,0,0);
	if (!ret) break;
	if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
	  printf("GFP reached reduction iter %d: %d -> %d\n",
		 i, size0,
		 Ddi_BddSize(itpTravMgr->reached));
	}
      }
      travMgr->settings.ints.igrFpRing = lastRing;
      travMgr->settings.ints.igrRingLast = itpMgr->lastRingId = lastRing;
    }
    Ddi_DataCopy(rOut, itpTravMgr->reached);
  }

  if (0 && itpMgr->nRings > 2) {
    int jj;

    for (jj = 2; jj < itpMgr->nRings && jj < step; jj++) {
      Ddi_Bdd_t *from1 = Ddi_BddarrayRead(itpMgr->fromRings, jj);
      Ddi_Bdd_t *from0 = Ddi_BddarrayRead(itpMgr->fromRings, jj - 1);
      Ddi_Bdd_t *reached1 = Ddi_BddarrayRead(itpMgr->reachedRings, jj);
      Ddi_Bdd_t *reached0 = Ddi_BddarrayRead(itpMgr->reachedRings, jj - 1);

      if (itpConstrLevel > 1 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(from0, myInvarConstr);
      }
      Ddi_Bdd_t *f0AndTr = Ddi_BddCompose(from0, ns, psLit);

      Ddi_BddAndAcc(f0AndTr, itpMgr->trAux);
      if (itpTravMgr->settings.useInvarFull && itpMgr->invarConstr != NULL) {
        Ddi_BddAndAcc(f0AndTr, itpMgr->invarConstr);
      }
      if (itpConstrLevel > 1 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(f0AndTr, myInvarConstr);
      }
      Pdtutil_Assert(Ddi_BddIncluded(reached0, reached1), "wrong ring R");
      Pdtutil_Assert(Ddi_BddIncluded(from1, reached1), "wrong ring F");
      Pdtutil_Assert(Ddi_BddIncluded(f0AndTr, reached1), "wrong ring IMG");
      Ddi_Free(f0AndTr);
    }
  }

  if (!(*pAbort) && !enFpChk) {
    Pdtutil_Assert(pAbort != NULL, "abort flag required");
    *pAbort = -1;
    unsoundProof = 1;
  }

  if (!(*pAbort) && itpTravMgr->settings.checkCompleteness) {
    int checkProp = itpTravMgr->settings.checkCompleteness;
    Ddi_Bdd_t *chkTr = Ddi_BddDup(itpMgr->trAux);
    Ddi_Bdd_t *chk = Ddi_BddDup(itpTravMgr->reached);
    Ddi_Bdd_t *chk0 = Ddi_BddDup(itpTravMgr->reached);
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ispecv = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Checking ITP completeness ...")
      );
    if (itpTravMgr->careBwd != NULL) {
      Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
    }
    Ddi_BddComposeAcc(chk, ns, psLit);
    Ddi_BddComposeAcc(chk0, ns, psLit);
    Ddi_BddAndAcc(chk, chkTr);
    Ddi_Free(chkTr);
    if (fullInit != NULL) {
      if (!Ddi_BddIncluded(fullInit, itpTravMgr->reached)) {
        printf("FULL init state is not included in reached\n");
      }
    }

    if (iv != NULL) {
      Ddi_Bdd_t *extraInvar = Ddi_BddMakeLiteralAig(iv, 1);

      Ddi_BddComposeAcc(extraInvar, ps, itpMgr->delta);
      Ddi_BddAndAcc(chk, extraInvar);
      Ddi_BddAndAcc(chk0, extraInvar);
      Ddi_Free(extraInvar);
    }
    if (itpMgr->invarConstr != NULL) {
      Ddi_BddAndAcc(chk, itpMgr->invarConstr);
    }
    if (1 && Trav_MgrReadAssume(travMgr) != NULL) {
      Ddi_BddAndAcc(chk, Trav_MgrReadAssume(travMgr));
    }
    if (0 && itpTravMgr->careBwd != NULL) {
      Ddi_BddNotAcc(itpTravMgr->careBwd);
      Pdtutil_Assert(!Ddi_AigSatAnd(chk, itpTravMgr->careBwd, NULL),
        "Completeness problem - Missed Failure");
      Ddi_BddNotAcc(itpTravMgr->careBwd);
      Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
    }

    if (checkProp) {
      Ddi_Bdd_t *chk2 = Ddi_BddCofactor(chk, ispecv, 0);

      Ddi_BddCofactorAcc(chk2, iv, 1);
      if (Ddi_AigSat(chk2)) {
        if (checkProp == 1) {
          Pdtutil_Assert(0, "Soundness problem - R hits target");
        } else {
          Pdtutil_Assert(pAbort != NULL, "abort flag required");
          unsoundProof = 0;
          if (1) {
            int j;
            int safe = Trav_ItpMgrReadConeBoundOK(itpMgr,step);
            int done=0;
            for (j=1; j<=safe && !done; j++) {
              Ddi_Bdd_t *chkCone = Ddi_BddDup(itpMgr->target);
              Ddi_BddWriteMark (chkCone, 0);
              Ddi_BddComposeAcc(chkCone, ps, nsLit);
              Ddi_Bdd_t *chkCone0 = Ddi_BddDup(chkCone);
              growConeBwd(itpMgr, chkCone, j, 1, NULL,
                          NULL, 
                          0, -1, 0 /*boundK */ );
              growConeBwd(itpMgr, chkCone0, j, 0, NULL,
                          itpMgr->initStub, 
                          0, -1, 0 /*boundK */ );
              int res = Ddi_AigSatAnd(chkCone,
                                      itpTravMgr->reached,0);
              if (res) {
                printf("reached is hitting cone of bound %d\n", j);
                int res0 = Ddi_AigSatAnd(chkCone0,itpMgr->init,0);
                if (res0)
                  unsoundProof = 1;
                else {
                  printf("BMC ok for bound %d\n", j);
                }
              }
              else {
                done = 1;
                printf("reached is safe for bound %d\n", j);
              }
              Ddi_Free(chkCone);
              Ddi_Free(chkCone0);
            }
          }

        }
      }
      if (unsoundProof) {
        *pAbort = -1;
      }
      else {
	int checkRetimedProp = 0;
	Ddi_Free(chk2);
	chk2 = Ddi_BddDup(chk0);
	if (checkRetimedProp) {
	  Ddi_Bdd_t *retimedTarget = Ddi_BddMakeLiteralAig(ispecv, 0);
	  Ddi_BddComposeAcc(retimedTarget, ps, itpMgr->delta);
	  Ddi_BddAndAcc(chk2,retimedTarget);
	  Ddi_Free(retimedTarget);
	  if (Ddi_AigSat(chk2)) {
	    Pdtutil_Assert(0, "Soundness problem - R hits target");
	  }
	}
      }
      Ddi_Free(chk2);
    }

    Ddi_BddDiffAcc(chk, itpTravMgr->reached);
    if (1 && myInvarConstr != NULL) {
      Ddi_AigAndCubeAcc(chk, myInvarConstr);
    }
    if (0 && Ddi_AigSat(chk)) {
      Ddi_Bdd_t *cex = Ddi_AigSatWithCex(chk);

      Ddi_BddExistProjectAcc(cex, nsvars);
      Ddi_AigNetStore(cex, "cex-bench", NULL, Pdtutil_Aig2BenchName_c);
    }
    Pdtutil_Assert(!Ddi_AigSat(chk),
      "Completeness problem - Underappr R at f.p.");
    Ddi_Free(chk);
    Ddi_Free(chk0);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), " done\n")
      );
  }
  // if (estimateR>2 ) { this condition always computes the # of r. states
  if (estimateR > 2 && *pAbort == 0) {
    int nv = Ddi_VararrayNum(itpMgr->ps);
    int over = 0;

    if (nv > 1000) {
      over = 1000 * (nv / 1000);
      nv = nv % 1000;
    }
    if (estimateR > 3) {
      Ddi_Bdd_t *r = Ddi_BddMakeMono(itpTravMgr->reached);

      fprintf(stdout, "#R exact States = %E\n", Ddi_BddCountMinterm(r, nv));
      if (over > 0) {
	fprintf(stdout, "exact multiplied by 10^%.2f (2^%d)\n", (float)(over/3.321928),over);
      }
      Ddi_Free(r);
    }

    fprintf(stdout, "#R States (estimated) = %LE\n",Ddi_AigEstimateMintermCount(itpTravMgr->reached, nv));
    /* long double tmp = Ddi_AigEstimateMintermCount(itpTravMgr->reached, nv); */
    if (over > 0) {
      fprintf(stdout, "estimated multiplied by 10^%.2f (2^%d)\n", (float)(over/3.321928),over);
    }
  }

  Ddi_Free(fullInit);
  if (storeReached != NULL) {
    Ddi_Var_t *vp = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");
    Ddi_Var_t *vc = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");

    Ddi_BddSwapVarsAcc(itpTravMgr->reached, itpMgr->ps, itpMgr->ns);
    Ddi_BddCofactorAcc(itpTravMgr->reached, vp, 1);
    Ddi_BddCofactorAcc(itpTravMgr->reached, vc, 1);
    if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
      printf("Writing itp reached to %s\n", storeReached);
    }
    Ddi_AigNetStore(itpTravMgr->reached, storeReached,
      NULL, Pdtutil_Aig2BenchName_c);
    char ringsfile[1000];
    strcpy(ringsfile, storeReached);
    char *s = strstr(ringsfile,".aig");
    if (s==NULL) {
      strcat(ringsfile,"_rings");
    }
    else {
      sprintf(s,"%s", "_rings.aig");
    }
    Ddi_Bddarray_t *rings = Ddi_BddarraySubstVars(itpMgr->fromRings,
                                        itpMgr->ns,itpMgr->ps);
    if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
      printf("Writing itp fromRings to %s\n",ringsfile);
    }
    Ddi_AigarrayNetStore(rings, ringsfile, NULL,
      Pdtutil_Aig2BenchName_c);
    Ddi_Free(rings);
  }

  if (checkReached != NULL) {
    if (bReached != NULL) {
      Ddi_Bdd_t *chk = Ddi_BddDiff(bReached, checkReached);

      Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
      Pdtutil_Assert(!Ddi_AigSat(chk), "overappr-br");
      Ddi_Free(chk);
    }
    Ddi_Free(checkReached);
  }
  if (bReached != NULL) {
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "ADDING CARE STATES: %d+%d -> ",
        Ddi_BddSize(itpTravMgr->careBwd), Ddi_BddSize(bReached))
      );
    Ddi_BddDiffAcc(itpTravMgr->careBwd, bReached);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "%d.\n", Ddi_BddSize(itpTravMgr->careBwd))
      );
    Ddi_Free(bReached);
  }

  itpTravMgrFree(itpTravMgr);
  if (freeInitStub) {
    Ddi_Free(initStub);
  }
  Ddi_Free(myTrRange);
  Ddi_Free(itpTravMgr->saveConstrainVars);
  Ddi_Free(itpTravMgr->saveConstrainSubstLits);
  Ddi_Free(myInvarConstr);
  Ddi_Free(savePreviousFrom);
  Ddi_Free(ternarySmooth);
  Ddi_Free(itpTravMgr->reached);
  Ddi_Free(reached1);
  Ddi_Free(itpTravMgr->from);
  Ddi_Free(nsvars);
  Ddi_Free(psvars);
  Ddi_Free(itpTravMgr->constrainVars);
  Ddi_Free(itpTravMgr->constrainSubstLits);
//  Ddi_MgrCheckExtRef(ddm,extRef+2);
  return (step - 1);
  /* END INTERPOLANT INNER LOOP */
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
interpolantInnerLoop0(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Ddi_Bdd_t * kCone,
  Ddi_Bdd_t * kConeOld,
  Ddi_Bdd_t * kConeRings,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * careBwd,
  Ddi_Bdd_t * careBwdBdd,
  Ddi_Bdd_t * rOut,
  Ddi_Bdd_t * careOut,
  Ddi_Bddarray_t * kConeOldAuxLits,
  Trav_ItpMgr_t * itpMgr,
  int *pAbort,
  int optLevel,
  int firstIter,
  int maxIter,
  unsigned long time_limit
)
{
  /* INTERPOLANT INNER LOOP */

  Ddi_Bddarray_t *initStub = itpMgr->initStub;
  Ddi_Vararray_t *pi = itpMgr->pi;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Bddarray_t *psLit = itpMgr->psLit;
  Ddi_Bddarray_t *nsLit = itpMgr->nsLit;
  Ddi_Vararray_t *dynAbstrAux = itpMgr->dynAbstrAux;
  Ddi_Vararray_t *dynAbstrCut = itpMgr->dynAbstrCut;
  Ddi_Bddarray_t *dynAbstrCutLits = itpMgr->dynAbstrCutLits;
  unsigned char *enAbstr = itpMgr->enAbstr;
  Ddi_Vararray_t *abstrRefCtrl = itpMgr->abstrRefCtrl;
  Ddi_Bddarray_t *abstrDoAbstr = itpMgr->abstrDoAbstr;
  Ddi_Bddarray_t *abstrDoRefine = itpMgr->abstrDoRefine;
  Ddi_Varset_t *ternarySmooth = NULL;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(kCone);
  int extRef = Ddi_MgrReadExtRef(ddm);
  Ddi_Varset_t *nsvars = Ddi_VarsetMakeFromArray(ns);
  Ddi_Varset_t *psvars = Ddi_VarsetMakeFromArray(ps);
  Ddi_Bdd_t *savePreviousFrom = NULL;
  Ddi_Bdd_t *bReached = NULL, *checkReached = NULL, *fromBdd = NULL,
    *saveFromBdd = NULL;
  Trav_ItpTravMgr_t *itpTravMgr = NULL;
  int step = 0, sat;
  int enCheckReached = 0;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int dynAbstr = Trav_MgrReadDynAbstr(travMgr);
  int ternaryAbstr = Trav_MgrReadTernaryAbstr(travMgr);
  int implAbstr = Trav_MgrReadImplAbstr(travMgr);
  int abstrWithCone = 0;
  int abstrRef = Trav_MgrReadAbstrRef(travMgr) % 100;
  int abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  int redRem = Ddi_MgrReadAigRedRemLevel(ddm);
  int abcOpt = Ddi_MgrReadAigAbcOptLevel(ddm);
  int useAbstrTr = 0;
  int again;
  int optReachedThresh = 10000;
  int optFromThresh = 5000;
  int optToThresh = 5000;
  int abortedTo = 0;
  int enDynAbstrOpt = /*dynAbstr==3 || */ dynAbstr > 5 || ternaryAbstr > 0;
  int enDynAbstrBase = dynAbstr > 0;
  int maxFailBddFwd = 1;
  int enBwdCareSimplify = 1;
  int itpOpt = itpMgr->itpOpt;
  int useCareBwd;
  int enToPlusImage = Trav_MgrReadItpEnToPlusImg(travMgr);
  int itpPart = Trav_MgrReadItpPart(travMgr);
  int itpPartTh = Ddi_MgrReadAigItpPartTh(ddm);
  int enItpBdd = Trav_MgrReadItpBdd(travMgr);
  int itpAppr = Trav_MgrReadItpAppr(travMgr);
  int unsoundProof = 0;
  int useFwdUnroll = 0;
  float itpTimeLimit = -1.0;
  int useTimedItp = 1 || itpMgr->boundkOptPis != NULL;
  int enDynAbstr = 1, enDynAbstr0 = 1, maxNoAbstr0 = 2, maxNoAbstr = 2;
  int enToPlusCubeSat = implAbstr > 1;
  char *storeReached = NULL;    //"ITP-RP";

  // char *storeReached="ITP-RP";
  Ddi_Bdd_t *myInvarConstr = NULL;
  int doFirstPass = 0;
  int minConeRing = 0;
  static int nFreeVars = 0;
  int doInductiveToPlus = Trav_MgrReadItpInductiveTo(travMgr);
  int initAbstr = Trav_MgrReadItpInitAbstr(travMgr);
  int minDynAbstrStep = Trav_MgrReadDynAbstrInitIter(travMgr);
  int imgApprEn = 400;
  int eqBeforeDynAbstr = 0;
  int eqAfterDynAbstr = 1;
  int tightenOrLoosen = (doInductiveToPlus > 6);
  int refineToPlus = 1 || (itpAppr > 1 || doInductiveToPlus > 7);
  int useTrRange = 0;
  Ddi_Bdd_t *myTrRange = NULL;
  int growCone = abs(Trav_MgrReadIgrGrowCone(travMgr));
  int enRewind = travMgr->settings.aig.igrRewind
    && Trav_MgrReadIgrGrowCone(travMgr) >= 0;
  Trav_Shared_t *travPdrShared = NULL, *travShared = NULL;
  int itpExact = Trav_MgrReadItpExact(travMgr);
  int freeInitStub = 0;
  int initFwdSteps = itpExact;
  int incompleteTrav = 0;
  int itpConstrLevel = Trav_MgrReadItpConstrLevel(travMgr);
  int useNewFwd = travMgr->settings.aig.itpNew;
  int useCareFwd = 1 || Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c
    || Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectCofactor_c;
  int maxTernary = 2;
  int estimateR = travMgr->settings.bdd.countReached;
  Ddi_Bdd_t *reached1 = NULL;
  int reuseRings = 0;
  int itpGenMaxIter = Trav_MgrReadItpGenMaxIter(travMgr);
  Ddi_Bdd_t *cexState = NULL;
  int cegarAbstrRef = 0;
  int initMinterm = -1;
  Ddi_Bdd_t *fullInit = NULL;
  int nOrInnerRings = 0;
  int enStructAbstractionWithCone = travMgr->settings.aig.itpStructAbstr;
  int implAbstrInitIter = 0;
  int doMonotoneGen = 0;
  int monotoneRedRemTh = 0;     //20000;

  int doAbstrStoredTo = 1;
  int enItpAbort = 0, enItpSeq = 0, prevToSize = -1;
  int rpmTh = travMgr->settings.aig.itpRpm;
  int chkSupp = 1;
  int chkRings = 0;
  int enFpChk = 1;
  Ddi_Bdd_t *l1, *l2;
  int reImgOnWeakening=1, suspendWeakening=0;

  if (abstrRef == 3) {
    abstrRef = 2;
  }

  if (implAbstr == 2) {
    implAbstr++;
    abstrWithCone = 1;
  }

  itpTravMgr = itpTravMgrInit(travMgr, itpMgr);
  if (careBwd != NULL) {
    itpTravMgr->careBwd = Ddi_BddDup(careBwd);
  }

  if (initAbstr < 0) {
    implAbstrInitIter = initAbstr = -initAbstr;
  }

  if (enStructAbstractionWithCone == 1) {
    itpTravMgr->settings.newConstrain = 0;
  }
  //  cexState = Ddi_AigNetLoadBench(ddm, "cex2", NULL);

  itpExact = 0;
  if (doInductiveToPlus > 7)
    tightenOrLoosen = 2;
  if (implAbstr > 5) {
    eqBeforeDynAbstr = 1;
    eqAfterDynAbstr = 0;
  }
  if (doInductiveToPlus && dynAbstr < 2) {
    eqBeforeDynAbstr = 1;
    eqAfterDynAbstr = 0;
  }

  if (kConeRings != NULL) {
    minConeRing = 1;
    //    minConeRing = Ddi_BddPartNum(kConeRings)/2;
  }

  if (0 && itpMgr->trRange != NULL) {
    myTrRange = Ddi_BddCompose(itpMgr->trRange, ps, nsLit);
  }

  /* Initializations */

  if (ternaryAbstr > 2)
    dynAbstr = 3;
  if (travMgr->settings.aig.selfTuningLevel == 0) {
    enDynAbstrOpt = enDynAbstrBase = 1;
  }

  if (dynAbstr == 0) {
    dynAbstr = 1;
    enDynAbstr = 0;
    enDynAbstr0 = 0;
  }

  *pAbort = 0;
  enBwdCareSimplify = itpTravMgr->careBwd != NULL
    && Ddi_BddSize(itpTravMgr->careBwd) > 2;
  if (initFwdSteps > 0) {
    freeInitStub = 1;
    Ddi_Free(itpMgr->initStubState);
    itpTravMgr->constrainVars = Ddi_VararrayAlloc(ddm, 0);
    itpTravMgr->constrainSubstLits = Ddi_BddarrayAlloc(ddm, 0);
    initStub =
      innerLoopInitFwd(travMgr, kCone, init, itpTravMgr->constrainVars,
      itpTravMgr->constrainSubstLits, initFwdSteps, NULL, itpMgr, NULL, 0, -1);
  }


  if (initStub != NULL && (itpTravMgr->settings.storeRings ||
      (itpMgr->nRings > 2))) {
    useCareFwd = 0;
  }
  if (itpTravMgr->careBwd != NULL && !Ddi_BddIsOne(itpTravMgr->careBwd)) {
    useCareFwd = 0;
  }
  if (Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectReached_c ||
    Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectTo_c) {
    useCareFwd = 0;
    printf("CF=0\n");
  }
  useCareFwd = 0;
  if (initMinterm >= 0) {
    Ddi_Varset_t *initSupp = Ddi_BddSupp(init);
    Ddi_Varset_t *forceVars = Ddi_VarsetMakeFromArray(ns);

    Ddi_VarsetDiffAcc(forceVars, initSupp);
    Ddi_Free(initSupp);
    Pdtutil_Assert(initMinterm <= 1,
      "invalid initMinterm value (0/1 allowed)");
    if (!Ddi_VarsetIsVoid(forceVars)) {
      Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(forceVars, 1);
      int j;

      fullInit = Ddi_BddDup(init);
      for (j = 0; j < Ddi_VararrayNum(vA); j++) {
        Ddi_Var_t *v = Ddi_VararrayRead(vA, j);
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(v, initMinterm);

        Ddi_BddAndAcc(init, lit);
        Ddi_Free(lit);
      }
      Ddi_Free(vA);
    }
    Ddi_Free(forceVars);
  }

  itpAbstrRefCurrAbstrSetup(itpMgr, kConeRings, kCone);
  itpTravMgr->stats.step = step = 0;
  if (0 && itpMgr->nRings > 3) {
    /* new handling */
    int k;

    step = itpMgr->nRings - 3;
    if (step < 0)
      step = 0;
    itpTravMgr->reached =
      Ddi_BddDup(Ddi_BddarrayRead(itpMgr->reachedRings, step));
    itpTravMgr->from = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, step));
    for (k = itpMgr->nRings - 1; k > step; k--) {
      Ddi_BddarrayRemove(itpMgr->reachedRings, k);
      Ddi_BddarrayRemove(itpMgr->fromRings, k);
    }
  } else if (1 && itpMgr->nRings > 0) {

    /* use previously saved forward rings */

    int checkInner, stopHere;
    Ddi_Bdd_t *fullBwdReached =
      itpTravMgr->careBwd != NULL ? Ddi_BddNot(itpTravMgr->careBwd) : NULL;
    Pdtutil_Assert(!Ddi_BddIsPartDisj(kCone), "invalid disj kcone");
    if (kConeRings == NULL) {
      int in2out = 1;

      if (firstIter >= 0) {
        step = firstIter;
      } else if (itpTravMgr->settings.storeRings < 2) {
        step = 0;
      } else {
        if (in2out) {
          if (itpMgr->nRings <= 1)
            step = 0;
          else {
            for (step = 1, stopHere = 0; !stopHere;) {
              Ddi_Bdd_t *ring = Ddi_BddarrayRead(itpMgr->fromRings, step);

              if (step == itpMgr->nRings - 1)
                break;
              stopHere = fullBwdReached != NULL &&
                Ddi_AigSatAnd(ring, fullBwdReached, NULL);
              stopHere = stopHere
                || Ddi_AigSatAnd(ring, kCone, itpTravMgr->careBwd);
              if (!stopHere) {
                //Ddi_BddarrayRemove(itpMgr->reachedRings,step);
                //Ddi_BddarrayRemove(itpMgr->fromRings,step);
                step++;
              }
            }
            step--;
          }
        } else {
          for (step = itpMgr->nRings - 1, checkInner = 1; checkInner;) {
            Ddi_Bdd_t *ring = Ddi_BddarrayRead(itpMgr->fromRings, step);

            if (step == 0)
              break;
            checkInner = fullBwdReached != NULL &&
              Ddi_AigSatAnd(ring, fullBwdReached, NULL);
            checkInner = checkInner
              || Ddi_AigSatAnd(ring, kCone, itpTravMgr->careBwd);
            if (checkInner) {
              //Ddi_BddarrayRemove(itpMgr->reachedRings,step);
              //Ddi_BddarrayRemove(itpMgr->fromRings,step);
              step--;
            }
          }
        }
      }

    } else if (firstIter >= 0) {
      int np = Ddi_BddPartNum(kConeRings);

      step = firstIter;
      Pdtutil_Assert(np > step, "missing part cone rings");
    } else {
      for (step = 0; step < Ddi_BddPartNum(kConeRings); step++) {
        if (Ddi_BddSize(Ddi_BddPartRead(kConeRings, step)) > 0)
          break;
      }

    }

    if (nOrInnerRings > 0 && kConeRings != NULL) {
      int np = Ddi_BddPartNum(kConeRings);

      if ((np - step) > nOrInnerRings) {
        int jj;

        for (jj = step + (np - step) / 2 + 1; jj < Ddi_BddPartNum(kConeRings);
          jj++) {
          Ddi_Bdd_t *a = Ddi_BddPartRead(kConeRings, jj - 1);
          Ddi_Bdd_t *b = Ddi_BddPartRead(kConeRings, jj);

          Ddi_BddOrAcc(b, a);
        }
      }
    }
    Ddi_Free(fullBwdReached);
    if (step > 0) {
      int jj;

#if 0
      reached = Ddi_BddarrayExtract(itpMgr->reachedRings, step);
      from = Ddi_BddarrayExtract(itpMgr->fromRings, step);
      itpMgr->nRings = step;
#else
      // reached = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->reachedRings,step));
      if (Ddi_BddarrayNum(itpMgr->reachedRings) == 0) {
        Pdtutil_Assert(Ddi_BddarrayNum(itpMgr->fromRings) > 0,
          "missing from ring");
        Ddi_Bdd_t *f0 = init;

        Ddi_BddarrayWrite(itpMgr->reachedRings, 0, f0);
      }
      itpTravMgr->reached =
        Ddi_BddDup(Ddi_BddarrayRead(itpMgr->reachedRings, 0));
      Ddi_BddSetPartDisj(itpTravMgr->reached);
      for (jj = 1; jj <= step; jj++) {
        itpTravMgr->from = Ddi_BddarrayRead(itpMgr->fromRings, jj);
        Ddi_BddPartInsertLast(itpTravMgr->reached, itpTravMgr->from);
      }
      Ddi_BddSetAig(itpTravMgr->reached);
      itpTravMgr->from = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, step));
#endif
      reuseRings = 1;
      //    itpAppr++;
    }
#if 0
    if (itpMgr->eqRings != NULL && step > 1) {
      if (constrainVars == NULL) {
        Ddi_Bdd_t *eqConstr = Ddi_BddarrayRead(itpMgr->eqRings, step - 1);  // ???
        Ddi_Vararray_t *vars = Ddi_BddReadEqVars(eqConstr);
        Ddi_Bddarray_t *subst = Ddi_BddReadEqSubst(eqConstr);

        constrainVars = Ddi_VararrayDup(vars);
        constrainSubstLits = Ddi_BddarrayDup(subst);
      }
    }
#endif

  }

  itpTravMgr->stats.step = step;
  if (!reuseRings) {

    /* normal case: no stored rings */

    /* init & reached state sets */

    if (initStub != NULL) {
      int i;
      Ddi_Bdd_t *newR;
      Ddi_Varset_t *rVars = NULL;

      if (itpMgr->initStubState != NULL) {
        itpTravMgr->reached = Ddi_BddDup(itpMgr->initStubState);
      } else if (dynAbstr > 5) {
        itpTravMgr->reached = Ddi_BddMakeConstAig(ddm, 0);
      } else {
        Ddi_Free(itpMgr->stubTrArray);
        itpMgr->stubTrArray = Ddi_BddarrayAlloc(ddm, 0);
        itpTravMgr->reached = Ddi_BddMakeConstAig(ddm, 1);
        for (i = 0; i < Ddi_BddarrayNum(initStub); i++) {
          Ddi_Bdd_t *nsLit_i =
            Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
          Ddi_Bdd_t *tr_i =
            Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(initStub, i));
          Ddi_BddAndAcc(itpTravMgr->reached, tr_i);
          Ddi_BddarrayInsertLast(itpMgr->stubTrArray, tr_i);
          Ddi_Free(tr_i);
          Ddi_Free(nsLit_i);
        }
        // Disabled as too expensive
        // Ddi_AigExistProjectAcc(reached,nsvars,NULL,3,0,30.0);
        Ddi_Free(itpMgr->initStubState);
        itpMgr->initStubState = Ddi_BddDup(itpTravMgr->reached);
      }
      rVars = Ddi_BddSupp(itpTravMgr->reached);
      Ddi_VarsetDiffAcc(rVars, nsvars);
      // force using init stub
      if (1 || !Ddi_VarsetIsVoid(rVars)) {
        /* avoid quantification. Prefer void initial reached */
        Ddi_Free(itpTravMgr->reached);
        itpTravMgr->reached = Ddi_BddMakeConstAig(ddm, 0);
        itpTravMgr->settings.useInitStub = 1;
        //  step--;
      }
      Ddi_Free(rVars);
      //      step++;
    } else {
      itpTravMgr->reached = Ddi_BddDup(init);
    }

    itpTravMgr->from = Ddi_BddDup(itpTravMgr->reached);
    /* forward unrolling (normally disabled) */
    if (dynAbstr > 3 || useFwdUnroll || itpExact) {
      Ddi_Vararray_t *newPiVars =
        Ddi_VararrayMakeNewVars(pi, "PDT_ITP_FWDUNR_PI", "0", 1);
      Ddi_Bddarray_t *newPiLits = Ddi_BddarrayMakeLiteralsAig(newPiVars, 1);

      itpTravMgr->fwdUnroll = Ddi_BddarrayDup(itpMgr->delta);
      Ddi_AigarrayComposeAcc(itpTravMgr->fwdUnroll, pi, newPiLits);
      if (initStub != NULL) {
        Ddi_AigarrayComposeAcc(itpTravMgr->fwdUnroll, ps, initStub);
        /* dummy const: will be replaced */
        itpTravMgr->restartFrom = Ddi_BddMakeConstAig(ddm, 1);
      } else {
        Ddi_Bdd_t *myInit = Ddi_BddCompose(init, itpMgr->ns, itpMgr->psLit);

        Ddi_AigarrayConstrainCubeAcc(itpTravMgr->fwdUnroll, myInit);
        Ddi_Free(myInit);
        itpTravMgr->restartFrom = Ddi_BddMakeConstAig(ddm, 1);
      }
      Ddi_Free(newPiVars);
      Ddi_Free(newPiLits);
    }

  }

  /* invar constraint */

  if (0 && itpMgr->invarConstr != NULL) {
    Ddi_BddNotAcc(itpMgr->invarConstr);
    Ddi_BddOrAcc(itpTravMgr->reached, itpMgr->invarConstr);
    Ddi_BddNotAcc(itpMgr->invarConstr);
  } else if (itpConstrLevel > 0) {
    /* GPC:  HERE for constraint handling !!! */
    /* handle invar space */
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ivNs = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$NS");

    if (iv != NULL) {
#if 1
      /* initially cofactored to both from and reached */
      //      Ddi_BddCofactorAcc(reached,iv,1);
      //      Ddi_BddCofactorAcc(from,iv,1);
      myInvarConstr = Ddi_BddMakeLiteralAig(ivNs, 1);
#else
      /* alternative: initially added full out-of-constraint-spece */
      Ddi_Bdd_t *invarOut = Ddi_BddMakeLiteralAig(iv, 0);

      Ddi_BddOrAcc(reached, invarOut);
      //      Ddi_BddCofactorAcc(from,iv,1);
      //      Ddi_BddOrAcc(from,invarOut);
      Ddi_Free(invarOut);
#endif
    }
  }

  /* from saved for restart after abort */
  savePreviousFrom = Ddi_BddDup(itpTravMgr->from);
  itpMgr->stats.deltaSize = Ddi_BddarraySize(itpMgr->delta);
  if (enCheckReached) {
    checkReached = Ddi_BddDup(kCone);
    Ddi_BddExistProjectAcc(checkReached, nsvars);
  }

  useCareBwd = 0;
  if (itpTravMgr->careBwd != NULL) {    /* --- */
    Ddi_Bdd_t *r = Ddi_BddNot(itpTravMgr->careBwd);

    useCareBwd = !Ddi_BddIncluded(r, kCone);
    Ddi_Free(r);
  }

  Ddi_Free(itpMgr->inductiveRplusLocal);
  if (itpMgr->inductiveRplus != NULL) {
    itpMgr->inductiveRplusLocal = Ddi_BddDup(itpMgr->inductiveRplus);
  }

  /* THIS IS THE TRAVERSAL LOOP !!! */

  do {
    int sizeAig;
    Ddi_Bdd_t *prevTo = NULL, *newFwd = NULL, *toMinusTot = NULL;
    Ddi_Bdd_t *fpCheck, *badCheck;
    Ddi_Bdd_t *localCone = NULL, *careCone = NULL, *toPlus = NULL,
      *toPlusCube = NULL, *itpCare = NULL, *itpFullCare = NULL;
    Ddi_Varset_t *abstrVars = NULL;
    Ddi_Bddarray_t *implArray = NULL;
    int chkInnerCone = 1, useApproxToPlus = 0;
    int nImgVars = 0;
    int toBddInCareBdd = 0;
    Tr_Tr_t *trBdd2 = NULL;
    Ddi_Bdd_t *inductiveTo = NULL, *inductiveTo2 = NULL,
      *myCareBwd = Ddi_BddDup(itpTravMgr->careBwd);
    int undoCex = 0;
    int enGeneralizedItp = 0;
    int itpDone = 0;
    static int nIter = 0;

    enFpChk = !(growCone && itpTravMgr->stats.coneHit)
      || itpMgr->abstrRefNnf;
    nIter++;
    //    || travMgr->settings.aig.igrMaxExact>10000;
    /* itpTravMgr->careBwd comes fro upper level routines: and with from if
       necessary */
    //    Ddi_MgrConsistencyCheck (ddm);
    if (itpMgr->inductiveRplusLocal != NULL) {
      Ddi_BddAndAcc(myCareBwd, itpMgr->inductiveRplusLocal);
    }

    if (travMgr->settings.aig.pdrShareReached ||
      travMgr->settings.aig.itpShareReached) {
      travShared = &(travMgr->xchg.shared);
      travPdrShared = travShared->sharedLink;
    }

    if (itpTravMgr->from == NULL) {
      if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        printf("  Aig interpolant inner iteration %d: (from=NULL) -> ", step);
        fflush(tMgrO(travMgr));
      }
    } else {

      /* this is the normal case */

      if (0 && (itpGenMaxIter >= 0)) {
        Ddi_Free(itpTravMgr->constrainVars);
        Ddi_Free(itpTravMgr->constrainSubstLits);
        itpTravMgr->constrainVars = Ddi_VararrayAlloc(ddm, 0);
        itpTravMgr->constrainSubstLits = Ddi_BddarrayAlloc(ddm, 0);
      }

      if (itpTravMgr->settings.useInitStub) {
        Ddi_Free(itpTravMgr->from);
        Ddi_Free(savePreviousFrom);
        itpTravMgr->from = Ddi_BddMakeConstAig(ddm, 1);
      }

      if (itpTravMgr->settings.storeRings) {

        int doRingWeakening = travMgr->settings.aig.itpWeaken;

        if (step == 0) {
          Ddi_BddarrayWrite(itpMgr->reachedRings, step, itpTravMgr->reached);
        }
        Ddi_BddarrayWrite(itpMgr->fromRings, step, itpTravMgr->from);
        itpMgr->nRings = Ddi_BddarrayNum(itpMgr->fromRings);
        if (0 && itpConstrLevel > 1 && myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(Ddi_BddarrayRead(itpMgr->reachedRings, step),
            myInvarConstr);
          Ddi_AigAndCubeAcc(Ddi_BddarrayRead(itpMgr->fromRings, step),
            myInvarConstr);
        }
        if (itpMgr->eqRings != NULL) {
          if (itpTravMgr->constrainVars != NULL) {
            Ddi_Bdd_t *myConstr = Ddi_BddMakeEq(itpTravMgr->constrainVars,
              itpTravMgr->constrainSubstLits);

            Ddi_BddarrayWrite(itpMgr->eqRings, step, myConstr);
            if (chkRings) {
              Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->from, myConstr),
                "eq inclusion problem in from rings");
            }
            Ddi_Free(myConstr);
          }
        }
        if (chkRings && step > 1) {
          Ddi_Bdd_t *bck = Ddi_BddNot(itpTravMgr->from);
          Ddi_Bdd_t *constr = NULL;

          if (itpMgr->invarConstr != NULL) {
            constr =
              Ddi_BddSubstVars(itpMgr->invarConstr, itpMgr->ps, itpMgr->ns);
            Ddi_BddAndAcc(bck, constr);
          }
          Ddi_BddComposeAcc(bck, itpMgr->ns, itpMgr->delta);
          Ddi_BddSubstVarsAcc(bck, itpMgr->ps, itpMgr->ns);
          Pdtutil_Assert(!Ddi_AigSatAnd(Ddi_BddarrayRead(itpMgr->fromRings,
                step - 1), bck, constr), "img problem in from rings");
          Ddi_Free(bck);
          Ddi_Free(constr);
        }
        if (step > 0 && chkRings
          && (step + 1) < Ddi_BddarrayNum(itpMgr->fromRings)) {
          Ddi_Bdd_t *bck =
            Ddi_BddNot(Ddi_BddarrayRead(itpMgr->fromRings, step + 1));
          Ddi_BddComposeAcc(bck, itpMgr->ns, itpMgr->delta);
          Ddi_BddSubstVarsAcc(bck, itpMgr->ps, itpMgr->ns);
          if (Ddi_AigSatAnd(itpTravMgr->from, bck, NULL)) {
            Ddi_Bdd_t *bck0 =
              Ddi_BddNot(Ddi_BddarrayRead(itpMgr->fromRings, step + 1));
            Ddi_BddComposeAcc(bck0, itpMgr->ns, itpMgr->delta0);
            Ddi_BddSubstVarsAcc(bck0, itpMgr->ps, itpMgr->ns);
            int j;

            for (j = 0; j < Ddi_BddarrayNum(itpMgr->delta); j++) {
              Ddi_Bdd_t *d = Ddi_BddarrayRead(itpMgr->delta, j);
              Ddi_Bdd_t *d0 = Ddi_BddarrayRead(itpMgr->delta0, j);

              if (!Ddi_BddIncluded(d, d0)) {
                printf("abstr delta inclusion problem [%d] size %d - %d\n",
                  j, Ddi_BddSize(d), Ddi_BddSize(d0));
              }
            }

            Pdtutil_Assert(!Ddi_AigSatAnd(itpTravMgr->from, bck0, NULL),
              "img problem in from rings");
            Ddi_Free(bck0);
          }
          Pdtutil_Assert(!Ddi_AigSatAnd(itpTravMgr->from, bck, NULL),
            "img problem in from rings");
          Ddi_Free(bck);
        }
        if (itpTravMgr->toItpSeq != NULL) {
          int jj;

          for (jj = 0; jj < Ddi_BddarrayNum(itpTravMgr->toItpSeq); jj++) {
            Ddi_Bdd_t *r_s_jj = NULL;
            Ddi_Bdd_t *itp_jj = Ddi_BddarrayRead(itpTravMgr->toItpSeq, jj);

            if (Ddi_BddarrayNum(itpMgr->fromRings) > step + jj + 1) {
              r_s_jj = Ddi_BddarrayRead(itpMgr->fromRings, step + jj + 1);
              Ddi_BddAndAcc(itp_jj, r_s_jj);
            }
            Ddi_BddarrayWrite(itpMgr->fromRings, step + jj + 1, itp_jj);
          }
          //      Ddi_Free(itpTravMgr->toItpSeq);
          itpMgr->nRings = Ddi_BddarrayNum(itpMgr->fromRings);
          step += Ddi_BddarrayNum(itpTravMgr->toItpSeq) + 1;
	  itpMgr->igr.sameConeFail = -1;
        }

	if (suspendWeakening) {
	  suspendWeakening = 0;
	}
        else if (doRingWeakening > 1 && step > 2 && itpTravMgr->toItpSeq == NULL
          && (Ddi_BddSize(itpTravMgr->from) > doRingWeakening)) {
          int jj, r0;

          Ddi_Free(itpTravMgr->from);
          itpSimplifyRingsBwdFwd(itpMgr, step, 2, itpMgr->delta, -1, 1, NULL, 0);
          if (Ddi_BddSize(Ddi_BddarrayRead(itpMgr->fromRings, step)) >
            2 * doRingWeakening) {
            itpSimplifyRingsBwdFwd(itpMgr, step, 2, itpMgr->delta, -1, 1, NULL, 0);
          }
	  if (reImgOnWeakening) {
	    step--;
            suspendWeakening = 1;
	  }
          itpTravMgr->from =
            Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, step));
          Ddi_Free(itpTravMgr->reached);
          if (Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectReached_c) {
            itpTravMgr->reached = Ddi_BddDup(itpTravMgr->from);
          } else {
            r0 = step - 2;
            if (r0 >= Ddi_BddarrayNum(itpMgr->reachedRings)) {
              r0 = Ddi_BddarrayNum(itpMgr->reachedRings) - 1;
            }
            itpTravMgr->reached =
              Ddi_BddDup(Ddi_BddarrayRead(itpMgr->reachedRings, r0));
            for (jj = r0 + 1; jj <= step; jj++) {
              Ddi_BddOrAcc(itpTravMgr->reached,
                Ddi_BddarrayRead(itpMgr->fromRings, jj));
              Ddi_BddSetAig(itpTravMgr->reached);
              Ddi_BddarrayWrite(itpMgr->reachedRings, jj, itpTravMgr->reached);
            }
          }

          if (savePreviousFrom != NULL) {
            Ddi_Free(savePreviousFrom);
            savePreviousFrom = Ddi_BddDup(itpTravMgr->from);
          }
        }

      }

      if (itpTravMgr->toItpSeq != NULL) {
        *pAbort = 1;
        again = 0;
        Ddi_Free(itpTravMgr->toItpSeq);
        break;
      }

      if (1 && !dynAbstr && optLevel > 0 &&
        itpTravMgr->careFwd != NULL && (0
          && (Ddi_BddSize(itpTravMgr->careFwd) <
            Ddi_BddSize(itpTravMgr->from))) || (itpTravMgr->careFwd != NULL
          && Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c)) {
        Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->careFwd);
      }

      itpTravMgr->to = NULL;
      if (doInductiveToPlus) {
        if (step >= ((initAbstr > 2) ? 2 : initAbstr)) {
          inductiveTo = Ddi_BddDup(itpTravMgr->from);
        }
      }

      if (0 && !Ddi_BddIsOne(itpTravMgr->from)) {
        prevTo = Ddi_BddDup(itpTravMgr->from);
        //Pdtutil_Assert(!Ddi_AigSatAnd(prevTo,kCone,NULL),"wrong prev itp");
      }

      Ddi_Free(itpTravMgr->careFwd);
      if (useCareFwd) {
        //
        if (itpTravMgr->settings.storeRings) {
          if (itpMgr->nRings > 0) {
            itpTravMgr->careFwd =
              Ddi_BddNot(Ddi_BddarrayRead(itpMgr->fromRings, 0));
          } else {
            itpTravMgr->careFwd = Ddi_BddMakeConstAig(ddm, 1);
          }
        } else {
          itpTravMgr->careFwd = Ddi_BddNot(itpTravMgr->from);
        }
      } else {
        itpTravMgr->careFwd = Ddi_BddMakeConstAig(ddm, 1);
      }

      if (itpTravMgr->careBwd != NULL
        && !Ddi_BddIncluded(itpTravMgr->from, itpTravMgr->careBwd)) {
        Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->careBwd);   /* @@@@ first iteration */
      }
      // Pdtutil_Assert(!Ddi_AigSatAnd(from,kCone,careBwd),
      //         "WRONG initial FROM\n");
      Ddi_BddComposeAcc(itpTravMgr->from, itpMgr->ns, itpMgr->psLit);
      if (chkSupp) {
        Ddi_Varset_t *fSupp = Ddi_BddSupp(itpTravMgr->from);

        Ddi_VarsetDiffAcc(fSupp, psvars);
        Pdtutil_Assert(Ddi_VarsetIsVoid(fSupp), "non state var in from");
        Ddi_Free(fSupp);
      }
      // printf("FROM*TR-AUX = %d\n", Ddi_AigSatAnd(from,kCone,itpMgr->trAux));

      if (1 && Trav_MgrReadAssume(travMgr) != NULL) {
        Ddi_BddAndAcc(itpTravMgr->from, Trav_MgrReadAssume(travMgr));
      }

      if (0 && itpMgr->invarConstr != NULL) {
        Ddi_BddOrAcc(itpTravMgr->from, itpMgr->invarConstr);
      } else if (0) {
        Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");

        if (iv != NULL) {
          Ddi_Bdd_t *invarIn = Ddi_BddMakeLiteralAig(iv, 1);

          Ddi_BddAndAcc(itpTravMgr->from, invarIn);
          Ddi_Free(invarIn);
        }
      }

      if (itpTravMgr->constrainVars != NULL) {
        int i, j, n = Ddi_VararrayNum(itpTravMgr->constrainVars);

        Ddi_AigarrayComposeAcc(itpTravMgr->constrainSubstLits,
          itpMgr->ns, itpMgr->psLit);
        /* GpC: this is because we miss a subst function for vararrays */
        for (i = 0; i < n; i++) {
          Ddi_Var_t *v_i = Ddi_VararrayRead(itpTravMgr->constrainVars, i);

          for (j = 0; j < Ddi_VararrayNum(ns); j++) {
            if (Ddi_VararrayRead(ns, j) == v_i) {
              Ddi_VararrayWrite(itpTravMgr->constrainVars, i,
                Ddi_VararrayRead(ps, j));
            }
          }
        }
      }

      /* take the from set */

      //      useTrRange=step>2;

      if (useTrRange) {
        Pdtutil_Assert(!Ddi_BddIsPartConj(itpTravMgr->from)
          && !itpTravMgr->settings.useInitStub, "wrong from format");
        Ddi_BddAndAcc(itpTravMgr->from, itpMgr->trRange);
      }

      if (Ddi_BddIsPartConj(itpTravMgr->from)) {
        /* BDDs used */
        itpTravMgr->from0 = Ddi_BddDup(Ddi_BddPartRead(itpTravMgr->from, 0));
        Ddi_BddAndAcc(itpTravMgr->from0, Ddi_BddPartRead(itpTravMgr->from, 1));
      } else {
        itpTravMgr->from0 = Ddi_BddDup(itpTravMgr->from);
      }

      /* prepare transition relation */

      localCone = itpImgGetCone(itpTravMgr, kCone, kConeRings, NULL, 
				step, 0, 0, 0, 0, -1, 0);

      if (abstrWithCone) {
        if (localCone == NULL || Ddi_BddIsZero(localCone)) {
          localCone =
            itpImgGetCone(itpTravMgr, kCone, kConeRings, NULL, 
			  step + 1, 1, 0, 0, 0, -1, 0);
          itpImgTrSetup(itpTravMgr, localCone);
          Ddi_Free(localCone);
        } else {
          itpImgTrSetup(itpTravMgr, localCone);
        }
      } else {
        itpImgTrSetup(itpTravMgr, NULL);
      }

      sizeAig = Ddi_BddSize(itpTravMgr->trAux);
      // printf("FROM*TR = %d\n", Ddi_AigSatAnd(from,kCone,careBwd));
      /* start checks */
      if (itpOutOfLimits(itpMgr)) {
        /* abort for time limit */
        Ddi_Free(itpTravMgr->from0);
        Ddi_Free(myCareBwd);
        step++;
        itpTravMgr->settings.checkCompleteness = 0;
        *pAbort = 1;
        break;
      }
      if (!toBddInCareBdd) {
        Ddi_Bdd_t *fromConstrained = Ddi_BddDup(itpTravMgr->from);

        if (myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(fromConstrained, myInvarConstr);
        }
        if (itpMgr->invarConstr != NULL) {
          Ddi_BddAndAcc(fromConstrained, itpMgr->invarConstr);
        }
        if (!Ddi_BddIncluded(fromConstrained, itpTravMgr->careBwd)) {
          /* traversal hits back cone through careBwd */
          if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
            printf("Inner loop REACHES back cone (chk 0)\n");
            fflush(tMgrO(travMgr));
          }
          Ddi_Free(fromConstrained);
          Ddi_Free(toMinusTot);
          Ddi_Free(itpTravMgr->from0);
          Ddi_Free(myCareBwd);
          step++;
          itpTravMgr->settings.checkCompleteness = 0;
          *pAbort = 1;
          break;
        }
        Ddi_Free(fromConstrained);
      }
      /* fix point check: exact image in reached ? */

      if (enFpChk) {
        long chkTime0, chkTime1;

        fpCheck = Ddi_BddDiff(itpTravMgr->from, itpTravMgr->reached);
        chkTime0 = util_cpu_time();

        if (0 && !useTrRange && itpMgr->trRange != NULL) {
          Ddi_BddAndAcc(fpCheck, itpMgr->trRange);
        }
        useTrRange = 0;
        if (0 && itpTravMgr->careBwd != NULL) {
          Ddi_BddAndAcc(fpCheck, itpTravMgr->careBwd);
        }
        if (myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(fpCheck, myInvarConstr);
        }
        if (itpTravMgr->settings.enConcurTr && !Ddi_AigSat(fpCheck)) {
          /* fix point reached */
          itpTravMgr->settings.enConcurTr = 0;
          Ddi_Free(fpCheck);
          fpCheck = Ddi_BddNot(itpTravMgr->reached);
          Ddi_BddComposeAcc(itpTravMgr->from, itpMgr->ns, itpMgr->psLit);
          Ddi_BddDiffAcc(itpTravMgr->from, itpMgr->concurStall);
          Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->trAux);
          Ddi_BddAndAcc(fpCheck, itpTravMgr->from);
          Ddi_Free(inductiveTo);
          Ddi_Free(itpTravMgr->to);
        }
        if (!Ddi_AigSat(fpCheck)) {
          if (step == 0)
            step++;             /* correct fp on init state !! */
          Ddi_Free(itpTravMgr->from0);
          Ddi_Free(fpCheck);
          Ddi_Free(itpTravMgr->trArray);
          Ddi_Free(itpTravMgr->trAux);
          Ddi_Free(inductiveTo);
          Ddi_Free(itpTravMgr->careFwd);
          Ddi_Free(prevTo);
          Ddi_Free(newFwd);
          Ddi_Free(itpTravMgr->to);
          Ddi_Free(myCareBwd);
          if (fullInit != NULL) {
            incompleteTrav = 1;
            Ddi_BddOrAcc(itpTravMgr->reached, fullInit);
            Ddi_Free(fullInit);
          }
          if (incompleteTrav) {
            Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c,
              fprintf(stdout,
                "FWD ITP INCOMPLETE fix-point - restarting from reached\n"));
            incompleteTrav = 0;
            itpTravMgr->from = Ddi_BddDup(itpTravMgr->reached);
            continue;
          }
          Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelNone_c, fprintf(stdout,
              "FWD ITP fix-point at depth %d\n", step));
          break;
        }
        Ddi_Free(fpCheck);

        chkTime1 = util_cpu_time();

        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        printf("fp chkTime: %s\n", util_print_time(chkTime1-chkTime0));
        fflush(tMgrO(travMgr));
      }

      }

      Ddi_Free(itpTravMgr->trAux);

      if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        printf("  Aig interpolant inner iteration %d: |from:%d| ->  ",
               step, Ddi_BddSize(itpTravMgr->from));
        fflush(tMgrO(travMgr));
      }
    }

    step++;
    if (chkRings && step > 1 && itpMgr->fromRings != NULL &&
      Ddi_BddarrayNum(itpMgr->fromRings) > step) {
      Ddi_Bdd_t *ring = Ddi_BddarrayRead(itpMgr->fromRings, step);

      Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->from, ring),
        "img problem in from rings");
    }

    if (optLevel >= 0 && Ddi_BddSize(itpTravMgr->reached) > optReachedThresh) {
      int mySize;
      int growthFactor = 2;
      int rrp = Ddi_MgrReadAigRedRemMaxCnt(ddm);

      if (itpExact)
        growthFactor *= 2;
      if (enBwdCareSimplify) {
        Ddi_BddAndAcc(itpTravMgr->reached, itpTravMgr->careBwd);
      }
      if (0 && step > 3 && itpTravMgr->careBwd != NULL
        && Ddi_BddSize(itpTravMgr->careBwd) > 100 && optReachedThresh < 10000)
        Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, 1);
      DdiAigRedRemovalAcc(itpTravMgr->reached, itpTravMgr->careBwd, -1,
        travMgr->settings.aig.lazyTimeLimit);
      Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, rrp);
      mySize = Ddi_BddSize(itpTravMgr->reached);
      if (mySize * growthFactor > optReachedThresh) {
        optReachedThresh = mySize * growthFactor;
        //      optReachedThresh *= 2;
      }
    }

    if (0 && (itpGenMaxIter > 0)) {
      int res;
      Ddi_Bdd_t *itpGen;
      int nState = Ddi_VararrayNum(ps);
      Ddi_Vararray_t *glbA;
      Ddi_Bdd_t *fromTot = Ddi_BddAnd(itpTravMgr->from, itpTravMgr->careFwd);
      Ddi_Varset_t *glbVars = Ddi_BddSupp(fromTot);
      int maxIter = itpGenMaxIter;

      if (itpConstrLevel > 1 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(fromTot, myInvarConstr);
      }

      Ddi_VarsetIntersectAcc(glbVars, nsvars);
      glbA = Ddi_VararrayMakeFromVarset(glbVars, 1);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "|to-GENeralization:%d|.\n",
          Ddi_BddSize(fromTot))
        );
      itpGen =
        Ddi_AigInterpolantByGenClauses(fromTot, kCone, myCareBwd, NULL, ps,
        ns, NULL, glbA, NULL, NULL, NULL, maxIter, 0, &res);
      Ddi_Free(glbA);
      Ddi_Free(glbVars);
      Ddi_Free(fromTot);
      if (res > 0) {
        itpTravMgr->to = itpGen;
        itpGen = NULL;
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "|to-GEN:%d|\n", Ddi_BddSize(itpTravMgr->to))
          );
        if (1) {
          Ddi_Bdd_t *chk = Ddi_BddDiff(itpTravMgr->from, itpTravMgr->to);

          Ddi_BddAndAcc(chk, itpTravMgr->careFwd);
          if (itpConstrLevel > 1 && myInvarConstr != NULL) {
            Ddi_AigAndCubeAcc(chk, myInvarConstr);
          }
          Pdtutil_Assert(!Ddi_AigSat(chk), "to minus problem");
          Ddi_Free(chk);
          Pdtutil_Assert(!Ddi_AigSatAnd(itpTravMgr->to, kCone, NULL),
            "to minus problem");
        }
      } else if (res == 0) {
        /* partial */
        toMinusTot = itpGen;
        Pdtutil_Assert(!Ddi_AigSatAnd(toMinusTot, kCone, NULL),
          "to minus problem");
        itpGen = NULL;
        Ddi_BddDiffAcc(itpTravMgr->careFwd, toMinusTot);
        if (0 && itpConstrLevel > 1 && myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(toMinusTot, myInvarConstr);
        }
      }
      Ddi_Free(itpGen);
    }

    if (0 && (itpMgr->invarConstr != NULL)) {
      Ddi_Bdd_t *invarConstrNs =
        Ddi_BddCompose(itpMgr->invarConstr, ns, psLit);
      Ddi_BddAndAcc(itpTravMgr->careFwd, invarConstrNs);
      Ddi_Free(invarConstrNs);
    }
#if 0
    if (0) {
      int i, update = 0, n = Ddi_VararrayNum(ps);

      again = 1;
      for (i = 0; i < n; i++) {
        int changed = 0;
        Ddi_Var_t *v = Ddi_VararrayRead(ns, i);
        Ddi_Bdd_t *d_i = Ddi_BddCofactor(Ddi_BddarrayRead(trArray, i), v, 1);
        Ddi_Bdd_t *implied = DdiAigImpliedVarsAcc(d_i, from0, NULL);

        if (implied != NULL) {
          Ddi_BddAndAcc(d_i, implied);
          Ddi_Free(implied);
          changed = update = 1;
        }
        Ddi_BddNotAcc(d_i);
        implied = DdiAigImpliedVarsAcc(d_i, from, NULL);
        if (implied != NULL) {
          Ddi_BddAndAcc(d_i, implied);
          Ddi_Free(implied);
          changed = update = 1;
        }
        if (changed) {
          Ddi_Bdd_t *vLit = Ddi_BddMakeLiteralAig(v, 1);

          Ddi_BddNotAcc(d_i);
          Ddi_BddXnorAcc(d_i, vLit);
          Ddi_BddarrayWrite(trArray, i, d_i);
          Ddi_Free(vLit);
        }
        Ddi_Free(d_i);
        Ddi_Free(implied);
      }
      if (update) {
        int size0 = Ddi_BddSize(from);

        Ddi_Free(from);
        from = Ddi_BddMakeConstAig(ddm, 1);
        for (i = 0; i < n; i++) {
          Ddi_BddAndAcc(from, Ddi_BddarrayRead(trArray, i));
        }
        if (newConstrain) {
          Ddi_AigConstrainOptAcc(from, from0, psvars, NULL, NULL, 2);
        } else {
          Ddi_BddAndAcc(from, from0);
        }
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "new from after impl red %d->%d.\n",
            size0, Ddi_BddSize(from))
          );
      }
    }
#endif

    if (useFwdUnroll && itpTravMgr->from != NULL) {
      sat = Ddi_AigSatAnd(itpTravMgr->from, kCone, itpTravMgr->careBwd);
      if (sat) {
        Ddi_Free(itpTravMgr->from);
      }
    }

    if (((dynAbstr && enDynAbstrBase || useFwdUnroll) &&
        (itpTravMgr->from != NULL || abortedTo)) && itpTravMgr->to == NULL) {
      int j;
      int nState = Ddi_VararrayNum(ns);

      if (dynAbstr > 3 && enDynAbstrOpt || useFwdUnroll) {

        /* use restart info */
        if (ternarySmooth == NULL) {
          ternarySmooth = Ddi_VarsetVoid(ddm);
        }
        Ddi_Free(itpTravMgr->from);
        Ddi_Free(itpTravMgr->from0);
        Pdtutil_Assert(itpTravMgr->restartFrom != NULL, "NULL restartFrom");
        Ddi_BddSetAig(itpTravMgr->restartFrom);
        itpTravMgr->from0 = Ddi_BddDup(itpTravMgr->restartFrom);
        itpTravMgr->from = Ddi_BddDup(itpTravMgr->restartFrom);
        Pdtutil_Assert(itpTravMgr->fwdUnroll != NULL, "NULL fwd unroll");
        Ddi_Free(itpTravMgr->trArray);
        itpTravMgr->trArray = Ddi_BddarrayDup(itpTravMgr->fwdUnroll);
        for (j = 0; j < nState; j++) {
          Ddi_Bdd_t *nsLit_j = Ddi_BddarrayRead(itpMgr->nsLit, j);

          Ddi_BddXnorAcc(Ddi_BddarrayRead(itpTravMgr->trArray, j), nsLit_j);
          Ddi_BddAndAcc(itpTravMgr->from,
            Ddi_BddarrayRead(itpTravMgr->trArray, j));
        }
        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("DYN-ABSTR: |new from|=%d\n", Ddi_BddSize(itpTravMgr->from));
        }
        if (travMgr->settings.aig.selfTuningLevel == 0 && ternarySmooth) {
          DdiAigExistOverAcc(itpTravMgr->from, ternarySmooth, NULL);
          if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
            printf("DYN-ABSTR: |new from after 3-ary sm|=%d\n",
              Ddi_BddSize(itpTravMgr->from));
          }
        }
      }

    }

    careCone = Ddi_BddDup(kCone);
    if (itpConstrLevel > 1 && myInvarConstr != NULL) {
      Ddi_AigAndCubeAcc(itpTravMgr->from, myInvarConstr);
    }

    if (itpTravMgr->to == NULL && itpTravMgr->from != NULL &&
      itpTravMgr->careBwd != NULL) {
      Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->from,
          itpTravMgr->careBwd), "wrong inclusion check");
      /* this is probably redundant as already checked */
      //      Ddi_Free(from);
      //      from = localCone = NULL;
    }

    Ddi_Free(itpTravMgr->constrainVars);
    Ddi_Free(itpTravMgr->constrainSubstLits);
    itpTravMgr->constrainVars = Ddi_VararrayAlloc(ddm, 0);
    itpTravMgr->constrainSubstLits = Ddi_BddarrayAlloc(ddm, 0);
    if (1 && itpTravMgr->settings.storeRings && (itpMgr->nRings > step)) {
      Ddi_Bdd_t *toPlus = Ddi_BddarrayRead(itpMgr->fromRings, step);

      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "|to+(stored):%d|.\n", Ddi_BddSize(toPlus))
        );
      if (0 && inductiveTo != NULL
        && Ddi_BddarrayNum(itpMgr->fromRings) > step + 1) {
        inductiveTo2 =
          Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings, step + 1));
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "|extra-ind-cand:%d|.\n",
            Ddi_BddSize(inductiveTo2))
          );
      }
    }

    if (itpTravMgr->to == NULL && implAbstr > 1 && step >= implAbstrInitIter) {
      /* tightening by implied vars */
      Ddi_Bdd_t *ternaryToPlus = NULL;
      Ddi_Bdd_t *myFrom = NULL;
      Ddi_Bdd_t *ternaryFrom = NULL;
      Ddi_Varset_t *ternaryVars;
      int nCube;

      if (itpExact) {
        /* use forward unroll */
        int j;
        int nState = Ddi_VararrayNum(ns);
        Ddi_Bdd_t *myFrom = Ddi_BddMakeConstAig(ddm, 1);

        for (j = 0; j < nState; j++) {
          Ddi_Bdd_t *tr_j = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->nsLit, j));

          Ddi_BddXnorAcc(tr_j, Ddi_BddarrayRead(itpTravMgr->fwdUnroll, j));
          Ddi_BddAndAcc(myFrom, tr_j);
          Ddi_Free(tr_j);
        }
      } else {
        myFrom = Ddi_BddDup(itpTravMgr->from);
      }

      ternaryVars = Ddi_BddSupp(myFrom);
      if (Ddi_VarsetIsArray(ternaryVars)) {
        Ddi_VarsetSetArray(nsvars);
      }
      if (Ddi_VarsetIsArray(nsvars)) {
        Ddi_VarsetSetArray(ternaryVars);
      }
      Ddi_VarsetDiffAcc(ternaryVars, nsvars);
      ternaryFrom = Ddi_BddDup(myFrom);
      DdiAigExistOverAcc(ternaryFrom, ternaryVars, NULL);
      ternaryToPlus =
        DdiAigImpliedVarsAcc(ternaryFrom, itpTravMgr->careFwd, nsvars);
      Ddi_Free(ternaryVars);
      Ddi_Free(ternaryFrom);
      if (ternaryToPlus != NULL) {
        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("ternary to+: %d\n", Ddi_BddSize(ternaryToPlus));
        }
        Ddi_AigConstrainCubeAcc(myFrom, ternaryToPlus);
        Ddi_AigConstrainCubeAcc(itpTravMgr->careFwd, ternaryToPlus);    /* @@@ */
      }

      if (enToPlusCubeSat && (0 || (minDynAbstrStep < 0 && step < 4)
          || step <= (minDynAbstrStep + 3))) {
        toPlusCube = DdiAigImpliedVarsAcc(myFrom, itpTravMgr->careFwd, nsvars);
      }
      if (toPlusCube == NULL) {
        toPlusCube = Ddi_BddMakeConstAig(ddm, 1);
      }
      if (ternaryToPlus != NULL) {
        Ddi_BddAndAcc(toPlusCube, ternaryToPlus);
        Ddi_Free(ternaryToPlus);
      }
      Ddi_Free(myFrom);
      nCube = Ddi_BddSize(toPlusCube);
      if (nCube == 0) {
        Ddi_Free(toPlusCube);
      } else {
        int sizeF = Ddi_BddSize(itpTravMgr->from);

        if (itpTravMgr->careFwd != NULL && !Ddi_BddIsOne(itpTravMgr->careFwd)) {
          Ddi_Bddarray_t *t2 = Ddi_BddarrayDup(itpTravMgr->trArray);
          Ddi_Bdd_t *trConstr = NULL;
          int j;

          for (j = 0; j < Ddi_VararrayNum(ns); j++) {
            Ddi_BddCofactorAcc(Ddi_BddarrayRead(t2, j),
              Ddi_VararrayRead(ns, j), 1);
          }
          trConstr = Ddi_BddCompose(toPlusCube, ns, t2);
          Ddi_BddAndAcc(itpTravMgr->from0, trConstr);
          Ddi_Free(trConstr);
          Ddi_Free(t2);
          Ddi_AigConstrainCubeAcc(itpTravMgr->careFwd, toPlusCube);
        }
        Ddi_AigConstrainCubeAcc(itpTravMgr->from, toPlusCube);
        Ddi_AigConstrainCubeAcc(myCareBwd, toPlusCube);
        nCube = nCube / 2 + 1;
        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("TO+IMG-cube: %d (f:%d->%d)\n",
            nCube, sizeF, Ddi_BddSize(itpTravMgr->from));
        }
      }

      // DdiAigEquivVarsAcc(from,NULL);

      if (implAbstr > 5 && eqBeforeDynAbstr) {
        Ddi_Vararray_t *constrainVarsPs = Ddi_VararrayAlloc(ddm, 0);
        Ddi_Bddarray_t *constrainSubstLitsPs = Ddi_BddarrayAlloc(ddm, 0);
        Ddi_Bdd_t *eq;
        Ddi_Varset_t *pipsvars = Ddi_VarsetMakeFromArray(pi);

        Ddi_VarsetUnionAcc(pipsvars, psvars);
        eq =
          DdiAigEquivVarsAcc(itpTravMgr->from, itpTravMgr->careFwd, NULL,
          pipsvars, NULL, constrainVarsPs, constrainSubstLitsPs);
        if (eq != NULL) {
          Ddi_BddComposeAcc(itpTravMgr->from, constrainVarsPs,
            constrainSubstLitsPs);
          Ddi_BddComposeAcc(itpTravMgr->from0, constrainVarsPs,
            constrainSubstLitsPs);
          Ddi_BddarrayComposeAcc(itpTravMgr->trArray, constrainVarsPs,
            constrainSubstLitsPs);
          Ddi_Free(eq);
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "PIPS EQ found\n")
            );
        }

        Ddi_Free(pipsvars);
        Ddi_Free(constrainVarsPs);
        Ddi_Free(constrainSubstLitsPs);
      }
      if (implAbstr > 2 && eqBeforeDynAbstr && step >= implAbstrInitIter) {
        Ddi_Bdd_t *eq;

        eq = DdiAigEquivVarsAcc(itpTravMgr->from, itpTravMgr->careFwd,
          NULL, nsvars, localCone,
          itpTravMgr->constrainVars, itpTravMgr->constrainSubstLits);
        if (eq != NULL) {
          Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from);
          int nsm;

          if (toPlus == NULL) {
            toPlus = Ddi_BddDup(eq);
          } else {
            Ddi_BddAndAcc(toPlus, eq);
          }

          if (itpTravMgr->careFwd != NULL
            && !Ddi_BddIsOne(itpTravMgr->careFwd)) {
            Ddi_Bddarray_t *t2 = Ddi_BddarrayDup(itpTravMgr->trArray);
            Ddi_Bdd_t *trConstr = NULL;
            int j;

            for (j = 0; j < Ddi_VararrayNum(ns); j++) {
              Ddi_BddCofactorAcc(Ddi_BddarrayRead(t2, j),
                Ddi_VararrayRead(ns, j), 1);
            }
            trConstr = Ddi_BddCompose(eq, ns, t2);
            Ddi_BddAndAcc(itpTravMgr->from0, trConstr);
            Ddi_Free(trConstr);
            Ddi_Free(t2);
          }
          //      if (careFwd != NULL) Ddi_BddAndAcc(toPlus,careFwd);
          if (Ddi_VarsetIsArray(nsvars)) {
            Ddi_VarsetSetArray(sm);
          }
          Ddi_VarsetDiffAcc(sm, nsvars);
          if (Ddi_VarsetNum(sm) < 4) {
            itpTravMgr->to =
              Ddi_BddExistProject(itpTravMgr->from, itpMgr->nsvars);
            sat = 0;
          }
          Ddi_Free(sm);
        }
        Ddi_Free(eq);
      }
      if (0 && itpTravMgr->to == NULL && itpTravMgr->settings.implAbstr > 5) {
        Ddi_Bdd_t *eq;

        implArray = Ddi_BddarrayAlloc(ddm, 0);
        itpTravMgr->to = DdiAigImplicationsAcc(itpTravMgr->from,
          NULL, NULL, nsvars, implArray);
        if (0) {
          Ddi_Bdd_t *chk = Ddi_BddDiff(itpTravMgr->from, itpTravMgr->to);

          Pdtutil_Assert(!Ddi_AigSat(chk), "wrong implication img+");
          Ddi_Free(chk);
        }
        eq = Ddi_BddAnd(itpTravMgr->to, localCone);
        if (Ddi_AigSat(eq)) {
          if (!Ddi_BddIsOne(itpTravMgr->to)) {
            Ddi_AigConstrainImplAcc(localCone, implArray);
            Ddi_BddAndAcc(localCone, itpTravMgr->to);
            if (toPlus == NULL) {
              toPlus = Ddi_BddDup(itpTravMgr->to);
            } else {
              Ddi_BddAndAcc(toPlus, itpTravMgr->to);
            }
          }
          Ddi_Free(itpTravMgr->to);
        } else {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMin_c,
            fprintf(tMgrO(travMgr), "FOUND IMPL INTERPOLANT\n"));
          sat = 0;
        }
        Ddi_Free(eq);
      }
    }

    if (itpTravMgr->to == NULL && (kConeOld != NULL)) {
      localCone = Ddi_BddMakeConstAig(ddm, 0);
      if (kConeOld != NULL) {
        Ddi_BddOrAcc(localCone, kConeOld);
      }
      if (useCareBwd) {         /* --- */
        Ddi_Bdd_t *r = Ddi_BddNot(itpTravMgr->careBwd);

        Ddi_BddOrAcc(localCone, r);
        Ddi_Free(r);
      }
      if (itpTravMgr->from != NULL && !Ddi_BddIsZero(localCone)
        && Ddi_AigSat(localCone)) {
        Ddi_Bdd_t *from1;

        // ??????? DYNABSTR
        if (toPlusCube != NULL) {
          int sizeC = Ddi_BddSize(localCone);

          Ddi_AigConstrainCubeAcc(localCone, toPlusCube);
          if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
            printf("TO+IMG-cube: (c0:%d->%d)\n", sizeC,
              Ddi_BddSize(localCone));
          }
        }
        if (itpTravMgr->constrainVars != NULL &&
          Ddi_VararrayNum(itpTravMgr->constrainVars) > 0) {
          Ddi_BddComposeAcc(localCone, itpTravMgr->constrainVars,
            itpTravMgr->constrainSubstLits);
        }

        if (!Ddi_AigSatAnd(localCone, myCareBwd, NULL)) {
          from1 = Ddi_BddMakeConstAig(ddm, 1);
        } else {
          from1 = Ddi_BddDup(itpTravMgr->from);
        }
        sat = -1;
        if (enDynAbstr0 && (minDynAbstrStep >= 0 && step > minDynAbstrStep)
          && optLevel > 1 /* >= 1 */  && dynAbstr) {

          int nAbstr;

          if (0 && Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c) {
            Ddi_BddDiffAcc(localCone, itpTravMgr->reached);
          }
          abstrVars =
            interpolantDynAbstrFrom(from1, itpTravMgr->from0, localCone,
            /* NULL *//*myCareBwd */ toPlus, itpMgr->invarConstr,
	    ns, nsvars, NULL,dynAbstrCut, dynAbstrAux, dynAbstrCutLits,
            itpTravMgr->trArray, enAbstr, NULL, 0, &nAbstr);
          if (nAbstr == 0) {
            if (--maxNoAbstr0 <= 0) {
              enDynAbstr0 = 0;
            }
          }
          if (abstrVars == NULL) {
            //      toPlus = NULL;
            sat = 1;
          } else if (step > 4 && !Ddi_BddIsOne(from1) && ternaryAbstr > 0) {
            Ddi_Varset_t *mySmooth = Ddi_VarsetVoid(ddm);
            int doTernary, totN;
            Ddi_Varset_t *sm = Ddi_BddSupp(from1);

            Ddi_VarsetIntersectAcc(sm, nsvars);
            totN = Ddi_VarsetNum(sm);
            Ddi_Free(sm);
            if (totN > 20) {

              Ddi_VarsetSetArray(mySmooth);
              interpolantTernaryAbstr(travMgr, from1, localCone, NULL,
                nsvars, NULL, mySmooth, dynAbstr, enDynAbstrOpt, 1);
              if (ternarySmooth != NULL) {
                Ddi_VarsetSetArray(ternarySmooth);
                Ddi_VarsetUnionAcc(ternarySmooth, mySmooth);
              }
              // DdiAigExistOverAcc (from1,mySmooth,NULL);
              if (ternaryAbstr > 1 && !Ddi_BddIsOne(from1))
                interpolantTernaryAbstr(travMgr, from1, localCone, NULL,
                  nsvars, NULL, ternarySmooth, dynAbstr, enDynAbstrOpt, 2);
            }
            Ddi_Free(mySmooth);
          }
          Ddi_Free(abstrVars);
        }
        if (sat == -1) {
          int j, useBddAppr = 0;
          Ddi_Bdd_t *toPlusBdd = Ddi_BddMakeConst(ddm, 1);

          if (toPlusCube != NULL) {
            Ddi_AigConstrainCubeAcc(from1, toPlusCube);
          }
          if (1 && itpAppr > 1 && toPlus == NULL &&
            itpMgr->trBdd != NULL && (itpMgr->trBddIsAig)) {
            Ddi_Varset_t *sFrom = Ddi_BddSupp(from1);

            Ddi_VarsetIntersectAcc(sFrom, nsvars);
            if (Ddi_VarsetIsVoid(sFrom)) {
              toPlus = Ddi_BddMakeConstAig(ddm, 1);
            } else {
              toPlus = interpolantSatApprImg(itpMgr,
                travMgr, from1, itpTravMgr->careFwd, NULL, 16, 0);
              if (Ddi_AigSatAnd(toPlus, localCone, NULL)) {
                Ddi_BddAndAcc(localCone, toPlus);
                Ddi_Free(toPlus);
              }
            }
            Ddi_Free(sFrom);
          }
          if (0 && implAbstr > 2) { /* BDD approx */
            Ddi_Varset_t *projPart, *nsFrom = Ddi_BddSupp(from1);
            Ddi_Vararray_t *nsFromArray = NULL;

            Ddi_VarsetIntersectAcc(nsFrom, nsvars);
            nsFromArray = Ddi_VararrayMakeFromVarset(nsFrom, 1);
            Ddi_BddSetPartConj(toPlusBdd);
            projPart = Ddi_VarsetVoid(ddm);
            for (j = 0; j < Ddi_VararrayNum(nsFromArray); j++) {
              Ddi_VarsetAddAcc(projPart, Ddi_VararrayRead(nsFromArray, j));
              if (j > 0 && (j % 12 == 0
                  || j == (Ddi_VararrayNum(nsFromArray) - 1))) {
                Ddi_Bdd_t *to_j =
                  DdiAigExistProjectByBdd(from1, NULL, 20000, projPart, -1.0,
                  0, 1);

                if (to_j != NULL && !Ddi_BddIsConstant(to_j)) {
                  Ddi_BddPartInsertLast(toPlusBdd, to_j);
                  useBddAppr = 1;
                }
                Ddi_Free(to_j);
                Ddi_Free(projPart);
                projPart = Ddi_VarsetVoid(ddm);
              }
            }
            Ddi_Free(projPart);
            Ddi_Free(nsFrom);
            Ddi_Free(nsFromArray);
          }
          Ddi_BddSetAig(toPlusBdd);
          if (useBddAppr) {
            if (Ddi_BddSize(toPlusBdd) > 1000) {
              DdiAigRedRemovalAcc(toPlusBdd, NULL, 1000, 30.0);
            }
            Ddi_BddAndAcc(localCone, toPlusBdd);
          }
          if (0 && toPlus == NULL) {
            toPlus = Ddi_AigSatAndWithInterpolant(from1, localCone,
              nsvars, psvars, NULL, NULL, NULL, NULL, &sat, itpPart, 0, -1.0);
          }
          if (toPlus == NULL) {
            toPlus = Ddi_BddMakeConstAig(ddm, 1);
          }
          Ddi_BddAndAcc(toPlus, toPlusBdd);
          Ddi_Free(toPlusBdd);
        }
        Ddi_Free(from1);
        Ddi_Free(localCone);
      }
    }

    if ( /*step>1 && */ doInductiveToPlus && inductiveTo != NULL) {
      Ddi_Bdd_t *partTo;
      int incremental = 1;
      Ddi_Bdd_t *myToPlus;

      if (itpTravMgr->constrainVars != NULL) {
        Ddi_BddComposeAcc(inductiveTo, itpTravMgr->constrainVars,
          itpTravMgr->constrainSubstLits);
      }

      if (toPlusCube != NULL) {
        Ddi_Bdd_t *inductiveTo2 = Ddi_BddDup(inductiveTo);

        Ddi_AigConstrainCubeAcc(inductiveTo, toPlusCube);
        if (Ddi_BddIsZero(inductiveTo)) {
          int j;
          Ddi_Bdd_t *partTo = Ddi_AigPartitionTop(inductiveTo2, 0);
          Ddi_Bddarray_t *arrayTo = Ddi_BddarrayMakeFromBddPart(partTo);

          Ddi_AigarrayConstrainCubeAcc(arrayTo, toPlusCube);
          Ddi_Free(inductiveTo);
          inductiveTo = Ddi_BddMakePartConjVoid(ddm);
          for (j = 0; j < Ddi_BddarrayNum(arrayTo); j++) {
            Ddi_Bdd_t *p_j = Ddi_BddarrayRead(arrayTo, j);

            if (!Ddi_BddIsZero(p_j)) {
              Ddi_BddPartInsertLast(inductiveTo, p_j);
            }
          }
          Ddi_BddSetAig(inductiveTo);
          Ddi_Free(partTo);
          Ddi_Free(arrayTo);
        }
        Ddi_Free(inductiveTo2);
      }
      if (incremental) {
        myToPlus = Ddi_AigInductiveImgPlus(itpTravMgr->from,
          inductiveTo, itpTravMgr->careFwd, toPlus, doInductiveToPlus);
        if (useNewFwd) {
          newFwd = Ddi_BddNot(inductiveTo);
          if (toPlusCube != NULL) {
            int s1, s = Ddi_BddSize(newFwd);

            Ddi_AigConstrainCubeAcc(newFwd, toPlusCube);
            if (0 && ((s1 = Ddi_BddSize(newFwd)) < s)) {
              printf("newFwd: %d -> %d\n", s, s1);
            }
          }
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "newFwd: %d\n", Ddi_BddSize(newFwd))
            );
        }
        if (myToPlus != NULL && inductiveTo2 != NULL) {
          Ddi_Bdd_t *toPlus2 =
            Ddi_AigInductiveImgPlus(itpTravMgr->from, inductiveTo2, myToPlus,
            toPlus, doInductiveToPlus);

          if (myToPlus != NULL && toPlus2 != NULL) {
            Ddi_BddAndAcc(myToPlus, toPlus2);
            Ddi_Free(toPlus2);
          }
        }
      } else {
        myToPlus = InductiveImgPlus(itpTravMgr->from, inductiveTo);
      }

      if (myToPlus != NULL) {
        if (doInductiveToPlus > 2 && Ddi_BddSize(myToPlus) > 1) {
          Ddi_Bdd_t *newRplus = InductiveImgInf(itpMgr, myToPlus,
            itpMgr->inductiveRplusLocal, itpMgr->trAux, NULL, localCone);

          if (newRplus != NULL) {
            Ddi_BddAndAcc(myCareBwd, newRplus);
            if (itpMgr->inductiveRplusLocal == NULL) {
              itpMgr->inductiveRplusLocal = Ddi_BddDup(newRplus);
            } else {
              Ddi_BddAndAcc(itpMgr->inductiveRplusLocal, newRplus);
            }
            Ddi_Free(newRplus);
          }
        }
        if (toPlus == NULL) {
          toPlus = Ddi_BddMakeConstAig(ddm, 1);
        }
        Ddi_BddAndAcc(toPlus, myToPlus);
        Ddi_Free(myToPlus);
      }

    }

    localCone = itpImgGetCone(itpTravMgr, kCone, kConeRings, NULL, 
			      step, 2, 0, 
			      0, 0, -1, enItpSeq);

    if (toPlusCube != NULL) {
      Ddi_AigConstrainCubeAcc(localCone, toPlusCube);
      if (0 && !Ddi_AigSat(localCone)) {
	Ddi_Free(localCone);
	localCone = Ddi_BddMakeConstAig(ddm, 0);
      }
      if (prevTo != NULL) {
        Ddi_AigConstrainCubeAcc(prevTo, toPlusCube);
      }
    }
    if (itpTravMgr->constrainVars != NULL &&
      Ddi_VararrayNum(itpTravMgr->constrainVars) > 0) {
      Ddi_BddComposeAcc(localCone, itpTravMgr->constrainVars,
        itpTravMgr->constrainSubstLits);
    }
    if (toPlus != NULL) {
      Ddi_AigConstrainCubeAcc(localCone, toPlus);
    }

    if (doMonotoneGen) {
      if (!Ddi_AigSatAnd(itpTravMgr->from, localCone, 0)) {
        Ddi_Bdd_t *myCone = Ddi_BddNot(localCone);

        Ddi_AigSplitMonotoneGenAcc(myCone, itpTravMgr->from, 0);
        Ddi_Free(localCone);
        localCone = Ddi_BddNot(myCone);
        Ddi_Free(myCone);
      }
    }

    if (abstrRef > 2) {
      /* pba */
      int mySat;
      Ddi_Bdd_t *fromAndCone = Ddi_BddAnd(itpTravMgr->from, localCone);
      Ddi_Bddarray_t *currAbstr = (step <= 2) ? NULL : itpMgr->abstrCurrAbstr;
      Ddi_Bddarray_t *abstrRefA =
        (abstrRef > 5) ? Ddi_AigAbstrRefinePba(fromAndCone,
        abstrRefCtrl, abstrDoRefine, currAbstr,
                    &mySat, -1.0) : Ddi_AigAbstrRefineCegarPba(fromAndCone,
                    abstrRefCtrl, abstrDoRefine, currAbstr, &mySat, -1.0);

      if (!mySat && abstrRefA != NULL) {
        if (1 && (abstrRef <= 5)) {
          Ddi_Bddarray_t *abstrRefA0 = abstrRefA;

          abstrRefA =
            Ddi_AigAbstrRefinePba(fromAndCone,
                                  abstrRefCtrl, abstrRefA0, NULL, &mySat, -1.0);
          Pdtutil_Assert(abstrRefA != NULL && !mySat, "error in pba ref.");
          Ddi_Free(abstrRefA0);
        }
        Ddi_BddComposeAcc(localCone, abstrRefCtrl, abstrRefA);
      }
      Ddi_Free(fromAndCone);
      Ddi_Free(itpMgr->abstrCurrAbstr);
      itpMgr->abstrCurrAbstr = abstrRefA;   // Ddi_Free(abstrRefA);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(stdout, "abstrCONE: %d\n", Ddi_BddSize(localCone)));
    }

    if (step > (doInductiveToPlus ? 1 : 2) && enToPlusImage &&
      itpTravMgr->to == NULL && toPlus != NULL &&
      itpTravMgr->from != NULL && localCone != NULL) {
      int satRes;
      Ddi_Bdd_t *chkToPlus = Ddi_BddDup(localCone);

      if (toPlus != NULL) {
        Ddi_BddAndAcc(chkToPlus, toPlus);
      }
      if (itpTravMgr->careBwd != NULL) {
        Ddi_BddAndAcc(chkToPlus, myCareBwd);
      }
      satRes = Ddi_AigSatWithAbort(chkToPlus, 10.0);
      useApproxToPlus = satRes == 0;
      Ddi_Free(chkToPlus);
      if (useApproxToPlus) {
        /* toPlus is already OK with cone. Stop image computation */
        Ddi_Free(itpTravMgr->from);
        itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
      }
    }

    if (0 && Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c) {
      Ddi_BddDiffAcc(localCone, itpTravMgr->reached);
    }

    if (dynAbstr && itpTravMgr->from != NULL
      && enStructAbstractionWithCone == 1) {

      int nAbstr;

      Pdtutil_Assert(!itpTravMgr->settings.newConstrain, "not yet supported");
      if (itpTravMgr->settings.useInvarFull && itpMgr->invarConstr != NULL) {
        Ddi_BddAndAcc(itpTravMgr->from0, itpMgr->invarConstr);
      }
      // structural abstraction
      nAbstr = interpolantStructAbstrFrom(itpTravMgr->from,
        itpTravMgr->from0,
        localCone, itpMgr->ns, itpMgr->nsvars, itpTravMgr->trArray);
      if (itpConstrLevel > 1 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(itpTravMgr->from, myInvarConstr);
      }

      if (toPlusCube != NULL) {
        Ddi_AigConstrainCubeAcc(itpTravMgr->from, toPlusCube);
      }
    }

    if (dynAbstr && enDynAbstrBase && (itpTravMgr->from != NULL || abortedTo)) {
      int j;
      unsigned char *abstrMask = NULL;
      int nState = Ddi_VararrayNum(ns);

      itpCare = NULL;
      itpFullCare = Ddi_BddDup(myCareBwd);
      if (toPlus != NULL) {
        Ddi_BddAndAcc(itpFullCare, toPlus);
      }
      if (optLevel >= 1) {
        //        itpCare = toPlus; // produces false failures !
        itpCare = itpFullCare;
      }
      if (optLevel > 2) {
        itpCare = itpFullCare;
      }

      if (itpTravMgr->from == NULL) {
        abstrVars = NULL;
      } else if (enDynAbstr && (minDynAbstrStep >= 0 && step > minDynAbstrStep)
        && itpTravMgr->to == NULL && !(itpExact == 1)) {
        Ddi_Bdd_t *saveFrom0 = NULL;
        int nAbstr;

        if (itpTravMgr->settings.useInvarFull && itpMgr->invarConstr != NULL) {
          Ddi_BddAndAcc(itpTravMgr->from0, itpMgr->invarConstr);
        }
        if (itpTravMgr->settings.newConstrain) {
#if 1
          saveFrom0 = itpTravMgr->from0;
          itpTravMgr->from0 = Ddi_BddMakeConstAig(ddm, 1);
#endif
        }
#if 0
        if (!Ddi_AigSatAnd(itpMgr->initStubState, localCone, 0)) {
          Ddi_Bdd_t *myTr = Ddi_BddMakePartConjFromArray(trArray);

          printf("SAT: %d\n", Ddi_AigSatAnd(myTr, localCone, 0));
          Ddi_Free(myTr);
        }
#endif

        if (cegarAbstrRef > 1 && step > 1 && Ddi_BddSize(localCone) > 1) {
          Ddi_AigSatAndFlowAbstraction(localCone, itpTravMgr->from);
        }

        /* GPC: fix abstraction with CARE */
        abstrVars = interpolantDynAbstrFrom(itpTravMgr->from,
          itpTravMgr->from0, localCone,
          /* careBwd DISABLED */ itpCare, itpMgr->invarConstr,
	  ns, nsvars, NULL,dynAbstrCut, dynAbstrAux,
          dynAbstrCutLits, itpTravMgr->trArray,
          enAbstr, abstrMask, 1, &nAbstr);
        if (nAbstr == 0 && --maxNoAbstr <= 0) {
          enDynAbstr = dynAbstr = 0;    //implAbstr = 0;
        }
        if (itpTravMgr->settings.newConstrain) {
          Ddi_Free(itpTravMgr->from0);
          itpTravMgr->from0 = saveFrom0;
        }
        if (itpConstrLevel > 1 && myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(itpTravMgr->from, myInvarConstr);
        }

        if (itpTravMgr->settings.newConstrain) {
          // disabled as already composed in from0, and constrainVars updated
          Ddi_BddComposeAcc(itpTravMgr->from, itpTravMgr->constrainVars,
            itpTravMgr->constrainSubstLits);
          // wrong as from 0 contains PI variables (not a state set) */
          // to consider backward propagation of toPlusCube
          // constraints (NOW DISABLED)
          // Ddi_AigConstrainOptAcc(from,from0,psvars,NULL,NULL,1);
          Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->from0);
          if (itpMgr->nFreeDelta > 0) {
            int j, eqFound = 0, nEqTot;
            Ddi_Vararray_t *vars = Ddi_VararrayAlloc(ddm, 0);
            Ddi_Bddarray_t *lits = Ddi_BddarrayAlloc(ddm, 0);
            Ddi_Varset_t *supp = Ddi_BddSupp(itpTravMgr->from);

            Ddi_VarsetIntersectAcc(supp, nsvars);
            for (j = 0; j < Ddi_VararrayNum(itpMgr->freeDeltaPi); j++) {
              Ddi_Varset_t *nsv =
                Ddi_BddSupp(Ddi_BddarrayRead(itpMgr->freeDeltaNsLit, j));
              if (Ddi_VarInVarset(supp, Ddi_VarsetTop(nsv))) {
                Ddi_VararrayInsertLast(vars,
                  Ddi_VararrayRead(itpMgr->freeDeltaPi, j));
                Ddi_BddarrayInsertLast(lits,
                  Ddi_BddarrayRead(itpMgr->freeDeltaNsLit, j));
              }
              Ddi_Free(nsv);
            }
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
              fprintf(tMgrO(travMgr),
                "(Exist by composition on free deltas: %d",
                Ddi_BddSize(itpTravMgr->from))
              );
            Ddi_BddComposeAcc(itpTravMgr->from, vars, lits);
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
              printf(" -> %d)\n", Ddi_BddSize(itpTravMgr->from))
              );
            do {
              Ddi_Bdd_t *eq = NULL;

              /*DdiAigEquivVarsSimpleAcc(from,NULL,
                 nsvars,NULL,localCone,NULL,NULL,&nEqTot); */
              eqFound = 0;
              if (eq != NULL) {
                Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from);

                if (toPlus != NULL)
                  Ddi_BddAndAcc(toPlus, eq);
                else
                  toPlus = Ddi_BddDup(eq);
                Ddi_VarsetDiffAcc(sm, nsvars);
                if (Ddi_VarsetNum(sm) < 3) {
                  itpTravMgr->to = Ddi_BddExistProject(itpTravMgr->from,
                    nsvars);
                  sat = 0;
                }
                Ddi_Free(sm);
                Ddi_Free(eq);
                eqFound = 1;
              }
            } while (itpTravMgr->to != NULL && (eqFound || nEqTot > 0));
            Ddi_Free(vars);
            Ddi_Free(lits);
            Ddi_Free(supp);
          }
        }
        if (0 && myCareBwd != NULL && Ddi_BddSize(myCareBwd) < 2) {
          Ddi_AigConstrainCubeAcc(itpTravMgr->from, myCareBwd);
        }
        if (toPlusCube != NULL) {
          Ddi_AigConstrainCubeAcc(itpTravMgr->from, toPlusCube);
        }
        if (0 && nAbstr > 0) {
          Ddi_Varset_t *supp = Ddi_BddSupp(itpTravMgr->from);

          Ddi_VarsetIntersectAcc(supp, nsvars);
          if (Ddi_VarsetNum(supp) < 10) {
            printf("\nKEPT-VARS: ");
            Ddi_VarsetPrint(supp, 0, 0, tMgrO(travMgr));
            printf("\n");
          }
          Ddi_Free(supp);
        }

        if (cegarAbstrRef > 0 && step > 1 && Ddi_BddSize(localCone) > 1) {
          Ddi_AigSatAndFlowAbstraction(localCone, itpTravMgr->from);
        }

        if (step > 2 && !Ddi_BddIsOne(itpTravMgr->from) &&
          dynAbstr > 1 && enDynAbstrOpt && ternaryAbstr > 0) {
          int doTernary, totN;
          Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from);

          Ddi_VarsetIntersectAcc(sm, nsvars);
          totN = Ddi_VarsetNum(sm);
          Ddi_Free(sm);
          if (totN > 20) {

            interpolantTernaryAbstr(travMgr, itpTravMgr->from,
              localCone, itpCare,
              nsvars, NULL, ternarySmooth, dynAbstr, enDynAbstrOpt, 1);
            if (ternaryAbstr > 1 && !Ddi_BddIsOne(itpTravMgr->from))
              interpolantTernaryAbstr(travMgr, itpTravMgr->from, localCone,
                itpCare, itpMgr->nsvars, NULL, ternarySmooth,
                dynAbstr, enDynAbstrOpt, 2);
            sm = Ddi_BddSupp(itpTravMgr->from);
            Ddi_VarsetIntersectAcc(sm, itpMgr->nsvars);
            if (maxTernary > 0 && --maxTernary <= 0) {
              /* disable ternary */
              ternaryAbstr = 0;
            }
            Ddi_Free(sm);
          }
        }

      }

      if (enDynAbstr && (minDynAbstrStep >= 0 && step > minDynAbstrStep)
        && itpTravMgr->to == NULL && abstrVars == NULL) {
        //      Pdtutil_Assert(chkInnerCone, "wrong inner appr");
        if (0 && careOut != NULL) {
          int jj;
          Ddi_Bdd_t *fromBck = Ddi_BddDup(localCone);
          Ddi_Bdd_t *reachedBck = Ddi_BddMakeConstAig(ddm, 0);
          Ddi_Bdd_t *reachedPs = Ddi_BddCompose(itpTravMgr->reached,
            itpMgr->ns, itpMgr->psLit);

          if (toPlusCube != NULL) {
            Ddi_BddAndAcc(fromBck, toPlusCube);
          }
          if (itpMgr->trRange != NULL) {
            Ddi_BddAndAcc(reachedPs, itpMgr->trRange);
          }
          for (jj = 0; jj < 2 * step; jj++) {
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
              fprintf(tMgrO(travMgr), "BCK partial preimage step: %d\n", jj)
              );
            Ddi_BddAndAcc(fromBck, itpMgr->tr); {
              Ddi_Varset_t *sm = Ddi_BddSupp(fromBck);

              Ddi_VarsetDiffAcc(sm, psvars);
              Ddi_AigExistSubsetAcc(fromBck, sm, reachedPs, NULL, 1, -1.0);
              Ddi_Free(sm);
            }
            Ddi_AigExistProjectAllSolutionAcc(fromBck, psvars, reachedPs, 10);
            Ddi_BddOrAcc(reachedBck, fromBck);
            Ddi_BddComposeAcc(fromBck, ps, nsLit);
            if (Ddi_BddSize(fromBck) == 0) {
              if (jj == 0)
                undoCex = 1;
              break;
            }
          }
          if (!undoCex && savePreviousFrom != NULL) {
            Ddi_BddDiffAcc(savePreviousFrom, reachedBck);
            undoCex = 1;
          }
          if (!undoCex)
            Ddi_BddAndAcc(careOut, reachedBck);
          Ddi_Free(reachedPs);
          Ddi_Free(fromBck);
          Ddi_Free(reachedBck);
        }
        Ddi_Free(itpTravMgr->from);
      }

      Ddi_Free(itpFullCare);
    } else {
      if (itpTravMgr->settings.newConstrain && !enDynAbstrOpt) {
        if (itpMgr->nFreeDelta > 0) {
          int j;
          Ddi_Vararray_t *vars = Ddi_VararrayAlloc(ddm, 0);
          Ddi_Bddarray_t *lits = Ddi_BddarrayAlloc(ddm, 0);
          Ddi_Varset_t *supp = Ddi_BddSupp(itpTravMgr->from);

          Ddi_VarsetIntersectAcc(supp, nsvars);
          for (j = 0; j < Ddi_VararrayNum(itpMgr->freeDeltaPi); j++) {
            Ddi_Varset_t *nsv =
              Ddi_BddSupp(Ddi_BddarrayRead(itpMgr->freeDeltaNsLit, j));
            if (Ddi_VarInVarset(supp, Ddi_VarsetTop(nsv))) {
              Ddi_VararrayInsertLast(vars,
                Ddi_VararrayRead(itpMgr->freeDeltaPi, j));
              Ddi_BddarrayInsertLast(lits,
                Ddi_BddarrayRead(itpMgr->freeDeltaNsLit, j));
            }
            Ddi_Free(nsv);
          }
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
            fprintf(tMgrO(travMgr),
              "(Exist by composition on free deltas: %d",
              Ddi_BddSize(itpTravMgr->from))
            );
          Ddi_BddComposeAcc(itpTravMgr->from, vars, lits);
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
            fprintf(tMgrO(travMgr), " -> %d)\n", Ddi_BddSize(itpTravMgr->from))
            );
          Ddi_Free(vars);
          Ddi_Free(lits);
          Ddi_Free(supp);
        }
      }
    }

    if (itpExact ||
      (itpTravMgr->from != NULL && (dynAbstr > 3 && enDynAbstrOpt ||
          useFwdUnroll))) {
      char suffix[20];
      Ddi_Bddarray_t *newFwdUnroll = NULL;
      int constrainFwdUnroll = 0, j;

      sprintf(suffix, "%d", step + 1);
      //      abstrMask = Pdtutil_Alloc(unsigned char,nState);
      newFwdUnroll = Ddi_BddarrayDup(itpMgr->delta);
      Ddi_Vararray_t *newPiVars =
        Ddi_VararrayMakeNewVars(pi, "PDT_ITP_FWDUNR_PI", suffix, 1);
      Ddi_Bddarray_t *newPiLits = Ddi_BddarrayMakeLiteralsAig(newPiVars, 1);

      Ddi_VararrayAppend(Tr_MgrReadI(Tr_TrMgr(itpMgr->trBdd)), newPiVars);
      Ddi_AigarrayComposeAcc(newFwdUnroll, pi, newPiLits);
      Ddi_Free(newPiVars);
      Ddi_Free(newPiLits);
      Pdtutil_Assert(itpExact || dynAbstr > 3
        || useFwdUnroll, "wrong dynabstr");
      /* ps possono essere in fwdUnroll */
      Ddi_AigarrayComposeAcc(newFwdUnroll, ps, itpMgr->nsLit);
      if (toPlusCube != NULL && constrainFwdUnroll) {
        Ddi_AigarrayConstrainCubeAcc(newFwdUnroll, toPlusCube);
      }
      Ddi_AigarrayComposeAcc(newFwdUnroll, ns, itpTravMgr->fwdUnroll);
      //      Ddi_Free(fwdUnroll);
      Ddi_Free(itpTravMgr->prevFwdUnroll);
      itpTravMgr->prevFwdUnroll = itpTravMgr->fwdUnroll;
      itpTravMgr->fwdUnroll = Ddi_BddarrayDup(newFwdUnroll);
      itpTravMgr->stats.fwdUnrollSize =
        Ddi_BddarraySize(itpTravMgr->fwdUnroll);
      Ddi_Free(newFwdUnroll);
    }

    if (itpTravMgr->from == NULL && itpTravMgr->to == NULL) {
      sat = 1;
    } else if (itpTravMgr->to == NULL) {

      if (0 && optLevel >= 0 && (dynAbstr <= 3 || !enDynAbstrOpt)
        && Ddi_BddSize(itpTravMgr->from) > optFromThresh) {
        int mySize;
        int rrp = Ddi_MgrReadAigRedRemMaxCnt(ddm);

        if (step > 3 && myCareBwd != NULL && Ddi_BddSize(myCareBwd) > 100
          && optFromThresh < 10000) {
          Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, 1);
        }
        DdiAigRedRemovalAcc(itpTravMgr->from,
          myCareBwd, 1000, travMgr->settings.aig.lazyTimeLimit);
        Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, rrp);
        mySize = Ddi_BddSize(itpTravMgr->from);
        if (mySize * 2 > optFromThresh) {
          optFromThresh = mySize * 2;
        }
      }

      if (abstrRef > 4) {
        if (useAbstrTr) {
          Ddi_BddComposeAcc(itpTravMgr->from, abstrRefCtrl, abstrDoAbstr);
        } else {
          Ddi_BddComposeAcc(itpTravMgr->from, abstrRefCtrl, abstrDoRefine);
        }
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMin_c,
          fprintf(tMgrO(travMgr), "(Abstr -> %d)",
            Ddi_BddSize(itpTravMgr->from))
          );
      }

      if (optLevel > 2 && (dynAbstr <= 3 && dynAbstr >= 1 || !enDynAbstrOpt)
        && Ddi_BddSize(itpTravMgr->from) < 5000) {
        Ddi_Varset_t *sm;

        Ddi_AigExistProjectAcc(itpTravMgr->from, itpMgr->nsvars, toPlus, 2,
          0, 100.0);
        sm = Ddi_BddSupp(itpTravMgr->from);
        Ddi_VarsetDiffAcc(sm, nsvars);
        if (Ddi_VarsetIsVoid(sm)) {
          itpTravMgr->to = Ddi_BddDup(itpTravMgr->from);
          sat = 0;
        } else {
          itpTravMgr->to =
            Ddi_BddMakeFromAigWithAbort(itpTravMgr->from, 100000);
          if (itpTravMgr->to != NULL) {
            Ddi_BddExistAcc(itpTravMgr->to, sm);
            Ddi_BddSetAig(itpTravMgr->to);
            sat = 0;
          }
        }
        Ddi_Free(sm);
      }

      if (itpTravMgr->to == NULL) {
        if (optLevel > 2 && abstrVars != NULL && !Ddi_VarsetIsVoid(abstrVars)) {
          Ddi_AigExistAcc(localCone, abstrVars, toPlus, 2, 0, 100.0);
        }
        abortedTo = 0;
        if (implAbstr > 5) {
          Ddi_Vararray_t *constrainVarsPsNs = Ddi_VararrayAlloc(ddm, 0);
          Ddi_Bddarray_t *constrainSubstLitsPsNs = Ddi_BddarrayAlloc(ddm, 0);
          Ddi_Bdd_t *eq;

          eq =
            DdiAigEquivVarsAcc(itpTravMgr->from, itpTravMgr->careFwd, nsvars,
            NULL, NULL, constrainVarsPsNs, constrainSubstLitsPsNs);
          if (eq != NULL) {
            Ddi_BddComposeAcc(itpTravMgr->from, constrainVarsPsNs,
              constrainSubstLitsPsNs);
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
              fprintf(tMgrO(travMgr), "PIPS->NS EQ found\n")
              );
          }
          Ddi_Free(eq);
          Ddi_Free(constrainVarsPsNs);
          Ddi_Free(constrainSubstLitsPsNs);
        }
        if (implAbstr > 2 && eqAfterDynAbstr && step >= implAbstrInitIter) {
          Ddi_Bdd_t *eq;

          if (toPlus != NULL && Ddi_BddSize(toPlus) > 0) {
            Ddi_Bdd_t *toPlus2 = Ddi_BddDup(toPlus);

            eq = DdiAigEquivVarsAcc(toPlus2, itpTravMgr->careFwd, NULL, nsvars,
              localCone, itpTravMgr->constrainVars,
              itpTravMgr->constrainSubstLits);
            if (Ddi_VararrayNum(itpTravMgr->constrainVars) > 0) {
              Ddi_BddComposeAcc(itpTravMgr->from, itpTravMgr->constrainVars,
                itpTravMgr->constrainSubstLits);
            }
            Ddi_Free(eq);
            Ddi_Free(toPlus2);
          }
          eq = DdiAigEquivVarsAcc(itpTravMgr->from, itpTravMgr->careFwd, NULL,
            itpMgr->nsvars, localCone, itpTravMgr->constrainVars,
            itpTravMgr->constrainSubstLits);
          Pdtutil_Assert(itpTravMgr->to == NULL, "null to required");
          if (implAbstr > 4 && step > 1 && step <= 3) {
            implArray = Ddi_BddarrayAlloc(ddm, 0);
            itpTravMgr->to =
              DdiAigImplicationsAcc(itpTravMgr->from, NULL, NULL, nsvars,
              implArray);
            if (0) {
              Ddi_Bdd_t *chk = Ddi_BddDiff(itpTravMgr->from, itpTravMgr->to);

              Pdtutil_Assert(!Ddi_AigSat(chk), "wrong implication img+");
              Ddi_Free(chk);
            }
            Ddi_AigConstrainImplAcc(localCone, implArray);
            Ddi_BddAndAcc(localCone, itpTravMgr->to);
            if (toPlus == NULL) {
              toPlus = Ddi_BddDup(itpTravMgr->to);
            } else {
              Ddi_BddAndAcc(toPlus, itpTravMgr->to);
            }
            Ddi_Free(itpTravMgr->to);
            Ddi_Free(implArray);
          }

          if (eq != NULL) {
            Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from);
            int nsm;

            if (toPlus == NULL) {
              toPlus = Ddi_BddDup(eq);
            } else {
              Ddi_BddAndAcc(toPlus, eq);
            }

            if (0 && Ddi_BddSize(localCone) > 10) {
              DdiAigRedRemovalControlAcc(localCone, itpTravMgr->from, 10,
                30.0);
            }
            //      if (careFwd != NULL) Ddi_BddAndAcc(toPlus,careFwd);
            if (Ddi_VarsetIsArray(nsvars)) {
              Ddi_VarsetSetArray(sm);
            }
            Ddi_VarsetDiffAcc(sm, nsvars);
            if (Ddi_VarsetNum(sm) < 4) {
              itpTravMgr->to =
                Ddi_BddExistProject(itpTravMgr->from, itpMgr->nsvars);
              sat = 0;
            } else if (0 && (step > 1)) {
              Ddi_Bdd_t *chk = Ddi_BddCompose(localCone, itpMgr->ns,
                itpMgr->delta);

              if (!Ddi_AigSatWithAbort(chk, 10.0)) {
                itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
                sat = 0;
              }
              Ddi_Free(chk);
            }
            Ddi_Free(sm);
          }
          Ddi_Free(eq);
          if (implAbstr > 3) {
            Ddi_Bdd_t *eq;
            Ddi_Bdd_t *constr = Ddi_BddDup(itpTravMgr->from);
            int size = Ddi_BddSize(localCone);
            int maxDepth = 20;

            if (itpTravMgr->careFwd != NULL) {
              Ddi_BddAndAcc(constr, itpTravMgr->careFwd);
            }
            eq = DdiAigFindEquiv(localCone, constr, maxDepth, 1, 30.0);
            if (eq != NULL && Ddi_BddSize(eq) > 0) {
              Ddi_BddSetAig(eq);
              if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
                int size1 = Ddi_BddSize(localCone);
                int sizeEq = Ddi_BddSize(eq);

                printf("EQ reduction (lev: %d) |Cone|: %d->%d, |EQ|: %d\n",
                  maxDepth, size, size1, sizeEq);
              }
              if (toPlus == NULL) {
                toPlus = Ddi_BddDup(eq);
              } else {
                Ddi_BddAndAcc(toPlus, eq);
              }
            }
            Ddi_Free(eq);
            Ddi_Free(constr);
          }
          //  Pdtutil_Assert(to==NULL,"numm to required");

        }

        if (itpTravMgr->to != NULL) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
            fprintf(tMgrO(travMgr), "NO INTERPOLANT DONE\n")
            );
        } else
          if (0 && toPlusCube != NULL
          && Ddi_BddSize(itpTravMgr->from) < 1000) {
          int j;
          Ddi_Bdd_t *partF = Ddi_AigPartitionTop(itpTravMgr->from, 0);

          for (j = 0; j < Ddi_BddPartNum(partF); j++) {
            Ddi_BddSetMono(Ddi_BddPartRead(partF, j));
          }
          //          Ddi_AigExistProjectAcc(from1,nsvars,NULL,0,0,100.0);
          Ddi_BddExistProjectAcc(partF, nsvars);
          Ddi_BddSetAig(partF);
          itpTravMgr->to = Ddi_BddDup(partF);
          Ddi_Free(partF);
        } else {
          int nv, ret;
          Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from); /* @@@ */
          int totN = Ddi_VarsetNum(sm);
          int exact;
          Ddi_Bdd_t *toAppr = NULL;

          if (Ddi_VarsetIsArray(nsvars)) {
            Ddi_VarsetSetArray(sm);
          }
          Ddi_VarsetIntersectAcc(sm, nsvars);
          sat = 0;
          if (!(itpExact)
            && (nv = Ddi_VarsetNum(sm)) < 150 && totN < 400 && nv > 10
            && Ddi_BddSize(localCone) > 5000
            && maxFailBddFwd > 0 && dynAbstr > 0 /*&& implAbstr>0 */ ) {
            Ddi_Bdd_t *myCare = Ddi_BddMakeConstAig(ddm, 1);

            if (toPlus != NULL) {
              Ddi_BddAndAcc(myCare, toPlus);
            }
            if (myCareBwd != NULL) {
              Ddi_BddAndAcc(myCare, myCareBwd);
            }
            // if (!Ddi_AigSatAnd(from,localCone,careBwd)) {
            if ((ret = Ddi_AigSatAndWithAbort(itpTravMgr->from,
                  localCone, myCare, 100.0)) != 1) {
              /* undefined result speculatively assumed UNSAT. If
                 wrong, check done later */
              if (ret < 0) {
                if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
                  printf("undef result - UNSAT speculated\n");
                }
              }
              exact = 0;
              if (0 && itpAppr > 0
                && itpMgr->trBdd != NULL && itpMgr->trBddIsAig) {
                toAppr = interpolantSatApprImg(itpMgr, travMgr,
                  itpTravMgr->from, itpTravMgr->careFwd, &exact, 16, 0);
              }
              if (exact) {
                itpTravMgr->to = toAppr;
              } else if (0) {
                int sizeTh = 20000 * 100 / nv;

                if (Ddi_BddSize(itpTravMgr->from) > 5000)
                  sizeTh *= 2;
                itpTravMgr->to = DdiAigExistProjectByBdd(itpTravMgr->from,
                  toAppr, sizeTh, nsvars, -1.0, 0, 0);
                if (itpTravMgr->to == NULL) {
                  itpTravMgr->to = DdiAigExistProjectByBdd(itpTravMgr->from,
                    toAppr, 5 * sizeTh, nsvars, -1.0, 0, 0);
                }
                if (itpTravMgr->to != NULL && toAppr != NULL) {
                  Ddi_BddAndAcc(itpTravMgr->to, toAppr);
                }
                Ddi_Free(toAppr);
              } else {
                if (toPlus == NULL && toAppr != NULL) {
                  toPlus = Ddi_BddDup(toAppr);
                }
                Ddi_Free(toAppr);
              }
              sat = 0;
              if (itpTravMgr->to != NULL) {
                Ddi_Bdd_t *chk = Ddi_BddDiff(itpTravMgr->from, itpTravMgr->to);

                Pdtutil_Assert(1 || !Ddi_AigSat(chk), "UNDERAPPR BDD IMG"); /*@@@ */
                Ddi_Free(chk);
                Ddi_Free(sm);
                sm = Ddi_BddSupp(itpTravMgr->to);
                Ddi_VarsetDiffAcc(sm, nsvars);
                if (!Ddi_VarsetIsVoid(sm)) {
                  Ddi_AigExistProjectAcc(itpTravMgr->to, itpMgr->nsvars,
                    NULL, 3, 0, 30.0);
                }
                Ddi_Free(sm);
                sm = Ddi_BddSupp(itpTravMgr->to);
                Ddi_VarsetDiffAcc(sm, nsvars);
                if (!Ddi_VarsetIsVoid(sm)) {
                  Ddi_Free(itpTravMgr->to);
                  maxFailBddFwd--;
                  //            maxFailBddFwd += 2;
                }
              } else {
                maxFailBddFwd--;
              }
            } else {
              sat = 1;
            }
            Ddi_Free(myCare);
          }
          Ddi_Free(sm);
          if (travPdrShared != NULL && travMgr->settings.aig.pdrShareReached) {

            if (travPdrShared->clauseShared != NULL) {
              int j, k, j2, nR;
              int nState = Ddi_VararrayNum(ps);
              Ddi_SatSolver_t *solver = Ddi_SatSolverAlloc();
              Ddi_ClauseArray_t *toClauses;
              Ddi_ClauseArray_t *cubeClauses = Ddi_ClauseArrayAlloc(40);
              Ddi_Bdd_t *refineTo = Ddi_BddMakePartConjVoid(ddm);
              bAig_Manager_t *bmgr = ddm->aig.mgr;

              DdiAig2CnfIdInit(ddm);
              for (j = 0; j < nState; j++) {
                Ddi_Var_t *ps_j = Ddi_VararrayRead(ps, j);
                Ddi_Var_t *ns_j = Ddi_VararrayRead(ns, j);
                bAigEdge_t psBaig = Ddi_VarToBaig(ps_j);
                bAigEdge_t nsBaig = Ddi_VarToBaig(ns_j);
                int psCnf, nsCnf;

                /* swap ps and ns because to is in ns space */
                nsCnf = DdiAig2CnfId(bmgr, nsBaig);
                psCnf = DdiAig2CnfId(bmgr, psBaig);
                Pdtutil_Assert(nsCnf == 2 * (j) + 1, "Wrong cnf id");
                Pdtutil_Assert(psCnf == 2 * (j + 1), "Wrong cnf id");
              }
              toClauses = Ddi_AigClauses(itpTravMgr->from, 0, NULL);
              DdiAig2CnfIdClose(ddm);
              Ddi_SatSolverAddClauses(solver, toClauses);
              pthread_mutex_lock(&travPdrShared->mutex);
              for (j = 0;
                j < Ddi_ClauseArrayNum(travPdrShared->clauseShared); j++) {
                Ddi_Clause_t *cl =
                  Ddi_ClauseArrayRead(travPdrShared->clauseShared, j);
                Ddi_Clause_t *cl2 = Ddi_ClauseNegLits(cl);

                Ddi_ClauseArrayPush(cubeClauses, cl2);
              }

              pthread_mutex_unlock(&travPdrShared->mutex);
              for (j = 0; j < Ddi_ClauseArrayNum(cubeClauses); j++) {
                Ddi_Clause_t *cube = Ddi_ClauseArrayRead(cubeClauses, j);

                if (!Ddi_SatSolve(solver, cube, -1)) {
                  /* to not included in cube: use cube */
                  Ddi_Clause_t *cl = Ddi_ClauseNegLits(cube);
                  Ddi_Bdd_t *clauseAig = Ddi_BddMakeFromClauseWithVars(cl, ns);

                  Ddi_ClauseFree(cl);
                  Ddi_BddPartInsertLast(refineTo, clauseAig);
                  Ddi_Free(clauseAig);
                }
              }

              Ddi_ClauseArrayFree(cubeClauses);
              Ddi_SatSolverQuit(solver);
              Ddi_BddSetAig(refineTo);
              if (toPlus != NULL) {
                Ddi_BddAndAcc(toPlus, refineTo);
              } else {
                toPlus = Ddi_BddDup(refineTo);
              }

              Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                fprintf(tMgrO(travMgr), "|to+pdrR:%d|.\n",
                  Ddi_BddSize(refineTo))
                );
              Ddi_Free(refineTo);
            }
          }


          if (itpAppr > 0
            && itpTravMgr->to == NULL && (itpAppr == 1 ||
              itpMgr->trBdd != NULL && (itpMgr->trBddIsAig))) {
            int exact, imgPlusSat = itpAppr == 1;
            Ddi_Bdd_t *myCare = Ddi_BddDup(itpTravMgr->careFwd);

            if (toPlus != NULL) {
              Ddi_BddAndAcc(myCare, toPlus);
            }
            if (imgPlusSat) {
              itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
              exact = 0;
              enToPlusImage = 1;
            } else {
              itpTravMgr->to = interpolantSatApprImg(itpMgr,
                travMgr, itpTravMgr->from, myCare, &exact, 10, 0);
              if (0 && itpAppr > 1 && itpTravMgr->to != NULL && nv > 10) {
                Ddi_Bdd_t *to2;

                Ddi_BddAndAcc(myCare, itpTravMgr->to);
                to2 = interpolantSatApprImg(itpMgr, travMgr,
                  itpTravMgr->from, myCare, &exact, nv, itpAppr - 1);
                if (to2 != NULL) {
                  Ddi_BddAndAcc(itpTravMgr->to, to2);
                }
                Ddi_Free(to2);
              }
              if (itpTravMgr->to != NULL && Ddi_BddSize(itpTravMgr->to) < 4) {
                if (--imgApprEn == 0) {
                  itpAppr = 0;
                }
              } else {
                imgApprEn++;
              }
            }
            Ddi_Free(myCare);
            if (toPlus == NULL) {
              toPlus = Ddi_BddDup(itpTravMgr->to);
            } else {
              Ddi_BddAndAcc(toPlus, itpTravMgr->to);
            }
            if (!exact && (!enToPlusImage ||
                (imgPlusSat = Ddi_AigSatAnd(toPlus, localCone, myCareBwd)))) {
              Ddi_Free(itpTravMgr->to); /* sbaglia con exact e failure !!! */
#if 1
              if (imgPlusSat) {
                int res;
                Ddi_Bdd_t *itpGen;
                int nState = Ddi_VararrayNum(ps);

                // Ddi_Bdd_t *a = Ddi_BddAnd(toPlus,localCone);
                Ddi_Vararray_t *glbA;
                Ddi_Varset_t *glbVars = Ddi_BddSupp(itpTravMgr->from);
                Ddi_Varset_t *toPlusVars = Ddi_BddSupp(toPlus);
                Ddi_Varset_t *coneVars = Ddi_BddSupp(localCone);
                int maxGen = 4 * nState;
                Ddi_Vararray_t *dynAC = NULL, *dynAA = NULL;
                Ddi_Bddarray_t *dynACL = NULL;
                int useDynAbstr = 1;
                Ddi_Bdd_t *fromAndNew = NULL, *localConeAndNew = NULL;;
                if (useDynAbstr) {
                  dynAA = dynAbstrAux;
                  dynAC = dynAbstrCut;
                  dynACL = dynAbstrCutLits;
                }

                if (itpGenMaxIter > 0) {
                  maxGen = itpGenMaxIter;
                }

                if (Ddi_VarsetIsArray(glbVars)) {
                  Ddi_VarsetSetArray(toPlusVars);
                }
                if (Ddi_VarsetIsArray(toPlusVars)) {
                  Ddi_VarsetSetArray(glbVars);
                }
                Ddi_VarsetUnionAcc(glbVars, toPlusVars);
                if (Ddi_VarsetIsArray(nsvars)) {
                  Ddi_VarsetSetArray(glbVars);
                }
                Ddi_VarsetIntersectAcc(glbVars, nsvars);
                if (Ddi_VarsetIsArray(coneVars)) {
                  Ddi_VarsetSetArray(glbVars);
                }
                Ddi_VarsetIntersectAcc(glbVars, coneVars);
                Ddi_Free(toPlusVars);
                Ddi_Free(coneVars);
                glbA = Ddi_VararrayMakeFromVarset(glbVars, 1);
                Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                  fprintf(tMgrO(travMgr), "|to+GENeralization:%d|.\n",
                    Ddi_BddSize(toPlus))
                  );
                fromAndNew = Ddi_BddDup(itpTravMgr->from);
                localConeAndNew = Ddi_BddDup(localCone);
                if (newFwd != NULL) {
                  Ddi_BddAndAcc(fromAndNew, newFwd);
                  if (!Ddi_BddIncluded(localCone, newFwd)) {
                    Ddi_BddAndAcc(localConeAndNew, newFwd);
                  }
                }
                itpGen = Ddi_AigInterpolantByGenClauses(localConeAndNew,
                  fromAndNew, myCareBwd, toPlus,
                  ps, ns, NULL, glbA, dynAC, dynAA, dynACL, maxGen, 0, &res);
                Ddi_Free(fromAndNew);
                Ddi_Free(localConeAndNew);
                //  Ddi_Free(a);
                Ddi_Free(glbA);
                Ddi_Free(glbVars);
                if (res >= 0) {
                  Ddi_BddNotAcc(itpGen);
                  if (newFwd != NULL) {
                    Ddi_BddNotAcc(newFwd);
                    if (!Ddi_BddIncluded(itpTravMgr->from, itpGen)) {
                      int s = Ddi_BddSize(itpGen);

                      Ddi_BddOrAcc(itpGen, newFwd);
                      Pdtutil_VerbosityLocal(verbosity,
                        Pdtutil_VerbLevelUsrMax_c, fprintf(tMgrO(travMgr),
                          "|OR !new:%d->%d|\n", s, Ddi_BddSize(itpGen))
                        );
                    }
                    Ddi_BddNotAcc(newFwd);
                    if (useNewFwd < 2)
                      Ddi_Free(newFwd);
                  }
                  if (0) {
                    Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->from, itpGen),
                      "wrong itp gen");
                  }
                  Ddi_BddAndAcc(toPlus, itpGen);
                  Pdtutil_VerbosityLocal(verbosity,
                    Pdtutil_VerbLevelUsrMax_c, fprintf(tMgrO(travMgr),
                      "|to+GEN:%d|\n", Ddi_BddSize(toPlus))
                    );
                  if (res > 0) {
                    /* to+ is adequate */
                    itpTravMgr->to = Ddi_BddDup(toPlus);
                  } else {
                    //          enGeneralizedItp=1;
                  }
                }
                Ddi_Free(itpGen);
              }
#endif
            } else {
              Ddi_Free(itpTravMgr->from);
              if (exact && Ddi_AigSatAnd(toPlus, localCone, myCareBwd)) {
                Ddi_Free(itpTravMgr->to);
                sat = 1;
              }
            }
          }

          if (itpTravMgr->to == NULL && !sat) {
            if ((toPlus != NULL || toPlusCube != NULL)) {
              Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                fprintf(stdout, "computing interpolant in TO+\n"));
              if (monotoneRedRemTh > 0
                && Ddi_BddSize(localCone) > monotoneRedRemTh) {
                Ddi_Bdd_t *notCone = Ddi_BddNot(localCone);
                Ddi_Bdd_t *myCare = Ddi_BddDup(toPlus);

                Ddi_AigOptByMonotoneCoreAcc(localCone, notCone, myCare, 0,
                  -1.0);
                //DdiAigRedRemovalControlAcc (localCone,myCare,-1,30.0);
                Ddi_Free(myCare);
                Ddi_Free(notCone);
              }
            }
          }

          if (itpTravMgr->to == NULL && !sat) {

            int sizeTot =
              Ddi_BddSize(localCone) + Ddi_BddSize(itpTravMgr->from);
            int disableItp = 0, enableItpBdd = (enItpBdd > 0);

            itpCare = NULL;
            if (optLevel >= 1 && (toPlus != NULL || myCareBwd != NULL)) {
              itpCare = Ddi_BddMakeConstAig(ddm, 1);
              if (1 && toPlus != NULL && Ddi_BddSize(itpCare) < 5000
                && Ddi_BddSize(toPlus) < 10000) {
                Ddi_BddAndAcc(itpCare, toPlus);
                // /* @@@@ */ Ddi_AigConstrainOptAcc(localCone,toPlus,
                //  NULL,NULL,NULL,3);
              }
              if (myCareBwd != NULL)
                Ddi_BddAndAcc(itpCare, myCareBwd);
            }

            itpTimeLimit = useTimedItp ?
              1.0 * sizeTot / 40000 * travMgr->settings.aig.lazyTimeLimit
              : -1.0;
            if (itpTimeLimit > 0
              && itpTimeLimit < travMgr->settings.aig.lazyTimeLimit) {
              itpTimeLimit = travMgr->settings.aig.lazyTimeLimit;
            }
            if (0 && myInvarConstr != NULL) {
              Ddi_AigAndCubeAcc(itpTravMgr->from, myInvarConstr);
#if 0
              Ddi_BddNotAcc(myInvarConstr);
              Ddi_BddOrAcc(localCone, myInvarConstr);
              Ddi_BddNotAcc(myInvarConstr);
#endif
            }

            if (toPlus != NULL && refineToPlus) {
              int jj, done;
	      int reCheckTarget = 0 && itpTravMgr->settings.storeRings &&
		(itpMgr->nRings > step);

              if (Ddi_AigSatAndWithAbort(itpTravMgr->from, localCone,
                  itpCare, 10.0) == 1) {
                disableItp = 1;
              } else {
                if (itpAppr > 2) {
                  Ddi_Bdd_t *to2;
                  int nv = Ddi_VararrayNum(ps);

                  to2 = interpolantSatApprImg(itpMgr,
                    travMgr, itpTravMgr->from, itpCare, NULL, nv, itpAppr - 1);
                  if (to2 != NULL) {
                    Ddi_BddAndAcc(toPlus, to2);
                    Ddi_BddAndAcc(itpCare, to2);
                    reCheckTarget = 1;
                  }
                  Ddi_Free(to2);
                }
              }

              if (!disableItp && Ddi_BddSize(toPlus) > 8
                && doInductiveToPlus > 7) {
                for (jj = done = 0; jj < 3 && !done; jj++) {
                  Ddi_Bdd_t *ref = Ddi_BddDup(localCone);

                  Ddi_AigExistProjectAllSolutionAcc(ref, nsvars, toPlus, 1);
                  if (Ddi_BddIsZero(ref)) {
                    done = 1;
                    disableItp = 1;
                    itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
                  } else {
                    if (0 && itpTravMgr->careBwd != NULL) {
                      Ddi_BddDiffAcc(itpTravMgr->careBwd, ref);
                    }
                    interpolantTernaryAbstr(travMgr, ref,
                      itpTravMgr->from, itpCare, nsvars, NULL, NULL, 2, 1, 0);
                    Pdtutil_Assert(!Ddi_AigSatAnd(ref, itpTravMgr->from,
                        itpCare), "Wrong to+ ref.");
                    Ddi_BddDiffAcc(toPlus, ref);
                    Ddi_BddDiffAcc(itpCare, ref);
                    reCheckTarget = 1;
                  }
                  Ddi_Free(ref);
                }
              }
              ddiAbcOptAcc(toPlus, -1.0);
              if (reCheckTarget) {
		Ddi_Bdd_t *myToPlus = Ddi_BddDup(toPlus);
		if (itpTravMgr->settings.storeRings &&
		    (itpMgr->nRings > step)) {
		  Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings,
							step);
		  Ddi_BddAndAcc(myToPlus, oldFrom);
		}
                disableItp =
                  !Ddi_AigSatAnd(myToPlus, localCone, itpTravMgr->careBwd);
		Ddi_Free(myToPlus);
                if (disableItp) {
                  itpTravMgr->to = toPlus;
                  toPlus = NULL;
                }
              }
            }

            if (!disableItp && !enableItpBdd) {
              Ddi_Bdd_t *toMinus = NULL;
              int saveItpAbortTh = ddm->settings.aig.itpAbortTh;

              if (enGeneralizedItp) {
                int res;
                Ddi_Bdd_t *itpGen;
                int nState = Ddi_VararrayNum(ps);
                Ddi_Vararray_t *glbA;
                Ddi_Varset_t *glbVars = Ddi_BddSupp(itpTravMgr->from);
                int maxGen = 4 * nState;

                if (itpGenMaxIter > 0) {
                  maxGen = itpGenMaxIter;
                }

                Ddi_VarsetIntersectAcc(glbVars, nsvars);
                glbA = Ddi_VararrayMakeFromVarset(glbVars, 1);
                Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
                  fprintf(tMgrO(travMgr), "|to-GENeralization:%d|.\n",
                    Ddi_BddSize(itpTravMgr->from))
                  );
                /* from ^ careFwd !!! */
                itpGen = Ddi_AigInterpolantByGenClauses(itpTravMgr->from,
                  localCone, myCareBwd, NULL,
                  ps, ns, NULL, glbA, NULL, NULL, NULL, maxGen, 0, &res);
                Ddi_Free(glbA);
                Ddi_Free(glbVars);
                if (res > 0) {
                  itpTravMgr->to = itpGen;
                  itpGen = NULL;
                  Pdtutil_VerbosityLocal(verbosity,
                    Pdtutil_VerbLevelUsrMax_c, fprintf(tMgrO(travMgr),
                      "|to-GEN:%d|\n", Ddi_BddSize(itpTravMgr->to))
                    );
                } else if (res == 0) {
                  /* partial */
                  toMinus = itpGen;
                  itpGen = NULL;
                }
                Ddi_Free(itpGen);
              }
#if 0
              to =
                Ddi_AigSatAndWithInterpolant(from, localCone, nsvars, psvars,
                /* careBwd DISABLED */ itpCare, NULL,
                implArray, &sat, itpPart, 0, itpTimeLimit);
              Ddi_Free(to);
#endif
              if (itpTravMgr->to == NULL) {
                Ddi_Bdd_t *fromAndNew = Ddi_BddDup(itpTravMgr->from);

                if (toMinus != NULL) {
                  if (itpCare == NULL) {
                    itpCare = Ddi_BddMakeConstAig(ddm, 1);
                  }
                  Ddi_BddDiffAcc(itpCare, toMinus);
                }
                if (0 && Ddi_BddSize(localCone) > 20000) {
                  Ddi_AigOptByBddSweepTop(localCone, itpCare, 1);
                }

                if (useNewFwd > 1 && newFwd != NULL)
                  Ddi_BddAndAcc(fromAndNew, newFwd);
                if (enItpAbort
                  && prevToSize > ddm->settings.aig.itpIteOptTh * 2) {
                  ddm->settings.aig.itpAbortTh = prevToSize * 2;
                }
                if (0 && enItpAbort) {
                  ddm->settings.aig.itpAbortTh = saveItpAbortTh;
                }
                if ((rpmTh > 0) && (Ddi_BddSize(localCone) > rpmTh)) {
                  if (!Ddi_AigSat(localCone)) {
                    Ddi_Free(localCone);
                    localCone = Ddi_BddMakeConstAig(ddm, 0);
                  } else {
                    Ddi_AigAbcRpmAcc(localCone, ns, -1, -1.0);
                  }
                }
                if (enItpSeq && Ddi_BddIsPartConj(localCone)) {
                  int jj, chk = 1;
                  Ddi_Vararray_t *seqRef = itpMgr->ns;
                  int nCuts = Ddi_BddPartNum(localCone);

                  enItpSeq = 0;
                  Pdtutil_Assert(Ddi_BddIsPartConj(localCone),
                    "partconj needed by itpseq");
                  itpTravMgr->toItpSeq =
                    Ddi_AigSatAndWithInterpolantSequence(fromAndNew,
                    localCone, &sat, nCuts, itpTimeLimit);
                  Pdtutil_Assert(!sat && itpTravMgr->toItpSeq != NULL,
                    "unsat needed");
                  itpTravMgr->to =
                    Ddi_BddarrayExtract(itpTravMgr->toItpSeq, 0);
                  if (chk) {
                    Ddi_Varset_t *supp = Ddi_BddSupp(itpTravMgr->to);

                    Ddi_VarsetDiffAcc(supp, itpMgr->nsvars);
                    Pdtutil_Assert(Ddi_VarsetIsVoid(supp),
                      "non state var in itpseq");
                    Ddi_Free(supp);
                  }
                  for (jj = 0; jj < Ddi_BddarrayNum(itpTravMgr->toItpSeq);
                    jj++) {
                    Ddi_Vararray_t *seqv = itpMgr->timeFrames->vars[jj + 1];
                    Ddi_Bdd_t *itp_jj =
                      Ddi_BddarrayRead(itpTravMgr->toItpSeq, jj);
                    Ddi_BddSubstVarsAcc(itp_jj, seqv, seqRef);
                    if (chk) {
                      Ddi_Varset_t *supp = Ddi_BddSupp(itp_jj);

                      Ddi_VarsetDiffAcc(supp, itpMgr->nsvars);
                      Pdtutil_Assert(Ddi_VarsetIsVoid(supp),
                        "non state var in itpseq");
                      Ddi_Free(supp);
                    }
                  }
                } else {
                  Ddi_Bdd_t *itpPlus = NULL;

                  if (toPlus != NULL) {
                    itpPlus = Ddi_BddDup(toPlus);
                    if (itpCare != NULL) {
                      Ddi_BddAndAcc(itpPlus, itpCare);
                    }
                    if (itpTravMgr->settings.storeRings &&
                      (itpMgr->nRings > step)) {
                      Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings,
                        step);

                      Ddi_BddAndAcc(itpPlus, oldFrom);
                    }
                  }
                  itpTravMgr->to =
                    Ddi_AigSatAndWithInterpolant(fromAndNew, localCone,
                    nsvars, psvars, /* careBwd DISABLED */ itpCare,
                    NULL /*itpPlus */ , NULL,
                    implArray, &sat, itpPart, 1, itpTimeLimit);
                  Ddi_Free(itpPlus);
                  // if (itpTravMgr->to!=NULL) Ddi_BddNotAcc(itpTravMgr->to;
                }
                Ddi_Free(fromAndNew);
                itpDone = itpTravMgr->to != NULL
                  && !Ddi_BddIsOne(itpTravMgr->to);
                if (enItpAbort && prevToSize > 0) {
                  ddm->settings.aig.itpAbortTh = saveItpAbortTh;
                }
                if (0 && enItpAbort) {
                  ddm->settings.aig.itpAbortTh = saveItpAbortTh;
                }
                if (itpDone && enItpAbort) {
                  prevToSize = Ddi_BddSize(itpTravMgr->to);
                }

                if (itpDone && newFwd != NULL && useNewFwd > 1) {
                  Ddi_BddNotAcc(newFwd);
                  if (!Ddi_BddIncluded(newFwd, itpTravMgr->to)) {
                    if (!Ddi_BddIncluded(itpTravMgr->from, itpTravMgr->to)) {
                      Ddi_BddOrAcc(itpTravMgr->to, newFwd);
                    } else {
                      printf("false include\n");
                    }
                  }
                  Ddi_Free(newFwd);
                }

                if (doInductiveToPlus > 1 && itpDone &&
                  itpTravMgr->to != NULL && step > 1) {
                  Ddi_Bdd_t *to1, *to0 = Ddi_BddDup(itpTravMgr->to);

                  //  Ddi_Bdd_t *to0 = to;
                  int size, size0 = Ddi_BddSize(to0);

                  to1 = Ddi_AigImgSimplify(to0, toPlus, NULL /*kCone */ , 2);
                  Ddi_Free(itpTravMgr->to);
                  itpTravMgr->to = to1;
                  size = Ddi_BddSize(itpTravMgr->to);
                  Ddi_Free(to0);
                  if (size != size0) {
                    Pdtutil_VerbosityLocal(verbosity,
                      Pdtutil_VerbLevelUsrMax_c, fprintf(tMgrO(travMgr),
                        "|to simplify: %d->%d|.\n", size0, size)
                      );
                  }
                }

                if (doInductiveToPlus > 5 && itpTravMgr->to != NULL) {
                  Ddi_AigGeneralizeItpAcc(itpTravMgr->from, itpTravMgr->to,
                    itpCare, 0);
                }
                if (itpTravMgr->to != NULL && toMinus != NULL) {
                  Ddi_BddOrAcc(itpTravMgr->to, toMinus);
                }
                Ddi_Free(toMinus);
              }
              if (sat == -2) {
                sat = 0;
                incompleteTrav = 1;
              }
              if (0 && itpTravMgr->to == NULL && itpMgr->trRange != NULL) {
                Ddi_Bdd_t *from2 = Ddi_BddCompose(itpTravMgr->reached,
                  itpMgr->ns, itpMgr->psLit);

                Ddi_BddAndAcc(from2, itpMgr->trRange);
                Ddi_BddAndAcc(from2, itpMgr->tr);
                if (toPlusCube != NULL) {
                  Ddi_AigConstrainCubeAcc(from2, toPlusCube);
                }
                if (!Ddi_AigSatAnd(from2, localCone, itpCare)) {
                  itpTravMgr->to = Ddi_AigSatAndWithInterpolant(from2, localCone, itpMgr->nsvars, itpMgr->psvars,   /* careBwd DISABLED */
                    itpCare, NULL, NULL,
                    implArray, &sat, itpPart, 1, itpTimeLimit);
                }
                Ddi_Free(from2);
              } else if (itpTravMgr->to != NULL && tightenOrLoosen) {
                int myDbg = 0;
                Ddi_Bdd_t *to0 = itpTravMgr->to;

#if 1
                // to = Ddi_AigTightenOrLoosen (to0,
                //   from, itpCare, tightenOrLoosen);
                //#else
                //          if (Ddi_BddSize(to)!=Ddi_BddSize(to0)) {
                // Ddi_Free(to);
                itpTravMgr->to = Ddi_BddNot(to0);
                interpolantTernaryAbstr(travMgr, itpTravMgr->to,
                  itpTravMgr->from, itpCare, itpMgr->nsvars, NULL, NULL, 2,
                  1, 0);
                Ddi_BddNotAcc(itpTravMgr->to);
                //          }
#endif
                // should be extended to itpCare !!!
                if (myDbg) {
                  Ddi_Bdd_t *chk =
                    Ddi_BddDiff(itpTravMgr->from, itpTravMgr->to);
                  if (itpCare != NULL) {
                    Ddi_BddAndAcc(chk, itpCare);
                  }
                  Pdtutil_Assert(!Ddi_AigSat(chk), "INVALID TIGHT");
                  Ddi_Free(chk);
                  chk = Ddi_BddDiff(itpTravMgr->to, to0);
                  if (itpCare != NULL) {
                    Ddi_BddAndAcc(chk, itpCare);
                  }
                  Pdtutil_Assert(!Ddi_AigSat(chk), "INVALID TIGHT");
                  Ddi_Free(chk);
                }
                Ddi_Free(to0);
                //          }
              }
            }

            if (itpTravMgr->to == NULL && !sat && itpMgr->boundkOptPis != NULL) {
              /* undefinedResult */
              Ddi_Bdd_t *to2;
              int j, k, n = itpMgr->boundkOptNumVars;

              itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
              for (j = 0; j < n; j++) {
                Ddi_Bdd_t *myConeAux = Ddi_BddDup(localCone);

                for (k = 0; k < n; k++) {
                  Ddi_Var_t *boundkV =
                    Ddi_VararrayRead(itpMgr->boundkOptPis, 2 * k);
                  Ddi_Var_t *boundkV2 =
                    Ddi_VararrayRead(itpMgr->boundkOptPis, 2 * k + 1);
                  if (k < j) {
                    Ddi_BddCofactorAcc(myConeAux, boundkV2, 0);
                    Ddi_BddCofactorAcc(myConeAux, boundkV, 1);
                  } else if (k > j) {
                    Ddi_BddCofactorAcc(myConeAux, boundkV2, 1);
                    Ddi_BddCofactorAcc(myConeAux, boundkV, 0);
                  }
                }
                if (Ddi_AigSatAnd(itpTravMgr->to, myConeAux, itpCare)) {
                  to2 = Ddi_AigSatAndWithInterpolant(itpTravMgr->from, myConeAux, nsvars, psvars,   /* careBwd DISABLED */
                    itpCare, NULL, NULL, implArray, &sat, itpPart, 1, -1.0);
                  if (to2 == NULL) {
                    Ddi_Free(itpTravMgr->to);
                    Ddi_Free(myConeAux);
                    break;
                  }
                  Ddi_BddAndAcc(itpTravMgr->to, to2);
                  //                  Ddi_BddAndAcc(itpCare,to2);
                  Ddi_Free(to2);
                }
                Ddi_Free(myConeAux);
              }
              Pdtutil_Assert(itpTravMgr->to == NULL ||
                !Ddi_AigSatAnd(itpTravMgr->to, localCone, itpCare),
                "wrong partitioned itp");
            }
            Ddi_Free(itpCare);
            if (itpTravMgr->to == NULL) {
              if (!sat && itpExact == 2) {
                /* aborted */
                itpTravMgr->to = Ddi_BddMakeConstAig(ddm, 1);
              }
              //            Pdtutil_Assert(chkInnerCone, "wrong inner appr");
            }
            //            toPlus,implArray,&sat,0,30.0);
            if (enableItpBdd || (0 && itpTravMgr->to != NULL &&
                Ddi_BddSize(itpTravMgr->to) > 100000)) {
              Ddi_Varset_t *sm = Ddi_BddSupp(itpTravMgr->from);
              Ddi_Bdd_t *to2;

              Ddi_VarsetIntersectAcc(sm, nsvars);
              if (Ddi_VarsetNum(sm) < 80 &&
                Ddi_BddSize(itpTravMgr->from) < 10000) {
                to2 = DdiAigExistProjectByBdd(itpTravMgr->from,
                  toPlus, 50000, nsvars, -1.0, 0, 0);
                sat = 0;
                if (to2 != NULL) {
                  Ddi_Bdd_t *chk = Ddi_BddDiff(itpTravMgr->from, to2);

                  Pdtutil_Assert(!Ddi_AigSat(chk), "UNDERAPPR BDD IMG");
                  Ddi_Free(chk);
                  Ddi_Free(sm);
                  sm = Ddi_BddSupp(to2);
                  Ddi_VarsetDiffAcc(sm, nsvars);
                  Pdtutil_Assert(Ddi_VarsetIsVoid(sm), "wrong bdd exist");
                  Ddi_Free(itpTravMgr->to);
                  itpTravMgr->to = to2;
                } else {
                  //                sat = 1;
                }
              }
              Ddi_Free(sm);
            }
          }

        }

        if (itpTravMgr->to == NULL && !sat) {
          abortedTo = 1;
          sat = 1;
        } else if (itpTravMgr->to != NULL &&
          Ddi_BddSize(itpTravMgr->to) > itpPartTh * 4
          && dynAbstr > 1 && !enDynAbstrOpt) {
          Ddi_Free(itpTravMgr->to);
          //        sat = 1;
        } else if (itpTravMgr->to != NULL
          && Ddi_BddSize(itpTravMgr->to) <= 2000 && dynAbstr > 1
          && enDynAbstrOpt) {
          // DISABLED ! It doesn't seem to work disabling it again!
          if (travMgr->settings.aig.selfTuningLevel > 1) {
            enDynAbstrOpt = 0;
          }
        }
        if (0 && (itpTravMgr->to == NULL
            || Ddi_BddSize(itpTravMgr->to) > 20000)) {
          Ddi_Varset_t *mySm = Ddi_BddSupp(itpTravMgr->from);
          Ddi_Bdd_t *toAndkCone;

          Ddi_VarsetDiffAcc(mySm, nsvars);
          Ddi_Free(itpTravMgr->to);
#if 1
          Ddi_AigOptByMinCut(itpTravMgr->from, itpTravMgr->careFwd, nsvars,
            1, 1, -1.0);
          Ddi_AigExistProjectAcc(itpTravMgr->from, nsvars,
            itpTravMgr->careFwd, 3, 0, 200.0);
          itpTravMgr->to =
            Ddi_AigSatAndWithInterpolant(itpTravMgr->from, localCone, nsvars,
            psvars, NULL, NULL, NULL, NULL, &sat, 0, 0, 30.0);
#else
          to = Ddi_BddDup(from);
          Ddi_AigExistProjectAcc(to, nsvars, NULL, 3, 0, -1.0);
          Ddi_AigExistProjectAcc(to, nsvars, NULL, 0, 0, -1.0);
          toAndkCone = Ddi_BddAnd(to, localCone);
          sat = Ddi_AigSat(toAndkCone);
          Ddi_Free(toAndkCone);
#endif
          Ddi_Free(mySm);
        }
      }

      if (itpTravMgr->to != NULL) {
        int i;
        Ddi_Bdd_t *auxTo;
        Ddi_Varset_t *vs = Ddi_BddSupp(itpTravMgr->to);

        if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
          printf("TO: %d (supp: %d) - AIG nodes %d\n",
            Ddi_BddSize(itpTravMgr->to), Ddi_VarsetNum(vs),
            Ddi_MgrReadAigNodesNum(ddm));
        }
        //      DdiLogBdd(to,0);
        for (i = 0; i < Ddi_VararrayNum(ns); i++) {
          if (Ddi_VarInVarset(vs, Ddi_VararrayRead(ns, i))) {
            itpMgr->coreVarsCnt[i]++;
          }
        }
        Ddi_Free(vs);
      }

    } else {
      /* to != NULL */
      sat = 0;
    }

    Ddi_Free(itpTravMgr->trArray);
    if (enCheckReached && careCone != NULL && !Ddi_BddIsZero(careCone) &&
      3 * Ddi_BddSize(careCone) < 2 * Ddi_BddSize(kCone)) {
      Ddi_Varset_t *sm = Ddi_BddSupp(careCone);

      Ddi_VarsetDiffAcc(sm, nsvars);
      if (checkReached != NULL) {
        Ddi_Bdd_t *chk = Ddi_BddDiff(careCone, checkReached);

        Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
        Pdtutil_Assert(!Ddi_AigSat(chk), "overappr-carecone");
        Ddi_Free(chk);
      }

      {
        int maxIter = Ddi_MgrReadAigMaxAllSolutionIter(ddm);

        Ddi_MgrSetAigMaxAllSolutionIter(ddm, 4);
        Ddi_AigExistSubsetAcc(careCone, sm, NULL, NULL, -2, 100.0);
        Ddi_MgrSetAigMaxAllSolutionIter(ddm, maxIter);
      }

      if (checkReached != NULL) {
        Ddi_Bdd_t *chk = Ddi_BddDiff(careCone, checkReached);

        Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
        Pdtutil_Assert(!Ddi_AigSat(chk), "overappr-carecone");
        Ddi_Free(chk);
      }


      if (bReached == NULL) {
        bReached = Ddi_BddDup(careCone);
      } else {
        Ddi_BddOrAcc(bReached, careCone);
      }
      Ddi_Free(sm);
    }

    if (itpExact == 2 && itpTravMgr->to != NULL &&
      trBdd2 != NULL && kConeOld != NULL) {
      Ddi_Bdd_t *toBdd = NULL, *toBddAppr;
      Pdtutil_VerbLevel_e verbosity = Ddi_MgrReadVerbosity(ddm);
      int thc = Ddi_MgrReadExistClustThresh(ddm);
      Ddi_Bdd_t *imgConstr = NULL;
      int exact;
      Ddi_Bdd_t *myTrBdd = Ddi_BddDup(itpMgr->trAux);

      Ddi_MgrSetExistClustThresh(ddm, -1);
      if (toPlusCube != NULL) {
        /* early quantification for IMAGE */
        Ddi_AigConstrainCubeAcc(myTrBdd, toPlusCube);
        Ddi_BddSetMono(toPlusCube);
        Ddi_BddExistProjectAcc(toPlusCube, nsvars);
        Ddi_BddConstrainAcc(Tr_TrBdd(trBdd2), toPlusCube);
      }
      imgConstr = Ddi_BddDup(itpTravMgr->to);
      if (toPlus != NULL) {
        Ddi_BddAndAcc(imgConstr, toPlus);
      }
      Ddi_BddSetMono(imgConstr);
      if (Ddi_BddSize(imgConstr) > 1) {
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMin_c,
          fprintf(tMgrO(travMgr), "Image Constraint Size: %d.\n",
            Ddi_BddSize(imgConstr))
          );
      }

      if (itpMgr->trAig != NULL) {
        Ddi_Bdd_t *toBddPart;
        Ddi_Bdd_t *myFrom = Ddi_BddMakeAig(saveFromBdd);
        int j;

        Ddi_BddSetPartConj(imgConstr);
        Ddi_BddAndAcc(myFrom, myTrBdd);
        toBddAppr = interpolantSatApprImg(itpMgr,
          travMgr, myFrom, itpTravMgr->careFwd, &exact, 10, 0);
        Ddi_BddAndAcc(itpTravMgr->to, toBddAppr);
        toBddPart = Ddi_AigPartitionTop(toBddAppr, 0);
        for (j = 0; j < Ddi_BddPartNum(toBddPart); j++) {
          Ddi_Bdd_t *t_j = Ddi_BddPartRead(toBddPart, j);

          Ddi_BddSetMono(t_j);
          Ddi_BddPartInsertLast(imgConstr, t_j);
        }
        Ddi_Free(myFrom);
        Ddi_Free(toBddPart);
        Ddi_Free(toBddAppr);
      }
      Ddi_Free(myTrBdd);
      if (0 && itpTravMgr->prevFwdUnroll != NULL && step > 4
        /*Ddi_BddSize(saveFromBdd) > 2000 */ ) {
        int th = -1;            // Fsm_MgrReadCutThresh(fsmMgr);
        Ddi_Bddarray_t *auxF = Ddi_BddarrayAlloc(ddm, 0);
        Ddi_Vararray_t *auxV = Ddi_VararrayAlloc(ddm, 0);
        Ddi_Bddarray_t *fwdBdd =
          Ddi_AigarrayOptByBdd(itpTravMgr->prevFwdUnroll, auxF, auxV, th, 0, -1,
          -1);

        Ddi_Free(auxF);
        Ddi_Free(auxV);
        Ddi_BddComposeAcc(Tr_TrBdd(trBdd2), ps, fwdBdd);
        Ddi_Free(fwdBdd);
        Ddi_Free(saveFromBdd);
        saveFromBdd = Ddi_BddMakeConst(ddm, 1);
      }

      if (0 && Ddi_BddSize(saveFromBdd) > 5000) {
        int j, n10, n5;
        Ddi_Varset_t *sf = Ddi_BddSupp(saveFromBdd);
        Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(sf, 1);

        Ddi_Free(sf);
        for (j = n10 = n5 = 0; j < Ddi_VararrayNum(vA); j++) {
          Ddi_Var_t *v_j = Ddi_VararrayRead(vA, j);
          Ddi_Bdd_t *cof0 = Ddi_BddCofactor(saveFromBdd, v_j, 0);
          Ddi_Bdd_t *cof1 = Ddi_BddCofactor(saveFromBdd, v_j, 1);
          int size0 = Ddi_BddSize(cof0);
          int size1 = Ddi_BddSize(cof1);

          if (size0 > size1 * 10 || size1 > size0 * 10)
            n10++;
          if (size0 > size1 * 5 || size1 > size0 * 5)
            n5++;
          Ddi_Free(cof0);
          Ddi_Free(cof1);
        }
        if (n5 > 0) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
            fprintf(tMgrO(travMgr), "unbalanced cofactors: (%d,%d)/%d\n",
              n5, n10, Ddi_VararrayNum(vA))
            );
        }
        Ddi_Free(vA);
      }

      if (Ddi_MetaActive(ddm) && step > 6) {
        Ddi_Varset_t *metaVars = Ddi_BddSupp(Tr_TrBdd(trBdd2));
        Ddi_Varset_t *meta2Vars = Ddi_BddSupp(saveFromBdd);
        int gSize = ddm->settings.meta.groupSizeMin;

        Ddi_VarsetUnionAcc(metaVars, meta2Vars);
        Ddi_Free(meta2Vars);
        if (Ddi_VarsetNum(metaVars) / gSize > 20) {
          gSize = Ddi_VarsetNum(metaVars) / 20;
        }
        Ddi_MetaInit(ddm, Ddi_Meta_FilterVars, NULL, metaVars, NULL, NULL,
          gSize);
        Ddi_Free(metaVars);
        Ddi_BddSetMeta(saveFromBdd);
        //      Ddi_BddSetMeta(imgConstr);
        Tr_MgrSetImgAndExistTh(Tr_TrMgr(itpMgr->trBdd), -1);
      } else {
        Ddi_BddSetMono(saveFromBdd);
      }

      //      Ddi_BddAndAcc(saveFromBdd,imgConstr);

      Ddi_BddConstrainAcc(Tr_TrBdd(trBdd2), imgConstr);
      toBdd = Tr_ImgWithConstrain(trBdd2, saveFromBdd, NULL);
      Ddi_BddSwapVarsAcc(imgConstr, ps, ns);
      Ddi_Free(saveFromBdd);
      saveFromBdd = Ddi_BddDup(toBdd);
      Ddi_BddSetPartConj(saveFromBdd);
      Ddi_BddPartInsert(saveFromBdd, 0, imgConstr);
      Ddi_BddSetFlattened(saveFromBdd);
      Ddi_Free(imgConstr);
      Ddi_MgrSetExistClustThresh(ddm, thc);
      Ddi_BddSwapVarsAcc(toBdd, ps, ns);
      Ddi_BddSetAig(toBdd);
      Ddi_BddAndAcc(itpTravMgr->to, toBdd);
      Ddi_Free(toBdd);
    }

    if (doMonotoneGen && itpTravMgr->to != NULL &&
      Ddi_BddSize(itpTravMgr->to) > 0 &&
      Ddi_BddIncluded(itpTravMgr->from, itpTravMgr->to)) {
      Ddi_Bdd_t *newTo, *care = Ddi_BddMakeConstAig(ddm, 1);
      Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);

      if (itpTravMgr->careBwd != NULL) {
        Ddi_BddAndAcc(care, itpTravMgr->careBwd);
      }
      if (toPlus != NULL) {
        Ddi_BddAndAcc(care, toPlus);
      }
      if (itpTravMgr->settings.storeRings && (itpMgr->nRings > step)) {
        Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings, step);

        Ddi_BddAndAcc(care, oldFrom);
      }
      //      Ddi_AigSplitMonotoneGenAcc (to,from,care);

      Ddi_Free(care);
      Ddi_Free(myOne);
    }

    if (itpTravMgr->to != NULL && (toPlus != NULL || toPlusCube != NULL)) {

      if (toPlus != NULL) {
        Ddi_BddAndAcc(itpTravMgr->to, toPlus);
      }

      if (toPlusCube != NULL) {
        /* early quantification for IMAGE */
        Ddi_BddSetMono(toPlusCube);
        Ddi_BddExistProjectAcc(toPlusCube, nsvars);
        Ddi_BddSetAig(toPlusCube);
#if 1
        Ddi_BddAndAcc(itpTravMgr->to, toPlusCube);
#else
        Ddi_BddSetPartConj(itpTravMgr->to);
        Ddi_BddPartInsertLast(itpTravMgr->to, toPlusCube);
#endif
      }
      if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        Ddi_Varset_t *vs = Ddi_BddSupp(itpTravMgr->to);

        printf("TO*TO+: %d (supp: %d)\n", Ddi_BddSize(itpTravMgr->to),
          Ddi_VarsetNum(vs));
        Ddi_Free(vs);
        if (0) {
          Ddi_Bdd_t *r = Ddi_BddMakeMono(itpTravMgr->to);

          printf("# TO states = %20.16g\n",
            Ddi_BddCountMinterm(r, Ddi_VararrayNum(itpMgr->ps)));
          Ddi_Free(r);
        }
      }
    }

    if (toPlusCube != NULL && !sat &&
      Ddi_BddSize(toPlusCube) > 0 && itpTravMgr->constrainVars != NULL) {
      Ddi_Varset_t *supp = Ddi_BddSupp(toPlusCube);
      Ddi_Vararray_t *vA = Ddi_VararrayMakeFromVarset(supp, 1);
      Ddi_Bddarray_t *vLits = Ddi_BddarrayMakeLiteralsAig(vA, 1);
      int i, j, n = Ddi_VararrayNum(vA);
      int nc = Ddi_VararrayNum(itpTravMgr->constrainVars);

      /* check duplicates */
      for (i = 0; i < n; i++) {
        for (j = 0; j < nc; j++) {
          Pdtutil_Assert(Ddi_VararrayRead(vA, i) !=
            Ddi_VararrayRead(itpTravMgr->constrainVars, j),
            "duplicate vars in constrain array");
        }
      }

      Ddi_AigarrayConstrainCubeAcc(vLits, toPlusCube);
      Ddi_VararrayAppend(itpTravMgr->constrainVars, vA);
      Ddi_BddarrayAppend(itpTravMgr->constrainSubstLits, vLits);
      Ddi_Free(vA);
      Ddi_Free(vLits);
      Ddi_Free(supp);
    }

    if (sat && itpTravMgr->to == NULL && careOut != NULL) {
      int jj;
      Ddi_Bdd_t *fromBck = Ddi_BddDup(localCone);
      Ddi_Bdd_t *reachedBck = Ddi_BddMakeConstAig(ddm, 0);
      Ddi_Bdd_t *reachedPs = Ddi_BddCompose(itpTravMgr->reached, ns, psLit);

      if (toPlusCube != NULL) {
        Ddi_BddAndAcc(fromBck, toPlusCube);
      }
      if (itpMgr->trRange != NULL) {
        Ddi_BddAndAcc(reachedPs, itpMgr->trRange);
      }
      for (jj = 0; jj < 2 * step; jj++) {
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "BCK partial preimage step: %d\n", jj)
          );
        Ddi_BddAndAcc(fromBck, itpMgr->tr);
        {
          Ddi_Varset_t *sm = Ddi_BddSupp(fromBck);
          Ddi_Bdd_t *prod = Ddi_BddAnd(fromBck, reachedPs);
          Ddi_Bdd_t *cex = Ddi_AigSatWithCex(prod);

          Ddi_VarsetDiffAcc(sm, psvars);
          Ddi_AigExistSubsetAcc(fromBck, sm, reachedPs, cex, 1, -1.0);
          Ddi_Free(sm);
          Ddi_Free(cex);
          Ddi_Free(prod);
        }
        Ddi_AigExistProjectAllSolutionAcc(fromBck, psvars, reachedPs, -1);
        Ddi_BddOrAcc(reachedBck, fromBck);
        Ddi_BddDiffAcc(reachedPs, fromBck);
        Ddi_BddComposeAcc(fromBck, ps, nsLit);
        if (Ddi_BddSize(fromBck) == 0) {
          if (jj == 0)
            undoCex = 1;
          break;
        }
      }
      if (!undoCex && savePreviousFrom != NULL) {
        Ddi_BddDiffAcc(savePreviousFrom, reachedBck);
        undoCex = 1;
      }
      if (!undoCex)
        Ddi_BddAndAcc(careOut, reachedBck);
      Ddi_Free(fromBck);
      Ddi_Free(reachedBck);
      Ddi_Free(reachedPs);
    }

    if (0 && itpTravMgr->settings.storeRings && sat && toPlus != NULL) {
      /* causes fix points intersecting target (unsound PASS) */
      if (toPlusCube != NULL) {
        Ddi_BddAndAcc(toPlus, toPlusCube);
      }
      Ddi_BddOrAcc(itpTravMgr->reached, toPlus);
      Ddi_BddarrayWrite(itpMgr->fromRings, step, toPlus);
      Ddi_BddarrayWrite(itpMgr->reachedRings, step, itpTravMgr->reached);
      itpMgr->nRings = Ddi_BddarrayNum(itpMgr->fromRings);
    }

    Ddi_Free(toPlusCube);
    if (Ddi_VararrayNum(itpTravMgr->constrainVars) == 0) {
      Ddi_Free(itpTravMgr->constrainVars);
      Ddi_Free(itpTravMgr->constrainSubstLits);
    }

    Ddi_Free(abstrVars);
    Ddi_Free(localCone);
    Ddi_Free(careCone);
    Ddi_Free(implArray);
    Ddi_Free(toPlus);
    Ddi_Free(inductiveTo);
    Ddi_Free(inductiveTo2);
    //    Ddi_Free(saveFromBdd);
    if (trBdd2 != NULL) {
      Tr_TrFree(trBdd2);
    }

    if (0 && redRem && itpTravMgr->to != NULL) {
      DdiAigRedRemovalAcc(itpTravMgr->to, itpTravMgr->careFwd, -1, -1.0);
      DdiAigRedRemovalAcc(itpTravMgr->to, itpTravMgr->careBwd, -1, -1.0);
    }


    if (sat && undoCex)
      sat = 0;
    if (sat) {

      Ddi_Free(itpTravMgr->to);
      Ddi_Free(toMinusTot);
      Ddi_Free(itpTravMgr->from0);
      Ddi_Free(itpTravMgr->careFwd);
      Ddi_Free(prevTo);
      Ddi_Free(newFwd);
      Ddi_Free(myCareBwd);
      Ddi_Free(inductiveTo);
      Ddi_Free(inductiveTo2);
      if (itpTravMgr->settings.tryInnerRing > 2 && enRewind) {
        if (growCone && (kConeRings != NULL)) {
          int np = Ddi_BddPartNum(kConeRings);

          if (step >= np) {
            itpTravMgr->settings.tryInnerRing = 0;
          }
        }
      }

      if (itpTravMgr->settings.tryInnerRing > 2 && enRewind) {

        itpTravMgr->settings.tryInnerRing = 1;
        Ddi_Free(itpTravMgr->from);
        itpTravMgr->from = Ddi_BddDup(savePreviousFrom);
        again = 1;
        step--;
        if (itpTravMgr->saveConstrainVars != NULL) {
          Ddi_Free(itpTravMgr->constrainVars);
          Ddi_Free(itpTravMgr->constrainSubstLits);
          itpTravMgr->constrainVars =
            Ddi_VararrayDup(itpTravMgr->saveConstrainVars);
          itpTravMgr->constrainSubstLits =
            Ddi_BddarrayDup(itpTravMgr->saveConstrainSubstLits);
        }

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr),
            "\nSAME CONE HIT - TO computation resuming at previous step.\n\n")
          );
        enItpSeq = travMgr->settings.aig.igrItpSeq;
        enItpAbort = 1;
        goto end_loop;
      } else {

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "Inner loop REACHES back cone.\n")
          );
        itpMgr->igr.sameConeFail = step;
        itpTravMgr->settings.checkCompleteness = 0;
        *pAbort = 1;
        if (step == 1 && initStub != NULL) {
          // this is a true failure
          *pAbort = 3;
        }
        break;
      }

    }

    if (0 && itpTravMgr->careBwd != NULL && !Ddi_BddIncluded(itpTravMgr->to,
        itpTravMgr->careBwd)) {
      Ddi_BddAndAcc(itpTravMgr->to, itpTravMgr->careBwd);   /* @@@@ first iteration */
    }

    if (itpTravMgr->to != NULL && optLevel >= 0 &&
      Ddi_BddSize(itpTravMgr->to) > optToThresh) {
      int mySize;
      int rrp = Ddi_MgrReadAigRedRemMaxCnt(ddm);

      if (step > 3 && itpTravMgr->careBwd != NULL &&
        Ddi_BddSize(itpTravMgr->careBwd) > 100 && optToThresh < 10000)
        Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, 1);
      if (0 && itpTravMgr->careFwd != NULL) {
        Ddi_BddAndAcc(itpTravMgr->to, itpTravMgr->careFwd);
      }
      if (0 && itpTravMgr->careBwd != NULL) {
        Ddi_BddAndAcc(itpTravMgr->to, itpTravMgr->careBwd);
      }
      DdiAigRedRemovalAcc(itpTravMgr->to, itpTravMgr->careBwd, 1000,
        travMgr->settings.aig.lazyTimeLimit);
      Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRemPeriod_c, inum, rrp);
      mySize = Ddi_BddSize(itpTravMgr->to);
      if (0 && mySize > 50 * optToThresh) {
        *pAbort = 2;            /* aborted */
      }
      if (mySize * 2 > optToThresh) {
        optToThresh = mySize * 2;
      } else {
        optToThresh *= 1.2;
      }
    }

    if (itpTravMgr->to != NULL && optLevel >= 0 &&
      (*pAbort == 2 || Ddi_BddSize(itpTravMgr->to) > 2 * optToThresh)) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "Inner loop ABORTED.\n")
        );
      Ddi_Free(itpTravMgr->to);
      Ddi_Free(itpTravMgr->from0);
      Ddi_Free(itpTravMgr->careFwd);
      Ddi_Free(prevTo);
      Ddi_Free(newFwd);
      Ddi_Free(myCareBwd);
      Ddi_Free(inductiveTo);
      Ddi_Free(inductiveTo2);
      Ddi_BddOrAcc(init, itpTravMgr->reached);
      itpTravMgr->settings.checkCompleteness = 0;
      *pAbort = 2;              /* aborted */
      break;
    }

    if (itpTravMgr->to != NULL) {
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "|to:%d|.\n", Ddi_BddSize(itpTravMgr->to))
        );
    }
    //        DdiAigRedRemovalAcc (to,careAig,-1);

    Ddi_Free(itpTravMgr->from);
    if (itpTravMgr->to != NULL) {

      if (1 && itpTravMgr->settings.storeRings && (itpMgr->nRings > step)) {
        Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->fromRings, step);

        // Ddi_Bdd_t *oldFrom =
        //             Ddi_BddDup(Ddi_BddarrayRead(itpMgr->fromRings,step));
        //Ddi_Bdd_t *oldFrom = Ddi_BddarrayRead(itpMgr->reachedRings,step);
        if (!Ddi_BddIncluded(itpTravMgr->to, oldFrom)) {
          if (doAbstrStoredTo) {
            Ddi_Bdd_t *myToPlus = Ddi_AigInductiveImgPlus(NULL,
              oldFrom, itpTravMgr->careFwd, itpTravMgr->to,
              2 /*doInductiveToPlus */ );

            if (myToPlus == NULL) {
              Ddi_BddAndAcc(itpTravMgr->to, oldFrom);
            } else {
              Ddi_BddAndAcc(itpTravMgr->to, myToPlus);
              Ddi_Free(myToPlus);
            }
          } else {
            Ddi_BddAndAcc(itpTravMgr->to, oldFrom);
          }
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "|to&oldTo:%d|.\n",
              Ddi_BddSize(itpTravMgr->to)););
        }
        if (chkRings && step > 1) {
          Pdtutil_Assert(Ddi_BddIncluded(itpTravMgr->to, oldFrom),
            "img problem in from rings");
        }
        //        Ddi_Free(oldFrom);

      }
      //      if (itpMgr->nPdrRings>step) {
      if (0 && (travPdrShared != NULL)) {

        if (travPdrShared->clauseShared != NULL) {
          int j, k, j2, nR;
          int nState = Ddi_VararrayNum(ps);
          Ddi_SatSolver_t *solver = Ddi_SatSolverAlloc();
          Ddi_SatSolver_t *solverR = Ddi_SatSolverAlloc();
          Ddi_ClauseArray_t *toClauses;
          Ddi_ClauseArray_t *reachedClauses;
          Ddi_ClauseArray_t *cubeClauses = Ddi_ClauseArrayAlloc(40);
          Ddi_Bdd_t *refineTo = Ddi_BddMakePartConjVoid(ddm);
          Ddi_Bdd_t *refineReached = Ddi_BddMakePartConjVoid(ddm);
          bAig_Manager_t *bmgr = ddm->aig.mgr;

          DdiAig2CnfIdInit(ddm);
          for (j = 0; j < nState; j++) {
            Ddi_Var_t *ps_j = Ddi_VararrayRead(ps, j);
            Ddi_Var_t *ns_j = Ddi_VararrayRead(ns, j);
            bAigEdge_t psBaig = Ddi_VarToBaig(ps_j);
            bAigEdge_t nsBaig = Ddi_VarToBaig(ns_j);
            int psCnf, nsCnf;

            /* swap ps and ns because to is in ns space */
            nsCnf = DdiAig2CnfId(bmgr, nsBaig);
            psCnf = DdiAig2CnfId(bmgr, psBaig);
            Pdtutil_Assert(nsCnf == 2 * (j) + 1, "Wrong cnf id");
            Pdtutil_Assert(psCnf == 2 * (j + 1), "Wrong cnf id");
          }
          toClauses = Ddi_AigClauses(itpTravMgr->to, 0, NULL);
          reachedClauses = Ddi_AigClauses(itpTravMgr->reached, 0, NULL);
          DdiAig2CnfIdClose(ddm);
          Ddi_SatSolverAddClauses(solver, toClauses);
          Ddi_SatSolverAddClauses(solverR, reachedClauses);
          Ddi_ClauseArrayFree(reachedClauses);
          pthread_mutex_lock(&travPdrShared->mutex);
          for (j = k = nR = 0;
            j < Pdtutil_IntegerArrayNum(travPdrShared->clauseSharedNum); j++) {
            int n =
              Pdtutil_IntegerArrayRead(travPdrShared->clauseSharedNum, j);
            if (j < step - 2) {
              k += n;
              continue;
            }
            for (j2 = 0; j2 < n; j2++) {
              Ddi_Clause_t *cl =
                Ddi_ClauseArrayRead(travPdrShared->clauseShared, k++);
              Ddi_Clause_t *cl2 = Ddi_ClauseNegLits(cl);

              Ddi_ClauseArrayPush(cubeClauses, cl2);
            }
            if (j == step - 1) {
              nR = Ddi_ClauseArrayNum(cubeClauses);
              /* previous ring: to be used for R */
            }
          }
          pthread_mutex_unlock(&travPdrShared->mutex);
          for (j = 0; j < Ddi_ClauseArrayNum(cubeClauses); j++) {
            Ddi_Clause_t *cube = Ddi_ClauseArrayRead(cubeClauses, j);

            if (j > nR && Ddi_SatSolve(solver, cube, -1)) {
              /* to not included in cube: use cube */
              Ddi_Clause_t *cl = Ddi_ClauseNegLits(cube);
              Ddi_Bdd_t *clauseAig = Ddi_BddMakeFromClauseWithVars(cl, ns);

              Ddi_ClauseFree(cl);
              Ddi_BddPartInsertLast(refineTo, clauseAig);
              Ddi_Free(clauseAig);
            }
            if (Ddi_SatSolve(solverR, cube, -1)) {
              /* reached not included in cube: use cube */
              Ddi_Clause_t *cl = Ddi_ClauseNegLits(cube);
              Ddi_Bdd_t *clauseAig = Ddi_BddMakeFromClauseWithVars(cl, ns);

              Ddi_ClauseFree(cl);
              Ddi_BddPartInsertLast(refineReached, clauseAig);
              Ddi_Free(clauseAig);
            }
          }

          Ddi_ClauseArrayFree(cubeClauses);
          Ddi_SatSolverQuit(solver);
          Ddi_SatSolverQuit(solverR);
          Ddi_BddSetAig(refineTo);
          Ddi_BddSetAig(refineReached);
          Ddi_BddAndAcc(itpTravMgr->to, refineTo);
          Ddi_BddAndAcc(itpTravMgr->reached, refineReached);
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "|to&pdrR:%d|.\n",
              Ddi_BddSize(itpTravMgr->to))
            );
          Ddi_Free(refineTo);
          Ddi_Free(refineReached);
        }
      }

      if (0 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(itpTravMgr->to, myInvarConstr);
      }

      if (toMinusTot != NULL) {
        Ddi_BddOrAcc(itpTravMgr->to, toMinusTot);
      }
      //      if (Ddi_BddIncluded(cexState,to)) {
      //    printf("included\n");
      //      }

      itpTravMgr->from = Ddi_BddDiff(itpTravMgr->to, itpTravMgr->reached);
      if (itpTravMgr->careBwd != NULL) {
        Ddi_BddAndAcc(itpTravMgr->from, itpTravMgr->careBwd);
      }

      Ddi_BddSetAig(itpTravMgr->from);
      if (itpConstrLevel > 1 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(itpTravMgr->from, myInvarConstr);
      }

      again = !enFpChk || useFwdUnroll || Ddi_AigSat(itpTravMgr->from) == 1;
      //    check theory of dynAbstr > 3 !
      //    again = dynAbstr < 4 && Ddi_AigSat(from)==1;
      Ddi_Free(itpTravMgr->from);
      if (!again) {
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "FWD ITP fix-point (0).\n"));
      }

      if (!again && dynAbstr > 3 && ternaryAbstr) {
        itpTravMgr->from = Ddi_BddDup(itpTravMgr->reached);
        again = 1;
      } else {
        if (Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectNew_c
          && (1 || (Ddi_BddSize(itpTravMgr->reached) < 10000) ||
            4 * Ddi_BddSize(itpTravMgr->reached) <
            Ddi_BddSize(itpTravMgr->to)) && reached1 != NULL) {
          //      from = Ddi_BddDiff(to,reached);
          itpTravMgr->from = Ddi_BddDiff(itpTravMgr->to, reached1);
        } else {
          itpTravMgr->from = Ddi_BddDup(itpTravMgr->to);
        }
      }

      if (Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectReached_c) {
        Ddi_Free(itpTravMgr->reached);
        itpTravMgr->reached = Ddi_BddDup(itpTravMgr->to);
      } else {
        Ddi_BddOrAcc(itpTravMgr->reached, itpTravMgr->to);
      }

      if (0 && itpMgr->nRings > 0 && step > 1) {
        int jj = step;
        Ddi_Bdd_t *from00 = Ddi_BddarrayRead(itpMgr->fromRings, jj - 1);
        Ddi_Bdd_t *f00AndTr = Ddi_BddCompose(from00, ns, psLit);

        Ddi_BddAndAcc(f00AndTr, itpMgr->trAux);
        if (itpTravMgr->settings.useInvarFull && itpMgr->invarConstr != NULL) {
          Ddi_BddAndAcc(f00AndTr, itpMgr->invarConstr);
        }
        if (itpConstrLevel > 1 && myInvarConstr != NULL) {
          Ddi_AigAndCubeAcc(f00AndTr, myInvarConstr);
        }
        Pdtutil_Assert(Ddi_BddIncluded(f00AndTr, itpTravMgr->reached),
          "wrong ring IMG");
        Ddi_Free(f00AndTr);
      }

      if (reached1 == NULL) {
        reached1 = Ddi_BddDup(itpTravMgr->reached);
      } else {
        Ddi_DataCopy(reached1, itpTravMgr->reached);
      }
      if (0 && verbosity >= Pdtutil_VerbLevelUsrMax_c) {
        Ddi_Bdd_t *r = Ddi_BddMakeMono(itpTravMgr->reached);

        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr), "# Reached states = %g.\n",
            Ddi_BddCountMinterm(r, Ddi_VararrayNum(itpMgr->ps)))
          );
        Ddi_Free(r);
      }

      if (useFwdUnroll) {
        Ddi_Bdd_t *chkTr = Ddi_BddDup(itpMgr->trAux);
        Ddi_Bdd_t *chk = Ddi_BddDup(itpTravMgr->reached);

        if (itpTravMgr->careBwd != NULL) {
          Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
        }
        Ddi_BddComposeAcc(chk, ns, psLit);
        Ddi_BddAndAcc(chk, chkTr);
        Ddi_Free(chkTr);
        Ddi_BddDiffAcc(chk, itpTravMgr->reached);
        if (itpTravMgr->careBwd != NULL) {
          Ddi_BddNotAcc(itpTravMgr->careBwd);
          Pdtutil_Assert(!Ddi_AigSatAnd(chk, itpTravMgr->careBwd, NULL),
            "Care set problem - Missed Failure");
          Ddi_BddNotAcc(itpTravMgr->careBwd);
          Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
        }
        again = Ddi_AigSat(chk);
        Ddi_Free(chk);
      }

      if (0 && redRem && itpTravMgr->careBwd != NULL) {
        DdiAigRedRemovalAcc(itpTravMgr->reached, itpTravMgr->careBwd, 1000,
          30.0);
      }

      Ddi_Free(itpTravMgr->careFwd);
      Ddi_Free(prevTo);
      Ddi_Free(newFwd);
      Ddi_Free(myCareBwd);
      Ddi_Free(itpTravMgr->to);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr), "   |tr|=%d |reached|=%d.\n",
          sizeAig, Ddi_BddSize(itpTravMgr->reached))
        );
      if (0) {
        fprintf(stdout, "#ReachedStates(estimated)=%g\n",
          Ddi_AigEstimateMintermCount(itpTravMgr->reached,
            Ddi_VararrayNum(ps)));
      }

    } else {
      Ddi_Free(newFwd);
      Ddi_Free(itpTravMgr->careFwd);
      Ddi_Free(prevTo);
      Ddi_Free(myCareBwd);
      if ((!enDynAbstrOpt || undoCex) && savePreviousFrom != NULL) {
        itpTravMgr->from = Ddi_BddDup(savePreviousFrom);
        again = 1;
        if (!undoCex) {
          enDynAbstrOpt = enDynAbstrBase = 1;
          itpTravMgr->settings.computeRestartFrom = (dynAbstr > 3);
        } else {
          useTrRange = 1;
        }

        step--;
        if (itpTravMgr->saveConstrainVars != NULL) {
          Ddi_Free(itpTravMgr->constrainVars);
          Ddi_Free(itpTravMgr->constrainSubstLits);
          itpTravMgr->constrainVars =
            Ddi_VararrayDup(itpTravMgr->saveConstrainVars);
          itpTravMgr->constrainSubstLits =
            Ddi_BddarrayDup(itpTravMgr->saveConstrainSubstLits);
        }

        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr),
            " TO computation ABORTED - resuming at previous step.\n")
          );
      } else {
        Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
          fprintf(tMgrO(travMgr), "   TO computation ABORTED.\n")
          );
        again = 0;
        *pAbort = 2;            /* aborted */
      }
    }

  end_loop:

    Ddi_Free(itpTravMgr->from0);
    if (itpTravMgr->from != NULL) {
      Ddi_Free(savePreviousFrom);
      savePreviousFrom = Ddi_BddDup(itpTravMgr->from);
    }
    Ddi_Free(itpTravMgr->saveConstrainVars);
    Ddi_Free(itpTravMgr->saveConstrainSubstLits);
    if (itpTravMgr->constrainVars != NULL) {
      itpTravMgr->saveConstrainVars =
        Ddi_VararrayDup(itpTravMgr->constrainVars);
      itpTravMgr->saveConstrainSubstLits =
        Ddi_BddarrayDup(itpTravMgr->constrainSubstLits);
    }

    if (travShared != NULL && travMgr->settings.aig.itpShareReached) {

      if (Ddi_BddSize(itpTravMgr->reached) > 20000) {
        travMgr->settings.aig.itpShareReached = 0;
        printf("reached is too large: disable SHARING\n");
      } else {
        int ii = step;
        Ddi_Bdd_t *rX;
        Ddi_Mgr_t *ddmX;

        Pdtutil_Assert(ii >= 0, "wrong step Number");
        pthread_mutex_lock(&travShared->mutex);
        if (travShared->ddmXchg == NULL) {
          travShared->ddmXchg = Ddi_MgrDup(ddm);
        }

        ddmX = travShared->ddmXchg;
        rX = Ddi_BddCopy(ddmX, itpTravMgr->reached);
        if (travShared->itpRchShared == NULL) {
          Pdtutil_Assert(travShared->ddmXchg != NULL, "null ddi xchg mgr");
          travShared->itpRchShared = Ddi_BddarrayAlloc(travShared->ddmXchg, 1);
          Ddi_BddarrayWrite(travShared->itpRchShared, 0, rX);
        }

        if (Ddi_BddarrayNum(travShared->itpRchShared) <= ii) {
          while (Ddi_BddarrayNum(travShared->itpRchShared) < ii) {
            Ddi_BddarrayInsertLast(travShared->itpRchShared, rX);
          }
          Pdtutil_Assert(Ddi_BddarrayNum(travShared->itpRchShared) == ii,
            "bad share ring");
          Ddi_BddarrayWrite(travShared->itpRchShared, ii, rX);
        } else {
          Ddi_Bdd_t *rX0 = Ddi_BddarrayRead(travShared->itpRchShared, ii);

          Ddi_BddAndAcc(rX0, rX);
        }
        Ddi_Free(rX);
        pthread_mutex_unlock(&travShared->mutex);
      }
    }

    Ddi_Free(toMinusTot);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr),
        "*** Trav time: %s ***\n",
        util_print_time((util_cpu_time() - travMgr->travTime)))
      );
    if (again && maxIter > 0 && step > maxIter) {
      *pAbort = 1;
      again = 0;
    }

  } while (again);

  Ddi_Free(saveFromBdd);
  if (itpMgr->inductiveRplusLocal != NULL) {
    Ddi_Bdd_t *myInit, *newRplus, *myRplus;

    myRplus = Ddi_BddDup(itpMgr->inductiveRplusLocal);
    if (itpMgr->initStubState != NULL) {
      myInit = Ddi_BddDup(itpMgr->initStubState);
    } else {
      myInit = Ddi_BddDup(init);
    }
    newRplus = InductiveImgInf(itpMgr, myRplus,
      itpMgr->inductiveRplus, itpMgr->trAux, myInit, NULL);
    Ddi_Free(myInit);
    Ddi_Free(myRplus);
    if (newRplus != NULL) {
      if (itpMgr->inductiveRplus == NULL) {
        itpMgr->inductiveRplus = Ddi_BddDup(newRplus);
      } else {
        Ddi_BddAndAcc(itpMgr->inductiveRplus, newRplus);
      }
      Ddi_Free(newRplus);
    }
  }

  if (rOut != NULL) {
    Ddi_DataCopy(rOut, itpTravMgr->reached);
  }

  if (0 && itpMgr->nRings > 2) {
    int jj;

    for (jj = 2; jj < itpMgr->nRings && jj < step; jj++) {
      Ddi_Bdd_t *from1 = Ddi_BddarrayRead(itpMgr->fromRings, jj);
      Ddi_Bdd_t *from0 = Ddi_BddarrayRead(itpMgr->fromRings, jj - 1);
      Ddi_Bdd_t *reached1 = Ddi_BddarrayRead(itpMgr->reachedRings, jj);
      Ddi_Bdd_t *reached0 = Ddi_BddarrayRead(itpMgr->reachedRings, jj - 1);

      if (itpConstrLevel > 1 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(from0, myInvarConstr);
      }
      Ddi_Bdd_t *f0AndTr = Ddi_BddCompose(from0, ns, psLit);

      Ddi_BddAndAcc(f0AndTr, itpMgr->trAux);
      if (itpTravMgr->settings.useInvarFull && itpMgr->invarConstr != NULL) {
        Ddi_BddAndAcc(f0AndTr, itpMgr->invarConstr);
      }
      if (itpConstrLevel > 1 && myInvarConstr != NULL) {
        Ddi_AigAndCubeAcc(f0AndTr, myInvarConstr);
      }
      Pdtutil_Assert(Ddi_BddIncluded(reached0, reached1), "wrong ring R");
      Pdtutil_Assert(Ddi_BddIncluded(from1, reached1), "wrong ring F");
      Pdtutil_Assert(Ddi_BddIncluded(f0AndTr, reached1), "wrong ring IMG");
      Ddi_Free(f0AndTr);
    }
  }

  if (!(*pAbort) && !enFpChk) {
    Pdtutil_Assert(pAbort != NULL, "abort flag required");
    *pAbort = -1;
    unsoundProof = 1;
  }

  if (!(*pAbort) && itpTravMgr->settings.checkCompleteness) {
    int checkProp = itpTravMgr->settings.checkCompleteness;
    Ddi_Bdd_t *chkTr = Ddi_BddDup(itpMgr->trAux);
    Ddi_Bdd_t *chk = Ddi_BddDup(itpTravMgr->reached);
    Ddi_Var_t *iv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");
    Ddi_Var_t *ispecv = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "Checking ITP completeness ...")
      );
    if (itpTravMgr->careBwd != NULL) {
      Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
    }
    Ddi_BddComposeAcc(chk, ns, psLit);
    Ddi_BddAndAcc(chk, chkTr);
    Ddi_Free(chkTr);
    if (fullInit != NULL) {
      if (!Ddi_BddIncluded(fullInit, itpTravMgr->reached)) {
        printf("FULL init state is not included in reached\n");
      }
    }

    if (iv != NULL) {
      Ddi_Bdd_t *extraInvar = Ddi_BddMakeLiteralAig(iv, 1);

      Ddi_BddComposeAcc(extraInvar, ps, itpMgr->delta);
      Ddi_BddAndAcc(chk, extraInvar);
      Ddi_Free(extraInvar);
    }
    if (itpMgr->invarConstr != NULL) {
      Ddi_BddAndAcc(chk, itpMgr->invarConstr);
    }
    if (1 && Trav_MgrReadAssume(travMgr) != NULL) {
      Ddi_BddAndAcc(chk, Trav_MgrReadAssume(travMgr));
    }
    if (0 && itpTravMgr->careBwd != NULL) {
      Ddi_BddNotAcc(itpTravMgr->careBwd);
      Pdtutil_Assert(!Ddi_AigSatAnd(chk, itpTravMgr->careBwd, NULL),
        "Completeness problem - Missed Failure");
      Ddi_BddNotAcc(itpTravMgr->careBwd);
      Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
    }

    if (checkProp) {
      Ddi_Bdd_t *chk2 = Ddi_BddCofactor(chk, ispecv, 0);

      Ddi_BddCofactorAcc(chk2, iv, 1);
      if (Ddi_AigSat(chk2)) {
        if (checkProp == 1) {
          Pdtutil_Assert(0, "Soundness problem - R hits target");
        } else {
          Pdtutil_Assert(pAbort != NULL, "abort flag required");
          *pAbort = -1;
          unsoundProof = 1;
        }
      }
      Ddi_Free(chk2);
    }

    Ddi_BddDiffAcc(chk, itpTravMgr->reached);
    if (1 && myInvarConstr != NULL) {
      Ddi_AigAndCubeAcc(chk, myInvarConstr);
    }
    if (0 && Ddi_AigSat(chk)) {
      Ddi_Bdd_t *cex = Ddi_AigSatWithCex(chk);

      Ddi_BddExistProjectAcc(cex, nsvars);
      Ddi_AigNetStore(cex, "cex-bench", NULL, Pdtutil_Aig2BenchName_c);
    }
    Pdtutil_Assert(!Ddi_AigSat(chk),
      "Completeness problem - Underappr R at f.p.");
    Ddi_Free(chk);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), " done\n")
      );
  }
  // if (estimateR>2 ) { this condition always computes the # of r. states
  if (estimateR > 2 && *pAbort == 0) {
    int nv = Ddi_VararrayNum(itpMgr->ps);
    int over = 0;

    if (nv > 1000) {
      over = 1000 * (nv / 1000);
      nv = nv % 1000;
    }
    if (estimateR > 3) {
      Ddi_Bdd_t *r = Ddi_BddMakeMono(itpTravMgr->reached);

      fprintf(stdout, "#R exact States = %E\n", Ddi_BddCountMinterm(r, nv));
      if (over > 0) {
	fprintf(stdout, "exact multiplied by 10^%.2f (2^%d)\n", (float)(over/3.321928),over);
      }
      Ddi_Free(r);
    }

    fprintf(stdout, "#R States (estimated) = %LE\n",Ddi_AigEstimateMintermCount(itpTravMgr->reached, nv));
    /* long double tmp = Ddi_AigEstimateMintermCount(itpTravMgr->reached, nv); */
    if (over > 0) {
      fprintf(stdout, "estimated multiplied by 10^%.2f (2^%d)\n", (float)(over/3.321928),over);
    }
  }

  Ddi_Free(fullInit);
  if (storeReached != NULL) {
    Ddi_Var_t *vp = Ddi_VarFromName(ddm, "PDT_BDD_INVARSPEC_VAR$PS");
    Ddi_Var_t *vc = Ddi_VarFromName(ddm, "PDT_BDD_INVAR_VAR$PS");

    Ddi_BddSwapVarsAcc(itpTravMgr->reached, itpMgr->ps, itpMgr->ns);
    Ddi_BddCofactorAcc(itpTravMgr->reached, vp, 1);
    Ddi_BddCofactorAcc(itpTravMgr->reached, vc, 1);
    if (verbosity >= Pdtutil_VerbLevelUsrMax_c) {
      printf("Writing itp reached to %s\n", storeReached);
    }
    Ddi_AigNetStore(itpTravMgr->reached, storeReached,
      NULL, Pdtutil_Aig2BenchName_c);
  }

  if (checkReached != NULL) {
    if (bReached != NULL) {
      Ddi_Bdd_t *chk = Ddi_BddDiff(bReached, checkReached);

      Ddi_BddAndAcc(chk, itpTravMgr->careBwd);
      Pdtutil_Assert(!Ddi_AigSat(chk), "overappr-br");
      Ddi_Free(chk);
    }
    Ddi_Free(checkReached);
  }
  if (bReached != NULL) {
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "ADDING CARE STATES: %d+%d -> ",
        Ddi_BddSize(itpTravMgr->careBwd), Ddi_BddSize(bReached))
      );
    Ddi_BddDiffAcc(itpTravMgr->careBwd, bReached);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "%d.\n", Ddi_BddSize(itpTravMgr->careBwd))
      );
    Ddi_Free(bReached);
  }

  itpTravMgrFree(itpTravMgr);
  if (freeInitStub) {
    Ddi_Free(initStub);
  }
  Ddi_Free(myTrRange);
  Ddi_Free(itpTravMgr->saveConstrainVars);
  Ddi_Free(itpTravMgr->saveConstrainSubstLits);
  Ddi_Free(myInvarConstr);
  Ddi_Free(savePreviousFrom);
  Ddi_Free(ternarySmooth);
  Ddi_Free(itpTravMgr->reached);
  Ddi_Free(reached1);
  Ddi_Free(itpTravMgr->from);
  Ddi_Free(nsvars);
  Ddi_Free(psvars);
  Ddi_Free(itpTravMgr->constrainVars);
  Ddi_Free(itpTravMgr->constrainSubstLits);
//  Ddi_MgrCheckExtRef(ddm,extRef+2);
  return (step - 1);
  /* END INTERPOLANT INNER LOOP */
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
interpolantTernaryAbstr(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * cone,
  Ddi_Bdd_t * care,
  Ddi_Varset_t * nsvars,
  Ddi_Varset_t * noTernaryVars,
  Ddi_Varset_t * ternarySmooth,
  int dynAbstr,
  int enDynAbstrOpt,
  int phase
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  int doTernary;
  int maxGroup = 100, nv;

  if (phase == 2)
    maxGroup *= 4;
  do {
    Ddi_Bdd_t *auxF = NULL;
    Ddi_Varset_t *ternaryVars = Ddi_VarsetVoid(ddm);
    Ddi_Varset_t *abstr = Ddi_BddSupp(from);
    Ddi_Varset_t *abstrCone = Ddi_BddSupp(cone);
    Ddi_Varset_t *sm = Ddi_VarsetDup(abstr);
    Ddi_Varset_t *smCone = Ddi_VarsetDup(abstrCone);

    if (noTernaryVars != NULL) {
      Ddi_VarsetDiffAcc(sm, noTernaryVars);
      Ddi_VarsetDiffAcc(abstr, noTernaryVars);
    }

    Ddi_VarsetSetArray(sm);
    Ddi_VarsetSetArray(smCone);
    Ddi_VarsetSetArray(abstr);
    Ddi_VarsetSetArray(abstrCone);
    Ddi_VarsetSetArray(ternaryVars);
    if (phase <= 1) {
      if (dynAbstr > 2 && enDynAbstrOpt) {
        Ddi_VarsetUnionAcc(abstr, abstrCone);
      }
      Ddi_VarsetDiffAcc(sm, nsvars);
      if (1 && phase == 1) {
        Ddi_VarsetDiffAcc(abstr, nsvars);
      }
      Ddi_Free(abstrCone);
      nv = Ddi_VarsetNum(abstr);
      if (nv > maxGroup * 8) {
        maxGroup = nv / 8 + 1;
      }

      if (nv > 0) {
        auxF = DdiAigTernaryInterpolantByGroupsAcc(from, cone, abstr, sm,
          ternaryVars, care /*toPlus */ , maxGroup, phase == 0 ? 3 : 1,
          travMgr->settings.aig.lazyTimeLimit);
      }
      /* toPlus removed as its support may include smooth variables */
      doTernary = 0;
      if (auxF != NULL && Ddi_VarsetNum(ternaryVars) > 0) {
        int sizeNew, sizeCone = Ddi_BddSize(cone);

        if (phase == 0) {
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr), "Ternary TIGHTEN %d->%d.\n",
              Ddi_BddSize(from), Ddi_BddSize(auxF))
            );
          Ddi_DataCopy(from, auxF);
        } else {
          Ddi_DataCopy(from, auxF);
          DdiAigRedRemovalAcc(from, care, 1000,
            travMgr->settings.aig.lazyTimeLimit);
          DdiAigExistOverAcc(cone, ternaryVars, NULL);
          sizeNew = Ddi_BddSize(cone);
          if (sizeNew < sizeCone) {
            doTernary = 1;
            Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
              fprintf(tMgrO(travMgr),
                "Ternary abstraction of bwdCone %d->%d.\n", sizeCone, sizeNew)
              );
          }
          if (ternarySmooth != NULL) {
            Ddi_VarsetUnionAcc(ternarySmooth, ternaryVars);
          }
        }
      }
      Ddi_Free(abstr);
      Ddi_Free(abstrCone);
      Ddi_Free(sm);
      Ddi_Free(smCone);
      Ddi_Free(auxF);
    } else {
      //      Ddi_VarsetDiffAcc(sm,nsvars);
      Ddi_VarsetDiffAcc(smCone, abstr);
      Ddi_VarsetDiffAcc(abstrCone, abstr);
      if (dynAbstr > 2 && enDynAbstrOpt) {
      }
      nv = Ddi_VarsetNum(abstrCone);
      if (nv > maxGroup * 8) {
        maxGroup = nv / 8 + 1;
      }
      auxF =
        DdiAigTernaryInterpolantByGroupsAcc(cone, from, abstrCone, smCone,
        ternaryVars, /*NULL*/ care /*toPlus */ , maxGroup, phase,
        travMgr->settings.aig.lazyTimeLimit);
      /* toPlus removed as its support may include smooth variables */
      doTernary = 0;
      if (auxF != NULL && Ddi_VarsetNum(ternaryVars) > 0) {
        int sizeNew, sizeCone = Ddi_BddSize(cone);

        sizeNew = Ddi_BddSize(auxF);
        if (sizeNew < sizeCone) {
          Ddi_DataCopy(cone, auxF);
          DdiAigRedRemovalAcc(cone, care, 1000,
            travMgr->settings.aig.lazyTimeLimit);
          doTernary = 1;
          Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
            fprintf(tMgrO(travMgr),
              "Ternary abstraction of bwdCone %d->%d.\n", sizeCone, sizeNew)
            );
        }
        if (ternarySmooth != NULL) {
          Ddi_VarsetUnionAcc(ternarySmooth, ternaryVars);
        }
      }
      Ddi_Free(smCone);
      Ddi_Free(sm);
      Ddi_Free(abstrCone);
      Ddi_Free(auxF);
      Ddi_Free(abstr);
    }
    Ddi_Free(ternaryVars);
  } while (doTernary);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
interpolantSatApprImg(
  Trav_ItpMgr_t * itpMgr,
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * care,
  int *exactP,
  int partSize,
  int apprLevel
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  Ddi_Bdd_t *toBdd = NULL;
  Ddi_Varset_t *coreVars = NULL, *imgVars = NULL;
  Ddi_Vararray_t *varsTot, *coreTot;
  int i0, i, th = 1000, n, sizeFrom;
  Ddi_Bdd_t *auxBddPart = Ddi_AigPartitionTop(from, 0);
  Ddi_Bdd_t *toBddPart = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t *myFrom = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Varset_t *s, *s_i, *sFrom = Ddi_BddSupp(from);
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *ps = itpMgr->ps;
  int *top, j, nState = Ddi_VararrayNum(ns);
  int nPart, nv, *enVars = Pdtutil_Alloc(int,
    nState
  );
  Ddi_Varset_t *psvars = Ddi_VarsetMakeFromArray(ps);
  Ddi_Varset_t *nsvars = Ddi_VarsetMakeFromArray(ns);
  Tr_Tr_t *trAig = itpMgr->trBdd;
  int maxSupp = partSize;

  static int coreIds[] = {
    0, 1, 2, 3, 4, 0, 1, 2, 5, 6, 0, 1, 2, 6, 7, 0, 1, 2, 8, 9
  };
  //    {0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4};
  //    {0,1,2,3,4,5,6,7,8,9,0,2,4,6,8,1,3,5,7,9};
  //    {0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9};
  if (0 && apprLevel == 0) {
    Ddi_Bdd_t *appr = interpolantSatApprImg(itpMgr, travMgr,
      from, care, exactP, 3, 1);

    Ddi_Free(appr);
  }
  //  care=NULL;
  if (itpMgr->trAig != NULL) {
    trAig = itpMgr->trAig;
  }

  sizeFrom = Ddi_BddSize(from);
  if (sizeFrom > 10000) {
    partSize = partSize * 3 / 4;
  }

  coreVars = Ddi_VarsetVoid(ddm);
  if (0) {
    int v[1000] = {
      3, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0,
      1, 1, 0, 0, 2, 2, 0, 2, 2, 0, 0, 2, 2, 0, 0, 1, 0, 0, 1, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0,
      2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2,
      2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2,
      0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 0, 0, 2,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 3, 3, 2, 2,
      2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 3, 3, 2, 2, 2, 2, 2,
      2, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 3, 3, 2, 2, 3, 2, 4, 3
    };
    for (i = 0; i < nState; i++) {
      itpMgr->coreVarsCnt[i] = v[i];
    }
  }
  if (0) {
    int nfound = 0;

    char *vn[100] = {
      "PDT_BDD_INVARSPEC_VAR$NS",
      "signal000001B0_normalized$NS",
      "signal000004C2_normalized$NS",
      "signal000004C3_normalized$NS",
      "signal00000370_normalized$NS",
      "signal00000439_normalized$NS",
      "signal00000375_normalized$NS",
      NULL
    };
    for (i = 0; i < nState; i++) {
      int j;
      Ddi_Var_t *v = Ddi_VararrayRead(ns, i);

      for (j = 0; j < 10; j++) {
        if (vn[j] != NULL && (strcmp(Ddi_VarName(v), vn[j]) == 0)) {
          itpMgr->coreVarsCnt[i] = 1000;
          nfound++;
          break;
        }
      }
    }
    Pdtutil_VerbosityMgr(travMgr, Pdtutil_VerbLevelDevMin_c,
      fprintf(stdout, "FOUND %d CORE VARS\n", nfound));
  }
  //  printf("CORE VARS CNT:");
  for (i = nv = 0; i < nState; i++) {
    enVars[i] = Ddi_VarInVarset(sFrom, Ddi_VararrayRead(ns, i));
    nv += enVars[i];
    //    printf (" %d", itpMgr->coreVarsCnt[i]);
  }
  //  printf("\n");

  Ddi_Free(sFrom);
  if (exactP != NULL) {
    *exactP = nv <= partSize;
  }

  top = Pdtutil_Alloc(int,
    nv
  );

  varsTot = Ddi_VararrayAlloc(ddm, nv);
  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c,
    fprintf(tMgrO(travMgr), "APPROX IMG: from: %d (nv: %d).\n", sizeFrom, nv)
    );
  for (j = 0; /*j<10&& */ j < nv; j++) {
    int imax = -1;

    for (i = 0; i < nState; i++) {
      if (enVars[i] == 0)
        continue;
      if (imax < 0 || itpMgr->coreVarsCnt[i] > itpMgr->coreVarsCnt[imax]) {
        imax = i;
      }
    }
    if (imax < 0)
      break;
    top[j] = imax;
    if (itpMgr->coreVarsCnt[imax] == 0) {
      itpMgr->coreVarsCnt[imax]++;
    }
    itpMgr->coreVarsCnt[imax] *= -1;
    if (j < partSize)
      Ddi_VarsetAddAcc(coreVars, Ddi_VararrayRead(ns, imax));
    Ddi_VararrayWrite(varsTot, j, Ddi_VararrayRead(ns, imax));
  }

  for (j = 0; /*j<10&& */ j < nv; j++) {
    int imax = top[j];

    itpMgr->coreVarsCnt[imax] *= -1;
  }

#if 0
  printf("CORE VARS\n");
  Ddi_VarsetPrint(coreVars, 0, 0, tMgrO(travMgr));
  printf("\nTOT VARS\n");
  for (j = 0; j < Ddi_VararrayNum(varsTot); j++) {
    printf("%s ", Ddi_VarName(Ddi_VararrayRead(varsTot, j)));
  }
  printf("\n");
  for (j--; j >= 0; j--) {
    itpMgr->coreVarsCnt[top[j]] *= -1;
  }
#endif

  Pdtutil_Free(enVars);
  coreTot = Ddi_VararrayMakeFromVarset(coreVars, 1);
  Ddi_DataCopy(toBddPart, from);
  Ddi_BddSetPartConj(toBddPart);
#if 0
  n = Ddi_BddPartNum(auxBddPart);
  for (i = n - 1; i >= 0; i--) {
    Ddi_Bdd_t *p_i = Ddi_BddPartRead(auxBddPart, i);

    s_i = Ddi_BddSupp(p_i);
    Ddi_VarsetIntersectAcc(s_i, nsvars);
    if (Ddi_VarsetNum(s_i) == 0) {
      /* from partition: no tr component */
      Ddi_BddAndAcc(myFrom, p_i);
      Ddi_BddPartRemove(auxBddPart, i);
    }
    Ddi_Free(s_i);
  }

  /* core vars */
  n = Ddi_BddPartNum(auxBddPart);
  sizeFrom = Ddi_BddSize(auxBddPart);
  for (i0 = 0, i = 0; i < n; i++) {
    Ddi_Bdd_t *p0 = Ddi_BddPartRead(toBddPart, i0);
    Ddi_Bdd_t *p_i = Ddi_BddPartRead(auxBddPart, i);

    s = Ddi_BddSupp(p0);
    s_i = Ddi_BddSupp(p_i);
    Ddi_VarsetIntersectAcc(s_i, coreVars);
    if (Ddi_VarsetNum(s_i) == 0) {
      /* no core vars */
      Ddi_Free(s);
      Ddi_Free(s_i);
      continue;
    }
    if (n > 1 && Ddi_BddSize(p_i) > 4 * sizeFrom / n) {
      /* shared partition - overlap */
      Ddi_BddAndAcc(myFrom, p_i);
    } else {
      Ddi_VarsetUnionAcc(s, s_i);
      Ddi_VarsetIntersectAcc(s, nsvars);
      if (Ddi_VarsetNum(s) > 8) {
        Ddi_BddPartInsertLast(toBddPart, p_i);
        i0++;
      } else {
        Ddi_BddAndAcc(p0, p_i);
      }
    }
    Ddi_Free(s);
    Ddi_Free(s_i);
  }

  /* other vars */
  n = Ddi_BddPartNum(auxBddPart);
  sizeFrom = Ddi_BddSize(auxBddPart);
  for ( /*i0=0, */ i = 0; i < n; i++) {
    Ddi_Bdd_t *p0 = Ddi_BddPartRead(toBddPart, i0);
    Ddi_Bdd_t *p_i = Ddi_BddPartRead(auxBddPart, i);

    s = Ddi_BddSupp(p0);
    s_i = Ddi_BddSupp(p_i);
    Ddi_VarsetIntersectAcc(s_i, nsvars);
    if (n > 1 && Ddi_BddSize(p_i) > 4 * sizeFrom / n) {
      /* shared partition - overlap */
      Ddi_BddAndAcc(myFrom, p_i);
    } else {
      Ddi_VarsetUnionAcc(s, s_i);
      Ddi_VarsetIntersectAcc(s, nsvars);
      if (Ddi_VarsetNum(s) > 8) {
        Ddi_BddPartInsertLast(toBddPart, p_i);
        i0++;
      } else {
        Ddi_BddAndAcc(p0, p_i);
      }
    }
    Ddi_Free(s);
    Ddi_Free(s_i);
  }
#endif

  nPart = 2 * (nv - partSize / 2) / partSize + 1;
  if (nPart > 5)
    nPart = 5;                  /* bound on part num */
  toBdd = Ddi_BddMakeConstAig(ddm, 1);
  for (i = 0; i < nPart; i++) {
    Ddi_Bdd_t *myTo;
    int doImg = (i == 0);       /*first part always enabled */

    imgVars = Ddi_VarsetVoid(ddm);
    if (i == 0) {
      Ddi_VarsetUnionAcc(imgVars, coreVars);
    } else if (partSize > 10) {
      for (j = 0; j < partSize; j++) {
        int l = i * partSize + j;

        if (l < Ddi_VararrayNum(varsTot)) {
          Ddi_VarsetAddAcc(imgVars, Ddi_VararrayRead(varsTot, l));
          doImg = 1;
        }
      }
    } else {
      for (j = 0; j < partSize; j++) {
        int l;

        if (j < partSize / 2) {
          l = coreIds[(i - 1) * 5 + j];
        } else {
          l = partSize + (i - 1) * partSize / 2 + j;
        }
        if (l < Ddi_VararrayNum(varsTot)) {
          Ddi_VarsetAddAcc(imgVars, Ddi_VararrayRead(varsTot, l));
          doImg = 1;
        }
      }
    }

#if 0
    Ddi_VarsetRemoveAcc(imgVars, Ddi_VarFromName(ddm, "l2060$NS"));
    Ddi_VarsetRemoveAcc(imgVars, Ddi_VarFromName(ddm, "l2066$NS"));
    Ddi_VarsetRemoveAcc(imgVars, Ddi_VarFromName(ddm, "l2250$NS"));
    Ddi_VarsetRemoveAcc(imgVars, Ddi_VarFromName(ddm, "l2262$NS"));
    Ddi_VarsetRemoveAcc(imgVars, Ddi_VarFromName(ddm, "l1212$NS"));
    //    Ddi_VarsetRemoveAcc(imgVars,Ddi_VarFromName(ddm,"l1208$NS"));
#endif
    //      toBdd = Ddi_BddExistProject(toBddPart,nsvars);
    if (doImg) {
      Ddi_Varset_t *satVars = (apprLevel == 1) ? psvars : NULL;

      myTo = imgBddAigAppr(Tr_TrMgr(trAig),
        toBddPart, myFrom, care, imgVars, satVars, maxSupp, apprLevel);
      Ddi_BddSetAig(myTo);
      Ddi_BddAndAcc(toBdd, myTo);
      Ddi_Free(myTo);
    }
    Ddi_Free(imgVars);
  }
  Ddi_Free(toBddPart);
  Ddi_Free(varsTot);
  Ddi_Free(coreTot);
  Ddi_Free(coreVars);
  Ddi_Free(auxBddPart);
  Ddi_Free(myFrom);
  Ddi_Free(nsvars);
  Ddi_Free(psvars);
  Pdtutil_Free(top);
  return toBdd;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
interpolantStructAbstrFrom(
  Ddi_Bdd_t * fromAndTr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * cone,
  Ddi_Vararray_t * ns,
  Ddi_Varset_t * nsvars,
  Ddi_Bddarray_t * trArray
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  Ddi_Varset_t *suppCone = Ddi_BddSupp(cone);
  Ddi_Varset_t *myNs = Ddi_VarsetDup(nsvars);
  Ddi_Vararray_t *vA;
  int nKeep, nTot, i, j;
  int disAbstr = 0;

  Ddi_VarsetSetArray(suppCone);
  Ddi_VarsetSetArray(myNs);
  Ddi_VarsetIntersectAcc(suppCone, myNs);
  vA = Ddi_VararrayMakeFromVarset(suppCone, 1);
  Ddi_Free(suppCone);
  Ddi_Free(myNs);
  DdiGenericDataCopy((Ddi_Generic_t *) fromAndTr, (Ddi_Generic_t *) from);
  for (i = 0; i < Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA, i);

    Pdtutil_Assert(Ddi_VarReadMark(v) == 0, "0 var mark required");
    Ddi_VarWriteMark(v, 1);
  }

  for (j = 0; j < Ddi_VararrayNum(ns); j++) {
    Ddi_Var_t *v = Ddi_VararrayRead(ns, j);
    int keepVar = Ddi_VarReadMark(v) != 0;

    if (keepVar || disAbstr) {
      Ddi_Bdd_t *tr_j = Ddi_BddarrayRead(trArray, j);

      Ddi_BddAndAcc(fromAndTr, tr_j);
    }
  }

  for (i = 0; i < Ddi_VararrayNum(vA); i++) {
    Ddi_Var_t *v = Ddi_VararrayRead(vA, i);

    Ddi_VarWriteMark(v, 0);
  }

  nKeep = Ddi_VararrayNum(vA);
  nTot = Ddi_VararrayNum(ns);
  Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMin_c,
    fprintf(dMgrO(ddm),
      "  STRUCT ABSTR KEPT %d/%d vars using cone supp\n", nKeep, nTot)
    );
  Ddi_Free(vA);
  return (nTot - nKeep);
}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Varset_t *
interpolantDynAbstrFrom(
  Ddi_Bdd_t * fromAndTr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * cone,
  Ddi_Bdd_t * care,
  Ddi_Bdd_t * invar,
  Ddi_Vararray_t * ns,
  Ddi_Varset_t * nsvars,
  Ddi_Vararray_t * noAbstr,
  Ddi_Vararray_t * dynAbstrCut,
  Ddi_Vararray_t * dynAbstrAux,
  Ddi_Bddarray_t * dynAbstrCutLits,
  Ddi_Bddarray_t * trArray,
  unsigned char *enAbstr,
  unsigned char *abstrMask,
  int doSimplifyTr,
  int *nAbstrP
)
{
  int j, k, p, doAbort, nPhases = 3;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  Ddi_Varset_t *fromVars, *abstrVars = NULL;
  Ddi_Bdd_t *myCone = Ddi_BddDup(cone);
  Ddi_Bdd_t *newFrom, *auxFrom = NULL;
  int logVarset = 0;
  unsigned char *myEnAbstr = NULL;
  int nvars = Ddi_VararrayNum(ns);
  int strategy = Ddi_MgrReadAigDynAbstrStrategy(ddm);
  int computeCore = 0, computeCorNumCex;
  int doProject = 0;
  int tryNnfCore=0;

  if (abstrVars!=NULL && tryNnfCore) {
    if (care!=NULL) {
      Ddi_Bdd_t *notCare = Ddi_BddNot(care);
      if (invar!=NULL) {
	printf("ANDING with INVAR\n");
	Ddi_BddAndAcc(notCare,invar);
      }
      Ddi_BddOrAcc(cone,notCare);
      Ddi_Free(notCare);
      care = NULL;
      Pdtutil_Assert(!Ddi_AigSatAnd(fromAndTr,cone,care),"unsound CARE");
    }
  }

  if (strategy > 1) {
    Ddi_MgrSetOption(ddm, Pdt_DdiDynAbstrStrategy_c, inum, strategy - 2);
    computeCore = 1;
  }
  //  Ddi_Bdd_t *from2, *saveFrom = Ddi_BddDup(fromAndTr);

  if (doProject) {
    //    DdiAigMonotoneRedAcc (cone,care,nsvars,-1);
  }

  if (1 && care != NULL && (1 || !Ddi_BddIncluded(myCone, care))) {
    Ddi_BddAndAcc(myCone, care);
  }

  if (computeCore && !Ddi_BddIsZero(myCone)) {
    int nCore = 0;

    myEnAbstr = Pdtutil_Alloc(unsigned char, nvars);

    for (j = 0; j < nvars; j++) {
      myEnAbstr[j] = (enAbstr != NULL) ? enAbstr[j] : 1;
    }

    int checkSat0 = 0 && Ddi_AigSatAnd(fromAndTr, myCone, NULL);

    for (p = 0; p < nPhases && nCore >= 0; p++) {

      int checkSat = 0 && Ddi_AigSatAnd(fromAndTr, myCone, NULL);

      nCore = Ddi_UnderEstimateUnsatCoreByCexGen(fromAndTr,
        myCone, ns, myEnAbstr, 10, NULL);
      if (nCore > 0) {
        Ddi_Bddarray_t *substF = Ddi_BddarrayAlloc(ddm, nCore);
        Ddi_Vararray_t *substV = Ddi_VararrayAlloc(ddm, nCore);

        DdiGenericDataCopy((Ddi_Generic_t *) fromAndTr,
          (Ddi_Generic_t *) from);
        for (j = k = 0; j < nvars; j++) {
          Ddi_Var_t *v = Ddi_VararrayRead(ns, j);
          Ddi_Bdd_t *tr_j = Ddi_BddarrayRead(trArray, j);
          int keepVar = myEnAbstr[j] == 0;

          if (!keepVar && strstr(Ddi_VarName(v), "PDT_BDD_INVAR") != NULL) {
            keepVar = 1;
            nCore++;
          }
          if (keepVar) {
            /* extract delta component (updated for current img) */
            Ddi_Bdd_t *d_j = Ddi_BddCofactor(tr_j, v, 1);

            Ddi_BddarrayWrite(substF, k, d_j);
            Ddi_VararrayWrite(substV, k, v);
            Ddi_Free(d_j);
            k++;
          } else {
            Ddi_BddAndAcc(fromAndTr, tr_j);
          }
        }
        Pdtutil_Assert(p > 0
          || (Ddi_BddarrayNum(substF) == nCore), "wrong core num");
        Ddi_BddComposeAcc(myCone, substV, substF);
        Ddi_Free(substF);
        Ddi_Free(substV);
        if (0) {
          Pdtutil_Assert(checkSat == Ddi_AigSatAnd(fromAndTr, myCone,
              NULL), "error in gen. core extr.");
          Pdtutil_Assert(checkSat == checkSat0, "error in gen. core extr.");
        }
      }
      Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMin_c,
        fprintf(dMgrO(ddm),
          "DYN ABSTR KEPT %d/%d vars using generalization\n", nCore, nvars)
        );
      if (nCore < 5)
        break;
    }
  }

  if (nAbstrP != NULL) {
    *nAbstrP = 0;
  }

  if (myEnAbstr != NULL) {
    if (Pdtutil_MgrVerbosity(ddm) > Pdtutil_VerbLevelDevMed_c) {
      printf("EA[0]: ");
      for (j = 0; j < nvars; j++)
        printf("%d", (int)myEnAbstr[j]);
      printf("\n");
    }
  }

  if (noAbstr!=NULL) {
    int na = Ddi_VararrayNum(noAbstr);
    unsigned char *enA = NULL;
    Ddi_Vararray_t *ns2 = Ddi_VararrayAlloc(ddm, 0);
    Ddi_Bddarray_t *cutL = Ddi_BddarrayAlloc(ddm, 0);

    Ddi_VararrayWriteMark(noAbstr, 1);
    Pdtutil_VerbosityMgr(ddm, Pdtutil_VerbLevelUsrMin_c,fprintf(dMgrO(ddm),
      "DYN abstr: %d/%d vars are no ABSTR\n", na, nvars)
    );

#if 1
    for (j = 0; j < nvars; j++) {
      Ddi_Var_t *ns_j = Ddi_VararrayRead(ns,j);
      Ddi_Bdd_t *cl_j = Ddi_BddarrayRead(dynAbstrCutLits,j);
      if (Ddi_VarReadMark(ns_j)==0) {
	// abstr enabled
	Ddi_VararrayInsertLast(ns2,ns_j);
	Ddi_BddarrayInsertLast(cutL,cl_j);
      }
    }

    auxFrom = Ddi_BddCompose(fromAndTr, ns2, cutL);

#else
    enA = (myEnAbstr != NULL) ? myEnAbstr : enAbstr;

    for (j = 0; j < nvars; j++) {
      Ddi_Var_t *ns_j = Ddi_VararrayRead(ns,j);
      if (Ddi_VarReadMark(ns_j)==1) {
	// marked as noabstr
	enA[j] = 0;
      }
    }
#endif
    Ddi_VararrayWriteMark(noAbstr, 0);
    Ddi_Free(ns2);
    Ddi_Free(cutL);
  }
  else {
    auxFrom = Ddi_BddCompose(fromAndTr, ns, dynAbstrCutLits);
  }

#if 0
  if (0 && Ddi_BddSize(auxFrom) > 100 && Ddi_BddSize(myCone) > 100) {
    Ddi_Bddarray_t *benchArray;
    Ddi_Bdd_t *lit;
    char filename[100];
    static int itpCounter = 0;

    //Pdtutil_Assert(Ddi_VararrayNum(dynAbstrCut)==Ddi_VararrayNum(ns),
    //"Wrong var array size");
    sprintf(filename, "itpDA%02d.bench", ++itpCounter);
    benchArray = Ddi_BddarrayAlloc(ddm, 0);
    Ddi_BddarrayInsertLast(benchArray, auxFrom);
    Ddi_BddarrayInsertLast(benchArray, myCone);
    for (j = 0; j < Ddi_VararrayNum(dynAbstrCut); j++) {
      lit = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(dynAbstrCut, j), 1);
      Ddi_BddarrayInsertLast(benchArray, lit);
      Ddi_Free(lit);
    }
    for (j = 0; j < Ddi_VararrayNum(ns); j++) {
      lit = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, j), 1);
      Ddi_BddarrayInsertLast(benchArray, lit);
      Ddi_Free(lit);
    }
    for (j = 0; j < Ddi_VararrayNum(dynAbstrAux); j++) {
      lit = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(dynAbstrAux, j), 1);
      Ddi_BddarrayInsertLast(benchArray, lit);
      Ddi_Free(lit);
    }
    Ddi_AigarrayNetStore(benchArray, filename, NULL,
      Pdtutil_Aig2BenchLocalId_c);
    Ddi_Free(benchArray);
  }
#endif

  int useMinisat22 = ddm->settings.aig.itpDrup; 
  if (useMinisat22)
    newFrom = Ddi_AigAbstrVarsForInterpolant22(auxFrom, myCone,
              dynAbstrCut, ns, dynAbstrAux, NULL,
              myEnAbstr != NULL ? myEnAbstr : enAbstr, &doAbort);
  else
    newFrom = Ddi_AigAbstrVarsForInterpolant(auxFrom, myCone,
              dynAbstrCut, ns, dynAbstrAux, NULL,
              myEnAbstr != NULL ? myEnAbstr : enAbstr, &doAbort);

#if 0
  if (0 && newFrom != NULL) {
    Ddi_Varset_t *sm = Ddi_VarsetMakeFromArray(dynAbstrCut);

    from2 = Ddi_BddExist(newFrom, sm);
    Ddi_Free(sm);
  }
#endif

  if (doAbort) {
    Ddi_Free(newFrom);
    newFrom = Ddi_AigAbstrVarsForInterpolantByRefinement(auxFrom, myCone,
      dynAbstrCut, ns, dynAbstrAux, NULL, enAbstr);
  }


  if (newFrom != NULL) {
    Ddi_Bdd_t *one = Ddi_BddMakeConstAig(ddm, 1);
    Ddi_Varset_t *totVars = Ddi_BddSupp(fromAndTr);
    Ddi_VarsetWriteMark(totVars, 1);

    abstrVars = Ddi_VarsetVoid(ddm);
    Ddi_VarsetSetArray(abstrVars);
    fromVars = Ddi_BddSupp(newFrom);
    Ddi_VarsetSetArray(fromVars);
    Ddi_VarsetIntersectAcc(fromVars, nsvars);
    DdiGenericDataCopy((Ddi_Generic_t *) fromAndTr, (Ddi_Generic_t *) from);
    //Ddi_VarsetPrint(fromVars,0,0,stdout);

    if (noAbstr!=NULL) {
      Ddi_Vararray_t *keptVars = Ddi_VararrayMakeFromVarset(fromVars, 1);
      Ddi_VararrayUnionAcc(noAbstr,keptVars);
      Ddi_Free(keptVars);
    }

    if (Pdtutil_MgrVerbosity(ddm) > Pdtutil_VerbLevelDevMed_c) {
      printf("EA[1]: ");
    }
    for (j = 0; j < Ddi_VararrayNum(ns); j++) {
      Ddi_Var_t *v = Ddi_VararrayRead(ns, j);
      int keepVar = 0;

      if (myEnAbstr != NULL) {
        keepVar |= myEnAbstr[j] == 0;
      }
      keepVar |= Ddi_VarInVarset(fromVars, v);
      if (0 && enAbstr != NULL)
        keepVar |= strstr(Ddi_VarName(v), "PDT_BDD_INVAR") != NULL;

      if (Pdtutil_MgrVerbosity(ddm) > Pdtutil_VerbLevelDevMed_c) {
        printf("%d", keepVar);
      }
      if (keepVar) {
        Ddi_Bdd_t *tr_j = Ddi_BddarrayRead(trArray, j);

        Ddi_BddAndAcc(fromAndTr, tr_j);
        if (abstrMask != NULL) {
          abstrMask[j] = 0;
        }
      } else if (Ddi_VarReadMark(Ddi_VararrayRead(ns, j))==1) {
        Ddi_VarsetAddAcc(abstrVars, Ddi_VararrayRead(ns, j));

        if (nAbstrP != NULL) {
          (*nAbstrP)++;
        }
        if (abstrMask != NULL) {
          abstrMask[j] = 1;
        }
        if (doSimplifyTr) {
          Ddi_BddarrayWrite(trArray, j, one);
        }
      }
    }

    if (doProject && Ddi_VarsetNum(fromVars) > 0) {

      if (0 && (Ddi_AigFilterStructMonotone(cone, fromVars) > 0)) {
        Ddi_AigFilterStructMonotone(cone, fromVars);
      }

      if (0)
        do {
          Ddi_Bdd_t *eq, *coneDup = Ddi_BddDup(cone);

          //      DdiAigMonotoneRedAcc (cone,care,nsvars,-1);
          if (Ddi_AigExistProjectAllSolutionAcc(coneDup, fromVars, care,
              -1) == NULL) {
            Ddi_BddNotAcc(coneDup);
            eq = DdiAigFindEquiv(cone, coneDup, 20, 0, 30.0);
            Ddi_BddNotAcc(coneDup);
            Ddi_Free(eq);
            Ddi_BddOrAcc(cone, coneDup);
          } else {
            Ddi_DataCopy(cone, coneDup);
          }
          Ddi_Free(coneDup);
        } while (0);
    }

    if (Pdtutil_MgrVerbosity(ddm) > Pdtutil_VerbLevelDevMin_c) {
      printf("\n");
    }

    Ddi_Free(one);

    if (0 && care != NULL && !Ddi_BddIncluded(from, care)) {
      Ddi_BddAndAcc(from, care);
    }
    if (invar != NULL) {
      Ddi_BddAndAcc(from, invar);
    }
    if (logVarset) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm), "DYN ABSTR VARS: ")
        );
      Ddi_VarsetPrint(fromVars, 0, 0, dMgrO(ddm));
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm), "\n")
        );
    }
    Ddi_VarsetWriteMark(totVars, 0);
    Ddi_Free(fromVars);
    Ddi_Free(totVars);
    Ddi_Free(newFrom);
  }


  Ddi_Free(myCone);
  Ddi_Free(auxFrom);

  Pdtutil_Free(myEnAbstr);

  if (abstrVars!=NULL && tryNnfCore) {
    int sizeCone = Ddi_BddSize(cone);
    if (sizeCone>0) {
    Ddi_AigOptByMonotoneCoreAcc (cone,fromAndTr,care,0,-1.0);
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm), 
      "NNF CONE COMP: %d -> %d\n", sizeCone, Ddi_BddSize(cone))
        );
    Pdtutil_Assert(!Ddi_AigSatAnd(fromAndTr,cone,care),"unsound dynABSTR");
    }
  }

  if (computeCore) {
    Ddi_MgrSetOption(ddm, Pdt_DdiDynAbstrStrategy_c, inum, strategy);
  }

  return abstrVars;

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Trav_TimeFrameInfo_t *
timeFrameInfoInit(
  Ddi_Mgr_t * ddiMgr,
  int initSize
)
{
  Trav_TimeFrameInfo_t *timeFrames = Pdtutil_Alloc(Trav_TimeFrameInfo_t, 1);

  timeFrames->Size = initSize;
  timeFrames->Num = 0;
  timeFrames->Lits = Pdtutil_Alloc(Ddi_Bddarray_t *, timeFrames->Size);
  timeFrames->vars = Pdtutil_Alloc(Ddi_Vararray_t *, timeFrames->Size);
  timeFrames->PiLits = Pdtutil_Alloc(Ddi_Bddarray_t *, timeFrames->Size);
  timeFrames->PiVars = Pdtutil_Alloc(Ddi_Vararray_t *, timeFrames->Size);
  timeFrames->Coi = Ddi_VarsetarrayAlloc(ddiMgr, 0);
  return timeFrames;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/ static void
timeFrameInfoFree(
  Trav_TimeFrameInfo_t * timeFrames
)
{
  int i;

  for (i = 0; i < timeFrames->Num; i++) {
    Ddi_Free(timeFrames->Lits[i]);
    Ddi_Free(timeFrames->vars[i]);
    Ddi_Free(timeFrames->PiLits[i]);
    Ddi_Free(timeFrames->PiVars[i]);
  }
  Ddi_Free(timeFrames->Coi);
  Pdtutil_Free(timeFrames->Lits);
  Pdtutil_Free(timeFrames->vars);
  Pdtutil_Free(timeFrames->PiLits);
  Pdtutil_Free(timeFrames->PiVars);
  Pdtutil_Free(timeFrames);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
timeFrameInfoPush(
  Trav_TimeFrameInfo_t * timeFrames,
  Ddi_Bddarray_t * lits,
  Ddi_Vararray_t * vars,
  Ddi_Bddarray_t * piLits,
  Ddi_Vararray_t * piVars,
  Ddi_Varset_t * coi
)
{
  int i = timeFrames->Num++;

  if (i >= timeFrames->Size) {
    timeFrames->Size *= 2;
    timeFrames->Lits = Pdtutil_Realloc(Ddi_Bddarray_t *,
      timeFrames->Lits, timeFrames->Size);
    timeFrames->vars = Pdtutil_Realloc(Ddi_Vararray_t *,
      timeFrames->vars, timeFrames->Size);
    timeFrames->PiLits = Pdtutil_Realloc(Ddi_Bddarray_t *,
      timeFrames->PiLits, timeFrames->Size);
    timeFrames->PiVars = Pdtutil_Realloc(Ddi_Vararray_t *,
      timeFrames->PiVars, timeFrames->Size);
  }
  timeFrames->Lits[i] = lits != NULL ? Ddi_BddarrayDup(lits) : NULL;
  timeFrames->vars[i] = vars != NULL ? Ddi_VararrayDup(vars) : NULL;
  timeFrames->PiLits[i] = Ddi_BddarrayDup(piLits);
  timeFrames->PiVars[i] = Ddi_VararrayDup(piVars);
  Ddi_VarsetarrayInsertLast(timeFrames->Coi, coi);
}



/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpMgrFindOrAddTimeFrames(
  Trav_ItpMgr_t * itpMgr,
  int nFrames,
  int timeShift,
  int useNsVars
)
{
  int i;
  Pdtutil_Assert(itpMgr->timeFrames!=NULL,"missing time frames info");
  for (i = 0; i < nFrames; i++) {
    timeFrameFindOrAdd(itpMgr->timeFrames,
      itpMgr->pi, itpMgr->ps, itpMgr->ns, itpMgr->psvars,
      timeShift + i, useNsVars, itpMgr->useAigVars);
  }
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
timeFrameFindOrAdd(
  Trav_TimeFrameInfo_t * timeFrames,
  Ddi_Vararray_t * pi,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * ns,
  Ddi_Varset_t * psVars,
  int i,
  int useNsVars,
  int useAigVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(ns);
  int j, nCoi,freePs=0;
  char name[1000];

  if (i + 1 > timeFrames->Num) {
    timeFrameFindOrAdd(timeFrames,pi,ps,ns,psVars,i-1,
		       useNsVars,useAigVars);
  }

  if ((i + 1) == timeFrames->Num) {
    Ddi_Vararray_t *newPi = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(pi));
    Ddi_Bddarray_t *newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
    Ddi_Vararray_t *newNs = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(ns));
    Ddi_Bddarray_t *newNsLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(ns));
    Ddi_Varset_t *coiSupp = Ddi_VarsetVoid(ddm);
    if (psVars==NULL) {
      freePs = 1;
      psVars = Ddi_VarsetMakeFromArray(ps);
    }
    
    Pdtutil_Assert(i + 1 == timeFrames->Num, "wrong time frames num");
    for (j = 0; j < Ddi_VararrayNum(pi); j++) {
      Ddi_Var_t *v = Ddi_VararrayRead(pi, j);
      Ddi_Var_t *newv = NULL;
      Ddi_Bdd_t *newvLit;

      Pdtutil_Assert(i>=-1,"wrong index");
      if (i==-1) 
        sprintf(name, "%s", Ddi_VarName(v));
      else
        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), i);
      newv = Ddi_VarFromName(ddm, name);
      if (newv == NULL) {
        if (!useAigVars) {
          newv = Ddi_VarNewBeforeVar(v);
          Ddi_VarAttachName(newv, name);
        } else {
          newv = Ddi_VarNewBaig(ddm, name);
        }
      }

      Ddi_VararrayWrite(newPi, j, newv);
      newvLit = Ddi_BddMakeLiteralAig(newv, 1);
      Ddi_BddarrayWrite(newPiLit, j, newvLit);
      Ddi_Free(newvLit);
    }
    for (j = 0; j < Ddi_VararrayNum(ns); j++) {
      if (useNsVars) {
        Ddi_Var_t *v = Ddi_VararrayRead(ns, j);
        Ddi_Var_t *newv = NULL;
        Ddi_Bdd_t *newvLit;

        sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), i);
        newv = Ddi_VarFromName(ddm, name);
        if (newv == NULL) {
          newv = Ddi_VarNewAfterVar(v);
          Ddi_VarAttachName(newv, name);
        }
        Ddi_VararrayWrite(newNs, j, newv);
        newvLit = Ddi_BddMakeLiteralAig(newv, 1);
        Ddi_BddarrayWrite(newNsLit, j, newvLit);
        Ddi_Free(newvLit);
      }
    }
    //      tr_i = Ddi_BddCompose(tr,pi,newPiLit);
    //      Ddi_BddComposeAcc(tr_i,ns,newNsLit);
    //      Ddi_BddComposeAcc(tr_i,ps,timeFrameLits[i]);

    if (Ddi_VarsetIsArray(coiSupp)) {
      Ddi_VarsetSetArray(psVars);
    } else if (Ddi_VarsetIsArray(psVars)) {
      Ddi_VarsetSetArray(coiSupp);
    }
    Ddi_VarsetIntersectAcc(coiSupp, psVars);
    nCoi = Ddi_VarsetNum(coiSupp);
    Ddi_VarsetSetBdd(psVars);
    Ddi_VarsetSetBdd(coiSupp);

    timeFrameInfoPush(timeFrames, useNsVars ? newNsLit : NULL,
      useNsVars ? newNs : NULL, newPiLit, newPi, coiSupp);

    Ddi_Free(newPi);
    Ddi_Free(newPiLit);
    Ddi_Free(newNs);
    Ddi_Free(newNsLit);
    Ddi_Free(coiSupp);
    if (freePs) Ddi_Free(psVars);
    
    return nCoi;
  } else if (useNsVars && (timeFrames->Lits[i] == NULL)) {
    sprintf(name, "%d", i);
    Ddi_Vararray_t *newNs = Ddi_VararrayMakeNewVars(ns, "PDT_TF_VAR", name, 0);

    timeFrames->Lits[i] = Ddi_BddarrayMakeLiteralsAig(newNs, 1);
    Ddi_Free(newNs);
  }
  return -1;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Trav_ItpTravMgr_t *
itpTravMgrInit(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Trav_ItpMgr_t * itpMgr
)
{
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Trav_ItpTravMgr_t *itpTravMgr = Pdtutil_Alloc(Trav_ItpTravMgr_t, 1);

  itpTravMgr->travMgr = travMgr;
  itpTravMgr->itpMgr = itpMgr;
  itpTravMgr->incrSat = NULL;

  itpTravMgr->from = NULL;
  itpTravMgr->from0 = NULL;
  itpTravMgr->fromBdd = NULL;
  itpTravMgr->restartFrom = NULL;
  itpTravMgr->prevStoredFrom = NULL;
  itpTravMgr->careForBwdCone = NULL;
  itpTravMgr->splitConeInfo.ring = NULL;
  itpTravMgr->splitConeInfo.preImg = NULL;
  itpTravMgr->splitConeInfo.ring_i = 0;
  itpTravMgr->conePiConstr = NULL;
  itpTravMgr->coneSubsetTop = NULL;
  itpTravMgr->reached = NULL;
  itpTravMgr->trArray = NULL;
  itpTravMgr->trAux = NULL;
  itpTravMgr->to = NULL;
  itpTravMgr->toItpSeq = NULL;
  itpTravMgr->cone = NULL;
  itpTravMgr->careFwd = NULL;
  itpTravMgr->prevTo = NULL;
  itpTravMgr->prevFrom = NULL;
  itpTravMgr->currFrom = NULL;
  itpTravMgr->careBwd = NULL;
  itpTravMgr->fwdUnroll = NULL;
  itpTravMgr->prevFwdUnroll = NULL;
  itpTravMgr->noDynAbstr = Ddi_VararrayAlloc(ddm, 0);

  itpTravMgr->constrainVars = NULL;
  itpTravMgr->constrainSubstLits = NULL;
  itpTravMgr->saveConstrainVars = NULL;
  itpTravMgr->saveConstrainSubstLits = NULL;
  itpTravMgr->imgPartVars = NULL;
  itpTravMgr->itpSatHints = NULL;
  itpTravMgr->observedGates = NULL;

  itpTravMgr->settings.bwdReach_k = 0;
  itpTravMgr->settings.computeRestartFrom = 0;
  itpTravMgr->settings.innerWithReducedCone = 0;
  itpTravMgr->settings.useInitStub = 0;
  itpTravMgr->settings.itpExact = Trav_MgrReadItpExact(travMgr);
  itpTravMgr->settings.enConcurTr = itpMgr->concurTr != NULL;
  itpTravMgr->settings.storeRings = Trav_MgrReadItpReuseRings(travMgr);

  itpTravMgr->settings.newConstrain =
    (Ddi_MgrReadAigDynAbstrStrategy(ddm) <= 1 &&
    !itpTravMgr->settings.storeRings);

  itpTravMgr->settings.implAbstr = Trav_MgrReadImplAbstr(travMgr);
  itpTravMgr->settings.useInvarFull = 0;
  itpTravMgr->settings.tryInnerRing = -2;
  itpTravMgr->settings.useBwdReachAsCone = 0;
  itpTravMgr->settings.enItpSeq = 0;
  itpTravMgr->settings.abstrRef = Trav_MgrReadAbstrRef(travMgr) % 100;
  itpTravMgr->settings.abstrRefGla = Trav_MgrReadAbstrRefGla(travMgr);
  itpTravMgr->settings.checkCompleteness =
    Trav_MgrReadItpCheckCompleteness(travMgr);


  itpTravMgr->stats.fwdUnrollSize = -1;
  itpTravMgr->stats.step = 0;
  itpTravMgr->stats.coneHit = 0;
  itpTravMgr->stats.conePiConstrTf_i = 0;
  itpTravMgr->stats.conePiConstrStep = 0;

  return itpTravMgr;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
itpTravMgrFree(
  Trav_ItpTravMgr_t * itpTravMgr
)
{
  Ddi_Free(itpTravMgr->from);
  Ddi_Free(itpTravMgr->from0);
  Ddi_Free(itpTravMgr->fromBdd);
  Ddi_Free(itpTravMgr->restartFrom);
  Ddi_Free(itpTravMgr->prevStoredFrom);
  Ddi_Free(itpTravMgr->careForBwdCone);
  Ddi_Free(itpTravMgr->splitConeInfo.ring);
  Ddi_Free(itpTravMgr->splitConeInfo.preImg);
  Ddi_Free(itpTravMgr->conePiConstr);
  Ddi_Free(itpTravMgr->coneSubsetTop);
  Ddi_Free(itpTravMgr->reached);
  Ddi_Free(itpTravMgr->trArray);
  Ddi_Free(itpTravMgr->trAux);
  Ddi_Free(itpTravMgr->to);
  Ddi_Free(itpTravMgr->toItpSeq);
  Ddi_Free(itpTravMgr->cone);
  Ddi_Free(itpTravMgr->careFwd);
  Ddi_Free(itpTravMgr->prevTo);
  Ddi_Free(itpTravMgr->prevFrom);
  Ddi_Free(itpTravMgr->currFrom);
  Ddi_Free(itpTravMgr->careBwd);
  Ddi_Free(itpTravMgr->fwdUnroll);
  Ddi_Free(itpTravMgr->prevFwdUnroll);
  Ddi_Free(itpTravMgr->noDynAbstr);

  Ddi_Free(itpTravMgr->constrainVars);
  Ddi_Free(itpTravMgr->constrainSubstLits);
  Ddi_Free(itpTravMgr->saveConstrainVars);
  Ddi_Free(itpTravMgr->saveConstrainSubstLits);
  Ddi_Free(itpTravMgr->imgPartVars);
  Ddi_Free(itpTravMgr->itpSatHints);
  Ddi_Free(itpTravMgr->observedGates);

  if (itpTravMgr->incrSat!=NULL) {
    Ddi_IncrSatMgrQuit(itpTravMgr->incrSat);
  }
  
  Pdtutil_Free(itpTravMgr);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
itpAbstrRefInit(
  Trav_ItpMgr_t * itpMgr
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  int jj, i, j;
  Ddi_Bddarray_t *abstrRefCtrlAux = NULL;
  Ddi_Vararray_t *abstrRefCtrlRefined = NULL;
  Ddi_Vararray_t *substVars = NULL, *abstrVars = NULL, *abstrFreePis = NULL;
  Ddi_Bddarray_t *abstrRefLits = NULL;
  Ddi_Bddarray_t *muxes = NULL;
  Ddi_Varset_t *voidVarset = NULL;
  Ddi_Bdd_t *deltaProp = NULL;
  int nCtrl;
  Ddi_Bdd_t *c1 = NULL, *c0 = NULL;
  int glaProp = 0, gla = itpMgr->abstrRefGla, disAbstrRef = 0;

  int abstrCnt[4] = {
    0, 0, 0, 0
  };
  int abstrOut = 1;
  int abstrSccDual = 0;
  int nState = Ddi_VararrayNum(itpMgr->ps);

  if (!itpMgr->abstrRef)
    return 0;

  if (glaProp>0) {
    if (glaProp>100) {
      glaProp -= 100;
    }
    else {
      disAbstrRef = 1;
    }
  }

  substVars = Ddi_VararrayAlloc(ddm, 0);
  muxes = Ddi_BddarrayAlloc(ddm, 0);

  voidVarset = Ddi_VarsetVoid(ddm);
  c1 = Ddi_BddMakeConstAig(ddm, 1);
  c0 = Ddi_BddMakeConstAig(ddm, 0);

  if (itpMgr->abstrRef > 2) {
    itpMgr->abstrRefScc = 1;
    travMgr->settings.aig.abstrRef -= 2;
    itpMgr->abstrRef -= 2;
    if (itpMgr->abstrRef > 2) {
      abstrOut = 0;
      itpMgr->abstrRefScc = 2;
      travMgr->settings.aig.abstrRef -= 2;
      itpMgr->abstrRef -= 2;
      if (itpMgr->abstrRef > 2) {
        abstrOut = 1;
        abstrSccDual = 1;
        itpMgr->abstrRefScc = 3;
        travMgr->settings.aig.abstrRef -= 2;
        itpMgr->abstrRef -= 2;
      }
    }
  }

  nCtrl = itpMgr->abstrRefScc == 3 ? 3 : 1;

  itpMgr->abstrRefFilter = Ddi_BddarrayAlloc(ddm, 0);
  itpMgr->abstrDoAbstr = Ddi_BddarrayAlloc(ddm, 0);
  itpMgr->abstrDoRefine = Ddi_BddarrayAlloc(ddm, 0);
  itpMgr->abstrRefInp = Ddi_VararrayAlloc(ddm, 0);
  itpMgr->abstrRefCtrl = Ddi_VararrayAlloc(ddm, 0);
  itpMgr->abstrRefPsPiVars = Ddi_VararrayAlloc(ddm, 0);
  itpMgr->abstrRefRefinedVars = Ddi_VarsetarrayAlloc(ddm, 2);

  if (itpMgr->abstrRefScc > 2) {
    abstrRefCtrlAux = Ddi_BddarrayAlloc(ddm, 0);
    abstrRefCtrlRefined = Ddi_VararrayAlloc(ddm, 0);
  }

  Ddi_VarsetarrayWrite(itpMgr->abstrRefRefinedVars, 0, voidVarset);
  Ddi_VarsetarrayWrite(itpMgr->abstrRefRefinedVars, 1, voidVarset);
  Ddi_Free(voidVarset);

  if (Trav_MgrReadAbstrRefRefinedVars(travMgr) != NULL) {
    Ddi_Varset_t *refinedVars =
      Ddi_VarsetarrayRead(Trav_MgrReadAbstrRefRefinedVars(travMgr), 0);
    Ddi_VarsetUnionAcc(Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars,
        0), refinedVars);
    refinedVars =
      Ddi_VarsetarrayRead(Trav_MgrReadAbstrRefRefinedVars(travMgr), 1);
    if (refinedVars != NULL) {
      Ddi_VarsetUnionAcc(Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars,
          1), refinedVars);
    }
  }

  Ddi_VarsetCheckMark(Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 0), 0);
  Ddi_VarsetCheckMark(Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 1), 0);

  Ddi_VarsetIncrMark(Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 0), 1);
  Ddi_VarsetIncrMark(Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 1), 2);


  if (itpMgr->abstrRefNnf) {
    int doAbstrState = 1;
    itpMgr->nnf.pi0 = Ddi_NnfDualRailVars(itpMgr->pi, 0);
    itpMgr->nnf.ps0 = Ddi_NnfDualRailVars(itpMgr->ps, 0);
    itpMgr->nnf.ns0 = Ddi_NnfDualRailVars(itpMgr->ns, 0);
    itpMgr->nnf.pi2 = Ddi_NnfDualRailVars(itpMgr->pi, 2);
    itpMgr->nnf.ps2 = Ddi_NnfDualRailVars(itpMgr->ps, 2);
    itpMgr->nnf.ns2 = Ddi_NnfDualRailVars(itpMgr->ns, 2);
    itpMgr->nnf.deltaAbstr =
      Ddi_AigarrayNnf(itpMgr->delta, NULL, NULL, NULL, NULL, NULL, NULL);

    if ((itpMgr->abstrRefNnf > 1)) {
      doAbstrState = 0;
      abstrVars = Ddi_VararrayDup(itpMgr->nnf.pi2);
    }
    else {
      abstrVars = Ddi_VararrayDup(itpMgr->nnf.ps2);
      Ddi_VararrayAppend(abstrVars, itpMgr->nnf.pi2);
    }
    abstrFreePis = Ddi_VararrayAlloc(ddm, Ddi_VararrayNum(abstrVars));
    abstrRefLits = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(abstrVars));
    // over-refine twin vars
    for (j = 0; j < Ddi_VararrayNum(abstrVars); j += 2) {
      Ddi_Var_t *v1 = Ddi_VararrayRead(abstrVars, j);
      Ddi_Var_t *v0 = Ddi_VararrayRead(abstrVars, j + 1);

      if (Ddi_VarReadMark(v1) && !Ddi_VarReadMark(v0)) {
        Pdtutil_Assert(Ddi_VarReadMark(v1) == 1,
          "wrong var mark for this setting");
        Ddi_VarWriteMark(v0, 1);
      } else if (Ddi_VarReadMark(v0) && !Ddi_VarReadMark(v1)) {
        Pdtutil_Assert(Ddi_VarReadMark(v0) == 1,
          "wrong var mark for this setting");
        Ddi_VarWriteMark(v1, 1);
      }
    }
    for (j = 0; j < Ddi_VararrayNum(abstrVars); j++) {
      Ddi_Bdd_t *refLit;

      if (!doAbstrState) {
        refLit = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(itpMgr->pi,
            j / 2), (j + 1) % 2);
        //        Ddi_VararrayWrite(abstrFreePis,j,Ddi_VararrayRead(itpMgr->nnf.pi0,j-2*nState));
        Ddi_VararrayWrite(abstrFreePis, j, NULL);
      }
      else if (j < 2 * nState) {
        refLit =
          Ddi_BddMakeLiteralAig(Ddi_VararrayRead(itpMgr->nnf.ps2, j), 1);
        Ddi_VararrayWrite(abstrFreePis, j, NULL);
      } else {
        refLit = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(itpMgr->pi,
            (j - 2 * nState) / 2), (j + 1) % 2);
        //        Ddi_VararrayWrite(abstrFreePis,j,Ddi_VararrayRead(itpMgr->nnf.pi0,j-2*nState));
        Ddi_VararrayWrite(abstrFreePis, j, NULL);
      }
      Ddi_BddarrayWrite(abstrRefLits, j, refLit);
      Ddi_Free(refLit);
    }
  } else if (glaProp && disAbstrRef) {
    abstrVars = Ddi_VararrayAlloc(ddm, 0);
    abstrRefLits = Ddi_BddarrayAlloc(ddm, 0);
  } else {
    abstrVars = Ddi_VararrayDup(itpMgr->ps);
    abstrRefLits = Ddi_BddarrayMakeLiteralsAig(itpMgr->ps, 1);
  }

  for (j = jj = 0; j < Ddi_VararrayNum(abstrVars); j++) {
    Ddi_Bdd_t *inpLit, *refLit, *ctrlLit, *mux_i = NULL, *lit_i;
    char name[1000];
    Ddi_Var_t *v = Ddi_VararrayRead(abstrVars, j);
    Ddi_Var_t *newi, *refi, *newc;
    int nCut = nCtrl - Ddi_VarReadMark(v);
    int ii, nIter;

    Pdtutil_Assert(nCut >= 0, "wrong abstrRef nCut");

    if (nCut == 0)
      continue;

    abstrCnt[nCut]++;

    newi = abstrFreePis == NULL ? NULL : Ddi_VararrayRead(abstrFreePis, j);
    if (newi == NULL) {
      sprintf(name, "abstrRefInp_%s", Ddi_VarName(v));
      newi = Ddi_VarFindOrAdd(ddm, name, 0);
    }
    refLit = Ddi_BddarrayRead(abstrRefLits, j);
    Ddi_VararrayInsertLast(itpMgr->abstrRefInp, newi);
    inpLit = Ddi_BddMakeLiteralAig(newi, 1);
    nIter = nCut == 1 ? 1 : 2;
    for (ii = 0; ii < nIter; ii++) {
      Ddi_VararrayWrite(itpMgr->abstrRefPsPiVars, jj, v);
      sprintf(name, "abstrRefCtrl%s_%s", ii == 0 ? "" : "1", Ddi_VarName(v));
      newc = Ddi_VarFindOrAdd(ddm, name, 0);
      Ddi_VararrayWrite(itpMgr->abstrRefCtrl, jj, newc);
      ctrlLit = Ddi_BddMakeLiteralAig(newc, 1);
      if (ii == 0) {
        mux_i = Ddi_BddIte(ctrlLit, inpLit, refLit);
      }
      Ddi_BddarrayWrite(itpMgr->abstrRefFilter, jj, ctrlLit);
      Ddi_BddarrayWrite(itpMgr->abstrDoAbstr, jj, c1);
      Ddi_BddarrayWrite(itpMgr->abstrDoRefine, jj, c0);

      if (abstrRefCtrlAux != NULL) {
        Ddi_BddarrayWrite(abstrRefCtrlAux, jj, c0);
        if (ii == 1 && nCut >= 2) {
          Pdtutil_Assert(jj > 0, "wrong index");
          Ddi_BddarrayWrite(abstrRefCtrlAux, jj - 1, ctrlLit);
          Ddi_BddarrayWrite(abstrRefCtrlAux, jj, c1);
        }
      }

      Ddi_Free(inpLit);
      Ddi_Free(ctrlLit);
      if (ii == 0 && nCut == 2) {
        // control var used as reference for substitution. Marked refine
        Ddi_BddNotAcc(Ddi_BddarrayRead(itpMgr->abstrDoAbstr, jj));
        Ddi_VararrayInsertLast(abstrRefCtrlRefined, newc);
      }
      jj++;
    }

    Pdtutil_Assert(mux_i != NULL, "NULL mux");
    Ddi_BddarrayInsertLast(muxes, mux_i);
    Ddi_VararrayInsertLast(substVars, v);
    Ddi_Free(mux_i);
  }

  Ddi_Vararray_t *auxV = Fsm_MgrReadVarAuxVar(itpMgr->fsmMgr);
  if (0 && auxV!=NULL) {
    int na = Ddi_VararrayNum(abstrVars);
    itpMgr->abstrPrioRefine = Ddi_BddarrayAlloc(ddm, na);
    Ddi_VararrayWriteMark(auxV, 1);
    for (int j = 0; j < na; j++) {
      Ddi_Var_t *v = Ddi_VararrayRead(abstrVars, j);
      if (Ddi_VarReadMark(v)) {
        Ddi_BddarrayWrite(itpMgr->abstrPrioRefine, j, c1);
        itpMgr->abstrPrioRefineNum++;
      }
      else 
        Ddi_BddarrayWrite(itpMgr->abstrPrioRefine, j, c0);
    }
    Ddi_VararrayWriteMark(auxV, 0);
  }
  
  if (glaProp) {
    int iProp = Ddi_VararrayNum(itpMgr->ps)-1;
    Ddi_Var_t *vProp = Ddi_VararrayRead(itpMgr->ps,iProp);
    /* Filter out PDT control vars */
    if (Ddi_VarName(vProp) != NULL &&
	(strcmp(Ddi_VarName(vProp), "PDT_BDD_INVARSPEC_VAR$PS") == 0)) {
      deltaProp = 
	Ddi_BddDup(Ddi_BddarrayRead(itpMgr->delta,iProp));
      Ddi_BddCofactorAcc(deltaProp,vProp,1);
    }
    else {
      glaProp=0;
      Pdtutil_Warning(1,"prop var not found: gla prop disabled");
    }
  }
  if (gla || glaProp) {
    Ddi_Bddarray_t *enables = (glaProp) ? 
      Ddi_FindPropCut(deltaProp, itpMgr->ps, itpMgr->delta, glaProp) :
      Ddi_FindIte(itpMgr->delta, itpMgr->ps, -1);

    Ddi_Bddarray_t *tmp = Ddi_AigarrayFindXors(itpMgr->delta,NULL,0);
    Ddi_Free(tmp);

    Ddi_Vararray_t *cutVars;
    Ddi_Vararray_t *cutCtrl;
    int i, ne = Ddi_BddarrayNum(enables);
    Ddi_Bddarray_t *muxesGla = Ddi_BddarrayAlloc(ddm, ne);
    char name[100];
    int chk=1;

    Pdtutil_Assert(itpMgr->abstrRefNnf==0,
		   "nnf abstr not supported with gla");
    cutVars = Ddi_VararrayAlloc(ddm, ne);
    cutCtrl = Ddi_VararrayAlloc(ddm, ne);

    Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelUsrMax_c) {
      fprintf(tMgrO(travMgr), "GLA - using %d gate cuts\n", ne);
    }

    for (i=0; i<ne; i++) {
      Ddi_Var_t *vInp, *vCtrl;
      Ddi_Bdd_t *inpLit, *ctrlLit, *refLit, *mux_i;
      sprintf(name,"abstrRefInp_PDT_ENABLE_CUT_VAR_%d", i);
      vInp = Ddi_VarFindOrAdd(ddm, name, 0);
      Ddi_VararrayWrite(cutVars,i,vInp);
      sprintf(name,"abstrRefCtrl_PDT_ENABLE_CUT_VAR_%d", i);
      vCtrl = Ddi_VarFindOrAdd(ddm, name, 0);
      Ddi_VararrayWrite(cutCtrl,i,vCtrl);

      inpLit = Ddi_BddMakeLiteralAig(vInp, 1);
      ctrlLit = Ddi_BddMakeLiteralAig(vCtrl, 1);
      refLit = Ddi_BddarrayRead(enables,i);
 
      mux_i = Ddi_BddIte(ctrlLit, inpLit, refLit);

      Ddi_VararrayInsertLast(itpMgr->abstrRefInp, vInp);
      Ddi_VararrayInsertLast(itpMgr->abstrRefCtrl, vCtrl);
      Ddi_BddarrayInsertLast(itpMgr->abstrRefFilter, ctrlLit);
      Ddi_BddarrayInsertLast(itpMgr->abstrDoAbstr, c1);
      Ddi_BddarrayInsertLast(itpMgr->abstrDoRefine, c0);

      Ddi_BddarrayWrite(muxesGla, i, mux_i);
      Ddi_Free(mux_i);
      Ddi_Free(ctrlLit);
      Ddi_Free(inpLit);
    }
    Ddi_Bddarray_t *newD = Ddi_AigarrayInsertCuts (itpMgr->delta, enables, cutVars);
    Ddi_BddarrayComposeAcc(newD,cutVars,muxesGla);
    if (itpMgr->delta0==NULL)
      itpMgr->delta0 = Ddi_BddarrayDup(itpMgr->delta);
    Ddi_DataCopy(itpMgr->delta,newD);

    Ddi_Free(muxesGla);
    Ddi_Free(newD);
    Ddi_Free(cutVars);
    Ddi_Free(cutCtrl);
    Ddi_Free(enables);
  }

  Ddi_Free(deltaProp);

  Ddi_VarsetWriteMark(Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 0), 0);
  Ddi_VarsetWriteMark(Ddi_VarsetarrayRead(itpMgr->abstrRefRefinedVars, 1), 0);
  Ddi_VararrayWriteMark(abstrVars, 0);

  if (itpMgr->abstrRefNnf) {
    Ddi_Bddarray_t *chkD;
    Ddi_Vararray_t *freePis = Ddi_VararrayDiff(itpMgr->pi, substVars);

    Ddi_BddarrayComposeAcc(itpMgr->nnf.deltaAbstr, substVars, muxes);
    chkD = Ddi_BddarrayCompose(itpMgr->nnf.deltaAbstr,
      itpMgr->abstrRefCtrl, itpMgr->abstrDoRefine);
    Pdtutil_Assert(Ddi_AigarrayNnfCheck(chkD,NULL), "wrong nnf");
    // refine free PIs that are not abstracted
    Ddi_Free(chkD);
    if (Ddi_VararrayNum(freePis) > 0) {
      Ddi_BddarrayAigFromNnfAcc(itpMgr->nnf.deltaAbstr, freePis, NULL, 0);
    }
    itpMgr->deltaAbstr =
      Ddi_BddarrayAigFromNnf(itpMgr->nnf.deltaAbstr, itpMgr->ps, NULL, 1);
    Ddi_Free(freePis);
    // refine abstr PIs
#if 1
    Ddi_BddarrayAigFromNnfAcc(itpMgr->deltaAbstr, itpMgr->pi,
      "abstrRefInp", 0);
    Ddi_BddarrayAigFromNnfAcc(itpMgr->deltaAbstr, itpMgr->ps,
      "abstrRefInp", 0);
#endif
  } else {
    itpMgr->deltaAbstr = Ddi_BddarrayCompose(itpMgr->delta, substVars, muxes);
  }

  Ddi_Free(abstrVars);
  Ddi_Free(abstrFreePis);
  Ddi_Free(abstrRefLits);

  Ddi_Free(substVars);
  Ddi_Free(muxes);

  Ddi_VararrayUnionAcc(itpMgr->pi, itpMgr->abstrRefInp);

  int printDeltaInfo = 0;
  if (printDeltaInfo) {
    int i, n=0;
    Ddi_Varset_t *in = Ddi_VarsetVoid(ddm);
    Ddi_Varset_t *out = Ddi_VarsetVoid(ddm);
    for (i=0; i<Ddi_BddarrayNum(itpMgr->delta); i++) {
      Ddi_Bdd_t *d_i = Ddi_BddarrayRead(itpMgr->delta,i);
      Ddi_Varset_t *s = Ddi_BddSupp(d_i);
      if (Ddi_VarsetNum(s)==1) {
	Ddi_Var_t *vo = Ddi_VararrayRead(itpMgr->ps,i);
	Ddi_Var_t *v = Ddi_VarsetTop(s);
	printf("latch: %s <- %s\n", Ddi_VarName(vo),
	       Ddi_VarName(v));
	//	DdiLogBdd(d_i,0);
	Ddi_VarsetAddAcc(out,vo);
	Ddi_VarsetAddAcc(in,v);
	n++;
      }
      Ddi_Free(s);
    }
    printf("N 1: %d\n", n);
    printf("input latches:\n");
    Ddi_VarsetPrint(in,NULL,NULL,stdout);
    printf("output latches:\n");
    Ddi_VarsetPrint(out,NULL,NULL,stdout);
    Ddi_VarsetIntersectAcc(in,out);
    printf("inout latches:\n");
    Ddi_VarsetPrint(in,NULL,NULL,stdout);
    Ddi_Free(in);
    Ddi_Free(out);

    //    Ddi_FindIte(itpMgr->delta, itpMgr->ps);
  }


  itpMgr->levelizeSccs = 1;
  if (itpMgr->levelizeSccs) {
    bAig_Manager_t *bmgr = ddm->aig.mgr;
    Ddi_Vararray_t *abstrRefSccCtrlV;
    Ddi_Bddarray_t *constArray;
    Ddi_SccMgr_t *sccMgr = Ddi_FsmSccTarjan(itpMgr->delta, NULL, itpMgr->ps);
    int maxScc=-1, maxSccBit=-1;
    int iScc, bit, n;

    int printByLevel = 0;

    if (printByLevel) {
      int level, maxl = -1;
      int i, j, ni = Ddi_VararrayNum(itpMgr->pi);
      int *countPi = Pdtutil_Alloc(int,ni);
      char *singleLatchScc = Pdtutil_Alloc(char,sccMgr->nScc);
      int singleLatchFilter = 2;
      for (i = 0; i < sccMgr->nScc; i++) {
	if (sccMgr->sccLatchCnt[i]==0) continue;
	int bit = sccMgr->mapSccBit[i];
	Pdtutil_Assert(bit>=0 && bit<sccMgr->nScc,"wrong scc bit");
	if (singleLatchFilter>1)
	  singleLatchScc[bit] = (char)(sccMgr->sccLatchCnt[i] <= 1);
	else {
	  singleLatchScc[bit] = (char)(sccMgr->sccLatchCnt[i] <= 1);
	  singleLatchScc[bit] &= (char)(sccMgr->sccGateCnt[i] <= 1);
	}
      }

      itpMgr->sccs.inCoreScc = Ddi_VararrayAlloc(ddm,0);

      for (i=0; i<ni; i++) countPi[i]=0;

      for (j = 0; j < sccMgr->nLatches; j++) {
	Ddi_Var_t *psV = Ddi_VararrayRead(itpMgr->ps, j);
	int bit = sccMgr->mapLatches[j];
	Pdtutil_Assert(bit>=0 && bit<sccMgr->nScc,"wrong scc bit");
	if (!singleLatchScc[bit] || 
	    strncmp("PDT_BDD_",Ddi_VarName(psV),8)==0) {
          Ddi_VararrayInsertLast(itpMgr->sccs.inCoreScc,psV);
        }
      }
      
      Pdtutil_Free(singleLatchScc);

      for (iScc = 0; iScc<sccMgr->nScc; iScc++) {
	level = sccMgr->sccTopologicalLevel[iScc];
	if (level>maxl) maxl = level;
      }

      if (0)
      for (level=maxl; level>=0; level--) {
	for (iScc = 0; iScc<sccMgr->nScc; iScc++) {
	  if (level == sccMgr->sccTopologicalLevel[iScc]) {
	    int j, nl = sccMgr->sccLatchCnt[iScc];
	    bit = sccMgr->mapSccBit[iScc];
	    printf("Scc: %5d - NL: %5d - level: %5d\n", iScc, 
		   nl, level);
	    for (j = 0; j < sccMgr->nLatches; j++) {
	      Ddi_Var_t *psV = Ddi_VararrayRead(itpMgr->ps, j);
	      int scc_j = sccMgr->mapLatches[j];
	      if (scc_j == bit) {
		printf(" %s", Ddi_VarName(psV));
	      }
	    }
	    if (sccMgr->sccLatchCnt[iScc]==0)
	      for (i=0; i<sccMgr->sccTopologicalNodes->num; i++) {
		bAigEdge_t baig = sccMgr->sccTopologicalNodes->nodes[i];
		int scc_j = sccMgr->mapScc[i];
		if(bAig_isVarNode(bmgr, baig)){
		  Ddi_Var_t *v = Ddi_VarFromBaig(ddm,baig);
		  if (scc_j == iScc) {
		    printf(" %s", Ddi_VarName(v));
		  }
		}
	      }
	    printf("\n");
	  }
	}
      }
      Pdtutil_Free(countPi);
    }

    if (0) {
      for (iScc = 0; iScc<sccMgr->nScc; iScc++) {
	if (maxScc<0 || 
	    sccMgr->sccLatchCnt[iScc]>sccMgr->sccLatchCnt[maxScc]) {
	  maxScc = iScc;
	}
	bit = sccMgr->mapSccBit[iScc];
	if (maxScc>=0) {
	  maxSccBit = sccMgr->mapSccBit[maxScc];
	}
	if (sccMgr->sccLatchCnt[iScc]==1)
	for (j = 0; j < sccMgr->nLatches; j++) {
	  Ddi_Var_t *psV = Ddi_VararrayRead(itpMgr->ps, j);
	  int level = sccMgr->sccLatchTopologicalLevel[j];
	  int scc_j = sccMgr->mapLatches[j];
	  if (scc_j == bit) {
	    printf("Scc: %5d - L: level: %5d - %s\n", iScc, 
		   level, Ddi_VarName(psV));
	  }
	}
      }
    }
    
    if (maxSccBit>=0) {
      abstrRefSccCtrlV = Ddi_VararrayAlloc(ddm, 0);

      for (j = 0; j < sccMgr->nLatches; j++) {
        Ddi_Var_t *psV = Ddi_VararrayRead(itpMgr->ps, j);
        int level = sccMgr->sccLatchTopologicalLevel[j];
        int bit_j = sccMgr->mapLatches[j];
        if (bit_j==maxSccBit) {
          Ddi_Var_t *ctrlV = Ddi_VararrayRead(itpMgr->abstrRefCtrl,j);
          Ddi_VararrayInsertLast(abstrRefSccCtrlV,ctrlV);
        }
      }
      n = Ddi_VararrayNum(abstrRefSccCtrlV);
      constArray = Ddi_BddarrayMakeConstAig(ddm,n,0);
      Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelUsrMax_c) {
        fprintf(tMgrO(travMgr), 
                "SCC refined (by level) %d/%d latches\n",
                n, sccMgr->nLatches);
      }
	
      Ddi_BddarrayComposeAcc(itpMgr->deltaAbstr, abstrRefSccCtrlV,
			   constArray);

      Ddi_SccMgrFree(sccMgr);
      Ddi_Free(abstrRefSccCtrlV);
      Ddi_Free(constArray);
    }
  }

  if (itpMgr->abstrRefScc > 0) {
    int refineSingleLatchDeltas=0;
    Ddi_Bddarray_t *abstrRefSccCtrl, *filteredDelta;
    Ddi_SccMgr_t *sccMgr = Ddi_FsmSccTarjan(itpMgr->delta, NULL, itpMgr->ps);
    Ddi_Vararray_t *finalSupp;

    Pdtutil_Assert(sccMgr->nLatches == Ddi_VararrayNum(itpMgr->ps),
      "wrong n of latches");

    if (refineSingleLatchDeltas) {
      char *singleLatchScc = Pdtutil_Alloc(char,sccMgr->nScc);
      int cnt;

      for (i = 0; i < sccMgr->nScc; i++) {
	if (sccMgr->sccLatchCnt[i]==0) continue;
	int bit = sccMgr->mapSccBit[i];
	Pdtutil_Assert(bit>=0 && bit<sccMgr->nScc,"wrong scc bit");
	if (refineSingleLatchDeltas>1)
	  singleLatchScc[bit] = (char)(sccMgr->sccLatchCnt[i] <= 1);
	else {
	  singleLatchScc[bit] = (char)(sccMgr->sccLatchCnt[i] <= 1);
	  singleLatchScc[bit] &= (char)(sccMgr->sccGateCnt[i] <= 1);
	}
      }
      filteredDelta = Ddi_BddarrayDup(itpMgr->deltaAbstr);

      if (itpMgr->hints.hintsEnabled) {
	int j = itpMgr->hints.invar0_i;
	singleLatchScc[j] = 0;
	sccMgr->mapLatches[j] = j;
      }
      for (j = cnt = 0; j < sccMgr->nLatches; j++) {
	int bit = sccMgr->mapLatches[j];
	Pdtutil_Assert(bit>=0 && bit<sccMgr->nScc,"wrong scc bit");
	if (singleLatchScc[bit]) {
	  cnt++;
	}
	else {
	  Ddi_BddarrayWrite(filteredDelta, j, c0);
	}
      }
      Ddi_BddarrayComposeAcc(filteredDelta, itpMgr->abstrRefCtrl,
			     itpMgr->abstrDoRefine);
      for (j = 0; j < sccMgr->nLatches; j++) {
	int bit = sccMgr->mapLatches[j];
	Pdtutil_Assert(bit>=0 && bit<sccMgr->nScc,"wrong scc bit");
	if (singleLatchScc[bit]) {
          // latch within scc
          Ddi_BddarrayWrite(itpMgr->deltaAbstr, j,
            Ddi_BddarrayRead(filteredDelta, j));
        }
      }
      Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelUsrMax_c) {
	fprintf(tMgrO(travMgr), 
		"fully refined deltas for %d/%d single latch SCCs\n",
		cnt, sccMgr->nLatches);
      }
      Ddi_Free(filteredDelta);
      Pdtutil_Free(singleLatchScc);
    }

    /* just mark enabled variables (not yet refined */
    for (j = 0; j < Ddi_VararrayNum(itpMgr->abstrRefPsPiVars); j++) {
      Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->abstrRefPsPiVars, j);

      if (abstrRefCtrlAux == NULL ||
        !Ddi_BddIsOne(Ddi_BddarrayRead(abstrRefCtrlAux, j))) {
        Ddi_VarWriteMark(v, j + 1);
      }
    }

    for (i = 0; i < sccMgr->nScc; i++) {
      int j, cnt;
      int bit = sccMgr->mapSccBit[i];

      // latches in single latch scc are handled with standard abstr/ref 
      if (sccMgr->sccLatchCnt[i] <= 1)
        continue;
      /* here we just have SCCs with >1 latches */
      abstrRefSccCtrl = Ddi_BddarrayMakeLiteralsAig(itpMgr->abstrRefCtrl, 1);
      filteredDelta = Ddi_BddarrayDup(itpMgr->deltaAbstr);
      for (j = cnt = 0; j < sccMgr->nLatches; j++) {
        Ddi_Var_t *psV = Ddi_VararrayRead(itpMgr->ps, j);
        Ddi_Bdd_t *newCtrl = c0; /* ctrl=0 means refine (1: abstract) */

        if (sccMgr->mapLatches[j] == bit) {
          int jj = Ddi_VarReadMark(psV) - 1;

          // latch within scc
          if (jj >= 0) {
            // connect latch (not abstracted) or replace control
            if (itpMgr->abstrRefScc > 2) {
              // replace control
              newCtrl = Ddi_BddarrayRead(abstrRefCtrlAux, jj);
            }
	    // only latches in Scc refined - other latches abstracted
            Ddi_BddarrayWrite(abstrRefSccCtrl, jj, newCtrl);
          }
          if (!abstrOut) {
            // deltas inside SCC are kept as they are - others zeroed
            Ddi_BddarrayWrite(filteredDelta, j, c0);
          }
          cnt++;
        } else {
          if (abstrOut) {
            // deltas outside SCC are kept as they are
            Ddi_BddarrayWrite(filteredDelta, j, c0);
          }
        }
      }
      Pdtutil_Assert(cnt == sccMgr->sccLatchCnt[i], "wrong scc latch num");
      // abstrOut = 0: refining (removing mux ctrl) deltas out of SCC
      // abstrOut = 1: refining (removing mux ctrl) deltas within SCC
      // just latches in SCC are connected/refined
      Ddi_BddarrayComposeAcc(filteredDelta, itpMgr->abstrRefCtrl,
        abstrRefSccCtrl);
      for (j = 0; j < sccMgr->nLatches; j++) {
        int write = abstrOut ? sccMgr->mapLatches[j] == bit :
          sccMgr->mapLatches[j] != bit;

        if (write) {
          // latch within scc
          Ddi_BddarrayWrite(itpMgr->deltaAbstr, j,
            Ddi_BddarrayRead(filteredDelta, j));
        }
      }

      Ddi_Free(abstrRefSccCtrl);
      Ddi_Free(filteredDelta);
    }

    // now all deltas out of considered abstraction have ctrl disabled
    Ddi_VararrayWriteMark(itpMgr->abstrRefPsPiVars, 0);

    if (1 && itpMgr->hints.hintsEnabled) {
      Ddi_Vararray_t *doRef = Ddi_VararrayIntersect(itpMgr->hints.hintsVars,itpMgr->ps);
      Ddi_VararraySubstVarsAcc(doRef,itpMgr->ps,
			       itpMgr->abstrRefCtrl);
      if (abstrRefCtrlRefined == NULL) {
	abstrRefCtrlRefined = Ddi_VararrayAlloc(ddm, 0);
      }
      Ddi_VararrayUnionAcc(abstrRefCtrlRefined,doRef);
      Ddi_Free(doRef);
    }

    if (abstrRefCtrlRefined != NULL &&
      Ddi_VararrayNum(abstrRefCtrlRefined) > 0) {
      int n = Ddi_VararrayNum(abstrRefCtrlRefined);
      Ddi_Bddarray_t *constArray = Ddi_BddarrayAlloc(ddm, n);

      for (j = 0; j < n; j++) {
        Ddi_BddarrayWrite(constArray, j, c0);
      }
      /* set previously refined deltas */
      Ddi_BddarrayComposeAcc(itpMgr->deltaAbstr,
        abstrRefCtrlRefined, constArray);
      Ddi_Free(constArray);
    }

    finalSupp = Ddi_BddarraySuppVararray(itpMgr->deltaAbstr);
    Ddi_VararrayIntersectAcc(finalSupp, itpMgr->abstrRefCtrl);
    Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelUsrMax_c) {
      fprintf(tMgrO(travMgr), "residual abstr latches %d/%d\n",
        Ddi_VararrayNum(finalSupp), sccMgr->nLatches);
    }
    Ddi_Free(finalSupp);

    Ddi_SccMgrFree(sccMgr);
    Ddi_Free(c0);
  }

  Pdtutil_VerbosityMgrIf(travMgr, Pdtutil_VerbLevelUsrMin_c) {
    fprintf(tMgrO(travMgr),
      "abstrRef CNT: R: %d - A1: %d - A2: %d - A3: %d\n ",
      abstrCnt[0], abstrCnt[1], abstrCnt[2], abstrCnt[3]);
  }

  abstrRefCompact(itpMgr);
  Ddi_Free(abstrRefCtrlAux);
  Ddi_Free(abstrRefCtrlRefined);
  Ddi_Free(c0);
  Ddi_Free(c1);

  return 1;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
subspaceCheckTransition(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *s0,
  Ddi_Bdd_t *s1
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = travMgr != NULL ?
    Trav_MgrReadVerbosity(travMgr) : Ddi_MgrReadVerbosity(ddm);
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  int res;
  
  Ddi_Bdd_t *next = Ddi_BddCompose(s1,ps,itpMgr->delta);
  Ddi_BddNotAcc(next);
  res = Ddi_AigSatAnd(s0,next,NULL);
  Ddi_Free(next);
  return res;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
subspaceCheckInit(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t *s
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = travMgr != NULL ?
    Trav_MgrReadVerbosity(travMgr) : Ddi_MgrReadVerbosity(ddm);
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  int res;
  Ddi_Bdd_t *check=Ddi_BddDup(s);
  
  if (itpMgr->initStub==NULL) {
    Ddi_AigConstrainCubeAcc(check,itpMgr->init);
  }
  else {
    Ddi_BddComposeAcc(check,itpMgr->ps,itpMgr->initStub);
  }
  //	if (Ddi_AigSat(t_i_j_0)) {
  res = 0;
  if (Ddi_BddIsOne(check))
    res = 2;
  else if (Ddi_AigSat(check))
    res = 1;

  Ddi_Free(check);
  return res;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
subspaceCheckTransitions(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bddarray_t *spacePartitions
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = travMgr != NULL ?
    Trav_MgrReadVerbosity(travMgr) : Ddi_MgrReadVerbosity(ddm);
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  
  int i;
  for (i=0; i<Ddi_BddarrayNum(spacePartitions); i++) {

    Ddi_Bdd_t *p_i = Ddi_BddarrayRead(spacePartitions,i);
    int r = subspaceCheckInit(itpMgr,p_i);
    if (r==2) {
      printf("space partition %d (size %d) includes init\n",
             i, Ddi_BddSize(p_i));
    }
    else if (r==1) {
      printf("space partition %d (size %d) intersects init\n",
             i, Ddi_BddSize(p_i));
    }
    else {
      printf("space partition %d (size %d) is out of init\n",
             i, Ddi_BddSize(p_i));
      //      Ddi_BddNotAcc(p_i);
    }
  }
  for (i=0; i<Ddi_BddarrayNum(spacePartitions); i++) {
    Ddi_Bdd_t *p_i = Ddi_BddarrayRead(spacePartitions,i);
    int j;
    for (j=0; j<Ddi_BddarrayNum(spacePartitions); j++) {
      if (j==i) continue;
      Ddi_Bdd_t *p_j = Ddi_BddarrayRead(spacePartitions,j);
      int rFwd = subspaceCheckTransition(itpMgr,p_i,p_j);
      int incl = Ddi_BddIncluded(p_i,p_j);
      int inter = Ddi_AigSatAnd(p_i,p_j,NULL);
      if (!rFwd) {
        printf("no transition from space partitions %d->%d\n",
             i, j);
      }
      if (!inter) {
        printf("no intersection between partitions %d-%d\n",
             i, j);
      }
      if (incl) {
        printf("partition %d included by %d\n",
             i, j);
      }
      Ddi_BddNotAcc(p_j);
      rFwd = subspaceCheckTransition(itpMgr,p_i,p_j);
      incl = Ddi_BddIncluded(p_i,p_j);
      inter = Ddi_AigSatAnd(p_i,p_j,NULL);
      if (!rFwd) {
        printf("no transition from space partitions %d->!%d\n",
             i, j);
      }
      if (!inter) {
        printf("no intersection between partitions %d-!%d\n",
             i, j);
      }
      if (incl) {
        printf("partition %d included by !%d\n",
             i, j);
      }
      Ddi_BddNotAcc(p_j);
    }
    Ddi_BddNotAcc(p_i);
    for (j=0; j<Ddi_BddarrayNum(spacePartitions); j++) {
      if (j==i) continue;
      Ddi_Bdd_t *p_j = Ddi_BddarrayRead(spacePartitions,j);
      int rFwd = subspaceCheckTransition(itpMgr,p_i,p_j);
      if (!rFwd) {
        printf("no transition from space partitions !%d->%d\n",
             i, j);
      }
      Ddi_BddNotAcc(p_j);
      rFwd = subspaceCheckTransition(itpMgr,p_i,p_j);
      if (!rFwd) {
        printf("no transition from space partitions !%d->!%d\n",
             i, j);
      }
      Ddi_BddNotAcc(p_j);
    }
    Ddi_BddNotAcc(p_i);
  }

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
itpHintsInit(
  Trav_ItpMgr_t * itpMgr
)
{
  Trav_Mgr_t *travMgr = itpMgr->travMgr;
  Ddi_Mgr_t *ddm = Trav_MgrReadDdiMgrDefault(travMgr);
  Pdtutil_VerbLevel_e verbosity = travMgr != NULL ?
    Trav_MgrReadVerbosity(travMgr) : Ddi_MgrReadVerbosity(ddm);
  Ddi_Var_t *pv = NULL, *nv = NULL;
  Ddi_Bdd_t *pvLit = NULL, *nvLit = NULL;
  int var_i, i, iter;
  Ddi_Bddarray_t *iStub;
  Ddi_Vararray_t *ps = itpMgr->ps;
  Ddi_Vararray_t *ns = itpMgr->ns;
  Ddi_Vararray_t *pi = itpMgr->pi;
  Ddi_Vararray_t *hintsVars = NULL;
  Ddi_Bddarray_t *hintsArray = NULL;
  int *hintsIds = NULL;
  Ddi_Bdd_t *deltaConstr, *deltaProp;
  int hints = itpMgr->hints.hintsNum;
  Ddi_Vararray_t *hintsRefVars = ps;
  Ddi_Bdd_t *hConstr=NULL;
  int nl = Ddi_VararrayNum(ps)-2;
  int freeRefVars = 0;

  if (0) {
    hintsRefVars = Ddi_VararrayAlloc(ddm,0);
    Ddi_Var_t *v0 = Ddi_VarFromName(ddm, "l148");
    Ddi_Var_t *v1 = Ddi_VarFromName(ddm, "l302");
    Ddi_Var_t *v2 = Ddi_VarFromName(ddm, "l152");
    Ddi_Var_t *v3 = Ddi_VarFromName(ddm, "l156");
    Ddi_Var_t *v4 = Ddi_VarFromName(ddm, "l168");
    Ddi_VararrayInsertLast(hintsRefVars,v0);
    Ddi_VararrayInsertLast(hintsRefVars,v1);
    Ddi_VararrayInsertLast(hintsRefVars,v2);
    Ddi_VararrayInsertLast(hintsRefVars,v3);
    Ddi_VararrayInsertLast(hintsRefVars,v4);
    freeRefVars = 1;
  }

  if (itpMgr->hints.hintsNum <= 0) return 0;
  // use percentage of latches
  hints = itpMgr->hints.hintsNum = (itpMgr->hints.hintsNum * nl) / 100;
  if (hints > nl) {
    hints = itpMgr->hints.hintsNum = nl;
  }
  Pdtutil_Assert(hints<=Ddi_VararrayNum(ps)-2,"too many hints");

  itpMgr->hints.strategy = travMgr->settings.bdd.hintsStrategy;

  for (var_i = Ddi_VararrayNum(ps)-1; var_i>=0; var_i--) {
    Ddi_Var_t *v_i = Ddi_VararrayRead(ps,var_i);
    int isConstr = Ddi_VarName(v_i) != NULL &&
      (strcmp(Ddi_VarName(v_i), "PDT_BDD_INVAR_VAR$PS") == 0);
    if (isConstr) {
      break;
    }
  }
  Pdtutil_Assert(var_i>=0,"invar var not found");
  itpMgr->hints.invar_i = var_i+1;
  itpMgr->hints.invar0_i = var_i;

  hintsVars = itpMgr->hints.hintsVars = Ddi_VararrayAlloc(ddm, 0);
  hintsIds = itpMgr->hints.hintsIds = Pdtutil_Alloc(int, hints);

  itpMgr->hints.hintsConstr = Ddi_BddMakeConstAig(ddm, 1);

  int start = 0;
  int j;
  deltaProp = 
    Ddi_BddNot(Ddi_BddarrayRead(itpMgr->delta,itpMgr->hints.invar_i));
  Ddi_Var_t *pVar = travMgr->pdtSpecVar;
  Ddi_BddCofactorAcc(deltaProp,pVar,1);
  if (itpMgr->hints.strategy>10) {
    int i,j, doBmc=1;
    int maxHint=10; 
    Ddi_Bdd_t *targetPart = Ddi_AigConjDecomp (deltaProp, 2*maxHint,0);
    Ddi_Bddarray_t *tmpHints = Ddi_BddarrayAlloc(ddm,0);
    Ddi_BddPartSortBySizeAcc(targetPart, 0);    // decreasing size	
    if (hintsArray==NULL) {
      hintsArray = itpMgr->hints.hintsArray = Ddi_BddarrayAlloc(ddm, 0);
    }
    if (doBmc) {
      Ddi_Bdd_t *conePart = Ddi_BddDup(targetPart);
      int maxBound = 10, n=Ddi_BddPartNum(conePart);
      int failBound[n];
      Ddi_BddSubstVarsAcc(conePart,ps,ns);
      for (i=0; i<Ddi_BddPartNum(conePart); i++) {
        Ddi_Bdd_t *c_i = Ddi_BddPartRead(conePart,i);
        Ddi_BddWriteMark(c_i, 0);
        failBound[i] = -1;
      }
      Ddi_BddWriteMark(conePart, 0);
      for (j=0; j<maxBound; j++) {
        Ddi_Bdd_t *bmc_j = Ddi_BddNot(conePart);
        growConeBwd(itpMgr, bmc_j, j, 0, NULL,
                      itpMgr->initStub, 0, -1, 0);
        for (i=0; i<Ddi_BddPartNum(targetPart); i++) {
          Ddi_Bdd_t *bmc_j_i;
          if (failBound[i]>=0) continue;
          bmc_j_i = Ddi_BddPartRead(bmc_j,i);
          Ddi_BddSetAig(bmc_j_i);
          if (Ddi_AigSat(bmc_j_i)) {
            failBound[i] = j;
          }
        }
        Ddi_Free(bmc_j);
      }
      Ddi_Free(conePart);
      int h;
      for (h=0; h<maxHint; h++) {
        int maxFail=-1, max_j=-1;
        for (i=0; i<Ddi_BddPartNum(targetPart); i++) {
          if (failBound[i]>maxFail) {
            maxFail = failBound[i];
            max_j = i;
          }
        }
        if (maxFail>=0) {
          Ddi_Bdd_t *h_i = Ddi_BddPartRead(targetPart,max_j);
          Ddi_BddarrayInsertLast(hintsArray,h_i);
          Ddi_BddAndAcc(itpMgr->hints.hintsConstr,h_i);
          failBound[max_j] = -1;
        }
      }
      printf("decomp propery hint[%d] - size %d\n",
             Ddi_BddarrayNum(hintsArray),
             Ddi_BddarraySize(hintsArray));
    }
   
    if (Ddi_BddarrayNum(hintsArray)==0)
    for (i=0; i<Ddi_BddPartNum(targetPart); i++) {
      Ddi_Bdd_t *t_i = Ddi_BddPartRead(targetPart,i);
      Ddi_Bdd_t *t_i_Part = Ddi_AigPartitionTop(t_i, 0);
      Ddi_BddPartSortBySizeAcc(t_i_Part, 0);    // decreasing size	

      if (1) {
        Ddi_Bddarray_t *spacePart;
        Ddi_BddNotAcc(t_i_Part);
        spacePart = Ddi_BddarrayMakeFromBddPart(t_i_Part);
        subspaceCheckTransitions(itpMgr,spacePart);
        Ddi_BddNotAcc(t_i_Part);
        Ddi_Free(spacePart);
      }
      if (itpMgr->initStub != NULL) {
      }
      for (j=0; j<Ddi_BddPartNum(t_i_Part); j++) {
	Ddi_Bdd_t *t_i_j = Ddi_BddPartRead(t_i_Part,j);
	Ddi_Bdd_t *t_i_j_0 = Ddi_BddDup(t_i_j); 
	if (itpMgr->initStub==NULL) {
	  Ddi_AigConstrainCubeAcc(t_i_j_0,itpMgr->init);
	}
	else {
	  Ddi_BddComposeAcc(t_i_j_0,itpMgr->ps,itpMgr->initStub);
	}
	//	if (Ddi_AigSat(t_i_j_0)) {
	if (Ddi_BddIsOne(t_i_j_0)) {
        }
        else {
          Ddi_BddNotAcc(t_i_j);
          Ddi_BddNotAcc(t_i_j_0);
        }
	if (1) {
          //	if (Ddi_BddIsOne(t_i_j_0)) {
	  //	  Ddi_BddNotAcc(t_i_j);
	  if (Ddi_AigSatAnd(itpMgr->hints.hintsConstr,t_i_j,NULL)) {
	    printf("found sat target partition\n");
	    if (0&&!Ddi_BddIsConstant(t_i_j_0)) 
	      Ddi_BddarrayInsertLast(tmpHints,t_i_j);
	    else
	      Ddi_BddarrayInsertLast(hintsArray,t_i_j);
	    Ddi_BddAndAcc(itpMgr->hints.hintsConstr,t_i_j);
	  }
	  else {
	    printf("found incompatible constr\n");
#if 0
            Ddi_BddNotAcc(t_i_j);
	    Ddi_BddAndAcc(itpMgr->hints.hintsConstr,t_i_j);
            Ddi_BddarrayInsertLast(hintsArray,t_i_j);
            Ddi_BddNotAcc(t_i_j);
#endif
	  }
	}
      }
      Ddi_Free(t_i_Part);
    }
    Ddi_BddarraySortBySizeAcc(hintsArray, 0);    // decreasing size	
    Ddi_BddarraySortBySizeAcc(tmpHints, 0);    // decreasing size	
    Ddi_BddarrayAppend(itpMgr->hints.hintsArray,tmpHints);
    Ddi_BddarraySortBySizeAcc(hintsArray, 0);    // decreasing size	
    Ddi_Free(tmpHints);
    Ddi_Free(targetPart);
    hints = itpMgr->hints.hintsNum = Ddi_BddarrayNum(hintsArray);
  }
  else {
    for (i=j=0; j<hints && i<Ddi_VararrayNum(hintsRefVars)-start; i++) {
      Ddi_Var_t *ps_i = Ddi_VararrayRead(hintsRefVars,i+start);
      Ddi_Bdd_t *hLit = Ddi_BddMakeLiteralAig(ps_i, 1);
      Ddi_Bdd_t *dpDup, *initVal;
      int val = 0;
      if (itpMgr->initStub != NULL) {
	initVal = Ddi_BddCompose(hLit,itpMgr->ps,itpMgr->initStub);
      } else {
	initVal = Ddi_BddDup(hLit);
	Ddi_AigConstrainCubeAcc(initVal,itpMgr->init);
      } 
      if (Ddi_BddIsOne(initVal)) {
	Ddi_BddNotAcc(hLit);
	val = 1;
      }
      Ddi_Free(initVal);
      dpDup = Ddi_BddCofactor(deltaProp,ps_i,val);
      if (1 || Ddi_AigSat(dpDup)) {
	Ddi_BddDiffAcc(itpMgr->hints.hintsConstr,hLit);
	Ddi_VararrayInsertLast(hintsVars,ps_i);
	hintsIds[j++] = i;
	Ddi_BddCofactorAcc(deltaProp,ps_i,val);
      }
      Ddi_Free(dpDup);
      Ddi_Free(hLit);
    }
    hints = itpMgr->hints.hintsNum = Ddi_VararrayNum(itpMgr->hints.hintsVars);
  }

  Ddi_Free(deltaProp);

  pv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR0_VAR$PS");
  nv = Ddi_VarFromName(ddm, "PDT_BDD_INVAR0_VAR$NS");
  if (pv == NULL) {
    pv = Ddi_VarNew(ddm);
    nv = Ddi_VarNew(ddm);
    Ddi_VarAttachName(pv, "PDT_BDD_INVAR0_VAR$PS");
    Ddi_VarAttachName(nv, "PDT_BDD_INVAR0_VAR$NS");
  }
  pvLit = Ddi_BddMakeLiteralAig(pv, 1);
  nvLit = Ddi_BddMakeLiteralAig(nv, 1);
  
  Ddi_VararrayInsert(itpMgr->ps, var_i, pv);
  Ddi_VararrayInsert(itpMgr->ns, var_i, nv);
  
  // so far just make any state as new
  Ddi_Bdd_t *zeroConst = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *oneConst = Ddi_BddMakeConstAig(ddm, 1);
  if (itpMgr->initStub != NULL) {
    Ddi_BddarrayInsert(itpMgr->initStub,var_i,oneConst);
    //    Ddi_BddarrayInsert(itpMgr->initStub,var_i,pvLit);
  } else {
    //    Ddi_BddDiffAcc(itpMgr->init,pvLit);
    Ddi_BddAndAcc(itpMgr->init,pvLit);
  }
  
  //  Ddi_BddarrayInsert(itpMgr->delta,var_i,pvLit);

  Ddi_BddarrayInsert(itpMgr->delta,var_i,zeroConst); 
  Ddi_Free(zeroConst);
  Ddi_Free(oneConst);

  deltaConstr = Ddi_BddarrayRead(itpMgr->delta,itpMgr->hints.invar_i);
  itpMgr->hints.saveConstr = Ddi_BddDup(deltaConstr);

  hConstr = Ddi_BddDup(itpMgr->hints.hintsConstr);
  if (itpMgr->hints.strategy>3 && itpMgr->hints.strategy<=10) {
    Ddi_BddComposeAcc(hConstr,itpMgr->ps,itpMgr->delta);
  }
  Ddi_BddAndAcc(deltaConstr,hConstr);
  Ddi_Free(hConstr);
  if (1) {
    int iProp = itpMgr->hints.invar_i+1;
    int iConstr = itpMgr->hints.invar_i;
    Ddi_Var_t *vProp = Ddi_VararrayRead(itpMgr->ps,iProp);
    Ddi_Var_t *vConstr = Ddi_VararrayRead(itpMgr->ps,iConstr);
    Ddi_Bdd_t *negProp = Ddi_BddMakeLiteralAig(vProp, 0);
    Ddi_Bdd_t *litConstr = Ddi_BddMakeLiteralAig(vConstr, 1);
    Ddi_BddAndAcc(negProp,litConstr);
    Ddi_BddOrAcc(deltaConstr,negProp);
    Ddi_Free(negProp);
    Ddi_Free(litConstr);
  }
  
  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
	fprintf(tMgrO(travMgr),
		"Adding an additional state var for hint management (%d vars)\n",
		itpMgr->hints.hintsNum));
    
  itpMgr->hints.hintsEnabled = 1;
  itpMgr->hints.hintsMaxStep = -1; // 50;

  if (freeRefVars) {
    Ddi_Free(hintsRefVars);
  }

  Ddi_Free(pvLit);
  Ddi_Free(nvLit);
  return 1;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
Trav_ItpMgr_t *
Trav_ItpMgrInit(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * invarspec,
  int newTrPis,
  int optLevel
)
{
  int i, j, nState, nPi;
  Pdtutil_VerbLevel_e verbosity = travMgr != NULL ?
    Trav_MgrReadVerbosity(travMgr) : Fsm_MgrReadVerbosity(fsmMgr);
  Ddi_Bddarray_t *delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  Ddi_Bddarray_t *initStub = Fsm_MgrReadInitStubBDD(fsmMgr);
  Ddi_Bdd_t *init = Fsm_MgrReadInitBDD(fsmMgr);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(delta);
  Trav_ItpMgr_t *itpMgr;
  Ddi_Bddarray_t *auxVarLits;
  int computeFreeDeltas = travMgr != NULL
    && Trav_MgrReadInputRegs(travMgr) > 0;
  int computeDeltaSupports = 0;
  int computeConcurTr = 0;
  int twoPhase = 0;
  int trWithStall = 0;
  int useTrRange = 0;
  Ddi_Bddarray_t *twoPhaseDelta = NULL;
  int useReached = travMgr == NULL ? 0 : Trav_MgrReadItpUseReached(travMgr);
  int reachInit = travMgr != NULL && useReached
    && Trav_MgrReadFromSelect(travMgr) == Trav_FromSelectReached_c;
  Ddi_Bdd_t *stallCtrl = NULL;
  //  reachInit = 1; /* just to try: not efficient */
  itpMgr = Pdtutil_Alloc(Trav_ItpMgr_t, 1);

  itpMgr->travMgr = travMgr;
  itpMgr->fsmMgr = fsmMgr;
  itpMgr->ddiMgr = ddm;

  itpMgr->dynAbstrAux = NULL;
  itpMgr->dynAbstrCut = NULL;
  itpMgr->abstrRefCtrl = NULL;
  itpMgr->abstrRefInp = NULL;
  itpMgr->dynAbstrCutLits = NULL;
  itpMgr->shiftPiLits = NULL;
  itpMgr->shiftPiVars = NULL;
  itpMgr->saveNewPiVars = NULL;
  itpMgr->abstrDoAbstr = NULL;
  itpMgr->abstrRefFilter = NULL;
  itpMgr->abstrDoRefine = NULL;
  itpMgr->abstrPrioRefine = NULL;
  itpMgr->abstrRefPsPiVars = NULL;
  itpMgr->abstrCurrAbstr = NULL;
  itpMgr->abstrRefRefinedVars = NULL;
  itpMgr->abstrRefTrConstr = NULL;
  itpMgr->trItpAbstr.psNsConstr = NULL;
  itpMgr->enAbstr = NULL;

  itpMgr->tr = itpMgr->trAux = NULL;
  itpMgr->trAbstr = itpMgr->itpTrAbstr = NULL;
  itpMgr->trAuxAbstr = NULL;
  itpMgr->trArrayAbstr = NULL;
  itpMgr->trRange = NULL;
  itpMgr->delta = NULL;
  itpMgr->delta0 = NULL;
  itpMgr->deltaAbstr = NULL;
  itpMgr->deltaStall = NULL;
  itpMgr->target = NULL;
  itpMgr->lemma = NULL;
  itpMgr->init = NULL;
  itpMgr->specSpace = NULL;
  itpMgr->initStub = NULL;
  itpMgr->initStubState = NULL;
  itpMgr->stallCtrl = NULL;
  itpMgr->stalledVarsPs = NULL;
  itpMgr->stalledVarsNs = NULL;
  itpMgr->retimedCutPis = NULL;
  itpMgr->retimedCutRefPis = NULL;
  itpMgr->abstrRefNumRefinedLatches = 0;
  itpMgr->abstrRefGla = 0;
  itpMgr->abstrPrioRefineNum = 0;
  itpMgr->dynAbstr = travMgr == NULL ? 0 : Trav_MgrReadDynAbstr(travMgr);
  itpMgr->abstrRef = travMgr == NULL ? 0 : Trav_MgrReadAbstrRef(travMgr);
  itpMgr->abstrRefGla = travMgr == NULL ? 0 : Trav_MgrReadAbstrRefGla(travMgr);
  itpMgr->abstrRefNnf = 0;
  itpMgr->abstrRefScc = 0;
  itpMgr->levelizeSccs = 0;
  itpMgr->redRem = Ddi_MgrReadAigRedRemLevel(ddm);
  itpMgr->abcOpt = Ddi_MgrReadAigAbcOptLevel(ddm);
  itpMgr->useAbstrTr = 1;
  itpMgr->coneOpt = 0;
  itpMgr->unsatGuaranteed = -1;
  itpMgr->useAigVars = -1;
  itpMgr->optLevel = optLevel;
  itpMgr->igr.useRings = 0;
  itpMgr->igr.useRingsStep = 0;
  itpMgr->igr.useBwdRings = 0;
  itpMgr->time_limit = travMgr == NULL ? -1 :
    (long)travMgr->settings.aig.itpTimeLimit * 1000;
  itpMgr->peakAig_limit = travMgr == NULL ? -1 :
    (long)travMgr->settings.aig.itpPeakAig;
  itpMgr->igr.sameConeFail = -1;
  itpMgr->igr.coneSubsetBound   = travMgr->settings.aig.igrConeSubsetBound;
  itpMgr->igr.coneSubsetSizeTh  = travMgr->settings.aig.igrConeSubsetSizeTh;
  itpMgr->igr.coneSubsetPiRatio = travMgr->settings.aig.igrConeSubsetPiRatio;

  itpMgr->itpIncr = travMgr != NULL && Trav_MgrReadItpPart(travMgr) == 1;

  itpMgr->pi = Fsm_MgrReadVarI(fsmMgr);
  itpMgr->ps = Fsm_MgrReadVarPS(fsmMgr);
  itpMgr->ns = Fsm_MgrReadVarNS(fsmMgr);
  itpMgr->auxVarPis = NULL;

  itpMgr->trItpAbstr.nFrames = 0;
  itpMgr->trItpAbstr.enCompute = 1;
  itpMgr->hints.invar_i = -1;
  itpMgr->hints.invar0_i = -1;

  itpMgr->sccs.sccSize = NULL;
  itpMgr->sccs.latchSccMap = NULL;
  itpMgr->sccs.inCoreScc = NULL;

  itpMgr->pdrClauses.refVars = NULL;
  itpMgr->pdrClauses.clauseShared = NULL;
  itpMgr->pdrClauses.clauseSharedNum = NULL;

  itpMgr->nnf.deltaAbstr = NULL;
  itpMgr->nnf.delta = NULL;
  itpMgr->nnf.pi0 = NULL;
  itpMgr->nnf.ps0 = NULL;
  itpMgr->nnf.ns0 = NULL;
  itpMgr->nnf.pi2 = NULL;
  itpMgr->nnf.ps2 = NULL;
  itpMgr->nnf.ns2 = NULL;

  itpMgr->timeFrames = timeFrameInfoInit(ddm, 1);

  itpMgr->stats.deltaSize = -1;
  itpMgr->stats.igrRewindRing = -1;
  itpMgr->stats.igrPiSubsetK = -1;
  itpMgr->stats.igrFpRing = -1;
  itpMgr->stats.itpOutOfLimits = 0;

  if (travMgr->settings.ints.igrRingLast>0) {
    itpMgr->stats.igrFpRing = travMgr->settings.ints.igrRingLast;
  }



  if (invarspec != NULL) {
    if (Ddi_BddIsPartConj(invarspec)) {
      itpMgr->target = Ddi_BddNot(Ddi_BddPartRead(invarspec, 1));
      itpMgr->specSpace = Ddi_BddDup(Ddi_BddPartRead(invarspec, 0));
    } else {
      itpMgr->target = Ddi_BddNot(invarspec);
      itpMgr->specSpace = Ddi_BddDup(invarspec);
    }
  }

  if (itpMgr->abstrRef > 100) {
    itpMgr->abstrRefNnf = itpMgr->abstrRef/100;
    itpMgr->abstrRef = itpMgr->abstrRef%100;
  }

  if (twoPhase) {
    Ddi_Vararray_t *twoPhasePis =
      Ddi_VararrayMakeNewVars(itpMgr->pi, "PDT_ITP_TWOPHASE_PI", "0", 1);
    Ddi_Bddarray_t *twoPhasePiLits =
      Ddi_BddarrayMakeLiteralsAig(twoPhasePis, 1);
    twoPhaseDelta = Ddi_BddarrayDup(delta);
    Ddi_AigarrayComposeAcc(twoPhaseDelta, itpMgr->pi, twoPhasePiLits);
    Ddi_AigarrayComposeNoMultipleAcc(twoPhaseDelta, itpMgr->ps, delta);

    Ddi_VararrayAppend(itpMgr->pi, twoPhasePis);
    Ddi_Free(twoPhasePis);
    Ddi_Free(twoPhasePiLits);
  }

  itpMgr->trArray = NULL;
  itpMgr->stubTrArray = NULL;

  itpMgr->trBdd = NULL;
  itpMgr->trAig = NULL;

  itpMgr->coreVars = NULL;

  itpMgr->splitCex = NULL;
  itpMgr->inductiveRplus = NULL;
  itpMgr->provedProps = NULL;
  itpMgr->inductiveRplusLocal = NULL;
  itpMgr->pdrReachedRings = Ddi_BddarrayAlloc(ddm, 0);
  itpMgr->nPdrRings = 0;

  itpMgr->coneBoundOk = Pdtutil_IntegerArrayAlloc(1);

  itpMgr->reachedRings = Ddi_BddarrayAlloc(ddm, 0);
  itpMgr->bckReachedRings = Ddi_BddarrayAlloc(ddm, 0);
  itpMgr->eqRings = Ddi_BddarrayAlloc(ddm, 0);
  if (travMgr != NULL && Trav_MgrReadNewi(travMgr) != NULL) {
    int j;

    itpMgr->fromRings = Ddi_BddarrayDup(Trav_MgrReadNewi(travMgr));
    itpMgr->nRings = Ddi_BddarrayNum(itpMgr->fromRings);
    printf("PREV RINGS REUSED: %d\n", itpMgr->nRings);
#if 1
    for (j = 0; j < Ddi_BddarrayNum(itpMgr->fromRings); j++) {
      Ddi_Bdd_t *ring_j = Ddi_BddarrayRead(itpMgr->fromRings, j);
      if (ring_j == NULL) {
      }
      else if (Ddi_BddIsPartConj(ring_j)) {
        Pdtutil_Assert(Ddi_BddPartNum(ring_j) == 2, "error in ring as part");
        Ddi_Bdd_t *eq = Ddi_BddPartExtract(ring_j, 1);

        Ddi_BddarrayWrite(itpMgr->eqRings, j, eq);
        Ddi_Free(eq);
        Ddi_BddSetAig(ring_j);
      }
    }
#endif
  } else {
    itpMgr->fromRings = Ddi_BddarrayAlloc(ddm, 0);
    itpMgr->nRings = 0;
  }

  itpMgr->shiftPiVars = Ddi_VararrayAlloc(ddm, 0);
  itpMgr->shiftPiLits = Ddi_BddarrayAlloc(ddm, 0);
  itpMgr->freeDeltaPi = Ddi_VararrayAlloc(ddm, 0);
  itpMgr->freeDeltaNsLit = Ddi_BddarrayAlloc(ddm, 0);


  itpMgr->hints.hintsVars = NULL;
  itpMgr->hints.hintsArray = NULL;
  itpMgr->hints.hintsIds = NULL;
  itpMgr->hints.hintsConstr = NULL;
  itpMgr->hints.saveConstr = NULL;

  if (initStub != NULL) {
    itpMgr->initStub = Ddi_BddarrayDup(initStub);
  } else {
    itpMgr->init = Ddi_BddDup(init);
  }
  if (twoPhaseDelta != NULL) {
    itpMgr->delta = twoPhaseDelta;
  } else {
    itpMgr->delta = Ddi_BddarrayDup(delta);
  }
  delta = NULL;                 /* to avoid misuse */

  itpMgr->hints.hintsNum = travMgr->settings.bdd.hintsTh;
  itpMgr->hints.hintsFirst = 0;
  itpMgr->hints.hintsEnabled = 0;
  if (itpMgr->hints.hintsNum > 0) {
    itpMgr->psvars = NULL;
    itpHintsInit(itpMgr);
  }
  
  nState = Ddi_VararrayNum(itpMgr->ps);

  itpMgr->psLit = Ddi_BddarrayMakeLiteralsAig(itpMgr->ps, 1);
  itpMgr->nsLit = Ddi_BddarrayMakeLiteralsAig(itpMgr->ns, 1);

  itpMgr->nsvars = Ddi_VarsetMakeFromArray(itpMgr->ns);
  itpMgr->pivars = Ddi_VarsetMakeFromArray(itpMgr->pi);
  itpMgr->psvars = Ddi_VarsetMakeFromArray(itpMgr->ps);

  itpMgr->trArray = Ddi_BddarrayAlloc(ddm, nState);
  itpMgr->freeDelta = Pdtutil_Alloc(int,
    nState
  );
  itpMgr->nFreeDelta = 0;
  itpMgr->coreVarsCnt = Pdtutil_Alloc(int,
    nState
  );
  for (i = 0; i < nState; i++)
    itpMgr->coreVarsCnt[i] = 0;

  itpMgr->concurTr = NULL;
  itpMgr->concurStall = NULL;
  itpMgr->invarConstr = NULL;
  itpMgr->invarConstrForTr = NULL;

  itpMgr->boundkOptPis = NULL;
  itpMgr->antecedents = NULL;
  itpMgr->enables = NULL;

  if (travMgr != NULL && Trav_MgrReadItpBoundkOpt(travMgr) < 0) {
    itpMgr->boundkOptPis = Ddi_VararrayAlloc(ddm, 0);
  }
  itpMgr->boundkOptNumVars = 0;

  itpMgr->itpOpt = 0;


  int enCuts = 0;
  if (enCuts) {
    Ddi_Vararray_t *retimedCutPis = Ddi_VararrayFindVarsFromPrefixSuffix (itpMgr->pi,
                                    "PDT_RETIMED_PI_AUX",NULL);
    if (retimedCutPis!=NULL) {
      itpMgr->retimedCutPis = retimedCutPis;
      itpMgr->retimedCutRefPis = Ddi_VararrayFindRefVars (retimedCutPis,
                                 "PDT_RETIMED_PI_AUX",NULL);
    }
  }

  if (itpMgr->dynAbstr) {
    itpMgr->dynAbstrAux = Ddi_VararrayAlloc(ddm, nState);
    itpMgr->dynAbstrCut = Ddi_VararrayAlloc(ddm, nState);
    itpMgr->dynAbstrCutLits = Ddi_BddarrayAlloc(ddm, nState);
    itpMgr->enAbstr = Pdtutil_Alloc(unsigned char,
      nState
    );

    for (j = 0; j < Ddi_VararrayNum(itpMgr->ps); j++) {
      Ddi_Bdd_t *lit;
      char name[1000];
      Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->ps, j);
      Ddi_Var_t *newv = NULL;

      sprintf(name, "dynAbstrAux_%s", Ddi_VarName(v));
      newv = Ddi_VarFromName(ddm, name);
      if (newv == NULL) {
        newv = Ddi_VarNewBeforeVar(v);
        Ddi_VarAttachName(newv, name);
      }
      Ddi_VararrayWrite(itpMgr->dynAbstrAux, j, newv);
      sprintf(name, "dynAbstrCut_%s", Ddi_VarName(v));
      newv = Ddi_VarFromName(ddm, name);
      if (newv == NULL) {
        newv = Ddi_VarNewBeforeVar(v);
        Ddi_VarAttachName(newv, name);
      }
      Ddi_VararrayWrite(itpMgr->dynAbstrCut, j, newv);
      lit = Ddi_BddMakeLiteralAig(newv, 1);
      Ddi_BddarrayWrite(itpMgr->dynAbstrCutLits, j, lit);
      Ddi_Free(lit);
      itpMgr->enAbstr[j] = 1;   //strstr(Ddi_VarName(v),"PDT_BDD_INVAR")==NULL;
#if 0
      if (strstr(Ddi_VarName(v), "l1346") != NULL) {
        itpMgr->enAbstr[j] = 0;
      }
      if (strstr(Ddi_VarName(v), "l1348") != NULL) {
        itpMgr->enAbstr[j] = 0;
      }
#endif
    }

  }

  if (travMgr != NULL && Trav_MgrReadItpBoundkOpt(travMgr) == 2) {
    int nd = Ddi_BddarrayNum(itpMgr->delta);
    Ddi_Var_t *sV = Fsm_MgrReadPdtSpecVar(fsmMgr);

    if (sV != NULL) {
      Ddi_BddCofactorAcc(Ddi_BddarrayRead(itpMgr->delta, nd - 1), sV, 1);
    }
  }

  if (travMgr != NULL) {
    Ddi_AigarrayAbcOptAcc(itpMgr->delta, -1.0);
  }

  if (reachInit) {
    int initReachable, addInitAsNext = 0;

    /* check init -> init transition */
    if (initStub != 0) {
      addInitAsNext = 1;
    } else {
      Ddi_Bdd_t *checkInit = Ddi_BddCompose(itpMgr->init,
        itpMgr->ps, itpMgr->delta);

      Ddi_BddAndAcc(checkInit, itpMgr->init);
      initReachable = Ddi_AigSat(checkInit);
      Ddi_Free(checkInit);
      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr),
          "INIT is %s reachable from INIT.\n", initReachable ? "" : "NOT")
        );
      if (!initReachable) {
        addInitAsNext = 1;
      }
    }
    if (addInitAsNext) {
      Ddi_Var_t *v = NULL;
      Ddi_Bdd_t *c_i;
      Ddi_Bddarray_t *iStub;
      int forceStall = 1;

      if (!forceStall && (initStub == NULL)) {
        iStub = Ddi_BddarrayRangeMakeFromCube(itpMgr->init, itpMgr->ps);
      } else {
        iStub = Ddi_BddarrayMakeLiteralsAig(itpMgr->ps, 1);
      }

      Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
        fprintf(tMgrO(travMgr),
          "Modifying TR to add init -> init transition.\n", i)
        );

      v = Ddi_VarFromName(ddm, "PDT_STALL_DUMMY_CONTROL");
      if (v == NULL) {
        v = Ddi_VarNew(ddm);
        Ddi_VarAttachName(v, "PDT_STALL_DUMMY_CONTROL");
      }
      Ddi_VararrayInsertLast(itpMgr->pi, v);
#if 0
      //      itpMgr->deltaStall = Ddi_BddDup(itpMgr->delta);
      c_i = Ddi_BddMakeLiteralAig(v, 1);
      for (i = 0; i < Ddi_BddarrayNum(itpMgr->delta); i++) {
        Ddi_Bdd_t *d_i, *p_i;

        p_i = Ddi_BddarrayRead(iStub, i);
        d_i = Ddi_BddIte(c_i, Ddi_BddarrayRead(itpMgr->delta, i), p_i);
        Ddi_BddarrayWrite(itpMgr->delta, i, d_i);
        Ddi_Free(d_i);
      }
      Ddi_AigarrayAbcOptAcc(itpMgr->delta, -1.0);
      Ddi_Free(c_i);
#else
      itpMgr->stallCtrl = v;
      stallCtrl = Ddi_BddMakeLiteralAig(v, 1);
      trWithStall = 1;
#endif
      Ddi_Free(iStub);
    }
  }

  if (invar != NULL) {
    itpMgr->invarConstr = Ddi_BddDup(invar);
    itpMgr->invarConstrForTr = Ddi_BddDup(invar);
  }
  if (0 && Trav_MgrReadAssume(travMgr) != NULL) {
    if (invar == NULL) {
      itpMgr->invarConstr = Ddi_BddMakeConstAig(ddm, 1);
    }
    Ddi_BddAndAcc(itpMgr->invarConstr, Trav_MgrReadAssume(travMgr));
  }
  
  if (itpMgr->abstrRef) {
    itpAbstrRefInit(itpMgr);
  }

  itpMgr->saveNewPiVars = Ddi_VararrayDup(itpMgr->pi);
  itpMgr->tr = Ddi_BddMakeConstAig(ddm, 1);

  nPi = Ddi_VararrayNum(itpMgr->pi);
  auxVarLits = Ddi_BddarrayAlloc(ddm, nPi);

  for (i = 0; i < Ddi_BddarrayNum(itpMgr->delta); i++) {
    Ddi_Bdd_t *tr_i, *psLit_i, *nsLit_i;
    Ddi_Varset_t *dSupp;

    nsLit_i = Ddi_BddarrayRead(itpMgr->nsLit, i);
    psLit_i = Ddi_BddarrayRead(itpMgr->psLit, i);

    if (itpMgr->deltaAbstr != NULL) {
      tr_i = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->deltaAbstr, i));
    } else {
      tr_i = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->delta, i));
    }
    if (trWithStall) { 
      Ddi_Bdd_t *newTr_i = Ddi_BddIte(stallCtrl, tr_i, psLit_i);
      Ddi_Free(tr_i);
      tr_i = newTr_i;
    }
    Ddi_BddXnorAcc(tr_i, nsLit_i);

    Ddi_BddAndAcc(itpMgr->tr, tr_i);

    Ddi_BddarrayWrite(itpMgr->trArray, i, tr_i);
    Ddi_Free(tr_i);

    /* find single input support deltas */

    itpMgr->freeDelta[i] = 0;

    int customSimplify = 0;
    if (customSimplify) {
      //      int i, j, deltaIndexes[] = {9,10,11,14,15,-1};
      int i, j, deltaIndexes[] = {9,977,1056,1057,-1};
      Ddi_Bddarray_t *en = Ddi_BddarrayAlloc(ddm,0);
      for (j=0; (i=deltaIndexes[j])>=0; j++) {
        Ddi_Var_t *ps_i = Ddi_VararrayRead(itpMgr->ps,i);
        Ddi_Bdd_t *d_i = Ddi_BddarrayRead(itpMgr->delta,i);
        Ddi_Bdd_t *cof0 = Ddi_BddCofactor(d_i,ps_i,0);
        Ddi_Bdd_t *cof1 = Ddi_BddCofactor(d_i,ps_i,1);
        Ddi_DataCopy(d_i,cof1);
        Ddi_BddNotAcc(cof1);
        Ddi_Bdd_t *en_i = Ddi_BddOr(cof0,cof1);
        Ddi_BddarrayInsertLast(en,en_i);
        Ddi_Free(en_i);
        Ddi_Free(cof0);
        Ddi_Free(cof1);
      }
      Ddi_Free(en);

    }

    if (computeDeltaSupports) {
      int cnt1 = 0, cnt1Delta=0;
      Ddi_Varset_t **suppArray = Ddi_BddarraySuppArray(itpMgr->delta);
      int nD = Ddi_BddarrayNum(itpMgr->delta);
      Ddi_VararrayWriteMark(itpMgr->ps, 0);
      Ddi_VararrayWriteMark(itpMgr->pi, 0);
      for (i=0; i<nD; i++) {
        int j;
        Ddi_Vararray_t *sA = Ddi_VararrayMakeFromVarset(suppArray[i], 1);
        for (j=0; j<Ddi_VararrayNum(sA); j++) {
          Ddi_Var_t *v_j = Ddi_VararrayRead(sA,j);
          Ddi_VarIncrMark(v_j, 1);
        }
        //        Ddi_Free(suppArray[i]);
        Ddi_Free(sA);
      }
      for (j=0; j<Ddi_VararrayNum(itpMgr->ps); j++) {
        Ddi_Var_t *v_j = Ddi_VararrayRead(itpMgr->ps,j);
        if (Ddi_VarReadMark(v_j)==1) {
          //          printf("single supp fanout %s ps[%d]\n", Ddi_VarName(v_j), j);
          cnt1++;
        }
      }
      for (j=0; j<Ddi_VararrayNum(itpMgr->pi); j++) {
        Ddi_Var_t *v_j = Ddi_VararrayRead(itpMgr->pi,j);
        if (Ddi_VarReadMark(v_j)==1) {
          //          printf("single supp fanout %s pi[%d]\n", Ddi_VarName(v_j), j);
          cnt1++;
        }
      }
      for (i=0; i<nD; i++) {
        int j;
        Ddi_Vararray_t *sA = Ddi_VararrayMakeFromVarset(suppArray[i], 1);
        int singleSupp=1;
        for (j=0; j<Ddi_VararrayNum(sA); j++) {
          Ddi_Var_t *v_j = Ddi_VararrayRead(sA,j);
          if (Ddi_VarReadMark(v_j)>1) singleSupp=0;
        }
        if (singleSupp) {
          cnt1Delta++;
        }
        Ddi_Free(suppArray[i]);
        Ddi_Free(sA);
      }
      
      printf("SINGLE SUPP CNT: %d - single supp deltas: %d/%d\n",
             cnt1, cnt1Delta, nD);
      Pdtutil_Free(suppArray);
      Ddi_VararrayWriteMark(itpMgr->ps, 0);
      Ddi_VararrayWriteMark(itpMgr->pi, 0);

      if (itpMgr->initStub!=NULL) {
        int cnt1is=0, cnt1Latch=0, cntConst=0;
        Ddi_Varset_t **suppArray = Ddi_BddarraySuppArray(itpMgr->initStub);
        int nD = Ddi_BddarrayNum(itpMgr->initStub);
        Ddi_Vararray_t *vars = Ddi_BddarraySuppVararray(itpMgr->initStub);
        Ddi_VararrayWriteMark(vars, 0);
        for (i=0; i<nD; i++) {
          int j;
          Ddi_Vararray_t *sA = Ddi_VararrayMakeFromVarset(suppArray[i], 1);
          for (j=0; j<Ddi_VararrayNum(sA); j++) {
            Ddi_Var_t *v_j = Ddi_VararrayRead(sA,j);
            Ddi_VarIncrMark(v_j, 1);
          }
          //          Ddi_Free(suppArray[i]);
          Ddi_Free(sA);
        }
        for (j=0; j<Ddi_VararrayNum(vars); j++) {
          Ddi_Var_t *v_j = Ddi_VararrayRead(vars,j);
          if (Ddi_VarReadMark(v_j)==1) {
            //            printf("single supp fanout %s is[%d]\n", Ddi_VarName(v_j), j);
            cnt1is++;
          }
          else {
            //            printf("init stub pi[%d] %s supp: %d\n", j,
            //                   Ddi_VarName(v_j), Ddi_VarReadMark(v_j));
          }
        }
        for (i=0; i<nD; i++) {
          int j;
          Ddi_Vararray_t *sA = Ddi_VararrayMakeFromVarset(suppArray[i], 1);
          int singleSupp=1, noSupp=1;
          for (j=0; j<Ddi_VararrayNum(sA); j++) {
            Ddi_Var_t *v_j = Ddi_VararrayRead(sA,j);
            if (Ddi_VarReadMark(v_j)>1) singleSupp=0;
            noSupp=0;
          }
          if (noSupp) {
            cntConst++;
          }
          else if (singleSupp) {
            cnt1Latch++;
          }
          Ddi_Free(suppArray[i]);
          Ddi_Free(sA);
        }
        Pdtutil_Free(suppArray);
        Ddi_VararrayWriteMark(vars, 0);
        printf("SINGLE INIT STUB SUPP CNT: %d/%d - %d/%d latches\n",
               cnt1is, Ddi_VararrayNum(vars), cnt1Latch, nD);
        printf("CONST INIT STUB LATCHES %d/%d latches\n",
               cntConst, nD);
        Ddi_Free(vars);

      }
    }
    
    if (computeFreeDeltas) {
      dSupp = Ddi_BddSupp(Ddi_BddarrayRead(itpMgr->delta, i));
      if (Ddi_VarsetNum(dSupp) == 1) {
        //      Ddi_VarsetIntersectAcc(dSupp,itpMgr->pivars);
        if (Ddi_VarsetNum(dSupp) == 1) {
          Ddi_Var_t *v = Ddi_VarsetTop(dSupp);
          int j;

          for (j = 0; j < Ddi_VararrayNum(itpMgr->freeDeltaPi); j++) {
            if (v == Ddi_VararrayRead(itpMgr->freeDeltaPi, j))
              break;
          }
          if (j == Ddi_VararrayNum(itpMgr->freeDeltaPi)) {
            int phase = !Ddi_BddIsComplement(Ddi_BddarrayRead(delta, i));
            Ddi_Bdd_t *lit =
              Ddi_BddMakeLiteralAig(Ddi_VararrayRead(itpMgr->ns, i), phase);
            itpMgr->nFreeDelta++;
            itpMgr->freeDelta[i] = 1;
            Ddi_VararrayInsertLast(itpMgr->freeDeltaPi, v);
            Ddi_BddarrayInsertLast(itpMgr->freeDeltaNsLit, lit);
            Ddi_Free(lit);
          }
        }
      }
      Ddi_Free(dSupp);
    }
  }
  if (itpMgr->nFreeDelta > 0) {
  }

  if (computeConcurTr) {
    Ddi_Bdd_t *eqTr = Ddi_BddMakePartConjVoid(ddm);
    Ddi_Bdd_t *one = Ddi_BddMakeConstAig(ddm, 1);
    int nstate = Ddi_VararrayNum(itpMgr->ps);

    itpMgr->concurTr = Ddi_BddMakePartDisjVoid(ddm);
    itpMgr->concurStall = Ddi_BddMakePartDisjVoid(ddm);

    for (i = 0; i < nstate; i++) {
      int j;
      Ddi_Bdd_t *d_i = Ddi_BddarrayRead(itpMgr->delta, i);
      Ddi_Var_t *v_i = Ddi_VararrayRead(itpMgr->ps, i);

      Ddi_Bdd_t *d_i_0 = Ddi_BddCofactor(d_i, v_i, 0);
      Ddi_Bdd_t *d_i_1 = Ddi_BddCofactor(d_i, v_i, 1);
      Ddi_Bdd_t *eq_i = Ddi_BddDiff(d_i_1, d_i_0);

      Ddi_BddPartInsertLast(eqTr, eq_i);
      Ddi_Free(eq_i);
      Ddi_Free(d_i_0);
      Ddi_Free(d_i_1);
    }

    for (i = 0; i < nstate; i++) {
      Ddi_Bdd_t *stall;
      Ddi_Var_t *v_i = Ddi_VararrayRead(itpMgr->ps, i);
      Ddi_Var_t *vn_i = Ddi_VararrayRead(itpMgr->ns, i);
      Ddi_Bdd_t *eq_i = Ddi_BddDup(Ddi_BddPartRead(eqTr, i));

      Ddi_BddPartWrite(eqTr, i, one);
      stall = Ddi_BddMakeAig(eqTr);
      Ddi_BddPartWrite(eqTr, i, eq_i);
      Ddi_BddNotAcc(eq_i);
      Ddi_BddAndAcc(eq_i, stall);
      if (Ddi_AigSat(eq_i)) {
        Ddi_Bdd_t *t_i = Ddi_BddDup(Ddi_BddarrayRead(itpMgr->delta, i));
        Ddi_Bdd_t *lit = Ddi_BddMakeLiteralAig(vn_i, 1);

        Ddi_BddXnorAcc(t_i, lit);
        Ddi_BddAndAcc(t_i, stall);
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr),
            "disj dpart possible with: %d (%s). t size: %d.\n", i,
            Ddi_VarName(v_i), Ddi_BddSize(t_i))
          );
        Ddi_BddPartInsertLast(itpMgr->concurTr, t_i);
        Ddi_BddPartInsertLast(itpMgr->concurStall, stall);
        Ddi_Free(t_i);
        Ddi_Free(lit);
      }
      Ddi_Free(stall);
      Ddi_Free(eq_i);
    }
    Ddi_Free(eqTr);
    Ddi_Free(one);

    if (Ddi_BddPartNum(itpMgr->concurTr) == 0) {
      Ddi_Free(itpMgr->concurTr);
      Ddi_Free(itpMgr->concurStall);
    }
    Ddi_BddSetAig(itpMgr->concurStall);
  }

  if (newTrPis) {
    itpMgr->auxVarPis = Ddi_VararrayAlloc(ddm, nPi);
    for (j = 0; j < nPi; j++) {
      Ddi_Bdd_t *lit;
      char name[1000];
      Ddi_Var_t *v = Ddi_VararrayRead(itpMgr->pi, j);
      Ddi_Var_t *newv = NULL;

      sprintf(name, "InterpolantAuxTrPi_%s", Ddi_VarName(v));
      newv = Ddi_VarFromName(ddm, name);
      if (newv == NULL) {
        int isAig = Ddi_VarIsAig(v);

        if (isAig) {
          newv = Ddi_VarNewBaig(ddm, name);
        } else {
          newv = Ddi_VarNewBeforeVar(v);
          Ddi_VarAttachName(newv, name);
        }
      }
      Ddi_VararrayWrite(itpMgr->auxVarPis, j, newv);
      lit = Ddi_BddMakeLiteralAig(newv, 1);
      Ddi_BddarrayWrite(auxVarLits, j, lit);
      Ddi_Free(lit);
      if (itpMgr->nFreeDelta > 0) {
        int k;

        for (k = 0; k < Ddi_VararrayNum(itpMgr->freeDeltaPi); k++) {
          if (v == Ddi_VararrayRead(itpMgr->freeDeltaPi, k)) {
            Ddi_VararrayWrite(itpMgr->freeDeltaPi, k, newv);
          }
        }
      }
    }
    Ddi_AigarrayComposeAcc(itpMgr->trArray, itpMgr->pi, auxVarLits);
    Ddi_BddComposeAcc(itpMgr->tr, itpMgr->pi, auxVarLits);
    if (0 && itpMgr->invarConstr != NULL) {
      Ddi_BddComposeAcc(itpMgr->invarConstr, itpMgr->pi, auxVarLits);
    }
    if (1 && itpMgr->invarConstrForTr != NULL) {
      Ddi_BddComposeAcc(itpMgr->invarConstrForTr, itpMgr->pi, auxVarLits);
    }
    if (itpMgr->concurTr != NULL) {
      Ddi_BddComposeAcc(itpMgr->concurTr, itpMgr->pi, auxVarLits);
      Ddi_BddComposeAcc(itpMgr->concurStall, itpMgr->pi, auxVarLits);
    }

    Ddi_Free(auxVarLits);
  }

  if (Ddi_MgrReadAigAbcOptLevel(ddm) > 2 && Ddi_BddSize(itpMgr->tr) < 20000) {
    ddiAbcOptAcc(itpMgr->tr, -1.0);
  }

  itpMgr->trAux = Ddi_BddDup(itpMgr->tr);
  if (useTrRange) {
    Ddi_Vararray_t *trRangePis =
      Ddi_VararrayMakeNewVars(itpMgr->pi, "PDT_ITP_RANGE_PI", "0", 1);
    Ddi_Bddarray_t *trRangePiLits = Ddi_BddarrayMakeLiteralsAig(trRangePis, 1);
    Ddi_Vararray_t *trRangePs =
      Ddi_VararrayMakeNewVars(itpMgr->ps, "PDT_ITP_RANGE_PS", "0", 1);
    Ddi_Bddarray_t *trRangePsLits = Ddi_BddarrayMakeLiteralsAig(trRangePs, 1);

    itpMgr->trRange = Ddi_BddDup(itpMgr->tr);
    Ddi_BddComposeAcc(itpMgr->trRange, itpMgr->auxVarPis, trRangePiLits);
    Ddi_BddComposeAcc(itpMgr->trRange, itpMgr->ps, trRangePsLits);
    Ddi_BddComposeAcc(itpMgr->trRange, itpMgr->ns, itpMgr->psLit);
    Ddi_Free(trRangePis);
    Ddi_Free(trRangePiLits);
    Ddi_Free(trRangePs);
    Ddi_Free(trRangePsLits);
  }

  if (itpMgr->abstrRef > 0 && itpMgr->abstrRef <= 2) {
    itpMgr->trAbstr = Ddi_BddDup(itpMgr->tr);
    itpMgr->trAuxAbstr = Ddi_BddDup(itpMgr->trAux);
    itpMgr->trArrayAbstr = Ddi_BddarrayDup(itpMgr->trArray);
  }

  if (travMgr->settings.aig.trAbstrItpLoad!=NULL) {
    int nFrames;
    itpMgr->trItpAbstr.psNsConstr = TravTravTrAbstrLoad(travMgr,&nFrames); 
    itpMgr->trItpAbstr.nFrames = nFrames;
    itpMgr->trItpAbstr.enCompute = 0;
    travMgr->settings.aig.trAbstrItp = nFrames;
  }
  
  if (itpMgr->abstrRef > 2) {
    Ddi_BddComposeAcc(itpMgr->tr, itpMgr->abstrRefCtrl, itpMgr->abstrDoRefine);
  }

  if (itpMgr->useAbstrTr && itpMgr->abstrRef > 2) {
    Ddi_BddComposeAcc(itpMgr->trAux,
      itpMgr->abstrRefCtrl, itpMgr->abstrDoAbstr);
  }

  int handleStalledLatches = 1;
  if (handleStalledLatches) {
    int nStalled=0;
    itpMgr->stalledVarsPs = Ddi_VararrayAlloc(ddm, 0);
    itpMgr->stalledVarsNs = Ddi_VararrayAlloc(ddm, 0);
    for (int i=0; i<Ddi_BddarrayNum(itpMgr->delta); i++) {
      Ddi_Bdd_t *d_i = Ddi_BddarrayRead(itpMgr->delta,i);
      Ddi_Var_t *ps_i = Ddi_VararrayRead(itpMgr->ps,i);
      if (Ddi_BddSize(d_i) == 1) {
	if (Ddi_BddTopVar(d_i)==ps_i && !Ddi_BddIsComplement(d_i)) {
	  nStalled++;
	  Ddi_Var_t *ns_i = Ddi_VararrayRead(itpMgr->ns,i);
	  Ddi_VararrayInsertLast(itpMgr->stalledVarsPs,ps_i);
	  Ddi_VararrayInsertLast(itpMgr->stalledVarsNs,ns_i);
	}
      }
    }
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(tMgrO(travMgr),
	    "%d stalled latches found\n", nStalled)
    );
  }
  
  Ddi_Free(stallCtrl);
  Ddi_Free(auxVarLits);


  int trackAntecedents = 0;
  if (trackAntecedents) {
    Ddi_Bdd_t *myTarget =
      Ddi_BddCompose(itpMgr->target,itpMgr->ps,itpMgr->delta);
    itpMgr->antecedents = findOrTerms(myTarget,trackAntecedents);
    Ddi_Free(myTarget);
  }
  
  return (itpMgr);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Trav_ItpMgrQuit(
  Trav_ItpMgr_t * itpMgr
)
{
  Ddi_Free(itpMgr->dynAbstrAux);
  Ddi_Free(itpMgr->dynAbstrCut);
  Ddi_Free(itpMgr->abstrRefCtrl);
  Ddi_Free(itpMgr->abstrRefInp);
  Ddi_Free(itpMgr->dynAbstrCutLits);
  Ddi_Free(itpMgr->shiftPiLits);
  Ddi_Free(itpMgr->shiftPiVars);
  Ddi_Free(itpMgr->saveNewPiVars);
  Ddi_Free(itpMgr->abstrDoAbstr);
  Ddi_Free(itpMgr->abstrRefFilter);
  Ddi_Free(itpMgr->abstrDoRefine);
  Ddi_Free(itpMgr->abstrPrioRefine);
  Ddi_Free(itpMgr->abstrCurrAbstr);
  Ddi_Free(itpMgr->abstrRefPsPiVars);
  Ddi_Free(itpMgr->abstrRefRefinedVars);
  Ddi_Free(itpMgr->abstrRefTrConstr);
  Ddi_Free(itpMgr->trItpAbstr.psNsConstr);

  Pdtutil_Free(itpMgr->enAbstr);

  timeFrameInfoFree(itpMgr->timeFrames);

  Ddi_Free(itpMgr->tr);
  Ddi_Free(itpMgr->trAbstr);
  Ddi_Free(itpMgr->trRange);
  Ddi_Free(itpMgr->trAux);
  Ddi_Free(itpMgr->itpTrAbstr);
  Ddi_Free(itpMgr->trAuxAbstr);
  Ddi_Free(itpMgr->target);
  Ddi_Free(itpMgr->lemma);
  Ddi_Free(itpMgr->init);
  Ddi_Free(itpMgr->specSpace);
  Ddi_Free(itpMgr->initStub);
  Ddi_Free(itpMgr->initStubState);
  Ddi_Free(itpMgr->delta);
  Ddi_Free(itpMgr->delta0);
  Ddi_Free(itpMgr->deltaAbstr);
  Ddi_Free(itpMgr->deltaStall);

  Ddi_Free(itpMgr->psLit);
  Ddi_Free(itpMgr->nsLit);
  Ddi_Free(itpMgr->nsvars);
  Ddi_Free(itpMgr->pivars);
  Ddi_Free(itpMgr->psvars);
  Ddi_Free(itpMgr->auxVarPis);
  Ddi_Free(itpMgr->coreVars);

  Pdtutil_Free(itpMgr->sccs.sccSize);
  Pdtutil_Free(itpMgr->sccs.latchSccMap);
  Ddi_Free(itpMgr->sccs.inCoreScc);

  Ddi_Free(itpMgr->trArray);
  Ddi_Free(itpMgr->trArrayAbstr);
  Ddi_Free(itpMgr->stubTrArray);
  Ddi_Free(itpMgr->splitCex);
  Ddi_Free(itpMgr->inductiveRplus);
  Ddi_Free(itpMgr->inductiveRplusLocal);
  Ddi_Free(itpMgr->pdrReachedRings);
  Ddi_Free(itpMgr->reachedRings);
  Ddi_Free(itpMgr->bckReachedRings);

  Pdtutil_IntegerArrayFree(itpMgr->coneBoundOk);

  Ddi_Free(itpMgr->eqRings);
  Ddi_Free(itpMgr->fromRings);
  Ddi_Free(itpMgr->provedProps);

  Ddi_Free(itpMgr->shiftPiVars);
  Ddi_Free(itpMgr->shiftPiLits);

  Ddi_Free(itpMgr->freeDeltaPi);
  Ddi_Free(itpMgr->freeDeltaNsLit);
  Ddi_Free(itpMgr->concurTr);
  Ddi_Free(itpMgr->concurStall);
  Ddi_Free(itpMgr->invarConstr);
  Ddi_Free(itpMgr->invarConstrForTr);
  Ddi_Free(itpMgr->boundkOptPis);
  Ddi_Free(itpMgr->antecedents);
  Ddi_Free(itpMgr->enables);

  Ddi_Free(itpMgr->hints.hintsVars);
  Ddi_Free(itpMgr->hints.hintsArray);
  Ddi_Free(itpMgr->hints.hintsConstr);
  Ddi_Free(itpMgr->hints.saveConstr);
  Ddi_Free(itpMgr->stalledVarsPs);
  Ddi_Free(itpMgr->stalledVarsNs);
  Ddi_Free(itpMgr->retimedCutPis);
  Ddi_Free(itpMgr->retimedCutRefPis);
  
  Pdtutil_Free(itpMgr->hints.hintsIds);

  Pdtutil_Free(itpMgr->freeDelta);
  Pdtutil_Free(itpMgr->coreVarsCnt);

  Ddi_Free(itpMgr->pdrClauses.refVars);
  Ddi_ClauseArrayFree(itpMgr->pdrClauses.clauseShared);
  Pdtutil_IntegerArrayFree(itpMgr->pdrClauses.clauseSharedNum);

  Ddi_Free(itpMgr->nnf.delta);
  Ddi_Free(itpMgr->nnf.deltaAbstr);
  Ddi_Free(itpMgr->nnf.pi0);
  Ddi_Free(itpMgr->nnf.ps0);
  Ddi_Free(itpMgr->nnf.ns0);
  Ddi_Free(itpMgr->nnf.pi2);
  Ddi_Free(itpMgr->nnf.ps2);
  Ddi_Free(itpMgr->nnf.ns2);

  if (itpMgr->trBdd != NULL) {
    Tr_TrFree(itpMgr->trBdd);
  }
  if (itpMgr->trAig != NULL) {
    Tr_TrFree(itpMgr->trAig);
  }

  Pdtutil_Free(itpMgr);

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
void
Trav_ItpMgrSetConeBoundOK(
  Trav_ItpMgr_t * itpMgr,
  int ring_i,
  int cone_k
)
{
  int n;
  if (itpMgr->coneBoundOk == NULL) {
    itpMgr->coneBoundOk = Pdtutil_IntegerArrayAlloc(1);
  }
  n = Pdtutil_IntegerArrayNum(itpMgr->coneBoundOk);
  if (ring_i >= n) {
    while (ring_i >= Pdtutil_IntegerArraySize(itpMgr->coneBoundOk)) {
      int newSize = 2*Pdtutil_IntegerArraySize(itpMgr->coneBoundOk);
      Pdtutil_IntegerArrayResize(itpMgr->coneBoundOk,newSize);
    }
    while (n<=ring_i) {
      Pdtutil_IntegerArrayIncNum(itpMgr->coneBoundOk);        
      Pdtutil_IntegerArrayWrite(itpMgr->coneBoundOk,n,-1);
      n++;
    }
  }
  Pdtutil_IntegerArrayWrite(itpMgr->coneBoundOk,ring_i,cone_k);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_ItpMgrReadConeBoundOK(
  Trav_ItpMgr_t * itpMgr,
  int ring_i
)
{
  int n;
  if (itpMgr->coneBoundOk == NULL) return -1;
  n = Pdtutil_IntegerArrayNum(itpMgr->coneBoundOk);
  if (n<=ring_i) return -1;
  return Pdtutil_IntegerArrayRead(itpMgr->coneBoundOk,ring_i);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
int
Trav_ItpMgrResetConeBoundOK(
  Trav_ItpMgr_t * itpMgr
)
{
  int n;
  if (itpMgr->coneBoundOk == NULL) return -1;
  Pdtutil_IntegerArrayFree(itpMgr->coneBoundOk);
  itpMgr->coneBoundOk = Pdtutil_IntegerArrayAlloc(1);
  return 1;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
timeFrameShiftAcc(
  Ddi_Bdd_t * f,
  Ddi_Vararray_t ** timeFrameVars,
  Ddi_Bddarray_t ** timeFrameLits,
  int nTimeFrames
)
{
  int i, timeMark;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;

  timeMark = Ddi_BddReadMark(f);
  Pdtutil_Assert(nTimeFrames > timeMark, "timeMark error");

  for (i = nTimeFrames - 1; i > 0; i--) {
    if (vA == NULL) {
      vA = Ddi_VararrayDup(timeFrameVars[i - 1]);
      lA = Ddi_BddarrayDup(timeFrameLits[i]);
    } else {
      Ddi_VararrayAppend(vA, timeFrameVars[i - 1]);
      Ddi_BddarrayAppend(lA, timeFrameLits[i]);
    }
  }
  Ddi_BddComposeAcc(f, vA, lA);
  Ddi_BddWriteMark(f, timeMark + 1);

  Ddi_Free(vA);
  Ddi_Free(lA);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
timeFrameShiftBackAcc(
  Ddi_Bdd_t * f,
  Ddi_Vararray_t ** timeFrameVars,
  Ddi_Bddarray_t ** timeFrameLits,
  int nTimeFrames
)
{
  int i;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;

  for (i = nTimeFrames - 1; i > 0; i--) {
    if (vA == NULL) {
      vA = Ddi_VararrayDup(timeFrameVars[i]);
      lA = Ddi_BddarrayDup(timeFrameLits[i - 1]);
    } else {
      Ddi_VararrayAppend(vA, timeFrameVars[i]);
      Ddi_BddarrayAppend(lA, timeFrameLits[i - 1]);
    }
  }
  Ddi_BddComposeAcc(f, vA, lA);

  Ddi_Free(vA);
  Ddi_Free(lA);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
timeFrameShiftKAcc(
  Ddi_Bdd_t * f,
  Ddi_Vararray_t ** timeFrameVars,
  Ddi_Bddarray_t ** timeFrameLits,
  int nTimeFrames,
  int k
)
{
  int i;
  Ddi_Vararray_t *vA = NULL;
  Ddi_Bddarray_t *lA = NULL;

  if (k<=0) return;
  Pdtutil_Assert(k >= 1, "wrong k in time frame shift");

  for (i = nTimeFrames - 1; i >= k; i--) {
    if (vA == NULL) {
      vA = Ddi_VararrayDup(timeFrameVars[i - k]);
      lA = Ddi_BddarrayDup(timeFrameLits[i]);
    } else {
      Ddi_VararrayAppend(vA, timeFrameVars[i - k]);
      Ddi_BddarrayAppend(lA, timeFrameLits[i]);
    }
  }
  Pdtutil_Assert(vA != NULL, "NULL var array in time frame shift");
  Ddi_BddComposeAcc(f, vA, lA);

  Ddi_Free(vA);
  Ddi_Free(lA);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void
timeFrameAddAcc(
  Ddi_Bdd_t * f,
  Ddi_Vararray_t * pi,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * ns,
  Ddi_Varset_t * psVars,
  Ddi_Vararray_t * composeVars,
  Ddi_Bddarray_t * composeFuncs,
  Trav_TimeFrameInfo_t * timeFrames,
  int useAigVars
)
{
  int d = Ddi_BddReadMark(f);

  Ddi_Vararray_t **timeFrameVars;
  Ddi_Bddarray_t **timeFrameLits;

  timeFrameFindOrAdd(timeFrames, pi, ps, ns, psVars, d, 0 /*enableLoopFree */ ,
    useAigVars);
  timeFrameShiftAcc(f, timeFrames->PiVars, timeFrames->PiLits, d + 2);
  Ddi_BddComposeAcc(f, composeVars, composeFuncs);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
genLemmas(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * spec,
  Ddi_Bdd_t * careBdd,
  int bound,
  int simulDepth,
  int maxLemmaLevel,
  int *result
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(init);
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Varset_t *pivars, *smooth;
  Ddi_Bddarray_t *delta, *psLit, *nsLit;
  Ddi_Bdd_t *unroll, *tr;       //, *tr_i;
  int i, j, nState, initIsCube;
  long startTime;               //, currTime;
  Ddi_Vararray_t **timeFrameStates = NULL;
  Ddi_Vararray_t **timeFrameInputs = NULL;
  Ddi_Bddarray_t **timeFrameLemmas = NULL;

  //Ddi_Varset_t *supp;
  Pdtutil_VerbLevel_e verbosity = Fsm_MgrReadVerbosity(fsmMgr);
  Ddi_Bddarray_t *lemmasBase, *lemmasBaseUnroll, *lemmaArray, *resultLemmas = 0;    //, *lemmaArrayFilter;
  int *enableLemma, nTotLemmas, again, step, nProved;
  Ddi_Bdd_t *initNoClk = Ddi_BddDup(init);
  Ddi_Bdd_t *initBdd = Ddi_BddMakeMono(init);
  int maxBound = bound > simulDepth ? bound : simulDepth;

  if (travMgr->settings.clk != NULL) {
    /* remove clock variable from init when generating lemmas */
    Ddi_Var_t *ckv = Ddi_VarFromName(ddm, travMgr->settings.clk);

    Ddi_BddCofactorAcc(initNoClk, ckv, 1);
    Ddi_BddCofactorAcc(initBdd, ckv, 1);
  }

  ps = Fsm_MgrReadVarPS(fsmMgr);

  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);

  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  nState = Ddi_BddarrayNum(delta);
  psLit = Ddi_BddarrayAlloc(ddm, nState);
  nsLit = Ddi_BddarrayAlloc(ddm, nState);

  pivars = Ddi_VarsetMakeFromArray(pi);
  smooth = Ddi_VarsetMakeFromArray(ps);
  Ddi_VarsetUnionAcc(smooth, pivars);
  Ddi_Free(pivars);

  {
    Ddi_Bdd_t *initBdd = Ddi_BddMakeMono(init);

    initIsCube = Ddi_BddIsCube(initBdd);
    Ddi_Free(initBdd);
  }

  /* build tr */
  tr = Ddi_BddMakeConstAig(ddm, 1);
  for (i = 0; i < Ddi_BddarrayNum(delta); i++) {
    Ddi_Bdd_t *tr_i, *psLit_i, *nsLit_i;

    nsLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ns, i), 1);
    psLit_i = Ddi_BddMakeLiteralAig(Ddi_VararrayRead(ps, i), 1);

    Ddi_BddarrayWrite(nsLit, i, nsLit_i);
    Ddi_BddarrayWrite(psLit, i, psLit_i);
    tr_i = Ddi_BddXnor(nsLit_i, Ddi_BddarrayRead(delta, i));
    Ddi_BddAndAcc(tr, tr_i);
    Ddi_Free(tr_i);
    Ddi_Free(psLit_i);
    Ddi_Free(nsLit_i);
  }

  startTime = util_cpu_time();

  timeFrameStates = Pdtutil_Alloc(Ddi_Vararray_t *, maxBound + 1);
  timeFrameInputs = Pdtutil_Alloc(Ddi_Vararray_t *, maxBound + 1);
  timeFrameLemmas = Pdtutil_Alloc(Ddi_Bddarray_t *, maxBound + 1);

  for (i = 0; i < maxBound; i++) {
    char suffix[10];

    //Ddi_Vararray_t *vars_t;

    sprintf(suffix, "%d", i);
    timeFrameStates[i] = newTimeFrameVars(ps, suffix);
    timeFrameInputs[i] = newTimeFrameVars(pi, suffix);
  }
  timeFrameStates[maxBound] = Ddi_VararrayDup(ps);
  timeFrameInputs[maxBound] = Ddi_VararrayDup(pi);

  lemmasBase = Ddi_AigarrayNodes(delta, maxLemmaLevel);
  if (0) {
    char **combImpl = Ddi_AigCombinationalImplications(lemmasBase, 0);

    Pdtutil_Free(combImpl);
    combImpl = Ddi_AigCombinationalImplications(lemmasBase, 1);
    Pdtutil_Free(combImpl);
  }
  lemmasBaseUnroll = Ddi_BddarrayDup(lemmasBase);

  for (i = 0; i < simulDepth; i++) {
    char name[1000];
    int j;
    Ddi_Var_t *newSelV;
    Ddi_Bdd_t *newSelVLit = NULL;
    Ddi_Vararray_t *pi_i = timeFrameInputs[i];
    Ddi_Bddarray_t *piLits = Ddi_BddarrayMakeLiteralsAig(pi_i, 1);
    Ddi_Vararray_t *ps_i = timeFrameStates[i];
    Ddi_Bddarray_t *psLits = Ddi_BddarrayMakeLiteralsAig(ps_i, 1);

    sprintf(name, "LEMMAS_SIMUL_SELV_%d", i);
    newSelV = Ddi_VarFromName(ddm, name);
    if (newSelV == NULL) {
      newSelV = Ddi_VarNew(ddm);
      Ddi_VarAttachName(newSelV, name);
    }
    newSelVLit = Ddi_BddMakeLiteralAig(newSelV, 1);

    Ddi_AigarrayComposeAcc(lemmasBaseUnroll, pi, piLits);
    Ddi_AigarrayComposeAcc(lemmasBaseUnroll, ps, psLits);
    Ddi_Free(psLits);
    Ddi_Free(piLits);
    Ddi_AigarrayComposeAcc(lemmasBaseUnroll, ps_i, delta);

#if 1
    for (j = 0; j < Ddi_BddarrayNum(lemmasBase); j++) {
      Ddi_Bdd_t *newl = Ddi_BddIte(newSelVLit,
        Ddi_BddarrayRead(lemmasBaseUnroll, j),
        Ddi_BddarrayRead(lemmasBase, j));

      Ddi_BddarrayWrite(lemmasBaseUnroll, j, newl);
      Ddi_Free(newl);
    }
#endif

    Ddi_Free(newSelVLit);
  }

  Pdtutil_Assert(initIsCube, "init cube required");

  Ddi_AigarrayConstrainCubeAcc(lemmasBaseUnroll, initNoClk);

  lemmaArray = Ddi_AigComputeInitialLemmas(lemmasBaseUnroll,
    lemmasBase, initBdd, maxLemmaLevel);
  Ddi_Free(lemmasBaseUnroll);

  if (spec != NULL) {
    Ddi_Varset_t *suppSpec = Ddi_BddSupp(spec);

    Ddi_BddarrayInsertLast(lemmaArray, spec);
    if (Ddi_VarsetNum(suppSpec) == 1) {
      for (i = 0; i < Ddi_VararrayNum(ps); i++) {
        if (Ddi_VarInVarset(suppSpec, Ddi_VararrayRead(ps, i))) {
          Ddi_Bdd_t *lemmaSpec = Ddi_BddarrayRead(delta, i);

          Ddi_BddarrayInsertLast(lemmaArray, lemmaSpec);
          break;
        }
      }
    }
    Ddi_Free(suppSpec);
  }
#if 0
  lemmaArrayFilter = Ddi_BddarrayDup(lemmaArray);
  Ddi_AigarrayConstrainCubeAcc(lemmaArrayFilter, initNoClk);
  for (i = Ddi_BddarrayNum(lemmaArray) - 1; i >= 0; i--) {
    if (Ddi_BddIsZero(Ddi_BddarrayRead(lemmaArrayFilter, i))) {
      Ddi_BddarrayRemove(lemmaArray, i);
    } else {
      for (j = 0; j < i; j++) {
        Ddi_Bdd_t *l_j = Ddi_BddarrayRead(lemmaArray, j);

        if (Ddi_BddEqual(Ddi_BddarrayRead(lemmaArrayFilter, i), l_j)) {
          Ddi_BddarrayRemove(lemmaArray, i);
          break;
        }
      }
    }
  }

  Ddi_Free(lemmaArrayFilter);
#endif

  /*
   * build time frame tr and lemmas
   */

  unroll = Ddi_BddMakeConstAig(ddm, 1);
  for (i = 0; i < bound; i++) {
    Ddi_Vararray_t *pi_i = timeFrameInputs[i];
    Ddi_Vararray_t *ps_i = timeFrameStates[i];
    Ddi_Vararray_t *ns_i = timeFrameStates[i + 1];
    Ddi_Bddarray_t *piLits = Ddi_BddarrayMakeLiteralsAig(pi_i, 1);
    Ddi_Bddarray_t *psLits = Ddi_BddarrayMakeLiteralsAig(ps_i, 1);
    Ddi_Bddarray_t *nsLits = Ddi_BddarrayMakeLiteralsAig(ns_i, 1);
    Ddi_Bdd_t *tr_i = Ddi_BddDup(tr);

    Ddi_BddComposeAcc(tr_i, pi, piLits);
    Ddi_BddComposeAcc(tr_i, ps, psLits);
    Ddi_BddComposeAcc(tr_i, ns, nsLits);
    timeFrameLemmas[i] = Ddi_BddarrayDup(lemmaArray);
    Ddi_AigarrayComposeAcc(timeFrameLemmas[i], pi, piLits);
    Ddi_AigarrayComposeAcc(timeFrameLemmas[i], ps, psLits);
    Ddi_Free(piLits);
    Ddi_Free(psLits);
    Ddi_Free(nsLits);
    Ddi_BddAndAcc(unroll, tr_i);
    Ddi_Free(tr_i);
  }

  timeFrameLemmas[bound] = NULL;

  nTotLemmas = Ddi_BddarrayNum(lemmaArray);
  enableLemma = Pdtutil_Alloc(int,
    nTotLemmas
  );

  for (i = 0; i < nTotLemmas; i++) {
    enableLemma[i] = 1;
  }

  lemmasBaseUnroll = Ddi_BddarrayDup(lemmaArray);
  for (i = 0; i < bound; i++) {

    int *resultArray;
    int *resultArray2 = NULL;

    Ddi_Vararray_t *pi_i = timeFrameInputs[i];
    Ddi_Bddarray_t *piLits = Ddi_BddarrayMakeLiteralsAig(pi_i, 1);
    Ddi_Vararray_t *ps_i = timeFrameStates[i];
    Ddi_Bddarray_t *psLits = Ddi_BddarrayMakeLiteralsAig(ps_i, 1);

    //    resultArray2 = Ddi_AigProveLemmas(init,lemmasBaseUnroll,NULL);
    resultArray = Ddi_AigProveLemmasMinisat(initNoClk, lemmasBaseUnroll, NULL);
    //    resultArray = Ddi_AigProveLemmas(init,lemmasBaseUnroll,NULL);

    if (i < maxBound) {
      Ddi_AigarrayComposeAcc(lemmasBaseUnroll, pi, piLits);
      Ddi_AigarrayComposeAcc(lemmasBaseUnroll, ps, psLits);
      Ddi_AigarrayComposeAcc(lemmasBaseUnroll, ps_i, delta);
    }

    Ddi_Free(psLits);
    Ddi_Free(piLits);

    for (j = 0; j < nTotLemmas; j++) {
      if (enableLemma[j]) {
        //Pdtutil_Assert(resultArray[j]==resultArray2[j],"wrong lemma");
        enableLemma[j] = resultArray[j];
      }
    }

    Pdtutil_Free(resultArray);
    Pdtutil_Free(resultArray2);
  }
  Ddi_Free(lemmasBaseUnroll);

  step = 0;
  do {
    int k;
    int *resultArray;
    int *resultArray2 = NULL;
    Ddi_Bddarray_t *currAssumptions, *currLemmas;

    currAssumptions = Ddi_BddarrayAlloc(ddm, 0);
    currLemmas = Ddi_BddarrayAlloc(ddm, 0);

    for (j = 0; j < nTotLemmas; j++) {
      if (enableLemma[j]) {
        Ddi_Bdd_t *lemma = Ddi_BddarrayRead(lemmaArray, j);

        Ddi_BddarrayInsertLast(currLemmas, lemma);
        for (i = 0; i < bound; i++) {
          lemma = Ddi_BddarrayRead(timeFrameLemmas[i], j);
          if (!Ddi_BddIsOne(lemma)) {
            Ddi_BddarrayInsertLast(currAssumptions, lemma);
          }
        }
      }
    }
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr),
        "Gen lemmas iteration %d (curr lemmas: %d) - ", step,
        Ddi_BddarrayNum(currLemmas))
      );
    step++;

    if (0) {
      int s;
      Ddi_Bdd_t *aux = Ddi_BddDup(unroll);

      for (i = 0; i < Ddi_BddarrayNum(currAssumptions); i++) {
        Ddi_BddAndAcc(aux, Ddi_BddarrayRead(currAssumptions, i));
      }
      s = Ddi_AigSat(aux);
      Pdtutil_Assert(s, "Wrong unrolling in lemma proof");
      Ddi_Free(aux);
    }

    resultArray =
      Ddi_AigProveLemmasMinisat(unroll, currLemmas, currAssumptions);
    //    resultArray2 = Ddi_AigProveLemmas(unroll,currLemmas,currAssumptions);

    again = 0;
    nProved = 0;
    for (j = k = 0; j < nTotLemmas; j++) {
      if (enableLemma[j]) {
        //Pdtutil_Assert(resultArray[j]==resultArray2[j],"wrong lemma");
        enableLemma[j] = resultArray[k++];
        if (enableLemma[j]) {
          nProved++;
        } else {
          again = 1;
        }
      }
    }

    Pdtutil_Free(resultArray);
    Pdtutil_Free(resultArray2);

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "proved %d.\n", nProved)
      );

    if (!again) {
      resultLemmas = Ddi_BddarrayDup(currLemmas);
    }
    Ddi_Free(currAssumptions);
    Ddi_Free(currLemmas);

  } while (again);


  for (i = 0; i <= maxBound; i++) {
    Ddi_Free(timeFrameStates[i]);
    Ddi_Free(timeFrameInputs[i]);
    if (i < bound)
      Ddi_Free(timeFrameLemmas[i]);
  }

  Pdtutil_Free(timeFrameStates);
  Pdtutil_Free(timeFrameInputs);
  Pdtutil_Free(timeFrameLemmas);
  Pdtutil_Free(enableLemma);


  Ddi_Free(psLit);
  Ddi_Free(nsLit);
  Ddi_Free(smooth);
  Ddi_Free(tr);
  Ddi_Free(lemmasBase);
  Ddi_Free(lemmaArray);

  Ddi_Free(initBdd);
  Ddi_Free(initNoClk);
  Ddi_Free(unroll);

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    fprintf(tMgrO(travMgr), "Lemma generation time: %.2f.\n",
      ((float)(util_cpu_time() - startTime)) / 1000););

  return (resultLemmas);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
genLemmaClasses(
  /* NEW version!!! */
  Trav_Mgr_t * travMgr,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bddarray_t * initStub,
  Ddi_Bdd_t * invar,
  Ddi_Bdd_t * spec,
  Ddi_Bdd_t * careBdd,
  Ddi_Bddarray_t * constants,
  int bound,
  int do_compaction,
  int do_implication,
  int do_heavy,
  int *result,
  int max_false,
  Ddi_Bddarray_t * false_lemmas
)
{
  int timeLimit =
    (int)(travMgr->settings.aig.lemmasTimeLimit * 1000) /*milli-sec. */ ;
  int do_split = 1, done_bound = -1, again, level, nNodes, do_strong;
  int verbosity = Trav_MgrReadVerbosity(travMgr) >= Pdtutil_VerbLevelUsrMax_c;
  Ddi_Bddarray_t *lemmas = NULL, *delta, *lambda, *reprs =
    NULL, *equals = NULL;
  Ddi_Bddarray_t *lemmasOverAppr = NULL;
  Ddi_Bdd_t *initAig = NULL, *initBdd = NULL, *care = NULL, *node;
  long startTime = util_cpu_time();
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(Fsm_MgrReadDeltaBDD(fsmMgr));
  int aigCnfLevel = ddm->settings.aig.aigCnfLevel;

  ddm->settings.aig.aigCnfLevel = 0;

#if 0
  if (do_heavy == 0) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "Finding STRONG lemmas only.\n")
      );
  } else if (do_heavy == 1) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "Finding WEAK lemmas.\n")
      );
  } else if (do_heavy == 2) {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr),
        "Finding combinational and strong/weak lemmas.\n")
      );
  } else {
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "Finding all lemmas.\n")
      );
  }
#endif

  assert(init || initStub || careBdd);
  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  //delta = Ddi_BddarrayDup(Fsm_MgrReadDeltaBDD(fsmMgr));
  //lambda = Fsm_MgrReadLambdaBDD(fsmMgr);
  //Ddi_BddarrayAppend(delta, lambda);
  reprs = Ddi_BddarrayAlloc(ddm, 0);
  equals = Ddi_BddarrayAlloc(ddm, 0);
  if (false_lemmas == NULL) {
    max_false = 0;
  }
  if (max_false > 0) {
    lemmasOverAppr = Ddi_BddarrayAlloc(ddm, 0);
    //false_lemmas = Ddi_BddarrayAlloc(ddm, 0);
  }

  if (spec) {
    care = Ddi_BddAnd(careBdd, spec);
  } else {
    care = Ddi_BddDup(careBdd);
  }
  *result = 0;

  if (init && !initStub) {
    initAig = Ddi_BddDup(init);
    initBdd = Ddi_BddMakeMono(init);
    if (travMgr->settings.clk != NULL) {
      /* remove clock variable from init when generating lemmas */
      Ddi_Var_t *ckv = Ddi_VarFromName(ddm, travMgr->settings.clk);

      Ddi_BddCofactorAcc(initAig, ckv, 1);
      Ddi_BddCofactorAcc(initBdd, ckv, 1);
    }
    Pdtutil_Assert(Ddi_BddIsCube(initBdd), "init cube required");
    Ddi_Free(initBdd);
  } else if (!init && !initStub) {
    Pdtutil_Assert(careBdd != NULL, "care required");
    initAig = Ddi_BddDup(careBdd);
  }

  if (do_heavy != 1) {
    Ddi_Bdd_t *mySpec = NULL;
    int phase = 0, nd;
    int start = 0, end = Ddi_BddarrayNum(Fsm_MgrReadDeltaBDD(fsmMgr)) / 2;

    delta = Fsm_MgrReadDeltaBDD(fsmMgr);
    nd = Ddi_BddarrayNum(delta);
    if ( /*nd < 200 || */ Ddi_BddarraySize(delta) < 20000) {
      start = 0;
      end = Ddi_BddarrayNum(Fsm_MgrReadDeltaBDD(fsmMgr)) - 1;
      phase = 4;
    } else {
      end = Ddi_BddarrayNum(Fsm_MgrReadDeltaBDD(fsmMgr)) - 1;
      phase = 1;
    }
    do {
      int i;
      Ddi_Bddarray_t *deltaTmp = NULL;
      Ddi_Bdd_t *dummy = Ddi_BddMakeConstAig(ddm, 1);

      delta = Fsm_MgrReadDeltaBDD(fsmMgr);
      deltaTmp = Ddi_BddarrayDup(delta);
      nd = Ddi_BddarrayNum(delta);
      if (phase > 0 && phase < 4) {
        int *s = Pdtutil_Alloc(int, nd
        );
        int max, min, avg;

        for (i = 0; i < nd; i++) {
          s[i] = Ddi_BddSize(Ddi_BddarrayRead(delta, i));
          if (i == 0)
            max = min = s[i];
          else {
            if (min > s[i])
              min = s[i];
            if (max < s[i])
              max = s[i];
          }
        }
        avg = min + (max - min) / (5 - phase);
        for (i = start; i <= end; i++) {
#if 0
          if (s[i] < avg) {
            //  Ddi_BddarrayInsertLast(deltaTmp, Ddi_BddarrayRead(delta, i));
          }
#else
          if (s[i] >= avg) {
            Ddi_BddarrayWrite(deltaTmp, i, dummy);
          }
#endif
        }
        Pdtutil_Free(s);
        phase++;
        if (phase == 4) {
          start = 0;
          end = nd - 1;
        }
      } else {
        for (i = start; i <= end; i++) {
          Ddi_BddarrayInsertLast(deltaTmp, Ddi_BddarrayRead(delta, i));
        }
      }
      lemmas =
        Ddi_LemmaGenerateClasses(pi, ps, ns, deltaTmp, initAig, initStub,
        invar, spec, care, constants, do_split ? 0 : bound, max_false,
        do_compaction || do_implication, 0 /*do_implication */ , 1, verbosity,
        &timeLimit, reprs, equals, false_lemmas, result, &done_bound, &again);

      if ((do_compaction || do_implication) && Ddi_BddarrayNum(reprs)) {
        lemmas = fsmOptByEquiv(fsmMgr, reprs, equals, lemmas, careBdd, spec);
        Ddi_Free(reprs);
        Ddi_Free(equals);
        reprs = Ddi_BddarrayAlloc(ddm, 0);
        equals = Ddi_BddarrayAlloc(ddm, 0);
      }
      if (lemmas && max_false > 0 && bound && !do_split) {
        Ddi_BddarrayAppend(lemmasOverAppr, lemmas);
      }
      Ddi_Free(lemmas);
      if (phase == 0) {
        //      start = end;
        start = 0;
        end = nd - 2;
        phase = 1;
      } else if (0 && (phase == 2)) {
        start += nd / 5;
        end += nd / 5;
        if (start < 0)
          start = 0;
        if (end >= nd) {
          start = 0;
          end = nd - 1;
          mySpec = spec;
          phase = 3;
        }
      } else if (phase == 4) {
        start = -1;
      }
      Ddi_Free(deltaTmp);
      Ddi_Free(dummy);
    } while (start >= 0);
  }
  if (do_heavy == 3) {
    do_heavy = 1;
  }

  while (do_heavy >= 0) {
    do_strong = (do_heavy != 1);
    if (!*result && do_split && timeLimit && bound > 0) {
      again = 0;
      do {
        level = done_bound;
        if (done_bound >= bound) {
          bound = done_bound + 1;
        }
        delta = Ddi_BddarrayDup(Fsm_MgrReadDeltaBDD(fsmMgr));
        ddm = Ddi_ReadMgr(delta);
        //lambda = Fsm_MgrReadLambdaBDD(fsmMgr);
        //Ddi_BddarrayAppend(delta, lambda);
        //assert(lemmas==NULL);
        lemmas =
          Ddi_LemmaGenerateClasses(pi, ps, ns, delta, initAig, initStub,
          invar, spec, careBdd, constants, bound, max_false,
          do_compaction || do_implication, 0 /*do_implication */ , do_strong,
          verbosity, &timeLimit, reprs, equals,
          false_lemmas, result, &done_bound, &again);
#if 0
        if (done_bound == level) {
          again += Ddi_BddarrayNum(reprs);
        } else if (done_bound == level + 1) {
          again = Ddi_BddarrayNum(reprs);
        } else {
          again = 0;
        }
#else
        again = 0;              //+= (done_bound == level);
#endif
        if ((do_compaction || do_implication) && Ddi_BddarrayNum(reprs)) {
          lemmas = fsmOptByEquiv(fsmMgr, reprs, equals, lemmas, careBdd, spec);
          Ddi_Free(reprs);
          Ddi_Free(equals);
          reprs = Ddi_BddarrayAlloc(ddm, 0);
          equals = Ddi_BddarrayAlloc(ddm, 0);
        }
        Ddi_Free(delta);
        if (lemmas && max_false > 0 && bound) {
          Ddi_BddarrayAppend(lemmasOverAppr, lemmas);
        }
        if (1 || do_strong) {
          Ddi_Free(lemmas);
        }
      } while (again && timeLimit && !*result);
    }
    if (do_heavy < 2) {
      do_heavy = -1;
    } else {
      do_heavy = 1;
    }
  }

  if (0 && !*result && do_implication && timeLimit) {
    delta = Ddi_BddarrayDup(Fsm_MgrReadDeltaBDD(fsmMgr));
    ddm = Ddi_ReadMgr(delta);
    //lambda = Fsm_MgrReadLambdaBDD(fsmMgr);
    //Ddi_BddarrayAppend(delta, lambda);
    assert(lemmas == NULL);

    lemmas =
      Ddi_LemmaGenerateClasses(pi, ps, ns, delta, initAig, initStub,
      invar, spec, careBdd, NULL, bound, max_false, do_compaction, 1,
      do_strong, verbosity, &timeLimit, reprs, equals, false_lemmas,
      result, &done_bound, &again);

    if (do_compaction) {
      lemmas = fsmOptByEquiv(fsmMgr, reprs, equals, lemmas, careBdd, spec);
    }
    Ddi_Free(delta);
  }
  //exit(7);
  Ddi_Free(reprs);
  Ddi_Free(equals);
  Ddi_Free(initAig);
  Ddi_Free(care);

  //delta = Ddi_BddarrayDup(Fsm_MgrReadDeltaBDD(fsmMgr));
  //lambda = Fsm_MgrReadLambdaBDD(fsmMgr);
  //Ddi_BddarrayAppend(delta, lambda);
  //nNodes = Ddi_BddarraySize(delta);
  //Ddi_Free(delta);

  if (do_compaction) {
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "Total lemma generation time: %s.\n",
        util_print_time(util_cpu_time() - startTime))
      );
  }
  //exit(72);

  ddm->settings.aig.aigCnfLevel = aigCnfLevel;

  return lemmasOverAppr;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
lemmaApproxTrav(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * init,
  Ddi_Bddarray_t * initStub,
  Ddi_Bdd_t * invar,
  int bound,
  int do_implication,
  int timeLimit
)
{
  //int timeLimit = (int)(travMgr->settings.aig.lemmasTimeLimit*1000)/*milli-sec.*/;
  //int timeLimit = (int)(1200*1000)/*milli-sec.*/;
  int verbosity = Fsm_MgrReadVerbosity(fsmMgr) >= Pdtutil_VerbLevelUsrMax_c;
  Ddi_Bddarray_t *lemmas, *delta;
  Ddi_Bdd_t *initAig = NULL, *initBdd = NULL;
  long startTime = util_cpu_time();
  Ddi_Vararray_t *pi, *ps, *ns;
  Ddi_Mgr_t *ddm;

  timeLimit *= 1000;
  Pdtutil_Assert(init || initStub, "init state required");
  ps = Fsm_MgrReadVarPS(fsmMgr);
  ns = Fsm_MgrReadVarNS(fsmMgr);
  pi = Fsm_MgrReadVarI(fsmMgr);
  delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  ddm = Ddi_ReadMgr(delta);

  if (init && !initStub) {
    initAig = Ddi_BddDup(init);
    initBdd = Ddi_BddMakeMono(init);
    if (travMgr->settings.clk != NULL) {
      /* remove clock variable from init when generating lemmas */
      Ddi_Var_t *ckv = Ddi_VarFromName(ddm, travMgr->settings.clk);

      Ddi_BddCofactorAcc(initAig, ckv, 1);
      Ddi_BddCofactorAcc(initBdd, ckv, 1);
    }
    Pdtutil_Assert(Ddi_BddIsCube(initBdd), "init cube required");

    Ddi_Free(initBdd);
  }
#if 0
  lemmas = Ddi_LemmaApproxTrav(pi, ps, ns, delta, initAig, initStub,
    invar, bound, 0 /*do_implication */ , verbosity, timeLimit);
#endif
  Ddi_Free(initAig);
  return lemmas;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bddarray_t *
fsmOptByEquiv(
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bddarray_t * reprs,
  Ddi_Bddarray_t * equals,
  Ddi_Bddarray_t * lemmaArray,
  Ddi_Bdd_t * careBdd,
  Ddi_Bdd_t * spec
)
{
  Ddi_Bddarray_t *delta = Ddi_BddarrayDup(Fsm_MgrReadDeltaBDD(fsmMgr));
  Ddi_Bddarray_t *d = Fsm_MgrReadDeltaBDD(fsmMgr);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(delta);
  Ddi_Bddarray_t *aux = Ddi_BddarrayAlloc(ddm, 1);
  int i, j, initSize = Ddi_BddarraySize(d);
  Ddi_Bdd_t *one, *lemma = NULL;

  /* GpC */ Ddi_AigarrayOptByEquiv(Fsm_MgrReadDeltaBDD(fsmMgr), reprs,
    equals);
  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm),
      "Rewriting: |delta| = %d -> %d.\n", initSize, Ddi_BddarraySize(d))
    );
#if 0
  for (i = 0; i < Ddi_BddarrayNum(d); i++) {
    Ddi_Bdd_t *diff = Ddi_BddXor(Ddi_BddarrayRead(d, i),
      Ddi_BddarrayRead(delta, i));

    if (careBdd) {
      Ddi_BddAndAcc(diff, careBdd);
    }
    Pdtutil_Assert(!Ddi_AigSat(diff), "WRONG LEMMA OPT");
    Ddi_Free(diff);
  }
#endif
  Ddi_Free(delta);
  initSize = Ddi_BddarraySize(Fsm_MgrReadLambdaBDD(fsmMgr));
  Ddi_AigarrayOptByEquiv(Fsm_MgrReadLambdaBDD(fsmMgr), reprs, equals);
  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c,
    fprintf(dMgrO(ddm), "Rewriting: |lambda| = %d -> %d.\n", initSize,
      Ddi_BddarraySize(Fsm_MgrReadLambdaBDD(fsmMgr)))
    );
  if (0 && lemmaArray) {
    one = Ddi_BddSetAig(Ddi_BddMakeConst(ddm, 1));
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm), "Rewriting: #impl. = %d",
        Ddi_BddarrayNum(lemmaArray))
      );
    Ddi_AigarrayOptByEquiv(lemmaArray, reprs, equals);
    for (i = Ddi_BddarrayNum(lemmaArray) - 1; i >= 0; i--) {
      if (Ddi_BddEqual(Ddi_BddarrayRead(lemmaArray, i), one)) {
        Ddi_BddarrayQuickRemove(lemmaArray, i);
        continue;
      }
      for (j = Ddi_BddarrayNum(lemmaArray) - 1; j > i; j--) {
        lemma = Ddi_BddarrayRead(lemmaArray, j);
        if (Ddi_BddEqual(Ddi_BddarrayRead(lemmaArray, i), lemma))
          Ddi_BddarrayQuickRemove(lemmaArray, j);
      }
    }
    Ddi_Free(one);
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm), "-> %d.\n", Ddi_BddarrayNum(lemmaArray))
      );
  }
  Ddi_BddarrayWrite(aux, 0, careBdd);
  if (spec) {
    Ddi_BddarrayWrite(aux, 1, spec);
  }
  Ddi_AigarrayOptByEquiv(aux, reprs, equals);
  DdiGenericDataCopy((Ddi_Generic_t *) careBdd,
    (Ddi_Generic_t *) Ddi_BddarrayRead(aux, 0));
  if (spec) {
    DdiGenericDataCopy((Ddi_Generic_t *) spec,
      (Ddi_Generic_t *) Ddi_BddarrayRead(aux, 1));
  }
  Ddi_Free(aux);

  return lemmaArray;
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Vararray_t *
newTimeFrameVars(
  Ddi_Vararray_t * baseVars,
  char *nameSuffix
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(baseVars);
  int nVars = Ddi_VararrayNum(baseVars);
  Ddi_Vararray_t *newVars = Ddi_VararrayAlloc(ddm, nVars);
  int j;

  for (j = 0; j < Ddi_VararrayNum(baseVars); j++) {
    char name[1000];
    Ddi_Var_t *newv, *v = Ddi_VararrayRead(baseVars, j);

    sprintf(name, "%s_%s", Ddi_VarName(v), nameSuffix);
    newv = Ddi_VarFromName(ddm, name);
    if (newv == NULL) {
      newv = Ddi_VarNewBeforeVar(v);
      Ddi_VarAttachName(newv, name);
    }
    Ddi_VararrayWrite(newVars, j, newv);
  }
  return (newVars);
}



/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
checkFixPoint0(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * oldCheck,
  Ddi_Bdd_t * check
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(check);
  Ddi_Vararray_t *ps = Fsm_MgrReadVarPS(fsmMgr);
  Ddi_Varset_t *psVars, *corePsVars, *noCorePsVars;
  Ddi_Bdd_t *myOldCheck, *myCheck;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bdd_t *careAig;

  int i, ret = 0;

  if (oldCheck == NULL) {
    /* no inner check: force no fixpoint */
    return (0);
  }

  careAig = Ddi_BddMakeConstAig(ddm, 1);

  myOldCheck = Ddi_BddDup(oldCheck);
  myCheck = Ddi_BddDup(check);

  psVars = Ddi_VarsetMakeFromArray(ps);
  corePsVars = Ddi_VarsetVoid(ddm);
  for (i = 0; i < 100 && i < 1 * Ddi_VararrayNum(ps) / 4; i++) {
    Ddi_VarsetAddAcc(corePsVars, Ddi_VararrayRead(ps, i));
  }
  noCorePsVars = Ddi_VarsetDiff(psVars, corePsVars);

  while (1) {

    Ddi_Bdd_t *window, *oldR, *wc;
    Ddi_Bdd_t *cexAig, *cexState, *cexStatePrevious;

    /* simple check */

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "simple check: %d.\n", Ddi_BddSize(myCheck))
      );

    cexAig = Ddi_AigSatWithCex(myCheck);

    if (cexAig == NULL) {
      ret = 1;
      break;
    }

    Ddi_BddSetMono(cexAig);
    cexState = Ddi_BddExistProject(cexAig, psVars);
    cexStatePrevious = Ddi_BddDup(cexState);
    Ddi_BddSetAig(cexStatePrevious);
    Ddi_BddAndAcc(cexStatePrevious, myOldCheck);
    Ddi_Free(cexAig);
    if (!Ddi_AigSat(cexStatePrevious)) {
      /* new state found: no fix point */
      Ddi_Free(cexState);
      Ddi_Free(cexStatePrevious);
      ret = 0;
      break;
    }
    Ddi_Free(cexStatePrevious);

    window = Ddi_BddExistProject(cexState, corePsVars);
    Ddi_BddSetAig(window);
    Ddi_Free(cexState);

    oldR = Ddi_BddAnd(window, myOldCheck);
    DdiAigRedRemovalAcc(oldR, careAig, -1, -1.0);

    //    Ddi_AigExistProjectAcc(oldR,noCorePsVars,NULL,1,1);
    Ddi_BddExistProjectAcc(oldR, noCorePsVars);
    //    Ddi_AigExistProjectAllSolutionAcc(oldR,noCorePsVars,careAig,-1);

    Ddi_BddAndAcc(oldR, window);
    wc = Ddi_BddAnd(window, myCheck);
    Ddi_BddDiffAcc(wc, oldR);
    Ddi_Free(oldR);
    Ddi_BddDiffAcc(myCheck, window);
    Ddi_BddDiffAcc(myOldCheck, window);
    Ddi_Free(window);

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "window check: %d.\n", Ddi_BddSize(wc))
      );

    if (Ddi_AigSat(wc)) {
      /* new state reached: no fix point */
      Ddi_Free(wc);
      ret = 0;
      break;
    }
    Ddi_Free(wc);

  }

  Ddi_Free(psVars);
  Ddi_Free(corePsVars);
  Ddi_Free(noCorePsVars);
  Ddi_Free(myCheck);
  Ddi_Free(careAig);
  Ddi_Free(myOldCheck);

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    fprintf(tMgrO(travMgr), "fp: %d.\n", ret)
    );

  return (ret);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
checkFixPoint(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * oldCheck,
  Ddi_Bdd_t * check,
  Ddi_Bdd_t * care
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(check);
  Ddi_Vararray_t *ps = Fsm_MgrReadVarPS(fsmMgr);
  Ddi_Vararray_t *pi = Fsm_MgrReadVarI(fsmMgr);
  Ddi_Varset_t *psVars = NULL, *piVars = NULL,
    *corePiVars = NULL, *noCorePiVars = NULL, *timePiVars = NULL;
  Ddi_Bdd_t *myOldCheck, *myCheck;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bdd_t *careAig;

  int i, ret = 0, step;
  int *checkStateVars;
  int fullR;

  if (oldCheck == NULL) {
    /* no inner check: force no fixpoint */
    return (0);
  }
  if (Ddi_BddIsOne(oldCheck) || Ddi_BddIsZero(check)) {
    /* trivial fixpoint */
    return (1);
  }

  psVars = Ddi_VarsetMakeFromArray(ps);
  piVars = Ddi_VarsetMakeFromArray(pi);

#if 0
  timePiVars = Ddi_BddSupp(check);
  corePiVars = Ddi_BddSupp(oldCheck);
  Ddi_VarsetUnionAcc(timePiVars, corePiVars);
  Ddi_Free(corePiVars);
  Ddi_VarsetDiffAcc(timePiVars, psVars);
  Ddi_VarsetDiffAcc(timePiVars, piVars);

  corePiVars = Ddi_VarsetVoid(ddm);
  for (i = 0; i < 1000 && i < 4 * Ddi_VararrayNum(pi) / 4; i++) {
    Ddi_VarsetAddAcc(corePiVars, Ddi_VararrayRead(pi, i));
  }
  noCorePiVars = Ddi_VarsetDiff(piVars, corePiVars);

  //  Ddi_VarsetUnionAcc(corePiVars,timePiVars);
#endif

  fullR = 0;

  ret = Ddi_AigCheckFixPoint(oldCheck, check, care, psVars, 10);

  Ddi_Free(psVars);
  Ddi_Free(piVars);
  Ddi_Free(timePiVars);
  Ddi_Free(corePiVars);
  Ddi_Free(noCorePiVars);

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelDevMax_c,
    fprintf(tMgrO(travMgr), "fp: %d.\n", ret)
    );

  return (ret);

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
checkFixPointByInterpolant(
  Trav_ItpMgr_t * itpMgr,
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * check,
  Ddi_Bdd_t * oldCheck,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * care,
  Ddi_Bdd_t * careBdd,
  Ddi_Bdd_t * rOut,
  Ddi_Bdd_t * careOut,
  Ddi_Bddarray_t * oldCheckAuxLits,
  int optLevel,
  int *pabort,
  unsigned long time_limit,
  int coneDepth,
  int firstIter,
  int maxIter,
  Trav_TimeFrameInfo_t *timeFrames
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(check);
  Ddi_Bdd_t *careBck,
    *careBckBdd = NULL, *kCone, *kConeOld = NULL, *kConeRings = NULL, *myInit;
  int abort, activeIterOffset;
  static int cntCalls = 0;

  Ddi_Bdd_t *careOne = NULL;
  if (Ddi_BddSize(care)>200000) {
    careOne = Ddi_BddMakeConstAig(ddm,1);
  }
  
  Pdtutil_VerbosityMgr(travMgr,
    Pdtutil_VerbLevelUsrMin_c,
    fprintf(tMgrO(travMgr),
      "Interpolant FINITE RUN: cone=%d, care=%d.\n",
      Ddi_BddSize(check), Ddi_BddSize(care)
    )
    );

  kCone = Ddi_BddCompose(check, itpMgr->ps, itpMgr->nsLit);
  if (Ddi_BddIsPartDisj(kCone)) {
    int np = Ddi_BddPartNum(kCone);
    int mark = Ddi_BddReadMark(Ddi_BddPartRead(check, np - 1));

    Ddi_BddWriteMark(Ddi_BddPartRead(kCone, np - 1), mark);
  }
  if (oldCheck != NULL) {
    kConeOld = Ddi_BddCompose(oldCheck, itpMgr->ps, itpMgr->nsLit);
  }
  careBck = Ddi_BddCompose(care, itpMgr->ps, itpMgr->nsLit);
  if (careBdd != NULL) {
    careBckBdd = Ddi_BddSwapVars(careBdd, itpMgr->ps, itpMgr->ns);
  }
  if (init == NULL) {
    myInit = Ddi_BddMakeConstAig(ddm, 0);
  } else {
    myInit = Ddi_BddCompose(init, itpMgr->ps, itpMgr->nsLit);
  }

  Pdtutil_Assert(careOut == NULL || Ddi_BddIsOne(careOut), "invalid careOut");

  if (Ddi_BddIsPartDisj(kCone)) {
    int i, n = Ddi_BddPartNum(kCone);

    kConeRings = kCone;
    kCone = Ddi_BddDup(Ddi_BddPartRead(kConeRings, n - 1));
  } else if (0 && itpMgr->itpOpt > 0) {
    int j;
    Ddi_Bdd_t *partCone = Ddi_AigPartitionTop(kCone, 1);
    Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);

    if (Ddi_BddPartNum(partCone) > 1) {
      int np = Ddi_BddPartNum(partCone);

      for (j = 0; j < Ddi_BddPartNum(partCone); j++) {
        Ddi_Bdd_t *p_j = Ddi_BddPartRead(partCone, j);
        Ddi_Varset_t *sm = Ddi_BddSupp(p_j);

        Ddi_VarsetDiffAcc(sm, itpMgr->nsvars);
        if (Ddi_VarsetIsVoid(sm)) {
          Ddi_BddDiffAcc(careBck, p_j);
          if (careOut != NULL) {
            Ddi_BddDiffAcc(careOut, p_j);
          }
          Ddi_BddPartWrite(partCone, j, myZero);
        }
        Ddi_Free(sm);
      }
      Ddi_BddSetAig(partCone);
      Ddi_DataCopy(kCone, partCone);
    }
    Ddi_Free(partCone);
    Ddi_Free(myZero);
  }
#if 1
  Ddi_BddNotAcc(careBck);
  if (Ddi_BddIsPartDisj(kCone)) {
    int i;

    for (i = 0; i < Ddi_BddPartNum(kCone); i++) {
      Ddi_Bdd_t *p_i = Ddi_BddPartRead(kCone, i);

      Ddi_BddOrAcc(p_i, careBck);
    }
  }
  Ddi_BddOrAcc(kCone, careBck);
  Ddi_BddNotAcc(careBck);
#endif

  if (0) {
    char fname[20];
    Ddi_Bdd_t *r = Ddi_BddMakeMono(kCone);

    Ddi_BddExistProjectAcc(r, itpMgr->nsvars);

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "# Reached states = %20.16g.\n",
        Ddi_BddCountMinterm(r, Ddi_VararrayNum(itpMgr->ps)))
      );

    sprintf(fname, "rch_%d", cntCalls++);

    if (0) {
      Ddi_Bdd_t *ref = Ddi_BddLoad(ddm, DDDMP_VAR_MATCHNAMES,
        DDDMP_MODE_DEFAULT, fname, NULL);

      if (Ddi_BddIncluded(r, ref))
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "r < ref.\n")
          );
      if (Ddi_BddIncluded(ref, r))
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "r > ref.\n")
          );
      if (!Ddi_BddEqual(ref, r))
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "r != ref.\n")
          );
      Ddi_Free(ref);
      sprintf(fname, "rchNew_%d", cntCalls - 1);
      Ddi_BddStore(r, "reached", DDDMP_MODE_TEXT, fname, NULL);
    } else {
      Ddi_BddStore(r, "reached", DDDMP_MODE_TEXT, fname, NULL);
    }

    Ddi_Free(r);
  }

  activeIterOffset = interpolantInnerLoop(travMgr,
                       kCone, kConeOld, kConeRings, myInit,
                       careOne!=NULL?careOne:careBck,
                       careBckBdd,
    rOut, careOut, oldCheckAuxLits, itpMgr, &abort, optLevel, firstIter,
    maxIter, time_limit);
  Ddi_Free(careOne);

  Ddi_BddComposeAcc(careBck, itpMgr->ns, itpMgr->psLit);
  Ddi_DataCopy(care, careBck);

  if (Ddi_BddIsPartDisj(check)) {
    // done only to align arrays
    Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);

    while (Ddi_BddPartNum(kConeRings) > Ddi_BddPartNum(check)) {
      Ddi_BddPartInsert(check, 0, myZero);
    }
    Ddi_Free(myZero);
  }

  if (rOut != NULL) {
    Ddi_BddComposeAcc(rOut, itpMgr->ns, itpMgr->psLit);
  }
  if (careOut != NULL) {
    Ddi_BddComposeAcc(careOut, itpMgr->ns, itpMgr->delta);
  }

  *pabort = 0;
  if (abort == 2) {
    Ddi_BddComposeAcc(myInit, itpMgr->ns, itpMgr->psLit);
    DdiGenericDataCopy((Ddi_Generic_t *) init, (Ddi_Generic_t *) myInit);
    *pabort = 1;
  } else if (abort < 0) {
    /* unsound proof */
    *pabort = -1;
    abort = 0;
  }

  Ddi_Free(myInit);
  Ddi_Free(kConeRings);
  Ddi_Free(kConeOld);
  Ddi_Free(kCone);
  Ddi_Free(careBck);
  Ddi_Free(careBckBdd);

  if (abort) {
    return (-(activeIterOffset + 1));
  } else {
    return (activeIterOffset);
  }
}



/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
checkFixPoint1(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * oldCheck,
  Ddi_Bdd_t * check,
  Ddi_Bdd_t * care
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(check);
  Ddi_Vararray_t *ps = Fsm_MgrReadVarPS(fsmMgr);
  Ddi_Vararray_t *pi = Fsm_MgrReadVarI(fsmMgr);
  Ddi_Varset_t *psVars, *piVars, *corePiVars, *noCorePiVars, *timePiVars;
  Ddi_Bdd_t *myOldCheck, *myCheck;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bdd_t *careAig;

  int i, ret = 0;

  if (oldCheck == NULL) {
    /* no inner check: force no fixpoint */
    return (0);
  }

  careAig = Ddi_BddMakeConstAig(ddm, 1);

  myOldCheck = Ddi_BddDup(oldCheck);
  myCheck = Ddi_BddDup(check);

  psVars = Ddi_VarsetMakeFromArray(ps);
  piVars = Ddi_VarsetMakeFromArray(pi);

  timePiVars = Ddi_BddSupp(myCheck);
  corePiVars = Ddi_BddSupp(myOldCheck);
  Ddi_VarsetUnionAcc(timePiVars, corePiVars);
  Ddi_Free(corePiVars);
  Ddi_VarsetDiffAcc(timePiVars, psVars);
  Ddi_VarsetDiffAcc(timePiVars, piVars);

  corePiVars = Ddi_VarsetVoid(ddm);
  for (i = 0; i < 1000 && i < 4 * Ddi_VararrayNum(pi) / 4; i++) {
    Ddi_VarsetAddAcc(corePiVars, Ddi_VararrayRead(pi, i));
  }
  noCorePiVars = Ddi_VarsetDiff(piVars, corePiVars);

  //  Ddi_VarsetUnionAcc(corePiVars,timePiVars);

  while (1) {

    Ddi_Bdd_t *window, *oldR, *wc;
    Ddi_Bdd_t *cexAig, *cexState, *cexStatePrevious;

    /* simple check */

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "simple check: %d.\n", Ddi_BddSize(myCheck))
      );

    wc = Ddi_BddAnd(myCheck, careAig);
    cexAig = Ddi_AigSatWithCex(wc);
    Ddi_Free(wc);

    if (cexAig == NULL) {
      ret = 1;
      break;
    }

    Ddi_BddSetMono(cexAig);
    cexState = Ddi_BddExistProject(cexAig, psVars);
    cexStatePrevious = Ddi_BddDup(cexState);
    Ddi_BddSetAig(cexStatePrevious);
    Ddi_BddAndAcc(cexStatePrevious, myOldCheck);
    Ddi_Free(cexState);
    if (!Ddi_AigSat(cexStatePrevious)) {
      /* new state found: no fix point */
      Ddi_Free(cexAig);
      Ddi_Free(cexStatePrevious);
      ret = 0;
      break;
    }
    Ddi_Free(cexStatePrevious);

    cexState = Ddi_BddExist(cexAig, psVars);
    Ddi_BddExistAcc(cexState, corePiVars);
    Ddi_Free(cexAig);
    Ddi_BddSetAig(cexState);

    window = Ddi_BddDup(myCheck);
    Ddi_AigConstrainCubeAcc(window, cexState);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "new window: %d.\n", Ddi_BddSize(window))
      );
    if (0) {
      Ddi_BddExistAcc(window, corePiVars);
    } else {
      Ddi_Bdd_t *wPartial = Ddi_BddDup(window);

      if (Ddi_AigExistAllSolutionAcc(wPartial,
          corePiVars, careAig, NULL, 10) == NULL) {
        Ddi_BddNotAcc(wPartial);
        DdiAigRedRemovalAcc(window, wPartial, -1, -1.0);
        Ddi_AigExistAcc(window, corePiVars, wPartial, 0, 0, -1.0);
        Ddi_BddNotAcc(wPartial);
        Ddi_BddOrAcc(window, wPartial);
        Ddi_Free(wPartial);
      }
    }
    oldR = Ddi_BddDup(myOldCheck);
    DdiAigRedRemovalAcc(oldR, window, -1, -1.0);
    wc = Ddi_BddDup(oldR);

    Ddi_BddExistAcc(cexState, piVars);
    Ddi_AigConstrainCubeAcc(oldR, cexState);
    Ddi_Free(cexState);

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "old R with cex (partial): %d.\n",
        Ddi_BddSize(oldR))
      );
    Ddi_AigExistAcc(oldR, piVars, window, 1, 0, -1.0);
    //    Ddi_AigExistProjectAcc(oldR,psVars,careAig,1,0);
    DdiAigRedRemovalAcc(oldR, window, -1, -1.0);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "old R with cex (full): %d.\n",
        Ddi_BddSize(oldR))
      );
    Ddi_AigExistAcc(oldR, piVars, window, 0, 0, -1.0);
    //    Ddi_AigExistProjectAllSolutionAcc(oldR,psVars,careAig,-1);

#if 1
    Ddi_BddNotAcc(oldR);
    //    Ddi_BddAndAcc(oldR,window);
    DdiAigRedRemovalAcc(wc, oldR, -1, -1.0);
    //    Ddi_AigExistProjectAcc(wc,psVars,oldR,0,0);
    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "old R tot: %d.\n", Ddi_BddSize(wc))
      );
    Ddi_AigOptByBddPartial(wc, oldR, -1.0);
    {
      Ddi_Bdd_t *wcPartial = Ddi_BddDup(wc);

      if (Ddi_AigExistProjectAllSolutionAcc(wcPartial,
          psVars, oldR, 10) == NULL) {
        Ddi_BddNotAcc(wcPartial);
        Ddi_BddAndAcc(oldR, wcPartial);
        Ddi_Free(wcPartial);
        DdiAigRedRemovalAcc(wc, oldR, -1, -1.0);
        DdiAigRedRemovalAcc(wc, window, -1, -1.0);
        //      Ddi_BddAndAcc(wc,oldR);
        //        Ddi_BddAndAcc(wc,window);
        Ddi_AigExistProjectAcc(wc, psVars, oldR, 0, 0, -1.0);
      } else {
        Ddi_Free(wc);
        wc = wcPartial;
      }
    }
    DdiAigRedRemovalAcc(wc, oldR, -1, -1.0);
    DdiAigRedRemovalAcc(wc, window, -1, -1.0);
    Ddi_AigExistProjectAcc(wc, psVars, oldR, 0, 0, -1.0);
    //    Ddi_AigExistProjectAllSolutionAcc(wc,psVars,oldR,-1);
    Ddi_BddNotAcc(oldR);
#else
    Ddi_Free(wc);
    wc = Ddi_BddMakeConstAig(ddm, 0);
#endif

    Ddi_BddOrAcc(wc, oldR);
    Ddi_Free(oldR);
    Ddi_BddNotAcc(wc);
    Ddi_BddAndAcc(wc, window);

    Ddi_BddNotAcc(window);
    Ddi_BddAndAcc(careAig, window);
    DdiAigRedRemovalAcc(myCheck, careAig, -1, -1.0);
    DdiAigRedRemovalAcc(myOldCheck, careAig, -1, -1.0);

    Ddi_Free(window);

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "window check: %d.\n", Ddi_BddSize(wc))
      );

    Ddi_BddAndAcc(wc, careAig);
    if (Ddi_AigSat(wc)) {
      /* new state reached: no fix point */
      Ddi_Free(wc);
      ret = 0;
      break;
    }
    Ddi_Free(wc);

  }

  Ddi_Free(psVars);
  Ddi_Free(piVars);
  Ddi_Free(timePiVars);
  Ddi_Free(corePiVars);
  Ddi_Free(noCorePiVars);
  Ddi_Free(myCheck);
  Ddi_Free(careAig);
  Ddi_Free(myOldCheck);

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    fprintf(tMgrO(travMgr), "fp: %d.\n", ret)
    );

  return (ret);

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
checkFixPoint2(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * oldCheck,
  Ddi_Bdd_t * check,
  Ddi_Bdd_t * care,
  int maxIter
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(check);
  Ddi_Vararray_t *ps = Fsm_MgrReadVarPS(fsmMgr);
  Ddi_Vararray_t *pi = Fsm_MgrReadVarI(fsmMgr);
  Ddi_Varset_t *psVars,
    *piVars, *corePiVars = NULL, *noCorePiVars = NULL, *timePiVars = NULL;
  Ddi_Bdd_t *myOldCheck, *myCheck;
  Pdtutil_VerbLevel_e verbosity = Trav_MgrReadVerbosity(travMgr);
  Ddi_Bdd_t *careAig;

  int i, ret = 0, step;
  int fullR;

  if (oldCheck == NULL) {
    /* no inner check: force no fixpoint */
    return (0);
  }

  if (care == NULL) {
    careAig = Ddi_BddMakeConstAig(ddm, 1);
  } else {
    careAig = Ddi_BddDup(care);
  }

  myOldCheck = Ddi_BddDup(oldCheck);
  myCheck = Ddi_BddDup(check);

  psVars = Ddi_VarsetMakeFromArray(ps);
  piVars = Ddi_VarsetMakeFromArray(pi);

#if 0
  timePiVars = Ddi_BddSupp(myCheck);
  corePiVars = Ddi_BddSupp(myOldCheck);
  Ddi_VarsetUnionAcc(timePiVars, corePiVars);
  Ddi_Free(corePiVars);
  Ddi_VarsetDiffAcc(timePiVars, psVars);
  Ddi_VarsetDiffAcc(timePiVars, piVars);

  corePiVars = Ddi_VarsetVoid(ddm);
#if 1
  for (i = 0; i < 1000 && i < 4 * Ddi_VararrayNum(pi) / 4; i++) {
    Ddi_VarsetAddAcc(corePiVars, Ddi_VararrayRead(pi, i));
  }
#endif
  noCorePiVars = Ddi_VarsetDiff(piVars, corePiVars);

  //  Ddi_VarsetUnionAcc(corePiVars,timePiVars);
#endif

  fullR = 0;

  ret = -1;                     /* abort */

  for (step = 0; step < maxIter; step++) {

    Ddi_Bdd_t *window, *wc;
    Ddi_Bdd_t *cexAig, *cexState, *cexStatePrevious;

    /* simple check */

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(tMgrO(travMgr), "simple check: %d(%d).\n",
        Ddi_BddSize(myCheck), Ddi_BddSize(careAig))
      );

    wc = Ddi_BddAnd(myCheck, careAig);
    Ddi_BddDiffAcc(wc, myOldCheck);
    DdiAigRedRemovalAcc(wc, NULL, -1, 300.0);
    cexAig = Ddi_AigSatWithCex(wc);
    Ddi_Free(wc);

    if (cexAig == NULL) {
      ret = 1;
      break;
    }
    //    Ddi_BddSetMono(cexAig);
    cexState = Ddi_BddCubeExistProject(cexAig, psVars);
    cexStatePrevious = Ddi_BddDup(cexState);
    Ddi_BddSetAig(cexStatePrevious);
    Ddi_BddAndAcc(cexStatePrevious, myOldCheck);
    Ddi_Free(cexState);
    Ddi_Free(cexAig);

    Ddi_BddAndAcc(cexStatePrevious, careAig);
    cexAig = Ddi_AigSatWithCex(cexStatePrevious);
    Ddi_Free(cexStatePrevious);

    if (cexAig == NULL) {
      /* new state found: no fix point */
      ret = 0;
      break;
    }
    //    Ddi_BddSetMono(cexAig);

    if (0 && step > 20) {
      Ddi_BddExistProjectAcc(cexAig, piVars);
    } else {
      //      Ddi_BddExistAcc(cexAig,psVars);
      Ddi_BddCubeExistAcc(cexAig, psVars);
    }

    Ddi_BddSetAig(cexAig);

    window = Ddi_BddDup(myOldCheck);
    if (step < 10) {
      Ddi_AigConstrainCubeAcc(window, cexAig);
      Ddi_BddExistProjectAcc(window, psVars);
    } else {
      Ddi_Varset_t *sm = Ddi_BddSupp(window);

      Ddi_VarsetDiffAcc(sm, psVars);
      Ddi_AigExistSubsetAcc(window, sm, careAig, cexAig, 1, -1.0);
      Ddi_Free(sm);
    }

    Ddi_Free(cexAig);
    Ddi_BddDiffAcc(careAig, window);

    if (0 && ((step + 1) % 20 == 0)) {
      Ddi_AigExistProjectAcc(myOldCheck, psVars, careAig, 1, 0, -1.0);
      Ddi_AigExistProjectAcc(myOldCheck, psVars, careAig, 1, 0, -1.0);
      DdiAigRedRemovalAcc(myOldCheck, careAig, -1, -1.0);
    }

    Ddi_Free(window);

  }

  if (care != NULL && ret != 1 && Ddi_BddSize(care) < 20000) {
    Ddi_Varset_t *supp = Ddi_BddSupp(myOldCheck);

    Ddi_VarsetDiffAcc(supp, psVars);
    if (Ddi_VarsetIsVoid(supp)) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "CFP2 - refine CARE %d+%d=",
          Ddi_BddSize(care), Ddi_BddSize(myOldCheck))
        );
      Ddi_BddDiffAcc(careAig, myOldCheck);
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "%d.\n", Ddi_BddSize(care))
        );
    }
    Ddi_Free(supp);
    {
      int rrl = Ddi_MgrReadAigRedRemLevel(ddm);

      Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRem_c, inum, rrl + 1);
      DdiAigRedRemovalAcc(careAig, NULL, -1, -1.0);
      Ddi_MgrSetOption(ddm, Pdt_DdiAigRedRem_c, inum, rrl);
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "CFP2 - new CARE=%d.\n", Ddi_BddSize(care))
        );
    }
    DdiGenericDataCopy((Ddi_Generic_t *) care, (Ddi_Generic_t *) careAig);
  }

  Ddi_Free(psVars);
  Ddi_Free(piVars);
  Ddi_Free(timePiVars);
  Ddi_Free(corePiVars);
  Ddi_Free(noCorePiVars);
  Ddi_Free(myCheck);
  Ddi_Free(careAig);
  Ddi_Free(myOldCheck);

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    fprintf(tMgrO(travMgr), "fp2: %d.\n", ret)
    );

  return (ret);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
imgBddAigAppr(
  Tr_Mgr_t * trMgr /* Tr Manager */ ,
  Ddi_Bdd_t * tr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * care,
  Ddi_Varset_t * coreVars,
  Ddi_Varset_t * satVars,
  int maxSupp,
  int apprLevel
)
{
  Ddi_Bdd_t *apprTo, *partTo;
  int i, n = Ddi_BddPartNum(tr);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);

  apprTo = Ddi_BddMakeConstAig(ddm, 1);
  for (i = 0; i < n; i++) {
    partTo = imgBddAigSat(trMgr,
      Ddi_BddPartRead(tr, i), from, care, coreVars, satVars, maxSupp,
      apprLevel);
    Ddi_BddAndAcc(apprTo, partTo);
    Ddi_Free(partTo);
  }
  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c,
    fprintf(dMgrO(ddm),
      "imgBddAigAppr[%d/%d]: %d.\n", i, n, Ddi_BddSize(apprTo)
    )
    );

  return (apprTo);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
imgBddAig(
  Tr_Mgr_t * trMgr /* Tr Manager */ ,
  Ddi_Bdd_t * tr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * care,
  Ddi_Varset_t * coreVars
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  Ddi_Vararray_t *ps = Tr_MgrReadPS(trMgr);
  Ddi_Vararray_t *ns = Tr_MgrReadNS(trMgr);
  Ddi_Vararray_t *pi = Tr_MgrReadI(trMgr);
  Ddi_Varset_t *psVars, *piVars, *nsVars, *corePiVars, *corePsVars;
  Ddi_Bdd_t *myTo, *myFromTr;
  Pdtutil_VerbLevel_e verbosity = Tr_MgrReadVerbosity(trMgr);
  Ddi_Bdd_t *careAig;
  Ddi_Vararray_t *coreArray;

  int i, ret = 0, step;
  int fullR;

  if (care == NULL) {
    careAig = Ddi_BddMakeConstAig(ddm, 1);
  } else {
    careAig = Ddi_BddDup(care);
  }

  myTo = Ddi_BddMakeConst(ddm, 0);
  myFromTr = Ddi_BddMakeAig(tr);
  Ddi_BddAndAcc(myFromTr, from);

  psVars = Ddi_VarsetMakeFromArray(ps);
  nsVars = Ddi_VarsetMakeFromArray(ns);
  piVars = Ddi_VarsetMakeFromArray(pi);

  //  Ddi_AigExistProjectAcc(myFromTr,nsVars,careAig,3,0,-1.0);

  corePsVars = Ddi_BddSupp(from);
  if (coreVars != NULL) {
    Ddi_VarsetIntersectAcc(corePsVars, coreVars);
  } else {
    coreArray = Ddi_VararrayMakeFromVarset(corePsVars, 1);
    Ddi_Free(corePsVars);
    corePsVars = Ddi_VarsetDup(psVars);
    for (i = 0; i < 0 && i < 2 * Ddi_VararrayNum(coreArray) / 2; i++) {
      Ddi_VarsetRemoveAcc(corePsVars, Ddi_VararrayRead(coreArray, i));
    }
    Ddi_Free(coreArray);
  }

#if 0
  corePiVars = Ddi_BddSupp(myFromTr);
  Ddi_VarsetDiffAcc(corePiVars, psVars);
  Ddi_VarsetDiffAcc(corePiVars, nsVars);

  corePiVars = Ddi_VarsetVoid(ddm);
  for (i = 0; i < 1000 && i < 4 * Ddi_VararrayNum(pi) / 4; i++) {
    Ddi_VarsetAddAcc(corePiVars, Ddi_VararrayRead(pi, i));
  }
#endif

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm), "imgBddAig: %d(%d).\n", Ddi_BddSize(tr),
      Ddi_BddSize(from))
    );

  for (step = 0;; step++) {

    Ddi_Bdd_t *window, *wc, *wTo, *myToAig;
    Ddi_Bdd_t *cexAig, *cexState, *cexStatePrevious;

    /* simple check */

    myToAig = Ddi_BddMakeAig(myTo);
    wc = Ddi_BddAnd(myFromTr, careAig);
    Ddi_BddDiffAcc(wc, myToAig);
    Ddi_Free(myToAig);
    cexAig = Ddi_AigSatWithCex(wc);
    Ddi_Free(wc);

    if (cexAig == NULL) {
      break;
    }

    Ddi_BddSetMono(cexAig);
#if 0
    cexState = Ddi_BddExistProject(cexAig, nsVars);
    wTo = Ddi_BddDup(cexState);
#else
    cexState = Ddi_BddExistProject(cexAig, corePsVars);
    Ddi_Free(cexAig);
    Ddi_BddSetAig(cexState);
    wTo = Ddi_BddDup(myFromTr);
    Ddi_AigConstrainCubeAcc(wTo, cexState);
    Ddi_BddSetMono(wTo);
    Ddi_BddExistProjectAcc(wTo, nsVars);
#endif
    Ddi_BddOrAcc(myTo, wTo);

    Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
      fprintf(dMgrO(ddm), "imgBddAig TO[%d] : %d(%d).\n", step,
        Ddi_BddSize(myTo), Ddi_BddSize(wTo))
      );

    if (0 && step % 100 == 0)
      Ddi_MgrReduceHeap(ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);

    Ddi_Free(wTo);
    Ddi_Free(cexState);

  }

  Ddi_MgrReduceHeap(ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);

  Ddi_Free(psVars);
  Ddi_Free(nsVars);
  Ddi_Free(piVars);
  Ddi_Free(myFromTr);
  Ddi_Free(careAig);
  Ddi_Free(corePsVars);

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm), "imgBddAig: %d.\n", Ddi_BddSize(myTo))
    );

  return (myTo);
}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
imgBddAigSat(
  Tr_Mgr_t * trMgr /* Tr Manager */ ,
  Ddi_Bdd_t * tr,
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * care,
  Ddi_Varset_t * coreVars,
  Ddi_Varset_t * satVars,
  int maxSupp,
  int apprLevel
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  Ddi_Vararray_t *ps = Tr_MgrReadPS(trMgr);
  Ddi_Vararray_t *ns = Tr_MgrReadNS(trMgr);
  Ddi_Vararray_t *pi = Tr_MgrReadI(trMgr);
  Ddi_Varset_t *psVars, *piVars, *nsVars, *corePiVars, *corePsVars;
  Ddi_Bdd_t *myTo, *myFromTr;
  Pdtutil_VerbLevel_e verbosity = Tr_MgrReadVerbosity(trMgr);
  Ddi_Bdd_t *careAig;
  Ddi_Vararray_t *coreArray;
  Ddi_Varset_t *supp;

  int i, ret = 0, step;
  int fullR;

  if (care == NULL) {
    careAig = Ddi_BddMakeConstAig(ddm, 1);
  } else {
    careAig = Ddi_BddDup(care);
  }

  myFromTr = Ddi_BddMakeAig(tr);
  Ddi_BddAndAcc(myFromTr, from);

  nsVars = Ddi_VarsetMakeFromArray(ns);
  supp = Ddi_BddSupp(myFromTr);
  Ddi_VarsetIntersectAcc(supp, nsVars);
  if (coreVars != NULL) {
    Ddi_VarsetIntersectAcc(supp, coreVars);
  }
  if (Ddi_VarsetNum(supp) > 1) {
    coreArray = Ddi_VararrayMakeFromVarset(supp, 1);
    Ddi_Free(supp);
    supp = Ddi_VarsetVoid(ddm);
    i = Ddi_VararrayNum(coreArray) - maxSupp;
    if (i < 0)
      i = 0;
    for (; i < Ddi_VararrayNum(coreArray); i++) {
      Ddi_VarsetAddAcc(supp, Ddi_VararrayRead(coreArray, i));
    }
    Ddi_Free(coreArray);
  }
  //  Ddi_AigExistProjectAcc(myFromTr,nsVars,careAig,3,0,-1.0);

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm), "imgBddAigSat: %d(%d).\n", Ddi_BddSize(tr),
      Ddi_BddSize(from))
    );
  //  Ddi_VarsetPrint(supp,0,0,tMgrO(travMgr));

  if (apprLevel > 1) {
    Ddi_AigProjectRefineOutImgAcc(myFromTr, supp, careAig,
      16 * apprLevel, apprLevel);
  } else if (apprLevel > 0) {
    Ddi_Bdd_t *tmpImg, *myFromTr0 = Ddi_BddDup(myFromTr);

    Pdtutil_Assert(satVars != NULL, "missing SAT vars");
    tmpImg = Ddi_AigProjectSatTernaryImgAcc(myFromTr0,
      supp, satVars, careAig, 512, apprLevel);
    if (tmpImg == NULL) {
      /* not full Img done */
      Ddi_Bdd_t *myCareAig = Ddi_BddDiff(careAig, myFromTr0);

      Ddi_AigProjectRefineOutImgAcc(myFromTr, supp, myCareAig,
        64 * apprLevel, apprLevel);
      Ddi_BddOrAcc(myFromTr, myFromTr0);
      Ddi_Free(myCareAig);
    } else {
      Ddi_DataCopy(myFromTr, myFromTr0);
    }
    Ddi_Free(myFromTr0);
  } else
    Ddi_AigProjectAllSolutionImgAcc(myFromTr, supp, careAig, -1, apprLevel);
  //  myTo = Ddi_BddMakeMono(myFromTr);
  myTo = Ddi_BddDup(myFromTr);

  //  Ddi_MgrReduceHeap (ddm, Ddi_ReorderingMethodString2Enum("sift"), 0);

  Ddi_Free(supp);
  Ddi_Free(nsVars);
  Ddi_Free(myFromTr);
  Ddi_Free(careAig);

  Pdtutil_VerbosityLocal(verbosity, Pdtutil_VerbLevelUsrMax_c,
    fprintf(dMgrO(ddm), "imgBddAig: %d.\n", Ddi_BddSize(myTo))
    );

  return (myTo);

}


/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static int
trLinearSquaring(
  Ddi_Bdd_t * tr,
  Ddi_Vararray_t * ps,
  Ddi_Bddarray_t * delta,
  Ddi_Vararray_t * pi,
  Ddi_Bdd_t * care,
  int nFrames
)
{
  int i, j;

  Ddi_Mgr_t *ddm = Ddi_ReadMgr(tr);
  Ddi_Vararray_t *oldPi = Ddi_VararrayDup(pi);
  Ddi_Bddarray_t *newPiLit = Ddi_BddarrayAlloc(ddm, Ddi_VararrayNum(pi));
  Ddi_Varset_t *smooth;
  int abcOpt = Ddi_MgrReadAigAbcOptLevel(ddm);
  Ddi_Bdd_t *oldTr = Ddi_BddDup(tr);

  for (i = 0; i < nFrames; i++) {
    for (j = 0; j < Ddi_VararrayNum(oldPi); j++) {
      char name[1000];
      Ddi_Var_t *v = Ddi_VararrayRead(oldPi, j);
      Ddi_Var_t *newv = Ddi_VarNewBeforeVar(v);
      Ddi_Bdd_t *newvLit;

      sprintf(name, "PDT_TF_VAR_%s_%d", Ddi_VarName(v), i);
      Ddi_VarAttachName(newv, name);
      Ddi_VararrayInsertLast(pi, newv);
      newvLit = Ddi_BddMakeLiteralAig(newv, 1);
      Ddi_BddarrayWrite(newPiLit, j, newvLit);
      Ddi_Free(newvLit);
    } Ddi_BddComposeAcc(tr, oldPi, newPiLit);

    Ddi_BddComposeAcc(tr, ps, delta);
    //    Ddi_BddOrAcc(tr,oldTr);
    if (abcOpt > 2) {
      ddiAbcOptAcc(tr, -1.0);
    }
  }
  Ddi_Free(newPiLit);
  Ddi_Free(oldPi);

  smooth = Ddi_VarsetMakeFromArray(pi);
  Ddi_AigExistAcc(tr, smooth, care, 0, 0, -1.0);
  DdiAigRedRemovalAcc(tr, care, -1, -1.0);
  Ddi_Free(smooth);
  Ddi_Free(oldTr);
  return 0;
}



/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static Ddi_Vararray_t **
composeRelationalWithNewTimeFrameVars(
  Ddi_Bdd_t * f,
  Ddi_Bdd_t * invar,
  Ddi_Vararray_t * ps,
  Ddi_Bddarray_t * delta,
  Ddi_Vararray_t * pi,
  Ddi_Varset_t * psIn,
  char *piNamePrefix,
  char *psNamePrefix,
  int frameSuffix,
  int doRel
)
{
  int j;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *invarspec_i, *tr;
  Ddi_Vararray_t *newPi;
  Ddi_Bddarray_t *newPiLits;
  Ddi_Vararray_t *newPs;
  Ddi_Bddarray_t *newPsLits;
  char suffix[20];
  Ddi_Varset_t *supp = Ddi_BddSupp(f);

  Ddi_Vararray_t **VA2 = Pdtutil_Alloc(Ddi_Vararray_t *, 2);

  sprintf(suffix, "%d", frameSuffix);
  newPs = Ddi_VararrayMakeNewVars(ps, psNamePrefix, suffix, 2);
  newPsLits = Ddi_BddarrayMakeLiteralsAig(newPs, 1);
  sprintf(suffix, "%d", frameSuffix + 1);
  newPi = Ddi_VararrayMakeNewVars(pi, piNamePrefix, suffix, 2);
  newPiLits = Ddi_BddarrayMakeLiteralsAig(newPi, 1);

  if (psIn != NULL) {
    Ddi_VarsetIntersectAcc(supp, psIn);
  }

  if (doRel) {
    tr = Ddi_BddMakeConstAig(ddm, 1);

    for (j = 0; j < Ddi_BddarrayNum(delta); j++) {
      Ddi_Var_t *ps_j = Ddi_VararrayRead(ps, j);

      if (Ddi_VarInVarset(supp, ps_j)) {
        Ddi_Bdd_t *psLit_j = Ddi_BddarrayRead(newPsLits, j);
        Ddi_Bdd_t *tr_j = Ddi_BddXnor(psLit_j, Ddi_BddarrayRead(delta, j));

        Ddi_BddAndAcc(tr, tr_j);
        Ddi_Free(tr_j);
      }
    }
    if (invar != NULL) {
      Ddi_BddAndAcc(tr, invar);
    }
    Ddi_BddComposeAcc(tr, pi, newPiLits);

    Ddi_BddComposeAcc(f, ps, newPsLits);
    Ddi_BddPartInsertLast(f, tr);

    Ddi_Free(tr);
  } else {
    if (0) {
      Ddi_Varset_t *supp = Ddi_BddSupp(f);
      Ddi_Varset_t *psV = Ddi_VarsetMakeFromArray(ps);

      Ddi_VarsetIntersectAcc(supp, psV);
      Ddi_VarsetPrint(supp, 0, 0, dMgrO(ddm));
      Ddi_Free(supp);
      Ddi_Free(psV);
    }

    Ddi_BddComposeAcc(f, ps, delta);
    if (invar != NULL) {
      Ddi_BddAndAcc(f, invar);
    }
    Ddi_BddComposeAcc(f, pi, newPiLits);
  }

  Ddi_Free(newPiLits);
  Ddi_Free(newPsLits);

  VA2[0] = newPi;
  VA2[1] = newPs;

  Ddi_Free(supp);

  return (VA2);

}

/**Function*******************************************************************
  Synopsis    []
  Description []
  SideEffects []
  SeeAlso     []
******************************************************************************/
static void *
refineRelationalTimeFrames(
  Ddi_Bdd_t * conePart,
  Ddi_Varset_t * psIn,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * pi,
  Ddi_Bddarray_t * delta,
  Ddi_Vararray_t ** timeFramePsVars,
  Ddi_Vararray_t ** timeFramePiVars,
  char *varNamePrefix,
  int cegar
)
{
  int i, j, np, nd;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(conePart);
  Ddi_Varset_t *s_0 = NULL;
  int nRefined = 0;
  int *psRefined;

  np = Ddi_BddPartNum(conePart);
  nd = Ddi_BddarrayNum(delta);

  psRefined = Pdtutil_Alloc(int,
    Ddi_VararrayNum(ps)
  );

  for (i = 0; i < Ddi_VararrayNum(ps); i++) {
    psRefined[i] = 0;
  }
  for (i = 0; i < np; i++) {
    Ddi_Varset_t *s_i = Ddi_BddSupp(Ddi_BddPartRead(conePart, i));

    if (i > 0) {
      Ddi_Var_t *refV = NULL;
      Ddi_Varset_t *sToRefine = Ddi_VarsetDiff(s_0, s_i);
      Ddi_Vararray_t *sA;
      Ddi_Bdd_t *trBase = Ddi_BddPartRead(conePart, i);

      //      Ddi_VarsetDiffAcc(sToRefine,freeVars);
      // remove s_0 vars from s_i
      Ddi_VarsetDiffAcc(s_i, s_0);

      if (Ddi_VarsetNum(sToRefine) > 0) {

        Ddi_Bddarray_t *psTimeLits = NULL;
        Ddi_Bddarray_t *piTimeLits = NULL;

        piTimeLits = Ddi_BddarrayMakeLiteralsAig(timeFramePiVars[i - 1], 1);
        if (i < np - 1) {
          psTimeLits = Ddi_BddarrayMakeLiteralsAig(timeFramePsVars[i], 1);
        }
        sA = Ddi_VararrayMakeFromVarset(sToRefine, 1);

        for (j = 0; j < Ddi_VararrayNum(sA); j++) {
          int k;
          Ddi_Bdd_t *trNew;
          Ddi_Var_t *refV, *v = Ddi_VararrayRead(sA, j);
          Ddi_Bdd_t *delta_k;

          refV = Ddi_VarFindRefVar(v, "PDT_ITPSEQ_REL_TF_PS_", '_');
          if (refV == NULL || ((cegar == 1)
              && !Ddi_VarInVarset(psIn, refV))
            || ((cegar == 2) && !Ddi_VarInVarset(psIn, v))) {
            continue;
          }
          for (k = 0; k < nd; k++) {
            if (Ddi_VararrayRead(ps, k) == refV) {
              break;
            }
          }
          Pdtutil_Assert(k < nd, "Ref Var not found");
          trNew = Ddi_BddMakeLiteralAig(v, 1);
          delta_k = Ddi_BddDup(Ddi_BddarrayRead(delta, k));
          Ddi_BddComposeAcc(delta_k, pi, piTimeLits);
          if (i < np - 1) {
            Ddi_BddComposeAcc(delta_k, ps, psTimeLits);
          }
          Ddi_BddXnorAcc(trNew, delta_k);
          Ddi_BddAndAcc(trBase, trNew);
          Ddi_Free(trNew);
          Ddi_Free(delta_k);
          if (!psRefined[k]) {
            psRefined[k] = 1;
            nRefined++;
          }
        }
        Ddi_Free(psTimeLits);
        Ddi_Free(piTimeLits);

        Ddi_Free(sA);
      }
      Ddi_Free(sToRefine);
    }
    Ddi_Free(s_0);
    s_0 = s_i;
  }

  Ddi_Free(s_0);

  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm), "Nrefined: %d.\n", nRefined)
    );

}



/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static Ddi_Varsetarray_t *
computeFsmCoiVars(
  Fsm_Mgr_t * fsmMgr,
  Ddi_Bdd_t * p,
  int maxIter
)
{
  Ddi_Varsetarray_t *coirings;
  Ddi_Varset_t *ps, *ns, *supp, *cone, *New, *newnew;
  Ddi_Bddarray_t *delta;
  Ddi_Vararray_t *psv;
  Ddi_Vararray_t *nsv;
  Ddi_Varsetarray_t *domain, *range;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(p);

  int i, j, np;

  psv = Fsm_MgrReadVarPS(fsmMgr);
  nsv = Fsm_MgrReadVarNS(fsmMgr);
  delta = Fsm_MgrReadDeltaBDD(fsmMgr);

  ps = Ddi_VarsetMakeFromArray(psv);
  ns = Ddi_VarsetMakeFromArray(nsv);

  coirings = Ddi_VarsetarrayAlloc(ddm, 0);

  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm), "COI Reduction: ")
    );

  np = Ddi_BddarrayNum(delta);
  domain = Ddi_VarsetarrayAlloc(ddm, np);
  range = Ddi_VarsetarrayAlloc(ddm, np);
  for (i = 0; i < np; i++) {
    supp = Ddi_BddSupp(Ddi_BddarrayRead(delta, i));
    Ddi_VarsetIntersectAcc(supp, ps);
    Ddi_VarsetarrayWrite(domain, i, supp);
    Ddi_Free(supp);
    supp = Ddi_VarsetMakeFromVar(Ddi_VararrayRead(nsv, i));
    Ddi_VarsetarrayWrite(range, i, supp);
    Ddi_Free(supp);
  }
  cone = Ddi_BddSupp(p);

  Ddi_VarsetIntersectAcc(cone, ps); /* remove PI vars */

  New = Ddi_VarsetDup(cone);

  j = 0;
  while (((j++ < maxIter) || (maxIter <= 0)) && (!Ddi_VarsetIsVoid(New))) {
    Ddi_VarsetUnionAcc(cone, New);
    Ddi_VarsetarrayInsertLast(coirings, cone);
    Ddi_VarsetSwapVarsAcc(New, psv, nsv);
    newnew = Ddi_VarsetVoid(ddm);
    for (i = 0; i < np; i++) {
      Ddi_Varset_t *common;

      supp = Ddi_VarsetarrayRead(range, i);
      common = Ddi_VarsetIntersect(supp, New);
      if (!Ddi_VarsetIsVoid(common)) {
#if 0
        if ((coiSets != NULL) && (coiSets[i] != NULL)) {
          Ddi_VarsetUnionAcc(cone, coiSets[i]);
        } else
#endif
        {
          Ddi_VarsetUnionAcc(newnew, Ddi_VarsetarrayRead(domain, i));
        }
      }
      Ddi_Free(common);
    }
    Ddi_Free(New);
    New = Ddi_VarsetDiff(newnew, cone);
    Ddi_Free(newnew);
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm), ".(%d)", Ddi_VarsetNum(cone))
      );
  }

  fprintf(dMgrO(ddm),
    "COI Reduction Performed: Kept %d State Vars out of %d.\n",
    Ddi_VarsetNum(cone), Ddi_VarsetNum(ps));

  Ddi_Free(New);
  Ddi_Free(domain);
  Ddi_Free(range);
  Ddi_Free(ps);
  Ddi_Free(ns);

  Ddi_Free(cone);

  return (coirings);

}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static void
fsmCoiReduction(
  Fsm_Mgr_t * fsmMgr,
  Ddi_Varset_t * coiVars
)
{
  Ddi_Vararray_t *pi = Fsm_MgrReadVarI(fsmMgr);
  Ddi_Vararray_t *ps = Fsm_MgrReadVarPS(fsmMgr);
  Ddi_Vararray_t *ns = Fsm_MgrReadVarNS(fsmMgr);
  Ddi_Bddarray_t *delta = Fsm_MgrReadDeltaBDD(fsmMgr);
  Ddi_Varset_t *dsupp, *stubsupp;
  int i, n;
  Ddi_Bddarray_t *initStub = Fsm_MgrReadInitStubBDD(fsmMgr);
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(delta);

  n = Ddi_BddarrayNum(delta);

  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c,
    fprintf(dMgrO(ddm), "Original DELTA - size: %d - partitions: %d.\n",
      Ddi_BddarraySize(delta), n)
    );

  for (i = n - 1; i >= 0; i--) {
    Ddi_Var_t *pv_i = Ddi_VararrayRead(ps, i);
    int isConstr = Ddi_VarName(pv_i) != NULL &&
      (strcmp(Ddi_VarName(pv_i), "PDT_BDD_INVAR_VAR$PS") == 0);
    if (!Ddi_VarInVarset(coiVars, pv_i) && !isConstr) {
      Ddi_VararrayRemove(ps, i);
      Ddi_VararrayRemove(ns, i);
      Ddi_BddarrayRemove(delta, i);
      if (initStub != NULL) {
        Ddi_BddarrayRemove(initStub, i);
      }
    }
  }

  n = Ddi_BddarrayNum(delta);

  Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
    Pdtutil_VerbLevelNone_c,
    fprintf(dMgrO(ddm), "Reduced DELTA - size: %d - partitions: %d.\n",
      Ddi_BddarraySize(delta), n)
    );

  dsupp = Ddi_BddarraySupp(delta);
  if (initStub != NULL) {
    stubsupp = Ddi_BddarraySupp(initStub);
    Ddi_VarsetUnionAcc(dsupp, stubsupp);
    Ddi_Free(stubsupp);
  }
  for (i = Ddi_VararrayNum(pi) - 1; i >= 0; i--) {
    Ddi_Var_t *pi_i = Ddi_VararrayRead(pi, i);

    if (!Ddi_VarInVarset(dsupp, pi_i)) {
      Ddi_VararrayRemove(pi, i);
    }
  }
  Ddi_Free(dsupp);
}



/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
bmcItpSeqCegarCheck(
  Trav_Mgr_t * travMgr /* Traversal Manager */ ,
  Ddi_Bddarray_t * delta,
  Ddi_Bdd_t * cone,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * extInvar,
  Ddi_Bdd_t * coneAndInit,
  Ddi_Bddarray_t * initStub,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * ns,
  Ddi_Vararray_t * pi,
  int maxBound,
  float seqSerial,
  int doCegar,
  int fwdBwdFP,
  int seqReverse,
  int seqGroup
)
{
  int i, initIsCube = 0;
  Ddi_Bdd_t *cex, *myCone, *myConePart, *cubeInit;
  Ddi_Varset_t *piv2, *piv, *psv;
  Ddi_Bdd_t *invar = Ddi_BddNot(cone);
  int doRelational = 1;
  long startTime, startTime1, currTime, endTime;
  Ddi_Bddarray_t *psSubstLits = NULL, *psLits = NULL;
  Ddi_Vararray_t *psNew = NULL;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(delta);
  Ddi_Bdd_t *rPart = NULL, *rPartB = NULL;
  int fixPoint, failure;
  int rTh = 10000;
  int doRefine = 1;
  Ddi_Varset_t *psIn = NULL, *psOut = NULL;
  int nPsVars = Ddi_VararrayNum(ps);
  Ddi_Vararray_t *assumeEqVars = NULL;
  Ddi_Bddarray_t *assumeEqSubst = NULL;

  int timeFrameArrayNum = 0, timeFrameArraySize = 1;
  int exactAssume = 1;
  int doBmc = 0;
  int enSeq;
  int useEqConstr = Trav_MgrReadImplAbstr(travMgr) > 1;

  Ddi_Vararray_t **timeFramePiVars =
    Pdtutil_Alloc(Ddi_Vararray_t *, timeFrameArraySize);
  Ddi_Vararray_t **timeFramePsVars =
    Pdtutil_Alloc(Ddi_Vararray_t *, timeFrameArraySize);


  if (doCegar < 0) {
    exactAssume = 0;
    doCegar *= -1;
  }

  psv = Ddi_VarsetMakeFromArray(ps);

  piv = Ddi_BddarraySupp(delta);

  Ddi_VarsetDiffAcc(piv, psv);
  myCone = Ddi_BddDup(cone);

  if (initStub == NULL) {
    cubeInit = Ddi_BddMakeMono(init);
    initIsCube = Ddi_BddIsCube(cubeInit);
    Ddi_Free(cubeInit);
  } else if (invar != NULL) {
    Ddi_BddDiffAcc(invar, init);
  }

  if (extInvar != NULL) {
    Ddi_BddAndAcc(invar, extInvar);
  }

  if (doCegar) {
    psIn = Ddi_BddSupp(myCone);
    Ddi_VarsetIntersectAcc(psIn, psv);
  }

  myConePart = Ddi_BddDup(myCone);
  Ddi_BddSetPartConj(myConePart);

  //  rPart = Ddi_BddMakeConstAig(ddm,0);
  //Ddi_BddSetPartDisj(rPart);

  if (fwdBwdFP >= 5) {
    doBmc = 1;
  } else {
    if (fwdBwdFP >= 0) {
      rPart = Ddi_BddMakePartConjVoid(ddm);
    }
    if (fwdBwdFP <= 0) {
      rPartB = Ddi_BddMakePartConjVoid(ddm);
    }
  }

  if (useEqConstr) {
    assumeEqVars = Ddi_VararrayAlloc(ddm, 0);
    assumeEqSubst = Ddi_BddarrayAlloc(ddm, 0);
  }

  for (i = fixPoint = failure = 0;
    (!fixPoint && !failure) /*&&i<maxBound */ ; i++) {

    Ddi_Bdd_t *check = Ddi_BddDup(myCone);
    Ddi_Bdd_t *checkPart = Ddi_BddDup(myConePart);
    Ddi_Bddarray_t *firstFrame = Ddi_BddarrayDup(delta);
    Ddi_Vararray_t *pi2, *ps2;
    char suffix[20];
    Ddi_Vararray_t **VA2;
    Ddi_Bdd_t *myInvar = exactAssume ? invar : extInvar;

    if (seqGroup > 0 && i < seqGroup)
      myInvar = extInvar;

    sprintf(suffix, "%d", i + 1);

    /* compose just 1st time-frame */
    /* propagate implications */

    if (initStub != NULL) {
      Ddi_BddarrayComposeAcc(firstFrame, ps, initStub);
    } else if (initIsCube) {
      Ddi_AigarrayConstrainCubeAcc(firstFrame, init);
    } else {
      Pdtutil_Assert(0, "CUBE init required");
    }

    if (!doBmc) {
      VA2 = composeRelationalWithNewTimeFrameVars(check,
        extInvar, ps, firstFrame,
        pi, psIn, "PDT_ITPSEQ_REL_TF_PI", "PDT_ITPSEQ_REL_TF_PS", i, 0);
      pi2 = VA2[0];
      ps2 = VA2[1];
      Pdtutil_Free(VA2);
      Ddi_Free(pi2);
      Ddi_Free(ps2);
    }

    VA2 = composeRelationalWithNewTimeFrameVars(checkPart,
      extInvar, ps, firstFrame,
      pi, psIn, "PDT_ITPSEQ_REL_TF_PI", "PDT_ITPSEQ_REL_TF_PS", i, 1);
    pi2 = VA2[0];
    ps2 = VA2[1];
    Pdtutil_Free(VA2);

    if (psNew == NULL) {
      psNew = Ddi_VararrayDup(ps2);
      psLits = Ddi_BddarrayMakeLiteralsAig(ps, 1);
      psSubstLits = Ddi_BddarrayDup(psLits);
    } else {
      Ddi_VararrayAppend(psNew, ps2);
      Ddi_BddarrayAppend(psSubstLits, psLits);
    }

    Ddi_Free(pi2);
    Ddi_Free(ps2);

    if (0 && doRelational) {
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "FI: ")
        );
      Ddi_AigPartPropImplications(checkPart, NULL, 1);
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "BI: ")
        );
      Ddi_AigPartPropImplications(checkPart, NULL, 0);
    }

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr),
        "BMC at bound %d: size %d (Part: %d) (Unroll: %d (Part: %d)).\n",
        i + 1, Ddi_BddSize(check), Ddi_BddSize(checkPart),
        Ddi_BddSize(myCone), Ddi_BddSize(myConePart))
      );

    if (doBmc) {
      startTime = util_cpu_time();
      cex = Ddi_AigSatWithCex(checkPart);
      if (cex != NULL)
        failure = 1;
      currTime = util_cpu_time();
    } else {
      startTime = util_cpu_time();
      cex = Ddi_AigSatWithCex(check);
      if (cex != NULL)
        failure = 1;
      currTime = util_cpu_time();
    }

    if (cex != NULL) {
      //Ddi_DataCopy(coneAndInit,check);
      Ddi_Free(check);
      Ddi_Free(checkPart);
      Ddi_Free(firstFrame);
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(tMgrO(travMgr), "FAILURE: BMC SAT at bound %d.\n", i)
        );
      break;
    }

    Ddi_Free(cex);

    enSeq = !failure && !doBmc && Ddi_BddSize(checkPart) > 1;
    if (seqGroup > 0 && (i + 1) % seqGroup != 0)
      enSeq = 0;

    if (enSeq) {
      int myRefine = doRefine;

      while (doCegar && myRefine) {
        cex = Ddi_AigSatWithCex(checkPart);
        myRefine = cex != NULL;
        if (myRefine) {
          int nRefined;
          Ddi_Varset_t *refVars = Ddi_AigRefineRelationalPartWithCex(checkPart,
            cex, psIn, "PDT_ITPSEQ_REL_TF_PS_", doCegar);

          if (refVars == NULL || Ddi_VarsetIsVoid(refVars)) {
            Ddi_Free(refVars);
            refVars = Ddi_AigRefineRelationalPartWithCex(checkPart,
              cex, psIn, "PDT_ITPSEQ_REL_TF_PS_", -doCegar);
          }
          if (refVars != NULL && ((nRefined = Ddi_VarsetNum(refVars)) > 0)) {
            printf("CEGAR: refining %d vars\n", nRefined);
            Ddi_VarsetUnionAcc(psIn, refVars);
          }
          Ddi_Free(refVars);
          refineRelationalTimeFrames(myConePart,
            psIn, ps, pi, delta,
            timeFramePsVars, timeFramePiVars, "PDT_ITPSEQ_REL_TF_PS_",
            doCegar);
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr),
              "cegar refinement: %d/%d state vars.\n",
              Ddi_VarsetNum(psIn), Ddi_VararrayNum(ps))
            );
          Ddi_Free(checkPart);
          checkPart = Ddi_BddDup(myConePart);
          VA2 =
            composeRelationalWithNewTimeFrameVars(checkPart, extInvar,
            ps, firstFrame, pi, psIn, "PDT_ITPSEQ_REL_TF_PI",
            "PDT_ITPSEQ_REL_TF_PS", i, 1);
          pi2 = VA2[0];
          ps2 = VA2[1];
          Pdtutil_Free(VA2);
          Ddi_Free(pi2);
          Ddi_Free(ps2);
        }
        Ddi_Free(cex);
      }

      if (useEqConstr) {
        Ddi_Free(assumeEqVars);
        Ddi_Free(assumeEqSubst);
        assumeEqVars = Ddi_VararrayAlloc(ddm, 0);
        assumeEqSubst = Ddi_BddarrayAlloc(ddm, 0);
      }
      fixPoint =
        itpSequenceStep(delta, checkPart, init, cone, myInvar, ps, ns,
        psSubstLits, psLits, psNew, rPart, rPartB, assumeEqVars,
        assumeEqSubst, i, maxBound, seqGroup, seqSerial, seqReverse);
      Ddi_Free(assumeEqVars);
      Ddi_Free(assumeEqSubst);

    }

    Ddi_Free(firstFrame);

    endTime = util_cpu_time();

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(tMgrO(travMgr), "Time: func=%s, rel=%s.\n",
        util_print_time(currTime - startTime),
        util_print_time(endTime - currTime))
      );

    Ddi_Free(checkPart);
    Ddi_Free(check);

    /* build tr */
    /* compose TR - delta */
    VA2 = composeRelationalWithNewTimeFrameVars(myConePart, myInvar, ps,
      delta, pi, psIn, "PDT_ITPSEQ_REL_TF_PI", "PDT_ITPSEQ_REL_TF_PS", i, 1);
    pi2 = VA2[0];
    ps2 = VA2[1];
    Pdtutil_Free(VA2);

    if (timeFrameArrayNum >= timeFrameArraySize) {
      timeFrameArraySize *= 2;
      timeFramePiVars = Pdtutil_Realloc(Ddi_Vararray_t *,
        timeFramePiVars, timeFrameArraySize);
      timeFramePsVars = Pdtutil_Realloc(Ddi_Vararray_t *,
        timeFramePsVars, timeFrameArraySize);
    }
    timeFramePiVars[timeFrameArrayNum] = pi2;
    timeFramePsVars[timeFrameArrayNum] = ps2;
    timeFrameArrayNum++;

    if (0) {
      Ddi_Bddarray_t *newPsLits = Ddi_BddarrayMakeLiteralsAig(ps2, 1);
      Ddi_Bdd_t *myConstr = Ddi_BddCompose(myCone, ps, newPsLits);

      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c, fprintf(tMgrO(travMgr), "CI: ")
        );
      Ddi_AigPartPropImplications(myConePart, myConstr, 1);
      Ddi_Free(newPsLits);
      Ddi_Free(myConstr);
    }

    if (!doBmc) {
      VA2 = composeRelationalWithNewTimeFrameVars(myCone, myInvar, ps,
        delta, pi, psIn, "PDT_ITPSEQ_REL_TF_PI", "PDT_ITPSEQ_REL_TF_PS", i, 0);
      pi2 = VA2[0];
      ps2 = VA2[1];
      Pdtutil_Free(VA2);
      Ddi_Free(pi2);
      Ddi_Free(ps2);
    }

  }

  for (i = 0; i < timeFrameArrayNum; i++) {
    Ddi_Free(timeFramePiVars[i]);
    Ddi_Free(timeFramePsVars[i]);
  }

  Pdtutil_Free(timeFramePiVars);
  Pdtutil_Free(timeFramePsVars);

  Ddi_Free(assumeEqVars);
  Ddi_Free(assumeEqSubst);

  Ddi_Free(psIn);
  Ddi_Free(rPart);
  Ddi_Free(rPartB);
  Ddi_Free(myConePart);

  Ddi_Free(psNew);
  Ddi_Free(psLits);
  Ddi_Free(psSubstLits);
  Ddi_Free(invar);
  Ddi_Free(myCone);
  Ddi_Free(piv);
  Ddi_Free(psv);

  return (cex);
}



/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static int
itpSequenceStep(
  Ddi_Bddarray_t * delta,
  Ddi_Bdd_t * checkPart,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * cone0,
  Ddi_Bdd_t * invar,
  Ddi_Vararray_t * ps,
  Ddi_Vararray_t * ns,
  Ddi_Bddarray_t * psSubstLits,
  Ddi_Bddarray_t * psLits,
  Ddi_Vararray_t * psNew,
  Ddi_Bdd_t * rPart,
  Ddi_Bdd_t * rPartB,
  Ddi_Vararray_t * assumeEqVars,
  Ddi_Bddarray_t * assumeEqSubst,
  int i,
  int seqK,
  int seqGroup,
  float seqSerial,
  int reverse
)
{
  int sat = 0, jj, j, rTh, rThB;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(delta);
  Ddi_Bddarray_t *itpSeq, *itpSeqNs, *itpSeqEq = NULL;
  Ddi_Bdd_t *myC = Ddi_BddMakePartConjVoid(ddm);
  Ddi_Bddarray_t *nsLits = Ddi_BddarrayMakeLiteralsAig(ns, 1);
  Ddi_Bdd_t *tr = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t *target = Ddi_BddCompose(cone0, ps, nsLits);
  int fixPoint = 0, nCuts = 0;
  Ddi_Bdd_t *myInvar = invar;
  int nAppr = 0;
  int doFwd, doBwd;

  doFwd = rPart != NULL;
  doBwd = rPartB != NULL;

  rTh = rPart == NULL ? 0 : Ddi_BddSize(rPart) * 2;
  rThB = rPartB == NULL ? 0 : Ddi_BddSize(rPartB) * 2;
  if (rTh < 10000)
    rTh = 10000;
  if (rThB < 10000)
    rThB = 10000;

  for (j = 0; j < Ddi_BddarrayNum(delta); j++) {
    Ddi_Bdd_t *tr_j, *nsLit_j;

    nsLit_j = Ddi_BddarrayRead(nsLits, j);
    tr_j = Ddi_BddXnor(nsLit_j, Ddi_BddarrayRead(delta, j));
    Ddi_BddAndAcc(tr, tr_j);
    Ddi_Free(tr_j);
  }
  if (0 && invar != NULL) {
    Ddi_Bdd_t *invarNs = Ddi_BddCompose(invar, ps, nsLits);

    Ddi_BddAndAcc(tr, invarNs);
    Ddi_Free(invarNs);
  }

  for (jj = Ddi_BddPartNum(checkPart) - 1; jj >= 0; jj--) {
    Ddi_BddPartInsertLast(myC, Ddi_BddPartRead(checkPart, jj));
  }

  if (assumeEqVars != NULL) {
    /* apply equivalences coming from previous steps */
    /* compose all constrained vars with assumptions
       indirect equivalences (a->b->c) are directly handled in
       assumeEq->vars/assumeEq->subst arrays */
    Ddi_BddComposeAcc(myC, assumeEqVars, assumeEqSubst);
    itpSeqEq = Ddi_AigItpSeqEq(myC, assumeEqVars, assumeEqSubst, -1);
  }

  if (seqK > 1 && (Ddi_BddPartNum(myC) > seqK) && seqSerial > 0) {
    int kCut;
    int nC = Ddi_BddPartNum(myC);
    Ddi_Bdd_t *myC2 = Ddi_BddDup(myC);

    nAppr = nC * seqSerial;
    if (nAppr == 0)
      nAppr = 1;
    if (nAppr >= nC)
      nAppr = nC - 1;
    itpSeq = Ddi_BddarrayAlloc(ddm, 0);
    if (reverse) {
      for (jj = 0; jj < nC; jj++) {
        Ddi_Bdd_t *p_jj = Ddi_BddPartRead(myC, nC - jj - 1);

        Ddi_BddPartWrite(myC2, jj, p_jj);
      }
    }
    for (kCut = 1; kCut <= nAppr; kCut++) {
      Ddi_Bdd_t *is_k, *isEq_k = NULL;
      Ddi_Bddarray_t *itpSeq_1 = NULL;

      if (assumeEqVars != NULL) {
        /* apply equivalences coming from previous steps */
        /* compose all constrained vars with assumptions
           indirect equivalences (a->b->c) are directly handled in
           assumeEq->vars/assumeEq->subst arrays */
        Ddi_Bddarray_t *itpSeqEq_1 = NULL;

        itpSeqEq_1 = Ddi_AigItpSeqEq(myC2, assumeEqVars, assumeEqSubst, 1);
        isEq_k = Ddi_BddDup(Ddi_BddarrayRead(itpSeqEq_1, 0));
        Ddi_Free(itpSeqEq_1);
      }

      itpSeq_1 =
        Ddi_AigSatAndWithInterpolantSequence(myC2, NULL, &sat, 1, -1.0);

      if (sat)
        break;
      is_k = Ddi_BddarrayRead(itpSeq_1, 0);
      Ddi_BddPartRemove(myC2, 0);
      Ddi_BddAndAcc(Ddi_BddPartRead(myC2, 0), is_k);
      Pdtutil_Assert(!Ddi_AigSat(myC2), "Invalid ITP-S");
      Ddi_BddarrayInsertLast(itpSeq, is_k);
      if (isEq_k != NULL) {
        Ddi_BddAndAcc(Ddi_BddarrayRead(itpSeqEq, kCut - 1), isEq_k);
      }
      Ddi_Free(isEq_k);
      Ddi_Free(itpSeq_1);
    }
    Ddi_Free(myC2);
    if (reverse) {
      int np = Ddi_BddarrayNum(itpSeq);
      Ddi_Bddarray_t *itpSeq2 = Ddi_BddarrayAlloc(ddm, np);

      for (jj = 0; jj < np; jj++) {
        Ddi_Bdd_t *p_jj = Ddi_BddNot(Ddi_BddarrayRead(itpSeq, jj));

        Ddi_BddarrayWrite(itpSeq2, np - jj - 1, p_jj);
        Ddi_Free(p_jj);
      }
      Ddi_Free(itpSeq);
      itpSeq = itpSeq2;
    }
  } else {
    itpSeq =
      Ddi_AigSatAndWithInterpolantSequence(myC, NULL, &sat, nCuts, -1.0);
  }
  if (sat) {
    Ddi_Free(itpSeq);
    Ddi_Free(itpSeqEq);
  }
  if (!sat && itpSeq != NULL && nAppr > 0) {
    int j;
    Ddi_Bddarray_t *itpSeq2;
    Ddi_Bdd_t *myC2;
    int nC = Ddi_BddPartNum(myC);

    Pdtutil_Assert(Ddi_BddarrayNum(itpSeq) >= nAppr, "WRONG Seq");
    if (reverse) {
      myC2 = Ddi_BddNot(Ddi_BddarrayRead(itpSeq, 0));
    } else {
      myC2 = Ddi_BddDup(Ddi_BddarrayRead(itpSeq, nAppr - 1));
    }
    Ddi_BddSetPartConj(myC2);
    if (assumeEqVars != NULL) {
      Ddi_BddComposeAcc(myC, assumeEqVars, assumeEqSubst);
    }
    for (j = nAppr; j < nC; j++) {
      int ii = reverse ? nC - j - 1 : j;

      Ddi_BddPartInsertLast(myC2, Ddi_BddPartRead(myC, ii));
    }
    Ddi_Free(myC);
    myC = myC2;
    itpSeq2 =
      Ddi_AigSatAndWithInterpolantSequence(myC, NULL, &sat, nCuts, -1.0);
    for (j = 1; j < Ddi_BddarrayNum(itpSeq2); j++) {
      int ii = reverse ? 0 : nAppr + j - 1;

      if (reverse) {
        Ddi_BddarrayInsert(itpSeq, ii, Ddi_BddarrayRead(itpSeq2, j));
        Ddi_BddNotAcc(Ddi_BddarrayRead(itpSeq, ii));
      } else {
        Ddi_BddarrayWrite(itpSeq, ii, Ddi_BddarrayRead(itpSeq2, j));
      }
    }
    Ddi_Free(itpSeq2);
  }

  Ddi_Free(myC);
  if (!sat && itpSeq != NULL) {
    int np = Ddi_BddPartNum(checkPart);
    int nrp = Ddi_BddPartNum(doFwd ? rPart : rPartB);
    Ddi_Bdd_t *rAig = NULL, *rAigB = NULL;

    for (jj = 1; 0 && jj < Ddi_BddarrayNum(itpSeq); jj++) {
      Ddi_Bdd_t *seq_j0 = Ddi_BddarrayRead(itpSeq, jj - 1);
      Ddi_Bdd_t *seq_j = Ddi_BddarrayRead(itpSeq, jj);
      Ddi_Bdd_t *chk_tr_j = Ddi_BddPartRead(checkPart, np - 1 - jj);
      Ddi_Bdd_t *seq_j0_and_tr = Ddi_BddAnd(seq_j0, chk_tr_j);

      Pdtutil_Assert(Ddi_BddIncluded(seq_j0_and_tr, seq_j), "wrong chk Seq");
      Ddi_Free(seq_j0_and_tr);
    }

    Ddi_BddarrayComposeAcc(itpSeq, psNew, psSubstLits);
    if (itpSeqEq != NULL) {
      Ddi_BddarrayComposeAcc(itpSeqEq, psNew, psSubstLits);
      for (jj = 0; jj < Ddi_BddarrayNum(itpSeq); jj++) {
        Ddi_Bdd_t *seq_jj = Ddi_BddarrayRead(itpSeq, jj);
        Ddi_Bdd_t *seqEq_jj = Ddi_BddarrayRead(itpSeqEq, jj);

        Ddi_BddAndAcc(seq_jj, seqEq_jj);
      }
    }
    itpSeqNs = Ddi_BddarrayDup(itpSeq);
    Ddi_BddarrayComposeAcc(itpSeqNs, ps, nsLits);

    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c,
      fprintf(dMgrO(ddm), "ITP-SEQ [n:%d,tot: %d]: ",
        Ddi_BddarrayNum(itpSeq), Ddi_BddarraySize(itpSeq))
      );
    for (jj = 1; jj < Ddi_BddarrayNum(itpSeq); jj++) {
      Ddi_Bdd_t *seq_j0 = Ddi_BddarrayRead(itpSeq, jj - 1);
      Ddi_Bdd_t *seq_j = Ddi_BddarrayRead(itpSeqNs, jj);
      Ddi_Bdd_t *seq_j0_and_tr = Ddi_BddAnd(seq_j0, tr);

      if (myInvar != NULL) {
        Ddi_BddAndAcc(seq_j0_and_tr, myInvar);
      }

      if (jj == 1)
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(dMgrO(ddm), "(%d)", Ddi_BddSize(seq_j0))
          );
      Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
        Pdtutil_VerbLevelNone_c,
        fprintf(dMgrO(ddm), "(%d)", Ddi_BddSize(seq_j))
        );
      // Pdtutil_Assert(Ddi_BddIncluded(seq_j0_and_tr, seq_j),"wrong itp Seq");
      Ddi_Free(seq_j0_and_tr);
    }
    Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
      Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm), "\n")
      );

    Ddi_Free(itpSeqEq);

    rAig = Ddi_BddDup(init);
    rAigB =
      Ddi_BddDup(Ddi_BddPartRead(checkPart, Ddi_BddPartNum(checkPart) - 1));

    for (jj = 0; jj < nrp; jj++) {
      Ddi_Bdd_t *r_j;

      if (doFwd) {
        r_j = Ddi_BddPartRead(rPart, jj);
        if (Ddi_BddSize(r_j) > 5000) {
          ddiAbcOptAcc(r_j, -1.0);
        }
      }
      if (doBwd) {
        r_j = Ddi_BddPartRead(rPartB, jj);
        if (Ddi_BddSize(r_j) > 5000) {
          ddiAbcOptAcc(r_j, -1.0);
        }
      }
    }

    if (myInvar != NULL) {
      Ddi_BddAndAcc(tr, myInvar);
    }

    for (jj = 0; jj < Ddi_BddarrayNum(itpSeq); jj++) {
      int jjB = Ddi_BddarrayNum(itpSeq) - jj - 1;
      Ddi_Bdd_t *seq_j = Ddi_BddarrayRead(itpSeq, jj);
      Ddi_Bdd_t *seqB_j = Ddi_BddNot(Ddi_BddarrayRead(itpSeq, jjB));
      Ddi_Bdd_t *rAigNs = NULL, *seqBNs_j = NULL, *r_jj_and_tr = NULL,
        *f_jj = NULL, *fB_jj = NULL;
      int fixPoint2 = 0;

      if (doFwd) {
        if (jj >= Ddi_BddPartNum(rPart)) {
          Ddi_BddPartWrite(rPart, jj, seq_j);
        } else {
          Ddi_BddAndAcc(Ddi_BddPartRead(rPart, jj), seq_j);
        }
        f_jj = Ddi_BddPartRead(rPart, jj);
        Ddi_BddOrAcc(rAig, f_jj);
        if (Ddi_BddSize(rAig) > rTh) {
          ddiAbcOptAcc(rAig, -1.0);
          rTh = Ddi_BddSize(rAig) * 2;
        }
        //      fixPoint2 = Ddi_BddIncluded(f_jj,rAig);
        r_jj_and_tr = Ddi_BddAnd(f_jj, tr);
        // r_jj_and_tr = Ddi_BddAnd(rAig,tr);
        rAigNs = Ddi_BddCompose(rAig, ps, nsLits);
        fixPoint |= Ddi_BddIncluded(r_jj_and_tr, rAigNs);
      }
      if (doBwd) {
        if (jj >= Ddi_BddPartNum(rPartB)) {
          Ddi_BddPartWrite(rPartB, jj, seqB_j);
        } else {
          Ddi_BddAndAcc(Ddi_BddPartRead(rPartB, jj), seqB_j);
        }
        fB_jj = Ddi_BddPartRead(rPartB, jj);
        Ddi_BddOrAcc(rAigB, fB_jj);
        if (Ddi_BddSize(rAigB) > rThB) {
          ddiAbcOptAcc(rAigB, -1.0);
          rThB = Ddi_BddSize(rAigB) * 2;
        }
        seqBNs_j = Ddi_BddCompose(seqB_j, ps, nsLits);
        Ddi_BddAndAcc(seqBNs_j, tr);
        fixPoint2 |= Ddi_BddIncluded(seqBNs_j, rAigB);
      }
      if (fixPoint) {
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm), "FWD FIX-POINT.\n")
          );
      }
      if (fixPoint2) {
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm), "BWD FIX-POINT.\n")
          );
      }
      fixPoint |= fixPoint2;
      if (0 && fixPoint != fixPoint2) {
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(dMgrO(ddm), "DIFFERENT FIX-POINT CHECKS.\n")
          );
        fixPoint = fixPoint2;
      }
      if (doFwd & 1 && jj < np - 2) {
        Ddi_Bdd_t *cex;
        int error = 0;

        if (Ddi_AigSatAnd(r_jj_and_tr, target, NULL)) {
          Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
            Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm), "error.\n")
            );
          error = 1;
        }
        Ddi_BddDiffAcc(r_jj_and_tr, rAigNs);
        if (error) {
          cex = Ddi_AigSatWithCex(r_jj_and_tr);
          if (cex != NULL) {
            Ddi_Varset_t *nsVars = Ddi_VarsetMakeFromArray(ns);

            Ddi_BddSetMono(cex);
            //Ddi_BddExistProjectAcc(cex,nsVars);
            Ddi_Free(nsVars);
            DdiLogBdd(cex, 0);
          }
          Ddi_Free(cex);
        }
      }
      Ddi_Free(r_jj_and_tr);
      Ddi_Free(rAigNs);
      Ddi_Free(seqBNs_j);
      Ddi_Free(seqB_j);
      if (fixPoint) {
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c,
          fprintf(dMgrO(ddm),
            "ITP SEQ - FIXED POINT REACHED: BMC-k: %d - DEPTH: %d.\n",
            i + 1, jj)
          );
        break;
      }
    }

    Ddi_Free(rAig);
    Ddi_Free(rAigB);
    Ddi_Free(itpSeqNs);
    Ddi_Free(itpSeq);
  }

  Ddi_Free(nsLits);
  Ddi_Free(tr);
  Ddi_Free(target);
  return fixPoint;

}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static Ddi_Varset_t *
refineRelationalPartWithCex(
  Ddi_Bdd_t * checkPart,
  Ddi_Bdd_t * cex,
  Ddi_Varset_t * psIn,
  char *prefix,
  int cegar
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cex);
  Ddi_Varset_t *refinedPs = Ddi_VarsetVoid(ddm);
  Ddi_Bdd_t *cexPart = NULL;
  Ddi_Bddarray_t *cexArray = NULL;
  Ddi_Bdd_t *myOne = Ddi_BddMakeConstAig(ddm, 1);
  Ddi_Bdd_t *myZero = Ddi_BddMakeConstAig(ddm, 0);
  Ddi_Bdd_t *cexBdd = NULL;

  int i, n;
  int np = Ddi_BddPartNum(checkPart);

  Ddi_Vararray_t *vA;
  Ddi_Bddarray_t *vSubst;
  Ddi_Varset_t *s_0 = NULL, *sCommon = NULL;

  /* remove non free vars from cex */
  sCommon = Ddi_VarsetVoid(ddm);
  for (i = 0; i < np - 1; i++) {
    Ddi_Varset_t *s_i = Ddi_BddSupp(Ddi_BddPartRead(checkPart, i));

    if (i > 0) {
      Ddi_VarsetIntersectAcc(s_0, s_i);
      Ddi_VarsetUnionAcc(sCommon, s_0);
    }
    Ddi_Free(s_0);

    s_0 = s_i;
  }
  Ddi_Free(s_0);

  Ddi_BddSetMono(cex);
  Ddi_BddExistAcc(cex, sCommon);
  cexBdd = Ddi_BddDup(cex);
  Ddi_BddSetAig(cex);

  cexPart = Ddi_AigPartitionTop(cex, 0);
  cexArray = Ddi_BddarrayMakeFromBddPart(cexPart);
  n = Ddi_BddarrayNum(cexArray);
  vA = Ddi_VararrayAlloc(ddm, n);
  vSubst = Ddi_BddarrayAlloc(ddm, n);

  for (i = 0; i < n; i++) {
    Ddi_Bdd_t *p = Ddi_BddarrayRead(cexArray, i);
    Ddi_Var_t *v = Ddi_BddTopVar(p);

    Ddi_VararrayWrite(vA, i, v);
    if (Ddi_BddIsComplement(p)) {
      Ddi_BddarrayWrite(vSubst, i, myZero);
    } else {
      Ddi_BddarrayWrite(vSubst, i, myOne);
    }
  }

  for (i = 0; i < n; i++) {
    Ddi_Bdd_t *p = Ddi_BddarrayRead(cexArray, i);
    Ddi_Var_t *v = Ddi_BddTopVar(p);
    char *vname = Ddi_VarName(v);
    Ddi_Var_t *refV;
    int checkVar = 0;

    refV = Ddi_VarFindRefVar(v, prefix, '_');

    checkVar = refV != NULL && !Ddi_VarInVarset(psIn, refV)
      && !Ddi_VarInVarset(psIn, v);
    checkVar = checkVar
      && ((cegar == 1) ? !Ddi_VarInVarset(refinedPs,
        refV) : !Ddi_VarInVarset(refinedPs, v));
    if (checkVar) {
      Ddi_Bdd_t *res, *lit = Ddi_BddMakeLiteralAig(v, 1);

      Ddi_BddarrayWrite(vSubst, i, lit);
#if 0
      res = Ddi_BddCompose(checkPart, vA, vSubst);
      Ddi_BddNotAcc(Ddi_BddPartRead(res, 0));
#else
      res = Ddi_BddDup(checkPart);
      Ddi_BddNotAcc(Ddi_BddPartRead(res, 0));
#if 1
      {
        Ddi_Varset_t *sm = Ddi_VarsetMakeFromVar(v);
        Ddi_Bdd_t *cube = Ddi_BddExist(cexBdd, sm);
        Ddi_Bdd_t *pLast = Ddi_BddPartRead(res, Ddi_BddPartNum(res) - 1);
        int l;

        Ddi_BddSetAig(cube);
        Ddi_BddAndAcc(pLast, cube);
        Ddi_Free(cube);
        Ddi_Free(sm);
      }
#else
      {
        Ddi_Bdd_t *cube = Ddi_BddMakeConstAig(ddm, 1);
        Ddi_Bdd_t *pLast = Ddi_BddPartRead(res, Ddi_BddPartNum(res) - 1);
        int l;

        for (l = 0; l < Ddi_BddarrayNum(cexArray); l++) {
          if (l != i) {
            Ddi_BddAndAcc(cube, Ddi_BddarrayRead(cexArray, l));
          }
        }
        Ddi_BddAndAcc(pLast, cube);
        Ddi_Free(cube);
      }
#endif
#endif
      //      Ddi_BddSetAig(res);
      //      Ddi_BddSetMono(res);
      //      Ddi_BddExistAcc(res,sCommon);
      //      Ddi_BddSetAig(res);
      //      Ddi_BddNotAcc(Ddi_BddPartRead(res,0));
      if (Ddi_AigSat(res)) {
        Ddi_VarsetAddAcc(refinedPs, refV);
        if (cegar > 1) {
          Ddi_VarsetAddAcc(refinedPs, v);
        }
        if (Ddi_BddIsComplement(p)) {
          Ddi_BddarrayWrite(vSubst, i, myZero);
        } else {
          Ddi_BddarrayWrite(vSubst, i, myOne);
        }
      } else if (0) {
        Pdtutil_VerbosityLocal(Pdtutil_VerbLevelNone_c,
          Pdtutil_VerbLevelNone_c, fprintf(dMgrO(ddm), "UNSAT.\n")
          );
      }
      Ddi_Free(res);
      Ddi_Free(lit);

    }
  }

  Ddi_Free(sCommon);

  Ddi_Free(myOne);
  Ddi_Free(myZero);

  Ddi_Free(vA);
  Ddi_Free(vSubst);
  Ddi_Free(cexArray);
  Ddi_Free(cexPart);
  Ddi_Free(cexBdd);

  return refinedPs;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
InductiveImgPlus(
  Ddi_Bdd_t * from,
  Ddi_Bdd_t * inductiveTo
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(from);
  Ddi_Bdd_t *partTo = Ddi_AigPartitionTop(inductiveTo, 0);
  Ddi_Bdd_t *toPlus = NULL;

  if (Ddi_BddPartNum(partTo) > 1) {
    Ddi_Bdd_t *auxTo = Ddi_BddDup(partTo);
    int doRefineTo = 0;

    Ddi_BddNotAcc(auxTo);
    do {
      Ddi_Bdd_t *cex;
      Ddi_Bdd_t *chk = Ddi_BddMakeAig(auxTo);

      Ddi_BddAndAcc(chk, from);
      cex = Ddi_AigSatWithCex(chk);
      Ddi_Free(chk);
      doRefineTo = 0;
      if (cex != NULL) {
        int ii;

        for (ii = Ddi_BddPartNum(auxTo) - 1; ii >= 0; ii--) {
          Ddi_Bdd_t *p_i = Ddi_BddDup(Ddi_BddPartRead(auxTo, ii));

          if (Ddi_AigSatAnd(p_i, cex, NULL)) {
            Ddi_BddPartRemove(auxTo, ii);
            Ddi_BddPartRemove(partTo, ii);
          }
          Ddi_Free(p_i);
        }
        Ddi_Free(cex);
        doRefineTo = 1;
      }
    } while (doRefineTo);
    Ddi_Free(auxTo);
    if (toPlus == NULL) {
      toPlus = Ddi_BddMakeConstAig(ddm, 1);
    }
    Ddi_BddSetAig(partTo);
    Ddi_BddAndAcc(toPlus, partTo);
  }
  Ddi_Free(partTo);
  return toPlus;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
InductiveImgInf(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * toPlus,
  Ddi_Bdd_t * currRplus,
  Ddi_Bdd_t * tr,
  Ddi_Bdd_t * init,
  Ddi_Bdd_t * cone
)
{
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(toPlus);
  Ddi_Bdd_t *inductiveToPlus;
  int num0, num1, found = 1;
  int chkInd = 0;
  Ddi_Bdd_t *myFrom;
  Ddi_Bdd_t *newInductiveToPlus;
  Ddi_Bdd_t *newRplus = NULL;

  if (Ddi_BddSize(toPlus) <= 1) {
    return NULL;
  }

  inductiveToPlus = Ddi_AigPartitionTop(toPlus, 0);

  if (init != NULL) {
    /* gen init state constraint */
    myFrom = Ddi_BddDup(init);
    newInductiveToPlus = Ddi_AigInductiveImgPlus(myFrom,
      inductiveToPlus, currRplus, NULL, 2);
    Ddi_Free(inductiveToPlus);
    if (newInductiveToPlus == NULL || Ddi_BddIsOne(newInductiveToPlus)) {
      found = 0;
    } else {
      inductiveToPlus = Ddi_AigPartitionTop(newInductiveToPlus, 0);
    }
    Ddi_Free(newInductiveToPlus);
    Ddi_Free(myFrom);
  }

  if (found) {
    do {
      num0 = Ddi_BddPartNum(inductiveToPlus);
      if (num0 < 1) {
        found = 0;
        break;
      }
      myFrom = Ddi_BddCompose(inductiveToPlus, itpMgr->ns, itpMgr->psLit);
      Ddi_BddSetAig(myFrom);
      Ddi_BddAndAcc(myFrom, tr);
      newInductiveToPlus = Ddi_AigInductiveImgPlus(myFrom,
        inductiveToPlus, currRplus, NULL, 2);
      Ddi_Free(myFrom);
      if (newInductiveToPlus == NULL || Ddi_BddIsOne(newInductiveToPlus)) {
        found = 0;
        Ddi_Free(newInductiveToPlus);
        break;
      }
      Ddi_Free(inductiveToPlus);
      inductiveToPlus = Ddi_AigPartitionTop(newInductiveToPlus, 0);
      Ddi_Free(newInductiveToPlus);
      num1 = Ddi_BddPartNum(inductiveToPlus);
    } while (num1 < num0);
  }
  if (found) {
    printf("INF inductive components: %d, size %d\n", num1,
      Ddi_BddSize(inductiveToPlus));
    Ddi_BddSetAig(inductiveToPlus);
    if (newRplus == NULL) {
      newRplus = Ddi_BddDup(inductiveToPlus);
    } else {
      Ddi_BddAndAcc(newRplus, inductiveToPlus);
    }
    if (newRplus != NULL) {
      Ddi_Bdd_t *myRplus = Ddi_BddDup(newRplus);

      if (currRplus != NULL)
        Ddi_BddAndAcc(myRplus, currRplus);
      Ddi_Bdd_t *myFrom = Ddi_BddCompose(myRplus, itpMgr->ns, itpMgr->psLit);
      Ddi_Bdd_t *target = Ddi_BddNot(myRplus);

      Pdtutil_Assert(!chkInd || !Ddi_AigSatAnd(myFrom, tr, target),
        "error generating inductive components");
      Ddi_Free(myFrom);
      Ddi_Free(target);
      if (cone != NULL) {
        if (!Ddi_AigSatAnd(myRplus, cone, NULL)) {
          printf("PROPERTY INDUCTIVELY PROVED !!!\n");
          exit(1);
        }
      }
      Ddi_Free(myRplus);
    }
  }

  Ddi_Free(inductiveToPlus);
  return newRplus;
}

/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
bmcCoiFilter(
  Ddi_Bdd_t * f,
  Ddi_Bdd_t * filter,
  Ddi_Bdd_t * care,
  Ddi_Vararray_t * cutVars
)
{
  int sat, i;
  Ddi_Bdd_t *fRed;
  Ddi_Varset_t *supp;
  Ddi_Vararray_t *vars;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  bAig_Manager_t *bmgr = ddm->aig.mgr;

  Pdtutil_Assert(Ddi_BddIsPartConj(f), "conj part required");
  Pdtutil_Assert(Ddi_BddPartNum(f) == Ddi_VararrayNum(cutVars),
    "conj part an var num do not match");
  supp = Ddi_BddSupp(filter);
  vars = Ddi_VararrayMakeFromVarset(supp, 1);
  Ddi_Free(supp);
  for (i = 0; i < Ddi_VararrayNum(vars); i++) {
    Ddi_Var_t *v_i = Ddi_VararrayRead(vars, i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v_i);

    Pdtutil_Assert(bAig_AuxInt(bmgr, varIndex) == -1,
      "aux int field not clean");
    bAig_AuxInt(bmgr, varIndex) = 1;
  }
  fRed = Ddi_BddMakePartConjVoid(ddm);
  for (i = 0; i < Ddi_VararrayNum(cutVars); i++) {
    Ddi_Var_t *v_i = Ddi_VararrayRead(cutVars, i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v_i);

    if (bAig_AuxInt(bmgr, varIndex) > 0) {
      /* common var, take a component */
      Ddi_Bdd_t *f_i = Ddi_BddPartRead(f, i);

      Ddi_BddPartInsertLast(fRed, f_i);
    }
  }
  for (i = 0; i < Ddi_VararrayNum(vars); i++) {
    Ddi_Var_t *v_i = Ddi_VararrayRead(vars, i);
    bAigEdge_t varIndex = Ddi_VarToBaig(v_i);

    bAig_AuxInt(bmgr, varIndex) = -1;
  }
  Ddi_Free(vars);

  return fRed;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static Ddi_Bdd_t *
itpTfSplitCex(
  Trav_ItpMgr_t * itpMgr,
  Ddi_Bdd_t * cex,
  int maxTf
)
{
  int jj, ii, firstTfIndex = 0;
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(cex);
  Ddi_Bdd_t *returnedCex;

  // mark cex vars
  Ddi_Bdd_t *cexPart = Ddi_AigPartitionTop(cex, 0);
  Ddi_Vararray_t *ps = itpMgr->ps;

  if (maxTf < 0)
    maxTf = itpMgr->timeFrames->Num - 2;
  Pdtutil_Assert(maxTf < itpMgr->timeFrames->Num,
    "not enough time frame vars for cex");

  returnedCex = Ddi_BddMakePartConjVoid(ddm);
  for (jj = 0; jj < Ddi_BddPartNum(cexPart); jj++) {
    Ddi_Bdd_t *p = Ddi_BddPartRead(cexPart, jj);
    int isCompl = Ddi_BddIsComplement(p);

    Pdtutil_Assert(Ddi_BddSize(p) == 1, "Wrong partition cube");
    Ddi_VarWriteMark(Ddi_BddTopVar(p), isCompl ? -1 : 1);
  }
  Ddi_VararrayCheckMark(ps, 0);

  if (itpMgr->initStub != NULL) {
    Ddi_Vararray_t *isVars = Ddi_BddarraySuppVararray(itpMgr->initStub);
    Ddi_Bdd_t *tfCex = Ddi_BddMakeConstAig(ddm, 1);

    firstTfIndex = 1;
    for (ii = 0; ii < Ddi_VararrayNum(isVars); ii++) {
      Ddi_Var_t *v_ii = Ddi_VararrayRead(isVars, ii);

      if (Ddi_VarReadMark(v_ii) != 0) {
        Ddi_Bdd_t *lit =
          Ddi_BddMakeLiteralAig(v_ii, Ddi_VarReadMark(v_ii) == -1 ? 0 : 1);
        Ddi_BddAndAcc(tfCex, lit);
        Ddi_Free(lit);
      }
    }
    Ddi_BddPartInsertLast(returnedCex, tfCex);
    Ddi_Free(tfCex);
    Ddi_Free(isVars);
  }

  for (jj = firstTfIndex; jj <= maxTf; jj++) {
    Ddi_Bdd_t *tfCex = Ddi_BddMakeConstAig(ddm, 1);
    Ddi_Vararray_t *tfSuppA = itpMgr->timeFrames->PiVars[jj];

    for (ii = 0; ii < Ddi_VararrayNum(tfSuppA); ii++) {
      Ddi_Var_t *v_ii = Ddi_VararrayRead(tfSuppA, ii);

      if (Ddi_VarReadMark(v_ii) != 0) {
        Ddi_Bdd_t *lit =
          Ddi_BddMakeLiteralAig(v_ii, Ddi_VarReadMark(v_ii) == -1 ? 0 : 1);
        Ddi_BddAndAcc(tfCex, lit);
        Ddi_Free(lit);
      }
    }
    Ddi_BddPartInsertLast(returnedCex, tfCex);
    Ddi_Free(tfCex);
  }
  for (jj = 0; jj < Ddi_BddPartNum(cexPart); jj++) {
    Ddi_Bdd_t *p = Ddi_BddPartRead(cexPart, jj);

    Pdtutil_Assert(Ddi_BddSize(p) == 1, "Wrong partition cube");
    Ddi_VarWriteMark(Ddi_BddTopVar(p), 0);
  }
  Ddi_Free(cexPart);
  //  Ddi_BddPartInsertLast(returnedCex,cex);

  return returnedCex;
}


/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static int
itpOutOfLimits(
  Trav_ItpMgr_t * itpMgr
)
{

  if (itpMgr->time_limit > 0 && (util_cpu_time() > itpMgr->time_limit)) {
    Pdtutil_VerbosityMgrIf(itpMgr->travMgr, Pdtutil_VerbLevelUsrMed_c) {
      fprintf(tMgrO(itpMgr->travMgr), "Time limit reached.\n");
    }
    itpMgr->stats.itpOutOfLimits = 1;
    return 1;
  }
  if (itpMgr->peakAig_limit > 0 &&
    Ddi_MgrReadPeakAigNodesNum(itpMgr->ddiMgr) > itpMgr->peakAig_limit) {
    Pdtutil_VerbosityMgrIf(itpMgr->travMgr, Pdtutil_VerbLevelUsrMed_c) {
      fprintf(tMgrO(itpMgr->travMgr), "Peak Aig limit reached.\n");
    }
    itpMgr->stats.itpOutOfLimits = 2;
    return 1;
  }

  return 0;
}



/**Function********************************************************************
  Synopsis    []
  Description []
  SideEffects [None]
  SeeAlso     []
******************************************************************************/
static int
substStalledLatches(
  Trav_ItpMgr_t *itpMgr,
  Ddi_Bdd_t *f
)
{
  if (itpMgr->stalledVarsPs==NULL) return 0;
  int ns = Ddi_VararrayNum(itpMgr->stalledVarsPs);
  if (ns==0) return 0;
  int size0 = Ddi_BddSize(f);
  Ddi_BddSubstVarsAcc(f,itpMgr->stalledVarsPs,itpMgr->stalledVarsNs);
  Pdtutil_VerbosityMgrIf(itpMgr->travMgr, Pdtutil_VerbLevelUsrMed_c) {
    fprintf(tMgrO(itpMgr->travMgr),
	    "%d stalled latches handled - size: %d -> %d\n",
	    ns, size0, Ddi_BddSize(f));
  }
  return ns;
}


static Ddi_Bdd_t *
subsByOrSelectRecur(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *cex,
  int minPart
) {
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *resSubset;

  Ddi_Bdd_t *fConj = Ddi_AigPartitionTop(f, 0);
  resSubset = Ddi_BddMakePartConjVoid(ddm);
  for (int i=0; i<Ddi_BddPartNum(fConj); i++) {
    Ddi_Bdd_t *f_i = Ddi_BddPartRead(fConj,i);
    Ddi_Bdd_t *f_iDisj = Ddi_AigPartitionTop(f_i, 1);
    Ddi_BddPartSortBySizeAcc(f_iDisj, 1); // increasing size
    Ddi_Bdd_t *f_iDisjCof = Ddi_BddDup(f_iDisj);
    Ddi_AigConstrainCubeAcc(f_iDisjCof, cex);
    for (int j=0; j<Ddi_BddPartNum(f_iDisj); j++) {
      Ddi_Bdd_t *f_i_j = Ddi_BddPartRead(f_iDisj,j);
      Ddi_Bdd_t *cof = Ddi_BddPartRead(f_iDisjCof,j);
      int isOne = Ddi_BddIsOne(cof);
      if (isOne) {
        Ddi_BddPartInsertLast(resSubset,f_i_j);
        break;
      }
    }
    Ddi_Free(f_iDisjCof);
    Ddi_Free(f_iDisj);
  }
  Pdtutil_Assert(Ddi_BddPartNum(resSubset)>0,"missing part");
  Ddi_Free(fConj);

  Ddi_BddPartSortBySizeAcc(resSubset, 0); // decreasing size
  int nPart = Ddi_BddPartNum(resSubset);

  while (nPart<minPart) {
    int ratio = minPart/nPart+1;
    int nPart0 = nPart;
    int target = minPart-nPart;
    int done=0;
    for (int i=0; i<nPart && (target>0); i++) {
      Ddi_Bdd_t *r_i = Ddi_BddPartRead(resSubset,i);
      if (Ddi_BddSize(r_i)>10) {
        Ddi_Bdd_t *newr_i = subsByOrSelectRecur(r_i,cex,ratio);
        Ddi_DataCopy(r_i,newr_i);
        if (Ddi_BddPartNum(newr_i)>1) {
          target -= (Ddi_BddPartNum(newr_i)-1);
          done=1;
        }
        Ddi_Free(newr_i);
      }
    }
    Ddi_BddSetFlattened(resSubset);
    Ddi_BddPartSortBySizeAcc(resSubset, 0); // decreasing size
    Ddi_Bdd_t *filtered = Ddi_BddMakePartConjVoid(ddm);
    Ddi_BddPartInsertLast(filtered,Ddi_BddPartRead(resSubset,0));
    for (int i=1; i<Ddi_BddPartNum(resSubset); i++) {
      Ddi_Bdd_t *p_i0 = Ddi_BddPartRead(resSubset,i-1);
      Ddi_Bdd_t *p_i = Ddi_BddPartRead(resSubset,i);
      if (!Ddi_BddEqual(p_i,p_i0)) {
        Ddi_BddPartInsertLast(filtered,p_i);
      }
    }
    Ddi_DataCopy(resSubset,filtered);
    Ddi_Free(filtered);
    nPart = Ddi_BddPartNum(resSubset);
    if (!done) break;
    if (nPart<=nPart0) break;
  }
  
  return(resSubset);
}

static Ddi_Bddarray_t *
findOrTerms(
  Ddi_Bdd_t *f,
  int levels
) {
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bddarray_t *resPart;

  Ddi_Bdd_t *fConj = Ddi_AigPartitionTop(f, 0);
  resPart = Ddi_BddarrayAlloc(ddm,0);
  for (int i=0; i<Ddi_BddPartNum(fConj); i++) {
    Ddi_Bdd_t *f_i = Ddi_BddPartRead(fConj,i);
    Ddi_Bdd_t *f_iDisj = Ddi_AigPartitionTop(f_i, 1);
    Ddi_BddPartSortBySizeAcc(f_iDisj, 1); // increasing size
    int start = 0;
    if (Ddi_BddPartNum(f_iDisj)>3)
      start = Ddi_BddPartNum(f_iDisj)/2;
    for (int j=0; j<Ddi_BddPartNum(f_iDisj); j++) {
      Ddi_Bdd_t *f_i_j = Ddi_BddPartRead(f_iDisj,j);
      if (levels>1) {
        Ddi_Bddarray_t *newP = findOrTerms(f_i_j,levels-1);
        if (newP!=NULL)
          Ddi_BddarrayAppend(resPart,newP);
        Ddi_Free(newP);
      }
      else
        Ddi_BddarrayInsertLast(resPart,f_i_j);
    }
    Ddi_Free(f_iDisj);
  }
  Ddi_Free(fConj);
  if (Ddi_BddarrayNum(resPart)==0) {
    Ddi_Free(resPart);
    return NULL;
  }
  Ddi_BddarraySortBySizeAcc(resPart, 0);    // decreasing size	
  int n = Ddi_BddarrayNum(resPart);
  while(Ddi_BddarrayNum(resPart)>n/2)
    Ddi_BddarrayRemove(resPart,Ddi_BddarrayNum(resPart)-1);
  return(resPart);
}

static Ddi_Bdd_t *
subsByOrSelect(
  Ddi_Bdd_t *f,
  Ddi_Bdd_t *cex,
  int minPart
) {
  Ddi_Mgr_t *ddm = Ddi_ReadMgr(f);
  Ddi_Bdd_t *cexPart = Ddi_AigPartitionTop(cex,0);
  Ddi_Bdd_t *fNew = subsByOrSelectRecur(f,cexPart,minPart);
  int np = Ddi_BddPartNum(fNew);
  Ddi_BddSetAig(fNew);
  Pdtutil_VerbosityMgrIf(ddm, Pdtutil_VerbLevelUsrMax_c) {
    fprintf(dMgrO(ddm),"Subsetting by Or Select - size %d -> %d (%d partitions)\n", 
            Ddi_BddSize(f), Ddi_BddSize(fNew), np);
  }
  Ddi_Free(cexPart);
  return fNew;
}
